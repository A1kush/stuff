<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>A1K Runner — Fix v2 (wave/boss/inventory/beam)</title>
<style>
  :root{
    --bg:#0d131c;--ink:#e9f4ff;--muted:#a8b7ce;--line:#293854;
    --panel:#121b20;--panel2:#0f1826;--panel3:#0b1421;
    --hp:#36c777;--hp2:#6de38e;--mp:#3ec5ff;--mp2:#6aa8ff;
    --boss:#ff8c6a;--boss2:#ffbb9a;--rage:#f9cc2b;--rage2:#ff7a31;
  }
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font:14px/1.4 system-ui,Segoe UI,Roboto,Arial,sans-serif}
  *{box-sizing:border-box}
  #wrap{position:relative;margin:0 auto;max-width:1280px;height:100vh;overflow:hidden;border-left:1px solid var(--line);border-right:1px solid var(--line)}
  canvas{display:block;image-rendering:pixelated;image-rendering:crisp-edges;background:linear-gradient(#0c1420,#0a1018);}

  /* HUD */
  .hud{position:absolute;left:10px;right:10px;top:8px;display:flex;gap:10px;align-items:center;pointer-events:none;flex-wrap:wrap}
  .pill{pointer-events:auto;background:var(--panel);border:1px solid var(--line);border-radius:10px;padding:6px 10px;font-size:12px;color:var(--muted)}
  .bar{position:relative;height:12px;background:var(--panel);border:1px solid var(--line);border-radius:999px;overflow:hidden;min-width:200px}
  .fill{position:absolute;inset:0;transform-origin:left center}
  .hp{background:linear-gradient(90deg,var(--hp),var(--hp2))}
  .mp{background:linear-gradient(90deg,var(--mp),var(--mp2))}
  .boss{background:linear-gradient(90deg,var(--boss),var(--boss2))}

  /* Dock */
  /*
   * Position the top dock lower so it doesn't overlap the stage/kills bar or currency.  This
   * change moves the row of buttons (speed, inventory, auto, pause, shop, settings) down,
   * leaving more vertical breathing room under the stage/wave/kills and currency bars.  See
   * the updated top value below.  Note: currency positioning remains inline on the element.
   */
  .subdock{position:absolute;left:10px;top:70px;display:flex;gap:8px;pointer-events:auto;flex-wrap:wrap}
  .btn{background:var(--panel2);border:1px solid var(--line);color:var(--ink);border-radius:10px;padding:6px 10px;cursor:pointer}
  .btn:active{transform:translateY(1px)}

  /* Drawers */
  .drawer{position:absolute;top:70px;bottom:70px;width:420px;background:var(--panel);border:1px solid var(--line);box-shadow:0 12px 28px rgba(0,0,0,.35);display:none;border-radius:12px}
  .drawer .in{padding:10px;overflow:auto;max-height:calc(100% - 42px)}
  .drawer h3{margin:0;padding:10px 12px;border-bottom:1px solid var(--line)}
  #inventory{right:10px} #shop{left:10px} #settings{left:50%;transform:translateX(-50%);max-width:92%;width:580px}
  .card{background:#0f1826;border:1px solid var(--line);border-radius:10px;padding:10px;margin:10px 0}
  .muted{color:var(--muted)}

  /* Inventory grid & equipment slots */
  .slots{display:grid;grid-template-columns:repeat(5,1fr);gap:8px}
  .slot{height:60px;border:1px dashed #41506a;border-radius:10px;background:#0c1826;display:flex;align-items:center;justify-content:center;color:#a8c0e0;cursor:pointer}
  .slot.pet{outline:2px solid #5bd2b2}
  .slot.equip{background:#0e1a2a;border-style:solid}
  .slot:hover{filter:brightness(1.06)}

  /* Controls */
  .controls{position:absolute;left:10px;right:10px;bottom:10px;display:flex;align-items:flex-end;justify-content:space-between;pointer-events:none}
  .stick{position:relative;width:140px;height:140px;border-radius:50%;background:radial-gradient(circle at 50% 50%, #111b2a 0%, #0c1420 60%, #0c1420 100%);border:1px solid var(--line);box-shadow:inset 0 0 18px rgba(0,0,0,.55);pointer-events:auto}
  .stick .nub{position:absolute;left:50%;top:50%;width:64px;height:64px;margin:-32px 0 0 -32px;border-radius:50%;background:radial-gradient(circle at 35% 35%, #29384f, #1b2639);border:1px solid #3b4d71;box-shadow:0 2px 6px rgba(0,0,0,.35)}
  .joyWrap{position:relative;display:flex;flex-direction:column;align-items:flex-start;}
  .char-buttons{position:absolute;bottom:100%;left:0;display:flex;gap:8px;margin-bottom:6px;}
  .char-buttons .charBtn{width:42px;height:42px;border-radius:50%;background:radial-gradient(circle at 40% 35%, #2a384f, #182235);border:1px solid var(--line);box-shadow:0 2px 6px rgba(0,0,0,.35);color:#dfe9ff;display:flex;align-items:center;justify-content:center;user-select:none;cursor:pointer;font-size:12px;font-weight:600;}
  .char-buttons .charBtn.active{background:radial-gradient(circle at 40% 35%, #334868, #25354d);box-shadow:0 3px 10px rgba(0,0,0,.45);}

  .actions{position:relative;display:flex;gap:22px;pointer-events:auto;align-items:flex-end}
  .col{display:flex;flex-direction:column;gap:16px;align-items:flex-end}
  .btn-round{width:64px;height:64px;border-radius:50%;background:radial-gradient(circle at 40% 35%, #2a384f, #182235);border:1px solid var(--line);box-shadow:0 3px 12px rgba(0,0,0,.35);color:#dfe9ff;display:flex;align-items:center;justify-content:center;user-select:none;cursor:pointer}
  .btn-round.small{width:56px;height:56px;font-size:11px}
  .btn-round.big{width:86px;height:86px;font-weight:700}
  .btn-round:active{transform:translateY(1px)}
  .btn-round.ready{box-shadow:0 0 14px 2px rgba(255,213,106,.8);border-color:#ffd56a;}

  /* Drawer close button */
  .drawer-close{
    position:absolute;
    top:6px;
    right:8px;
    width:20px;
    height:20px;
    border:0;
    background:transparent;
    color:var(--muted);
    font-size:16px;
    line-height:20px;
    cursor:pointer;
    pointer-events:auto;
  }
  .drawer-close:hover{color:var(--ink);}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="cv" width="1280" height="720"></canvas>

  <!-- HUD -->
  <div class="hud">
    <div class="pill" id="stagePill">Stage 1 • Wave 1/10 • Kills 0</div>
    <div class="bar"><div class="fill hp" id="hpFill" style="transform:scaleX(1)"></div></div>
    <div class="bar"><div class="fill mp" id="mpFill" style="transform:scaleX(1)"></div></div>
    <div class="bar" style="min-width:320px"><div class="fill boss" id="bossFill" style="transform: scaleX(0);"></div></div>
  </div>
    <div id="currency" class="hud" style="top:30px;gap:8px;justify-content:flex-start;pointer-events:none;">
      <div class="pill" style="pointer-events:auto">Gold: <b id="goldVal">0</b></div>
      <div class="pill" style="pointer-events:auto">Silver: <b id="silverVal">0</b></div>
      <div class="pill" style="pointer-events:auto">Tickets: <b id="ticketVal">0</b></div>
      <div class="pill" style="pointer-events:auto">Gems: <b id="gemVal">0</b></div>
    </div>

  <!-- Dock -->
  <div class="subdock">
    <button class="btn" id="btnSpeed">×1</button>
    <button class="btn" id="btnInventory">Inventory</button>
    <button class="btn" id="btnAuto">Auto: ON</button>
    <button class="btn" id="btnStart">Pause</button>
    <button class="btn" id="btnShop">Shop</button>
    <button class="btn" id="btnSettings">Settings</button>
    <button class="btn" id="btnTalents">Talents</button>
  </div>

  <!-- Inventory Drawer -->
  <aside id="inventory" class="drawer">
    <h3>Inventory (32 slots) + Equipment<button class="drawer-close" aria-label="Close">×</button></h3>
    <div class="in">
      <div class="card">
        <b>Equipment</b>
        <div id="equip" class="slots" style="grid-template-columns:repeat(5,1fr)">
          <div class="slot equip" data-slot="weapon">Weapon</div>
          <div class="slot equip" data-slot="armor">Armor</div>
          <div class="slot equip" data-slot="acc1">Accessory 1</div>
          <div class="slot equip" data-slot="acc2">Accessory 2</div>
          <div class="slot equip pet" data-slot="pet">Pet</div>
        </div>
      </div>
      <div class="card">
        <b>Bag</b>
        <div id="invGrid" class="slots" style="grid-template-columns:repeat(8,1fr)"></div>
      </div>
    </div>
  </aside>

  <!-- Shop & Settings (same as before, brief for patch) -->
  <aside id="shop" class="drawer">
    <h3>Shop<button class="drawer-close" aria-label="Close">×</button></h3>
    <div class="in">
      <div class="card"><b>+Damage (All)</b> — 100 Gold <button class="btn" id="buyDmg">Buy</button></div>
      <div class="card"><b>+Fire Rate (All)</b> — 100 Gold <button class="btn" id="buyRoF">Buy</button></div>
      <div class="card"><b>Potion +50 HP</b> — 50 Gold <button class="btn" id="buyHP">Buy</button></div>
      <div class="card"><b>Rage Pill</b> — 80 Gold <button class="btn" id="buyRage">Buy</button></div>

      <!-- Boosters -->
      <div class="card"><b>XP Booster (15m)</b> — +30% XP <span class="muted">1500G / 30T</span> <button class="btn" id="buyXP">Buy</button></div>
      <div class="card"><b>Drop Booster (15m)</b> — +25% Drops <span class="muted">500G / 10T</span> <button class="btn" id="buyDrop">Buy</button></div>
      <div class="card"><b>Rage Starter</b> — Start next stage with full Rage <span class="muted">2000G / 45T</span> <button class="btn" id="buyRageStart">Buy</button></div>
      <div class="card"><b>Magnet Aura (30m)</b> — Big pickup radius <span class="muted">20G</span> <button class="btn" id="buyMagnet">Buy</button></div>

      <!-- Consumables & Tokens -->
      <div class="card"><b>Revive Token</b> — Continue once at 40% HP <span class="muted">60G / 5T</span> <button class="btn" id="buyRevive">Buy</button></div>
      <div class="card"><b>Random Gear Kit</b> — 4 random gear <span class="muted">200G</span> <button class="btn" id="buyGearKit">Buy</button></div>
      <div class="card"><b>Respect Token</b> — Refund all AP <span class="muted">200G / 20T</span> <button class="btn" id="buyRespect">Buy</button></div>
      <div class="card"><b>Boss Pass</b> — Skip to next boss (if cleared) <span class="muted">1000G / 20T</span> <button class="btn" id="buyBossPass">Buy</button></div>

      <!-- Upgrades -->
      <div class="card"><b>Inventory Row +1</b> — Adds 8 bag slots <span class="muted">2.5kG</span> <button class="btn" id="buyInvRow">Buy</button></div>
      <div class="card"><b>Loadout Slot +1</b> — Extra loadout page <span class="muted">120T</span> <button class="btn" id="buyLoadout">Buy</button></div>
      <div class="card"><b>Pet Slot +1</b> — Equip extra pet <span class="muted">500G / 180T</span> <button class="btn" id="buyPetSlot">Buy</button></div>
      <div class="card"><b>Forge Permit I</b> — Unlock +5 upgrade <span class="muted">1000G</span> <button class="btn" id="buyForge1">Buy</button></div>
      <div class="card"><b>Forge Permit II</b> — Unlock +10 upgrade <span class="muted">2000G</span> <button class="btn" id="buyForge2">Buy</button></div>
      <div class="card"><b>Forge Permit III</b> — Unlock +15 upgrade <span class="muted">3000G</span> <button class="btn" id="buyForge3">Buy</button></div>

      <!-- Gear & Craft -->
      <div class="card"><b>Weapon Cache</b> — Choose 1 of 3 weapons <span class="muted">1000G</span> <button class="btn" id="buyWCache">Buy</button></div>
      <div class="card"><b>Armor Cache</b> — Choose 1 of 3 armors <span class="muted">1000G</span> <button class="btn" id="buyACache">Buy</button></div>
      <div class="card"><b>Accessory Cache</b> — Choose 1 of 3 accessories <span class="muted">1000G</span> <button class="btn" id="buyAccCache">Buy</button></div>

      <!-- Keys & Chests -->
      <div class="card"><b>Gift Key</b> — Opens Gift Chest <span class="muted">500G / 25T</span> <button class="btn" id="buyGiftKey">Buy</button></div>
      <div class="card"><b>Boss Key</b> — Opens Boss Chest <span class="muted">3kG / 30T</span> <button class="btn" id="buyBossKey">Buy</button></div>

      <!-- Bundles -->
      <div class="card"><b>Starter Pack</b> — 2 Gift Keys + Magnet Aura (10m) <span class="muted">FREE</span> <button class="btn" id="buyBundleStarter">Claim</button></div>
      <div class="card"><b>Booster Pack</b> — 5 Gift Keys + XP & Drop Boosters ×3 <span class="muted">500G / 50T</span> <button class="btn" id="buyBundleBooster">Buy</button></div>
      <div class="card"><b>Founder Pack</b> — Loadout slot + cosmetic <span class="muted">100T</span> <button class="btn" id="buyBundleFounder">Buy</button></div>
    </div>
  </aside>
  <aside id="settings" class="drawer">
    <h3>Settings<button class="drawer-close" aria-label="Close">×</button></h3>
    <div class="in">
      <div class="card">
        <label><input type="checkbox" id="optAuto" checked> Auto‑AI</label>
        <div style="margin-top:8px">Canvas Size: <select id="optSize">
          <option value="1">100%</option><option value="1.25">125%</option><option value="1.5">150%</option><option value="2">200%</option>
        </select></div>
        <label style="display:block;margin-top:6px"><input type="checkbox" id="optPar" checked> Parallax</label>
      </div>

      <!-- Sprite loader status card: lists which optional assets loaded or fell back to proxies.  Populated by loadAssets(). -->
      <div class="card">
        <b>Sprite Loader Status:</b>
        <div id="loaderStatus" class="muted" style="font-size:12px;margin-top:4px;white-space:pre-wrap;"></div>
      </div>
    </div>
  </aside>

  <!-- Talents Drawer -->
  <aside id="talents" class="drawer">
    <h3>Talents<button class="drawer-close" aria-label="Close">×</button></h3>
    <div class="in">
      <canvas id="talentCanvas" width="800" height="440" style="image-rendering:pixelated;width:100%;background:var(--panel3);border:1px solid var(--line);border-radius:10px;"></canvas>
      <div class="muted" style="margin-top:8px">Spend AP to unlock nodes. Keystone: <b>Rage II</b>. Press T to toggle.</div>
    </div>
  </aside>

  <!-- Controls -->
  <div class="controls">
    <div class="joyWrap">
      <div class="char-buttons">
        <div class="charBtn active" id="btnCharA">A</div>
        <div class="charBtn" id="btnCharU">U</div>
        <div class="charBtn" id="btnCharM">M</div>
      </div>
      <div class="stick" id="stick"><div class="nub" id="nub"></div></div>
    </div>
    <div class="actions">
      <div class="col">
        <div class="btn-round small" id="btnRage">R</div>
        <div class="btn-round small" id="btnShield">Shield</div>
        <div class="btn-round small" id="btnJump">Jump</div>
        <div class="btn-round big" id="btnShoot"><b>•</b></div>
      </div>
      <div class="col">
        <div class="btn-round small" id="btnS1">S1</div>
        <div class="btn-round small" id="btnS2">S2</div>
        <div class="btn-round small" id="btnS3">S3</div>
      </div>
    </div>
  </div>
</div>

<script>
const DESIGN_W=1280, DESIGN_H=720;
const wrap=document.getElementById('wrap'); const cv=document.getElementById('cv'); let ctx=cv.getContext('2d');

// === PATCH v3 CONFIG ===
// Configuration for stage/wave sizing, global slowdowns, combat tweaks, controls and UI.
const PATCH = {
  meta: { wavesPerStage: 10, totalStages: 10 },
  systems: {
    enemyMoveScale: 0.75,        // 25% slower movement
    enemyFireRateScale: 0.75,    // 25% slower firing (longer cooldown)
    jump: { v0: -0.28 },         // jump impulse source of truth
    rage: { max: 100, gainOnDealt: 1/15, gainOnTaken: 1/20, gainOnGift: 10 },
    talents: {
      perPoint: { atk: 100, def: 100, hp: 100 },
      cap: 30
    }
  },
  waves: {
    sizes: [
      { stage:1,  min:10, max:20 }, { stage:2,  min:20, max:25 },
      { stage:3,  min:20, max:30 }, { stage:4,  min:25, max:35 },
      { stage:5,  min:30, max:40 }, { stage:6,  min:30, max:45 },
      { stage:7,  min:35, max:45 }, { stage:8,  min:35, max:50 },
      { stage:9,  min:40, max:55 }, { stage:10, min:45, max:60 }
    ],
    miniboss:    { waveMin:5, waveMax:7, chance:0.40 },
    giftBoxBoss: { waveMin:2, waveMax:9, chance:0.35 }
  },
  loot: {
    perEnemy: { gold:[20,100], silver:[30,1000], giftChance:0.10, gearChance:0.15 },
    giftBoxBoss: {
      perHit: { gold:[5,15], silver:[20,60], gearChance:0.05 },
      kill: { expMultiplier:3.0, gearRankWeights:{ S:0.20, A:0.35, B:0.30, C:0.15 } }
    }
  },
  combat: {
    reflect: {
      playerMelee: { enabledFor:['A1','Missy'], activeMs:[0,350], dmgMul:1.2 },
      boss: { windowSec:0.6, cooldownSec:4.0, maxBullets:12 }
    },
    boss: { preferredDistance:260, summon:{ count:2, cooldownSec:6.0, maxAlive:6 } }
  },
  controls: { leaderKeys: { A1:'KeyA', Unique:'KeyU', Missy:'KeyM' } },
  ui: { showRageAboveNonLeaders:true }
};
// === END PATCH v3 CONFIG ===

/* ===== Asset Loader ===== */
// Basic asset loader that attempts to load optional sprites (PNG/GIF) for
// players and backgrounds.  Results are stored in the `assets` map and
// status strings are appended to `assetStatus`.  The loader tries each
// path in order and falls back to null (proxy) on failure.  A summary
// of loaded assets is displayed in the Settings drawer under
// "Sprite Loader Status:" once all attempts complete.
const assets = {};
const assetStatus = [];
function loadAssets(){
  const items = [
    {key:'A1', paths:['A1.png']},
    {key:'Unique', paths:['Unique.png']},
    {key:'Missy', paths:['Missy.png']},
    {key:'BG_mid', paths:['BG_mid.gif','BG_mid.png']},
    {key:'BG_ground', paths:['BG_ground.gif','BG_ground.png']},
    // you can add more assets here as needed (e.g. bgm.mp3)
  ];
  let pending = items.length;
  function done(){
    if(--pending===0){ updateLoaderStatus(); }
  }
  items.forEach(item=>{
    let loaded=false;
    function tryPath(i){
      if(i>=item.paths.length){
        assetStatus.push(`${item.key}: proxy`);
        assets[item.key] = null;
        done();
        return;
      }
      const img = new Image();
      img.onload = function(){
        loaded=true;
        assetStatus.push(`${item.key}: ${item.paths[i]}`);
        assets[item.key] = img;
        done();
      };
      img.onerror = function(){
        // try next path
        tryPath(i+1);
      };
      img.src = item.paths[i];
    }
    tryPath(0);
  });
}
function updateLoaderStatus(){
  const el = document.getElementById('loaderStatus');
  if(el){
    el.textContent = assetStatus.join(', ');
  }
}

// store clickable rectangles for non-leader skill icons
let nonSkillRects = [];
function resize(){
  const scale=Math.min(innerWidth/DESIGN_W, innerHeight/DESIGN_H);
  const cssW=DESIGN_W*scale, cssH=DESIGN_H*scale;
  Object.assign(cv.style,{width:cssW+'px',height:cssH+'px',position:'absolute',left:((innerWidth-cssW)/2)+'px',top:((innerHeight-cssH)/2)+'px'});
  const dpr=Math.min(devicePixelRatio||1,2); cv.width=Math.round(DESIGN_W*dpr); cv.height=Math.round(DESIGN_H*dpr);
  ctx=cv.getContext('2d'); ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener('resize',resize); resize();

/* ===== State ===== */
const st={
  time:0, dt:0, running:true, speed:1, started:false,
  stage:1, wave:1, wavesPerStage: PATCH.meta.wavesPerStage, kills:0,
  gold:0, silver:0, tickets:0, gems:0,
  hp:100, hpMax:100, mp:100, mpMax:100, mpRegen:8,
  // rage and rageMax derive from PATCH.systems.rage.max
  rage:0, rageMax: PATCH.systems.rage.max, rageOn:false, rageDur:0, rageICD:0,
  auto:false, useParallax:true,
  waveClearDelay:800, waveClearT:0,
  players:[
    {id:'A1',x:220,y:DESIGN_H-160,vx:0,vy:0,grounded:true, dmg:20, alive:true, lane:0, overT:0, overCD:0},
    {id:'Unique',x:260,y:DESIGN_H-130,vx:0,vy:0,grounded:true,dmg:18, alive:true, lane:1, overT:0, overCD:0},
    {id:'Missy',x:240,y:DESIGN_H-100,vx:0,vy:0,grounded:true,dmg:18, alive:true, lane:2, overT:0, overCD:0}
  ],
  leader:0, lastSwap:0,
  shots:[], eShots:[], enemies:[], pickups:[], effects:[],
  bossHP:0, bossMax:1, bossAlive:false, chestBoss:false,
  cds:{'A1':{S1:0,S2:0,S3:0}, 'Unique':{S1:0,S2:0,S3:0}, 'Missy':{S1:0,S2:0,S3:0}},

  // Progression & talents
  level:1,
  xp:0,
  apTotal:0,
  apSpent:0,
  apPicks: new Set(),
  rageTier:1,
  // auto skill management
  _autoNextSkill:0,
  _autoSkillIdx:0,
  // parry timer for reflect
  parryT:0,

  // Booster and power‑up timers and counts
  xpBoost:0,           // XP gain multiplier (e.g. 0.3 for +30%)
  xpBoostT:0,          // XP booster remaining time (ms)
  dropBoost:0,         // Drop chance multiplier (e.g. 0.25 for +25%)
  dropBoostT:0,
  magnetAuraT:0,       // Magnet aura remaining time (ms)
  reviveTokens:0,      // number of revive tokens
  giftKeys:0,
  bossKeys:0,
  pityCount:0,
  bossSkipPasses:0,
  nextStageRageStart:false,
  invRows:4,
  invRowCost:2500,
  loadoutSlots:1,
  petSlots:1,
  forgeLevel:0,
  bundleStarter:false,
  bundleBooster:false,
  bundleFounder:false,
};
// number of unique bosses.  Stages beyond this reuse the last boss pattern.
const BOSS_COUNT = 4;
const SPEEDS=[1,2,3,4,6];
function rng(){return Math.random();}
const $=q=>document.querySelector(q);

/* ===== UI wiring ===== */
$('#btnInventory').onclick=()=>toggle('#inventory');
$('#btnShop').onclick=()=>toggle('#shop');
$('#btnSettings').onclick=()=>toggle('#settings');
$('#btnAuto').onclick=()=>{ st.auto=!st.auto; $('#btnAuto').textContent='Auto: '+(st.auto?'ON':'OFF'); };
$('#btnStart').onclick=()=>{ st.running=!st.running; $('#btnStart').textContent=st.running?'Pause':'Start'; };
$('#btnSpeed').onclick=()=>{ const i=SPEEDS.indexOf(st.speed); st.speed=SPEEDS[(i+1)%SPEEDS.length]; $('#btnSpeed').textContent='×'+st.speed; };

function toggle(sel){ const e=$(sel); e.style.display=e.style.display==='block'?'none':'block'; }
function updateCharBtns(){ ['A','U','M'].forEach((c,i)=>document.getElementById('btnChar'+c).classList.toggle('active',st.leader===i)); }
document.getElementById('btnCharA').onclick=()=>{ st.leader=0; updateCharBtns(); };
document.getElementById('btnCharU').onclick=()=>{ st.leader=1; updateCharBtns(); };
document.getElementById('btnCharM').onclick=()=>{ st.leader=2; updateCharBtns(); };

// Close button for drawers
document.querySelectorAll('.drawer .drawer-close').forEach(btn=>{
  btn.addEventListener('click', e=>{
    e.stopPropagation();
    const d = btn.closest('.drawer');
    if(d) d.style.display = 'none';
  });
});

// Toggle talents drawer via button or T key
$('#btnTalents').onclick = () => toggle('#talents');
addEventListener('keydown', e => { if(e.code === 'KeyT') toggle('#talents'); });

/* ===== Talents UI & logic ===== */
const talentCanvas = document.getElementById('talentCanvas');
let talentCtx;
if(talentCanvas){ talentCtx = talentCanvas.getContext('2d'); }

// define a simple talents tree: attack%, shield, and Rage II keystone
const talents = [
  {id:'atk1', x:120, y:340, cost:1, req:[], text:'+5% ATK', fx:(s)=>{ s.atkMul+=0.05; }},
  {id:'atk2', x:220, y:280, cost:1, req:['atk1'], text:'+5% ATK', fx:(s)=>{ s.atkMul+=0.05; }},
  {id:'atk3', x:320, y:220, cost:1, req:['atk2'], text:'+5% ATK', fx:(s)=>{ s.atkMul+=0.05; }},
  {id:'shield1', x:520, y:340, cost:1, req:[], text:'+10 Shield', fx:(s)=>{ s.shield+=10; }},
  {id:'shield2', x:620, y:280, cost:1, req:['shield1'], text:'+10 Shield', fx:(s)=>{ s.shield+=10; }},
  {id:'crit1', x:320, y:340, cost:1, req:[], text:'+2% Crit', fx:(s)=>{ s.crit=(s.crit||0)+2; }},
  {id:'move1', x:420, y:280, cost:1, req:[], text:'+5% Move', fx:(s)=>{ s.move=(s.move||0)+5; }},
  {id:'skillHaste1', x:720, y:340, cost:1, req:[], text:'+5% Haste', fx:(s)=>{ s.haste=(s.haste||0)+5; }},
  {id:'rage2', x:420, y:160, cost:3, req:['atk3','shield2'], keystone:true, text:'Rage II', fx:(s)=>{ st.rageTier=2; }}
];

function tallyTalentStats(){
  const s = {atkMul:0, shield:0, crit:0, move:0, haste:0};
  // reset rage tier
  st.rageTier = 1;
  for(const t of talents){
    if(st.apPicks.has(t.id) && t.fx){ t.fx(s); }
  }
  st._talentStats = s;
  recalcStats();
}

function drawTalents(){
  if(!talentCtx) return;
  const ctx2 = talentCtx;
  ctx2.clearRect(0,0,talentCanvas.width, talentCanvas.height);
  // connectors
  ctx2.strokeStyle = '#2a3b58'; ctx2.lineWidth = 2; ctx2.beginPath();
  const idMap = Object.fromEntries(talents.map(t => [t.id, t]));
  talents.forEach(n => {
    if(n.req){ n.req.forEach(rid => { const a=idMap[rid]; if(a){ ctx2.moveTo(a.x,a.y); ctx2.lineTo(n.x,n.y); } }); }
  });
  ctx2.stroke();
  // nodes
  talents.forEach(n => {
    const owned = st.apPicks.has(n.id);
    const canBuy = !owned && (st.apSpent < Math.min(30, st.apTotal)) && (!n.req || n.req.every(rid => st.apPicks.has(rid)));
    // ring
    ctx2.beginPath();
    ctx2.fillStyle = owned ? '#20314d' : '#0f1e33';
    ctx2.strokeStyle = canBuy ? '#63e6ff' : '#394d6f';
    const rad = n.keystone ? 18 : 14;
    ctx2.arc(n.x, n.y, rad, 0, Math.PI*2);
    ctx2.fill(); ctx2.stroke();
    // inner fill if owned
    if(owned){ ctx2.beginPath(); ctx2.fillStyle = '#2d4a76'; ctx2.arc(n.x, n.y, rad-4, 0, Math.PI*2); ctx2.fill(); }
    // text
    ctx2.fillStyle = '#8fb6ff'; ctx2.font = '10px monospace';
    ctx2.textAlign = 'left'; ctx2.textBaseline = 'middle';
    ctx2.fillText(n.text, n.x + rad + 6, n.y);
  });
  // update header with AP spent/total
  const hdr = document.querySelector('#talents h3');
  if(hdr){ hdr.innerHTML = `Talents (${st.apSpent}/${st.apTotal})<button class="drawer-close" aria-label="Close">×</button>`; }
  // rewire close button again (since we replaced innerHTML)
  document.querySelectorAll('#talents .drawer-close').forEach(btn=>{
    btn.onclick = (e) => { e.stopPropagation(); document.getElementById('talents').style.display='none'; };
  });
}

if(talentCanvas){
  // draw once at start
  drawTalents();
  // click to purchase
  talentCanvas.addEventListener('click', e => {
    const rect = talentCanvas.getBoundingClientRect();
    const x = (e.clientX - rect.left) / rect.width * talentCanvas.width;
    const y = (e.clientY - rect.top) / rect.height * talentCanvas.height;
    talents.forEach(n => {
      const rad = n.keystone ? 18 : 14;
      if(Math.hypot(n.x - x, n.y - y) <= rad + 4){
        const owned = st.apPicks.has(n.id);
        const canBuy = !owned && (st.apSpent < Math.min(30, st.apTotal)) && (!n.req || n.req.every(rid => st.apPicks.has(rid)));
        if(canBuy){ st.apPicks.add(n.id); st.apSpent += n.cost || 1; tallyTalentStats(); drawTalents(); }
      }
    });
  });
}

/* ===== Inventory scaffolding ===== */
const inv=[]; const equip={weapon:null,armor:null,acc1:null,acc2:null,pet:null};
const invGrid=document.getElementById('invGrid'); const equipBox=document.getElementById('equip');
function makeItem(name,slot,atk=2){ return {id:Math.random(), name, slot, atk, rarity:['Common','Rare','Epic'][Math.floor(rng()*3)]}; }

// Compute player stats from equipped items.  Each hero has a base damage which is
// increased by the atk values of their currently equipped items.  Additional stats
// (shield, move speed, etc.) could be added here using similar accumulation logic.
function recalcStats(){
  // base damage per hero
  const baseDamage = {A1:20, Unique:18, Missy:18};
  // accumulate atk bonuses by hero id
  const bonus = {A1:0, Unique:0, Missy:0};
  for(const slot in equip){
    const it = equip[slot];
    if(!it) continue;
    if(it.atk){
      // apply this bonus equally to all players for simplicity
      bonus.A1 += it.atk;
      bonus.Unique += it.atk;
      bonus.Missy += it.atk;
    }
  }
  for(const p of st.players){
    const id = p.id;
    let dmgBase = baseDamage[id] + bonus[id];
    // apply legacy talent attack multiplier if present
    if(st._talentStats && st._talentStats.atkMul){ dmgBase *= (1 + st._talentStats.atkMul); }
    p.dmg = Math.round(dmgBase);
  }
  // Apply AP stat buffs: each spent ability point adds atk/def/hp from PATCH.systems.talents.perPoint
  const ap = Math.min(PATCH.systems.talents.cap, st.apTotal || 0);
  const extra = PATCH.systems.talents.perPoint;
  // increase party HP Max and apply defense flat reduction
  st.hpMax = 100 + ap * extra.hp;
  st.hp = Math.min(st.hp, st.hpMax);
  st._defFlat = ap * extra.def;
  // increase damage for each hero
  for(const p of st.players){ p.dmg += ap * extra.atk; }
  // preserve original shield bonus from talents (unused yet)
  st._shieldMaxBonus = (st._talentStats && st._talentStats.shield) ? st._talentStats.shield : 0;
}

// Add a random item to the inventory, used when collecting gift boxes.  If there is
// no empty slot, the item is discarded.  Item slots are chosen randomly from the
// available equipment types.
function addRandomItem(){
  // find an empty inventory slot
  const totalSlots = st.invRows * 8;
  for(let i=0; i<totalSlots; i++){
    if(!inv[i]){
      const slots = ['weapon','armor','acc1','acc2','pet'];
      const sl = slots[Math.floor(Math.random() * slots.length)];
      const newIt = makeItem('Gift Item', sl, 1 + Math.floor(Math.random()*4));
      inv[i] = newIt;
      refreshInv();
      refreshEquip();
      recalcStats();
      return;
    }
  }
}
function refreshInv(){
  // build grid cells
  invGrid.innerHTML='';
  const totalSlots = st.invRows * 8;
  for(let i=0;i<totalSlots;i++){
    const d=document.createElement('div');
    d.className='slot';
    const it=inv[i];
    d.textContent = it ? it.name : '•';
    d.onclick = ()=>{
      if(!it) return;
      // equip the item into its slot and remove from bag
      equip[it.slot] = it;
      inv[i] = null;
      refreshInv();
      refreshEquip();
      recalcStats();
    };
    invGrid.appendChild(d);
  }
}
function refreshEquip(){
  [...equipBox.children].forEach(d=>{
    const k=d.dataset.slot; const it=equip[k]; d.textContent = (k.toUpperCase()) + (it?': '+it.name:'');
  });
}
for(let i=0;i<8;i++) inv.push(makeItem('Blade +'+(i+1),'weapon',3+i));
inv.push(makeItem('Pet: Mini‑Cat','pet',0)); refreshInv(); refreshEquip();
recalcStats();

/* ===== Input ===== */
const keys = {};
// Handle key presses for leader cycling, jump and direct leader select.  Use PATCH.controls.leaderKeys for specific heroes.
addEventListener('keydown', e => {
  keys[e.code] = true;
  // cycle leaders with Q
  if(e.code === 'KeyQ'){ st.leader = (st.leader + 1) % 3; updateCharBtns(); }
  // jump with space
  if(e.code === 'Space'){ jumpAll(); }
  // direct leader selection using configured keys
  if(e.code === PATCH.controls.leaderKeys.A1){ st.leader = 0; updateCharBtns(); }
  else if(e.code === PATCH.controls.leaderKeys.Unique){ st.leader = 1; updateCharBtns(); }
  else if(e.code === PATCH.controls.leaderKeys.Missy){ st.leader = 2; updateCharBtns(); }
});
addEventListener('keyup', e => { keys[e.code] = false; });
const stick=document.getElementById('stick'), nub=document.getElementById('nub'); let joyId=null, joyX=0, joyY=0, lastTap=0;
stick.addEventListener('pointerdown',e=>{ stick.setPointerCapture(e.pointerId); joyId=e.pointerId; onJoy(e); });
stick.addEventListener('pointermove',e=>{ if(e.pointerId===joyId) onJoy(e); });
stick.addEventListener('pointerup',e=>{ if(e.pointerId===joyId){ joyId=null; joyX=0; joyY=0; nub.style.left='50%'; nub.style.top='50%'; const now=performance.now(); if(now-lastTap<260) jumpAll(); lastTap=now; }});
function onJoy(e){ const r=stick.getBoundingClientRect(); const cx=r.left+r.width/2, cy=r.top+r.height/2; let dx=e.clientX-cx, dy=e.clientY-cy; const m=Math.hypot(dx,dy); const lim=r.width*0.38; if(m>lim){ dx=dx/m*lim; dy=dy/m*lim; } nub.style.left=(50+dx/r.width*100)+'%'; nub.style.top=(50+dy/r.height*100)+'%'; joyX=dx/lim; joyY=dy/lim; }

// click detection for non-leader skill icons
cv.addEventListener('pointerdown', e => {
  // ignore if clicking on UI (buttons are above canvas) by checking pointer-events: none on hud; pointer still captured though
  const rect = cv.getBoundingClientRect();
  const x = (e.clientX - rect.left) / rect.width * DESIGN_W;
  const y = (e.clientY - rect.top) / rect.height * DESIGN_H;
  for(const r of nonSkillRects){
    if(x >= r.x && x <= r.x + r.w && y >= r.y && y <= r.y + r.h){
      // ensure skill is ready
      const hero = st.players[r.pIndex];
      if(cdReady(hero.id, r.key)){
        useSkill(hero, r.key);
      }
      break;
    }
  }
});

/* ===== Helpers ===== */
function leader(){ return st.players[st.leader]; }
function laneY(l){ return (DESIGN_H-100) + (l===0?-30:l===2?30:0); }
function jumpAll(){
  // Jump all heroes if grounded using the configured impulse.  This keeps jumps consistent when the value changes.
  for(const p of st.players){
    if(p.grounded){
      p.vy = PATCH.systems.jump.v0;
      p.grounded = false;
    }
  }
} // lowered jump (from PATCH)
function grantGold(n){ st.gold+=n; updateCurrencies(); }

// Update currency display values in the HUD.  This is used whenever
// currencies change (e.g. pickups, purchases).  Without this helper,
// the UI would not reflect current gold/ticket totals.
function updateCurrencies(){
  const g=document.getElementById('goldVal'); if(g) g.textContent=st.gold;
  const s=document.getElementById('silverVal'); if(s) s.textContent=st.silver;
  const t=document.getElementById('ticketVal'); if(t) t.textContent=st.tickets;
  const z=document.getElementById('gemVal'); if(z) z.textContent=st.gems;
}

/* ===== Shop purchase helper ===== */
// Attempt to deduct currency for a purchase.  Prefers to spend gold if
// available; falls back to tickets if sufficient.  Accepts a gold cost
// (gCost) and ticket cost (tCost).  On success, executes the provided
// callback and returns true.  If funds are insufficient, displays a
// floater and returns false.
function tryBuy(item, gCost, tCost, cb){
  // choose currency: use gold first if enough
  if(gCost !== null && st.gold >= gCost){
    st.gold -= gCost;
    updateCurrencies();
    cb('gold');
    return true;
  }
  if(tCost !== null && st.tickets >= tCost){
    st.tickets -= tCost;
    updateCurrencies();
    cb('tickets');
    return true;
  }
  // not enough funds
  addFloater(DESIGN_W/2, 60, 'Insufficient funds', '#ff7a6a');
  return false;
}

/* ===== Chest opening functions ===== */
function openGiftChest(){
  // Determine rarity with pity system: guarantee Epic if pityCount >= 19
  const rnd = Math.random();
  let rarity;
  if(st.pityCount >= 19){ rarity = 'Epic'; st.pityCount = 0; }
  else {
    if(rnd < 0.60) rarity = 'Common';
    else if(rnd < 0.90) rarity = 'Rare';
    else if(rnd < 0.99) rarity = 'Epic';
    else rarity = 'Legendary';
    // track pity for non‑Epic+ results
    if(rarity === 'Common' || rarity === 'Rare'){ st.pityCount++; } else { st.pityCount = 0; }
  }
  // create random item with slot and atk based on rarity
  const slots=['weapon','armor','acc1','acc2','pet'];
  const slot=slots[Math.floor(Math.random()*slots.length)];
  let atk=2;
  if(rarity === 'Rare') atk=4;
  if(rarity === 'Epic') atk=6;
  if(rarity === 'Legendary') atk=8;
  const it = makeItem(rarity+' Item', slot, atk);
  // find empty slot
  const totalSlots = st.invRows * 8;
  let placed=false;
  for(let i=0;i<totalSlots;i++){
    if(!inv[i]){ inv[i] = it; placed=true; break; }
  }
  if(!placed){ addFloater(DESIGN_W/2, 80, 'Bag Full', '#ff7a6a'); }
  refreshInv(); refreshEquip(); recalcStats();
  // award tickets or gold? optionally
}
function openBossChest(){
  // Boss chests drop higher rarities: 30% Rare, 50% Epic, 20% Legendary
  const rnd = Math.random();
  let rarity;
  if(rnd < 0.30) rarity = 'Rare';
  else if(rnd < 0.80) rarity = 'Epic';
  else rarity = 'Legendary';
  st.pityCount = 0; // reset pity on boss chest
  const slots=['weapon','armor','acc1','acc2','pet'];
  const slot=slots[Math.floor(Math.random()*slots.length)];
  let atk=5;
  if(rarity === 'Epic') atk=7;
  if(rarity === 'Legendary') atk=10;
  const it=makeItem(rarity+' Boss Item', slot, atk);
  const totalSlots = st.invRows * 8;
  let placed=false;
  for(let i=0;i<totalSlots;i++){
    if(!inv[i]){ inv[i]=it; placed=true; break; }
  }
  if(!placed){ addFloater(DESIGN_W/2, 80, 'Bag Full', '#ff7a6a'); }
  refreshInv(); refreshEquip(); recalcStats();
}
function spawnCoin(x,y,amt){ st.pickups.push({kind:'coin',x,y,amt,vy:-0.2,life:500}); }
function spawnGift(x,y){ st.pickups.push({kind:'gift',x,y,vy:-0.1,life:300}); }

// Add a floating text effect (damage/resource indicator)
function addFloater(x,y,txt,color){ st.effects.push({x,y,txt,color,vy:-0.25,life:800}); }

/* ===== Skills & CDs ===== */
const CD={ 'A1':{S1:6000,S2:10000,S3:16000}, 'Unique':{S1:4000,S2:20000,S3:40000}, 'Missy':{S1:3000,S2:25000,S3:30000} };
function cdReady(id,k){ return st.cds[id][k]<=0; } function startCD(id,k){ st.cds[id][k]=CD[id][k]; }
document.getElementById('btnS1').onclick=()=>useSkill(leader(),'S1');
document.getElementById('btnS2').onclick=()=>useSkill(leader(),'S2');
document.getElementById('btnS3').onclick=()=>useSkill(leader(),'S3');
document.getElementById('btnRage').onclick=()=>{
  if(st.rage>=st.rageMax && !st.rageOn){
    st.rageOn=true; st.rage=0; st.rageICD=20000;
    // tiered buffs: set duration and multipliers based on Rage Tier
    if(st.rageTier===2){ st.rageDur=12000; st._rageAtk=1.40; st._rageSpd=1.30; st._rageShield=1.30; }
    else { st.rageDur=10000; st._rageAtk=1.25; st._rageSpd=1.20; st._rageShield=1.20; }
    // hero ultimate when activating Rage
    const h = leader();
    if(h.id==='A1') spawnA1Ultimate(h);
    else if(h.id==='Unique') spawnUniqueUltimate(h);
    else if(h.id==='Missy') spawnMissyUltimate(h);
  }
};
document.getElementById('btnShield').onclick=()=>{ if(!st._shieldOn && st.mp>=30){ st._shieldOn=true; st._shieldT=2500; st.mp-=30; } };
document.getElementById('btnJump').onclick=()=>jumpAll();
const hold={shoot:false}; document.getElementById('btnShoot').onpointerdown=()=>hold.shoot=true; document.getElementById('btnShoot').onpointerup=()=>hold.shoot=false;

/* ===== Shop button handlers ===== */
// Utility to increase damage for all players by a percent
function boostDamage(percent){
  for(const p of st.players){ p.dmg = Math.round(p.dmg * (1 + percent)); }
}
// +Damage (All)
const btnDmg = document.getElementById('buyDmg');
if(btnDmg) btnDmg.onclick = () => {
  tryBuy('Damage', 100, null, () => {
    boostDamage(0.10);
    addFloater(DESIGN_W/2, 60, '+Damage', '#36c777');
  });
};
// +Fire Rate (All) – approximate by increasing damage slightly
const btnRoF = document.getElementById('buyRoF');
if(btnRoF) btnRoF.onclick = () => {
  tryBuy('Fire Rate', 100, null, () => {
    boostDamage(0.08);
    addFloater(DESIGN_W/2, 60, '+Fire Rate', '#36c777');
  });
};
// Potion +50 HP
const btnHP = document.getElementById('buyHP');
if(btnHP) btnHP.onclick = () => {
  tryBuy('HP Potion', 50, null, () => {
    st.hp = Math.min(st.hpMax, st.hp + 50);
    addFloater(DESIGN_W/2, 60, '+HP', '#6aa8ff');
  });
};
// Rage Pill – grant 30 Rage
const btnRageP = document.getElementById('buyRage');
if(btnRageP) btnRageP.onclick = () => {
  tryBuy('Rage Pill', 80, null, () => {
    st.rage = Math.min(st.rageMax, st.rage + 30);
    addFloater(DESIGN_W/2, 60, '+Rage', '#f9cc2b');
  });
};
// XP Booster (15m)
const btnXP = document.getElementById('buyXP');
if(btnXP) btnXP.onclick = () => {
  tryBuy('XP Booster', 1500, 30, () => {
    st.xpBoost = 0.30; st.xpBoostT = 15 * 60 * 1000;
    addFloater(DESIGN_W/2, 60, 'XP Boost!', '#6aa8ff');
  });
};
// Drop Booster (15m)
const btnDrop = document.getElementById('buyDrop');
if(btnDrop) btnDrop.onclick = () => {
  tryBuy('Drop Booster', 500, 10, () => {
    st.dropBoost = 0.25; st.dropBoostT = 15 * 60 * 1000;
    addFloater(DESIGN_W/2, 60, 'Drop Boost!', '#ffb56a');
  });
};
// Rage Starter – start next stage at full rage
const btnRageStart = document.getElementById('buyRageStart');
if(btnRageStart) btnRageStart.onclick = () => {
  tryBuy('Rage Starter', 2000, 45, () => {
    st.nextStageRageStart = true;
    addFloater(DESIGN_W/2, 60, 'Next Rage ready', '#f9cc2b');
  });
};
// Magnet Aura (30m) – extend pickup magnet range
const btnMagnet = document.getElementById('buyMagnet');
if(btnMagnet) btnMagnet.onclick = () => {
  tryBuy('Magnet Aura', 20, null, () => {
    st.magnetAuraT = Math.max(st.magnetAuraT, 30 * 60 * 1000);
    addFloater(DESIGN_W/2, 60, 'Magnet Aura', '#ffd56a');
  });
};
// Revive Token
const btnRevive = document.getElementById('buyRevive');
if(btnRevive) btnRevive.onclick = () => {
  tryBuy('Revive Token', 60, 5, () => {
    st.reviveTokens++;
    addFloater(DESIGN_W/2, 60, '+Revive', '#ff7a6a');
  });
};
// Random Gear Kit
const btnGearKit = document.getElementById('buyGearKit');
if(btnGearKit) btnGearKit.onclick = () => {
  tryBuy('Random Gear', 200, null, () => {
    for(let i=0;i<4;i++) addRandomItem();
    addFloater(DESIGN_W/2, 60, 'Gear Kit!', '#8fb6ff');
  });
};
// Respect Token – reset AP
const btnRespect = document.getElementById('buyRespect');
if(btnRespect) btnRespect.onclick = () => {
  tryBuy('Respect Token', 200, 20, () => {
    st.apPicks.clear(); st.apSpent = 0;
    tallyTalentStats(); drawTalents();
    addFloater(DESIGN_W/2, 60, 'AP Reset', '#6aa8ff');
  });
};
// Boss Pass
const btnBossPass = document.getElementById('buyBossPass');
if(btnBossPass) btnBossPass.onclick = () => {
  tryBuy('Boss Pass', 1000, 20, () => {
    st.bossSkipPasses++;
    addFloater(DESIGN_W/2, 60, '+Boss Pass', '#ffd56a');
  });
};
// Inventory Row +1
const btnInvRow = document.getElementById('buyInvRow');
if(btnInvRow) btnInvRow.onclick = () => {
  tryBuy('Inventory Row', st.invRowCost, null, () => {
    st.invRows++;
    st.invRowCost += 500;
    refreshInv();
    addFloater(DESIGN_W/2, 60, '+Bag Slots', '#8fb6ff');
  });
};
// Loadout Slot +1
const btnLoad = document.getElementById('buyLoadout');
if(btnLoad) btnLoad.onclick = () => {
  tryBuy('Loadout Slot', null, 120, () => {
    st.loadoutSlots++;
    addFloater(DESIGN_W/2, 60, '+Loadout Slot', '#8fb6ff');
  });
};
// Pet Slot +1
const btnPetSlot = document.getElementById('buyPetSlot');
if(btnPetSlot) btnPetSlot.onclick = () => {
  tryBuy('Pet Slot', 500, 180, () => {
    st.petSlots++;
    addFloater(DESIGN_W/2, 60, '+Pet Slot', '#ffb4e6');
  });
};
// Forge Permits
const btnF1 = document.getElementById('buyForge1');
if(btnF1) btnF1.onclick = () => {
  tryBuy('Forge Permit I', 1000, null, () => {
    st.forgeLevel = Math.max(st.forgeLevel, 1);
    recalcStats();
    addFloater(DESIGN_W/2, 60, 'Forge I', '#ffd56a');
  });
};
const btnF2 = document.getElementById('buyForge2');
if(btnF2) btnF2.onclick = () => {
  tryBuy('Forge Permit II', 2000, null, () => {
    st.forgeLevel = Math.max(st.forgeLevel, 2);
    recalcStats();
    addFloater(DESIGN_W/2, 60, 'Forge II', '#ffd56a');
  });
};
const btnF3 = document.getElementById('buyForge3');
if(btnF3) btnF3.onclick = () => {
  tryBuy('Forge Permit III', 3000, null, () => {
    st.forgeLevel = Math.max(st.forgeLevel, 3);
    recalcStats();
    addFloater(DESIGN_W/2, 60, 'Forge III', '#ffd56a');
  });
};
// Gear & Craft caches
const btnWC = document.getElementById('buyWCache');
if(btnWC) btnWC.onclick = () => {
  tryBuy('Weapon Cache', 1000, null, () => {
    addRandomItem();
    addFloater(DESIGN_W/2, 60, 'Weapon Cache', '#8fb6ff');
  });
};
const btnAC = document.getElementById('buyACache');
if(btnAC) btnAC.onclick = () => {
  tryBuy('Armor Cache', 1000, null, () => {
    addRandomItem();
    addFloater(DESIGN_W/2, 60, 'Armor Cache', '#8fb6ff');
  });
};
const btnAccC = document.getElementById('buyAccCache');
if(btnAccC) btnAccC.onclick = () => {
  tryBuy('Accessory Cache', 1000, null, () => {
    addRandomItem();
    addFloater(DESIGN_W/2, 60, 'Accessory Cache', '#8fb6ff');
  });
};
// Keys & Chests
const btnGiftKey = document.getElementById('buyGiftKey');
if(btnGiftKey) btnGiftKey.onclick = () => {
  tryBuy('Gift Key', 500, 25, () => {
    openGiftChest();
    addFloater(DESIGN_W/2, 60, 'Gift Chest', '#ffd56a');
  });
};
const btnBossKey = document.getElementById('buyBossKey');
if(btnBossKey) btnBossKey.onclick = () => {
  tryBuy('Boss Key', 3000, 30, () => {
    openBossChest();
    addFloater(DESIGN_W/2, 60, 'Boss Chest', '#ff8c6a');
  });
};
// Bundles
const btnBStart = document.getElementById('buyBundleStarter');
if(btnBStart) btnBStart.onclick = () => {
  if(st.bundleStarter){ addFloater(DESIGN_W/2, 60, 'Claimed', '#a8b7ce'); return; }
  // free starter pack: 2 gift chests and 10m magnet aura
  st.bundleStarter = true;
  openGiftChest(); openGiftChest();
  st.magnetAuraT = Math.max(st.magnetAuraT, 10 * 60 * 1000);
  addFloater(DESIGN_W/2, 60, 'Starter Pack', '#ffd56a');
};
const btnBBooster = document.getElementById('buyBundleBooster');
if(btnBBooster) btnBBooster.onclick = () => {
  if(st.bundleBooster){ addFloater(DESIGN_W/2, 60, 'Purchased', '#a8b7ce'); return; }
  tryBuy('Booster Pack', 500, 50, () => {
    st.bundleBooster = true;
    // 5 gift chests
    for(let i=0;i<5;i++) openGiftChest();
    // XP & drop boosters ×3 => 45 minutes each
    st.xpBoost = 0.30; st.xpBoostT = Math.max(st.xpBoostT, 45 * 60 * 1000);
    st.dropBoost = 0.25; st.dropBoostT = Math.max(st.dropBoostT, 45 * 60 * 1000);
    addFloater(DESIGN_W/2, 60, 'Booster Pack', '#ffd56a');
  });
};
const btnBFounder = document.getElementById('buyBundleFounder');
if(btnBFounder) btnBFounder.onclick = () => {
  if(st.bundleFounder){ addFloater(DESIGN_W/2, 60, 'Purchased', '#a8b7ce'); return; }
  tryBuy('Founder Pack', null, 100, () => {
    st.bundleFounder = true;
    st.loadoutSlots++;
    addFloater(DESIGN_W/2, 60, 'Founder Pack', '#ffd56a');
  });
};

function useSkill(a,key){
  const id = a.id;
  if(!cdReady(id,key)) return;
  if(id==='A1'){
    if(key==='S1'){
      // launch multiple forward waves and open parry window
      for(let i=0;i<5;i++){
        const ang=(i-2)*0.22;
        st.shots.push({x:a.x+20,y:a.y-40,vx:Math.cos(ang)*560,vy:Math.sin(ang)*560,speed:560,dmg:18,life:520,laneY:a.y,homing:true,pierce:2});
      }
      // extend parry window for A1
      st.parryT = Math.max(st.parryT, 350);
    }
    else if(key==='S2'){ const tx=a.x+120, ty=a.y-40; setTimeout(()=>st.shots.push({x:tx,y:ty,vx:0,vy:0,dmg:360,life:80,aoe:72}),800); }
    else { a.x=Math.min(420,a.x+80); for(let i=0;i<7;i++){ const ang=(i-3)*0.28; st.shots.push({x:a.x+20,y:a.y-40,vx:Math.cos(ang)*600,vy:Math.sin(ang)*600,speed:600,dmg:16,life:480,laneY:a.y,homing:true}); } }
  } else if(id==='Unique'){
    if(key==='S1'){ const n=1+Math.floor(Math.random()*3); for(let i=0;i<n;i++){ setTimeout(()=>{ const t=nearestEnemy(a)||{x:a.x+300,y:a.y}; const ang=Math.atan2(t.y-(a.y-40), t.x-(a.x+10)); st.shots.push({x:a.x+10,y:a.y-40,vx:Math.cos(ang)*560,vy:Math.sin(ang)*560,speed:560,dmg:20,life:520,laneY:a.y,homing:true,pierce:2}); }, i*90); } }
    else if(key==='S2'){ st.hp=Math.min(st.hpMax, st.hp+20); st._shieldOn=true; st._shieldT=Math.max(st._shieldT||0,4000); }
    else { a.overT=7000; a.overCD=0; } // BEAM FIX: timer-based, no setInterval
  } else { // Missy
    if(key==='S1'){ melee(a,36,42,24); wave(a,0.9); }
    else if(key==='S2'){ st._bubbleT=7000; st._shieldOn=true; st._shieldT=Math.max(st._shieldT||0,7000); st.rage=Math.min(st.rageMax, st.rage+20); }
    else { st.pickups.push({kind:'catAlly',x:a.x+40,y:a.y-30,vx:0.08,life:900,fireT:0}); st.pickups.push({kind:'catAlly',x:a.x+58,y:a.y-30,vx:0.08,life:900,fireT:0}); }
  }
  startCD(id,key);
}
function wave(a, mul){ st.shots.push({x:a.x+24,y:a.y-40,vx:560,vy:0,speed:560,dmg:Math.round(a.dmg*mul),life:620,laneY:a.y,homing:false,pierce:2}); }
// Melee attack: damage enemies in front of the attacker and reflect overlapping bullets if applicable.
function melee(a, reach, height, dmg){
  // Attempt to reflect enemy bullets during melee.  Only A1 and Missy reflect.
  tryReflectDuringMelee(a);
  for(const e of st.enemies){
    if(e.hp>0 && e.x > a.x && (e.x - a.x) <= reach && Math.abs(e.y - a.y) <= height / 2){
      e.hp -= dmg;
    }
  }
}

// Attempt to reflect enemy bullets during a melee strike.  Only heroes whose id is listed
// in PATCH.combat.reflect.playerMelee.enabledFor will cause reflection.  For each overlapping
// enemy projectile within a rectangular melee zone ahead of the attacker, convert it into a
// friendly shot with mirrored horizontal velocity and reduced vertical velocity.  Reflected
// shots gain piercing and scaled damage.
function tryReflectDuringMelee(attacker){
  if(!PATCH.combat.reflect.playerMelee.enabledFor.includes(attacker.id)) return;
  const reachX = 54;
  const reachY = 36;
  for(const b of st.eShots){
    if(!b || b.life <= 0) continue;
    if(Math.abs(b.x - attacker.x) < reachX && Math.abs(b.y - (attacker.y - 20)) < reachY){
      // flip projectile to player
      const nvx = Math.abs(b.vx); // ensure it travels rightward (toward enemies)
      const nvy = b.vy * 0.5;
      b.vx = nvx;
      b.vy = nvy;
      b.speed = Math.hypot(nvx, nvy);
      b.owner = 'player';
      b.team = 'player';
      b.pierce = (b.pierce || 0) + 1;
      b.dmg = Math.round((b.dmg || 10) * PATCH.combat.reflect.playerMelee.dmgMul);
    }
  }
}


/* ===== Progression & Leveling ===== */
function xpToNext(L){ return Math.round(50 + 25*L + 5*L*L); }
function grantXP(n){
  // apply XP booster if active
  let gain = n;
  if(st.xpBoost && st.xpBoostT > 0){ gain = n * (1 + st.xpBoost); }
  st.xp += gain;
  while(st.xp >= xpToNext(st.level)){
    st.xp -= xpToNext(st.level);
    st.level++;
    // restore party HP/MP on level up
    st.hp = st.hpMax;
    st.mp = st.mpMax;
    // ability point gain starting at level 2
    if(st.level >= 2 && st.apTotal < 30){ st.apTotal++; }
  }
}

/* ===== Rage Ultimates ===== */
function spawnA1Ultimate(p){
  // reduce A1 HP by 10% of current
  st.hp = Math.max(1, st.hp - Math.round(st.hp * 0.10));
  // spawn three giant slash waves across three lanes
  const lanes = [0,1,2];
  lanes.forEach((ln, idx) => {
    const yPos = laneY(ln);
    for(let i=0;i<3;i++){
      setTimeout(() => {
        st.shots.push({x:p.x+20, y:yPos-40, vx:800, vy:0, speed:800, dmg:150, life:1000, laneY:yPos, homing:false, pierce:5, aoe:0});
      }, i*200);
    }
  });
  // loot boost: raise coin drop chance for 15s
  st._lootBoost = 15000;
}
function spawnUniqueUltimate(p){
  // prolong overcharge beam for 12s; increase tick damage slightly
  p.overT = 12000;
  p.overCD = 0;
}
function spawnMissyUltimate(p){
  // summon chest allies for 20s; these act like stronger cat allies and drop gifts on death
  const positions = [40, 60, 80];
  positions.forEach((off, idx) => {
    st.pickups.push({kind:'catAlly', x:p.x + off, y:p.y - 30, vx:0.06 + idx*0.02, life:2000, fireT:0, strong:true});
  });
}

/* ===== Enemies & Waves ===== */
function nearestEnemy(a){ let best=null,bd=1e9; for(const e of st.enemies){ if(e.hp<=0) continue; const dx=e.x-a.x; if(dx<=0) continue; const d=Math.hypot(dx,e.y-a.y); if(d<bd){bd=d;best=e;} } return best; }
function spawnWave(){
  // spawn mobs for normal waves or a stage boss on the final wave.  The boss type scales
  // with the current stage (capped at BOSS_COUNT) and may randomly be replaced by a chest boss.
  if(st.wave < st.wavesPerStage){
    // Determine number of enemies by stage using PATCH.waves.sizes.  Use enemiesPerWave() helper.
    const n = enemiesPerWave(st.stage);
    for(let i=0; i<n; i++){
      const hpBase = 80 + (st.stage - 1) * 40 + st.wave * 8;
      const e = {
        kind: 'mob',
        x: DESIGN_W + 120 + i * 60,
        y: laneY([0,1,2][i % 3]),
        hp: hpBase,
        max: hpBase,
        vx: -0.30 - 0.02 * st.stage,
        fireCD: 1200 + Math.random() * 800
      };
      applyEnemyScalars(e);
      st.enemies.push(e);
    }
    // chance to spawn a miniboss between waves 5–7
    if(st.wave >= PATCH.waves.miniboss.waveMin && st.wave <= PATCH.waves.miniboss.waveMax && Math.random() < PATCH.waves.miniboss.chance){
      const hp = 350 + st.stage * 120;
      const m = { kind:'miniboss', x: DESIGN_W - 140, y: laneY(1), hp: hp, max: hp, vx: -0.12, fireCD: 1000 };
      applyEnemyScalars(m);
      st.enemies.push(m);
    }
    // chance to spawn a gift-box boss (piñata) between waves 2–9
    if(st.wave >= PATCH.waves.giftBoxBoss.waveMin && st.wave <= PATCH.waves.giftBoxBoss.waveMax && Math.random() < PATCH.waves.giftBoxBoss.chance){
      const hp = 420 + st.stage * 80;
      const gb = { kind:'chestBoss', x: DESIGN_W - 220, y: laneY(1), hp: hp, max: hp, vx: -0.10, canHurt: false };
      applyEnemyScalars(gb);
      st.enemies.push(gb);
    }
  } else {
    // Determine which boss pattern to use based on stage.  Only BOSS_COUNT unique patterns
    // exist; later stages reuse the final pattern.  Chest boss still has a 50% chance.
    const idx = Math.min(st.stage, BOSS_COUNT);
    const useChest = rng() < 0.5;
    const bossKind = useChest ? 'chestBoss' : 'boss' + idx;
    const hp = 900 + (st.stage - 1) * 220;
    const b = {
      kind: bossKind,
      x: DESIGN_W - 260,
      y: laneY(1),
      hp: hp,
      max: hp,
      vx: 0,
      phase2: false,
      fireCD: 600
    };
    // If not a chest boss, set preferred distance and reflect/summon fields
    if(!useChest){
      b.preferredDist = PATCH.combat.boss.preferredDistance;
      b.reflectCD = 0;
      b.reflectOn = false;
      b.reflectT = 0;
      b.reflected = 0;
      b.summonCD = PATCH.combat.boss.summon.cooldownSec * 1000;
    }
    // scale fireCD via helper for global slowdown
    applyEnemyScalars(b);
    st.enemies.push(b);
    st.bossAlive = true;
    st.bossMax = hp;
    st.bossHP = hp;
    st.chestBoss = useChest;
  }
}
// === PATCH v3 helpers ===
// Determine number of enemies per wave by stage using the PATCH.waves.sizes table.
function enemiesPerWave(stageNum){
  const list = PATCH.waves.sizes;
  let row = list.find(r => r.stage === stageNum);
  if(!row) row = list[list.length - 1];
  return Math.floor(row.min + Math.random() * (row.max - row.min + 1));
}
// Apply global slowdowns to enemies.  Movement and fire rate are scaled by PATCH settings.
function applyEnemyScalars(e){
  if(e.vx !== undefined){ e.vx *= PATCH.systems.enemyMoveScale; }
  if(e.fireCD !== undefined){ e.fireCD *= (1 / PATCH.systems.enemyFireRateScale); }
}
// === END PATCH v3 helpers ===
function advanceWave(){
  if(st.wave < st.wavesPerStage){
    // normal wave advance
    st.wave++;
    spawnWave();
  } else {
    // end of stage: move to next stage
    st.stage++;
    st.wave = 1;
    st.bossAlive = false;
    st.chestBoss = false;
    // Rage Starter: set rage to full for next stage, but preserve cooldown
    if(st.nextStageRageStart){
      st.rage = st.rageMax;
      st.nextStageRageStart = false;
    }
    // Boss Pass: if player has passes and has previously cleared this stage's boss
    if(st.bossSkipPasses > 0 && st.bossCleared && st.bossCleared[st.stage]){
      st.bossSkipPasses--;
      // set wave to last wave to spawn boss immediately
      st.wave = st.wavesPerStage;
    }
    spawnWave();
  }
}

/* ===== Loop ===== */
let last=performance.now();
function loop(t){
  const dt=(t-last)/1000; last=t;
  if(!st.running){ requestAnimationFrame(loop); return; }
  st.time+=dt*st.speed; st.dt=dt*st.speed;

  // initial spawn gate
  if(!st.started){ st.started=true; spawnWave(); }

  // timers
  for(const id of ['A1','Unique','Missy']) for(const k of ['S1','S2','S3']) st.cds[id][k]=Math.max(0,st.cds[id][k]-st.dt*1000);
  if(st._shieldOn){ st._shieldT-=st.dt*1000; if(st._shieldT<=0) st._shieldOn=false; }
  if(st._bubbleT){ st._bubbleT-=st.dt*1000; if(st._bubbleT<=0) st._bubbleT=0; }
  if(st.rageOn){ st.rageDur-=st.dt*1000; if(st.rageDur<=0) st.rageOn=false; } else if(st.rageICD>0){ st.rageICD-=st.dt*1000; }
  st.mp=Math.min(st.mpMax, st.mp+st.mpRegen*st.dt);
  if(st.parryT>0){ st.parryT -= st.dt*1000; if(st.parryT < 0) st.parryT = 0; }
  if(st._lootBoost && st._lootBoost > 0){ st._lootBoost -= st.dt * 1000; if(st._lootBoost < 0) st._lootBoost = 0; }

  // decrement booster timers
  if(st.xpBoostT > 0){ st.xpBoostT -= st.dt * 1000; if(st.xpBoostT <= 0){ st.xpBoostT = 0; st.xpBoost = 0; } }
  if(st.dropBoostT > 0){ st.dropBoostT -= st.dt * 1000; if(st.dropBoostT <= 0){ st.dropBoostT = 0; st.dropBoost = 0; } }
  if(st.magnetAuraT > 0){ st.magnetAuraT -= st.dt * 1000; if(st.magnetAuraT <= 0){ st.magnetAuraT = 0; } }

  // formation + movement
  const l=leader(); l.vx=(joyX||0)*0.45*(st.rageOn?1.2:1); l.vy+=0.002; // slightly stronger gravity
  for(const p of st.players){
    const targetX = (p===l? l.x : l.x-90-(p===st.players[2]?20:0));
    const targetY = laneY(p.lane);
    if(p===l){ p.x+=l.vx*DESIGN_W*st.dt; p.y+=l.vy*DESIGN_H*st.dt; }
    else { p.x+=(targetX-p.x)*0.08; p.y+=(targetY-p.y)*0.10; }
    if(p.y>laneY(p.lane)){ p.y=laneY(p.lane); p.vy=0; p.grounded=true; } else p.grounded=false;
    p.x=Math.max(60,Math.min(520,p.x));
    // Unique beam ticks (bug fix: timer-based)
    if(p.overT>0){ p.overT-=st.dt*1000; p.overCD-=st.dt*1000; if(p.overCD<=0){ p.overCD=120; const t=nearestEnemy(p); if(t){ const ang=Math.atan2(t.y-(p.y-40), t.x-(p.x+10)); st.shots.push({x:p.x+10,y:p.y-40,vx:Math.cos(ang)*740,vy:Math.sin(ang)*740,speed:740,dmg:10,life:180,laneY:p.y,homing:true,pierce:3}); } } }
  }

  // auto & manual fire / skills
  if(st.auto){
    // always hold shoot
    hold.shoot = true;
    // schedule auto use of skills, shield, jump and rage sequentially
    if(st.time >= st._autoNextSkill){
      let acted = false;
      // If Rage ready and not on cooldown, use it
      if(!st.rageOn && st.rage >= st.rageMax && st.rageICD <= 0){
        st.rageOn = true; st.rage = 0; st.rageICD = 20000; st.rageDur = 10000;
        acted = true;
      } else {
        // Prioritize heal/shield if HP or MP low
        // Use shield if not active and mp available
        if(!st._shieldOn && st.mp >= 30){ st._shieldOn = true; st._shieldT = 2500; st.mp -= 30; acted = true; }
        // Jump periodically to avoid contact
        else if(st.time - (st._lastAutoJump||0) > 2.5){ jumpAll(); st._lastAutoJump = st.time; acted = true; }
        // Auto skills for leader first, then others
        const order = [st.leader, (st.leader+1)%3, (st.leader+2)%3];
        for(const idx of order){ if(acted) break; const h = st.players[idx];
          for(const sk of ['S3','S2','S1']){ if(cdReady(h.id, sk)){
            // Unique healing only if HP below 70%
            if(h.id==='Unique' && sk==='S2' && st.hp/st.hpMax > 0.7) continue;
            // Missy bubble (S2) rarely used, only if many enemies
            if(h.id==='Missy' && sk==='S2' && st.enemies.length < 3) continue;
            useSkill(h, sk);
            acted = true;
            break;
          } }
        }
      }
      if(acted){
        // delay next auto skill to avoid spamming
        st._autoNextSkill = st.time + 0.8;
      }
    }
  }
  // manual fire if hold.shoot
  if(hold.shoot){
    // A1 short melee cadence
    if((st.time%0.35)<0.02){ melee(l,32,42,20); wave(l,0.7); }
    // Unique & Missy occasional shots
    for(const p of st.players){
      if(p.id!=='A1'){
        const t=nearestEnemy(p)||{x:p.x+280,y:p.y}; const ang=Math.atan2(t.y-(p.y-40), t.x-(p.x+10));
        st.shots.push({x:p.x+10,y:p.y-40,vx:Math.cos(ang)*520,vy:Math.sin(ang)*520,speed:520,dmg:p.dmg,life:980,laneY:p.y,homing:true});
      }
    }
  }

  // shots (player)
  for(const s of st.shots){
    if(s.homing){ const t=nearestEnemy({x:s.x,y:s.laneY}); if(t){ const ax=t.x-s.x, ay=t.y-s.y; const m=Math.hypot(ax,ay)||1; s.vx=(ax/m)*s.speed; s.vy=(ay/m)*s.speed; } }
    // update position
    s.x+=s.vx*st.dt; s.y+=s.vy*st.dt; s.life-=st.dt*1000;
    // bounce off ground or ceiling or walls if bounce property is present
    if(s.bounce && s.bounce>0){
      // ground at DESIGN_H-120; ceiling at 0
      if(s.y > DESIGN_H-120 && s.vy>0){ s.vy = -Math.abs(s.vy); s.bounce--; }
      if(s.y < 0 && s.vy<0){ s.vy = Math.abs(s.vy); s.bounce--; }
      // left and right walls
      if(s.x < 0 && s.vx<0){ s.vx = Math.abs(s.vx); s.bounce--; }
      if(s.x > DESIGN_W && s.vx>0){ s.vx = -Math.abs(s.vx); s.bounce--; }
    }
  }
  st.shots=st.shots.filter(s=>s.life>0 && s.x<DESIGN_W+60 && s.y>-60 && s.y<DESIGN_H+60);

  // enemies move & shoot
  for(const e of st.enemies){
    e.x += (e.vx||0)*DESIGN_W*st.dt;
    // Boss reflect & summon logic (PATCH v3)
    if(e.kind && e.kind.startsWith('boss') && !st.chestBoss){
      // reflect window and cooldown
      if(e.reflectOn){
        e.reflectT -= st.dt * 1000;
        if(e.reflectT <= 0){ e.reflectOn = false; addFloater(e.x, e.y - 60, 'Reflect Off', '#a8b7ce'); }
      } else {
        e.reflectCD = Math.max(0, (e.reflectCD || 0) - st.dt * 1000);
        if(e.reflectCD <= 0){
          e.reflectOn = true;
          e.reflectT = PATCH.combat.reflect.boss.windowSec * 1000;
          e.reflected = 0;
          e.reflectCD = PATCH.combat.reflect.boss.cooldownSec * 1000 + e.reflectT;
          addFloater(e.x, e.y - 60, 'Reflect!', '#ffd56a');
        }
      }
      // summon adds
      e.summonCD = (e.summonCD || 0) - st.dt * 1000;
      if(e.summonCD <= 0){
        const addsAlive = st.enemies.filter(x => x.kind === 'boss_add' && x.hp > 0).length;
        if(addsAlive < PATCH.combat.boss.summon.maxAlive){
          for(let i=0; i<PATCH.combat.boss.summon.count; i++){
            const add = { kind:'boss_add', x: e.x - 40 - 20 * i, y: laneY([0,1,2][i % 3]), hp: 120 + st.stage * 20, max: 120 + st.stage * 20, vx: -0.20, fireCD: 1400 };
            applyEnemyScalars(add);
            st.enemies.push(add);
          }
        }
        e.summonCD = PATCH.combat.boss.summon.cooldownSec * 1000;
      }
      // maintain preferred distance from leader
      if(e.preferredDist){
        const targetX = Math.max(520, st.players[st.leader].x + e.preferredDist);
        const ax = (targetX - e.x) * 0.004;
        e.vx = (e.vx || 0) + ax;
        e.vx = Math.max(-0.2, Math.min(0.2, e.vx));
      }
    }
    // boss patterns
    e.fireCD = (e.fireCD||600) - st.dt*1000;
    if(e.fireCD<=0){
      if(e.kind === 'mob'){
        e.fireCD = 900 + Math.random() * 600;
        enemyShoot(e, false);
      } else if(e.kind && (e.kind.startsWith('boss') || e.kind === 'chestBoss')){
        // Bosses and chest bosses shoot more frequently and can have homing bullets
        e.fireCD = 420;
        enemyShoot(e, rng() < 0.25);
      }
    }
    // phase flip when a boss crosses half HP; applies to numbered bosses only
    if(e.kind && e.kind.startsWith('boss') && !e.phase2 && e.hp < e.max * 0.5){
      e.phase2 = true;
    }
  }

  // enemy shots update
  for(const b of st.eShots){
    // parry reflection: if a parry window is active on A1 or Missy, convert enemy bullets into friendly shots
    if(st.parryT > 0){
      for(const p of st.players){
        if((p.id==='A1' || p.id==='Missy') && Math.abs(p.x - b.x) < 28 && Math.abs(p.y - b.y) < 28){
          // reflect bullet: remove from enemy shots and spawn a friendly piercing wave
          b.life = 0;
          // spawn reflected shot with same speed directed forward and piercing
          const vx = b.vx > 0 ? b.vx : Math.abs(b.vx);
          const vy = b.vy;
          st.shots.push({x:b.x, y:b.y, vx:vx, vy:vy, speed:Math.hypot(vx,vy), dmg:20, life:600, laneY:b.y, homing:false, pierce:3});
          break;
        }
      }
    }
    if(b.homing){ const t=st.players[st.leader]; const ax=t.x-b.x, ay=t.y-b.y; const m=Math.hypot(ax,ay)||1; b.vx=(ax/m)*b.speed; b.vy=(ay/m)*b.speed; }
    b.x+=b.vx*st.dt; b.y+=b.vy*st.dt; b.life-=st.dt*1000;
  }
  st.eShots = st.eShots.filter(b=>b.life>0 && b.x>-60 && b.x<DESIGN_W+60 && b.y>-60 && b.y<DESIGN_H+60);

  // collisions: player shots vs enemies
  for(const s of st.shots){
    for(const e of st.enemies){
      if(e.hp<=0) continue;
      const dx=e.x-s.x, dy=e.y-s.y;
      if(Math.abs(dx)<24 && Math.abs(dy)<32){
        // boss reflect: if reflect is active, flip projectile instead of damaging
        if(e.kind && e.kind.startsWith('boss') && e.reflectOn){
          if(e.reflected < PATCH.combat.reflect.boss.maxBullets){
            const nvx = (s.vx > 0 ? -Math.abs(s.vx) : Math.abs(s.vx));
            const nvy = s.vy * 0.5;
            st.eShots.push({x: s.x, y: s.y, vx: nvx, vy: nvy, speed: Math.hypot(nvx, nvy), life: 2000, homing: false});
            e.reflected++;
            addFloater(e.x, e.y - 50, 'Ping!', '#ffd56a');
            s.life = 0;
            continue;
          }
        }
        // compute damage with rage and apply
        const dmgVal = Math.round(s.dmg * (st.rageOn ? 1.25 : 1));
        e.hp -= dmgVal;
        // show damage floater
        addFloater(e.x, e.y-20, '-' + dmgVal, '#ff7a6a');
        s.life = 0;
        if(st.bossAlive){ st.bossHP=Math.max(0,Math.min(st.bossMax,e.hp)); }
        // spawn extra coins from chest bosses
        if(e.kind==='chestBoss' && Math.random()<0.35) spawnCoin(e.x,e.y-20, 4+Math.floor(Math.random()*5));
        if(e.hp<=0){
          st.kills++; st.rage=Math.min(st.rageMax, st.rage + (st.rageOn?20:6));
          // spawn coins and gifts, boosted if lootBoost active
          let baseCoins = 5 + Math.floor(Math.random()*8);
          if(st._lootBoost && st._lootBoost > 0){ baseCoins += 3; }
          spawnCoin(e.x,e.y-20, baseCoins);
          // compute gift chance: base 8%, +12% if loot boost is active, +dropBoost multiplier
          let giftChance = 0.08;
          if(st._lootBoost && st._lootBoost > 0){ giftChance += 0.12; }
          if(st.dropBoost && st.dropBoostT > 0){ giftChance += st.dropBoost; }
          if(Math.random() < giftChance) spawnGift(e.x,e.y-28);
          // award XP on kill: base XP for mobs, large bonus for bosses
          if((e.kind && e.kind.startsWith('boss')) || e.kind === 'chestBoss'){
            grantXP(120);
          } else {
            grantXP(6 + Math.floor(rng() * 4));
          }
          // mark boss kill if this enemy is any boss (boss1,boss2, etc.) or chest boss
          if((e.kind && e.kind.startsWith('boss')) || e.kind === 'chestBoss'){
            st.bossAlive = false;
            if(e.kind && e.kind.startsWith('boss')){
              if(!st.bossCleared) st.bossCleared = {};
              st.bossCleared[st.stage] = true;
            }
          }
        }
      }
    }
  }
  st.enemies = st.enemies.filter(e=>e.hp>0 && e.x>-80); // allow mobs to run past and despawn off left

  // collisions: enemy shots vs players
  for(const b of st.eShots){
    for(const p of st.players){
      if(Math.abs(p.x-b.x)<20 && Math.abs(p.y-b.y)<20){
        if(st._shieldOn){
          b.life = 0;
        } else {
          // subtract flat defense from damage but always inflict at least 1
          const dmg = Math.max(1, 8 - (st._defFlat || 0));
          st.hp = Math.max(0, st.hp - dmg);
          addFloater(p.x, p.y - 24, '-' + dmg, '#ff7a6a');
          b.life = 0;
        }
      }
    }
  }

  // contact damage: if enemies collide with players, apply damage before HP/MP. Shields absorb first.
  for(const e of st.enemies){
    if(e.hp <= 0) continue;
    for(const p of st.players){
      if(Math.abs(p.x - e.x) < 26 && Math.abs(p.y - e.y) < 34){
        if(st._shieldOn){
          // shield absorbs contact damage, but reduce shield duration slightly
          st._shieldT = Math.max(0, st._shieldT - 200);
        } else {
          const dmg2 = Math.max(1, 10 - (st._defFlat || 0));
          st.hp = Math.max(0, st.hp - dmg2);
          addFloater(p.x, p.y - 28, '-' + dmg2, '#ff7a6a');
        }
      }
    }
  }

  // pickups magnet
  for(const it of st.pickups){
    it.life-=st.dt*1000;
    const ld=leader(); const dx=ld.x-it.x, dy=ld.y-it.y; const d=Math.hypot(dx,dy);
    const magnetRange = (st.magnetAuraT > 0 ? 360 : 220);
    if(d<magnetRange){ it.x+=(dx/d)*magnetRange*st.dt; it.y+=(dy/d)*magnetRange*st.dt; }
    if(d<24){
      if(it.kind === 'coin'){
        grantGold(it.amt);
        addFloater(it.x, it.y, '+Gold', '#ffd56a');
      }
      if(it.kind === 'gift'){
        // collecting a gift box awards a ticket and rolls a random item into the bag
        st.tickets++;
        addRandomItem();
        addFloater(it.x, it.y, '+Ticket', '#ff8c6a');
      }
      it.life = 0;
    }
  }
  st.pickups=st.pickups.filter(p=>p.life>0);

  // update floating effects
  for(const ef of st.effects){
    ef.y += ef.vy * DESIGN_H * st.dt;
    ef.life -= st.dt * 1000;
  }
  st.effects = st.effects.filter(e => e.life > 0);

  // wave clear gating
  if(st.enemies.length===0 && !st.bossAlive && st.pickups.filter(p=>p.kind!=='catAlly').length===0){
    if(st.waveClearT<=0){ st.waveClearT=st.waveClearDelay; } else { st.waveClearT-=st.dt*1000; if(st.waveClearT<=0){ advanceWave(); } }
  } else { st.waveClearT=0; }

  // hp death
  if(st.hp<=0){
    if(st.reviveTokens > 0){
      // consume a revive token and restore 40% HP/Shield
      st.reviveTokens--;
      st.hp = Math.max(1, Math.round(st.hpMax * 0.40));
      st.mp = Math.max(1, Math.round(st.mpMax * 0.40));
      // clear enemy and bullet lists to give breathing room
      st.enemies.length = 0;
      st.shots.length = 0;
      st.eShots.length = 0;
      st.pickups.length = 0;
      // reset overcharge and bubble states
      for(const p of st.players){ p.overT = 0; }
      // do not reset stage or wave; continue playing
    } else {
      st.stage=1; st.wave=1; st.kills=0; st.hp=st.hpMax; st.mp=st.mpMax;
      st.enemies.length=0; st.shots.length=0; st.eShots.length=0; st.pickups.length=0;
      for(const p of st.players){ p.overT=0; }
      spawnWave();
    }
  }

  // draw & HUD
  draw();
  document.getElementById('hpFill').style.transform='scaleX('+(st.hp/st.hpMax)+')';
  document.getElementById('mpFill').style.transform='scaleX('+(st.mp/st.mpMax)+')';
  document.getElementById('bossFill').style.transform='scaleX('+(st.bossAlive? (st.bossHP/st.bossMax):0)+')';
  document.getElementById('stagePill').textContent=`Stage ${st.stage} • Wave ${st.wave}/${st.wavesPerStage} • Kills ${st.kills}`;

  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// begin loading optional sprite assets.  Once loading completes, the
// status summary will populate in the Settings drawer.  If no files
// are present (e.g. you didn't drop PNG/GIF assets next to this
// HTML), proxies (colored shapes) will be used instead.
loadAssets();

// Apply initial stats recalculation to incorporate AP-based buffs and updated HP/def values
recalcStats();

/* ===== Enemy shooting helpers ===== */
function enemyShoot(e, homing){
  // Determine base parameters by enemy kind.  Bosses increase difficulty per stage.  Mobs
  // shoot a single slow bullet, chest bosses fire a modest spread with some homing, and
  // numbered bosses scale with the stage index (up to BOSS_COUNT) to increase bullet count
  // and speed.  Higher stage bosses may drop occasional minions or add vertical shock shots.
  const t = st.players[st.leader];
  const ang = Math.atan2((t.y - (e.y)), (t.x - (e.x)));
  let sp = 420;
  let count = 1;
  let homingChance = 0;
  if(e.kind === 'mob'){
    sp = 420; count = 1; homingChance = 0;
  } else if(e.kind === 'chestBoss'){
    sp = 520; count = 5; homingChance = 0.3;
  } else if(e.kind && e.kind.startsWith('boss')){
    // extract stage index from 'bossN'
    const sIdx = parseInt(e.kind.replace('boss','')) || 1;
    sp = 520 + sIdx * 20;
    count = 5 + (sIdx - 1) * 2;
    homingChance = 0.25 + sIdx * 0.05;
    // bosses beyond stage 1 occasionally spawn an extra mob
    if(sIdx > 1 && Math.random() < 0.3){
      const lane = [0,1,2][Math.floor(Math.random() * 3)];
      const hpMob = 80 + (st.stage - 1) * 40 + st.wave * 8;
      st.enemies.push({kind:'mob', x:e.x + 120, y:laneY(lane), hp:hpMob, max:hpMob, vx:-0.30 - 0.02*st.stage, fireCD:1200 + Math.random()*800});
    }
    // bosses beyond stage 2 also fire a downward shock bullet
    if(sIdx > 2){
      st.eShots.push({x:e.x, y:e.y, vx:0, vy:600, speed:600, life:2000, homing:false});
    }
  } else {
    // default case: treat unknown as a basic single shot
    sp = 520; count = 1; homingChance = 0;
  }
  // spawn spread bullets
  for(let i=0; i<count; i++){
    const spread = (count > 1 ? (i - (count - 1) / 2) * 0.15 : 0);
    // decide if this bullet is homing: only bullets near the center of the spread may home
    let hv = false;
    if(homing && Math.abs(i - (count - 1) / 2) < 0.5 && Math.random() < homingChance) hv = true;
    const vx = Math.cos(ang + spread) * sp;
    const vy = Math.sin(ang + spread) * sp;
    st.eShots.push({x:e.x, y:e.y, vx, vy, speed:sp, life:2000, homing:hv});
  }
}

/* ===== Rendering ===== */
function draw(){
  ctx.clearRect(0,0,DESIGN_W,DESIGN_H);
  // BG
  ctx.fillStyle='#0f1826'; ctx.fillRect(0,0,DESIGN_W,DESIGN_H);
  // ground stripes
  ctx.fillStyle='#0e1c2e'; ctx.fillRect(0,DESIGN_H-120,DESIGN_W,120);
  ctx.fillStyle='#14243a'; ctx.fillRect(0,DESIGN_H-260,DESIGN_W,140);
  // players
  for(const p of st.players){
    // draw sprite if loaded; otherwise fallback to colored rectangle
    const img = assets[p.id];
    if(img){
      // scale roughly to player size; adjust offsets to center
      const w=40, h=60;
      ctx.drawImage(img, p.x - w/2, p.y - h + 8, w, h);
    } else {
      // fallback colored body
      ctx.fillStyle = p===st.players[0] ? '#6aa8ff' : (p===st.players[1] ? '#a78bfa' : '#ffb4e6');
      ctx.fillRect(p.x-18,p.y-34,36,52);
    }
    // overhead bars: HP, XP, Rage
    const barW = 52;
    const barH = 3;
    const baseX = p.x - barW/2;
    let yOff = p.y - 44;
    // HP bar (global for now)
    ctx.fillStyle = '#283f33'; ctx.fillRect(baseX, yOff, barW, barH);
    ctx.fillStyle = '#36c777'; ctx.fillRect(baseX, yOff, barW * (st.hp / st.hpMax), barH);
    yOff -= (barH + 2);
    // XP bar
    const xpRatio = st.level >= 101 ? 1 : (st.xp / xpToNext(st.level));
    ctx.fillStyle = '#233850'; ctx.fillRect(baseX, yOff, barW, barH);
    ctx.fillStyle = '#6aa8ff'; ctx.fillRect(baseX, yOff, barW * xpRatio, barH);
    yOff -= (barH + 2);
    // Rage bar
    ctx.fillStyle = '#42310f'; ctx.fillRect(baseX, yOff, barW, barH);
    ctx.fillStyle = '#f9cc2b'; ctx.fillRect(baseX, yOff, barW * (st.rage / st.rageMax), barH);
  }
  // non-leader skill icons
  nonSkillRects = [];
  st.players.forEach((p, idx) => {
    if(idx === st.leader) return;
    // base position above player head for skill icons
    const iconR = 10;
    let xPos = p.x - (iconR * 6) + 2;
    const yPos = p.y - 66;
    ['S1','S2','S3'].forEach((key, k) => {
      const cd = st.cds[p.id][key] || 0;
      const ready = cd <= 0;
      const cx = xPos + k * (iconR*2 + 6);
      const cy = yPos;
      // store rect for click detection
      nonSkillRects.push({pIndex: idx, key, x: cx - iconR, y: cy - iconR, w: iconR*2, h: iconR*2});
      // draw circular icon
      ctx.beginPath();
      ctx.arc(cx, cy, iconR, 0, Math.PI * 2);
      ctx.fillStyle = ready ? '#ffd56a' : '#394d6f';
      ctx.fill();
      // inner ring to show cooldown percent
      const pct = ready ? 1 : (1 - cd / CD[p.id][key]);
      ctx.beginPath();
      ctx.arc(cx, cy, iconR-3, -Math.PI/2, -Math.PI/2 + Math.PI*2 * pct);
      ctx.strokeStyle = ready ? '#ffe9a3' : '#566c8e';
      ctx.lineWidth = 2;
      ctx.stroke();
      // label (small number)
      ctx.fillStyle = '#0b1421';
      ctx.font = '9px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      const label = key === 'S1' ? '1' : key === 'S2' ? '2' : '3';
      ctx.fillText(label, cx, cy);
    });
  });

  // Draw small rage bars above non-leader heroes if enabled by configuration.
  if(PATCH.ui.showRageAboveNonLeaders){
    drawRageOverheads();
  }
  // enemies
  for(const e of st.enemies){
    let color;
    if(e.kind === 'mob'){
      color = '#ff6e6e';
    } else if(e.kind && e.kind.startsWith('boss')){
      color = '#ffa566';
    } else {
      // chest boss or other special enemy
      color = '#ffd56a';
    }
    ctx.fillStyle = color;
    const w = (e.kind === 'mob' ? 34 : 56);
    const h = (e.kind === 'mob' ? 40 : 60);
    ctx.fillRect(e.x - 18, e.y - 28, w, h);
  }
  // shots
  ctx.fillStyle='#9ad1ff'; for(const s of st.shots){ ctx.fillRect(s.x-3,s.y-2,6,4); }
  ctx.fillStyle='#ffb18b'; for(const b of st.eShots){ ctx.fillRect(b.x-3,b.y-2,6,4); }
  // pickups
  for(const it of st.pickups){ ctx.fillStyle = it.kind==='coin' ? '#ffd56a' : '#ff8c6a'; ctx.fillRect(it.x-5,it.y-5,10,10); }

  // floating damage/resource text
  for(const ef of st.effects){
    const alpha = Math.max(0, ef.life / 800);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = ef.color;
    ctx.font = '12px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(ef.txt, ef.x, ef.y);
    ctx.globalAlpha = 1;
  }
}

// Draw small Rage bars above non-leader heroes.  Uses the global Rage value from st.rage and
// st.rageMax.  These bars provide quick feedback on Rage accumulation for party members
// that are not currently controlled by the player.  Configurable via PATCH.ui.showRageAboveNonLeaders.
function drawRageOverheads(){
  const max = st.rageMax || PATCH.systems.rage.max;
  const ratio = max > 0 ? Math.max(0, Math.min(1, st.rage / max)) : 0;
  const barW = 36;
  const barH = 4;
  st.players.forEach((p, idx) => {
    if(idx === st.leader) return;
    const x = p.x - barW/2;
    const y = p.y - 62;
    // background
    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(x, y, barW, barH);
    // fill
    ctx.fillStyle = '#f9cc2b';
    ctx.fillRect(x, y, barW * ratio, barH);
  });
}
</script>
</body>
</html>
