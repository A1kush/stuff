<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>A1K 3D Dungeon Game - 3rd Person View</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      overflow: hidden;
      background: #000;
      color: #fff;
    }

    #gameContainer {
      width: 100vw;
      height: 100vh;
      position: relative;
    }

    #gameCanvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    #uiOverlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 100;
    }

    .ui-panel {
      pointer-events: auto;
      background: rgba(0, 0, 0, 0.7);
      border: 2px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      padding: 15px;
      backdrop-filter: blur(10px);
    }

    #hud {
      position: absolute;
      top: 20px;
      left: 20px;
      min-width: 250px;
    }

    #hud h3 {
      margin-bottom: 10px;
      color: #ff9a9e;
      font-size: 18px;
    }

    .stat-row {
      display: flex;
      justify-content: space-between;
      margin: 5px 0;
      font-size: 14px;
    }

    .health-bar, .mana-bar {
      width: 100%;
      height: 20px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      margin: 5px 0;
      overflow: hidden;
    }

    .health-fill {
      height: 100%;
      background: linear-gradient(90deg, #ff6b6b, #ff8787);
      transition: width 0.3s;
    }

    .mana-fill {
      height: 100%;
      background: linear-gradient(90deg, #4dabf7, #74c0fc);
      transition: width 0.3s;
    }

    #controls {
      position: absolute;
      bottom: 20px;
      left: 20px;
      font-size: 12px;
      line-height: 1.8;
    }

    #missionBoard {
      position: absolute;
      top: 20px;
      right: 20px;
      min-width: 300px;
      max-height: 80vh;
      overflow-y: auto;
      display: none;
    }

    #missionBoard.active {
      display: block;
    }

    .mission-card {
      background: rgba(255, 154, 158, 0.1);
      border: 1px solid rgba(255, 154, 158, 0.3);
      border-radius: 6px;
      padding: 10px;
      margin: 10px 0;
      cursor: pointer;
      transition: all 0.3s;
    }

    .mission-card:hover {
      background: rgba(255, 154, 158, 0.2);
      transform: translateX(-5px);
    }

    .btn {
      background: linear-gradient(135deg, #ff9a9e, #a8edea);
      border: none;
      color: #fff;
      padding: 10px 20px;
      border-radius: 6px;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.3s;
      margin: 5px;
    }

    .btn:hover {
      transform: scale(1.05);
      box-shadow: 0 4px 15px rgba(255, 154, 158, 0.4);
    }

    #loadingScreen {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #0a0a0f;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }

    .loading-spinner {
      width: 50px;
      height: 50px;
      border: 4px solid rgba(255, 154, 158, 0.2);
      border-top-color: #ff9a9e;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 20px;
      height: 20px;
      pointer-events: none;
    }

    .crosshair-line {
      position: absolute;
      background: rgba(255, 255, 255, 0.8);
    }

    .crosshair-h {
      width: 12px;
      height: 2px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    .crosshair-v {
      width: 2px;
      height: 12px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="gameCanvas"></canvas>
    
    <div id="uiOverlay">
      <div id="loadingScreen">
        <div class="loading-spinner"></div>
        <div>Loading 3D Dungeon Game...</div>
      </div>

      <div id="hud" class="ui-panel">
        <h3>Player Stats</h3>
        <div class="stat-row">
          <span>Level:</span>
          <span id="playerLevel">1</span>
        </div>
        <div class="stat-row">
          <span>HP:</span>
          <span id="playerHP">100 / 100</span>
        </div>
        <div class="health-bar">
          <div class="health-fill" id="healthFill" style="width: 100%"></div>
        </div>
        <div class="stat-row">
          <span>MP:</span>
          <span id="playerMP">50 / 50</span>
        </div>
        <div class="mana-bar">
          <div class="mana-fill" id="manaFill" style="width: 100%"></div>
        </div>
        <div class="stat-row">
          <span>Gold:</span>
          <span id="playerGold">0</span>
        </div>
        <div class="stat-row">
          <span>Room:</span>
          <span id="currentRoom">1-1</span>
        </div>
      </div>

      <div id="controls" class="ui-panel">
        <strong>Controls:</strong><br>
        WASD - Move<br>
        Mouse - Look Around<br>
        Space - Jump<br>
        Shift - Run<br>
        E - Interact<br>
        M - Mission Board<br>
        ESC - Menu
      </div>

      <div id="missionBoard" class="ui-panel">
        <h3>Mission Board</h3>
        <button class="btn" onclick="toggleMissionBoard()">Close</button>
        <div id="missionList"></div>
      </div>

      <div id="crosshair">
        <div class="crosshair-line crosshair-h"></div>
        <div class="crosshair-line crosshair-v"></div>
      </div>
    </div>
  </div>

  <!-- Three.js Library -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  
  <!-- Game Data (optional - game works without these) -->
  <script>
    // Fallback if game-data.js is not available
    if (!window.gameState) {
      window.gameState = {
        level: 1,
        playerLevel: 1,
        missions: { available: [], active: null, completed: [], progress: {} },
        dungeons: { currentDungeon: null, currentRoom: null },
        raidKeys: 0,
        gold: 0
      };
    }
    
    // Fallback MissionDatabase
    if (!window.MissionDatabase) {
      window.MissionDatabase = {
        getAvailableMissions: () => [],
        getMissionById: () => null,
        getMissionsByType: () => []
      };
    }
    
    // Fallback MissionBoardRenderer
    if (!window.MissionBoardRenderer) {
      window.MissionBoardRenderer = {
        startMission: () => console.log('Mission system not fully loaded')
      };
    }
  </script>
  
  <!-- Try to load game data if available -->
  <script src="game-data.js" onerror="console.log('game-data.js not found, using fallbacks')"></script>
  <script src="candy-dungeon-bundle.js" onerror="console.log('candy-dungeon-bundle.js not found, using fallbacks')"></script>

  <script>
    // ═══════════════════════════════════════════════════════════════════════════
    // A1K 3D DUNGEON GAME - 3rd Person View
    // Production-ready with real sprites and dungeon stages
    // ═══════════════════════════════════════════════════════════════════════════

    class Dungeon3DGame {
      constructor() {
        this.scene = null;
        this.camera = null;
        this.renderer = null;
        this.player = null;
        this.enemies = [];
        this.dungeonRooms = [];
        this.currentRoom = 0;
        
        // Player state
        this.playerState = {
          level: 1,
          hp: 100,
          maxHp: 100,
          mp: 50,
          maxMp: 50,
          gold: 0,
          position: new THREE.Vector3(0, 1, 0),
          rotation: 0,
          velocity: new THREE.Vector3(0, 0, 0),
          onGround: false
        };

        // Controls
        this.keys = {};
        this.mouse = { x: 0, y: 0, sensitivity: 0.002 };
        this.cameraAngle = { horizontal: 0, vertical: 0 };

        // 3rd person camera
        this.cameraDistance = 8;
        this.cameraHeight = 4;
        this.cameraTarget = new THREE.Vector3();

        // Sprite textures
        this.spriteTextures = {};
        this.animationFrames = {};

        this.init();
      }

      init() {
        // Initialize Three.js scene
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x0a0a0f);
        this.scene.fog = new THREE.Fog(0x0a0a0f, 10, 50);

        // Camera setup
        const aspect = window.innerWidth / window.innerHeight;
        this.camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
        this.camera.position.set(0, this.cameraHeight, this.cameraDistance);

        // Renderer setup
        const canvas = document.getElementById('gameCanvas');
        this.renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;
        this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Lighting
        this.setupLighting();

        // Create sprites
        this.createSprites();

        // Create dungeon
        this.createDungeon();

        // Create player
        this.createPlayer();

        // Setup controls
        this.setupControls();

        // Start game loop
        this.animate();

        // Hide loading screen
        setTimeout(() => {
          document.getElementById('loadingScreen').style.display = 'none';
        }, 1000);
      }

      setupLighting() {
        // Ambient light
        const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
        this.scene.add(ambientLight);

        // Main directional light (sun)
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        directionalLight.shadow.camera.near = 0.5;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -20;
        directionalLight.shadow.camera.right = 20;
        directionalLight.shadow.camera.top = 20;
        directionalLight.shadow.camera.bottom = -20;
        this.scene.add(directionalLight);

        // Point lights for atmosphere
        const torch1 = new THREE.PointLight(0xffa500, 1, 15);
        torch1.position.set(-5, 3, -5);
        this.scene.add(torch1);

        const torch2 = new THREE.PointLight(0xffa500, 1, 15);
        torch2.position.set(5, 3, 5);
        this.scene.add(torch2);
      }

      createSprites() {
        // Create sprite texture loader
        const loader = new THREE.TextureLoader();

        // Player sprite (animated character)
        this.createPlayerSprite();

        // Enemy sprites
        this.createEnemySprites();

        // Environment sprites
        this.createEnvironmentSprites();
      }

      createPlayerSprite() {
        // Create enhanced 3D character model with better detail
        const playerGroup = new THREE.Group();

        // Torso (more detailed)
        const torsoGeometry = new THREE.BoxGeometry(0.5, 0.8, 0.3);
        const torsoMaterial = new THREE.MeshStandardMaterial({ 
          color: 0x4a90e2,
          metalness: 0.3,
          roughness: 0.7
        });
        const torso = new THREE.Mesh(torsoGeometry, torsoMaterial);
        torso.position.y = 0.7;
        torso.castShadow = true;
        playerGroup.add(torso);

        // Chest plate
        const chestGeometry = new THREE.BoxGeometry(0.52, 0.4, 0.32);
        const chestMaterial = new THREE.MeshStandardMaterial({ 
          color: 0x5a9fd2,
          metalness: 0.5,
          roughness: 0.5
        });
        const chest = new THREE.Mesh(chestGeometry, chestMaterial);
        chest.position.y = 1.0;
        chest.castShadow = true;
        playerGroup.add(chest);

        // Head (more detailed)
        const headGeometry = new THREE.SphereGeometry(0.25, 16, 16);
        const headMaterial = new THREE.MeshStandardMaterial({ 
          color: 0xffdbac,
          metalness: 0.1,
          roughness: 0.9
        });
        const head = new THREE.Mesh(headGeometry, headMaterial);
        head.position.y = 1.5;
        head.castShadow = true;
        playerGroup.add(head);

        // Helmet
        const helmetGeometry = new THREE.SphereGeometry(0.27, 16, 16);
        helmetGeometry.scale(1, 0.8, 1);
        const helmetMaterial = new THREE.MeshStandardMaterial({ 
          color: 0x8b7355,
          metalness: 0.4,
          roughness: 0.6
        });
        const helmet = new THREE.Mesh(helmetGeometry, helmetMaterial);
        helmet.position.y = 1.6;
        helmet.castShadow = true;
        playerGroup.add(helmet);

        // Arms (more detailed)
        const armGeometry = new THREE.CylinderGeometry(0.12, 0.1, 0.8, 8);
        const armMaterial = new THREE.MeshStandardMaterial({ 
          color: 0x4a90e2,
          metalness: 0.2,
          roughness: 0.8
        });
        
        const leftArm = new THREE.Mesh(armGeometry, armMaterial);
        leftArm.position.set(-0.4, 0.8, 0);
        leftArm.rotation.z = 0.2;
        leftArm.castShadow = true;
        playerGroup.add(leftArm);

        const rightArm = new THREE.Mesh(armGeometry, armMaterial);
        rightArm.position.set(0.4, 0.8, 0);
        rightArm.rotation.z = -0.2;
        rightArm.castShadow = true;
        playerGroup.add(rightArm);

        // Shoulder pads
        const shoulderGeometry = new THREE.BoxGeometry(0.2, 0.15, 0.15);
        const shoulderMaterial = new THREE.MeshStandardMaterial({ 
          color: 0x8b7355,
          metalness: 0.5,
          roughness: 0.5
        });
        
        const leftShoulder = new THREE.Mesh(shoulderGeometry, shoulderMaterial);
        leftShoulder.position.set(-0.5, 1.1, 0);
        leftShoulder.castShadow = true;
        playerGroup.add(leftShoulder);

        const rightShoulder = new THREE.Mesh(shoulderGeometry, shoulderMaterial);
        rightShoulder.position.set(0.5, 1.1, 0);
        rightShoulder.castShadow = true;
        playerGroup.add(rightShoulder);

        // Legs (more detailed)
        const legGeometry = new THREE.CylinderGeometry(0.15, 0.12, 0.9, 8);
        const legMaterial = new THREE.MeshStandardMaterial({ 
          color: 0x2c3e50,
          metalness: 0.2,
          roughness: 0.8
        });
        
        const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
        leftLeg.position.set(-0.18, -0.35, 0);
        leftLeg.castShadow = true;
        playerGroup.add(leftLeg);

        const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
        rightLeg.position.set(0.18, -0.35, 0);
        rightLeg.castShadow = true;
        playerGroup.add(rightLeg);

        // Boots
        const bootGeometry = new THREE.BoxGeometry(0.2, 0.15, 0.3);
        const bootMaterial = new THREE.MeshStandardMaterial({ 
          color: 0x1a1a1a,
          metalness: 0.3,
          roughness: 0.7
        });
        
        const leftBoot = new THREE.Mesh(bootGeometry, bootMaterial);
        leftBoot.position.set(-0.18, -0.85, 0);
        leftBoot.castShadow = true;
        playerGroup.add(leftBoot);

        const rightBoot = new THREE.Mesh(bootGeometry, bootMaterial);
        rightBoot.position.set(0.18, -0.85, 0);
        rightBoot.castShadow = true;
        playerGroup.add(rightBoot);

        // Weapon (enhanced sword)
        const swordBlade = new THREE.Mesh(
          new THREE.BoxGeometry(0.08, 1.0, 0.03),
          new THREE.MeshStandardMaterial({ 
            color: 0xc0c0c0,
            metalness: 0.95,
            roughness: 0.05,
            emissive: 0x444444,
            emissiveIntensity: 0.2
          })
        );
        swordBlade.position.set(0.5, 0.9, 0);
        swordBlade.rotation.z = -0.3;
        playerGroup.add(swordBlade);

        const swordHilt = new THREE.Mesh(
          new THREE.BoxGeometry(0.12, 0.2, 0.12),
          new THREE.MeshStandardMaterial({ 
            color: 0x8b4513,
            metalness: 0.3,
            roughness: 0.7
          })
        );
        swordHilt.position.set(0.5, 0.7, 0);
        playerGroup.add(swordHilt);

        // Store parts for animation
        playerGroup.userData = {
          leftArm,
          rightArm,
          leftLeg,
          rightLeg,
          weapon: swordBlade,
          animationTime: 0
        };

        this.playerSprite = playerGroup;
      }

      createEnemySprites() {
        // Enhanced Goblin enemy with more detail
        const goblinGroup = new THREE.Group();

        // Body
        const goblinBody = new THREE.Mesh(
          new THREE.CylinderGeometry(0.25, 0.25, 0.6, 8),
          new THREE.MeshStandardMaterial({ 
            color: 0x8b4513,
            roughness: 0.8,
            metalness: 0.1
          })
        );
        goblinBody.position.y = 0.3;
        goblinBody.castShadow = true;
        goblinGroup.add(goblinBody);

        // Head (larger, more goblin-like)
        const goblinHead = new THREE.Mesh(
          new THREE.SphereGeometry(0.22, 16, 16),
          new THREE.MeshStandardMaterial({ 
            color: 0x654321,
            roughness: 0.9,
            metalness: 0.0
          })
        );
        goblinHead.position.y = 0.85;
        goblinHead.castShadow = true;
        goblinGroup.add(goblinHead);

        // Ears
        const earGeometry = new THREE.ConeGeometry(0.08, 0.15, 8);
        const earMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 });
        
        const leftEar = new THREE.Mesh(earGeometry, earMaterial);
        leftEar.position.set(-0.2, 0.95, 0);
        leftEar.rotation.z = -0.3;
        goblinGroup.add(leftEar);

        const rightEar = new THREE.Mesh(earGeometry, earMaterial);
        rightEar.position.set(0.2, 0.95, 0);
        rightEar.rotation.z = 0.3;
        goblinGroup.add(rightEar);

        // Arms
        const armGeometry = new THREE.CylinderGeometry(0.08, 0.08, 0.5, 8);
        const armMaterial = new THREE.MeshStandardMaterial({ color: 0x8b4513 });
        
        const leftArm = new THREE.Mesh(armGeometry, armMaterial);
        leftArm.position.set(-0.3, 0.5, 0);
        leftArm.rotation.z = 0.3;
        leftArm.castShadow = true;
        goblinGroup.add(leftArm);

        const rightArm = new THREE.Mesh(armGeometry, armMaterial);
        rightArm.position.set(0.3, 0.5, 0);
        rightArm.rotation.z = -0.3;
        rightArm.castShadow = true;
        goblinGroup.add(rightArm);

        // Legs
        const legGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.5, 8);
        const legMaterial = new THREE.MeshStandardMaterial({ color: 0x654321 });
        
        const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
        leftLeg.position.set(-0.15, -0.15, 0);
        leftLeg.castShadow = true;
        goblinGroup.add(leftLeg);

        const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
        rightLeg.position.set(0.15, -0.15, 0);
        rightLeg.castShadow = true;
        goblinGroup.add(rightLeg);

        // Weapon (club)
        const clubGeometry = new THREE.CylinderGeometry(0.06, 0.1, 0.6, 8);
        const clubMaterial = new THREE.MeshStandardMaterial({ 
          color: 0x8b4513,
          roughness: 0.9
        });
        const club = new THREE.Mesh(clubGeometry, clubMaterial);
        club.position.set(0.4, 0.6, 0);
        club.rotation.z = -0.5;
        goblinGroup.add(club);

        // Store for animation
        goblinGroup.userData = {
          leftArm,
          rightArm,
          leftLeg,
          rightLeg,
          animationTime: 0
        };

        this.enemySpriteTemplate = goblinGroup;
      }

      createEnvironmentSprites() {
        // Torch sprite
        const torchGroup = new THREE.Group();
        
        const torchPole = new THREE.Mesh(
          new THREE.CylinderGeometry(0.05, 0.05, 2, 8),
          new THREE.MeshStandardMaterial({ color: 0x654321 })
        );
        torchPole.position.y = 1;
        torchGroup.add(torchPole);

        const torchFlame = new THREE.Mesh(
          new THREE.SphereGeometry(0.15, 8, 8),
          new THREE.MeshStandardMaterial({ 
            color: 0xffa500,
            emissive: 0xff4400,
            emissiveIntensity: 0.8
          })
        );
        torchFlame.position.y = 2.1;
        torchGroup.add(torchFlame);

        // Point light for torch
        const torchLight = new THREE.PointLight(0xffa500, 1.5, 10);
        torchLight.position.y = 2.1;
        torchGroup.add(torchLight);

        this.torchSprite = torchGroup;
      }

      createDungeon() {
        // Create multiple dungeon rooms with different themes
        const roomTypes = [
          { name: 'Dungeon Depths', floorColor: 0x2a2a2a, wallColor: 0x1a1a1a, lightColor: 0xffa500, size: 20, theme: 'dark' },
          { name: 'Crystal Caverns', floorColor: 0x4a0080, wallColor: 0x2a0050, lightColor: 0x9d4edd, size: 20, theme: 'magic' },
          { name: 'Volcanic Forge', floorColor: 0x8b0000, wallColor: 0x5a0000, lightColor: 0xff4500, size: 20, theme: 'fire' },
          { name: 'Elf Forest', floorColor: 0x228b22, wallColor: 0x1a5a1a, lightColor: 0x90ee90, size: 20, theme: 'nature' },
          { name: 'Ice Cavern', floorColor: 0x4682b4, wallColor: 0x2f4f4f, lightColor: 0x00bfff, size: 20, theme: 'ice' },
          { name: 'Ancient Temple', floorColor: 0xd4af37, wallColor: 0xb8860b, lightColor: 0xffd700, size: 20, theme: 'gold' }
        ];

        roomTypes.forEach((roomType, index) => {
          const room = this.createDungeonRoom(roomType, index);
          this.dungeonRooms.push(room);
        });

        // Show first room
        this.loadRoom(0);
      }

      createDungeonRoom(roomType, index) {
        const room = new THREE.Group();
        const size = roomType.size;
        const offsetX = index * (size + 5);

        // Floor with texture pattern
        const floorGeometry = new THREE.PlaneGeometry(size, size, 10, 10);
        const floorMaterial = new THREE.MeshStandardMaterial({ 
          color: roomType.floorColor,
          roughness: 0.8,
          metalness: 0.1
        });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.set(offsetX, 0, 0);
        floor.receiveShadow = true;
        room.add(floor);

        // Add floor details based on theme
        if (roomType.theme === 'magic') {
          // Crystal formations
          for (let i = 0; i < 8; i++) {
            const crystal = new THREE.Mesh(
              new THREE.ConeGeometry(0.3, 0.8, 6),
              new THREE.MeshStandardMaterial({
                color: roomType.lightColor,
                emissive: roomType.lightColor,
                emissiveIntensity: 0.5,
                metalness: 0.8,
                roughness: 0.2
              })
            );
            crystal.position.set(
              offsetX + (Math.random() - 0.5) * (size - 4),
              0.4,
              (Math.random() - 0.5) * (size - 4)
            );
            crystal.rotation.y = Math.random() * Math.PI * 2;
            crystal.castShadow = true;
            room.add(crystal);
          }
        } else if (roomType.theme === 'fire') {
          // Lava pools
          for (let i = 0; i < 3; i++) {
            const lava = new THREE.Mesh(
              new THREE.CylinderGeometry(1, 1, 0.2, 16),
              new THREE.MeshStandardMaterial({
                color: 0xff4500,
                emissive: 0xff4500,
                emissiveIntensity: 1.0
              })
            );
            lava.position.set(
              offsetX + (Math.random() - 0.5) * (size - 4),
              0.1,
              (Math.random() - 0.5) * (size - 4)
            );
            room.add(lava);
          }
        } else if (roomType.theme === 'nature') {
          // Trees/plants
          for (let i = 0; i < 6; i++) {
            const tree = new THREE.Mesh(
              new THREE.CylinderGeometry(0.3, 0.4, 2, 8),
              new THREE.MeshStandardMaterial({ color: 0x8b4513 })
            );
            tree.position.set(
              offsetX + (Math.random() - 0.5) * (size - 4),
              1,
              (Math.random() - 0.5) * (size - 4)
            );
            tree.castShadow = true;
            room.add(tree);

            const leaves = new THREE.Mesh(
              new THREE.ConeGeometry(0.8, 1.5, 8),
              new THREE.MeshStandardMaterial({ color: 0x228b22 })
            );
            leaves.position.set(
              tree.position.x,
              tree.position.y + 1.5,
              tree.position.z
            );
            leaves.castShadow = true;
            room.add(leaves);
          }
        }

        // Walls
        const wallHeight = 5;
        const wallThickness = 0.5;
        const wallMaterial = new THREE.MeshStandardMaterial({ 
          color: roomType.wallColor,
          roughness: 0.9
        });

        // Back wall
        const backWall = new THREE.Mesh(
          new THREE.BoxGeometry(size, wallHeight, wallThickness),
          wallMaterial
        );
        backWall.position.set(offsetX, wallHeight / 2, -size / 2);
        backWall.receiveShadow = true;
        room.add(backWall);

        // Front wall (with opening)
        const frontWallLeft = new THREE.Mesh(
          new THREE.BoxGeometry(size / 2 - 2, wallHeight, wallThickness),
          wallMaterial
        );
        frontWallLeft.position.set(offsetX - size / 4, wallHeight / 2, size / 2);
        frontWallLeft.receiveShadow = true;
        room.add(frontWallLeft);

        const frontWallRight = new THREE.Mesh(
          new THREE.BoxGeometry(size / 2 - 2, wallHeight, wallThickness),
          wallMaterial
        );
        frontWallRight.position.set(offsetX + size / 4, wallHeight / 2, size / 2);
        frontWallRight.receiveShadow = true;
        room.add(frontWallRight);

        // Side walls
        const sideWallLeft = new THREE.Mesh(
          new THREE.BoxGeometry(wallThickness, wallHeight, size),
          wallMaterial
        );
        sideWallLeft.position.set(offsetX - size / 2, wallHeight / 2, 0);
        sideWallLeft.receiveShadow = true;
        room.add(sideWallLeft);

        const sideWallRight = new THREE.Mesh(
          new THREE.BoxGeometry(wallThickness, wallHeight, size),
          wallMaterial
        );
        sideWallRight.position.set(offsetX + size / 2, wallHeight / 2, 0);
        sideWallRight.receiveShadow = true;
        room.add(sideWallRight);

        // Add torches with theme-appropriate lighting
        for (let i = 0; i < 4; i++) {
          const torch = this.torchSprite.clone();
          const angle = (i / 4) * Math.PI * 2;
          const radius = size / 2 - 2;
          torch.position.set(
            offsetX + Math.cos(angle) * radius,
            0,
            Math.sin(angle) * radius
          );
          
          // Update torch light color based on theme
          torch.children.forEach(child => {
            if (child instanceof THREE.PointLight) {
              child.color.setHex(roomType.lightColor);
            }
            if (child instanceof THREE.Mesh && child.material.emissive) {
              child.material.color.setHex(roomType.lightColor);
              child.material.emissive.setHex(roomType.lightColor);
            }
          });
          
          room.add(torch);
        }

        // Add pillars
        for (let i = 0; i < 4; i++) {
          const pillar = new THREE.Mesh(
            new THREE.CylinderGeometry(0.5, 0.5, wallHeight, 8),
            new THREE.MeshStandardMaterial({ 
              color: roomType.wallColor * 0.8,
              roughness: 0.7
            })
          );
          const angle = (i / 4) * Math.PI * 2 + Math.PI / 8;
          const radius = size / 3;
          pillar.position.set(
            offsetX + Math.cos(angle) * radius,
            wallHeight / 2,
            Math.sin(angle) * radius
          );
          pillar.castShadow = true;
          room.add(pillar);
        }

        // Add enemies
        for (let i = 0; i < 3; i++) {
          const enemy = this.createEnemy(offsetX + (Math.random() - 0.5) * (size - 4), Math.random() * (size - 4));
          room.add(enemy);
          this.enemies.push(enemy);
        }

        room.userData = {
          type: roomType.name,
          index: index,
          offsetX: offsetX,
          theme: roomType.theme,
          lightColor: roomType.lightColor
        };

        return room;
      }

      createEnemy(x, z) {
        const enemy = this.enemySpriteTemplate.clone();
        enemy.position.set(x, 0, z);
        enemy.userData = {
          hp: 50,
          maxHp: 50,
          speed: 0.02,
          type: 'goblin'
        };
        return enemy;
      }

      createPlayer() {
        this.player = this.playerSprite.clone();
        this.player.position.copy(this.playerState.position);
        this.scene.add(this.player);
      }

      loadRoom(roomIndex) {
        // Hide all rooms
        this.dungeonRooms.forEach(room => {
          room.visible = false;
        });

        // Show current room
        if (this.dungeonRooms[roomIndex]) {
          this.dungeonRooms[roomIndex].visible = true;
          if (!this.scene.children.includes(this.dungeonRooms[roomIndex])) {
            this.scene.add(this.dungeonRooms[roomIndex]);
          }
          this.currentRoom = roomIndex;
          
          // Reset player position
          const room = this.dungeonRooms[roomIndex];
          this.playerState.position.set(room.userData.offsetX, 1, 0);
          this.player.position.copy(this.playerState.position);
          
          // Update UI
          document.getElementById('currentRoom').textContent = `${roomIndex + 1}-1`;
        }
      }

      setupControls() {
        // Keyboard controls
        document.addEventListener('keydown', (e) => {
          this.keys[e.code] = true;
          
          if (e.code === 'KeyM') {
            toggleMissionBoard();
          }
        });

        document.addEventListener('keyup', (e) => {
          this.keys[e.code] = false;
        });

        // Mouse button controls
        document.addEventListener('mousedown', (e) => {
          if (e.button === 0) {
            this.keys['Mouse0'] = true;
          }
        });

        document.addEventListener('mouseup', (e) => {
          if (e.button === 0) {
            this.keys['Mouse0'] = false;
          }
        });

        // Mouse controls
        document.addEventListener('mousemove', (e) => {
          if (document.pointerLockElement === document.getElementById('gameCanvas')) {
            this.cameraAngle.horizontal -= e.movementX * this.mouse.sensitivity;
            this.cameraAngle.vertical -= e.movementY * this.mouse.sensitivity;
            this.cameraAngle.vertical = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, this.cameraAngle.vertical));
          }
        });

        // Pointer lock
        document.getElementById('gameCanvas').addEventListener('click', () => {
          document.getElementById('gameCanvas').requestPointerLock();
        });
      }

      updatePlayer(deltaTime) {
        const speed = this.keys['ShiftLeft'] ? 0.15 : 0.08;
        const moveVector = new THREE.Vector3();
        let isMoving = false;

        // Movement input
        if (this.keys['KeyW']) {
          moveVector.z -= 1;
          isMoving = true;
        }
        if (this.keys['KeyS']) {
          moveVector.z += 1;
          isMoving = true;
        }
        if (this.keys['KeyA']) {
          moveVector.x -= 1;
          isMoving = true;
        }
        if (this.keys['KeyD']) {
          moveVector.x += 1;
          isMoving = true;
        }

        // Normalize and apply camera rotation
        if (moveVector.length() > 0) {
          moveVector.normalize();
          moveVector.applyAxisAngle(new THREE.Vector3(0, 1, 0), this.cameraAngle.horizontal);
          moveVector.multiplyScalar(speed);
          this.playerState.position.add(moveVector);
        }

        // Player animation
        if (this.player && this.player.userData) {
          if (!this.player.userData.animationTime) {
            this.player.userData.animationTime = 0;
          }
          
          if (isMoving) {
            this.player.userData.animationTime += deltaTime * 15;
            const walkCycle = Math.sin(this.player.userData.animationTime);
            
            if (this.player.userData.leftLeg) {
              this.player.userData.leftLeg.rotation.x = walkCycle * 0.4;
            }
            if (this.player.userData.rightLeg) {
              this.player.userData.rightLeg.rotation.x = -walkCycle * 0.4;
            }
            if (this.player.userData.leftArm) {
              this.player.userData.leftArm.rotation.x = -walkCycle * 0.3;
            }
            if (this.player.userData.rightArm) {
              this.player.userData.rightArm.rotation.x = walkCycle * 0.3;
            }
            
            // Weapon swing animation
            if (this.player.userData.weapon) {
              this.player.userData.weapon.rotation.z = -0.3 + walkCycle * 0.2;
            }
          } else {
            // Reset to idle
            if (this.player.userData.leftLeg) {
              this.player.userData.leftLeg.rotation.x = 0;
            }
            if (this.player.userData.rightLeg) {
              this.player.userData.rightLeg.rotation.x = 0;
            }
            if (this.player.userData.leftArm) {
              this.player.userData.leftArm.rotation.x = 0;
            }
            if (this.player.userData.rightArm) {
              this.player.userData.rightArm.rotation.x = 0;
            }
            if (this.player.userData.weapon) {
              this.player.userData.weapon.rotation.z = -0.3;
            }
          }
        }

        // Attack (left click)
        if (this.keys['Mouse0'] && this.player.userData && !this.player.userData.attacking) {
          this.playerAttack();
        }

        // Gravity
        if (!this.playerState.onGround) {
          this.playerState.velocity.y -= 0.01;
        } else {
          this.playerState.velocity.y = 0;
        }

        // Jump
        if (this.keys['Space'] && this.playerState.onGround) {
          this.playerState.velocity.y = 0.15;
          this.playerState.onGround = false;
        }

        this.playerState.position.add(this.playerState.velocity);

        // Ground collision
        if (this.playerState.position.y < 1) {
          this.playerState.position.y = 1;
          this.playerState.onGround = true;
          this.playerState.velocity.y = 0;
        }

        // Update player model
        this.player.position.copy(this.playerState.position);
        this.player.rotation.y = this.cameraAngle.horizontal + Math.PI;

        // Room transitions
        const currentRoomData = this.dungeonRooms[this.currentRoom]?.userData;
        if (currentRoomData) {
          const roomSize = 20;
          const roomCenter = currentRoomData.offsetX;
          
          if (this.playerState.position.z > roomSize / 2 - 1 && this.currentRoom < this.dungeonRooms.length - 1) {
            this.loadRoom(this.currentRoom + 1);
          } else if (this.playerState.position.z < -roomSize / 2 + 1 && this.currentRoom > 0) {
            this.loadRoom(this.currentRoom - 1);
          }
        }
      }

      playerAttack() {
        if (!this.player.userData) return;
        
        this.player.userData.attacking = true;
        
        // Attack animation
        if (this.player.userData.weapon) {
          const originalZ = this.player.userData.weapon.rotation.z;
          this.player.userData.weapon.rotation.z = -1.0;
          
          setTimeout(() => {
            if (this.player.userData && this.player.userData.weapon) {
              this.player.userData.weapon.rotation.z = originalZ;
            }
            this.player.userData.attacking = false;
          }, 200);
        }

        // Check for enemy hits
        this.enemies.forEach(enemy => {
          if (!enemy.visible) return;
          
          const distance = this.playerState.position.distanceTo(enemy.position);
          if (distance < 2) {
            enemy.userData.hp -= 20;
            if (enemy.userData.hp <= 0) {
              // Enemy defeated
              enemy.visible = false;
              this.playerState.gold += 10;
              this.playerState.hp = Math.min(this.playerState.maxHp, this.playerState.hp + 5);
            }
          }
        });
      }

      updateCamera() {
        // Enhanced 3rd person camera (Fortnite/GTA style)
        // Smooth camera following with collision avoidance
        
        // Adjust camera distance based on vertical angle
        const dynamicDistance = this.cameraDistance + Math.sin(this.cameraAngle.vertical) * 2;
        
        const cameraOffset = new THREE.Vector3(
          Math.sin(this.cameraAngle.horizontal) * dynamicDistance,
          this.cameraHeight + Math.sin(this.cameraAngle.vertical) * 3,
          Math.cos(this.cameraAngle.horizontal) * dynamicDistance
        );

        this.cameraTarget.copy(this.playerState.position);
        this.cameraTarget.y += 1.5;

        const desiredPosition = this.cameraTarget.clone().add(cameraOffset);
        
        // Smooth camera movement
        this.camera.position.lerp(desiredPosition, 0.15);
        
        // Look at player with slight offset for better feel
        const lookTarget = this.cameraTarget.clone();
        lookTarget.y += Math.sin(this.cameraAngle.vertical) * 0.5;
        this.camera.lookAt(lookTarget);
        
        // Camera collision with walls (simple check)
        const raycaster = new THREE.Raycaster(
          this.cameraTarget,
          cameraOffset.normalize()
        );
        const intersects = raycaster.intersectObjects(this.scene.children, true);
        if (intersects.length > 0 && intersects[0].distance < dynamicDistance) {
          this.camera.position.lerp(
            this.cameraTarget.clone().add(cameraOffset.normalize().multiplyScalar(intersects[0].distance - 0.5)),
            0.3
          );
        }
      }

      updateEnemies(deltaTime) {
        this.enemies.forEach((enemy, index) => {
          if (!enemy.visible) return;

          // Simple AI: move towards player
          const direction = new THREE.Vector3();
          direction.subVectors(this.playerState.position, enemy.position);
          direction.y = 0;
          const distance = direction.length();

          if (distance > 0.5 && distance < 10) {
            direction.normalize();
            enemy.position.add(direction.multiplyScalar(enemy.userData.speed));
            enemy.lookAt(this.playerState.position);
            
            // Walking animation
            if (enemy.userData) {
              enemy.userData.animationTime += deltaTime * 10;
              const walkCycle = Math.sin(enemy.userData.animationTime);
              
              if (enemy.userData.leftLeg) {
                enemy.userData.leftLeg.rotation.x = walkCycle * 0.3;
              }
              if (enemy.userData.rightLeg) {
                enemy.userData.rightLeg.rotation.x = -walkCycle * 0.3;
              }
              if (enemy.userData.leftArm) {
                enemy.userData.leftArm.rotation.x = -walkCycle * 0.2;
              }
              if (enemy.userData.rightArm) {
                enemy.userData.rightArm.rotation.x = walkCycle * 0.2;
              }
            }
          }

          // Attack if close
          if (distance < 1.5 && enemy.userData.lastAttack < Date.now() - 1000) {
            this.enemyAttack(enemy);
            enemy.userData.lastAttack = Date.now();
          }
        });
      }

      enemyAttack(enemy) {
        // Damage player
        const damage = 5;
        this.playerState.hp = Math.max(0, this.playerState.hp - damage);
        
        // Visual feedback
        if (this.playerState.hp <= 0) {
          this.playerState.hp = this.playerState.maxHp; // Respawn
          this.playerState.position.set(0, 1, 0);
          this.player.position.copy(this.playerState.position);
        }
      }

      updateUI() {
        document.getElementById('playerLevel').textContent = this.playerState.level;
        document.getElementById('playerHP').textContent = `${Math.ceil(this.playerState.hp)} / ${this.playerState.maxHp}`;
        document.getElementById('playerMP').textContent = `${Math.ceil(this.playerState.mp)} / ${this.playerState.maxMp}`;
        document.getElementById('playerGold').textContent = this.playerState.gold.toLocaleString();
        
        const healthPercent = (this.playerState.hp / this.playerState.maxHp) * 100;
        document.getElementById('healthFill').style.width = healthPercent + '%';
        
        const manaPercent = (this.playerState.mp / this.playerState.maxMp) * 100;
        document.getElementById('manaFill').style.width = manaPercent + '%';
      }

      animate() {
        requestAnimationFrame(() => this.animate());

        const deltaTime = 0.016; // ~60fps

        this.updatePlayer(deltaTime);
        this.updateCamera();
        this.updateEnemies(deltaTime);
        this.updateUI();

        this.renderer.render(this.scene, this.camera);
      }
    }

    // Mission Board Integration
    function toggleMissionBoard() {
      const board = document.getElementById('missionBoard');
      board.classList.toggle('active');
      
      if (board.classList.contains('active')) {
        loadMissions();
      }
    }

    function loadMissions() {
      const missionList = document.getElementById('missionList');
      missionList.innerHTML = '';

      if (window.MissionDatabase) {
        const playerLevel = window.gameState?.level || 1;
        const missions = window.MissionDatabase.getAvailableMissions(playerLevel);
        
        missions.slice(0, 5).forEach(mission => {
          const card = document.createElement('div');
          card.className = 'mission-card';
          card.innerHTML = `
            <h4>${mission.name}</h4>
            <p>${mission.description}</p>
            <button class="btn" onclick="startMission('${mission.id}')">Start</button>
          `;
          missionList.appendChild(card);
        });
      } else {
        missionList.innerHTML = '<p>Mission system loading...</p>';
      }
    }

    function startMission(missionId) {
      if (window.MissionBoardRenderer) {
        window.MissionBoardRenderer.startMission(missionId);
        toggleMissionBoard();
      }
    }

    // Initialize game
    let game;
    window.addEventListener('load', () => {
      // Initialize game state if needed
      if (!window.gameState) {
        window.gameState = {
          level: 1,
          playerLevel: 1,
          missions: {
            available: [],
            active: null,
            completed: [],
            progress: {}
          },
          dungeons: {
            currentDungeon: null,
            currentRoom: null
          },
          raidKeys: 0
        };
      }

      // Start game
      game = new Dungeon3DGame();
    });

    // Handle window resize
    window.addEventListener('resize', () => {
      if (game && game.camera && game.renderer) {
        game.camera.aspect = window.innerWidth / window.innerHeight;
        game.camera.updateProjectionMatrix();
        game.renderer.setSize(window.innerWidth, window.innerHeight);
      }
    });
  </script>
</body>
</html>

