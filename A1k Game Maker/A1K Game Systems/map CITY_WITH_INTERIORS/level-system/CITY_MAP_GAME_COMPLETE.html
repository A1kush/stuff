<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>üéÆ City Map Game - Complete with Interiors & Casino</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #0a0a12;
      color: #fff;
      overflow: hidden;
    }

    #gameCanvas {
      display: block;
      background: #0b0f17;
      image-rendering: -webkit-optimize-contrast;
      /* Edge 79+ */
      image-rendering: pixelated;
      /* Standard */
      image-rendering: crisp-edges;
      /* Firefox, Safari */
      cursor: crosshair;
    }

    .ui-overlay {
      position: fixed;
      pointer-events: none;
    }

    .ui-overlay>* {
      pointer-events: auto;
    }

    /* Top Bar */
    .top-bar {
      top: 0;
      left: 0;
      right: 0;
      background: rgba(0, 0, 0, 0.9);
      padding: 12px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      border-bottom: 2px solid #fbbf24;
      z-index: 100;
    }

    .zone-display {
      font-size: 1.3rem;
      font-weight: bold;
      color: #fbbf24;
    }

    .stats-display {
      display: flex;
      gap: 20px;
    }

    .stat {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    /* Top Bar Buttons */
    .top-bar-btn {
      background: linear-gradient(135deg, rgba(79, 195, 247, 0.2), rgba(79, 195, 247, 0.1));
      border: 2px solid rgba(79, 195, 247, 0.4);
      border-radius: 8px;
      color: #fff;
      padding: 8px 12px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 16px;
      min-width: 44px;
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .top-bar-btn:hover {
      background: linear-gradient(135deg, rgba(79, 195, 247, 0.4), rgba(79, 195, 247, 0.2));
      border-color: rgba(79, 195, 247, 0.7);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(79, 195, 247, 0.4);
    }

    .top-bar-btn:active {
      transform: translateY(0);
    }

    /* Menu Panel */
    .menu-panel {
      position: fixed;
      top: 70px;
      right: 20px;
      background: rgba(15, 24, 38, 0.98);
      border: 2px solid rgba(79, 195, 247, 0.5);
      border-radius: 12px;
      padding: 20px;
      min-width: 280px;
      z-index: 200;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
      display: none;
    }

    .menu-panel.active {
      display: block;
      animation: slideDown 0.3s ease-out;
    }

    @keyframes slideDown {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .menu-title {
      font-size: 18px;
      color: #fbbf24;
      font-weight: 700;
      margin-bottom: 16px;
      border-bottom: 2px solid rgba(79, 195, 247, 0.3);
      padding-bottom: 8px;
    }

    .menu-item {
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(79, 195, 247, 0.3);
      border-radius: 6px;
      padding: 12px;
      margin-bottom: 8px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 14px;
    }

    .menu-item:hover {
      background: rgba(79, 195, 247, 0.2);
      border-color: rgba(79, 195, 247, 0.6);
      transform: translateX(4px);
    }

    .menu-item-icon {
      font-size: 20px;
      width: 30px;
      text-align: center;
    }

    /* Settings Panel */
    .settings-panel {
      position: fixed;
      top: 70px;
      right: 20px;
      background: rgba(15, 24, 38, 0.98);
      border: 2px solid rgba(167, 139, 250, 0.5);
      border-radius: 12px;
      padding: 20px;
      min-width: 320px;
      max-width: 400px;
      z-index: 200;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.6);
      display: none;
    }

    .settings-panel.active {
      display: block;
      animation: slideDown 0.3s ease-out;
    }

    .settings-group {
      margin-bottom: 16px;
    }

    .settings-label {
      font-size: 12px;
      color: rgba(207, 227, 255, 0.8);
      margin-bottom: 6px;
      display: block;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .settings-slider {
      width: 100%;
      height: 6px;
      background: rgba(0, 0, 0, 0.5);
      border-radius: 3px;
      outline: none;
      cursor: pointer;
    }

    .settings-toggle {
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(79, 195, 247, 0.3);
      border-radius: 6px;
      padding: 8px 12px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .settings-toggle:hover {
      background: rgba(79, 195, 247, 0.1);
      border-color: rgba(79, 195, 247, 0.5);
    }

    .toggle-switch {
      width: 40px;
      height: 20px;
      background: rgba(255, 59, 59, 0.5);
      border-radius: 10px;
      position: relative;
      transition: background 0.3s ease;
    }

    .toggle-switch.on {
      background: rgba(56, 239, 125, 0.5);
    }

    .toggle-switch-handle {
      width: 16px;
      height: 16px;
      background: white;
      border-radius: 50%;
      position: absolute;
      top: 2px;
      left: 2px;
      transition: left 0.3s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .toggle-switch.on .toggle-switch-handle {
      left: 22px;
    }

    /* Tiny Event Log (Top, below top bar) */
    .tiny-log {
      position: fixed;
      top: 55px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      padding: 4px 15px;
      border-radius: 4px;
      font-size: 10px;
      font-family: 'Courier New', monospace;
      color: #10b981;
      z-index: 99;
      max-width: 500px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      transition: opacity 0.3s;
      opacity: 0;
    }

    .tiny-log.show {
      opacity: 1;
    }

    /* Character Panels */
    .character-panels {
      top: 105px;
      left: 20px;
      display: none; /* Hidden by default, toggle from menu */
      flex-direction: column;
      gap: 8px;
      z-index: 90;
    }

    .character-panels.active {
      display: flex;
    }

    .character-panel {
      background: rgba(0, 0, 0, 0.85);
      border: 2px solid #10b981;
      border-radius: 6px;
      padding: 10px;
      width: 220px;
      transition: all 0.3s;
    }

    .character-panel.selected {
      border-color: #fbbf24;
      box-shadow: 0 0 15px rgba(251, 191, 36, 0.4);
    }

    .char-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
    }

    .char-name {
      font-weight: bold;
      font-size: 1rem;
    }

    .char-level {
      color: #10b981;
      font-size: 0.85rem;
    }

    .hp-bar {
      background: #374151;
      height: 6px;
      border-radius: 3px;
      overflow: hidden;
      margin: 4px 0;
    }

    .hp-fill {
      background: linear-gradient(90deg, #ef4444, #f87171);
      height: 100%;
      transition: width 0.3s;
    }

    .char-style {
      font-size: 0.75rem;
      color: #9ca3af;
      margin-top: 4px;
    }

    /* Controls Hint */
    .controls-hint {
      bottom: 20px;
      left: 20px;
      background: rgba(0, 0, 0, 0.85);
      border: 2px solid #6366f1;
      border-radius: 8px;
      padding: 12px;
      font-size: 0.85rem;
      z-index: 90;
      display: none; /* Hidden by default, toggle from menu */
    }

    .controls-hint.active {
      display: block;
    }

    .controls-hint h4 {
      color: #fbbf24;
      margin-bottom: 6px;
    }

    .control-line {
      margin: 2px 0;
      color: #d1d5db;
    }

    .key {
      background: #374151;
      padding: 2px 6px;
      border-radius: 3px;
      border: 1px solid #4b5563;
      font-weight: bold;
      color: #10b981;
    }

    /* Minimap */
    .minimap {
      top: 105px;
      right: 20px;
      width: 260px;
      height: 130px;
      background: rgba(0, 0, 0, 0.85);
      border: 2px solid #6366f1;
      border-radius: 8px;
      padding: 10px;
      z-index: 90;
    }

    .minimap h4 {
      font-size: 0.85rem;
      color: #fbbf24;
      margin-bottom: 6px;
    }

    #minimapCanvas {
      width: 100%;
      height: 90px;
      border-radius: 4px;
    }

    /* Casino/Arcade Game Panel */
    .game-panel {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.95);
      border: 3px solid #fbbf24;
      border-radius: 12px;
      padding: 25px;
      min-width: 500px;
      max-width: 700px;
      z-index: 300;
      display: none;
    }

    .game-panel.show {
      display: block;
      animation: popIn 0.3s ease;
    }

    @keyframes popIn {
      from {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.8);
      }

      to {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
    }

    .game-title {
      font-size: 2rem;
      font-weight: bold;
      color: #fbbf24;
      text-align: center;
      margin-bottom: 20px;
    }

    .bet-slider-container {
      margin: 20px 0;
    }

    .bet-slider-label {
      display: flex;
      justify-content: space-between;
      margin-bottom: 10px;
      font-size: 1.1rem;
    }

    .bet-slider {
      width: 100%;
      height: 8px;
      background: #374151;
      border-radius: 4px;
      outline: none;
      -webkit-appearance: none;
      appearance: none;
    }

    .bet-slider::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 20px;
      height: 20px;
      background: #fbbf24;
      cursor: pointer;
      border-radius: 50%;
    }

    .bet-slider::-moz-range-thumb {
      width: 20px;
      height: 20px;
      background: #fbbf24;
      cursor: pointer;
      border-radius: 50%;
    }

    .game-area {
      background: rgba(0, 0, 0, 0.5);
      border-radius: 8px;
      padding: 30px;
      margin: 20px 0;
      text-align: center;
    }

    .rps-buttons {
      display: flex;
      justify-content: center;
      gap: 20px;
      margin: 20px 0;
    }

    .rps-button {
      background: linear-gradient(135deg, #10b981, #059669);
      border: none;
      border-radius: 8px;
      padding: 20px;
      font-size: 3rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .rps-button:hover {
      transform: scale(1.1);
      box-shadow: 0 5px 20px rgba(16, 185, 129, 0.5);
    }

    .rps-button:active {
      transform: scale(0.95);
    }

    .slot-reels {
      display: flex;
      justify-content: center;
      gap: 15px;
      margin: 20px 0;
    }

    .slot-reel {
      background: #1f2937;
      border: 3px solid #fbbf24;
      border-radius: 8px;
      width: 100px;
      height: 120px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 4rem;
      animation: spin 0.5s ease;
    }

    @keyframes spin {

      0%,
      100% {
        transform: rotateX(0deg);
      }

      50% {
        transform: rotateX(180deg);
      }
    }

    .game-result {
      font-size: 1.8rem;
      font-weight: bold;
      margin: 20px 0;
      padding: 15px;
      border-radius: 8px;
    }

    .game-result.win {
      background: rgba(16, 185, 129, 0.3);
      color: #10b981;
    }

    .game-result.lose {
      background: rgba(239, 68, 68, 0.3);
      color: #ef4444;
    }

    .game-result.tie {
      background: rgba(251, 191, 36, 0.3);
      color: #fbbf24;
    }

    .action-button {
      background: linear-gradient(135deg, #10b981, #059669);
      color: white;
      border: none;
      padding: 12px 25px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 1.1rem;
      font-weight: bold;
      margin: 5px;
      transition: all 0.2s;
    }

    .action-button:hover {
      transform: scale(1.05);
      box-shadow: 0 5px 15px rgba(16, 185, 129, 0.4);
    }

    .action-button.secondary {
      background: linear-gradient(135deg, #6366f1, #4f46e5);
    }

    .action-button.close {
      background: linear-gradient(135deg, #ef4444, #dc2626);
    }

    .action-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    /* Interior View Indicator */
    .interior-indicator {
      position: fixed;
      top: 75px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(239, 68, 68, 0.9);
      color: white;
      padding: 8px 20px;
      border-radius: 20px;
      font-weight: bold;
      font-size: 0.9rem;
      z-index: 95;
      display: none;
    }

    .interior-indicator.show {
      display: block;
    }

    /* Toast Notification */
    .toast {
      position: fixed;
      bottom: 30px;
      right: 30px;
      background: rgba(0, 0, 0, 0.95);
      color: #10b981;
      padding: 12px 20px;
      border-radius: 6px;
      border: 2px solid #10b981;
      font-weight: bold;
      z-index: 9999;
      animation: toastIn 0.3s ease;
    }

    @keyframes toastIn {
      from {
        opacity: 0;
        transform: translateX(100px);
      }

      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    /* ===== HUD CANDY INTEGRATION ===== */
    #hud-wrap {
      position: fixed;
      inset: auto 0 0 0;
      padding: 10px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      pointer-events: none;
      z-index: 100;
    }

    #hud-left {
      pointer-events: auto;
      justify-self: start;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 11px;
      margin-left: 28px;
    }

    #hud-right {
      pointer-events: auto;
      justify-self: end;
      display: grid;
      grid-template-rows: auto auto;
      gap: 7px;
      align-content: end;
      margin-right: 103px;
      margin-bottom: 28px;
    }

    /* Joystick - Candy Style (30% smaller) */
    #vj-root {
      width: 98px;
      height: 98px;
      position: relative;
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
      filter: drop-shadow(0 6px 14px rgba(0, 0, 0, 0.4));
    }

    #vj-base {
      position: absolute;
      inset: 0;
      margin: auto;
      width: 83px;
      height: 83px;
      border-radius: 50%;
      background: radial-gradient(circle at 35% 25%, rgba(255, 255, 255, 0.15), rgba(122, 213, 255, 0.08), rgba(0, 0, 0, 0.4));
      border: 2px solid rgba(122, 213, 255, 0.35);
      box-shadow: 
        inset 0 2px 8px rgba(0, 0, 0, 0.3),
        inset 0 -1px 7px rgba(122, 213, 255, 0.25),
        inset 0 1px 1px rgba(255, 255, 255, 0.4),
        0 0 17px rgba(122, 213, 255, 0.2);
    }

    #vj-knob {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 39px;
      height: 39px;
      margin-left: -20px;
      margin-top: -20px;
      border-radius: 50%;
      background: radial-gradient(circle at 35% 25%, rgba(255, 255, 255, 0.35), rgba(122, 213, 255, 0.25), rgba(167, 139, 250, 0.15));
      border: 2px solid rgba(122, 213, 255, 0.85);
      box-shadow: 
        0 4px 13px rgba(0, 0, 0, 0.4),
        0 0 20px rgba(122, 213, 255, 0.45),
        inset 0 1px 4px rgba(255, 255, 255, 0.45),
        inset 0 -2px 6px rgba(122, 213, 255, 0.3);
      transform: translate(0, 0);
      transition: transform 0.08s ease-out;
    }

    /* Utility Buttons - Candy Style (30% smaller) */
    .utility-stack {
      display: flex;
      flex-direction: column;
      gap: 7px;
      margin-bottom: 11px;
      justify-content: center;
      align-items: center;
    }

    .utility-row {
      display: flex;
      gap: 7px;
    }

    .utility-btn {
      padding: 7px 10px;
      border-radius: 999px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      background: radial-gradient(ellipse at 30% 20%, rgba(255, 255, 255, 0.28), rgba(255, 182, 255, 0.12), rgba(167, 139, 250, 0.15));
      color: #fff;
      font-weight: 800;
      letter-spacing: .03em;
      font-size: 9px;
      text-shadow: 0 1px 4px rgba(0, 0, 0, 0.5);
      box-shadow: 
        0 3px 11px rgba(0, 0, 0, 0.35),
        inset 0 1px 0 rgba(255, 255, 255, 0.4),
        inset 0 -1px 6px rgba(167, 139, 250, 0.3),
        0 0 14px rgba(255, 182, 255, 0.2);
      touch-action: manipulation;
      cursor: pointer;
      transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .utility-btn:hover {
      transform: translateY(-2px) scale(1.05);
      box-shadow: 
        0 6px 20px rgba(0, 0, 0, 0.4),
        inset 0 1px 0 rgba(255, 255, 255, 0.5),
        inset 0 -2px 10px rgba(167, 139, 250, 0.4),
        0 0 28px rgba(255, 182, 255, 0.35);
    }

    .utility-btn:active {
      transform: translateY(1px) scale(0.97);
      box-shadow: 
        0 2px 10px rgba(0, 0, 0, 0.3),
        inset 0 3px 10px rgba(0, 0, 0, 0.3),
        inset 0 -1px 4px rgba(255, 255, 255, 0.2);
    }

    /* Top row - Sky Candy */
    .utility-row.top .utility-btn {
      background: radial-gradient(ellipse at 30% 20%, rgba(255, 255, 255, 0.3), rgba(122, 213, 255, 0.2), rgba(168, 230, 255, 0.18));
      border-color: rgba(122, 213, 255, 0.5);
      box-shadow: 
        0 4px 16px rgba(0, 0, 0, 0.35),
        inset 0 1px 0 rgba(255, 255, 255, 0.45),
        inset 0 -2px 8px rgba(122, 213, 255, 0.35),
        0 0 20px rgba(122, 213, 255, 0.25);
    }

    /* Bottom row - Yellow Candy */
    .utility-row.bot .utility-btn[data-btn="bag"],
    .utility-row.bot .utility-btn[data-btn="switch"] {
      background: radial-gradient(ellipse at 30% 20%, rgba(255, 255, 255, 0.28), rgba(255, 214, 102, 0.2), rgba(255, 235, 153, 0.15));
      border-color: rgba(255, 214, 102, 0.6);
      box-shadow: 
        0 4px 16px rgba(0, 0, 0, 0.35),
        inset 0 1px 0 rgba(255, 255, 255, 0.4),
        inset 0 -2px 8px rgba(255, 214, 102, 0.35),
        0 0 20px rgba(255, 214, 102, 0.3);
    }

    /* AI Button - Purple Magic */
    .utility-btn[data-btn="ai"] {
      background: radial-gradient(ellipse at 30% 20%, rgba(255, 255, 255, 0.15), rgba(186, 85, 211, 0.18), rgba(233, 215, 255, 0.1));
      border: 2px dashed rgba(186, 85, 211, 0.75);
      color: #F3E8FF;
      box-shadow: 
        0 4px 16px rgba(0, 0, 0, 0.35),
        inset 0 1px 0 rgba(255, 255, 255, 0.3),
        inset 0 -2px 8px rgba(186, 85, 211, 0.25),
        0 0 24px rgba(186, 85, 211, 0.3);
    }

    /* Skill Pills - Candy Style (30% smaller) */
    .skill-row {
      display: flex;
      gap: 7px;
      margin-bottom: 8px;
      justify-content: flex-end;
    }

    .skill-pill {
      padding: 7px 10px;
      border-radius: 999px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      background: radial-gradient(ellipse at 30% 20%, rgba(255, 255, 255, 0.25), rgba(255, 255, 255, 0.08), rgba(0, 0, 0, 0.15));
      font-weight: 900;
      letter-spacing: .05em;
      font-size: 9px;
      position: relative;
      text-shadow: 0 1px 4px rgba(0, 0, 0, 0.6);
      color: #fff;
      cursor: pointer;
      touch-action: manipulation;
      transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .skill-pill::after {
      content: attr(data-skill);
    }

    .skill-pill:active {
      transform: scale(0.95) translateY(2px);
    }

    /* S1 - Pink Candy */
    .skill-pill.s1 {
      border-color: rgba(255, 122, 217, 0.75);
      background: radial-gradient(ellipse at 30% 20%, rgba(255, 255, 255, 0.3), rgba(255, 122, 217, 0.25), rgba(255, 181, 232, 0.15));
      box-shadow: 
        0 4px 16px rgba(0, 0, 0, 0.35),
        inset 0 2px 6px rgba(255, 255, 255, 0.4),
        inset 0 -2px 10px rgba(255, 122, 217, 0.3),
        0 0 24px rgba(255, 122, 217, 0.25);
    }

    /* S2 - Mint Candy */
    .skill-pill.s2 {
      border-color: rgba(122, 248, 200, 0.8);
      background: radial-gradient(ellipse at 30% 20%, rgba(255, 255, 255, 0.3), rgba(122, 248, 200, 0.25), rgba(168, 255, 224, 0.15));
      box-shadow: 
        0 4px 16px rgba(0, 0, 0, 0.35),
        inset 0 2px 6px rgba(255, 255, 255, 0.4),
        inset 0 -2px 10px rgba(122, 248, 200, 0.3),
        0 0 24px rgba(122, 248, 200, 0.25);
    }

    /* S3 - Sky Candy */
    .skill-pill.s3 {
      border-color: rgba(122, 213, 255, 0.8);
      background: radial-gradient(ellipse at 30% 20%, rgba(255, 255, 255, 0.3), rgba(122, 213, 255, 0.25), rgba(168, 230, 255, 0.15));
      box-shadow: 
        0 4px 16px rgba(0, 0, 0, 0.35),
        inset 0 2px 6px rgba(255, 255, 255, 0.4),
        inset 0 -2px 10px rgba(122, 213, 255, 0.3),
        0 0 24px rgba(122, 213, 255, 0.25);
    }

    /* Attack Buttons - Candy Style (30% smaller) */
    .big-btn {
      touch-action: manipulation;
      -webkit-user-select: none;
      user-select: none;
      padding: 13px 17px;
      border-radius: 14px;
      border: 2px solid rgba(255, 255, 255, 0.35);
      background: radial-gradient(ellipse at 30% 20%, rgba(255, 255, 255, 0.25), rgba(255, 255, 255, 0.1), rgba(0, 0, 0, 0.2));
      color: #fff;
      font-weight: 900;
      letter-spacing: .06em;
      font-size: 13px;
      text-shadow: 0 2px 6px rgba(0, 0, 0, 0.6);
      cursor: pointer;
      transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .big-btn:hover {
      transform: translateY(-3px) scale(1.03);
    }

    .big-btn:active {
      transform: translateY(2px) scale(0.97);
    }

    .big-btn.attack {
      border-color: rgba(255, 122, 217, 0.85);
      background: radial-gradient(ellipse at 30% 20%, rgba(255, 255, 255, 0.3), rgba(255, 122, 217, 0.25), rgba(255, 100, 150, 0.2));
      box-shadow: 
        0 6px 24px rgba(0, 0, 0, 0.4),
        inset 0 2px 8px rgba(255, 255, 255, 0.4),
        inset 0 -3px 12px rgba(255, 122, 217, 0.35),
        0 0 32px rgba(255, 122, 217, 0.35);
    }

    .big-btn.jump {
      border-color: rgba(122, 213, 255, 0.85);
      background: radial-gradient(ellipse at 30% 20%, rgba(255, 255, 255, 0.3), rgba(122, 213, 255, 0.25), rgba(100, 180, 255, 0.2));
      box-shadow: 
        0 6px 24px rgba(0, 0, 0, 0.4),
        inset 0 2px 8px rgba(255, 255, 255, 0.4),
        inset 0 -3px 12px rgba(122, 213, 255, 0.35),
        0 0 32px rgba(122, 213, 255, 0.35);
    }

    .rage-shield-container {
      position: absolute;
      right: -56px;
      top: 0%;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      gap: 11px;
    }

    .btn-container {
      position: relative;
    }

    .rage-shield-btn {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.35);
      background: radial-gradient(circle at 35% 25%, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.1), rgba(0, 0, 0, 0.2));
      color: #fff;
      font-weight: 900;
      letter-spacing: .05em;
      font-size: 8px;
      text-shadow: 0 1px 4px rgba(0, 0, 0, 0.6);
      cursor: pointer;
      touch-action: manipulation;
      user-select: none;
      transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .rage-shield-btn:hover {
      transform: scale(1.08);
    }

    .rage-shield-btn:active {
      transform: scale(0.95);
    }

    .rage-shield-btn.rage {
      border-color: rgba(255, 100, 100, 0.85);
      background: radial-gradient(circle at 35% 25%, rgba(255, 255, 255, 0.3), rgba(255, 100, 100, 0.25), rgba(255, 50, 50, 0.2));
      box-shadow: 
        0 6px 20px rgba(0, 0, 0, 0.4),
        inset 0 2px 6px rgba(255, 255, 255, 0.4),
        inset 0 -3px 10px rgba(255, 100, 100, 0.35),
        0 0 28px rgba(255, 100, 100, 0.35);
    }

    .rage-shield-btn.shield {
      border-color: rgba(100, 200, 255, 0.85);
      background: radial-gradient(circle at 35% 25%, rgba(255, 255, 255, 0.3), rgba(100, 200, 255, 0.25), rgba(80, 180, 255, 0.2));
      box-shadow: 
        0 6px 20px rgba(0, 0, 0, 0.4),
        inset 0 2px 6px rgba(255, 255, 255, 0.4),
        inset 0 -3px 10px rgba(100, 200, 255, 0.35),
        0 0 28px rgba(100, 200, 255, 0.35);
    }

    /* HUD Toggle Buttons */
    .hud-toggle-container {
      position: fixed;
      bottom: 240px;
      right: 80px;
      display: flex;
      gap: 4px;
      z-index: 101;
    }

    .hud-toggle-btn {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.4);
      background: radial-gradient(circle, rgba(122, 213, 255, 0.3), rgba(0, 0, 0, 0.6));
      color: #fff;
      font-size: 12px;
      font-weight: 900;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
    }

    .hud-toggle-btn:hover {
      transform: scale(1.1);
      box-shadow: 0 0 12px rgba(122, 213, 255, 0.6);
    }

    #hud-wrap.hidden {
      display: none;
    }

    /* ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
       BAG SYSTEM CSS - INTEGRATED FROM A1K-BAG-ULTIMATE
       ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê */

    /* BAG WINDOW */
    .bag-window {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 95vw;
      max-width: 1400px;
      height: 92vh;
      max-height: 900px;
      background: linear-gradient(135deg, rgba(255, 154, 158, 0.15) 0%, rgba(254, 207, 239, 0.15) 50%, rgba(255, 236, 210, 0.15) 100%), rgba(15, 24, 38, 0.98);
      border: 3px solid rgba(255, 255, 255, 0.5);
      border-radius: 20px;
      box-shadow: 0 8px 0 rgba(0, 0, 0, 0.2), 0 12px 32px rgba(255, 105, 180, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.2);
      display: none;
      flex-direction: column;
      z-index: 999;
      backdrop-filter: blur(10px);
    }

    .bag-window.open {
      display: flex;
      animation: bagFadeIn 0.3s ease;
    }

    @keyframes bagFadeIn {
      from {
        opacity: 0;
        transform: translate(-50%, -45%);
      }
      to {
        opacity: 1;
        transform: translate(-50%, -50%);
      }
    }

    /* BAG TITLEBAR */
    .bag-titlebar {
      display: flex;
      align-items: center;
      padding: 8px 14px;
      background: linear-gradient(135deg, rgba(255, 154, 158, 0.2) 0%, rgba(254, 207, 239, 0.2) 100%), rgba(0, 0, 0, 0.3);
      border-bottom: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 20px 20px 0 0;
      cursor: move;
      user-select: none;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2);
    }

    .bag-titlebar-icon {
      font-size: 18px;
      margin-right: 10px;
    }

    .bag-titlebar-title {
      flex: 1;
      font-size: 14px;
      font-weight: 600;
      color: #4fc3f7;
      letter-spacing: 0.5px;
    }

    .bag-titlebar-controls {
      display: flex;
      gap: 6px;
    }

    .titlebar-btn {
      width: 28px;
      height: 28px;
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      color: #cfe3ff;
      font-size: 14px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .titlebar-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: translateY(-1px);
    }

    .titlebar-btn.close:hover {
      background: rgba(255, 59, 59, 0.8);
      color: white;
    }

    /* BAG TABS */
    .bag-tabs-strip {
      display: flex;
      gap: 1px;
      flex: 1;
      overflow-x: auto;
      padding: 2px 0;
      flex-wrap: nowrap;
      scrollbar-width: none;
    }

    .bag-tab {
      display: flex;
      align-items: center;
      gap: 2px;
      padding: 2px 4px;
      border-radius: 4px 4px 0 0;
      border: 1px solid transparent;
      background: rgba(255, 255, 255, 0.05);
      color: rgba(207, 227, 255, 0.7);
      font-size: 7px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      white-space: nowrap;
      flex-shrink: 0;
    }

    .bag-tab:hover {
      background: rgba(79, 195, 247, 0.1);
      color: #cfe3ff;
      transform: translateY(-1px);
    }

    .bag-tab.active {
      background: rgba(79, 195, 247, 0.2);
      border-color: rgba(79, 195, 247, 0.6);
      color: #4fc3f7;
      box-shadow: 0 0 16px rgba(79, 195, 247, 0.3) inset;
    }

    /* BAG CONTENT */
    .bag-content {
      flex: 1;
      overflow-y: auto;
      padding: 16px;
      background: rgba(0, 0, 0, 0.2);
    }

    /* ITEM CARDS */
    .item-card {
      background: linear-gradient(135deg, rgba(15, 24, 38, 0.9), rgba(10, 18, 32, 0.9));
      border: 2px solid rgba(79, 195, 247, 0.3);
      border-radius: 12px;
      padding: 12px;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .item-card:hover {
      border-color: rgba(79, 195, 247, 0.6);
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(79, 195, 247, 0.3);
    }

    .item-card-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 8px;
    }

    .item-icon {
      font-size: 32px;
      text-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
    }

    .item-name {
      font-size: 14px;
      font-weight: 600;
      color: #fff;
    }

    .item-description {
      font-size: 11px;
      color: rgba(207, 227, 255, 0.7);
      margin-top: 4px;
    }

    .item-stats {
      display: flex;
      gap: 8px;
      margin-top: 8px;
      font-size: 10px;
    }

    .item-stat {
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 4px;
      border: 1px solid rgba(79, 195, 247, 0.2);
    }

    /* GRID LAYOUTS */
    .items-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: 12px;
    }

    /* RARITY COLORS */
    .rarity-common { border-color: rgba(158, 158, 158, 0.5); }
    .rarity-uncommon { border-color: rgba(30, 255, 0, 0.5); }
    .rarity-rare { border-color: rgba(0, 112, 221, 0.5); }
    .rarity-epic { border-color: rgba(163, 53, 238, 0.5); }
    .rarity-legendary { border-color: rgba(255, 128, 0, 0.5); }
  </style>
</head>

<body>

  <!-- Game Canvas -->
  <canvas id="gameCanvas"></canvas>

  <!-- UI Overlays -->
  <div class="ui-overlay top-bar">
    <div class="zone-display" id="currentZone">Entry Plaza</div>
    <div class="stats-display">
      <div class="stat">
        <span>üó∫Ô∏è</span>
        <span id="mapPosition">300 / 12,800</span>
      </div>
      <div class="stat">
        <span>üè†</span>
        <span id="buildingCount">0 / 13</span>
      </div>
      <div class="stat">
        <span>üí∞</span>
        <span id="goldCount">10,000</span>
      </div>
    </div>
    <div class="top-bar-controls" style="display: flex; gap: 10px; align-items: center;">
      <button class="top-bar-btn" id="menuBtn" title="Menu">
        <span style="font-size: 18px;">‚ò∞</span>
      </button>
      <button class="top-bar-btn" id="settingsBtn" title="Settings">
        <span style="font-size: 16px;">‚öôÔ∏è</span>
      </button>
    </div>
  </div>

  <!-- Tiny Event Log -->
  <div class="tiny-log" id="tinyLog"></div>

  <!-- Menu Panel -->
  <div class="menu-panel" id="menuPanel">
    <div class="menu-title">‚ò∞ Game Menu</div>
    <div class="menu-item" onclick="togglePanel('.character-panels', 'üë• Party')">
      <div class="menu-item-icon">üë•</div>
      <div>View Party</div>
    </div>
    <div class="menu-item" onclick="togglePanel('.controls-hint', '‚å®Ô∏è Controls')">
      <div class="menu-item-icon">‚å®Ô∏è</div>
      <div>Show Controls</div>
    </div>
    <div class="menu-item" onclick="toggleMinimap()">
      <div class="menu-item-icon">üó∫Ô∏è</div>
      <div>Toggle Minimap</div>
    </div>
    <div class="menu-item" onclick="saveGame()">
      <div class="menu-item-icon">üíæ</div>
      <div>Save Game</div>
    </div>
    <div class="menu-item" onclick="loadGame()">
      <div class="menu-item-icon">üìÇ</div>
      <div>Load Game</div>
    </div>
    <div class="menu-item" onclick="showQuestsLog()">
      <div class="menu-item-icon">üìú</div>
      <div>Quest Log</div>
    </div>
    <div class="menu-item" onclick="showAchievements()">
      <div class="menu-item-icon">üèÜ</div>
      <div>Achievements</div>
    </div>
    <div class="menu-item" onclick="document.getElementById('menuPanel').classList.remove('active')">
      <div class="menu-item-icon">‚úï</div>
      <div>Close Menu</div>
    </div>
  </div>

  <!-- Settings Panel -->
  <div class="settings-panel" id="settingsPanel">
    <div class="menu-title">‚öôÔ∏è Game Settings</div>
    
    <div class="settings-group">
      <label class="settings-label">Game Speed</label>
      <input type="range" class="settings-slider" id="gameSpeedSlider" min="0.5" max="2" step="0.1" value="1">
      <div style="font-size: 12px; color: rgba(207, 227, 255, 0.6); text-align: center; margin-top: 4px;">
        <span id="gameSpeedValue">1.0x</span>
      </div>
    </div>

    <div class="settings-group">
      <label class="settings-label">Graphics Quality</label>
      <select style="width: 100%; padding: 8px; background: rgba(0, 0, 0, 0.5); border: 1px solid rgba(79, 195, 247, 0.3); border-radius: 6px; color: #fff; font-size: 13px;">
        <option value="high" selected>High Quality</option>
        <option value="medium">Medium Quality</option>
        <option value="low">Low Quality (Performance)</option>
      </select>
    </div>

    <div class="settings-group">
      <div class="settings-toggle" onclick="toggleSetting(this, 'showMinimap')">
        <span>Show Minimap</span>
        <div class="toggle-switch on" id="minimapToggle">
          <div class="toggle-switch-handle"></div>
        </div>
      </div>
    </div>

    <div class="settings-group">
      <div class="settings-toggle" onclick="toggleSetting(this, 'showParticles')">
        <span>Particle Effects</span>
        <div class="toggle-switch on" id="particlesToggle">
          <div class="toggle-switch-handle"></div>
        </div>
      </div>
    </div>

    <div class="settings-group">
      <div class="settings-toggle" onclick="toggleSetting(this, 'showDamageNumbers')">
        <span>Damage Numbers</span>
        <div class="toggle-switch on" id="damageToggle">
          <div class="toggle-switch-handle"></div>
        </div>
      </div>
    </div>

    <div class="settings-group">
      <div class="settings-toggle" onclick="toggleSetting(this, 'autoLoot')">
        <span>Auto-Loot</span>
        <div class="toggle-switch on" id="lootToggle">
          <div class="toggle-switch-handle"></div>
        </div>
      </div>
    </div>

    <div class="menu-item" onclick="document.getElementById('settingsPanel').classList.remove('active')" style="margin-top: 16px; border-color: rgba(167, 139, 250, 0.3);">
      <div class="menu-item-icon">‚úï</div>
      <div>Close Settings</div>
    </div>
  </div>

  <!-- Interior Indicator -->
  <div class="interior-indicator" id="interiorIndicator">
    üè† INSIDE - Press E at door to exit
  </div>

  <!-- Character Panels -->
  <div class="ui-overlay character-panels">
    <div class="character-panel selected" id="panel-a1">
      <div class="char-header">
        <span class="char-name">üë§ A1 (Leader)</span>
        <span class="char-level">Lv 1</span>
      </div>
      <div class="hp-bar">
        <div class="hp-fill" style="width: 100%"></div>
      </div>
      <div style="font-size: 0.7rem; color: #d1d5db;">
        HP: 100/100 | ATK: 45 | DEF: 20
      </div>
      <div class="char-style">HD Pixel Art</div>
    </div>

    <div class="character-panel" id="panel-missy">
      <div class="char-header">
        <span class="char-name">üê± Missy</span>
        <span class="char-level">Lv 1</span>
      </div>
      <div class="hp-bar">
        <div class="hp-fill" style="width: 100%"></div>
      </div>
      <div style="font-size: 0.7rem; color: #d1d5db;">
        HP: 120/120 | ATK: 50 | DEF: 30
      </div>
      <div class="char-style">HD Pixel Art</div>
    </div>

    <div class="character-panel" id="panel-companion">
      <div class="char-header">
        <span class="char-name">‚öîÔ∏è Unique</span>
        <span class="char-level">Lv 1</span>
      </div>
      <div class="hp-bar">
        <div class="hp-fill" style="width: 100%"></div>
      </div>
      <div style="font-size: 0.7rem; color: #d1d5db;">
        HP: 150/150 | ATK: 60 | DEF: 40
      </div>
      <div class="char-style">HD Pixel Art</div>
    </div>
  </div>

  <!-- Controls Hint -->
  <div class="ui-overlay controls-hint">
    <h4>‚å®Ô∏è Controls</h4>
    <div class="control-line"><span class="key">‚Üê‚Üí‚Üë‚Üì</span> Move</div>
    <div class="control-line"><span class="key">Shift</span> Run</div>
    <div class="control-line"><span class="key">E</span> Interact</div>
    <div class="control-line"><span class="key">M</span> Minimap</div>
    <div class="control-line"><span class="key">ESC</span> Close</div>
  </div>

  <!-- Minimap -->
  <div class="ui-overlay minimap" id="minimapPanel">
    <h4>üó∫Ô∏è World Map</h4>
    <canvas id="minimapCanvas" width="240" height="90"></canvas>
  </div>

  <!-- HUD Candy Controls -->
  <div id="hud-wrap">
    <!-- LEFT CLUSTER -->
    <div id="hud-left">
      <!-- Utility Buttons -->
      <div class="utility-stack">
        <div class="utility-row top">
          <button class="utility-btn" data-btn="pet" title="Pet - Summon pet companions">Pet</button>
          <button class="utility-btn" data-btn="veh" title="Veh - Summon equipped vehicle">Veh</button>
          <button class="utility-btn" data-btn="act" title="Act - Enter houses/pickup items">Act</button>
          <button class="utility-btn" data-btn="act2" title="Act2 - Interact with toys">Act2</button>
        </div>
        <div class="utility-row bot">
          <button class="utility-btn" data-btn="bag" title="Bag - Open inventory">Bag</button>
          <button class="utility-btn" data-btn="ai" title="AI - Summon AI to party">AI</button>
          <button class="utility-btn" data-btn="switch" title="Switch - Change character">Switch</button>
        </div>
      </div>

      <!-- Joystick -->
      <div id="vj-root">
        <div id="vj-base"></div>
        <div id="vj-knob"></div>
      </div>
    </div>

    <!-- RIGHT CLUSTER -->
    <div id="hud-right">
      <!-- Skill Pills -->
      <div class="skill-row">
        <button class="skill-pill s1" data-skill="S1" data-btn="s1" aria-label="Skill 1"></button>
        <button class="skill-pill s2" data-skill="S2" data-btn="s2" aria-label="Skill 2"></button>
        <button class="skill-pill s3" data-skill="S3" data-btn="s3" aria-label="Skill 3"></button>
      </div>

      <!-- Attack Buttons -->
      <div class="btn-container">
        <button class="big-btn attack" data-btn="attack">ATTACK</button>
        <button class="big-btn jump" data-btn="jump">JUMP</button>
        <div class="rage-shield-container">
          <button class="rage-shield-btn rage" data-btn="rage">RAGE</button>
          <button class="rage-shield-btn shield" data-btn="shield">SHIELD</button>
        </div>
      </div>
    </div>
  </div>

  <!-- HUD Toggle Buttons -->
  <div class="hud-toggle-container">
    <button class="hud-toggle-btn" id="hudHideBtn" title="Hide Controls">‚àí</button>
    <button class="hud-toggle-btn" id="hudShowBtn" title="Show Controls" style="display: none;">+</button>
  </div>

  <!-- Bag Window -->
  <div class="bag-window" id="bagWindow">
    <div class="bag-titlebar">
      <div class="bag-titlebar-icon">üéí</div>
      <div class="bag-titlebar-title">A1K Inventory System</div>
      <div class="bag-titlebar-controls">
        <button class="titlebar-btn close" onclick="window.BagSystem.close()">‚úï</button>
      </div>
    </div>

    <div style="display: flex; padding: 8px; background: rgba(0, 0, 0, 0.2); border-bottom: 1px solid rgba(79, 195, 247, 0.2);">
      <div class="bag-tabs-strip" id="bagTabsStrip"></div>
    </div>

    <div class="bag-content" id="bagContent"></div>
  </div>

  <!-- Game Panel (Casino/Arcade) -->
  <div class="game-panel" id="gamePanel">
    <div class="game-title" id="gameTitle">Rock Paper Scissors</div>

    <!-- Bet Slider -->
    <div class="bet-slider-container" id="betSliderContainer">
      <div class="bet-slider-label">
        <span>üí∞ Bet Amount:</span>
        <span id="betAmount">1,000 gold</span>
      </div>
      <input type="range" class="bet-slider" id="betSlider" min="100" max="500000" step="100" value="1000">
      <div style="display: flex; justify-content: space-between; margin-top: 5px; font-size: 0.8rem; color: #9ca3af;">
        <span>Min: 100g</span>
        <button class="action-button secondary" style="padding: 4px 12px; font-size: 0.8rem;" onclick="setMaxBet()">Max
          Bet</button>
        <span id="maxBetDisplay">Max: 500,000g</span>
      </div>
    </div>

    <!-- Game Area -->
    <div class="game-area" id="gameArea">
      <!-- Content changes based on game -->
    </div>

    <!-- Result Display -->
    <div class="game-result" id="gameResult" style="display: none;"></div>

    <!-- Action Buttons -->
    <div style="text-align: center; margin-top: 20px;">
      <button class="action-button close" onclick="closeGamePanel()">Close (ESC)</button>
    </div>
  </div>

  <script>
    // ============================
    // GAME STATE
    // ============================

    const WORLD = {
      width: 12800,
      height: 1080,
    };

    const ZONES = [
      { id: "ENTRY", name: "Entry Plaza", x: 0, end: 1200, color: "#1f2937", sky: "#4a5568" },
      { id: "TRAIN", name: "Training Grounds", x: 1200, end: 2400, color: "#334155", sky: "#64748b" },
      { id: "PLAZA", name: "Central Plaza", x: 2400, end: 3600, color: "#2b2c40", sky: "#475569" },
      { id: "MARKET", name: "Market Square", x: 3600, end: 4800, color: "#2b2c40", sky: "#475569" },
      { id: "TOWER", name: "Tower District", x: 4800, end: 6000, color: "#312e2e", sky: "#52525b" },
      { id: "CASINO", name: "Casino Strip", x: 6000, end: 7200, color: "#3d1b2d", sky: "#7c2d12" },
      { id: "ARCADE", name: "Arcade Zone", x: 7200, end: 8400, color: "#2d1b3d", sky: "#6b21a8" },
      { id: "RACING", name: "Racing Track", x: 8400, end: 9600, color: "#1b3d2d", sky: "#14532d" },
      { id: "FISHING", name: "Fishing Docks", x: 9600, end: 10800, color: "#1b2d3d", sky: "#0c4a6e" },
      { id: "FARMING", name: "Farming Fields", x: 10800, end: 12000, color: "#2d3d1b", sky: "#3f6212" },
      { id: "CELESTIAL", name: "Celestial Gates", x: 12000, end: 12800, color: "#4d4d1b", sky: "#854d0e" },
    ];

    // QUEST SYSTEM
    const QUESTS = {
      main: [
        { id: 'main_1', name: 'Welcome to the City', description: 'Explore the Training Grounds and defeat 3 enemies', type: 'main', rewards: { gold: 100, xp: 50 }, objectives: [{ type: 'kill', count: 3, current: 0 }], unlockPortal: 'portal_plaza', completed: false },
        { id: 'main_2', name: 'Plaza Champion', description: 'Clear Central Plaza of all enemies', type: 'main', rewards: { gold: 200, xp: 100 }, objectives: [{ type: 'kill', count: 5, current: 0 }], unlockPortal: 'portal_market', completed: false },
        { id: 'main_3', name: 'Market Protector', description: 'Defeat the Market Square enemies', type: 'main', rewards: { gold: 300, xp: 150 }, objectives: [{ type: 'kill', count: 6, current: 0 }], unlockPortal: 'portal_tower', completed: false },
        { id: 'main_4', name: 'Tower Ascension', description: 'Conquer the Tower District', type: 'main', rewards: { gold: 500, xp: 250 }, objectives: [{ type: 'kill', count: 7, current: 0 }], unlockPortal: 'portal_casino', completed: false },
        { id: 'main_5', name: 'Final Challenge', description: 'Defeat 12 enemies at Celestial Gates', type: 'main', rewards: { gold: 1000, xp: 500 }, objectives: [{ type: 'kill', count: 12, current: 0 }], unlockPortal: 'portal_celestial', completed: false }
      ],
      side: [
        { id: 'side_1', name: 'Pet Collector', description: 'Summon 3 different pets', type: 'side', rewards: { gold: 150, item: 'pet_box' }, objectives: [{ type: 'summon_pet', count: 3, current: 0 }], completed: false },
        { id: 'side_2', name: 'Gear Master', description: 'Equip 5 pieces of gear', type: 'side', rewards: { gold: 200, item: 'gear_kit' }, objectives: [{ type: 'equip_gear', count: 5, current: 0 }], completed: false },
        { id: 'side_3', name: 'Skill Expert', description: 'Cast 20 skills', type: 'side', rewards: { gold: 300, xp: 100 }, objectives: [{ type: 'cast_skill', count: 20, current: 0 }], completed: false },
        { id: 'side_4', name: 'Vehicle Enthusiast', description: 'Ride 5 different vehicles', type: 'side', rewards: { gold: 400 }, objectives: [{ type: 'ride_vehicle', count: 5, current: 0 }], completed: false },
        { id: 'side_5', name: 'AI Commander', description: 'Summon 3 different robots', type: 'side', rewards: { gold: 500, item: 'robot_kit' }, objectives: [{ type: 'summon_robot', count: 3, current: 0 }], completed: false }
      ],
      daily: [
        { id: 'daily_1', name: 'Daily Slayer', description: 'Defeat 10 enemies today', type: 'daily', rewards: { gold: 100, xp: 50 }, objectives: [{ type: 'kill', count: 10, current: 0 }], resetTime: null, completed: false },
        { id: 'daily_2', name: 'Daily Merchant', description: 'Buy 3 items from shop', type: 'daily', rewards: { gold: 150 }, objectives: [{ type: 'shop_buy', count: 3, current: 0 }], resetTime: null, completed: false },
        { id: 'daily_3', name: 'Daily Explorer', description: 'Visit 3 different zones', type: 'daily', rewards: { gold: 200 }, objectives: [{ type: 'zone_visit', count: 3, current: 0, zones: new Set() }], resetTime: null, completed: false }
      ]
    };

    // ZONE PORTALS - Fast travel between zones
    const ZONE_PORTALS = [
      { id: "portal_train", name: "Training Portal", x: 1100, y: 580, targetZone: "TRAIN", icon: "üåÄ", color: "#64748b", unlocked: true },
      { id: "portal_plaza", name: "Plaza Portal", x: 2300, y: 580, targetZone: "PLAZA", icon: "üåÄ", color: "#475569", unlocked: false },
      { id: "portal_market", name: "Market Portal", x: 3500, y: 580, targetZone: "MARKET", icon: "üåÄ", color: "#475569", unlocked: false },
      { id: "portal_tower", name: "Tower Portal", x: 4700, y: 580, targetZone: "TOWER", icon: "üåÄ", color: "#52525b", unlocked: false },
      { id: "portal_casino", name: "Casino Portal", x: 5900, y: 580, targetZone: "CASINO", icon: "üåÄ", color: "#7c2d12", unlocked: false },
      { id: "portal_arcade", name: "Arcade Portal", x: 7100, y: 580, targetZone: "ARCADE", icon: "üåÄ", color: "#6b21a8", unlocked: false },
      { id: "portal_racing", name: "Racing Portal", x: 8300, y: 580, targetZone: "RACING", icon: "üåÄ", color: "#14532d", unlocked: false },
      { id: "portal_fishing", name: "Fishing Portal", x: 9500, y: 580, targetZone: "FISHING", icon: "üåÄ", color: "#0c4a6e", unlocked: false },
      { id: "portal_farming", name: "Farming Portal", x: 10700, y: 580, targetZone: "FARMING", icon: "üåÄ", color: "#3f6212", unlocked: false },
      { id: "portal_celestial", name: "Celestial Portal", x: 11900, y: 580, targetZone: "CELESTIAL", icon: "üåÄ", color: "#854d0e", unlocked: false }
    ];

    const BUILDINGS = [
      { id: "photo", name: "Photo Booth", type: "booth", x: 260, width: 100, height: 120, color: "#9A6BFF", hasInterior: true },
      { id: "arena", name: "Battle Arena", type: "arena", x: 1500, width: 200, height: 180, yOffset: 250, color: "#ef4444", hasInterior: true },
      { id: "quest", name: "Quest Board", type: "board", x: 2900, width: 80, height: 140, color: "#22d3ee", hasInterior: true },
      { id: "archives", name: "Archives", type: "library", x: 3100, width: 180, height: 200, color: "#94a3b8", hasInterior: true },
      { id: "shop", name: "Item Shop", type: "shop", x: 4100, width: 150, height: 160, color: "#9fd7ff", hasInterior: true },
      { id: "forge", name: "Blacksmith", type: "forge", x: 4300, width: 140, height: 150, color: "#f97316", hasInterior: true },
      { id: "tower", name: "Candy Tower", type: "tower", x: 5300, width: 180, height: 280, color: "#9ca3af", hasInterior: true },
      { id: "casino", name: "Grand Casino", type: "casino", x: 6500, width: 240, height: 200, color: "#f43f5e", hasInterior: true },
      { id: "arcade", name: "Game Arcade", type: "arcade", x: 7700, width: 220, height: 180, color: "#a855f7", hasInterior: true },
      { id: "race", name: "Racing Track", type: "track", x: 8900, width: 200, height: 160, color: "#34d399", hasInterior: true },
      { id: "fishing", name: "Fishing Pier", type: "pier", x: 10100, width: 180, height: 140, color: "#38bdf8", hasInterior: true },
      { id: "farm", name: "Farmhouse", type: "farmhouse", x: 11300, width: 170, height: 170, color: "#a3e635", hasInterior: true },
      { id: "temple", name: "Divine Temple", type: "temple", x: 12500, width: 220, height: 260, color: "#fde047", hasInterior: true },
      { id: "celestial", name: "Celestial Gates", type: "gates", x: 13700, width: 280, height: 320, color: "#fef3c7", hasInterior: true },
    ];

    // ENEMY TYPE DEFINITIONS
    const ENEMY_TYPES = {
      SLASHER: {
        name: 'Shadow Slasher',
        icon: '‚öîÔ∏è',
        color: '#ef4444',
        hp: 100,
        maxHp: 100,
        atk: 20,
        def: 5,
        speed: 1.2,
        attackRange: 50,
        aggroRange: 300,
        xpReward: 25,
        goldReward: 15,
        type: 'melee',
        attackCooldown: 1.5,
        behavior: 'chase'
      },
      SHOOTER: {
        name: 'Plasma Shooter',
        icon: 'üéØ',
        color: '#3b82f6',
        hp: 70,
        maxHp: 70,
        atk: 15,
        def: 3,
        speed: 0.8,
        attackRange: 250,
        aggroRange: 350,
        xpReward: 30,
        goldReward: 20,
        type: 'ranged',
        attackCooldown: 2.0,
        behavior: 'keepDistance'
      },
      DRONE: {
        name: 'Flying Drone',
        icon: 'üõ∏',
        color: '#8b5cf6',
        hp: 60,
        maxHp: 60,
        atk: 12,
        def: 2,
        speed: 1.5,
        attackRange: 200,
        aggroRange: 400,
        xpReward: 35,
        goldReward: 25,
        type: 'flying',
        attackCooldown: 1.8,
        behavior: 'circle'
      },
      BRUTE: {
        name: 'Heavy Brute',
        icon: 'üíÄ',
        color: '#dc2626',
        hp: 250,
        maxHp: 250,
        atk: 35,
        def: 15,
        speed: 0.6,
        attackRange: 60,
        aggroRange: 250,
        xpReward: 50,
        goldReward: 40,
        type: 'tank',
        attackCooldown: 2.5,
        behavior: 'chase'
      }
    };

    const GameState = {
      mode: 'exterior', // 'exterior' or 'interior'
      currentBuilding: null,
      party: [
        { id: "a1", name: "A1", x: 300, y: 550, hp: 100, maxHp: 100, walkFrame: 0, atk: 45, def: 20, level: 1, xp: 0, animState: 'idle', animFrame: 0, animTimer: 0, facing: 'down' },
        { id: "missy", name: "Missy", x: 250, y: 570, hp: 120, maxHp: 120, walkFrame: 0, atk: 50, def: 30, level: 1, xp: 0, animState: 'idle', animFrame: 0, animTimer: 0, facing: 'down' },
        { id: "companion", name: "Unique", x: 350, y: 570, hp: 150, maxHp: 150, walkFrame: 0, atk: 60, def: 40, level: 1, xp: 0, animState: 'idle', animFrame: 0, animTimer: 0, facing: 'down' },
      ],
      camera: { x: 0 },
      currentZone: "ENTRY",
      nearestBuilding: null,
      nearestPortal: null,
      unlockedPortals: new Set(['portal_train']), // Training portal unlocked by default
      // BAG SYSTEM INTEGRATION - Extended GameState
      gold: 15750,
      gems: 250,
      keys: 12,
      tickets: 8,
      level: 1,
      xp: 0,
      equipped: {
        head: null, chest: null, gloves: null, pants: null, boots: null,
        weapon: null, offhand: null, ring1: null, ring2: null, necklace: null,
        vehicle: null, pet: null, spirit: null, robot: null
      },
      currentCharacter: 'Missy',
      equippedSkins: { A1: 'default', Unique: 'default', Missy: 'default' },
      bagOpen: false,
      nearestInteractive: null,
      discoveredBuildings: new Set(),
      keys: {},
      animTime: 0,
      currentBet: 1000,
      gameInProgress: false,
      arcadeTickets: 0,
      savedExteriorPosition: null,

      // COMBAT SYSTEM - Enemy tracking
      enemies: [],
      projectiles: [],
      damageNumbers: [],
      combatActive: false,
      
      // Combat meters
      rage: 0,
      maxRage: 100,
      rageMode: false,
      rageModeTimer: 0,
      isBlocking: false,
      blockTimer: 0,
      parryWindow: 0, // AAA: Perfect parry timing window
      parryWindowDuration: 200, // 0.2 seconds
      canCounter: false,
      
      // Screen effects
      screenShake: 0,
      hitFlash: 0,
      
      // PHASE 3: Content Expansion - Quest System
      activeQuests: [],
      completedQuests: new Set(),
      questProgress: {},
      discoveredZones: new Set(['ENTRY']),
      visitedZonesThisSession: new Set(['ENTRY']),
      
      // PHASE 3: NPCs & Collectibles
      npcs: [],
      collectedItems: new Set(),
      foundSecrets: new Set(),
      
      // PHASE 3: Achievements
      achievements: new Set(),
      achievementProgress: {},
      
      // PHASE 4: Save/Load System
      lastSaveTime: null,
      autoSaveEnabled: true,
      autoSaveInterval: 30000, // 30 seconds
      
      // PHASE 5: Tutorial & Audio
      tutorialComplete: false,
      tutorialStep: 0,
      audioEnabled: true,
      musicVolume: 0.7,
      sfxVolume: 0.8,
      
      // AAA PHASE 1: Combo System
      comboCount: 0,
      comboMultiplier: 1.0,
      comboTimer: 0,
      maxCombo: 0,
      comboMilestones: [10, 25, 50, 100],
      comboRewardsClaimed: [],
      
      // AAA PHASE 1: Status Effects
      statusEffects: {}, // Track all status effects by entity ID
      
      // AAA PHASE 1: Skill Combos
      lastSkillCast: null,
      skillComboWindow: 2000, // 2 seconds to combo skills
      lastSkillCastTime: 0,
      skillCombos: [], // Track active skill combos
      
      // AAA PHASE 2: Skill Trees
      skillPoints: 0,
      skillTrees: {
        A1: { combat: {}, defense: {}, ultimate: {} },
        Missy: { precision: {}, luck: {}, divine: {} },
        Unique: { tech: {}, energy: {}, cyber: {} }
      },
      
      // AAA PHASE 2: Character Builds
      attributePoints: 0,
      attributes: {
        A1: { STR: 10, DEX: 5, INT: 3, VIT: 8, LUK: 2 },
        Missy: { STR: 6, DEX: 10, INT: 5, VIT: 7, LUK: 10 },
        Unique: { STR: 5, DEX: 7, INT: 10, VIT: 6, LUK: 5 }
      },
      
      // AAA PHASE 2: Crafting System
      craftingMaterials: {},
      craftedItems: [],

      // BAG SYSTEM INVENTORY - COMPLETE DATA FROM A1K-BAG-ULTIMATE
      inventory: {
        skills: [
          // === A1 (WARRIOR) - 11 skills ===
          { id: 'A1_S1', name: 'Crimson Slash', characterId: 'A1', slot: 1, damage: 150, cooldown: 2.5, unlock: 1, element: 'PHYSICAL', description: '3-hit crimson X-wave slash', icon: '‚öîÔ∏è', tier: 'starter' },
          { id: 'A1_S2', name: 'Shadow Clone', characterId: 'A1', slot: 2, damage: 0, cooldown: 15, unlock: 20, element: 'SUMMON', description: 'Summon combat clone ally', icon: 'üë•', tier: 'common' },
          { id: 'A1_S3', name: 'Power Wave', characterId: 'A1', slot: 3, damage: 250, cooldown: 4, unlock: 1, element: 'PHYSICAL', description: '4-hit power wave combo', icon: 'üí®', tier: 'starter' },
          { id: 'A1_S4', name: 'Phantom Strike', characterId: 'A1', slot: 4, damage: 320, cooldown: 20, unlock: 30, element: 'SHADOW', description: 'Teleport & execute combo (6 slashes)', icon: 'üåô', tier: 'rare' },
          { id: 'A1_S5', name: 'Crimson Cyclone', characterId: 'A1', slot: 5, damage: 300, cooldown: 24, unlock: 40, element: 'PHYSICAL', description: '3-blink aerial spin attack', icon: 'üå™Ô∏è', tier: 'rare' },
          { id: 'A1_X1', name: 'Rift Cutter', characterId: 'A1', slot: 'X', damage: 380, cooldown: 28, unlock: 50, element: 'ARCANE', description: 'Twin dimension rifts (chargeable)', icon: 'üåå', tier: 'epic', chargeable: true },
          { id: 'A1_BLADE_DANCE', name: 'Blade Dance', characterId: 'A1', slot: null, damage: 600, cooldown: 6, unlock: 10, element: 'PHYSICAL', description: '5-hit spinning slash attack', icon: 'üó°Ô∏è', tier: 'uncommon' },
          { id: 'A1_CRIMSON_FURY', name: 'Crimson Fury', characterId: 'A1', slot: null, damage: 850, cooldown: 8, unlock: 20, element: 'FIRE', description: 'Rapid burning slashes + explosion', icon: 'üî•', tier: 'rare', burn: true },
          { id: 'A1_SHADOW_STEP', name: 'Shadow Step', characterId: 'A1', slot: null, damage: 0, cooldown: 4, unlock: 5, element: 'SHADOW', description: 'Dash with invulnerability frames', icon: 'üëª', tier: 'common' },
          { id: 'A1_VOID_REAPER', name: 'Void Reaper', characterId: 'A1', slot: null, damage: 1800, cooldown: 16, unlock: 35, element: 'SHADOW', description: 'Death scythe AoE with lifesteal', icon: 'üíÄ', tier: 'epic', lifesteal: true },
          { id: 'A1_DIMENSION_BREAKER', name: 'Dimension Breaker', characterId: 'A1', slot: null, damage: 3200, cooldown: 25, unlock: 45, element: 'ARCANE', description: 'Reality-shattering rift explosion', icon: 'üå†', tier: 'legendary', stun: true },
          // === UNIQUE (CYBORG) - 11 skills ===
          { id: 'UNIQUE_S1', name: 'Plasma Blast', characterId: 'UNIQUE', slot: 1, damage: 120, cooldown: 2, unlock: 1, element: 'PLASMA', description: '3-hit plasma bolt barrage', icon: '‚ö°', tier: 'starter' },
          { id: 'UNIQUE_S2', name: 'Combat Drone', characterId: 'UNIQUE', slot: 2, damage: 0, cooldown: 15, unlock: 20, element: 'SUMMON', description: 'Summon combat drone ally', icon: 'ü§ñ', tier: 'common' },
          { id: 'UNIQUE_S3', name: 'Power Beam', characterId: 'UNIQUE', slot: 3, damage: 400, cooldown: 8, unlock: 1, element: 'ENERGY', description: 'Channeled energy beam', icon: 'üí•', tier: 'starter' },
          { id: 'UNIQUE_S4', name: 'Cryo Rail', characterId: 'UNIQUE', slot: 4, damage: 180, cooldown: 20, unlock: 30, element: 'ICE', description: 'Ice rail beam + 4 cryo rounds', icon: '‚ùÑÔ∏è', tier: 'rare', freeze: true },
          { id: 'UNIQUE_S5', name: 'Ion Drill', characterId: 'UNIQUE', slot: 5, damage: 220, cooldown: 24, unlock: 40, element: 'LIGHTNING', description: 'Steerable ion drill beam', icon: 'üåÄ', tier: 'rare' },
          { id: 'UNIQUE_X1', name: 'Hyper Beam', characterId: 'UNIQUE', slot: 'X', damage: 300, cooldown: 28, unlock: 50, element: 'LIGHTNING', description: 'Massive channeled beam (chargeable)', icon: 'üåä', tier: 'epic', chargeable: true, freeze: true },
          { id: 'UNIQUE_ICE_BEAM', name: 'Freeze Ray', characterId: 'UNIQUE', slot: null, damage: 500, cooldown: 7, unlock: 10, element: 'ICE', description: 'Freeze enemies in beam path', icon: 'üßä', tier: 'uncommon', freeze: true },
          { id: 'UNIQUE_LIGHTNING_BARRAGE', name: 'Thunder Volley', characterId: 'UNIQUE', slot: null, damage: 400, cooldown: 8, unlock: 12, element: 'LIGHTNING', description: '10-hit lightning chain bolts', icon: '‚ö°', tier: 'uncommon', chain: true },
          { id: 'UNIQUE_EMP_BLAST', name: 'EMP Blast', characterId: 'UNIQUE', slot: null, damage: 800, cooldown: 12, unlock: 22, element: 'LIGHTNING', description: 'AoE electromagnetic pulse', icon: 'üí•', tier: 'rare', silence: true, stun: true },
          { id: 'UNIQUE_PLASMA_STORM', name: 'Meteor Strike', characterId: 'UNIQUE', slot: null, damage: 280, cooldown: 18, unlock: 30, element: 'FIRE', description: '12 plasma meteors from orbit', icon: '‚òÑÔ∏è', tier: 'epic', burn: true },
          { id: 'UNIQUE_ABSOLUTE_ZERO_NOVA', name: 'Absolute Zero', characterId: 'UNIQUE', slot: null, damage: 2400, cooldown: 20, unlock: 38, element: 'ICE', description: 'Massive AoE freeze + shatter', icon: '‚ùÑÔ∏è', tier: 'legendary', freeze: true },
          // === MISSY (CAT ANGEL) - 11 skills ===
          { id: 'MISSY_S1', name: 'Crescent Slash', characterId: 'MISSY', slot: 1, damage: 130, cooldown: 2.5, unlock: 1, element: 'PHYSICAL', description: '3-hit crescent wave attack', icon: 'üåô', tier: 'starter' },
          { id: 'MISSY_S2', name: 'Spirit Pet', characterId: 'MISSY', slot: 2, damage: 0, cooldown: 15, unlock: 20, element: 'SUMMON', description: 'Summon loyal pet companion', icon: 'üêæ', tier: 'common' },
          { id: 'MISSY_S3', name: 'Rapid Fire', characterId: 'MISSY', slot: 3, damage: 200, cooldown: 4, unlock: 1, element: 'PHYSICAL', description: '4-hit rapid pistol shots', icon: 'üî´', tier: 'starter' },
          { id: 'MISSY_S4', name: 'Starlight Rail', characterId: 'MISSY', slot: 4, damage: 180, cooldown: 6, unlock: 30, element: 'LIGHT', description: 'Rail beam + 8 boomerang comets', icon: 'üí´', tier: 'rare', magnet: true },
          { id: 'MISSY_S5', name: 'Storm Vortex', characterId: 'MISSY', slot: 5, damage: 720, cooldown: 8, unlock: 40, element: 'LIGHT', description: 'Spinning cyclone + shotgun volley', icon: 'üå™Ô∏è', tier: 'rare', magnet: true },
          { id: 'MISSY_X1', name: 'Fortune Cannon', characterId: 'MISSY', slot: 'X', damage: 2800, cooldown: 20, unlock: 50, element: 'LIGHT', description: 'Golden coin mega-beam (chargeable)', icon: 'üí∞', tier: 'epic', chargeable: true, magnet: true },
          { id: 'MISSY_BLADE_STORM', name: 'Blade Tempest', characterId: 'MISSY', slot: null, damage: 550, cooldown: 7, unlock: 11, element: 'PHYSICAL', description: 'Spinning blade + 16 pistol shots', icon: 'üó°Ô∏è', tier: 'uncommon' },
          { id: 'MISSY_LUCKY_STRIKE', name: 'Lucky Strike', characterId: 'MISSY', slot: null, damage: 600, cooldown: 5, unlock: 5, element: 'LIGHT', description: 'High chance double damage + coin', icon: 'üçÄ', tier: 'common', luck: true },
          { id: 'MISSY_JACKPOT_RAIN', name: 'Treasure Rain', characterId: 'MISSY', slot: null, damage: 150, cooldown: 12, unlock: 18, element: 'LIGHT', description: '20 golden exploding coins', icon: 'üí∏', tier: 'rare', luck: true },
          { id: 'MISSY_DEADEYE', name: 'Deadeye Shot', characterId: 'MISSY', slot: null, damage: 2000, cooldown: 14, unlock: 24, element: 'PHYSICAL', description: 'Perfect precision shot (crit)', icon: 'üéØ', tier: 'rare', crit: true, pierce: true },
          
          // === A1 EXTENDED SKILLS (19 more) ===
          { id: 'A1_BERSERKER_RAGE', name: 'Berserker Rage', characterId: 'A1', slot: null, damage: 1200, cooldown: 10, unlock: 15, element: 'FIRE', description: 'Unleash berserker fury with flaming slashes', icon: 'üí¢', tier: 'rare', burn: true },
          { id: 'A1_WHIRLWIND', name: 'Whirlwind', characterId: 'A1', slot: null, damage: 900, cooldown: 8, unlock: 12, element: 'PHYSICAL', description: 'Spin attack hitting all nearby enemies', icon: 'üåÄ', tier: 'uncommon' },
          { id: 'A1_EARTH_SHAKER', name: 'Earth Shaker', characterId: 'A1', slot: null, damage: 1500, cooldown: 15, unlock: 25, element: 'PHYSICAL', description: 'Slam ground causing shockwave', icon: 'üåç', tier: 'epic', stun: true },
          { id: 'A1_BLOOD_STRIKE', name: 'Blood Strike', characterId: 'A1', slot: null, damage: 1100, cooldown: 12, unlock: 22, element: 'SHADOW', description: 'Drain enemy life force', icon: 'ü©∏', tier: 'rare', lifesteal: true },
          { id: 'A1_DUAL_EXECUTION', name: 'Dual Execution', characterId: 'A1', slot: null, damage: 1600, cooldown: 16, unlock: 28, element: 'PHYSICAL', description: 'Twin-blade execution strike', icon: '‚öîÔ∏è', tier: 'epic', crit: true },
          { id: 'A1_THUNDER_STRIKE', name: 'Thunder Strike', characterId: 'A1', slot: null, damage: 1300, cooldown: 13, unlock: 26, element: 'LIGHTNING', description: 'Lightning-charged sword strike', icon: '‚ö°', tier: 'rare', chain: true },
          { id: 'A1_INFERNO_BLADE', name: 'Inferno Blade', characterId: 'A1', slot: null, damage: 1700, cooldown: 18, unlock: 32, element: 'FIRE', description: 'Summon flaming sword from sky', icon: 'üî•', tier: 'epic', burn: true },
          { id: 'A1_SPECTRAL_SLASH', name: 'Spectral Slash', characterId: 'A1', slot: null, damage: 1400, cooldown: 14, unlock: 29, element: 'SHADOW', description: 'Phase through enemies dealing damage', icon: 'üëª', tier: 'rare', pierce: true },
          { id: 'A1_DRAGON_STRIKE', name: 'Dragon Strike', characterId: 'A1', slot: null, damage: 2200, cooldown: 20, unlock: 36, element: 'FIRE', description: 'Channel dragon spirit into blade', icon: 'üêâ', tier: 'legendary', burn: true },
          { id: 'A1_VOID_SLASH', name: 'Void Slash', characterId: 'A1', slot: null, damage: 1900, cooldown: 17, unlock: 34, element: 'ARCANE', description: 'Cut through reality itself', icon: 'üåå', tier: 'epic', silence: true },
          { id: 'A1_STEEL_TEMPEST', name: 'Steel Tempest', characterId: 'A1', slot: null, damage: 1250, cooldown: 11, unlock: 21, element: 'PHYSICAL', description: 'Rapid multi-hit sword flurry', icon: '‚öîÔ∏è', tier: 'rare' },
          { id: 'A1_HELLFIRE_WAVE', name: 'Hellfire Wave', characterId: 'A1', slot: null, damage: 2100, cooldown: 19, unlock: 38, element: 'FIRE', description: 'Wave of hellfire engulfs enemies', icon: 'üî•', tier: 'legendary', burn: true },
          { id: 'A1_FROZEN_BLADE', name: 'Frozen Blade', characterId: 'A1', slot: null, damage: 1350, cooldown: 13, unlock: 27, element: 'ICE', description: 'Ice-infused blade attack', icon: '‚ùÑÔ∏è', tier: 'rare', freeze: true },
          { id: 'A1_PHANTOM_DANCE', name: 'Phantom Dance', characterId: 'A1', slot: null, damage: 1800, cooldown: 16, unlock: 31, element: 'SHADOW', description: 'Dance of death with shadow clones', icon: 'üíÉ', tier: 'epic' },
          { id: 'A1_TITAN_SLASH', name: 'Titan Slash', characterId: 'A1', slot: null, damage: 2400, cooldown: 22, unlock: 40, element: 'PHYSICAL', description: 'Massive overhead cleave', icon: '‚öîÔ∏è', tier: 'legendary' },
          { id: 'A1_CHAOS_STRIKE', name: 'Chaos Strike', characterId: 'A1', slot: null, damage: 2600, cooldown: 24, unlock: 42, element: 'ARCANE', description: 'Chaotic energy erupts from blade', icon: 'üå†', tier: 'legendary', stun: true },
          { id: 'A1_NOVA_SLASH', name: 'Nova Slash', characterId: 'A1', slot: null, damage: 2000, cooldown: 18, unlock: 35, element: 'LIGHT', description: 'Explosive light-wave slash', icon: 'üí´', tier: 'epic' },
          { id: 'A1_METEOR_BLADE', name: 'Meteor Blade', characterId: 'A1', slot: null, damage: 2800, cooldown: 26, unlock: 44, element: 'FIRE', description: 'Summon meteor onto blade', icon: '‚òÑÔ∏è', tier: 'legendary', burn: true },
          { id: 'A1_OMEGA_STRIKE', name: 'Omega Strike', characterId: 'A1', slot: null, damage: 3500, cooldown: 30, unlock: 50, element: 'ARCANE', description: 'Ultimate finishing move', icon: 'üí•', tier: 'legendary', crit: true, pierce: true },
          
          // === UNIQUE EXTENDED SKILLS (19 more) ===
          { id: 'UNIQUE_LASER_BARRAGE', name: 'Laser Barrage', characterId: 'UNIQUE', slot: null, damage: 850, cooldown: 9, unlock: 14, element: 'ENERGY', description: '20-hit laser beam barrage', icon: 'üí•', tier: 'uncommon' },
          { id: 'UNIQUE_QUANTUM_SHIFT', name: 'Quantum Shift', characterId: 'UNIQUE', slot: null, damage: 0, cooldown: 8, unlock: 16, element: 'ARCANE', description: 'Teleport with damage immunity', icon: 'üåÄ', tier: 'rare' },
          { id: 'UNIQUE_NANO_SWARM', name: 'Nano Swarm', characterId: 'UNIQUE', slot: null, damage: 1100, cooldown: 12, unlock: 20, element: 'PLASMA', description: 'Deploy nano-bot swarm', icon: 'ü¶†', tier: 'rare' },
          { id: 'UNIQUE_GRAVITON_BEAM', name: 'Graviton Beam', characterId: 'UNIQUE', slot: null, damage: 1400, cooldown: 15, unlock: 25, element: 'ARCANE', description: 'Gravity-crushing beam', icon: 'üåå', tier: 'epic' },
          { id: 'UNIQUE_PULSE_CANNON', name: 'Pulse Cannon', characterId: 'UNIQUE', slot: null, damage: 1600, cooldown: 16, unlock: 28, element: 'ENERGY', description: 'Charged pulse explosion', icon: 'üí•', tier: 'epic' },
          { id: 'UNIQUE_TESLA_COIL', name: 'Tesla Coil', characterId: 'UNIQUE', slot: null, damage: 1200, cooldown: 13, unlock: 23, element: 'LIGHTNING', description: 'Electric field damages all nearby', icon: '‚ö°', tier: 'rare', chain: true },
          { id: 'UNIQUE_CRYO_MISSILE', name: 'Cryo Missile', characterId: 'UNIQUE', slot: null, damage: 1500, cooldown: 14, unlock: 26, element: 'ICE', description: 'Freezing missile barrage', icon: '‚ùÑÔ∏è', tier: 'rare', freeze: true },
          { id: 'UNIQUE_PHOTON_LANCE', name: 'Photon Lance', characterId: 'UNIQUE', slot: null, damage: 1800, cooldown: 17, unlock: 32, element: 'LIGHT', description: 'Pierce all enemies with light beam', icon: 'üí´', tier: 'epic', pierce: true },
          { id: 'UNIQUE_DARK_MATTER', name: 'Dark Matter Bomb', characterId: 'UNIQUE', slot: null, damage: 2100, cooldown: 19, unlock: 36, element: 'ARCANE', description: 'Summon dark matter explosion', icon: 'üåå', tier: 'legendary' },
          { id: 'UNIQUE_FUSION_CORE', name: 'Fusion Core', characterId: 'UNIQUE', slot: null, damage: 2400, cooldown: 21, unlock: 39, element: 'FIRE', description: 'Mini nuclear explosion', icon: '‚ò¢Ô∏è', tier: 'legendary', burn: true },
          { id: 'UNIQUE_ORBITAL_STRIKE', name: 'Orbital Strike', characterId: 'UNIQUE', slot: null, damage: 2200, cooldown: 20, unlock: 37, element: 'ENERGY', description: 'Call down satellite beam', icon: 'üõ∞Ô∏è', tier: 'legendary' },
          { id: 'UNIQUE_ANTIMATTER', name: 'Antimatter Wave', characterId: 'UNIQUE', slot: null, damage: 2600, cooldown: 23, unlock: 41, element: 'ARCANE', description: 'Annihilate with antimatter', icon: 'üí•', tier: 'legendary', silence: true },
          { id: 'UNIQUE_CYBER_OVERDRIVE', name: 'Cyber Overdrive', characterId: 'UNIQUE', slot: null, damage: 1900, cooldown: 18, unlock: 34, element: 'LIGHTNING', description: 'Overclock all systems', icon: '‚ö°', tier: 'epic', chain: true },
          { id: 'UNIQUE_VOID_CANNON', name: 'Void Cannon', characterId: 'UNIQUE', slot: null, damage: 2300, cooldown: 20, unlock: 38, element: 'SHADOW', description: 'Fire void energy projectile', icon: 'üåë', tier: 'legendary' },
          { id: 'UNIQUE_PLASMA_NOVA', name: 'Plasma Nova', characterId: 'UNIQUE', slot: null, damage: 2500, cooldown: 22, unlock: 40, element: 'PLASMA', description: 'Exploding plasma sphere', icon: '‚òÄÔ∏è', tier: 'legendary' },
          { id: 'UNIQUE_SINGULARITY', name: 'Singularity', characterId: 'UNIQUE', slot: null, damage: 2800, cooldown: 25, unlock: 43, element: 'ARCANE', description: 'Create black hole', icon: 'üï≥Ô∏è', tier: 'legendary', stun: true },
          { id: 'UNIQUE_PHASE_BEAM', name: 'Phase Beam', characterId: 'UNIQUE', slot: null, damage: 2100, cooldown: 19, unlock: 35, element: 'ARCANE', description: 'Beam phases through obstacles', icon: 'üåÄ', tier: 'epic', pierce: true },
          { id: 'UNIQUE_ION_STORM', name: 'Ion Storm', characterId: 'UNIQUE', slot: null, damage: 2700, cooldown: 24, unlock: 42, element: 'LIGHTNING', description: 'Massive ion storm', icon: '‚õàÔ∏è', tier: 'legendary', chain: true },
          { id: 'UNIQUE_OMEGA_BEAM', name: 'Omega Beam', characterId: 'UNIQUE', slot: null, damage: 3600, cooldown: 30, unlock: 50, element: 'ENERGY', description: 'Ultimate mega-beam', icon: 'üí•', tier: 'legendary', crit: true },
          
          // === MISSY EXTENDED SKILLS (19 more) ===
          { id: 'MISSY_ANGEL_WINGS', name: 'Angel Wings', characterId: 'MISSY', slot: null, damage: 0, cooldown: 10, unlock: 15, element: 'LIGHT', description: 'Summon angel wings for flight', icon: 'ü™Ω', tier: 'rare' },
          { id: 'MISSY_HOLY_NOVA', name: 'Holy Nova', characterId: 'MISSY', slot: null, damage: 950, cooldown: 9, unlock: 13, element: 'LIGHT', description: 'Burst of holy light', icon: '‚ú®', tier: 'uncommon' },
          { id: 'MISSY_CAT_SCRATCH', name: 'Cat Scratch Fury', characterId: 'MISSY', slot: null, damage: 1100, cooldown: 11, unlock: 17, element: 'PHYSICAL', description: 'Rapid claw attacks', icon: 'üêæ', tier: 'rare' },
          { id: 'MISSY_DIVINE_SHIELD', name: 'Divine Shield', characterId: 'MISSY', slot: null, damage: 0, cooldown: 12, unlock: 19, element: 'LIGHT', description: 'Protective light barrier', icon: 'üõ°Ô∏è', tier: 'rare' },
          { id: 'MISSY_GOLDEN_RAIN', name: 'Golden Rain', characterId: 'MISSY', slot: null, damage: 1300, cooldown: 14, unlock: 23, element: 'LIGHT', description: 'Rain of golden arrows', icon: 'üèπ', tier: 'rare', luck: true },
          { id: 'MISSY_ANGEL_BEAM', name: 'Angel Beam', characterId: 'MISSY', slot: null, damage: 1500, cooldown: 15, unlock: 27, element: 'LIGHT', description: 'Channeled holy beam', icon: 'üí´', tier: 'epic' },
          { id: 'MISSY_NINE_LIVES', name: 'Nine Lives', characterId: 'MISSY', slot: null, damage: 0, cooldown: 20, unlock: 30, element: 'LIGHT', description: 'Revive with full HP once', icon: 'üò∏', tier: 'epic' },
          { id: 'MISSY_MOONLIGHT', name: 'Moonlight Slash', characterId: 'MISSY', slot: null, damage: 1600, cooldown: 16, unlock: 29, element: 'LIGHT', description: 'Crescent moon projectile', icon: 'üåô', tier: 'epic' },
          { id: 'MISSY_STARDUST', name: 'Stardust Storm', characterId: 'MISSY', slot: null, damage: 1400, cooldown: 14, unlock: 25, element: 'LIGHT', description: 'Swirling stardust attack', icon: '‚≠ê', tier: 'rare' },
          { id: 'MISSY_DUAL_SHOT', name: 'Dual Shot', characterId: 'MISSY', slot: null, damage: 1200, cooldown: 12, unlock: 21, element: 'PHYSICAL', description: 'Fire both weapons at once', icon: 'üî´', tier: 'rare' },
          { id: 'MISSY_HEAVEN_STRIKE', name: 'Heaven Strike', characterId: 'MISSY', slot: null, damage: 2000, cooldown: 18, unlock: 33, element: 'LIGHT', description: 'Summon heavenly lightning', icon: '‚ö°', tier: 'epic' },
          { id: 'MISSY_LUCKY_SEVEN', name: 'Lucky Seven', characterId: 'MISSY', slot: null, damage: 1700, cooldown: 16, unlock: 31, element: 'LIGHT', description: '7 lucky shots guaranteed crits', icon: 'üé∞', tier: 'epic', luck: true, crit: true },
          { id: 'MISSY_ANGEL_JUDGMENT', name: 'Angel Judgment', characterId: 'MISSY', slot: null, damage: 2200, cooldown: 20, unlock: 37, element: 'LIGHT', description: 'Divine judgment from above', icon: '‚öñÔ∏è', tier: 'legendary' },
          { id: 'MISSY_CAT_POUNCE', name: 'Cat Pounce', characterId: 'MISSY', slot: null, damage: 1800, cooldown: 17, unlock: 32, element: 'PHYSICAL', description: 'Leap and strike from above', icon: 'üê±', tier: 'epic' },
          { id: 'MISSY_HOLY_ARROW', name: 'Holy Arrow Barrage', characterId: 'MISSY', slot: null, damage: 1900, cooldown: 18, unlock: 34, element: 'LIGHT', description: '30 holy arrows rain down', icon: 'üèπ', tier: 'epic', pierce: true },
          { id: 'MISSY_CELESTIAL_BEAM', name: 'Celestial Beam', characterId: 'MISSY', slot: null, damage: 2400, cooldown: 21, unlock: 39, element: 'LIGHT', description: 'Beam from heaven', icon: '‚òÄÔ∏è', tier: 'legendary' },
          { id: 'MISSY_JACKPOT_777', name: 'Jackpot 777', characterId: 'MISSY', slot: null, damage: 2600, cooldown: 23, unlock: 41, element: 'LIGHT', description: 'Triple 7 mega win', icon: 'üé∞', tier: 'legendary', luck: true, crit: true },
          { id: 'MISSY_SERAPH_WINGS', name: 'Seraph Wings', characterId: 'MISSY', slot: null, damage: 2800, cooldown: 25, unlock: 43, element: 'LIGHT', description: 'Transform into seraph', icon: 'üëº', tier: 'legendary' },
          { id: 'MISSY_DIVINE_WRATH', name: 'Divine Wrath', characterId: 'MISSY', slot: null, damage: 3700, cooldown: 30, unlock: 50, element: 'LIGHT', description: 'Ultimate holy power', icon: '‚ú®', tier: 'legendary', crit: true, pierce: true }
        ],
        items: [
          // ===  CHESTS & CONTAINERS ===
          { id: "item_chest_001", name: "Bronze Chest", icon: "üì¶", category: "container", quantity: 3, dropTable: ['common'], goldRange: [50, 100] },
          { id: "item_chest_002", name: "Silver Chest", icon: "üéÅ", category: "container", quantity: 2, dropTable: ['uncommon', 'rare'], goldRange: [100, 250] },
          { id: "item_chest_003", name: "Golden Chest", icon: "üíé", category: "container", quantity: 1, dropTable: ['rare', 'epic'], goldRange: [250, 500] },
          { id: "item_chest_004", name: "Legendary Chest", icon: "üèÜ", category: "container", quantity: 1, dropTable: ['epic', 'legendary'], goldRange: [500, 1000] },
          { id: "item_chest_005", name: "Mystery Box", icon: "üé≤", category: "container", quantity: 5, dropTable: ['random'], goldRange: [10, 1000] },
          
          // === POTIONS ===
          { id: "item_potion_001", name: "Health Potion", icon: "üß™", category: "consumable", quantity: 10, effect: 'heal', value: 50 },
          { id: "item_potion_002", name: "Mana Potion", icon: "üíô", category: "consumable", quantity: 5, effect: 'mana', value: 30 },
          { id: "item_potion_003", name: "Greater Health Potion", icon: "‚ù§Ô∏è", category: "consumable", quantity: 3, effect: 'heal', value: 150 },
          { id: "item_potion_004", name: "Elixir of Life", icon: "üíó", category: "consumable", quantity: 1, effect: 'fullHeal', value: 9999 },
          { id: "item_potion_005", name: "Speed Potion", icon: "‚ö°", category: "consumable", quantity: 7, effect: 'speedBoost', value: 50, duration: 30000 },
          { id: "item_potion_006", name: "Strength Elixir", icon: "üí™", category: "consumable", quantity: 4, effect: 'atkBoost', value: 25, duration: 60000 },
          { id: "item_potion_007", name: "Iron Skin Potion", icon: "üõ°Ô∏è", category: "consumable", quantity: 4, effect: 'defBoost', value: 30, duration: 60000 },
          { id: "item_potion_008", name: "Lucky Charm", icon: "üçÄ", category: "consumable", quantity: 2, effect: 'luckBoost', value: 100, duration: 120000 },
          { id: "item_potion_009", name: "Resurrection Scroll", icon: "üìú", category: "consumable", quantity: 1, effect: 'revive', value: 100 },
          { id: "item_potion_010", name: "XP Boost Potion", icon: "‚≠ê", category: "consumable", quantity: 3, effect: 'xpBoost', value: 100, duration: 300000 },
          
          // === MATERIALS ===
          { id: "item_mat_001", name: "Iron Ore", icon: "‚õèÔ∏è", category: "material", quantity: 25, value: 10 },
          { id: "item_mat_002", name: "Gold Ore", icon: "üí∞", category: "material", quantity: 15, value: 50 },
          { id: "item_mat_003", name: "Diamond", icon: "üíé", category: "material", quantity: 5, value: 500 },
          { id: "item_mat_004", name: "Magic Crystal", icon: "üîÆ", category: "material", quantity: 10, value: 100 },
          { id: "item_mat_005", name: "Dragon Scale", icon: "üêâ", category: "material", quantity: 3, value: 1000 },
          { id: "item_mat_006", name: "Phoenix Feather", icon: "üî•", category: "material", quantity: 2, value: 2000 },
          { id: "item_mat_007", name: "Mithril Bar", icon: "üìä", category: "material", quantity: 8, value: 300 },
          { id: "item_mat_008", name: "Shadow Essence", icon: "üåë", category: "material", quantity: 12, value: 150 },
          { id: "item_mat_009", name: "Light Shard", icon: "‚ú®", category: "material", quantity: 10, value: 200 },
          { id: "item_mat_010", name: "Ancient Rune", icon: "üìø", category: "material", quantity: 4, value: 800 },
          
          // === FOOD & CONSUMABLES ===
          { id: "item_food_001", name: "Bread", icon: "üçû", category: "food", quantity: 20, effect: 'heal', value: 10 },
          { id: "item_food_002", name: "Steak", icon: "ü•©", category: "food", quantity: 15, effect: 'heal', value: 30 },
          { id: "item_food_003", name: "Apple", icon: "üçé", category: "food", quantity: 30, effect: 'heal', value: 5 },
          { id: "item_food_004", name: "Golden Apple", icon: "üåü", category: "food", quantity: 2, effect: 'heal', value: 100, permanent: {maxHp: 10} },
          { id: "item_food_005", name: "Dragon Fruit", icon: "üê≤", category: "food", quantity: 1, effect: 'powerUp', value: 50, duration: 180000 },
          
          // === SPECIAL ITEMS ===
          { id: "item_special_001", name: "Teleport Scroll", icon: "üåÄ", category: "special", quantity: 5, effect: 'teleport' },
          { id: "item_special_002", name: "Return Stone", icon: "üè†", category: "special", quantity: 10, effect: 'returnHome' },
          { id: "item_special_003", name: "Battle Flag", icon: "üö©", category: "special", quantity: 3, effect: 'rallyCry', duration: 60000 },
          { id: "item_special_004", name: "Pet Whistle", icon: "üéµ", category: "special", quantity: 999, effect: 'summonPet' },
          { id: "item_special_005", name: "Experience Tome", icon: "üìñ", category: "special", quantity: 2, effect: 'instantLevel' },
          { id: "item_special_006", name: "Skill Reset Orb", icon: "üîÑ", category: "special", quantity: 1, effect: 'resetSkills' },
          { id: "item_special_007", name: "Gear Enchant Scroll", icon: "‚ú®", category: "special", quantity: 8, effect: 'enchantGear' },
          { id: "item_special_008", name: "Duplicate Mirror", icon: "ü™û", category: "special", quantity: 1, effect: 'duplicate' }
        ],
        gear: [
          // === WEAPONS - SWORDS ===
          { id: "gear_sword_001", name: "Steel Longsword", icon: "‚öîÔ∏è", slot: "weapon", attack: 45, rarity: "rare", level: 10 },
          { id: "gear_sword_002", name: "Iron Dagger", icon: "üó°Ô∏è", slot: "weapon", attack: 28, rarity: "common", level: 1 },
          { id: "gear_sword_003", name: "Flaming Blade", icon: "üî•", slot: "weapon", attack: 80, rarity: "epic", level: 25, special: "burn" },
          { id: "gear_sword_004", name: "Frost Saber", icon: "‚ùÑÔ∏è", slot: "weapon", attack: 75, rarity: "epic", level: 22, special: "freeze" },
          { id: "gear_sword_005", name: "Dragon Slayer", icon: "üêâ", slot: "weapon", attack: 150, rarity: "legendary", level: 50, special: "dragonSlayer" },
          { id: "gear_sword_006", name: "Shadow Reaper", icon: "üåë", slot: "weapon", attack: 120, crit: 25, rarity: "legendary", level: 45, special: "lifesteal" },
          { id: "gear_sword_007", name: "Holy Avenger", icon: "‚ú®", slot: "weapon", attack: 130, rarity: "legendary", level: 48, special: "smite" },
          { id: "gear_sword_008", name: "Katana of Speed", icon: "‚ö°", slot: "weapon", attack: 65, speed: 30, rarity: "rare", level: 18 },
          
          // === WEAPONS - BOWS & GUNS ===
          { id: "gear_bow_001", name: "Hunter's Bow", icon: "üèπ", slot: "weapon", attack: 40, rarity: "uncommon", level: 8, range: 150 },
          { id: "gear_bow_002", name: "Sniper Rifle", icon: "üî´", slot: "weapon", attack: 95, crit: 40, rarity: "epic", level: 30, range: 300 },
          { id: "gear_bow_003", name: "Plasma Cannon", icon: "üí•", slot: "weapon", attack: 140, rarity: "legendary", level: 45, special: "aoe" },
          
          // === WEAPONS - MAGIC ===
          { id: "gear_staff_001", name: "Wooden Staff", icon: "ü™Ñ", slot: "weapon", attack: 30, magic: 40, rarity: "common", level: 1 },
          { id: "gear_staff_002", name: "Arcane Scepter", icon: "üîÆ", slot: "weapon", attack: 60, magic: 80, rarity: "epic", level: 25 },
          { id: "gear_staff_003", name: "Staff of Cosmos", icon: "üåå", slot: "weapon", attack: 110, magic: 150, rarity: "legendary", level: 50, special: "cosmos" },
          
          // === ARMOR - HELMETS ===
          { id: "gear_helmet_001", name: "Iron Helmet", icon: "‚õëÔ∏è", slot: "head", defense: 15, hp: 20, rarity: "uncommon", level: 5 },
          { id: "gear_helmet_002", name: "Steel Helm", icon: "ü™ñ", slot: "head", defense: 30, hp: 40, rarity: "rare", level: 15 },
          { id: "gear_helmet_003", name: "Dragon Helm", icon: "üê≤", slot: "head", defense: 60, hp: 100, rarity: "epic", level: 30 },
          { id: "gear_helmet_004", name: "Crown of Kings", icon: "üëë", slot: "head", defense: 50, hp: 80, magic: 50, rarity: "legendary", level: 40 },
          { id: "gear_helmet_005", name: "Shadow Hood", icon: "üé≠", slot: "head", defense: 25, speed: 20, crit: 15, rarity: "rare", level: 20 },
          
          // === ARMOR - CHEST ===
          { id: "gear_armor_001", name: "Chainmail Armor", icon: "üõ°Ô∏è", slot: "chest", defense: 35, hp: 50, rarity: "rare", level: 12 },
          { id: "gear_armor_002", name: "Leather Vest", icon: "üëî", slot: "chest", defense: 20, hp: 30, rarity: "common", level: 1 },
          { id: "gear_armor_003", name: "Plate Armor", icon: "ü¶∫", slot: "chest", defense: 70, hp: 120, rarity: "epic", level: 28 },
          { id: "gear_armor_004", name: "Dragonscale Mail", icon: "üêâ", slot: "chest", defense: 100, hp: 200, rarity: "legendary", level: 45, special: "fireResist" },
          { id: "gear_armor_005", name: "Assassin's Cloak", icon: "ü•∑", slot: "chest", defense: 40, speed: 40, crit: 20, rarity: "epic", level: 25 },
          { id: "gear_armor_006", name: "Mage Robes", icon: "üßô", slot: "chest", defense: 25, hp: 60, magic: 80, rarity: "rare", level: 18 },
          
          // === ARMOR - GLOVES ===
          { id: "gear_gloves_001", name: "Steel Gauntlets", icon: "üß§", slot: "gloves", defense: 12, attack: 5, rarity: "rare", level: 10 },
          { id: "gear_gloves_002", name: "Leather Gloves", icon: "ü§≤", slot: "gloves", defense: 5, attack: 3, rarity: "common", level: 1 },
          { id: "gear_gloves_003", name: "Titan Gauntlets", icon: "üí™", slot: "gloves", defense: 25, attack: 15, hp: 30, rarity: "epic", level: 30 },
          { id: "gear_gloves_004", name: "Shadow Wraps", icon: "üåë", slot: "gloves", defense: 15, crit: 25, speed: 15, rarity: "rare", level: 22 },
          { id: "gear_gloves_005", name: "Arcane Gloves", icon: "‚ú®", slot: "gloves", defense: 18, magic: 40, rarity: "epic", level: 26 },
          
          // === ARMOR - PANTS ===
          { id: "gear_pants_001", name: "Iron Greaves", icon: "ü¶µ", slot: "pants", defense: 25, hp: 35, rarity: "uncommon", level: 8 },
          { id: "gear_pants_002", name: "Leather Pants", icon: "üëñ", slot: "pants", defense: 15, hp: 20, rarity: "common", level: 1 },
          { id: "gear_pants_003", name: "Plate Leggings", icon: "ü¶ø", slot: "pants", defense: 50, hp: 80, rarity: "epic", level: 25 },
          { id: "gear_pants_004", name: "Swift Boots", icon: "üëü", slot: "pants", defense: 20, speed: 50, rarity: "rare", level: 15 },
          
          // === ARMOR - BOOTS ===
          { id: "gear_boots_001", name: "Steel Boots", icon: "ü•æ", slot: "boots", defense: 15, hp: 25, rarity: "uncommon", level: 6 },
          { id: "gear_boots_002", name: "Leather Boots", icon: "üë¢", slot: "boots", defense: 10, speed: 10, rarity: "common", level: 1 },
          { id: "gear_boots_003", name: "Dragon Boots", icon: "üê≤", slot: "boots", defense: 35, hp: 60, speed: 25, rarity: "epic", level: 28 },
          { id: "gear_boots_004", name: "Winged Boots", icon: "ü™Ω", slot: "boots", defense: 20, speed: 80, rarity: "legendary", level: 35, special: "flight" },
          
          // === ACCESSORIES - RINGS ===
          { id: "gear_ring_001", name: "Gold Ring", icon: "üíç", slot: "ring", hp: 15, rarity: "common", level: 1 },
          { id: "gear_ring_002", name: "Ruby Ring", icon: "üíé", slot: "ring", attack: 20, hp: 25, rarity: "rare", level: 12 },
          { id: "gear_ring_003", name: "Sapphire Ring", icon: "üí†", slot: "ring", magic: 35, hp: 30, rarity: "rare", level: 14 },
          { id: "gear_ring_004", name: "Dragon Ring", icon: "üêâ", slot: "ring", attack: 40, defense: 30, hp: 50, rarity: "epic", level: 30 },
          { id: "gear_ring_005", name: "Ring of Power", icon: "‚ö°", slot: "ring", attack: 60, magic: 60, hp: 80, rarity: "legendary", level: 45 },
          { id: "gear_ring_006", name: "Speed Ring", icon: "üí®", slot: "ring", speed: 40, crit: 15, rarity: "epic", level: 25 },
          
          // === ACCESSORIES - NECKLACES ===
          { id: "gear_neck_001", name: "Silver Necklace", icon: "üìø", slot: "necklace", hp: 20, defense: 10, rarity: "common", level: 1 },
          { id: "gear_neck_002", name: "Amulet of Protection", icon: "üõ°Ô∏è", slot: "necklace", defense: 40, hp: 60, rarity: "rare", level: 16 },
          { id: "gear_neck_003", name: "Phoenix Pendant", icon: "üî•", slot: "necklace", magic: 50, hp: 100, rarity: "epic", level: 28, special: "revive" },
          { id: "gear_neck_004", name: "Cosmic Amulet", icon: "üåå", slot: "necklace", attack: 50, magic: 50, hp: 120, rarity: "legendary", level: 50 },
          { id: "gear_neck_005", name: "Lucky Charm", icon: "üçÄ", slot: "necklace", luck: 50, crit: 20, rarity: "rare", level: 18 },
          
          // === OFFHAND ===
          { id: "gear_shield_001", name: "Wooden Shield", icon: "üõ°Ô∏è", slot: "offhand", defense: 20, rarity: "common", level: 1 },
          { id: "gear_shield_002", name: "Iron Shield", icon: "üõ°Ô∏è", slot: "offhand", defense: 40, hp: 40, rarity: "uncommon", level: 10 },
          { id: "gear_shield_003", name: "Tower Shield", icon: "üõ°Ô∏è", slot: "offhand", defense: 80, hp: 100, rarity: "epic", level: 30 },
          { id: "gear_shield_004", name: "Aegis of Legend", icon: "üõ°Ô∏è", slot: "offhand", defense: 120, hp: 150, rarity: "legendary", level: 45, special: "reflect" },
          { id: "gear_tome_001", name: "Spell Tome", icon: "üìñ", slot: "offhand", magic: 40, rarity: "rare", level: 15 },
          { id: "gear_orb_001", name: "Crystal Orb", icon: "üîÆ", slot: "offhand", magic: 70, hp: 50, rarity: "epic", level: 28 },
          { id: "gear_boots_001", name: "Traveler's Boots", icon: "üë¢", category: "armor", defense: 10, rarity: "common" },
          { id: "gear_ring_001", name: "Ring of Power", icon: "üíç", category: "accessory", attack: 15, rarity: "epic" },
          { id: "gear_ring_002", name: "Ring of Protection", icon: "üíç", category: "accessory", defense: 18, rarity: "rare" },
          { id: "gear_necklace_001", name: "Amulet of Vitality", icon: "üìø", category: "accessory", hp: 80, defense: 10, rarity: "epic" },
          { id: "gear_shield_001", name: "Wooden Shield", icon: "üõ°Ô∏è", category: "weapon", defense: 25, rarity: "common" }
        ],
        vehicles: [
          { id: "vehicle_sports_car", name: "Sports Car", icon: "üèéÔ∏è", type: "car", category: "ground", speed: 1.5, agility: 0.7, durability: 0.8, cost: 1000, capacity: 2, special: "boost", description: "Fast sports car with high speed" },
          { id: "vehicle_hoverbike", name: "Hoverbike", icon: "üèçÔ∏è", type: "bike", category: "hover", speed: 1.2, agility: 1.0, durability: 0.6, cost: 800, capacity: 1, special: "agility", description: "Agile hoverbike for quick movement" },
          { id: "vehicle_jetcart", name: "Jet Cart", icon: "üõí", type: "cart", category: "ground", speed: 1.0, agility: 0.8, durability: 1.0, cost: 1200, capacity: 3, special: "durability", description: "Balanced jet-powered cart" },
          { id: "vehicle_turbo_board", name: "Turbo Board", icon: "üõπ", type: "board", category: "hover", speed: 1.3, agility: 1.2, durability: 0.5, cost: 600, capacity: 1, special: "speed", description: "Lightweight turbo board" },
          { id: "traffic_sedan", name: "Sedan", icon: "üöó", type: "sedan", category: "ground", speed: 0.57, agility: 1.0, durability: 0.71, cost: 500, capacity: 2, special: "civilian", description: "Standard civilian sedan" },
          { id: "traffic_van", name: "Van", icon: "üöê", type: "van", category: "ground", speed: 0.46, agility: 0.8, durability: 1.07, cost: 800, capacity: 3, special: "durability", description: "Heavy utility van" },
          { id: "traffic_bike", name: "Traffic Bike", icon: "üö≤", type: "bike", category: "hover", speed: 0.71, agility: 1.2, durability: 0.43, cost: 400, capacity: 1, special: "agility", description: "Fast traffic motorcycle" },
          { id: "personal_bike", name: "Personal Bike", icon: "üèçÔ∏è", type: "bike", category: "ground", speed: 2.6, agility: 1.3, durability: 0.6, cost: 900, capacity: 2, special: "speed + agility", description: "Lightweight, fast, agile bike" },
          { id: "personal_chopper", name: "Chopper", icon: "üèçÔ∏è", type: "chopper", category: "ground", speed: 2.0, agility: 0.7, durability: 1.2, cost: 1500, capacity: 3, special: "durability + capacity", description: "Heavy cruiser bike with multiple seats" },
          { id: "personal_jetpack", name: "Jetpack", icon: "üéí", type: "jetpack", category: "air", speed: 2.4, agility: 1.5, durability: 0.4, cost: 2500, capacity: 1, special: "flight + evasion", description: "Personal flight pack with vertical freedom" },
          { id: "personal_car", name: "Personal Car", icon: "üöô", type: "car", category: "ground", speed: 2.2, agility: 1.0, durability: 0.9, cost: 1100, capacity: 3, special: "balanced", description: "Balanced baseline vehicle" },
          { id: "mech_proto", name: "Mech Proto", icon: "ü§ñ", type: "mech", category: "ground", speed: 2.0, agility: 0.5, durability: 2.0, cost: 3000, capacity: 1, special: "knockback immunity", description: "Early-stage battle mech with high HP" },
          { id: "mech_apex", name: "Mech Apex", icon: "ü§ñ", type: "mech", category: "ground", speed: 2.3, agility: 0.7, durability: 2.5, cost: 5000, capacity: 1, special: "boost + missiles", description: "Advanced version with shoulder cannons" },
          { id: "skateboard_street", name: "Street Skateboard", icon: "üõπ", type: "skateboard", category: "ground", speed: 2.5, agility: 1.4, durability: 0.3, cost: 500, capacity: 1, special: "strong acceleration", description: "Street-style board with strong acceleration" },
          { id: "transit_bus", name: "Bus", icon: "üöå", type: "bus", category: "ground", speed: 0.64, agility: 0.5, durability: 1.5, cost: 2000, capacity: 8, special: "transport", description: "Public bus for passengers" },
          { id: "transit_train", name: "Train", icon: "üöÜ", type: "train", category: "ground", speed: 0.93, agility: 0.3, durability: 2.0, cost: 5000, capacity: 8, special: "transport", description: "High-speed train coach" },
          { id: "vehicle_hoverbike_alt", name: "Hoverbike Alt", icon: "üèçÔ∏è", type: "bike", category: "hover", speed: 1.1, agility: 0.9, durability: 0.7, cost: 750, capacity: 1, special: "agility", description: "Alternative hoverbike design" }
        ],
        pets: [
          { id: "pet_firecub", name: "Fire Cub", icon: "üî•", element: "fire", rarity: "common", attack: 20, health: 80, speed: 0.6, cost: 300, ability: "Fire Breath", abilityDamage: 30, description: "A playful fire cub that shoots small fireballs" },
          { id: "pet_flame_spirit", name: "Flame Spirit", icon: "üî•", element: "fire", rarity: "rare", attack: 28, health: 75, speed: 0.7, cost: 800, ability: "Fire Breath", abilityDamage: 30, description: "Ethereal flame spirit with intense heat" },
          { id: "pet_icewolf", name: "Ice Wolf", icon: "üê∫", element: "ice", rarity: "common", attack: 18, health: 90, speed: 0.5, cost: 350, ability: "Ice Shard", abilityDamage: 25, description: "Loyal ice wolf with freezing attacks" },
          { id: "pet_frost_wolf", name: "Frost Wolf", icon: "üê∫", element: "ice", rarity: "rare", attack: 25, health: 100, speed: 0.5, cost: 850, ability: "Ice Shard", abilityDamage: 25, description: "Powerful frost wolf alpha" },
          { id: "pet_lightningbird", name: "Lightning Bird", icon: "ü¶Ö", element: "electric", rarity: "uncommon", attack: 30, health: 60, speed: 0.8, cost: 600, ability: "Lightning Strike", abilityDamage: 35, description: "Fast electric bird with shocking strikes" },
          { id: "pet_earthgolem", name: "Earth Golem", icon: "üóø", element: "earth", rarity: "rare", attack: 35, health: 150, speed: 0.3, cost: 900, ability: "Rock Throw", abilityDamage: 40, description: "Sturdy rock golem with crushing power" },
          { id: "pet_airsprite", name: "Air Sprite", icon: "üí®", element: "wind", rarity: "uncommon", attack: 15, health: 70, speed: 0.9, cost: 550, ability: "Gust", abilityDamage: 20, description: "Swift air sprite that dances on the wind" },
          { id: "pet_magic_monkey", name: "Magic Monkey", icon: "üêµ", element: "arcane", rarity: "epic", attack: 40, health: 90, speed: 0.6, cost: 1500, ability: "Magic Missile", abilityDamage: 45, description: "Mischievous magical monkey with arcane powers" },
          { id: "pet_magicfrog", name: "Magic Frog", icon: "üê∏", element: "arcane", rarity: "common", attack: 12, health: 50, speed: 0.4, cost: 250, ability: "Magic Missile", abilityDamage: 45, description: "Cute magical frog with minor spells" },
          { id: "pet_gremlin", name: "Gremlin", icon: "üëπ", element: "dark", rarity: "uncommon", attack: 22, health: 65, speed: 0.7, cost: 500, ability: "Shadow Claw", abilityDamage: 35, description: "Sneaky gremlin with shadow attacks" },
          { id: "pet_missy", name: "Missy Spirit", icon: "üëº", element: "light", rarity: "legendary", attack: 50, health: 120, speed: 0.5, cost: 2500, ability: "Holy Light", abilityDamage: 50, description: "Legendary light spirit with divine power" },
          { id: "pet_dark_missy", name: "Dark Missy", icon: "üòà", element: "shadow", rarity: "legendary", attack: 55, health: 130, speed: 0.7, cost: 3000, ability: "Shadow Shot", abilityDamage: 55, description: "Dark angel with halo and wing, dual-wielding sword and gun" },
          { id: "summon_robot_drone", name: "Robot Drone", icon: "ü§ñ", element: "tech", rarity: "epic", attack: 35, health: 100, speed: 0.7, cost: 1200, ability: "Energy Beam", abilityDamage: 40, description: "Combat drone with energy blasters" },
          // === NEW PETS - EXPANSION ===
          { id: "pet_dragon_001", name: "Baby Dragon", icon: "üê≤", element: "fire", rarity: "epic", attack: 45, health: 140, speed: 0.6, cost: 2000, ability: "Dragon Breath", abilityDamage: 60, description: "Young dragon with powerful fire breath" },
          { id: "pet_phoenix_001", name: "Phoenix", icon: "ü¶Ö", element: "fire", rarity: "legendary", attack: 60, health: 110, speed: 0.9, cost: 3500, ability: "Rebirth", abilityDamage: 70, special: "reviveOnce", description: "Majestic phoenix that can revive once per battle" },
          { id: "pet_unicorn_001", name: "Unicorn", icon: "ü¶Ñ", element: "light", rarity: "epic", attack: 35, health: 120, speed: 0.8, cost: 1800, ability: "Heal Aura", abilityDamage: 0, special: "healParty", description: "Magical unicorn that heals allies" },
          { id: "pet_demon_001", name: "Shadow Demon", icon: "üëπ", element: "dark", rarity: "legendary", attack: 65, health: 150, speed: 0.5, cost: 4000, ability: "Void Blast", abilityDamage: 80, description: "Powerful demon from the shadow realm" },
          { id: "pet_turtle_001", name: "Thunder Turtle", icon: "üê¢", element: "electric", rarity: "rare", attack: 25, health: 180, speed: 0.3, cost: 1000, ability: "Thunder Shell", abilityDamage: 35, special: "highDefense", description: "Slow but tanky electric turtle" },
          { id: "pet_cat_001", name: "Cyber Cat", icon: "üê±", element: "tech", rarity: "uncommon", attack: 28, health: 75, speed: 0.8, cost: 700, ability: "Laser Eyes", abilityDamage: 30, description: "Cybernetically enhanced feline" },
          { id: "pet_panda_001", name: "Spirit Panda", icon: "üêº", element: "nature", rarity: "epic", attack: 40, health: 160, speed: 0.4, cost: 1600, ability: "Nature's Wrath", abilityDamage: 50, description: "Gentle giant with nature magic" },
          { id: "pet_snake_001", name: "Venom Serpent", icon: "üêç", element: "poison", rarity: "rare", attack: 32, health: 85, speed: 0.7, cost: 1100, ability: "Poison Fang", abilityDamage: 40, special: "poisonDot", description: "Deadly snake with toxic venom" },
          { id: "pet_lion_001", name: "Thunder Lion", icon: "ü¶Å", element: "electric", rarity: "epic", attack: 50, health: 135, speed: 0.6, cost: 2200, ability: "Roar", abilityDamage: 55, special: "stunEnemies", description: "Majestic lion with electric mane" },
          { id: "pet_octopus_001", name: "Kraken Jr", icon: "üêô", element: "water", rarity: "legendary", attack: 58, health: 145, speed: 0.7, cost: 3200, ability: "Tidal Wave", abilityDamage: 75, description: "Baby kraken with water mastery" },
          { id: "pet_bee_001", name: "Mega Bee", icon: "üêù", element: "nature", rarity: "uncommon", attack: 20, health: 60, speed: 0.9, cost: 600, ability: "Sting Barrage", abilityDamage: 25, description: "Giant bee with rapid attacks" },
          { id: "pet_ghost_001", name: "Friendly Ghost", icon: "üëª", element: "spirit", rarity: "rare", attack: 30, health: 90, speed: 0.8, cost: 1300, ability: "Haunt", abilityDamage: 45, special: "phaseThrough", description: "Playful ghost that phases through attacks" },
          { id: "pet_alien_001", name: "UFO Pet", icon: "üõ∏", element: "cosmic", rarity: "legendary", attack: 70, health: 125, speed: 0.8, cost: 5000, ability: "Cosmic Ray", abilityDamage: 90, description: "Extraterrestrial companion from beyond the stars" }
        ],
        spirits: [
          { id: "dark_soul", name: "Dark Soul", icon: "üúè", element: "dark", rarity: "rare", power: 85, bonusType: "atkMul", bonusValue: 0.06, attackDamage: 30, description: "A dark energy spirit that enhances offensive power through shadow energy" },
          { id: "light_soul", name: "Light Soul", icon: "‚òÄÔ∏è", element: "light", rarity: "rare", power: 90, bonusType: "hpFlat", bonusValue: 60, attackDamage: 25, description: "A radiant light spirit that grants protective health and slow-fall abilities" },
          { id: "golden_spirit", name: "Golden Spirit", icon: "‚ú∂", element: "gold", rarity: "uncommon", power: 75, bonusType: "goldGain", bonusValue: 0.15, attackDamage: 20, description: "A fortunate spirit that increases gold collection and attracts nearby treasures" },
          { id: "tech_essence", name: "Tech Essence", icon: "‚ö°", element: "tech", rarity: "rare", power: 80, bonusType: "speedMul", bonusValue: 0.05, attackDamage: 35, description: "A technological spirit core that boosts movement speed and reaction time" },
          { id: "storm_wisp", name: "Storm Wisp", icon: "üå©Ô∏è", element: "storm", rarity: "epic", power: 92, bonusType: "atkMul", bonusValue: 0.08, attackDamage: 40, description: "A powerful storm spirit combining attack power and speed with chain lightning" },
          { id: "guardian_sand", name: "Guardian Sand", icon: "‚è≥", element: "earth", rarity: "epic", power: 88, bonusType: "damageTakenMul", bonusValue: 0.85, attackDamage: 28, description: "An ancient earth guardian that reduces incoming damage through protective barriers" },
          { id: "ember_fox", name: "Ember Fox", icon: "ü¶ä", element: "fire", rarity: "legendary", power: 94, bonusType: "atkMul", bonusValue: 0.05, attackDamage: 45, description: "A legendary fire fox spirit granting attack power and luck through blazing trails" }
        ],
        robots: [
          { id: "robox_standard", name: "Robox Standard", icon: "ü§ñ", type: "combat_bot", category: "ground", tier: "common", hp: 2000, atk: 300, def: 50, speed: 140, cost: 1000, abilities: ["Sword Slash", "Energy Bolt", "Triple Strike"], modes: ["follow", "aggro", "guard"], description: "Standard Robox combat bot with balanced stats" },
          { id: "robox_elite", name: "Robox Elite", icon: "ü§ñ", type: "combat_bot", category: "ground", tier: "rare", hp: 3500, atk: 500, def: 100, speed: 160, cost: 3000, abilities: ["Lightning Fan", "Domain Pulse", "Spiral Volley"], modes: ["follow", "aggro", "guard"], description: "Elite version with enhanced weapons and shields" },
          { id: "robox_titan", name: "Robox Titan", icon: "ü§ñ", type: "combat_bot", category: "ground", tier: "legendary", hp: 5000, atk: 800, def: 200, speed: 120, cost: 8000, abilities: ["Mega Beam", "Rocket Barrage", "EMP Pulse", "Overdrive"], modes: ["follow", "aggro", "rampage"], description: "Massive combat bot with devastating firepower" },
          { id: "drone_scout", name: "Scout Drone", icon: "üõ∏", type: "support_drone", category: "hover", tier: "common", hp: 800, atk: 100, def: 20, speed: 200, cost: 500, abilities: ["Scan", "Light Laser"], modes: ["follow", "patrol", "scout"], description: "Fast recon drone with light weapons" },
          { id: "drone_healer", name: "Repair Drone", icon: "üõ∏", type: "support_drone", category: "hover", tier: "uncommon", hp: 1200, atk: 50, def: 30, speed: 140, cost: 1500, abilities: ["Repair Beam", "Shield Boost", "Emergency Heal"], modes: ["follow", "assist"], description: "Healing support drone that repairs allies" },
          { id: "drone_shield", name: "Shield Drone", icon: "üõ∏", type: "support_drone", category: "hover", tier: "rare", hp: 1800, atk: 0, def: 100, speed: 100, cost: 2500, abilities: ["Energy Shield", "Barrier Wall", "Reflect"], modes: ["follow", "guard", "defend"], description: "Defensive drone that projects energy shields" },
          { id: "mech_assault", name: "Assault Mech", icon: "ü¶æ", type: "mech", category: "ground", tier: "epic", hp: 4000, atk: 600, def: 150, speed: 110, cost: 5000, abilities: ["Gatling Burst", "Rocket Salvo", "Ground Pound"], modes: ["follow", "aggro", "siege"], description: "Heavy mech with dual gatling guns" },
          { id: "sniper_bot", name: "Sniper Bot", icon: "üéØ", type: "ranged_specialist", category: "ground", tier: "rare", hp: 1500, atk: 700, def: 40, speed: 100, cost: 3500, abilities: ["Railgun Shot", "Charged Blast", "Piercing Round"], modes: ["follow", "snipe", "overwatch"], description: "Long-range precision bot with railgun" },
          { id: "stealth_bot", name: "Stealth Bot", icon: "üë§", type: "infiltrator", category: "ground", tier: "epic", hp: 1000, atk: 450, def: 30, speed: 220, cost: 4000, abilities: ["Cloak", "Backstab", "Smoke Bomb", "Shadow Strike"], modes: ["follow", "hunt", "flank"], description: "Cloaking assassin bot with backstab damage" },
          { id: "guardian_angel_bot", name: "Guardian Angel", icon: "üòá", type: "support_drone", category: "hover", tier: "epic", hp: 2000, atk: 150, def: 120, speed: 160, cost: 3500, abilities: ["Divine Shield", "Resurrect", "Holy Beam", "Blessing"], modes: ["follow", "protect", "assist"], description: "Angelic support bot that shields and revives allies" },
          { id: "berserker_bot", name: "Berserker Unit", icon: "üò°", type: "combat_bot", category: "ground", tier: "rare", hp: 2800, atk: 650, def: 60, speed: 180, cost: 3200, abilities: ["Rage Mode", "Dual Blades", "Whirlwind"], modes: ["aggro", "berserk"], description: "Aggressive melee bot that grows stronger as HP drops" },
          { id: "hacker_bot", name: "Cyber Hacker", icon: "üíª", type: "support_drone", category: "hover", tier: "rare", hp: 1000, atk: 200, def: 50, speed: 190, cost: 2800, abilities: ["Hack Enemy", "Disable Defenses", "Data Steal", "System Crash"], modes: ["follow", "disrupt", "hack"], description: "Elite hacker bot that disables enemy systems and steals buffs" },
          { id: "tank_bot", name: "Iron Fortress", icon: "üè∞", type: "mech", category: "ground", tier: "epic", hp: 6000, atk: 350, def: 300, speed: 80, cost: 6000, abilities: ["Taunt", "Shield Wall", "Counter Strike", "Fortify"], modes: ["guard", "tank", "defend"], description: "Ultra-tanky bot that draws enemy fire and protects the team" },
          { id: "ninja_bot", name: "Shadow Ninja", icon: "ü•∑", type: "infiltrator", category: "ground", tier: "legendary", hp: 1500, atk: 900, def: 40, speed: 250, cost: 7500, abilities: ["Shadow Clone", "Critical Strike", "Vanish", "Assassination", "Smoke Screen"], modes: ["follow", "stealth", "assassinate"], description: "Master assassin bot with instant-kill techniques" },
          { id: "healer_bot", name: "Medic Prime", icon: "‚öïÔ∏è", type: "support_drone", category: "hover", tier: "uncommon", hp: 1500, atk: 80, def: 70, speed: 150, cost: 2200, abilities: ["Mass Heal", "Regeneration Aura", "Cure", "Revive"], modes: ["follow", "heal", "support"], description: "Advanced medical bot with area healing and resurrection" },
          { id: "mage_bot", name: "Arcane Golem", icon: "üîÆ", type: "combat_bot", category: "ground", tier: "epic", hp: 2200, atk: 550, def: 100, speed: 130, cost: 4500, abilities: ["Fireball", "Ice Storm", "Lightning Chain", "Meteor"], modes: ["follow", "aggro", "cast"], description: "Magic-wielding bot with elemental spells" },
          { id: "bomber_bot", name: "Demolition Unit", icon: "üí£", type: "combat_bot", category: "ground", tier: "rare", hp: 1800, atk: 750, def: 50, speed: 110, cost: 3300, abilities: ["Plant Bomb", "Explosive Shot", "Cluster Bomb", "Self-Destruct"], modes: ["follow", "aggro", "kamikaze"], description: "Explosive specialist bot with massive AoE damage" },
          { id: "dragon_bot", name: "Mecha Dragon", icon: "üê≤", type: "mech", category: "air", tier: "legendary", hp: 4500, atk: 850, def: 180, speed: 200, cost: 9000, abilities: ["Flame Breath", "Tail Swipe", "Dragon Dive", "Inferno", "Wing Shield"], modes: ["follow", "aggro", "flight"], description: "Legendary dragon-type mech with flight and fire attacks" }
        ],
        skins: {
          A1: [
            { id: "a1_default", name: "Default A1", rarity: "common", unlocked: true, description: "Original A1 warrior design" },
            { id: "a1_warrior", name: "Battle Warrior", rarity: "rare", unlocked: true, description: "Enhanced warrior with battle armor" },
            { id: "a1_shadow", name: "Shadow Warrior", rarity: "epic", unlocked: false, description: "Dark warrior with shadow powers" },
            { id: "a1_golden", name: "Golden Warrior", rarity: "legendary", unlocked: false, description: "Legendary golden armor" }
          ],
          Unique: [
            { id: "unique_default", name: "Default Unique", rarity: "common", unlocked: true, description: "Original Unique rogue design" },
            { id: "unique_rogue", name: "Shadow Rogue", rarity: "rare", unlocked: true, description: "Stealthy rogue with enhanced agility" },
            { id: "unique_tactical", name: "Tactical Ops", rarity: "epic", unlocked: false, description: "Futuristic tactical operative" },
            { id: "unique_phantom", name: "Phantom Assassin", rarity: "legendary", unlocked: false, description: "Master of shadows and stealth" }
          ],
          Missy: [
            { id: "missy_default", name: "Default Missy", rarity: "common", unlocked: true, description: "Original Missy mage design" },
            { id: "missy_mage", name: "Arcane Mage", rarity: "rare", unlocked: true, description: "Powerful mage with arcane abilities" },
            { id: "missy_angel", name: "Angel Guardian", rarity: "epic", unlocked: true, description: "Divine angel with halo and wings" },
            { id: "missy_celestial", name: "Celestial Sorceress", rarity: "legendary", unlocked: false, description: "Supreme magical powers from the cosmos" }
          ]
        }
      },

      // Interior content system
      interior: {
        hunters: [],
        pets: [],
        chests: [],
        npcs: [],
        counters: [],
        computers: [],
        arcadeMachines: []
      },

      // Persistent data
      hunterInventories: {},
      chestStates: {},
      questProgress: {},
      petCollection: [],
      arcadeHighScores: {},
      trainingProgress: {},
      computerCooldowns: {},
      activeQuests: [],

      // Indoor combat (training/arena)
      indoorCombat: {
        active: false,
        enemies: [],
        wave: 0,
        spawnTimer: 0,
        fx: []
      }
    };

    // ============================
    // CANVAS SETUP
    // ============================

    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    }

    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);

    // ============================
    // TINY LOG SYSTEM
    // ============================

    let logTimeout = null;

    function showTinyLog(message, duration = 5000) {
      const log = document.getElementById("tinyLog");
      log.textContent = message;
      log.classList.add("show");

      clearTimeout(logTimeout);
      logTimeout = setTimeout(() => {
        log.classList.remove("show");
      }, duration);
    }

    // ============================
    // ENEMY SYSTEM
    // ============================

    function spawnEnemy(typeKey, x, y) {
      const template = ENEMY_TYPES[typeKey];
      if (!template) return null;

      const enemy = {
        id: 'enemy_' + Date.now() + '_' + Math.random(),
        ...template,
        hp: template.maxHp,
        x: x,
        y: y,
        vx: 0,
        vy: 0,
        state: 'idle', // idle, chase, attack, dead
        target: null,
        attackTimer: 0,
        aggroTarget: null,
        patrolAngle: Math.random() * Math.PI * 2
      };

      GameState.enemies.push(enemy);
      return enemy;
    }

    function updatePetRobotCombat(deltaTime) {
      const leader = GameState.party[0];
      if (!leader) return;

      // Pet attacks
      if (GameState.equipped.pet && !GameState.equipped.pet.attackTimer) {
        GameState.equipped.pet.attackTimer = 0;
      }
      
      if (GameState.equipped.pet) {
        const pet = GameState.equipped.pet;
        pet.attackTimer -= deltaTime;
        
        if (pet.attackTimer <= 0) {
          // Find nearest enemy
          let nearestEnemy = null;
          let nearestDist = Infinity;
          
          for (const enemy of GameState.enemies) {
            if (enemy.hp <= 0) continue;
            const dx = enemy.x - leader.x;
            const dy = enemy.y - leader.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < nearestDist && dist < 300) {
              nearestEnemy = enemy;
              nearestDist = dist;
            }
          }
          
          if (nearestEnemy) {
            // Pet attacks enemy
            // AAA: Apply combo multiplier
            const baseDamage = pet.attack + (pet.abilityDamage || 0);
            const damage = Math.floor(baseDamage * GameState.comboMultiplier);
            nearestEnemy.hp = Math.max(0, nearestEnemy.hp - damage);
            createDamageNumber(nearestEnemy.x, nearestEnemy.y - 40, damage, '#ff66ff');
            
            // AAA: Add to combo
            addCombo(true);
            
            if (nearestEnemy.hp <= 0) {
              nearestEnemy.state = 'dead';
              nearestEnemy.deathTimer = 0;
            }
            
            pet.attackTimer = 2000; // 2 second cooldown
          }
        }
      }

      // Robot attacks
      if (GameState.equipped.robot && !GameState.equipped.robot.attackTimer) {
        GameState.equipped.robot.attackTimer = 0;
      }
      
      if (GameState.equipped.robot) {
        const robot = GameState.equipped.robot;
        robot.attackTimer -= deltaTime;
        
        if (robot.attackTimer <= 0) {
          // Find nearest enemy
          let nearestEnemy = null;
          let nearestDist = Infinity;
          
          for (const enemy of GameState.enemies) {
            if (enemy.hp <= 0) continue;
            const dx = enemy.x - leader.x;
            const dy = enemy.y - leader.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            
            if (dist < nearestDist && dist < 400) {
              nearestEnemy = enemy;
              nearestDist = dist;
            }
          }
          
          if (nearestEnemy) {
            // Robot attacks enemy
            // AAA: Apply combo multiplier
            const baseDamage = robot.atk;
            const damage = Math.floor(baseDamage * GameState.comboMultiplier);
            nearestEnemy.hp = Math.max(0, nearestEnemy.hp - damage);
            createDamageNumber(nearestEnemy.x, nearestEnemy.y - 40, damage, '#00ffff');
            
            // AAA: Add to combo
            addCombo(true);
            
            if (nearestEnemy.hp <= 0) {
              nearestEnemy.state = 'dead';
              nearestEnemy.deathTimer = 0;
            }
            
            robot.attackTimer = 1500; // 1.5 second cooldown
          }
        }
      }
    }

    function updateEnemies(deltaTime) {
      const leader = GameState.party[0];
      if (!leader) return;

      for (let i = GameState.enemies.length - 1; i >= 0; i--) {
        const enemy = GameState.enemies[i];

        // Remove dead enemies
        if (enemy.hp <= 0) {
          if (enemy.state !== 'dead') {
            enemy.state = 'dead';
            // Award rewards
            GameState.gold += enemy.goldReward;
            gainXP(enemy.xpReward); // Use gainXP for level-up handling
            showToast(`üíÄ ${enemy.name} defeated! +${enemy.goldReward}g +${enemy.xpReward}xp`);
            
            // Update quest progress
            updateQuestProgress('kill', 1);
          }
          // Remove after death animation
          if (enemy.deathTimer > 1000) {
            GameState.enemies.splice(i, 1);
          } else {
            enemy.deathTimer = (enemy.deathTimer || 0) + deltaTime;
          }
          continue;
        }

        // Distance to leader
        const dx = leader.x - enemy.x;
        const dy = leader.y - enemy.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        // Aggro check
        if (dist < enemy.aggroRange && !enemy.aggroTarget) {
          enemy.aggroTarget = leader;
          enemy.state = 'chase';
        }

        // Update attack timer
        if (enemy.attackTimer > 0) {
          enemy.attackTimer -= deltaTime;
        }

        // AI Behavior
        if (enemy.state === 'chase' && enemy.aggroTarget) {
          if (dist < enemy.attackRange) {
            // In attack range
            enemy.state = 'attack';
            if (enemy.attackTimer <= 0) {
              attackPlayer(enemy, enemy.aggroTarget);
              enemy.attackTimer = enemy.attackCooldown * 1000;
            }
          } else {
            // Chase player
            const moveSpeed = enemy.speed * deltaTime * 0.1;
            enemy.x += (dx / dist) * moveSpeed;
            enemy.y += (dy / dist) * moveSpeed;
          }
        } else if (enemy.state === 'idle' || !enemy.aggroTarget) {
          // Patrol behavior
          enemy.patrolAngle += deltaTime * 0.001;
          enemy.x += Math.cos(enemy.patrolAngle) * 0.5;
          enemy.y += Math.sin(enemy.patrolAngle) * 0.3;
        }

        // Keep enemies on ground
        if (enemy.type !== 'flying') {
          enemy.y = Math.max(500, Math.min(600, enemy.y));
        }
      }
    }

    function attackPlayer(enemy, target) {
      if (!target || target.hp <= 0) return;

      // Calculate damage
      const baseDamage = enemy.atk;
      const defense = target.def || 0;
      let damage = Math.max(1, baseDamage - defense);

      // AAA: Check for perfect parry
      let isParry = false;
      if (GameState.isBlocking && GameState.parryWindow > 0) {
        // PERFECT PARRY!
        isParry = true;
        damage = 0;
        GameState.canCounter = true;
        
        // Visual feedback
        showToast('‚ö° PERFECT PARRY! Counter ready!', 2000, '#ffff00');
        screenShake(10, 200);
        addHitFlash(0.3);
        AudioSystem.playSound('parry');
        
        // Slow-motion effect simulation (visual feedback only)
        for (let i = 0; i < 20; i++) {
          const angle = (i / 20) * Math.PI * 2;
          GameState.projectiles.push({
            x: target.x,
            y: target.y - 20,
            vx: Math.cos(angle) * 3,
            vy: Math.sin(angle) * 3,
            damage: 0,
            color: '#ffff00',
            type: 'particle',
            radius: 4,
            lifetime: 500,
            createdAt: Date.now()
          });
        }
      } else if (GameState.isBlocking) {
        // Normal block
        damage = Math.floor(damage * 0.5); // 50% damage reduction
        showToast(`üõ°Ô∏è Blocked! Only ${damage} damage taken`);
      }

      // Apply damage
      target.hp = Math.max(0, target.hp - damage);
      
      // AAA: Only break combo if not a perfect parry
      if (!isParry) {
        breakCombo();
      }
      
      // Build rage when taking damage
      GameState.rage = Math.min(GameState.maxRage, GameState.rage + damage * 0.5);
      
      // Hit flash on damage taken
      addHitFlash(0.2);
      addScreenShake(1);

      // Create damage number
      createDamageNumber(target.x, target.y - 40, damage, '#ff3b3b');

      // Visual feedback
      if (!GameState.isBlocking) {
        showToast(`üí• ${target.name} took ${damage} damage!`);
      }

      // Check if player died
      if (target.hp <= 0) {
        showToast(`üíÄ ${target.name} has been defeated!`);
      }
    }

    function createDamageNumber(x, y, damage, color = '#ffffff') {
      GameState.damageNumbers.push({
        x: x,
        y: y,
        damage: damage,
        color: color,
        alpha: 1.0,
        lifetime: 0
      });
    }

    function updateDamageNumbers(deltaTime) {
      for (let i = GameState.damageNumbers.length - 1; i >= 0; i--) {
        const dmg = GameState.damageNumbers[i];
        dmg.y -= deltaTime * 0.05;
        dmg.alpha -= deltaTime * 0.001;
        dmg.lifetime += deltaTime;

        if (dmg.alpha <= 0 || dmg.lifetime > 2000) {
          GameState.damageNumbers.splice(i, 1);
        }
      }
    }

    function renderEnemy(enemy) {
      const screenX = enemy.x - GameState.camera.x;
      const screenY = enemy.y;

      // Don't render if off-screen
      if (screenX < -100 || screenX > canvas.width + 100) return;

      ctx.save();

      // Death fade
      if (enemy.state === 'dead') {
        ctx.globalAlpha = 1 - (enemy.deathTimer || 0) / 1000;
      }

      // Shadow
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.beginPath();
      ctx.ellipse(screenX, screenY + 25, 20, 8, 0, 0, Math.PI * 2);
      ctx.fill();

      // Enemy body
      ctx.font = 'bold 40px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      // Glow effect
      ctx.shadowColor = enemy.color;
      ctx.shadowBlur = 15;
      ctx.fillText(enemy.icon, screenX, screenY);
      ctx.shadowBlur = 0;

      // HP bar
      if (enemy.hp < enemy.maxHp) {
        const barWidth = 50;
        const barHeight = 4;
        const barX = screenX - barWidth / 2;
        const barY = screenY - 35;

        // Background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(barX, barY, barWidth, barHeight);

        // HP fill
        const hpPercent = enemy.hp / enemy.maxHp;
        ctx.fillStyle = hpPercent > 0.5 ? '#4ade80' : hpPercent > 0.25 ? '#fbbf24' : '#ef4444';
        ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);

        // Border
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.strokeRect(barX, barY, barWidth, barHeight);
      }

      // Name tag (if damaged)
      if (enemy.hp < enemy.maxHp) {
        ctx.font = 'bold 10px Arial';
        ctx.fillStyle = '#ffffff';
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 3;
        ctx.strokeText(enemy.name, screenX, screenY - 45);
        ctx.fillText(enemy.name, screenX, screenY - 45);
      }

      ctx.restore();
    }

    function renderDamageNumbers() {
      ctx.save();
      ctx.font = 'bold 16px Arial';
      ctx.textAlign = 'center';

      for (const dmg of GameState.damageNumbers) {
        const screenX = dmg.x - GameState.camera.x;
        ctx.globalAlpha = dmg.alpha;
        ctx.fillStyle = dmg.color;
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 3;
        ctx.strokeText(dmg.damage.toString(), screenX, dmg.y);
        ctx.fillText(dmg.damage.toString(), screenX, dmg.y);
      }

      ctx.restore();
    }

    // PLAYER ATTACK FUNCTIONS
    let skillCooldowns = {};

    function castSkill(skill) {
      if (GameState.mode !== 'exterior') {
        showToast('‚ö†Ô∏è Can only use skills in exterior mode!');
        return;
      }

      const leader = GameState.party[0];
      if (!leader || leader.hp <= 0) {
        showToast('‚ö†Ô∏è Leader is defeated!');
        return;
      }

      // Check cooldown
      const now = Date.now();
      const cooldownKey = skill.id;
      if (skillCooldowns[cooldownKey] && now < skillCooldowns[cooldownKey]) {
        const remaining = ((skillCooldowns[cooldownKey] - now) / 1000).toFixed(1);
        showToast(`‚è±Ô∏è ${skill.name} on cooldown (${remaining}s)!`);
        return;
      }

      // Set cooldown
      skillCooldowns[cooldownKey] = now + (skill.cooldown * 1000);

      // AAA: Check for skill combo bonus
      const comboBonus = checkSkillCombo(skill);
      
      // Visual feedback
      showToast(`${skill.icon} ${skill.name}! ${skill.damage} ${skill.element} damage`);
      
      // PHASE 3: Quest tracking & tutorial
      updateQuestProgress('cast_skill', 1);
      advanceTutorial('skill');
      
      // PHASE 3: Achievement tracking
      if (!GameState.achievementProgress['SKILL_CASTS']) {
        GameState.achievementProgress['SKILL_CASTS'] = 0;
      }
      GameState.achievementProgress['SKILL_CASTS']++;
      if (GameState.achievementProgress['SKILL_CASTS'] >= 100) {
        checkAchievement('SKILL_MASTER', 100);
      }

      // Skill-specific effects
      const skillRange = skill.type === 'melee' ? 100 : 300;
      let hitCount = 0;

      // Deal damage to enemies in range
      for (const enemy of GameState.enemies) {
        if (enemy.hp <= 0) continue;

        const dx = enemy.x - leader.x;
        const dy = enemy.y - leader.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist <= skillRange) {
          // AAA: Calculate damage with combo multiplier AND skill combo bonus
          const baseDamage = skill.damage || 0;
          const damage = Math.floor(baseDamage * GameState.comboMultiplier * comboBonus);

          // Apply damage
          enemy.hp = Math.max(0, enemy.hp - damage);
          hitCount++;
          
          // AAA: Add to combo
          addCombo(true);

          // Create damage number (skill color based on element)
          const elementColors = {
            PHYSICAL: '#ffff00',
            FIRE: '#ff6600',
            ICE: '#66ccff',
            LIGHTNING: '#ffff00',
            SHADOW: '#9966ff',
            LIGHT: '#ffffcc',
            ARCANE: '#ff66ff',
            PLASMA: '#00ffff',
            ENERGY: '#00ff00',
            SUMMON: '#ffffff'
          };
          const color = elementColors[skill.element] || '#ffffff';
          createDamageNumber(enemy.x, enemy.y - 40, damage, color);

          // AAA: Apply status effects
          if (skill.freeze && enemy.id) {
            applyStatusEffect(enemy.id, 'FREEZE');
          }
          if (skill.burn && enemy.id) {
            applyStatusEffect(enemy.id, 'BURN');
          }
          if (skill.stun && enemy.id) {
            applyStatusEffect(enemy.id, 'STUN');
          }
          if (skill.poison && enemy.id) {
            applyStatusEffect(enemy.id, 'POISON');
          }

          // Check if enemy died
          if (enemy.hp <= 0) {
            enemy.state = 'dead';
            enemy.deathTimer = 0;
          }
        }
      }

      // Visual effects based on skill
      createSkillVFX(skill, leader.x, leader.y);

      console.log(`üéØ ${skill.name} cast! Hit ${hitCount} enemies.`);
    }

    function createSkillVFX(skill, x, y) {
      // Create visual effect particles based on skill
      const vfxCount = skill.chargeable ? 12 : 8;
      
      for (let i = 0; i < vfxCount; i++) {
        const angle = (Math.PI * 2 * i) / vfxCount;
        const speed = 2 + Math.random() * 2;
        
        GameState.projectiles.push({
          x: x,
          y: y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed - 1,
          life: 0,
          maxLife: 1000,
          color: getSkillColor(skill.element),
          size: skill.tier === 'legendary' ? 8 : skill.tier === 'epic' ? 6 : 4,
          icon: skill.icon,
          isVFX: true
        });
      }
    }

    function getSkillColor(element) {
      const colors = {
        PHYSICAL: '#ffff00',
        FIRE: '#ff6600',
        ICE: '#66ccff',
        LIGHTNING: '#ffff00',
        SHADOW: '#9966ff',
        LIGHT: '#ffffcc',
        ARCANE: '#ff66ff',
        PLASMA: '#00ffff',
        ENERGY: '#00ff00',
        SUMMON: '#ffffff'
      };
      return colors[element] || '#ffffff';
    }

    function updateProjectiles(deltaTime) {
      for (let i = GameState.projectiles.length - 1; i >= 0; i--) {
        const proj = GameState.projectiles[i];
        
        proj.x += proj.vx;
        proj.y += proj.vy;
        proj.life += deltaTime;

        // Gravity for VFX particles
        if (proj.isVFX) {
          proj.vy += 0.1;
        }

        // Remove if expired
        if (proj.life >= proj.maxLife) {
          GameState.projectiles.splice(i, 1);
        }
      }
    }

    function renderProjectiles() {
      ctx.save();
      
      for (const proj of GameState.projectiles) {
        const screenX = proj.x - GameState.camera.x;
        const alpha = 1 - (proj.life / proj.maxLife);
        
        ctx.globalAlpha = alpha;
        ctx.fillStyle = proj.color;
        ctx.shadowColor = proj.color;
        ctx.shadowBlur = 10;
        
        if (proj.isVFX) {
          // Particle effect
          ctx.beginPath();
          ctx.arc(screenX, proj.y, proj.size, 0, Math.PI * 2);
          ctx.fill();
        } else {
          // Projectile
          ctx.beginPath();
          ctx.arc(screenX, proj.y, 6, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      ctx.restore();
    }

    // RAGE & SHIELD SYSTEMS
    function activateRageMode() {
      if (GameState.rage < GameState.maxRage) {
        showToast(`‚ö†Ô∏è Need 100 rage! Current: ${GameState.rage.toFixed(0)}`);
        return;
      }

      // Activate rage mode
      GameState.rageMode = true;
      GameState.rageModeTimer = 10000; // 10 seconds
      GameState.rage = 0;

      showToast('üò° RAGE MODE ACTIVATED! +100% damage for 10s!');
    }

    function activateShield() {
      if (GameState.isBlocking) {
        showToast('üõ°Ô∏è Already blocking!');
        return;
      }

      // Activate shield
      GameState.isBlocking = true;
      GameState.blockTimer = 2000; // 2 seconds
      
      // AAA: Activate parry window (first 0.2s of block)
      GameState.parryWindow = GameState.parryWindowDuration;
      GameState.canCounter = false;

      showToast('üõ°Ô∏è SHIELD UP! Perfect parry for 0.2s!', 1500, '#00aaff');
    }

    function updateRageShield(deltaTime) {
      // Update rage mode
      if (GameState.rageMode) {
        GameState.rageModeTimer -= deltaTime;
        if (GameState.rageModeTimer <= 0) {
          GameState.rageMode = false;
          showToast('üò§ Rage mode ended');
        }
      }

      // Update shield
      if (GameState.isBlocking) {
        GameState.blockTimer -= deltaTime;
        
        // AAA: Update parry window
        if (GameState.parryWindow > 0) {
          GameState.parryWindow -= deltaTime;
          if (GameState.parryWindow <= 0) {
            GameState.parryWindow = 0;
          }
        }
        
        if (GameState.blockTimer <= 0) {
          GameState.isBlocking = false;
          GameState.parryWindow = 0;
          GameState.canCounter = false;
          showToast('üõ°Ô∏è Shield lowered');
        }
      }
      
      // Update screen effects
      if (GameState.screenShake > 0) {
        GameState.screenShake = Math.max(0, GameState.screenShake - deltaTime * 0.01);
      }
      if (GameState.hitFlash > 0) {
        GameState.hitFlash = Math.max(0, GameState.hitFlash - deltaTime * 0.005);
      }
    }

    function addScreenShake(intensity = 1) {
      GameState.screenShake = Math.min(10, GameState.screenShake + intensity);
    }

    function addHitFlash(intensity = 0.3) {
      GameState.hitFlash = Math.min(1, GameState.hitFlash + intensity);
    }

    // AAA: Counter-Attack System
    function performCounterAttack() {
      if (!GameState.canCounter) {
        showToast('‚ö†Ô∏è No counter available!', 1000, '#999999');
        return;
      }
      
      const leader = GameState.party[0];
      if (!leader) return;
      
      // Find nearest enemy
      let nearestEnemy = null;
      let nearestDist = 300;
      
      for (const enemy of GameState.enemies) {
        if (enemy.hp <= 0) continue;
        const dx = enemy.x - leader.x;
        const dy = enemy.y - leader.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < nearestDist) {
          nearestEnemy = enemy;
          nearestDist = dist;
        }
      }
      
      if (!nearestEnemy) {
        showToast('‚ö†Ô∏è No enemy in range!', 1000, '#999999');
        return;
      }
      
      // AAA: Counter deals 3x damage and stuns
      const counterDamage = Math.floor(leader.atk * 3 * GameState.comboMultiplier);
      nearestEnemy.hp = Math.max(0, nearestEnemy.hp - counterDamage);
      
      // Apply stun
      if (nearestEnemy.id) {
        applyStatusEffect(nearestEnemy.id, 'STUN');
      }
      
      // Add to combo
      addCombo(true);
      
      // Massive visual feedback
      showToast(`‚ö° COUNTER! ${counterDamage} damage + STUN!`, 2500, '#ffff00');
      screenShake(15, 400);
      createDamageNumber(nearestEnemy.x, nearestEnemy.y - 40, counterDamage, '#ffff00');
      
      // Counter particles
      for (let i = 0; i < 30; i++) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 2 + Math.random() * 4;
        GameState.projectiles.push({
          x: nearestEnemy.x,
          y: nearestEnemy.y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed - 2,
          damage: 0,
          color: '#ffff00',
          type: 'particle',
          radius: 5,
          lifetime: 800,
          createdAt: Date.now()
        });
      }
      
      // Clear counter flag
      GameState.canCounter = false;
      GameState.isBlocking = false;
      GameState.blockTimer = 0;
      GameState.parryWindow = 0;
      
      AudioSystem.playSound('counter');
    }

    function performJumpAttack() {
      if (GameState.mode !== 'exterior') {
        showToast('‚ö†Ô∏è Can only jump attack in exterior mode!');
        return;
      }

      const leader = GameState.party[0];
      if (!leader || leader.hp <= 0) {
        showToast('‚ö†Ô∏è Leader is defeated!');
        return;
      }

      const jumpRange = 150; // Larger than melee
      const jumpDamage = leader.atk * 1.5; // 50% more damage
      let hitCount = 0;

      // Deal AOE damage in jump radius
      for (const enemy of GameState.enemies) {
        if (enemy.hp <= 0) continue;

        const dx = enemy.x - leader.x;
        const dy = enemy.y - leader.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist <= jumpRange) {
          // Calculate damage
          let damage = Math.floor(jumpDamage);
          
          if (GameState.rageMode) {
            damage *= 2;
          }
          
          const finalDamage = Math.max(1, damage - (enemy.def || 0));

          // Apply damage
          enemy.hp = Math.max(0, enemy.hp - finalDamage);
          hitCount++;
          
          // Build rage
          GameState.rage = Math.min(GameState.maxRage, GameState.rage + 3);

          // Create damage number
          createDamageNumber(enemy.x, enemy.y - 40, finalDamage, '#ffaa00');

          // Check if enemy died
          if (enemy.hp <= 0) {
            enemy.state = 'dead';
            enemy.deathTimer = 0;
          }
        }
      }

      // Screen shake
      addScreenShake(3);

      // Visual feedback
      if (hitCount > 0) {
        showToast(`üí• Jump Attack! Hit ${hitCount} ${hitCount === 1 ? 'enemy' : 'enemies'}!`);
      } else {
        showToast('üí® Jump attack - no enemies in AOE range!');
      }
      
      // Create jump VFX
      for (let i = 0; i < 16; i++) {
        const angle = (Math.PI * 2 * i) / 16;
        GameState.projectiles.push({
          x: leader.x,
          y: leader.y,
          vx: Math.cos(angle) * 3,
          vy: Math.sin(angle) * 3 - 2,
          life: 0,
          maxLife: 800,
          color: '#ffaa00',
          size: 6,
          isVFX: true
        });
      }
    }

    function performMeleeAttack() {
      if (GameState.mode !== 'exterior') {
        showToast('‚ö†Ô∏è Can only attack in exterior mode!');
        return;
      }

      const leader = GameState.party[0];
      if (!leader || leader.hp <= 0) {
        showToast('‚ö†Ô∏è Leader is defeated!');
        return;
      }

      const attackRange = 80;
      const attackArc = Math.PI / 2; // 90 degrees in front
      let hitCount = 0;

      // Check all enemies in range
      for (const enemy of GameState.enemies) {
        if (enemy.hp <= 0) continue;

        const dx = enemy.x - leader.x;
        const dy = enemy.y - leader.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist <= attackRange) {
          // Calculate damage with equipped gear bonuses
          let baseDamage = leader.atk;
          
          // Add weapon damage
          if (GameState.equipped.weapon) {
            baseDamage += GameState.equipped.weapon.attack || 0;
          }
          
          // Add gear bonuses
          const gearBonus = ['ring1', 'ring2', 'gloves'].reduce((sum, slot) => {
            const item = GameState.equipped[slot];
            return sum + (item?.attack || 0);
          }, 0);
          baseDamage += gearBonus;

          // Calculate final damage
          const defense = enemy.def || 0;
          let damage = Math.max(1, baseDamage - defense);
          
          // Apply rage mode bonus
          if (GameState.rageMode) {
            damage *= 2; // Double damage in rage mode
          }

          // Apply damage
          enemy.hp = Math.max(0, enemy.hp - damage);
          hitCount++;
          
          // Build rage on hit
          GameState.rage = Math.min(GameState.maxRage, GameState.rage + 5);

          // Screen shake on hit
          addScreenShake(0.5);

          // Create damage number
          const damageColor = GameState.rageMode ? '#ff0000' : '#ffff00';
          createDamageNumber(enemy.x, enemy.y - 40, damage, damageColor);

          // Check if enemy died
          if (enemy.hp <= 0) {
            enemy.state = 'dead';
            enemy.deathTimer = 0;
            addScreenShake(2); // Bigger shake on kill
            
            // Death explosion particles
            for (let i = 0; i < 20; i++) {
              const angle = (Math.PI * 2 * i) / 20;
              const speed = 2 + Math.random() * 3;
              GameState.projectiles.push({
                x: enemy.x,
                y: enemy.y,
                vx: Math.cos(angle) * speed,
                vy: Math.sin(angle) * speed - 2,
                life: 0,
                maxLife: 1200,
                color: enemy.color,
                size: 4 + Math.random() * 4,
                isVFX: true
              });
            }
          }
        }
      }

      if (hitCount > 0) {
        showToast(`‚öîÔ∏è Hit ${hitCount} ${hitCount === 1 ? 'enemy' : 'enemies'}!`);
      } else {
        showToast('üí® Attack missed - no enemies in range!');
      }
    }

    // ENEMY SPAWN ZONES (based on world zones)
    const SPAWN_ZONES = [
      { zoneId: 'TRAIN', enemyTypes: ['SLASHER'], count: 3, spawnRate: 0.5 },
      { zoneId: 'PLAZA', enemyTypes: ['SLASHER', 'SHOOTER'], count: 5, spawnRate: 0.7 },
      { zoneId: 'MARKET', enemyTypes: ['SLASHER', 'SHOOTER', 'DRONE'], count: 6, spawnRate: 0.8 },
      { zoneId: 'TOWER', enemyTypes: ['SHOOTER', 'DRONE', 'BRUTE'], count: 7, spawnRate: 0.9 },
      { zoneId: 'CASINO', enemyTypes: ['DRONE', 'BRUTE'], count: 8, spawnRate: 1.0 },
      { zoneId: 'ARCADE', enemyTypes: ['SLASHER', 'DRONE', 'BRUTE'], count: 9, spawnRate: 1.1 },
      { zoneId: 'RACING', enemyTypes: ['DRONE', 'BRUTE'], count: 10, spawnRate: 1.2 },
      { zoneId: 'FISHING', enemyTypes: ['SHOOTER', 'SLASHER'], count: 6, spawnRate: 0.8 },
      { zoneId: 'FARMING', enemyTypes: ['SLASHER', 'BRUTE'], count: 7, spawnRate: 0.9 },
      { zoneId: 'CELESTIAL', enemyTypes: ['BRUTE', 'DRONE'], count: 12, spawnRate: 1.5 }
    ];

    function spawnZoneEnemies() {
      // Clear existing enemies
      GameState.enemies = [];

      // Find current zone
      const leader = GameState.party[0];
      if (!leader) return;

      const currentZone = ZONES.find(z => leader.x >= z.x && leader.x < z.end);
      if (!currentZone) return;

      // Find spawn configuration
      const spawnConfig = SPAWN_ZONES.find(sz => sz.zoneId === currentZone.id);
      if (!spawnConfig) return;

      // Spawn enemies in zone
      for (let i = 0; i < spawnConfig.count; i++) {
        const enemyType = spawnConfig.enemyTypes[Math.floor(Math.random() * spawnConfig.enemyTypes.length)];
        const spawnX = currentZone.x + Math.random() * (currentZone.end - currentZone.x);
        const spawnY = 500 + Math.random() * 100;
        
        spawnEnemy(enemyType, spawnX, spawnY);
      }

      showToast(`‚ö†Ô∏è ${spawnConfig.count} enemies detected in ${currentZone.name}!`);
    }

    // ============================
    // INPUT HANDLING
    // ============================

    window.addEventListener("keydown", (e) => {
      GameState.keys[e.key] = true;

      // Spawn enemies (TEST: Press X key)
      if (e.key === "x" || e.key === "X") {
        if (GameState.mode === 'exterior') {
          spawnZoneEnemies();
        }
      }

      if (e.key === "e" || e.key === "E") {
        handleInteraction();
      }

      if (e.key === "Escape") {
        closeGamePanel();
      }

      if (e.key === "m" || e.key === "M") {
        const minimap = document.getElementById("minimapPanel");
        minimap.style.display = minimap.style.display === "none" ? "block" : "none";
      }

      if (e.key === "f" || e.key === "F") {
        if (GameState.mode === 'interior' && GameState.indoorCombat.active) {
          attackIndoorEnemy();
        }
      }
    });

    window.addEventListener("keyup", (e) => {
      GameState.keys[e.key] = false;
    });

    // ============================
    // INTERACTION SYSTEM
    // ============================

    function handleInteraction() {
      if (GameState.mode === 'exterior') {
        // Check for portal first (higher priority)
        if (GameState.nearestPortal) {
          usePortal(GameState.nearestPortal);
        }
        // Try to enter building
        else if (GameState.nearestBuilding && GameState.nearestBuilding.hasInterior) {
          enterBuilding(GameState.nearestBuilding);
        }
      } else if (GameState.mode === 'interior') {
        // Check if near exit door
        if (GameState.nearestInteractive && GameState.nearestInteractive.type === 'exit') {
          exitBuilding();
        }
        // Check if near game/interactive object
        else if (GameState.nearestInteractive && GameState.nearestInteractive.type === 'game') {
          startGame(GameState.nearestInteractive.gameType);
        }
        // Check if near action/interactive object
        else if (GameState.nearestInteractive && GameState.nearestInteractive.type === 'action') {
          handleAction(GameState.nearestInteractive);
        }
        // Check if near hunter
        else if (GameState.nearestInteractive && GameState.nearestInteractive.type === 'hunter') {
          interactWithHunter(GameState.nearestInteractive.hunter);
        }
        // Check if near chest
        else if (GameState.nearestInteractive && GameState.nearestInteractive.type === 'chest') {
          openChest(GameState.nearestInteractive.chest);
        }
        // Check if near computer
        else if (GameState.nearestInteractive && GameState.nearestInteractive.type === 'computer') {
          playComputerGame();
        }
      }
    }

    // ============================
    // ACTION HANDLING SYSTEM
    // ============================

    function handleAction(interactive) {
      switch (interactive.actionType) {
        case 'photo':
          takePhoto();
          break;
        case 'quest':
          acceptQuest(interactive.questId);
          break;
        case 'read':
          readLore();
          break;
        case 'upgrade':
          upgradeWeapon();
          break;
        case 'farm':
          farmPlot(interactive.plotId);
          break;
        case 'blessing':
          receiveBlessing(interactive.blessingType);
          break;
      }
    }

    function takePhoto() {
      showToast("üì∏ *FLASH!* Photo saved!");
      showTinyLog("Photo taken successfully!");

      // Could actually capture canvas as image here
      // For now, just visual feedback
      const flash = document.createElement('div');
      flash.style.cssText = 'position:fixed;top:0;left:0;width:100vw;height:100vh;background:white;z-index:9999;pointer-events:none;';
      document.body.appendChild(flash);

      setTimeout(() => {
        flash.style.opacity = '0';
        flash.style.transition = 'opacity 0.3s';
        setTimeout(() => document.body.removeChild(flash), 300);
      }, 100);
    }

    function acceptQuest(questId) {
      const quests = [
        { title: "Slay Dragon", reward: 10000 },
        { title: "Clear Dungeon", reward: 5000 },
        { title: "Harvest Crops", reward: 500 },
        { title: "Catch 10 Fish", reward: 1000 },
        { title: "Win Race", reward: 2000 },
        { title: "Mine Gems", reward: 3000 }
      ];

      const quest = quests[questId];
      showToast(`üìã Quest Accepted: ${quest.title}`);
      showTinyLog(`Accepted: ${quest.title} (Reward: ${quest.reward} XP)`);

      // Could add quest tracking system here
      GameState.gold += 100; // Small acceptance bonus
      updateGoldDisplay();
    }

    function readLore() {
      const loreEntries = [
        "In the ancient times, heroes walked among gods...",
        "The Celestial Gates were forged in divine fire...",
        "Legends speak of a warrior who conquered 1000 floors...",
        "The Casino was built on the ruins of an old temple...",
        "Ancient magic flows through the fishing pier...",
      ];

      const randomLore = loreEntries[Math.floor(Math.random() * loreEntries.length)];
      showToast(`üìö ${randomLore}`);
      showTinyLog("Discovered ancient knowledge!");

      GameState.gold += 50; // Knowledge bonus
      updateGoldDisplay();
    }

    function upgradeWeapon() {
      const upgradeCost = 1000;

      if (GameState.gold >= upgradeCost) {
        GameState.gold -= upgradeCost;
        updateGoldDisplay();

        // Increase party ATK (simulated)
        for (const char of GameState.party) {
          if (!char.atk) char.atk = 45;
          char.atk += 10;
        }

        showToast("üî® Weapon Upgraded! +10 ATK to all party members!");
        showTinyLog(`Weapon forged! Party ATK increased!`);

        // Visual effect
        for (const char of GameState.party) {
          char.upgradeFlash = 30; // Frames to flash
        }
      } else {
        showToast("‚ùå Not enough gold! Need 1000 gold.");
        showTinyLog("Insufficient funds for upgrade");
      }
    }

    function farmPlot(plotId) {
      if (!GameState.farmPlots) {
        GameState.farmPlots = new Array(6).fill(null);
      }

      if (plotId < 3) {
        // Has crop - harvest it
        const rewards = [300, 400, 500];
        const reward = rewards[plotId];
        GameState.gold += reward;
        updateGoldDisplay();

        showToast(`üåæ Harvested! +${reward} gold`);
        showTinyLog(`Crop harvested for ${reward} gold!`);

        // Mark as harvested
        GameState.farmPlots[plotId] = null;
      } else {
        // Empty plot - plant seeds
        const seedCost = 100;
        if (GameState.gold >= seedCost) {
          GameState.gold -= seedCost;
          updateGoldDisplay();

          GameState.farmPlots[plotId] = Date.now();

          showToast(`üå± Seeds planted! (-${seedCost} gold)`);
          showTinyLog("Seeds will grow over time...");
        } else {
          showToast("‚ùå Not enough gold for seeds! Need 100 gold.");
        }
      }
    }

    function receiveBlessing(blessingType) {
      const blessings = {
        XP: { name: "XP Blessing", effect: "+25% XP gain for 10 minutes", icon: "‚≠ê" },
        Gold: { name: "Gold Blessing", effect: "+25% Gold gain for 10 minutes", icon: "üí∞" },
        Luck: { name: "Luck Blessing", effect: "+25% Luck for 10 minutes", icon: "üçÄ" }
      };

      const blessing = blessings[blessingType];

      if (!GameState.blessings) GameState.blessings = {};

      if (GameState.blessings[blessingType]) {
        showToast(`‚ö†Ô∏è ${blessing.name} already active!`);
        showTinyLog("Blessing already in effect");
        return;
      }

      GameState.blessings[blessingType] = {
        endTime: Date.now() + 10 * 60 * 1000, // 10 minutes
        multiplier: 1.25
      };

      showToast(`${blessing.icon} ${blessing.name} Received!`);
      showTinyLog(blessing.effect);

      // Visual effect
      for (const char of GameState.party) {
        char.blessingGlow = 60; // Frames to glow
      }
    }

    // ============================
    // HUNTER SYSTEM
    // ============================

    function initializeHunters(buildingType) {
      const hunters = [];
      const W = canvas.width;
      const H = canvas.height;

      // Shop buildings get C-rank shop hunter
      if (buildingType === 'shop') {
        hunters.push({
          rank: 'C',
          name: 'Hunter Jake',
          x: W * 0.25,
          y: H - 220,
          w: 22,
          h: 28,
          service: 'shop',
          color: '#8bc34a',
          inventory: [
            { name: 'Health Potion', cost: 100, effect: 'heal', value: 50 },
            { name: 'Strength Elixir', cost: 250, effect: 'atkBoost', value: 10 },
            { name: 'Basic Gear', cost: 500, effect: 'defBoost', value: 5 }
          ]
        });
      }

      // Blacksmith gets B-rank training hunter
      if (buildingType === 'forge') {
        hunters.push({
          rank: 'B',
          name: 'Hunter Aria',
          x: W * 0.50,
          y: H - 220,
          w: 22,
          h: 28,
          service: 'training',
          color: '#2196f3',
          skills: [
            { name: 'Power Strike', cost: 1000, effect: 'atkBoost', value: 15 },
            { name: 'Iron Skin', cost: 1500, effect: 'defBoost', value: 20 },
            { name: 'Swift Dash', cost: 1200, effect: 'speedBoost', value: 25 }
          ]
        });
      }

      // Quest Board gets S-rank quest hunter
      if (buildingType === 'board') {
        hunters.push({
          rank: 'S',
          name: 'Hunter Zephyr',
          x: W * 0.75,
          y: H - 220,
          w: 22,
          h: 28,
          service: 'quests',
          color: '#9c27b0',
          quests: [
            { id: 'elite_hunt', name: 'Elite Hunt', reward: 5000, target: 'Defeat 10 indoor enemies', progress: 0, goal: 10 },
            { id: 'speed_run', name: 'Speed Run', reward: 10000, target: 'Clear 5 waves in 2 minutes', completed: false },
            { id: 'perfect_clear', name: 'Perfect Clear', reward: 20000, target: 'Take no damage', completed: false }
          ]
        });
      }

      return hunters;
    }

    function interactWithHunter(hunter) {
      const msg = `${hunter.name} (Rank ${hunter.rank})`;

      if (hunter.service === 'shop') {
        // Display shop inventory
        let shopList = `${msg} - Shop\n\n`;
        hunter.inventory.forEach((item, idx) => {
          shopList += `${idx + 1}. ${item.name} - ${item.cost}g\n`;
        });

        showToast(shopList);

        // Purchase first item (simplified)
        if (GameState.gold >= hunter.inventory[0].cost) {
          GameState.gold -= hunter.inventory[0].cost;
          updateGoldDisplay();

          const item = hunter.inventory[0];
          if (item.effect === 'heal') {
            GameState.party[0].hp = Math.min(GameState.party[0].maxHp, GameState.party[0].hp + item.value);
            showTinyLog(`Purchased ${item.name}! +${item.value} HP`);
          } else if (item.effect === 'atkBoost') {
            GameState.party[0].atk += item.value;
            showTinyLog(`Purchased ${item.name}! +${item.value} ATK`);
          } else if (item.effect === 'defBoost') {
            GameState.party[0].def += item.value;
            showTinyLog(`Purchased ${item.name}! +${item.value} DEF`);
          }
        } else {
          showToast(`‚ùå Not enough gold! Need ${hunter.inventory[0].cost}g`);
        }
      }

      else if (hunter.service === 'training') {
        // Display training options
        let trainingList = `${msg} - Training\n\n`;
        hunter.skills.forEach((skill, idx) => {
          shopList += `${idx + 1}. ${skill.name} - ${skill.cost}g\n`;
        });

        showToast(trainingList);

        // Purchase first skill (simplified)
        const skill = hunter.skills[0];
        if (GameState.gold >= skill.cost) {
          GameState.gold -= skill.cost;
          updateGoldDisplay();

          if (skill.effect === 'atkBoost') {
            for (const char of GameState.party) char.atk += skill.value;
            showToast(`üî• Training Complete! +${skill.value} ATK to all party!`);
            showTinyLog(`Learned ${skill.name}!`);
          } else if (skill.effect === 'defBoost') {
            for (const char of GameState.party) char.def += skill.value;
            showToast(`üõ°Ô∏è Training Complete! +${skill.value} DEF to all party!`);
          } else if (skill.effect === 'speedBoost') {
            showToast(`‚ö° Training Complete! Movement enhanced!`);
          }
        } else {
          showToast(`‚ùå Not enough gold! Need ${skill.cost}g`);
        }
      }

      else if (hunter.service === 'quests') {
        // Display quests
        let questList = `${msg} - Quest Board\n\n`;
        hunter.quests.forEach((q, idx) => {
          const status = q.completed ? '‚úÖ' : GameState.activeQuests.includes(q.id) ? 'üìå' : 'üìã';
          questList += `${status} ${q.name}\n   ${q.target}\n   Reward: ${q.reward}g\n\n`;
        });

        showToast(questList);

        // Accept first uncompleted quest
        const availableQuest = hunter.quests.find(q => !q.completed && !GameState.activeQuests.includes(q.id));
        if (availableQuest) {
          GameState.activeQuests.push(availableQuest.id);
          GameState.questProgress[availableQuest.id] = { progress: 0, goal: availableQuest.goal || 1 };
          showTinyLog(`Quest accepted: ${availableQuest.name}`);
        }
      }
    }

    // ============================
    // CHEST SYSTEM
    // ============================

    const CHEST_TYPES = {
      common: { rarity: 'C', color: '#9e9e9e', goldMin: 10, goldMax: 50, glow: 0.2 },
      uncommon: { rarity: 'B', color: '#4caf50', goldMin: 50, goldMax: 150, glow: 0.4 },
      rare: { rarity: 'A', color: '#2196f3', goldMin: 150, goldMax: 400, glow: 0.6 },
      epic: { rarity: 'S', color: '#9c27b0', goldMin: 400, goldMax: 1000, glow: 0.8 },
      legendary: { rarity: 'S+', color: '#ff9800', goldMin: 1000, goldMax: 5000, glow: 1.0 }
    };

    function initializeChests(buildingType) {
      const chests = [];
      const W = canvas.width;
      const H = canvas.height;

      // Determine chest count and rarity based on building tier
      let chestCount = 1;
      let rarityWeights = { common: 0.5, uncommon: 0.3, rare: 0.15, epic: 0.04, legendary: 0.01 };

      // High-tier buildings get more/better chests
      if (buildingType === 'gates') {
        chestCount = 3;
        rarityWeights = { uncommon: 0.2, rare: 0.3, epic: 0.3, legendary: 0.2 };
      } else if (buildingType === 'temple' || buildingType === 'tower') {
        chestCount = 2;
        rarityWeights = { common: 0.2, uncommon: 0.3, rare: 0.3, epic: 0.15, legendary: 0.05 };
      } else if (buildingType === 'casino' || buildingType === 'arcade') {
        chestCount = 2;
        rarityWeights = { common: 0.3, uncommon: 0.4, rare: 0.2, epic: 0.08, legendary: 0.02 };
      }

      for (let i = 0; i < chestCount; i++) {
        const rarity = getWeightedRarity(rarityWeights);
        const chestType = CHEST_TYPES[rarity];

        // Position chests around the room
        const xPos = W * (0.2 + i * 0.3);
        const yPos = H - 250 - Math.random() * 50;

        chests.push({
          id: `${buildingType}_chest_${i}`,
          x: xPos,
          y: yPos,
          w: 28,
          h: 20,
          rarity: rarity,
          type: chestType,
          opened: GameState.chestStates[`${buildingType}_chest_${i}`] || false
        });
      }

      return chests;
    }

    function getWeightedRarity(weights) {
      const roll = Math.random();
      let cumulative = 0;

      for (const [rarity, weight] of Object.entries(weights)) {
        cumulative += weight;
        if (roll < cumulative) return rarity;
      }

      return 'common';
    }

    function openChest(chest) {
      if (chest.opened) {
        showToast("This chest has already been opened!");
        return;
      }

      chest.opened = true;
      GameState.chestStates[chest.id] = true;

      const goldReward = Math.floor(chest.type.goldMin + Math.random() * (chest.type.goldMax - chest.type.goldMin));
      GameState.gold += goldReward;
      updateGoldDisplay();

      const rarityText = chest.type.rarity;
      showToast(`üì¶ ${rarityText}-Rank Chest! +${goldReward} gold!`);
      showTinyLog(`Opened ${rarityText}-rank chest`);

      // Bonus XP for rare chests
      if (chest.rarity === 'epic' || chest.rarity === 'legendary') {
        const xpBonus = chest.rarity === 'legendary' ? 500 : 200;
        GameState.xp += xpBonus;
        showTinyLog(`Bonus: +${xpBonus} XP!`);
      }
    }

    // ============================
    // COMPUTER/TERMINAL SYSTEM
    // ============================

    function initializeComputers(buildingType) {
      const computers = [];
      const W = canvas.width;
      const H = canvas.height;

      // Archives, Shop, and Photo Booth get computers
      if (buildingType === 'library' || buildingType === 'shop' || buildingType === 'booth') {
        computers.push({
          x: W * 0.8,
          y: H - 260,
          w: 60,
          h: 44
        });
      }

      return computers;
    }

    function playComputerGame() {
      const cooldownKey = GameState.currentBuilding.id;

      if (GameState.computerCooldowns[cooldownKey] && Date.now() < GameState.computerCooldowns[cooldownKey]) {
        showToast('üíª Computer cooling down...');
        return;
      }

      const games = [
        'Coin Flip', 'Dice Roll', 'Number Guess',
        'Slots', 'Blackjack', 'Color Rush'
      ];

      const selectedGame = games[Math.floor(Math.random() * games.length)];
      const betAmount = 500 + Math.floor(Math.random() * 1000);

      if (GameState.gold < betAmount) {
        showToast(`‚ùå Need ${betAmount}g to play ${selectedGame}!`);
        return;
      }

      let won = false;
      let winAmount = 0;

      switch (selectedGame) {
        case 'Coin Flip':
          won = Math.random() < 0.5;
          winAmount = won ? betAmount * 2 : 0;
          break;
        case 'Dice Roll':
          won = Math.random() < 0.166; // 1 in 6
          winAmount = won ? betAmount * 5 : 0;
          break;
        case 'Number Guess':
          const guess = Math.floor(Math.random() * 100);
          const target = Math.floor(Math.random() * 100);
          const diff = Math.abs(guess - target);
          won = diff < 10;
          winAmount = won ? Math.floor(betAmount * (3 - diff / 10)) : 0;
          break;
        case 'Slots':
          const reels = [
            Math.floor(Math.random() * 5),
            Math.floor(Math.random() * 5),
            Math.floor(Math.random() * 5)
          ];
          if (reels[0] === reels[1] && reels[1] === reels[2]) {
            won = true;
            winAmount = betAmount * 10;
          } else if (reels[0] === reels[1] || reels[1] === reels[2]) {
            won = true;
            winAmount = betAmount * 2;
          }
          break;
        case 'Blackjack':
          const playerCard = Math.floor(Math.random() * 21) + 1;
          const dealerCard = Math.floor(Math.random() * 21) + 1;
          won = playerCard > dealerCard;
          winAmount = won ? betAmount * 2 : 0;
          break;
        case 'Color Rush':
          won = Math.random() < 0.3;
          winAmount = won ? betAmount * 4 : 0;
          break;
      }

      GameState.gold -= betAmount;

      if (won) {
        GameState.gold += winAmount;
        showToast(`üíª ${selectedGame} WON! +${winAmount}g`);
        showTinyLog(`Computer game win: ${winAmount - betAmount}g profit`);
      } else {
        showToast(`üíª ${selectedGame} Lost... -${betAmount}g`);
        showTinyLog(`Computer game: Lost ${betAmount}g`);
      }

      updateGoldDisplay();

      // Set cooldown (1 second)
      GameState.computerCooldowns[cooldownKey] = Date.now() + 1000;
    }

    // ============================
    // PET SYSTEM
    // ============================

    function initializePets(buildingType) {
      const pets = [];
      const leader = GameState.party[0];

      // Temple and Farmhouse get pets
      if (buildingType === 'temple' || buildingType === 'farmhouse') {
        pets.push({
          type: 'cat',
          name: 'Shadow',
          x: leader.x - 30,
          y: leader.y + 15,
          w: 16,
          h: 16,
          following: 'player',
          buff: { atkBoost: 10, critChance: 5 },
          color: '#795548'
        });

        pets.push({
          type: 'dog',
          name: 'Spark',
          x: leader.x + 30,
          y: leader.y + 15,
          w: 18,
          h: 18,
          following: 'player',
          buff: { defBoost: 15, hpRegen: 2 },
          color: '#ff9800'
        });
      }

      return pets;
    }

    function initializeArcadeMachines() {
      const machines = [];
      const W = canvas.width;
      const H = canvas.height;

      machines.push(
        {
          id: 'arc_rps',
          name: 'Rock Duel',
          gameType: 'rps',
          x: W * 0.16,
          y: H - 320,
          w: 90,
          h: 150,
          theme: '#ff8a65',
          screen: 'RPS'
        },
        {
          id: 'arc_slots',
          name: 'Lucky Slots',
          gameType: 'slots',
          x: W * 0.32,
          y: H - 330,
          w: 92,
          h: 155,
          theme: '#26c6da',
          screen: 'SLOTS'
        },
        {
          id: 'arc_missy',
          name: 'Missy Prime',
          gameType: 'missy',
          x: W * 0.48,
          y: H - 340,
          w: 96,
          h: 160,
          theme: '#7e57c2',
          screen: 'MISSY'
        },
        {
          id: 'arc_platformer',
          name: 'Coin Climb',
          gameType: 'platformer',
          x: W * 0.64,
          y: H - 330,
          w: 92,
          h: 155,
          theme: '#ff6bb5',
          screen: 'COIN'
        },
        {
          id: 'arc_racing',
          name: 'Hyper Drift',
          gameType: 'racing',
          x: W * 0.80,
          y: H - 320,
          w: 90,
          h: 150,
          theme: '#4dd0e1',
          screen: 'RACE'
        }
      );

      return machines;
    }

    function updatePets(dt) {
      const leader = GameState.party[0];

      for (const pet of GameState.interior.pets) {
        // Follow leader with smooth movement
        const targetX = leader.x + (pet.type === 'cat' ? -30 : 30);
        const targetY = leader.y + 15;

        const dx = targetX - pet.x;
        const dy = targetY - pet.y;
        const dist = Math.hypot(dx, dy);

        if (dist > 5) {
          const speed = 200;
          pet.x += (dx / dist) * speed * dt;
          pet.y += (dy / dist) * speed * dt;
        }
      }
    }

    // ============================
    // INDOOR COMBAT SYSTEM
    // ============================

    function startIndoorCombat() {
      GameState.indoorCombat.active = true;
      GameState.indoorCombat.enemies = [];
      GameState.indoorCombat.wave = 0;
      GameState.indoorCombat.spawnTimer = 0.5;
      GameState.indoorCombat.fx = [];

      showToast('‚öîÔ∏è Indoor Combat Started! Press F to attack!');
      showTinyLog('Wave-based combat active');
    }

    function spawnIndoorEnemy() {
      const W = canvas.width;
      const H = canvas.height;

      const arenaMinX = W * 0.28;
      const arenaMaxX = W * 0.72;
      const spawnX = arenaMinX + Math.random() * (arenaMaxX - arenaMinX);
      const spawnY = H - 240 - Math.random() * 50;

      const hpBase = 180 + GameState.indoorCombat.wave * 45;

      GameState.indoorCombat.enemies.push({
        id: `enemy_${Date.now()}_${Math.floor(Math.random() * 1000)}`,
        x: spawnX,
        y: spawnY,
        vx: (Math.random() < 0.5 ? -1 : 1) * (80 + GameState.indoorCombat.wave * 6),
        hp: hpBase,
        hpMax: hpBase,
        w: 20,
        h: 26,
        color: '#ff93d3'
      });
    }

    function updateIndoorCombat(dt) {
      if (!GameState.indoorCombat.active) return;

      const combat = GameState.indoorCombat;
      combat.spawnTimer -= dt;

      // Spawn new enemy if needed
      if (combat.spawnTimer <= 0 && combat.enemies.length < 3) {
        spawnIndoorEnemy();
        combat.wave++;
        combat.spawnTimer = Math.max(1.2, 3.2 - combat.wave * 0.12);
      }

      // Update enemy movement
      const W = canvas.width;
      const arenaMinX = W * 0.25;
      const arenaMaxX = W * 0.75;

      combat.enemies.forEach(enemy => {
        enemy.x += enemy.vx * dt;
        if (enemy.x < arenaMinX || enemy.x > arenaMaxX) {
          enemy.vx *= -1;
          enemy.x = Math.max(arenaMinX, Math.min(arenaMaxX, enemy.x));
        }
      });

      // Update VFX
      combat.fx = combat.fx.filter(fx => {
        fx.life -= dt * 1000;
        return fx.life > 0;
      });
    }

    function attackIndoorEnemy() {
      // AAA: If counter is available, perform counter-attack instead
      if (GameState.canCounter) {
        performCounterAttack();
        return;
      }
      
      if (!GameState.indoorCombat.active) return;

      const leader = GameState.party[0];
      const combat = GameState.indoorCombat;

      // Find nearest enemy
      let nearest = null;
      let minDist = 200;

      for (const enemy of combat.enemies) {
        const dist = Math.hypot(leader.x - enemy.x, leader.y - enemy.y);
        if (dist < minDist) {
          minDist = dist;
          nearest = enemy;
        }
      }

      if (!nearest) {
        showTinyLog('No enemy in range');
        return;
      }

      // AAA: Apply combo multiplier to damage
      const baseDamage = leader.atk + Math.floor(Math.random() * 20);
      const damage = Math.floor(baseDamage * GameState.comboMultiplier);
      nearest.hp -= damage;
      
      // AAA: Add to combo counter
      addCombo(true);

      // Spawn VFX
      spawnIndoorFxSlash(nearest.x, nearest.y - 12);
      spawnIndoorFxBurst(nearest.x, nearest.y - 10, '#ff6b35', 200);
      
      // PHASE 5: Tutorial trigger
      advanceTutorial('attack');

      // Check if enemy defeated
      if (nearest.hp <= 0) {
        const goldReward = 500 + Math.floor(Math.random() * 4500);
        const xpReward = 50 + Math.floor(Math.random() * 150);

        GameState.gold += goldReward;
        gainXP(xpReward); // Use gainXP for level-up handling
        updateGoldDisplay();

        showTinyLog(`Enemy defeated! +${goldReward}g +${xpReward} XP`);

        // Remove enemy
        combat.enemies = combat.enemies.filter(e => e !== nearest);
        combat.spawnTimer = Math.min(combat.spawnTimer, 0.8);

        // PHASE 3: Track quest progress
        updateQuestProgress('kill', 1);
        
        // PHASE 3: Check achievements
        if (!GameState.achievementProgress['ENEMY_COUNT']) {
          GameState.achievementProgress['ENEMY_COUNT'] = 0;
        }
        GameState.achievementProgress['ENEMY_COUNT']++;
        
        if (GameState.achievementProgress['ENEMY_COUNT'] === 1) {
          checkAchievement('FIRST_ENEMY');
        } else if (GameState.achievementProgress['ENEMY_COUNT'] === 10) {
          checkAchievement('ENEMY_SLAYER_10', 10);
        } else if (GameState.achievementProgress['ENEMY_COUNT'] === 50) {
          checkAchievement('ENEMY_SLAYER_50', 50);
        } else if (GameState.achievementProgress['ENEMY_COUNT'] === 100) {
          checkAchievement('ENEMY_SLAYER_100', 100);
        }
        
        // Check gold achievements
        checkAchievement('GOLD_1000', GameState.gold);
        checkAchievement('GOLD_10000', GameState.gold);
      }
    }

    function spawnIndoorFxSlash(x, y, life = 300) {
      GameState.indoorCombat.fx.push({
        type: 'slash',
        x, y,
        life, maxLife: life,
        frame: 0
      });
    }

    function spawnIndoorFxBurst(x, y, color = '#ff6adf', life = 240) {
      GameState.indoorCombat.fx.push({
        type: 'burst',
        x, y, color,
        life, maxLife: life
      });
    }

    function spawnIndoorFxBeam(x1, y1, x2, y2, color = '#9fd7ff', life = 280) {
      GameState.indoorCombat.fx.push({
        type: 'beam',
        x1, y1, x2, y2, color,
        life, maxLife: life
      });
    }

    function enterBuilding(building) {
      // Save exterior positions
      GameState.savedExteriorPosition = {
        party: GameState.party.map(c => ({ x: c.x, y: c.y })),
        camera: { x: GameState.camera.x }
      };

      GameState.mode = 'interior';
      GameState.currentBuilding = building;

      // Reset character positions for interior view (center of screen)
      const leader = GameState.party[0];
      leader.x = canvas.width / 2;
      leader.y = 450;

      GameState.party[1].x = canvas.width / 2 - 50;
      GameState.party[1].y = 470;

      GameState.party[2].x = canvas.width / 2 + 50;
      GameState.party[2].y = 470;

      // Initialize hunters for this building type
      GameState.interior.hunters = initializeHunters(building.type);

      // Initialize chests for this building
      GameState.interior.chests = initializeChests(building.type);

      // Initialize computers for this building
      GameState.interior.computers = initializeComputers(building.type);

      // Initialize pets for this building
      GameState.interior.pets = initializePets(building.type);

      // Initialize arcade machines for arcade
      if (building.type === 'arcade') {
        GameState.interior.arcadeMachines = initializeArcadeMachines();
      }

      // Start indoor combat for Arena
      if (building.type === 'arena') {
        startIndoorCombat();
      }

      document.getElementById("interiorIndicator").classList.add("show");
      showTinyLog(`Entered ${building.name}!`);
      showToast(`üè† Entered ${building.name}`);
    }

    function exitBuilding() {
      // Restore exterior positions
      if (GameState.savedExteriorPosition) {
        GameState.party.forEach((char, i) => {
          char.x = GameState.savedExteriorPosition.party[i].x;
          char.y = GameState.savedExteriorPosition.party[i].y;
        });
        GameState.camera.x = GameState.savedExteriorPosition.camera.x;
      }

      GameState.mode = 'exterior';
      GameState.currentBuilding = null;
      GameState.nearestInteractive = null;

      // Clear interior content
      GameState.interior.hunters = [];
      GameState.interior.pets = [];
      GameState.interior.chests = [];
      GameState.interior.npcs = [];
      GameState.interior.counters = [];
      GameState.interior.computers = [];
      GameState.interior.arcadeMachines = [];

      // Stop indoor combat
      GameState.indoorCombat.active = false;
      GameState.indoorCombat.enemies = [];
      GameState.indoorCombat.wave = 0;
      GameState.indoorCombat.fx = [];

      document.getElementById("interiorIndicator").classList.remove("show");
      showTinyLog("Exited to exterior");
      showToast("üö™ Returned to city");
    }

    // ============================
    // CASINO/ARCADE GAME SYSTEM
    // ============================

   function startGame(gameType) {
      if (GameState.gameInProgress) return;

      const panel = document.getElementById("gamePanel");
      const title = document.getElementById("gameTitle");
      const gameArea = document.getElementById("gameArea");
      const betContainer = document.getElementById("betSliderContainer");
      const result = document.getElementById("gameResult");

      result.style.display = "none";
      result.className = "game-result";

      switch (gameType) {
        case 'rps':
          title.textContent = "ü™®üìÑ‚úÇÔ∏è Rock Paper Scissors";
          betContainer.style.display = "block";
          gameArea.innerHTML = `
            <p style="font-size: 1.2rem; margin-bottom: 20px;">Choose your move!</p>
            <div class="rps-buttons">
              <button class="rps-button" onclick="playRPS('rock')">ü™®</button>
              <button class="rps-button" onclick="playRPS('paper')">üìÑ</button>
              <button class="rps-button" onclick="playRPS('scissors')">‚úÇÔ∏è</button>
            </div>
          `;
          break;

        case 'slots':
          title.textContent = "üé∞ Slot Machine";
          betContainer.style.display = "block";
          gameArea.innerHTML = `
            <p style="font-size: 1.2rem; margin-bottom: 20px;">Pull the lever!</p>
            <div class="slot-reels">
              <div class="slot-reel" id="reel1">üçí</div>
              <div class="slot-reel" id="reel2">üçã</div>
              <div class="slot-reel" id="reel3">üíé</div>
            </div>
            <button class="action-button" onclick="playSlots()" style="margin-top: 20px;">üé∞ SPIN!</button>
          `;
          break;

        case 'roulette':
          title.textContent = "üé° Roulette";
          betContainer.style.display = "block";
          gameArea.innerHTML = `
            <p style="font-size: 1.2rem; margin-bottom: 15px;">Place your bet!</p>
            <div style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; max-width: 500px; margin: 0 auto 20px;">
              <button class="action-button" onclick="playRoulette('red')" style="background: #ef4444; padding: 15px;">
                üî¥ Red<br><small>2x payout</small>
              </button>
              <button class="action-button" onclick="playRoulette('black')" style="background: #1f2937; padding: 15px;">
                ‚ö´ Black<br><small>2x payout</small>
              </button>
              <button class="action-button" onclick="playRoulette('green')" style="background: #22c55e; padding: 15px;">
                üü¢ Green<br><small>14x payout</small>
              </button>
              <button class="action-button" onclick="playRoulette('number')" style="background: #3b82f6; padding: 15px;">
                üéØ Number<br><small>36x payout</small>
              </button>
            </div>
            <div id="rouletteWheel" style="font-size: 4rem; margin: 20px 0; min-height: 100px; display: flex; align-items: center; justify-content: center;">
              üé°
            </div>
          `;
          break;

        case 'dice':
          title.textContent = "üé≤ Dice Game";
          betContainer.style.display = "block";
          gameArea.innerHTML = `
            <p style="font-size: 1.2rem; margin-bottom: 15px;">Roll two dice!</p>
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; max-width: 450px; margin: 0 auto 20px;">
              <button class="action-button" onclick="playDice('low')" style="padding: 15px;">
                üìâ Low (2-6)<br><small>2x payout</small>
              </button>
              <button class="action-button" onclick="playDice('seven')" style="padding: 15px; background: #fbbf24;">
                üéØ Seven<br><small>5x payout</small>
              </button>
              <button class="action-button" onclick="playDice('high')" style="padding: 15px;">
                üìà High (8-12)<br><small>2x payout</small>
              </button>
            </div>
            <div id="diceDisplay" style="font-size: 5rem; margin: 20px 0; min-height: 120px; display: flex; gap: 20px; align-items: center; justify-content: center;">
              üé≤ üé≤
            </div>
            <div id="diceTotal" style="font-size: 2rem; color: #fbbf24; min-height: 40px;">
              
            </div>
          `;
          break;

        case 'blackjack':
          title.textContent = "üÉè Blackjack";
          betContainer.style.display = "block";
          gameArea.innerHTML = `
            <p style="font-size: 1.2rem; margin-bottom: 20px;">Coming Soon!</p>
            <p>Full blackjack implementation with dealer AI</p>
          `;
          break;

        case 'racing':
          title.textContent = "üèÅ Racing Challenge";
          betContainer.style.display = "none";
          gameArea.innerHTML = `
            <p style="font-size: 1.2rem; margin-bottom: 15px;">3-Lap Race!</p>
            <div style="text-align: left; max-width: 500px; margin: 0 auto;">
              <div style="margin-bottom: 10px;">
                <strong>Lap:</strong> <span id="raceLap">0</span> / 3
              </div>
              <div style="margin-bottom: 10px;">
                <strong>Speed:</strong> <span id="raceSpeed">0</span> km/h
              </div>
              <div style="margin-bottom: 10px;">
                <strong>Progress:</strong>
                <div style="background: #374151; height: 20px; border-radius: 10px; overflow: hidden;">
                  <div id="raceProgress" style="background: #10b981; height: 100%; width: 0%; transition: width 0.1s;"></div>
                </div>
              </div>
              <div style="margin-bottom: 20px;">
                <strong>Time:</strong> <span id="raceTime">0.00</span>s
              </div>
            </div>
            <p style="font-size: 0.9rem; color: #9ca3af; margin-bottom: 15px;">
              Spam SPACE or CLICK to accelerate!
            </p>
            <button class="action-button" onclick="startRace()" style="font-size: 1.5rem;">üèÅ START RACE</button>
          `;
          break;

        case 'fishing':
          title.textContent = "üé£ Fishing Mini-Game";
          betContainer.style.display = "none";
          gameArea.innerHTML = `
            <p style="font-size: 1.2rem; margin-bottom: 15px;">Cast your line!</p>
            <div style="margin-bottom: 20px;">
              <div id="fishingIndicator" style="font-size: 3rem; min-height: 80px; display: flex; align-items: center; justify-content: center;">
                üé£
              </div>
              <div id="fishingStatus" style="font-size: 1.1rem; color: #9ca3af; margin-top: 10px;">
                Waiting...
              </div>
            </div>
            <button id="fishingButton" class="action-button" onclick="castLine()" style="font-size: 1.3rem;">
              üé£ CAST LINE
            </button>
            <div id="fishingResults" style="margin-top: 20px; text-align: left; max-width: 400px; margin-left: auto; margin-right: auto;">
              <strong>Today's Catch:</strong>
              <div id="fishList" style="margin-top: 10px; font-size: 0.9rem;"></div>
            </div>
          `;
          break;

        case 'celestial':
          title.textContent = "üåü Celestial Challenge";
          betContainer.style.display = "none";
          gameArea.innerHTML = `
            <p style="font-size: 1.2rem; margin-bottom: 15px; color: #a855f7;">Ultimate Boss Battle!</p>
            <div style="margin-bottom: 20px;">
              <div style="margin-bottom: 15px;">
                <strong style="color: #ef4444;">üêâ Celestial Dragon</strong>
                <div style="background: #374151; height: 25px; border-radius: 12px; overflow: hidden; margin-top: 5px;">
                  <div id="bossHP" style="background: linear-gradient(90deg, #ef4444, #dc2626); height: 100%; width: 100%; transition: width 0.3s;"></div>
                </div>
                <div style="font-size: 0.9rem; color: #9ca3af;">HP: <span id="bossHPText">10000</span> / 10000</div>
              </div>
              <div>
                <strong style="color: #22c55e;">‚öîÔ∏è Your Party</strong>
                <div style="background: #374151; height: 25px; border-radius: 12px; overflow: hidden; margin-top: 5px;">
                  <div id="partyHP" style="background: linear-gradient(90deg, #22c55e, #16a34a); height: 100%; width: 100%; transition: width 0.3s;"></div>
                </div>
                <div style="font-size: 0.9rem; color: #9ca3af;">HP: <span id="partyHPText">300</span> / 300</div>
              </div>
            </div>
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; max-width: 400px; margin: 0 auto 20px;">
              <button class="action-button" onclick="celestialAttack('heavy')" style="padding: 15px;">
                ‚öîÔ∏è Heavy Attack<br><small>(-100 HP, miss chance)</small>
              </button>
              <button class="action-button" onclick="celestialAttack('quick')" style="padding: 15px;">
                üó°Ô∏è Quick Attack<br><small>(-50 HP, guaranteed)</small>
              </button>
              <button class="action-button" onclick="celestialDefend()" style="padding: 15px;">
                üõ°Ô∏è Defend<br><small>(Block 50% damage)</small>
              </button>
              <button class="action-button" onclick="celestialHeal()" style="padding: 15px;">
                ‚ù§Ô∏è Heal<br><small>(+100 HP)</small>
              </button>
            </div>
            <div id="celestialLog" style="background: #1f2937; padding: 15px; border-radius: 8px; max-width: 400px; margin: 0 auto; max-height: 150px; overflow-y: auto; text-align: left; font-size: 0.85rem; font-family: monospace;">
              <div style="color: #fbbf24;">‚öîÔ∏è Battle started! Defeat the Celestial Dragon!</div>
            </div>
          `;
          // Initialize celestial battle state
          if (!GameState.celestialBattle) {
            GameState.celestialBattle = {
              bossHP: 10000,
              bossMaxHP: 10000,
              partyHP: 300,
              partyMaxHP: 300,
              defending: false,
              turn: 0
            };
          }
          break;
      }

      panel.classList.add("show");
    }

    function playRPS(playerChoice) {
      const bet = GameState.currentBet;

      if (GameState.gold < bet) {
        showToast("‚ùå Not enough gold!", "error");
        return;
      }

      GameState.gold -= bet;
      updateGoldDisplay();

      const isArcade = GameState.currentBuilding && GameState.currentBuilding.type === 'arcade';

      const choices = ['rock', 'paper', 'scissors'];
      const cpuChoice = choices[Math.floor(Math.random() * choices.length)];

      const icons = {
        rock: 'ü™®',
        paper: 'üìÑ',
        scissors: '‚úÇÔ∏è'
      };

      const result = document.getElementById("gameResult");
      result.style.display = "block";

      let outcome = '';
      let payout = 0;

      if (playerChoice === cpuChoice) {
        outcome = 'tie';
        payout = bet; // Return bet
        result.className = "game-result tie";
        result.innerHTML = `
          TIE! ${icons[playerChoice]} vs ${icons[cpuChoice]}<br>
          Bet returned: ${bet.toLocaleString()} gold
        `;
      } else if (
        (playerChoice === 'rock' && cpuChoice === 'scissors') ||
        (playerChoice === 'paper' && cpuChoice === 'rock') ||
        (playerChoice === 'scissors' && cpuChoice === 'paper')
      ) {
        outcome = 'win';
        payout = bet * 2; // 2x bet
        result.className = "game-result win";
        result.innerHTML = `
          YOU WIN! ${icons[playerChoice]} beats ${icons[cpuChoice]}!<br>
          Won: ${payout.toLocaleString()} gold üéâ
        `;
      } else {
        outcome = 'lose';
        payout = 0;
        result.className = "game-result lose";
        result.innerHTML = `
          YOU LOSE! ${icons[cpuChoice]} beats ${icons[playerChoice]}<br>
          Lost: ${bet.toLocaleString()} gold
        `;
      }

      GameState.gold += payout;
      updateGoldDisplay();

      if (outcome === 'win') {
        showToast(`üéâ Won ${payout.toLocaleString()} gold!`);
        showTinyLog(`RPS: Won ${payout.toLocaleString()} gold!`);

        // Award tickets in arcade
        if (isArcade) {
          const tickets = 5 + Math.floor(bet / 1000);
          GameState.arcadeTickets += tickets;
          showTinyLog(`+${tickets} arcade tickets!`);
        }
      } else if (outcome === 'lose') {
        showTinyLog(`RPS: Lost ${bet.toLocaleString()} gold`);
      }
    }

    function playSlots() {
      const bet = GameState.currentBet;

      if (GameState.gold < bet) {
        showToast("‚ùå Not enough gold!", "error");
        return;
      }

      GameState.gold -= bet;
      updateGoldDisplay();

      const isArcade = GameState.currentBuilding && GameState.currentBuilding.type === 'arcade';

      const symbols = ['üçí', 'üçã', 'üçä', 'üíé', '7Ô∏è‚É£', '‚≠ê', 'üé∞'];
      const multipliers = {
        'üçí': 2,
        'üçã': 3,
        'üçä': 4,
        'üíé': 5,
        '7Ô∏è‚É£': 10,
        '‚≠ê': 20,
        'üé∞': 100
      };

      // Spin animation
      const reel1 = document.getElementById("reel1");
      const reel2 = document.getElementById("reel2");
      const reel3 = document.getElementById("reel3");

      let spinCount = 0;
      const spinInterval = setInterval(() => {
        reel1.textContent = symbols[Math.floor(Math.random() * symbols.length)];
        reel2.textContent = symbols[Math.floor(Math.random() * symbols.length)];
        reel3.textContent = symbols[Math.floor(Math.random() * symbols.length)];
        spinCount++;

        if (spinCount > 10) {
          clearInterval(spinInterval);

          // Final result
          const result1 = symbols[Math.floor(Math.random() * symbols.length)];
          const result2 = symbols[Math.floor(Math.random() * symbols.length)];
          const result3 = symbols[Math.floor(Math.random() * symbols.length)];

          reel1.textContent = result1;
          reel2.textContent = result2;
          reel3.textContent = result3;

          // Calculate payout
          const result = document.getElementById("gameResult");
          result.style.display = "block";
          let payout = 0;

          if (result1 === result2 && result2 === result3) {
            // JACKPOT - all 3 match
            payout = bet * multipliers[result1];
            result.className = "game-result win";
            result.innerHTML = `
              üé∞ JACKPOT! üé∞<br>
              ${result1} ${result2} ${result3}<br>
              Won: ${payout.toLocaleString()} gold! (${multipliers[result1]}x)
            `;
            showToast(`üé∞ JACKPOT! Won ${payout.toLocaleString()} gold!`);
            showTinyLog(`SLOTS JACKPOT: ${payout.toLocaleString()} gold!`);

            // Award tickets in arcade
            if (isArcade) {
              const tickets = 10 + Math.floor(bet / 500);
              GameState.arcadeTickets += tickets;
              showTinyLog(`+${tickets} arcade tickets!`);
            }
          } else if (result1 === result2 || result2 === result3 || result1 === result3) {
            // 2 matching
            const matchSymbol = result1 === result2 ? result1 : (result2 === result3 ? result2 : result1);
            payout = Math.floor(bet * multipliers[matchSymbol] / 2);
            result.className = "game-result win";
            result.innerHTML = `
              Two Match!<br>
              ${result1} ${result2} ${result3}<br>
              Won: ${payout.toLocaleString()} gold
            `;
            showTinyLog(`Slots: Won ${payout.toLocaleString()} gold`);

            // Award tickets in arcade (smaller for pairs)
            if (isArcade) {
              const tickets = 3 + Math.floor(bet / 1000);
              GameState.arcadeTickets += tickets;
              showTinyLog(`+${tickets} arcade tickets!`);
            }
          } else if (result1 === 'üçí' || result2 === 'üçí' || result3 === 'üçí') {
            // Cherry bonus
            payout = bet * 2;
            result.className = "game-result win";
            result.innerHTML = `
              Cherry Bonus!<br>
              ${result1} ${result2} ${result3}<br>
              Won: ${payout.toLocaleString()} gold
            `;
            showTinyLog(`Slots: Cherry bonus ${payout.toLocaleString()} gold`);
          } else {
            // No match
            result.className = "game-result lose";
            result.innerHTML = `
              No Match<br>
              ${result1} ${result2} ${result3}<br>
              Lost: ${bet.toLocaleString()} gold
            `;
            showTinyLog(`Slots: Lost ${bet.toLocaleString()} gold`);
          }

          GameState.gold += payout;
          updateGoldDisplay();

          // Award tickets in arcade
          if (isArcade && payout > bet) {
            const tickets = Math.floor((payout - bet) / 100);
            if (tickets > 0) {
              GameState.arcadeTickets += tickets;
              showTinyLog(`+${tickets} arcade tickets!`);
            }
          }
        }
      }, 100);
    }

    function closeGamePanel() {
      document.getElementById("gamePanel").classList.remove("show");
      GameState.gameInProgress = false;
    }

    function setMaxBet() {
      const maxBet = Math.min(500000, GameState.gold);
      GameState.currentBet = maxBet;
      document.getElementById("betSlider").value = maxBet;
      updateBetDisplay();
    }

    function updateBetDisplay() {
      document.getElementById("betAmount").textContent = `${GameState.currentBet.toLocaleString()} gold`;
    }

    function updateGoldDisplay() {
      document.getElementById("goldCount").textContent = GameState.gold.toLocaleString();
      document.getElementById("maxBetDisplay").textContent = `Max: ${Math.min(500000, GameState.gold).toLocaleString()}g`;
    }

    // ============================
    // MINI-GAME FUNCTIONS
    // ============================

    // ROULETTE GAME
    function playRoulette(betType) {
      const bet = GameState.currentBet;

      if (GameState.gold < bet) {
        showToast("‚ùå Not enough gold!", "error");
        return;
      }

      GameState.gold -= bet;
      updateGoldDisplay();

      const wheel = document.getElementById('rouletteWheel');
      const result = document.getElementById('gameResult');

      // Roulette numbers: 0 (green), 1-36 (alternating red/black)
      const redNumbers = [1, 3, 5, 7, 9, 12, 14, 16, 18, 19, 21, 23, 25, 27, 30, 32, 34, 36];
      const greenNumbers = [0];

      // Spin animation
      let spinCount = 0;
      const spinInterval = setInterval(() => {
        const randomNum = Math.floor(Math.random() * 37);
        wheel.textContent = randomNum;
        spinCount++;

        if (spinCount > 15) {
          clearInterval(spinInterval);

          // Final result
          const finalNumber = Math.floor(Math.random() * 37);
          wheel.textContent = finalNumber;

          const isRed = redNumbers.includes(finalNumber);
          const isBlack = !isRed && finalNumber !== 0;
          const isGreen = finalNumber === 0;

          result.style.display = "block";
          let payout = 0;
          let won = false;

          if (betType === 'red' && isRed) {
            payout = bet * 2;
            won = true;
          } else if (betType === 'black' && isBlack) {
            payout = bet * 2;
            won = true;
          } else if (betType === 'green' && isGreen) {
            payout = bet * 14;
            won = true;
          } else if (betType === 'number') {
            // Simplified - random chance for number bet
            if (Math.random() < 1 / 36) {
              payout = bet * 36;
              won = true;
            }
          }

          if (won) {
            result.className = "game-result win";
            result.innerHTML = `
              üéâ WINNER! üéâ<br>
              Ball landed on: ${finalNumber} (${isGreen ? 'üü¢' : isRed ? 'üî¥' : '‚ö´'})<br>
              Won: ${payout.toLocaleString()} gold!
            `;
            showToast(`üé° Roulette Win! +${payout.toLocaleString()} gold`);
            showTinyLog(`Roulette: Won ${payout.toLocaleString()} gold!`);
          } else {
            result.className = "game-result lose";
            result.innerHTML = `
              Ball landed on: ${finalNumber} (${isGreen ? 'üü¢' : isRed ? 'üî¥' : '‚ö´'})<br>
              Lost: ${bet.toLocaleString()} gold
            `;
            showTinyLog(`Roulette: Lost ${bet.toLocaleString()} gold`);
          }

          GameState.gold += payout;
          updateGoldDisplay();
        }
      }, 100);
    }

    // DICE GAME
    function playDice(betType) {
      const bet = GameState.currentBet;

      if (GameState.gold < bet) {
        showToast("‚ùå Not enough gold!", "error");
        return;
      }

      GameState.gold -= bet;
      updateGoldDisplay();

      const diceDisplay = document.getElementById('diceDisplay');
      const diceTotal = document.getElementById('diceTotal');
      const result = document.getElementById('gameResult');

      const diceEmojis = ['‚öÄ', '‚öÅ', '‚öÇ', '‚öÉ', '‚öÑ', '‚öÖ'];

      // Roll animation
      let rollCount = 0;
      const rollInterval = setInterval(() => {
        const die1 = Math.floor(Math.random() * 6);
        const die2 = Math.floor(Math.random() * 6);
        diceDisplay.innerHTML = `<div>${diceEmojis[die1]}</div><div>${diceEmojis[die2]}</div>`;
        rollCount++;

        if (rollCount > 10) {
          clearInterval(rollInterval);

          // Final roll
          const die1Value = Math.floor(Math.random() * 6) + 1;
          const die2Value = Math.floor(Math.random() * 6) + 1;
          const total = die1Value + die2Value;

          diceDisplay.innerHTML = `<div>${diceEmojis[die1Value - 1]}</div><div>${diceEmojis[die2Value - 1]}</div>`;
          diceTotal.textContent = `Total: ${total}`;

          result.style.display = "block";
          let payout = 0;
          let won = false;

          if (betType === 'low' && total >= 2 && total <= 6) {
            payout = bet * 2;
            won = true;
          } else if (betType === 'seven' && total === 7) {
            payout = bet * 5;
            won = true;
          } else if (betType === 'high' && total >= 8 && total <= 12) {
            payout = bet * 2;
            won = true;
          }

          if (won) {
            result.className = "game-result win";
            result.innerHTML = `
              üé≤ WINNER! üé≤<br>
              Rolled: ${total} (${die1Value} + ${die2Value})<br>
              Won: ${payout.toLocaleString()} gold!
            `;
            showToast(`üé≤ Dice Win! +${payout.toLocaleString()} gold`);
            showTinyLog(`Dice: Won ${payout.toLocaleString()} gold!`);
          } else {
            result.className = "game-result lose";
            result.innerHTML = `
              Rolled: ${total} (${die1Value} + ${die2Value})<br>
              Lost: ${bet.toLocaleString()} gold
            `;
            showTinyLog(`Dice: Lost ${bet.toLocaleString()} gold`);
          }

          GameState.gold += payout;
          updateGoldDisplay();
        }
      }, 100);
    }

    // RACING GAME
    let raceInterval = null;
    function startRace() {
      if (raceInterval) return;

      const raceState = {
        lap: 0,
        progress: 0,
        speed: 0,
        startTime: Date.now(),
        clicks: 0
      };

      document.querySelector('button[onclick="startRace()"]').textContent = 'üèÅ RACING...';
      document.querySelector('button[onclick="startRace()"]').disabled = true;

      // Add click/space handlers
      const accelerate = () => {
        raceState.clicks++;
        raceState.speed = Math.min(300, raceState.speed + 5);
      };

      document.addEventListener('click', accelerate);
      document.addEventListener('keydown', (e) => {
        if (e.code === 'Space') {
          e.preventDefault();
          accelerate();
        }
      });

      raceInterval = setInterval(() => {
        // Decay speed
        raceState.speed = Math.max(0, raceState.speed - 2);

        // Update progress
        raceState.progress += raceState.speed * 0.01;

        // Check lap completion
        if (raceState.progress >= 100) {
          raceState.lap++;
          raceState.progress = 0;
          showToast(`üèÅ Lap ${raceState.lap} completed!`);
        }

        // Update UI
        document.getElementById('raceLap').textContent = raceState.lap;
        document.getElementById('raceSpeed').textContent = Math.floor(raceState.speed);
        document.getElementById('raceProgress').style.width = raceState.progress + '%';
        document.getElementById('raceTime').textContent = ((Date.now() - raceState.startTime) / 1000).toFixed(2);

        // Check win condition
        if (raceState.lap >= 3) {
          clearInterval(raceInterval);
          raceInterval = null;

          const time = ((Date.now() - raceState.startTime) / 1000).toFixed(2);
          const reward = Math.max(1000, 5000 - Math.floor(time * 10));

          GameState.gold += reward;
          updateGoldDisplay();

          showToast(`üèÜ Race Won! Time: ${time}s - Reward: ${reward} gold!`);
          showTinyLog(`Race completed in ${time}s!`);

          document.querySelector('button[onclick="startRace()"]').textContent = 'üèÅ RACE AGAIN';
          document.querySelector('button[onclick="startRace()"]').disabled = false;

          document.removeEventListener('click', accelerate);
        }
      }, 50);
    }

    // FISHING GAME
    let fishingTimeout = null;
    let fishingActive = false;
    function castLine() {
      if (fishingActive) return;

      fishingActive = true;
      const button = document.getElementById('fishingButton');
      const status = document.getElementById('fishingStatus');
      const indicator = document.getElementById('fishingIndicator');

      button.disabled = true;
      button.textContent = '‚è≥ Waiting for bite...';
      status.textContent = 'Line cast... waiting...';
      indicator.textContent = 'üé£';

      // Random wait time (2-5 seconds)
      const waitTime = 2000 + Math.random() * 3000;

      fishingTimeout = setTimeout(() => {
        // Fish bites!
        status.textContent = 'üêü FISH BITING! CLICK NOW!';
        status.style.color = '#22c55e';
        status.style.fontWeight = 'bold';
        indicator.textContent = 'üêüüí¶';
        button.textContent = '‚ö° REEL IN!';
        button.disabled = false;
        button.style.animation = 'pulse 0.5s infinite';

        // Limited time to click (1.5 seconds)
        const catchWindow = setTimeout(() => {
          if (fishingActive) {
            // Missed it
            status.textContent = 'Fish got away! üò¢';
            status.style.color = '#ef4444';
            indicator.textContent = 'üé£';
            button.textContent = 'üé£ CAST AGAIN';
            button.style.animation = '';
            fishingActive = false;
          }
        }, 1500);

        button.onclick = () => {
          clearTimeout(catchWindow);

          // Caught fish!
          const fishTypes = [
            { name: 'Common Fish', rarity: 'Common', value: 50, emoji: 'üêü' },
            { name: 'Salmon', rarity: 'Common', value: 100, emoji: 'üê†' },
            { name: 'Tuna', rarity: 'Uncommon', value: 200, emoji: 'üê°' },
            { name: 'Rare Trout', rarity: 'Rare', value: 500, emoji: 'üé£' },
            { name: 'Golden Fish', rarity: 'Epic', value: 1000, emoji: 'üê†‚ú®' },
            { name: 'LEVIATHAN', rarity: 'LEGENDARY', value: 5000, emoji: 'üêã' }
          ];

          // Weighted random
          const roll = Math.random();
          let fish;
          if (roll < 0.5) fish = fishTypes[Math.floor(Math.random() * 2)]; // Common
          else if (roll < 0.8) fish = fishTypes[2]; // Uncommon
          else if (roll < 0.95) fish = fishTypes[3]; // Rare
          else if (roll < 0.99) fish = fishTypes[4]; // Epic
          else fish = fishTypes[5]; // Legendary

          GameState.gold += fish.value;
          updateGoldDisplay();

          status.textContent = `Caught ${fish.name}! +${fish.value} gold`;
          status.style.color = fish.rarity === 'LEGENDARY' ? '#a855f7' : fish.rarity === 'Epic' ? '#fbbf24' : '#22c55e';
          indicator.textContent = fish.emoji;

          showToast(`${fish.emoji} Caught ${fish.name}! +${fish.value} gold`);
          showTinyLog(`Fishing: ${fish.name} (${fish.rarity})`);

          // Add to catch list
          const fishList = document.getElementById('fishList');
          const entry = document.createElement('div');
          entry.textContent = `${fish.emoji} ${fish.name} (+${fish.value}g)`;
          entry.style.color = status.style.color;
          fishList.insertBefore(entry, fishList.firstChild);

          button.textContent = 'üé£ CAST AGAIN';
          button.style.animation = '';
          button.onclick = () => castLine();
          fishingActive = false;
        };
      }, waitTime);
    }

    // CELESTIAL BATTLE GAME
    function celestialAttack(type) {
      const battle = GameState.celestialBattle;
      if (!battle) return;

      const log = document.getElementById('celestialLog');

      // Player attack
      let damage = 0;
      let hit = true;

      if (type === 'heavy') {
        hit = Math.random() > 0.3; // 70% hit chance
        damage = hit ? 100 : 0;
        addCelestialLog(log, hit ? `‚öîÔ∏è Heavy attack! -${damage} HP` : '‚ùå Heavy attack missed!', hit ? '#22c55e' : '#ef4444');
      } else if (type === 'quick') {
        damage = 50;
        addCelestialLog(log, `üó°Ô∏è Quick attack! -${damage} HP`, '#22c55e');
      }

      battle.bossHP = Math.max(0, battle.bossHP - damage);
      updateCelestialUI();

      // Check win
      if (battle.bossHP <= 0) {
        const reward = 10000;
        GameState.gold += reward;
        updateGoldDisplay();

        addCelestialLog(log, `üåü VICTORY! Celestial Dragon defeated! +${reward} gold`, '#fbbf24');
        showToast(`üåü LEGENDARY VICTORY! +${reward} gold!`);
        showTinyLog('Celestial Dragon defeated!');

        // Reset battle
        GameState.celestialBattle = null;

        setTimeout(() => {
          closeGamePanel();
        }, 3000);
        return;
      }

      // Boss counter-attack
      setTimeout(() => {
        const bossAttacks = [
          { name: 'Fire Breath', damage: 50 },
          { name: 'Tail Swipe', damage: 40 },
          { name: 'Divine Roar', damage: 30 },
          { name: 'Meteor Strike', damage: 70 }
        ];

        const bossAttack = bossAttacks[Math.floor(Math.random() * bossAttacks.length)];
        let bossDamage = bossAttack.damage;

        if (battle.defending) {
          bossDamage = Math.floor(bossDamage / 2);
          addCelestialLog(log, `üõ°Ô∏è Defended! ${bossAttack.name} blocked (-${bossDamage} HP)`, '#3b82f6');
          battle.defending = false;
        } else {
          addCelestialLog(log, `üêâ ${bossAttack.name}! (-${bossDamage} HP)`, '#ef4444');
        }

        battle.partyHP = Math.max(0, battle.partyHP - bossDamage);
        updateCelestialUI();

        // Check loss
        if (battle.partyHP <= 0) {
          addCelestialLog(log, 'üíÄ DEFEATED! Your party has fallen...', '#ef4444');
          showToast('üíÄ Defeated by the Celestial Dragon...');
          showTinyLog('Battle lost...');

          GameState.celestialBattle = null;

          setTimeout(() => {
            closeGamePanel();
          }, 3000);
        }
      }, 1000);
    }

    function celestialDefend() {
      const battle = GameState.celestialBattle;
      if (!battle) return;

      battle.defending = true;
      const log = document.getElementById('celestialLog');
      addCelestialLog(log, 'üõ°Ô∏è Defensive stance! Next attack damage halved.', '#3b82f6');

      // Boss still attacks
      setTimeout(() => {
        celestialAttack('quick'); // Trigger boss turn
      }, 500);
    }

    function celestialHeal() {
      const battle = GameState.celestialBattle;
      if (!battle) return;

      const healAmount = Math.min(100, battle.partyMaxHP - battle.partyHP);
      battle.partyHP += healAmount;

      const log = document.getElementById('celestialLog');
      addCelestialLog(log, `‚ù§Ô∏è Healed! +${healAmount} HP`, '#22c55e');
      updateCelestialUI();

      // Boss attacks after heal
      setTimeout(() => {
        const bossAttacks = [
          { name: 'Fire Breath', damage: 50 },
          { name: 'Tail Swipe', damage: 40 }
        ];
        const bossAttack = bossAttacks[Math.floor(Math.random() * bossAttacks.length)];

        battle.partyHP = Math.max(0, battle.partyHP - bossAttack.damage);
        addCelestialLog(log, `üêâ ${bossAttack.name}! (-${bossAttack.damage} HP)`, '#ef4444');
        updateCelestialUI();

        if (battle.partyHP <= 0) {
          addCelestialLog(log, 'üíÄ DEFEATED! Your party has fallen...', '#ef4444');
          showToast('üíÄ Defeated by the Celestial Dragon...');
          GameState.celestialBattle = null;
          setTimeout(() => closeGamePanel(), 3000);
        }
      }, 1000);
    }

    function updateCelestialUI() {
      const battle = GameState.celestialBattle;
      if (!battle) return;

      const bossHPPercent = (battle.bossHP / battle.bossMaxHP) * 100;
      const partyHPPercent = (battle.partyHP / battle.partyMaxHP) * 100;

      document.getElementById('bossHP').style.width = bossHPPercent + '%';
      document.getElementById('bossHPText').textContent = battle.bossHP;
      document.getElementById('partyHP').style.width = partyHPPercent + '%';
      document.getElementById('partyHPText').textContent = battle.partyHP;
    }

    function addCelestialLog(container, message, color = '#fff') {
      const entry = document.createElement('div');
      entry.textContent = message;
      entry.style.color = color;
      entry.style.marginBottom = '5px';
      container.appendChild(entry);
      container.scrollTop = container.scrollHeight;
    }

    // Bet slider listener
    document.getElementById("betSlider").addEventListener("input", (e) => {
      GameState.currentBet = parseInt(e.target.value);
      updateBetDisplay();
    });

    // ============================
    // PARTY MOVEMENT
    // ============================

    function updateParty() {
      const leader = GameState.party[0];
      const speed = GameState.keys["Shift"] ? 10 : 5;

      let moved = false;

      // Different movement limits for interior vs exterior
      const minX = GameState.mode === 'interior' ? 100 : 50;
      const maxX = GameState.mode === 'interior' ? canvas.width - 100 : WORLD.width - 50;
      const minY = GameState.mode === 'interior' ? 200 : 400;
      const maxY = GameState.mode === 'interior' ? 600 : 600;

      if (GameState.keys["ArrowLeft"]) {
        leader.x = Math.max(minX, leader.x - speed);
        moved = true;
      }
      if (GameState.keys["ArrowRight"]) {
        leader.x = Math.min(maxX, leader.x + speed);
        moved = true;
      }
      if (GameState.keys["ArrowUp"]) {
        leader.y = Math.max(minY, leader.y - speed);
        moved = true;
      }
      if (GameState.keys["ArrowDown"]) {
        leader.y = Math.min(maxY, leader.y + speed);
        moved = true;
      }

      if (moved) {
        GameState.animTime++;
        leader.walkFrame = GameState.animTime;

        // Followers
        const follower1 = GameState.party[1];
        const follower2 = GameState.party[2];

        follower1.x += (leader.x - 50 - follower1.x) * 0.15;
        follower1.y += (leader.y + 20 - follower1.y) * 0.15;
        follower1.walkFrame = GameState.animTime - 2;

        follower2.x += (leader.x + 50 - follower2.x) * 0.15;
        follower2.y += (leader.y + 20 - follower2.y) * 0.15;
        follower2.walkFrame = GameState.animTime - 4;

        if (GameState.mode === 'exterior') {
          updateCamera();
          checkZone();
          checkNearbyBuildings();
          checkNearbyPortals();
        } else {
          checkInteriorInteractives();
        }
      }
    }

    function updateCamera() {
      const leader = GameState.party[0];
      const targetCameraX = leader.x - canvas.width / 2;
      GameState.camera.x += (targetCameraX - GameState.camera.x) * 0.1;
      GameState.camera.x = Math.max(0, Math.min(WORLD.width - canvas.width, GameState.camera.x));

      document.getElementById("mapPosition").textContent = `${Math.floor(leader.x)} / ${WORLD.width}`;
    }

    function checkZone() {
      const leader = GameState.party[0];
      const zone = ZONES.find((z) => leader.x >= z.x && leader.x < z.end);

      if (zone && zone.id !== GameState.currentZone) {
        GameState.currentZone = zone.id;
        document.getElementById("currentZone").textContent = zone.name;
        showTinyLog(`Entered ${zone.name}`);
      }
    }

    function checkNearbyBuildings() {
      const leader = GameState.party[0];
      let nearest = null;
      let minDist = 200;

      for (const building of BUILDINGS) {
        const dist = Math.abs(leader.x - (building.x + building.width / 2));
        if (dist < minDist && dist < 200) {
          nearest = building;
          minDist = dist;
        }
      }

      if (nearest && nearest !== GameState.nearestBuilding) {
        GameState.nearestBuilding = nearest;
        showTinyLog(`Near ${nearest.name} - Press E to enter`);

        if (!GameState.discoveredBuildings.has(nearest.id)) {
          GameState.discoveredBuildings.add(nearest.id);
          document.getElementById("buildingCount").textContent =
            `${GameState.discoveredBuildings.size} / ${BUILDINGS.length}`;
          showToast(`üè† Discovered: ${nearest.name}`);
        }
      } else if (!nearest) {
        GameState.nearestBuilding = null;
      }
    }

    function checkNearbyPortals() {
      const leader = GameState.party[0];
      let nearest = null;
      let minDist = 150;

      for (const portal of ZONE_PORTALS) {
        const dx = leader.x - portal.x;
        const dy = leader.y - portal.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < minDist) {
          nearest = portal;
          minDist = dist;
        }
      }

      if (nearest && nearest !== GameState.nearestPortal) {
        GameState.nearestPortal = nearest;
        const isUnlocked = GameState.unlockedPortals.has(nearest.id);
        if (isUnlocked) {
          showTinyLog(`${nearest.name} - Press E to fast travel`);
        } else {
          showTinyLog(`${nearest.name} - Locked (complete quest to unlock)`);
        }
      } else if (!nearest) {
        GameState.nearestPortal = null;
      }
    }

    function usePortal(portal) {
      if (!GameState.unlockedPortals.has(portal.id)) {
        showToast('üîí Portal is locked! Complete quests to unlock.');
        return;
      }

      const targetZone = ZONES.find(z => z.id === portal.targetZone);
      if (!targetZone) return;

      // Teleport to zone
      const leader = GameState.party[0];
      const targetX = targetZone.x + (targetZone.end - targetZone.x) / 2;
      const offset = targetX - leader.x;

      // Move entire party
      for (const char of GameState.party) {
        char.x += offset;
      }

      showToast(`üåÄ Teleported to ${targetZone.name}!`);
      
      // Spawn enemies in new zone
      setTimeout(() => {
        spawnZoneEnemies();
      }, 500);
    }

    function checkInteriorInteractives() {
      const leader = GameState.party[0];

      // Check exit door (always at specific position in interior)
      const exitX = canvas.width / 2;
      const exitY = 650;
      const distToExit = Math.sqrt(Math.pow(leader.x - exitX, 2) + Math.pow(leader.y - exitY, 2));

      if (distToExit < 100) {
        GameState.nearestInteractive = { type: 'exit' };
        return;
      }

      // Check game objects based on building type
      if (GameState.currentBuilding) {
        const interactives = getInteriorInteractives(GameState.currentBuilding);

        for (const interactive of interactives) {
          const dist = Math.sqrt(
            Math.pow(leader.x - interactive.x, 2) +
            Math.pow(leader.y - interactive.y, 2)
          );

          if (dist < 100) {
            GameState.nearestInteractive = interactive;
            showTinyLog(`Press E to ${interactive.label}`);
            return;
          }
        }
      }

      GameState.nearestInteractive = null;
    }

    function getInteriorInteractives(building) {
      const interactives = [];

      switch (building.type) {
        case 'casino':
          interactives.push(
            { type: 'game', gameType: 'rps', x: 300, y: 500, label: 'Play Rock Paper Scissors' },
            { type: 'game', gameType: 'slots', x: 550, y: 500, label: 'Play Slots' },
            { type: 'game', gameType: 'roulette', x: 800, y: 500, label: 'Play Roulette' },
            { type: 'game', gameType: 'dice', x: 1050, y: 500, label: 'Play Dice' },
            { type: 'game', gameType: 'blackjack', x: 1300, y: 500, label: 'Play Blackjack' }
          );
          break;

        case 'arcade':
          // Add arcade machines as interactives
          for (const machine of GameState.interior.arcadeMachines) {
            interactives.push({
              type: 'game',
              gameType: machine.gameType,
              x: machine.x + machine.w / 2,
              y: machine.y + machine.h,
              label: `Play ${machine.name}`
            });
          }
          break;

        case 'booth':
          // Photo booth - take screenshot
          interactives.push(
            { type: 'action', actionType: 'photo', x: canvas.width / 2, y: 400, label: 'Take Photo! üì∏' }
          );
          break;

        case 'board':
          // Quest board - accept quests (6 quest positions)
          for (let i = 0; i < 6; i++) {
            const col = i % 3;
            const row = Math.floor(i / 3);
            const x = 400 + col * 350;
            const y = 270 + row * 180;
            interactives.push(
              { type: 'action', actionType: 'quest', questId: i, x, y, label: 'Accept Quest' }
            );
          }
          break;

        case 'library':
          // Archives - read lore
          interactives.push(
            { type: 'action', actionType: 'read', x: canvas.width / 2, y: 430, label: 'Read Ancient Texts üìö' }
          );
          break;

        case 'forge':
          // Blacksmith - upgrade weapon
          interactives.push(
            { type: 'action', actionType: 'upgrade', x: canvas.width / 2, y: 420, label: 'Upgrade Weapon (1000 gold) üî®' }
          );
          break;

        case 'track':
          // Racing - start race
          interactives.push(
            { type: 'game', gameType: 'racing', x: canvas.width / 2, y: 360, label: 'Start 3-Lap Race! üèÅ' }
          );
          break;

        case 'pier':
          // Fishing - cast line
          interactives.push(
            { type: 'game', gameType: 'fishing', x: canvas.width / 2, y: bobberY || 400, label: 'Cast Fishing Line üé£' }
          );
          break;

        case 'farmhouse':
          // Farming - 6 plots
          for (let row = 0; row < 2; row++) {
            for (let col = 0; col < 3; col++) {
              const x = 300 + col * 250;
              const y = 400 + row * 130;
              const plotNum = row * 3 + col;
              interactives.push(
                { type: 'action', actionType: 'farm', plotId: plotNum, x, y, label: plotNum < 3 ? 'Harvest Crop üåæ' : 'Plant Seeds üå±' }
              );
            }
          }
          break;

        case 'temple':
          // Temple - 3 blessings
          const blessings = ['XP', 'Gold', 'Luck'];
          for (let i = 0; i < 3; i++) {
            const x = 250 + i * 350;
            interactives.push(
              { type: 'action', actionType: 'blessing', blessingType: blessings[i], x, y: 480, label: `Receive ${blessings[i]} Blessing ‚≠ê` }
            );
          }
          break;

        case 'gates':
          // Celestial Gates - enter challenge
          interactives.push(
            { type: 'game', gameType: 'celestial', x: canvas.width / 2, y: 375, label: 'Enter Ultimate Challenge üåü' }
          );
          break;
      }

      // Add hunters as interactable objects
      for (const hunter of GameState.interior.hunters) {
        interactives.push({
          type: 'hunter',
          hunter: hunter,
          x: hunter.x,
          y: hunter.y,
          label: `Talk to ${hunter.name} (${hunter.service})`
        });
      }

      // Add chests as interactable objects
      for (const chest of GameState.interior.chests) {
        if (!chest.opened) {
          interactives.push({
            type: 'chest',
            chest: chest,
            x: chest.x,
            y: chest.y,
            label: `Open ${chest.type.rarity}-Rank Chest üì¶`
          });
        }
      }

      // Add computers as interactable objects
      for (const computer of GameState.interior.computers) {
        interactives.push({
          type: 'computer',
          computer: computer,
          x: computer.x + 30,
          y: computer.y - 20,
          label: 'Play Computer Games üíª'
        });
      }

      return interactives;
    }

    // ============================
    // RENDERING
    // ============================

    function drawMinimap() {
      const minimapCanvas = document.getElementById("minimapCanvas");
      if (!minimapCanvas) return;

      const mctx = minimapCanvas.getContext("2d");
      mctx.clearRect(0, 0, 240, 90);

      // Background
      mctx.fillStyle = "#111827";
      mctx.fillRect(0, 0, 240, 90);

      // Zones
      const scale = 240 / WORLD.width;
      for (const zone of ZONES) {
        mctx.fillStyle = zone.color;
        mctx.fillRect(zone.x * scale, 0, (zone.end - zone.x) * scale, 90);
      }

      // Buildings
      for (const building of BUILDINGS) {
        if (GameState.discoveredBuildings.has(building.id)) {
          mctx.fillStyle = "#fbbf24";
        } else {
          mctx.fillStyle = "#4b5563";
        }
        mctx.fillRect(building.x * scale, 40, 3, 25);
      }

      // Characters (only in exterior mode)
      if (GameState.mode === 'exterior') {
        for (const char of GameState.party) {
          let color = "#00ffff";
          if (char.id === "missy") color = "#ff69b4";
          else if (char.id === "companion") color = "#fbbf24";

          mctx.fillStyle = color;
          mctx.beginPath();
          mctx.arc(char.x * scale, 45, 3, 0, Math.PI * 2);
          mctx.fill();
        }

        // Viewport
        mctx.strokeStyle = "#fff";
        mctx.lineWidth = 1;
        mctx.strokeRect(GameState.camera.x * scale, 0, (canvas.width * scale), 90);
      }
    }

    function render() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.save();
      
      // Apply screen shake
      if (GameState.screenShake > 0) {
        const shakeX = (Math.random() - 0.5) * GameState.screenShake;
        const shakeY = (Math.random() - 0.5) * GameState.screenShake;
        ctx.translate(shakeX, shakeY);
      }

      if (GameState.mode === 'exterior') {
        renderExterior();
      } else {
        renderInterior();
      }
      
      ctx.restore();
      
      // Apply hit flash overlay
      if (GameState.hitFlash > 0) {
        ctx.fillStyle = `rgba(255, 0, 0, ${GameState.hitFlash * 0.3})`;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }
      
      // Apply rage mode overlay
      if (GameState.rageMode) {
        ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
        ctx.lineWidth = 4;
        ctx.strokeRect(2, 2, canvas.width - 4, canvas.height - 4);
      }
      
      // Apply shield overlay
      if (GameState.isBlocking) {
        ctx.strokeStyle = 'rgba(0, 150, 255, 0.7)';
        ctx.lineWidth = 6;
        ctx.strokeRect(3, 3, canvas.width - 6, canvas.height - 6);
      }
      
      // AAA: Render combo UI
      renderComboUI();
      
      // AAA: Render status effects
      renderStatusEffects();
    }

    function renderExterior() {
      // Sky
      const zone = ZONES.find((z) => {
        const midX = GameState.camera.x + canvas.width * 0.5;
        return midX >= z.x && midX < z.end;
      }) || ZONES[0];

      const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      skyGradient.addColorStop(0, zone.sky);
      skyGradient.addColorStop(1, zone.color);
      ctx.fillStyle = skyGradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Ground
      const baseY = 660;
      ctx.fillStyle = "#2d5016";
      ctx.fillRect(0, baseY, canvas.width, canvas.height - baseY);

      ctx.fillStyle = "#4ade80";
      ctx.fillRect(0, baseY - 3, canvas.width, 3);

      ctx.fillStyle = "#3b2e58";
      ctx.fillRect(0, baseY + 10, canvas.width, 6);

      // Buildings
      for (const building of BUILDINGS) {
        const x = building.x - GameState.camera.x;

        if (x + building.width < -100 || x > canvas.width + 100) continue;

        const y = baseY - building.height - (building.yOffset || 0);

        if (GameState.nearestBuilding === building) {
          ctx.shadowColor = "#fbbf24";
          ctx.shadowBlur = 30;
          ctx.fillStyle = "rgba(251, 191, 36, 0.2)";
          ctx.fillRect(x - 10, y - 10, building.width + 20, building.height + 20);
          ctx.shadowBlur = 0;
        }

        drawBuilding(building, x, y);

        if (GameState.nearestBuilding === building && building.hasInterior) {
          ctx.fillStyle = "rgba(0, 0, 0, 0.9)";
          ctx.fillRect(x + building.width / 2 - 70, y - 60, 140, 35);
          ctx.strokeStyle = "#fbbf24";
          ctx.lineWidth = 2;
          ctx.strokeRect(x + building.width / 2 - 70, y - 60, 140, 35);

          ctx.fillStyle = "#fbbf24";
          ctx.font = "bold 14px Arial";
          ctx.textAlign = "center";
          ctx.fillText("Press E to Enter", x + building.width / 2, y - 37);
        }
      }

      // Characters (with vehicle visual effect for leader)
      for (let i = 0; i < GameState.party.length; i++) {
        const char = GameState.party[i];
        const x = char.x - GameState.camera.x;
        const y = char.y;
        if (x > -50 && x < canvas.width + 50) {
          const isLeader = (i === 0);
          
          // Draw vehicle glow/aura if leader has vehicle equipped
          if (isLeader && GameState.equipped.vehicle) {
            const vehicle = GameState.equipped.vehicle;
            // Vehicle aura/glow
            ctx.save();
            ctx.globalAlpha = 0.3;
            ctx.fillStyle = '#00ffff';
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 30;
            ctx.beginPath();
            ctx.ellipse(x, y + 20, 50, 20, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();
            
            // Vehicle icon above character
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(vehicle.icon, x, y - 60);
            ctx.shadowColor = '#00ffff';
            ctx.shadowBlur = 10;
            ctx.fillText(vehicle.icon, x, y - 60);
            ctx.shadowBlur = 0;
          }
          
          drawCharacter(x, y, char, isLeader);
        }
      }

      // Draw equipped companions (pets, vehicles, robots)
      const leader = GameState.party[0];
      const leaderX = leader.x - GameState.camera.x;
      const leaderY = leader.y;
      
      // Draw equipped pet (follows behind leader with animation)
      if (GameState.equipped.pet) {
        const pet = GameState.equipped.pet;
        const bobOffset = Math.sin(GameState.animTime * 0.08) * 5;
        const swayOffset = Math.cos(GameState.animTime * 0.06) * 3;
        const petX = leaderX - 60 + swayOffset;
        const petY = leaderY + 10 + bobOffset;
        
        // Pet shadow (pulses slightly)
        const shadowSize = 15 + Math.sin(GameState.animTime * 0.1) * 2;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.beginPath();
        ctx.ellipse(petX, petY + 25, shadowSize, 5, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Pet glow based on element (animated intensity)
        const glowColors = {
          fire: '#ff6600', ice: '#66ccff', electric: '#ffff00',
          earth: '#8b4513', wind: '#e0e0e0', arcane: '#9966ff',
          dark: '#6600cc', light: '#ffff99', shadow: '#4a0080',
          tech: '#00ff99'
        };
        const glowIntensity = 15 + Math.sin(GameState.animTime * 0.15) * 5;
        
        // Pet icon (large emoji with rotation)
        ctx.save();
        ctx.translate(petX, petY);
        ctx.rotate(Math.sin(GameState.animTime * 0.05) * 0.1);
        ctx.font = 'bold 48px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.shadowColor = glowColors[pet.element] || '#ffffff';
        ctx.shadowBlur = glowIntensity;
        ctx.fillText(pet.icon, 0, 0);
        ctx.shadowBlur = 0;
        ctx.restore();
        
        // Pet name tag
        ctx.font = 'bold 10px Arial';
        ctx.fillStyle = '#ffffff';
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 3;
        ctx.strokeText(pet.name, petX, petY - 35);
        ctx.fillText(pet.name, petX, petY - 35);
        
        // Attack indicator (when pet is attacking)
        if (pet.attackTimer && pet.attackTimer < 500) {
          ctx.strokeStyle = glowColors[pet.element] || '#ffffff';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(petX, petY, 30, 0, Math.PI * 2);
          ctx.stroke();
        }
      }
      
      // Draw equipped robot (follows to the right of leader with animation)
      if (GameState.equipped.robot) {
        const robot = GameState.equipped.robot;
        const hoverOffset = Math.sin(GameState.animTime * 0.07) * 6;
        const scanRotation = Math.sin(GameState.animTime * 0.04) * 0.15;
        const robotX = leaderX + 60;
        const robotY = leaderY + hoverOffset;
        
        // Robot shadow (pulses)
        const shadowPulse = 20 + Math.sin(GameState.animTime * 0.1) * 3;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
        ctx.beginPath();
        ctx.ellipse(robotX, leaderY + 30, shadowPulse, 7, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Tech glow rings (orbiting)
        for (let i = 0; i < 3; i++) {
          const angle = (GameState.animTime * 0.02) + (i * Math.PI * 2 / 3);
          const ringX = Math.cos(angle) * 25;
          const ringY = Math.sin(angle) * 25;
          ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(robotX + ringX, robotY + ringY, 3, 0, Math.PI * 2);
          ctx.stroke();
        }
        
        // Robot body (with rotation)
        ctx.save();
        ctx.translate(robotX, robotY);
        ctx.rotate(scanRotation);
        ctx.font = 'bold 56px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        
        // Robot cyan tech glow (pulsing)
        const glowPulse = 20 + Math.sin(GameState.animTime * 0.12) * 8;
        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = glowPulse;
        ctx.fillText(robot.icon, 0, 0);
        ctx.shadowBlur = 0;
        ctx.restore();
        
        // Robot HP bar (tech style with animated fill)
        const barWidth = 60;
        const barHeight = 4;
        const barX = robotX - barWidth / 2;
        const barY = robotY - 40;
        
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(barX, barY, barWidth, barHeight);
        
        // Animated fill
        const fillGlow = Math.sin(GameState.animTime * 0.2) * 0.3 + 0.7;
        ctx.fillStyle = `rgba(0, 255, 255, ${fillGlow})`;
        ctx.fillRect(barX, barY, barWidth, barHeight);
        
        // Border with glow
        ctx.strokeStyle = '#00ffff';
        ctx.lineWidth = 1;
        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = 5;
        ctx.strokeRect(barX, barY, barWidth, barHeight);
        ctx.shadowBlur = 0;
        
        // Robot name (glowing)
        ctx.font = 'bold 10px Arial';
        ctx.fillStyle = '#00ffff';
        ctx.shadowColor = '#00ffff';
        ctx.shadowBlur = 8;
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 3;
        ctx.strokeText(robot.name, robotX, robotY - 48);
        ctx.fillText(robot.name, robotX, robotY - 48);
        ctx.shadowBlur = 0;
        
        // Attack indicator (when robot is attacking)
        if (robot.attackTimer && robot.attackTimer < 500) {
          ctx.strokeStyle = '#00ffff';
          ctx.lineWidth = 3;
          ctx.shadowColor = '#00ffff';
          ctx.shadowBlur = 10;
          ctx.beginPath();
          ctx.arc(robotX, robotY, 35, 0, Math.PI * 2);
          ctx.stroke();
          ctx.shadowBlur = 0;
        }
      }

      // Draw zone portals
      for (const portal of ZONE_PORTALS) {
        const portalX = portal.x - GameState.camera.x;
        if (portalX < -100 || portalX > canvas.width + 100) continue;
        
        const isUnlocked = GameState.unlockedPortals.has(portal.id);
        const isNear = GameState.nearestPortal === portal;
        
        // Portal glow
        const glowSize = 40 + Math.sin(GameState.animTime * 0.1) * 10;
        const glowAlpha = isUnlocked ? 0.3 : 0.1;
        ctx.fillStyle = `rgba(100, 200, 255, ${glowAlpha})`;
        ctx.shadowColor = portal.color;
        ctx.shadowBlur = isNear ? 30 : 15;
        ctx.beginPath();
        ctx.arc(portalX, portal.y, glowSize, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
        
        // Portal icon
        ctx.font = 'bold 48px Arial';
        ctx.textAlign = 'center';
        ctx.fillStyle = isUnlocked ? portal.color : '#666666';
        ctx.fillText(portal.icon, portalX, portal.y);
        
        // Portal name (if near or unlocked)
        if (isNear || isUnlocked) {
          ctx.font = 'bold 12px Arial';
          ctx.fillStyle = '#ffffff';
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 3;
          ctx.strokeText(portal.name, portalX, portal.y + 40);
          ctx.fillText(portal.name, portalX, portal.y + 40);
        }
        
        // Interaction prompt
        if (isNear && isUnlocked) {
          ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
          ctx.fillRect(portalX - 70, portal.y - 50, 140, 30);
          ctx.strokeStyle = portal.color;
          ctx.lineWidth = 2;
          ctx.strokeRect(portalX - 70, portal.y - 50, 140, 30);
          
          ctx.fillStyle = '#4fc3f7';
          ctx.font = 'bold 12px Arial';
          ctx.fillText('Press E to Travel', portalX, portal.y - 32);
        } else if (isNear && !isUnlocked) {
          ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
          ctx.fillRect(portalX - 60, portal.y - 50, 120, 30);
          ctx.strokeStyle = '#666666';
          ctx.lineWidth = 2;
          ctx.strokeRect(portalX - 60, portal.y - 50, 120, 30);
          
          ctx.fillStyle = '#999999';
          ctx.font = 'bold 11px Arial';
          ctx.fillText('üîí Locked', portalX, portal.y - 32);
        }
      }

      // Draw enemies
      for (const enemy of GameState.enemies) {
        renderEnemy(enemy);
      }

      // Draw projectiles and VFX
      renderProjectiles();

      // Draw damage numbers
      renderDamageNumbers();

      // Draw minimap
      drawMinimap();
    }

    function renderInterior() {
      if (!GameState.currentBuilding) return;

      // Interior background
      const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      gradient.addColorStop(0, "#1a1a1a");
      gradient.addColorStop(1, "#0a0a0a");
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      drawInteriorLayout(GameState.currentBuilding);

      // Characters (fixed position in interior)
      for (const char of GameState.party) {
        drawCharacter(char.x, char.y, char);
      }

      // Draw hunters
      for (const hunter of GameState.interior.hunters) {
        drawHunter(hunter);
      }

      // Draw chests
      for (const chest of GameState.interior.chests) {
        drawChest(chest);
      }

      // Draw computers
      for (const computer of GameState.interior.computers) {
        drawComputer(computer);
      }

      // Draw pets
      for (const pet of GameState.interior.pets) {
        drawPet(pet);
      }

      // Draw indoor combat enemies and VFX
      if (GameState.indoorCombat.active) {
        drawIndoorCombat();
      }

      // Exit door indicator
      const exitX = canvas.width / 2;
      const exitY = 650;

      ctx.fillStyle = "#4a5568";
      ctx.fillRect(exitX - 40, exitY - 80, 80, 80);
      ctx.strokeStyle = "#fbbf24";
      ctx.lineWidth = 3;
      ctx.strokeRect(exitX - 40, exitY - 80, 80, 80);

      ctx.fillStyle = "#fff";
      ctx.font = "bold 16px Arial";
      ctx.textAlign = "center";
      ctx.fillText("EXIT", exitX, exitY - 35);
      ctx.fillText("üö™", exitX, exitY - 10);

      if (GameState.nearestInteractive && GameState.nearestInteractive.type === 'exit') {
        ctx.fillStyle = "rgba(251, 191, 36, 0.3)";
        ctx.fillRect(exitX - 50, exitY - 90, 100, 100);
      }
    }

    // ============================
    // HELPER DRAWING FUNCTIONS
    // ============================

    function drawBrickTexture(x, y, w, h, baseColor) {
      const brickW = 20;
      const brickH = 10;
      const rows = Math.ceil(h / brickH);
      const cols = Math.ceil(w / brickW);

      for (let row = 0; row < rows; row++) {
        for (let col = 0; col < cols; col++) {
          const offsetX = row % 2 === 0 ? 0 : brickW / 2;
          const bx = x + col * brickW + offsetX;
          const by = y + row * brickH;

          if (bx >= x + w || by >= y + h) continue;

          const variation = (row + col) % 3 * 10;
          ctx.fillStyle = shadeColor(baseColor, -variation);
          ctx.fillRect(bx, by, brickW - 2, brickH - 2);

          ctx.strokeStyle = shadeColor(baseColor, -40);
          ctx.lineWidth = 1;
          ctx.strokeRect(bx, by, brickW - 2, brickH - 2);
        }
      }
    }

    function drawWindow(x, y, w, h) {
      ctx.fillStyle = "#2d3748";
      ctx.fillRect(x, y, w, h);

      const gradient = ctx.createLinearGradient(x, y, x, y + h);
      gradient.addColorStop(0, "rgba(135, 206, 235, 0.4)");
      gradient.addColorStop(0.5, "rgba(135, 206, 235, 0.6)");
      gradient.addColorStop(1, "rgba(70, 130, 180, 0.5)");
      ctx.fillStyle = gradient;
      ctx.fillRect(x + 2, y + 2, w - 4, h - 4);

      ctx.strokeStyle = "#2d3748";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(x + w / 2, y);
      ctx.lineTo(x + w / 2, y + h);
      ctx.moveTo(x, y + h / 2);
      ctx.lineTo(x + w, y + h / 2);
      ctx.stroke();

      ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
      ctx.fillRect(x + 4, y + 4, w / 3, h / 3);
    }

    function drawDoor(x, y, w, h, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x, y, w, h);

      ctx.strokeStyle = shadeColor(color, -30);
      ctx.lineWidth = 2;
      ctx.strokeRect(x, y, w, h);

      ctx.fillStyle = "#fbbf24";
      ctx.beginPath();
      ctx.arc(x + w - 8, y + h / 2, 3, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawRoof(x, y, w, style, color) {
      const roofColor = shadeColor(color, -50);
      ctx.fillStyle = roofColor;

      if (style === "peaked") {
        ctx.beginPath();
        ctx.moveTo(x - 15, y);
        ctx.lineTo(x + w + 15, y);
        ctx.lineTo(x + w / 2, y - 30);
        ctx.closePath();
        ctx.fill();

        ctx.strokeStyle = shadeColor(roofColor, -20);
        ctx.lineWidth = 2;
        ctx.stroke();
      } else if (style === "flat") {
        ctx.fillRect(x - 10, y - 10, w + 20, 10);

        ctx.strokeStyle = shadeColor(roofColor, -20);
        ctx.lineWidth = 2;
        ctx.strokeRect(x - 10, y - 10, w + 20, 10);
      }
    }

    // ============================
    // BUILDING-SPECIFIC SPRITES
    // ============================

    function drawPhotoBooth(x, y, w, h, color) {
      // Colorful booth body
      const gradient = ctx.createLinearGradient(x, y, x + w, y);
      gradient.addColorStop(0, color);
      gradient.addColorStop(0.5, "#FF69B4");
      gradient.addColorStop(1, color);
      ctx.fillStyle = gradient;
      ctx.fillRect(x, y, w, h);

      // Camera icon
      ctx.fillStyle = "#000";
      ctx.fillRect(x + w / 2 - 20, y + 30, 40, 30);
      ctx.beginPath();
      ctx.arc(x + w / 2, y + 45, 15, 0, Math.PI * 2);
      ctx.fill();

      // Flash bulbs
      for (let i = 0; i < 3; i++) {
        ctx.fillStyle = "#FFD700";
        ctx.beginPath();
        ctx.arc(x + 20 + i * 25, y + 10, 5, 0, Math.PI * 2);
        ctx.fill();
      }

      // Curtain
      ctx.fillStyle = "#ff93d3";
      ctx.fillRect(x + w / 4, y + h - 40, w / 2, 40);
    }

    function drawQuestBoard(x, y, w, h, color) {
      // Wooden board
      ctx.fillStyle = "#8B4513";
      ctx.fillRect(x, y, w, h);

      // Wood grain
      for (let i = 0; i < 5; i++) {
        ctx.strokeStyle = "rgba(0, 0, 0, 0.2)";
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, y + i * 20);
        ctx.lineTo(x + w, y + i * 20 + 10);
        ctx.stroke();
      }

      // Scrolls
      for (let i = 0; i < 3; i++) {
        ctx.fillStyle = "#FFF8DC";
        ctx.fillRect(x + 15, y + 20 + i * 35, w - 30, 25);
        ctx.strokeStyle = "#D2691E";
        ctx.lineWidth = 2;
        ctx.strokeRect(x + 15, y + 20 + i * 35, w - 30, 25);
      }

      // Pins
      for (let i = 0; i < 3; i++) {
        ctx.fillStyle = "#DC143C";
        ctx.beginPath();
        ctx.arc(x + 20, y + 32 + i * 35, 3, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawArchives(x, y, w, h, color) {
      drawBrickTexture(x, y, w, h, color);

      // Columns
      ctx.fillStyle = "#9ca3af";
      for (let i = 0; i < 4; i++) {
        const cx = x + 15 + i * (w - 30) / 3;
        ctx.fillRect(cx, y, 12, h);

        // Column capital
        ctx.fillRect(cx - 3, y, 18, 8);
        ctx.fillRect(cx - 3, y + h - 8, 18, 8);
      }

      // Books in windows
      for (let i = 0; i < 2; i++) {
        const wx = x + w / 2 - 25 + i * 30;
        const wy = y + 40;

        drawWindow(wx, wy, 20, 30);

        // Book spines
        for (let j = 0; j < 3; j++) {
          ctx.fillStyle = ["#8B0000", "#1E90FF", "#228B22"][j];
          ctx.fillRect(wx + 4 + j * 5, wy + 8, 4, 15);
        }
      }

      drawDoor(x + w / 2 - 20, y + h - 50, 40, 50, "#4a3020");
    }

    function drawBlacksmith(x, y, w, h, color) {
      drawBrickTexture(x, y, w, h, color);

      // Forge fire glow
      ctx.shadowColor = "#ff6600";
      ctx.shadowBlur = 30;
      ctx.fillStyle = "#ff6600";
      ctx.fillRect(x + 15, y + 30, 30, 25);
      ctx.shadowBlur = 0;

      // Anvil symbol
      ctx.fillStyle = "#4a5568";
      ctx.fillRect(x + w / 2 - 15, y + h / 2 - 10, 30, 20);
      ctx.fillRect(x + w / 2 - 8, y + h / 2 - 20, 16, 10);

      // Hammer
      ctx.strokeStyle = "#8B4513";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(x + w / 2 + 20, y + h / 2 - 15);
      ctx.lineTo(x + w / 2 + 35, y + h / 2);
      ctx.stroke();

      ctx.fillStyle = "#4a5568";
      ctx.fillRect(x + w / 2 + 32, y + h / 2 - 5, 10, 10);

      // Smoke
      for (let i = 0; i < 3; i++) {
        ctx.fillStyle = `rgba(150, 150, 150, ${0.3 - i * 0.1})`;
        ctx.beginPath();
        ctx.arc(x + 30, y + 10 - i * 15, 8 + i * 3, 0, Math.PI * 2);
        ctx.fill();
      }

      drawDoor(x + w / 2 - 15, y + h - 45, 30, 45, "#2d1810");
    }

    function drawRacingTrack(x, y, w, h, color) {
      // Grandstand
      ctx.fillStyle = color;
      ctx.fillRect(x, y, w, h);

      // Checkered pattern
      const checkSize = 15;
      for (let row = 0; row < 3; row++) {
        for (let col = 0; col < 6; col++) {
          if ((row + col) % 2 === 0) {
            ctx.fillStyle = "#000";
            ctx.fillRect(x + col * checkSize + 20, y + 20 + row * checkSize, checkSize, checkSize);
          }
        }
      }

      // Checkered flag
      ctx.fillStyle = "#000";
      ctx.fillRect(x + w - 40, y + 20, 3, 50);

      for (let r = 0; r < 3; r++) {
        for (let c = 0; c < 2; c++) {
          if ((r + c) % 2 === 0) {
            ctx.fillStyle = "#000";
          } else {
            ctx.fillStyle = "#fff";
          }
          ctx.fillRect(x + w - 37 + c * 10, y + 20 + r * 10, 10, 10);
        }
      }

      // Finish line
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 3;
      ctx.setLineDash([10, 10]);
      ctx.beginPath();
      ctx.moveTo(x + 20, y + h - 20);
      ctx.lineTo(x + w - 20, y + h - 20);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    function drawFishingPier(x, y, w, h, color) {
      // Wooden dock
      ctx.fillStyle = "#8B7355";
      ctx.fillRect(x, y, w, h);

      // Planks
      for (let i = 0; i < w / 15; i++) {
        ctx.strokeStyle = "#654321";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x + i * 15, y);
        ctx.lineTo(x + i * 15, y + h);
        ctx.stroke();
      }

      // Water below
      ctx.fillStyle = "#1e3a5f";
      ctx.fillRect(x - 10, y + h, w + 20, 20);

      // Waves
      ctx.strokeStyle = "#4682B4";
      ctx.lineWidth = 2;
      for (let i = 0; i < 3; i++) {
        ctx.beginPath();
        ctx.moveTo(x, y + h + 7 + i * 6);
        ctx.quadraticCurveTo(x + w / 2, y + h + 10 + i * 6, x + w, y + h + 7 + i * 6);
        ctx.stroke();
      }

      // Fishing rod
      ctx.strokeStyle = "#8B4513";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(x + w - 30, y + h);
      ctx.lineTo(x + w - 20, y + 20);
      ctx.stroke();

      // Fishing line
      ctx.strokeStyle = "#666";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(x + w - 20, y + 20);
      ctx.lineTo(x + w - 15, y + h + 15);
      ctx.stroke();

      // Bobber
      ctx.fillStyle = "#ff0000";
      ctx.beginPath();
      ctx.arc(x + w - 15, y + h + 15, 4, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawFarmhouse(x, y, w, h, color) {
      // Barn body
      drawBrickTexture(x, y, w, h * 0.7, "#a3524f");

      // Barn roof
      ctx.fillStyle = "#8B0000";
      ctx.beginPath();
      ctx.moveTo(x - 15, y);
      ctx.lineTo(x + w / 2, y - 40);
      ctx.lineTo(x + w + 15, y);
      ctx.closePath();
      ctx.fill();

      // Barn doors (double)
      ctx.fillStyle = "#4a3020";
      ctx.fillRect(x + w / 2 - 25, y + h - 60, 22, 50);
      ctx.fillRect(x + w / 2 + 3, y + h - 60, 22, 50);

      ctx.strokeStyle = "#2d1810";
      ctx.lineWidth = 2;
      ctx.strokeRect(x + w / 2 - 25, y + h - 60, 22, 50);
      ctx.strokeRect(x + w / 2 + 3, y + h - 60, 22, 50);

      // Hay window
      drawWindow(x + 20, y + 30, 25, 25);

      // Windmill (small)
      ctx.fillStyle = "#D2691E";
      ctx.fillRect(x + w - 35, y + 20, 8, 40);

      // Windmill blades
      ctx.save();
      ctx.translate(x + w - 31, y + 25);
      ctx.rotate(GameState.animTime * 0.02);
      ctx.fillStyle = "#8B4513";
      for (let i = 0; i < 4; i++) {
        ctx.save();
        ctx.rotate((i * Math.PI) / 2);
        ctx.fillRect(-3, -20, 6, 20);
        ctx.restore();
      }
      ctx.restore();

      // Crops (small)
      for (let i = 0; i < 5; i++) {
        ctx.fillStyle = "#90EE90";
        ctx.fillRect(x + 10 + i * 15, y + h - 15, 8, 15);
      }
    }

    function drawTemple(x, y, w, h, color) {
      drawBrickTexture(x, y, w, h, color);

      // Pillars (Greek style)
      ctx.fillStyle = "#E6E6FA";
      for (let i = 0; i < 5; i++) {
        const cx = x + 10 + i * (w - 20) / 4;
        ctx.fillRect(cx, y + 30, 10, h - 30);

        // Fluting
        ctx.strokeStyle = shadeColor("#E6E6FA", -20);
        ctx.lineWidth = 1;
        for (let j = 0; j < 3; j++) {
          ctx.beginPath();
          ctx.moveTo(cx + 2 + j * 3, y + 30);
          ctx.lineTo(cx + 2 + j * 3, y + h);
          ctx.stroke();
        }
      }

      // Golden dome top
      ctx.fillStyle = "#FFD700";
      ctx.shadowColor = "#FFD700";
      ctx.shadowBlur = 20;
      ctx.beginPath();
      ctx.arc(x + w / 2, y + 15, 25, Math.PI, 2 * Math.PI);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Divine glow
      ctx.fillStyle = "rgba(255, 215, 0, 0.2)";
      ctx.beginPath();
      ctx.arc(x + w / 2, y + 15, 35, 0, Math.PI * 2);
      ctx.fill();

      // Entrance arch
      ctx.strokeStyle = "#FFD700";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(x + w / 2, y + h - 20, 25, Math.PI, 2 * Math.PI);
      ctx.stroke();
    }

    function drawCelestialGates(x, y, w, h, color) {
      // Massive gates
      const gradient = ctx.createLinearGradient(x, y, x + w, y + h);
      gradient.addColorStop(0, "#FFD700");
      gradient.addColorStop(0.5, "#FFF8DC");
      gradient.addColorStop(1, "#FFD700");
      ctx.fillStyle = gradient;
      ctx.fillRect(x, y, w, h);

      // Gate panels (double doors)
      ctx.strokeStyle = "#DAA520";
      ctx.lineWidth = 4;
      ctx.strokeRect(x + 10, y + 20, w / 2 - 20, h - 40);
      ctx.strokeRect(x + w / 2 + 10, y + 20, w / 2 - 20, h - 40);

      // Ornate decorations
      for (let i = 0; i < 3; i++) {
        ctx.fillStyle = "#FF6347";
        ctx.beginPath();
        ctx.arc(x + w / 4, y + 60 + i * 60, 8, 0, Math.PI * 2);
        ctx.fill();

        ctx.beginPath();
        ctx.arc(x + (3 * w) / 4, y + 60 + i * 60, 8, 0, Math.PI * 2);
        ctx.fill();
      }

      // Stars around gates
      for (let i = 0; i < 6; i++) {
        const sx = x + Math.random() * w;
        const sy = y + Math.random() * 50;

        ctx.fillStyle = "#FFF";
        ctx.shadowColor = "#FFF";
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.arc(sx, sy, 3, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;

      // Divine rays
      ctx.save();
      ctx.globalAlpha = 0.3;
      ctx.strokeStyle = "#FFD700";
      ctx.lineWidth = 2;
      for (let i = 0; i < 8; i++) {
        ctx.beginPath();
        ctx.moveTo(x + w / 2, y);
        ctx.lineTo(x + w / 2 + Math.cos(i * Math.PI / 4) * 100, y - 50);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawArena(x, y, w, h, color) {
      drawBrickTexture(x, y, w, h, color);

      // Large entrance
      ctx.fillStyle = "#1a1a1a";
      ctx.fillRect(x + w * 0.3, y + h - 60, w * 0.4, 60);

      // Columns
      ctx.fillStyle = "#9ca3af";
      for (let i = 0; i < 3; i++) {
        const cx = x + w * 0.25 + i * w * 0.25;
        ctx.fillRect(cx, y + h - 60, 10, 60);
      }

      // Arena symbol
      ctx.fillStyle = "#fbbf24";
      ctx.font = "bold 30px Arial";
      ctx.textAlign = "center";
      ctx.fillText("‚öîÔ∏è", x + w / 2, y + h / 2);

      drawRoof(x, y, w, "flat", color);
    }

    function drawShop(x, y, w, h, color) {
      drawBrickTexture(x, y, w, h, color);

      // Awning
      ctx.fillStyle = "#ff6b6b";
      ctx.fillRect(x, y + h - 80, w, 15);

      // Awning stripes
      ctx.fillStyle = "#fff";
      for (let i = 0; i < 5; i++) {
        ctx.fillRect(x + i * 30, y + h - 80, 15, 15);
      }

      // Shop windows
      drawWindow(x + 15, y + 30, 40, 45);
      drawWindow(x + w - 55, y + 30, 40, 45);

      // Display items
      ctx.fillStyle = "#FFD700";
      ctx.font = "20px Arial";
      ctx.fillText("üíé", x + 25, y + 55);
      ctx.fillText("‚öîÔ∏è", x + w - 45, y + 55);

      drawDoor(x + w / 2 - 20, y + h - 60, 40, 60, "#4a5568");
    }

    function drawTower(x, y, w, h, color) {
      // Tower base (wider)
      const baseH = h * 0.3;
      drawBrickTexture(x, y + h - baseH, w, baseH, shadeColor(color, -20));

      // Tower middle (narrower)
      const midW = w * 0.7;
      const midX = x + (w - midW) / 2;
      const midH = h * 0.5;
      drawBrickTexture(midX, y + h - baseH - midH, midW, midH, color);

      // Tower top (narrowest)
      const topW = w * 0.5;
      const topX = x + (w - topW) / 2;
      const topH = h * 0.2;
      drawBrickTexture(topX, y, topW, topH, shadeColor(color, 20));

      // Spire
      ctx.fillStyle = "#FFD700";
      ctx.beginPath();
      ctx.moveTo(topX, y);
      ctx.lineTo(topX + topW, y);
      ctx.lineTo(x + w / 2, y - 35);
      ctx.closePath();
      ctx.fill();

      // Windows at each level
      drawWindow(x + w / 2 - 10, y + h - baseH - midH + 20, 20, 30);
      drawWindow(topX + topW / 2 - 8, y + 10, 16, 20);

      drawDoor(x + w / 2 - 15, y + h - 45, 30, 45, "#2d3748");
    }

    function drawCasino(x, y, w, h, color) {
      drawBrickTexture(x, y, w, h, color);

      // Neon sign effect
      ctx.shadowColor = "#ff00ff";
      ctx.shadowBlur = 20;
      ctx.fillStyle = "#ff00ff";
      ctx.fillRect(x + 20, y + 20, w - 40, 30);
      ctx.shadowBlur = 0;

      ctx.fillStyle = "#fff";
      ctx.font = "bold 18px Arial";
      ctx.textAlign = "center";
      ctx.fillText("CASINO", x + w / 2, y + 40);

      // Colorful lights
      for (let i = 0; i < 5; i++) {
        const colors = ["#ff0000", "#00ff00", "#0000ff", "#ffff00", "#ff00ff"];
        ctx.fillStyle = colors[i];
        ctx.shadowColor = colors[i];
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.arc(x + 20 + i * 30, y + 60, 6, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;

      // Multiple windows
      for (let i = 0; i < 3; i++) {
        drawWindow(x + 30 + i * 45, y + 85, 30, 40);
      }

      drawDoor(x + w / 2 - 25, y + h - 60, 50, 60, "#8b0000");
    }

    function drawArcade(x, y, w, h, color) {
      // Colorful exterior
      const gradient = ctx.createLinearGradient(x, y, x, y + h);
      gradient.addColorStop(0, "#a855f7");
      gradient.addColorStop(0.5, "#ec4899");
      gradient.addColorStop(1, "#f59e0b");
      ctx.fillStyle = gradient;
      ctx.fillRect(x, y, w, h);

      // Retro pixels pattern
      const pixelSize = 8;
      for (let i = 0; i < 5; i++) {
        for (let j = 0; j < 3; j++) {
          const colors = ["#ff0000", "#00ff00", "#0000ff", "#ffff00"];
          ctx.fillStyle = colors[(i + j) % 4];
          ctx.fillRect(x + 20 + i * 30, y + 20 + j * 20, pixelSize, pixelSize);
        }
      }

      // ARCADE text
      ctx.fillStyle = "#fff";
      ctx.font = "bold 20px 'Courier New'";
      ctx.textAlign = "center";
      ctx.shadowColor = "#000";
      ctx.shadowBlur = 5;
      ctx.fillText("ARCADE", x + w / 2, y + h / 2);
      ctx.shadowBlur = 0;

      // Flashing lights
      const flash = Math.sin(GameState.animTime * 0.1) > 0;
      if (flash) {
        ctx.fillStyle = "#ffff00";
      } else {
        ctx.fillStyle = "#ff00ff";
      }
      for (let i = 0; i < 4; i++) {
        ctx.fillRect(x + 30 + i * 40, y + h - 30, 20, 8);
      }

      drawDoor(x + w / 2 - 20, y + h - 55, 40, 55, "#1a1a1a");
    }

    function drawBuilding(building, x, y) {
      ctx.save();

      const w = building.width;
      const h = building.height;

      // Shadow
      ctx.fillStyle = "rgba(0, 0, 0, 0.4)";
      ctx.fillRect(x + 5, y + h, w, 15);

      // Draw specific building type
      switch (building.type) {
        case "booth":
          drawPhotoBooth(x, y, w, h, building.color);
          break;
        case "arena":
          drawArena(x, y, w, h, building.color);
          break;
        case "board":
          drawQuestBoard(x, y, w, h, building.color);
          break;
        case "library":
          drawArchives(x, y, w, h, building.color);
          break;
        case "shop":
          drawShop(x, y, w, h, building.color);
          break;
        case "forge":
          drawBlacksmith(x, y, w, h, building.color);
          break;
        case "tower":
          drawTower(x, y, w, h, building.color);
          break;
        case "casino":
          drawCasino(x, y, w, h, building.color);
          break;
        case "arcade":
          drawArcade(x, y, w, h, building.color);
          break;
        case "track":
          drawRacingTrack(x, y, w, h, building.color);
          break;
        case "pier":
          drawFishingPier(x, y, w, h, building.color);
          break;
        case "farmhouse":
          drawFarmhouse(x, y, w, h, building.color);
          break;
        case "temple":
          drawTemple(x, y, w, h, building.color);
          break;
        case "gates":
          drawCelestialGates(x, y, w, h, building.color);
          break;
        default:
          // Generic building
          ctx.fillStyle = building.color;
          ctx.fillRect(x, y, w, h);
          drawWindow(x + 20, y + 30, 30, 40);
          drawDoor(x + w / 2 - 20, y + h - 50, 40, 50, "#2d3748");
          drawRoof(x, y, w, "peaked", building.color);
      }

      // Building name
      ctx.fillStyle = "#fff";
      ctx.font = "bold 14px Arial";
      ctx.textAlign = "center";
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 3;
      ctx.strokeText(building.name, x + w / 2, y - 35);
      ctx.fillText(building.name, x + w / 2, y - 35);

      ctx.restore();
    }

    function drawInteriorLayout(building) {
      ctx.save();

      // Floor
      ctx.fillStyle = "#2d1810";
      ctx.fillRect(0, 600, canvas.width, canvas.height - 600);

      // Walls
      ctx.fillStyle = "#4a3020";
      ctx.fillRect(0, 0, 50, canvas.height);
      ctx.fillRect(canvas.width - 50, 0, 50, canvas.height);

      // Title
      ctx.fillStyle = "#fff";
      ctx.font = "bold 40px Arial";
      ctx.textAlign = "center";
      ctx.shadowColor = "#000";
      ctx.shadowBlur = 10;
      ctx.fillText(building.name, canvas.width / 2, 100);
      ctx.shadowBlur = 0;

      // Interior objects based on type
      if (building.type === 'casino') {
        drawCasinoInterior();
      } else if (building.type === 'arcade') {
        drawArcadeInterior();
      } else if (building.type === 'shop') {
        drawShopInterior();
      } else if (building.type === 'tower') {
        drawTowerInterior();
      } else if (building.type === 'arena') {
        drawArenaInterior();
      } else if (building.type === 'booth') {
        drawPhotoBoothInterior();
      } else if (building.type === 'board') {
        drawQuestBoardInterior();
      } else if (building.type === 'library') {
        drawArchivesInterior();
      } else if (building.type === 'forge') {
        drawBlacksmithInterior();
      } else if (building.type === 'track') {
        drawRacingTrackInterior();
      } else if (building.type === 'pier') {
        drawFishingPierInterior();
      } else if (building.type === 'farmhouse') {
        drawFarmhouseInterior();
      } else if (building.type === 'temple') {
        drawTempleInterior();
      } else if (building.type === 'gates') {
        drawCelestialGatesInterior();
      }

      ctx.restore();
    }

    function drawCasinoInterior() {
      // Red carpet floor pattern
      ctx.fillStyle = "#8b0000";
      for (let i = 0; i < canvas.width; i += 100) {
        for (let j = 600; j < canvas.height; j += 100) {
          ctx.fillRect(i, j, 50, 50);
        }
      }

      // Chandeliers
      for (let i = 0; i < 5; i++) {
        const cx = 200 + i * 300;
        ctx.fillStyle = "#ffd700";
        ctx.beginPath();
        ctx.arc(cx, 150, 20, 0, Math.PI * 2);
        ctx.fill();

        // Light glow
        ctx.shadowColor = "#ffd700";
        ctx.shadowBlur = 40;
        ctx.fillStyle = "rgba(255, 215, 0, 0.3)";
        ctx.beginPath();
        ctx.arc(cx, 150, 40, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;
      }

      // Game tables - MUCH BIGGER
      const tables = [
        { x: 300, y: 400, label: 'ü™®üìÑ‚úÇÔ∏è', game: 'rps', name: 'Rock Paper\nScissors' },
        { x: canvas.width / 2, y: 400, label: 'üé∞', game: 'slots', name: 'Slot\nMachine' },
        { x: canvas.width - 300, y: 400, label: 'üÉè', game: 'blackjack', name: 'Blackjack\nTable' },
      ];

      for (const table of tables) {
        const isNear = GameState.nearestInteractive &&
          GameState.nearestInteractive.gameType === table.game;

        // Table shadow
        ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
        ctx.fillRect(table.x - 95, table.y - 85, 190, 190);

        // Table base
        ctx.fillStyle = isNear ? "#10b981" : "#1f2937";
        ctx.fillRect(table.x - 90, table.y - 90, 180, 180);

        // Table top (green felt)
        const feltColor = isNear ? "#059669" : "#0d4a2e";
        ctx.fillStyle = feltColor;
        ctx.fillRect(table.x - 80, table.y - 80, 160, 160);

        // Border
        ctx.strokeStyle = isNear ? "#fbbf24" : "#4b5563";
        ctx.lineWidth = 5;
        ctx.strokeRect(table.x - 90, table.y - 90, 180, 180);

        // Game icon
        ctx.fillStyle = "#fff";
        ctx.font = "bold 60px Arial";
        ctx.textAlign = "center";
        ctx.fillText(table.label, table.x, table.y + 20);

        // Table name
        ctx.font = "bold 14px Arial";
        ctx.fillStyle = "#fbbf24";
        const lines = table.name.split('\n');
        lines.forEach((line, i) => {
          ctx.fillText(line, table.x, table.y - 100 - (lines.length - 1 - i) * 18);
        });

        // Glow effect if near
        if (isNear) {
          ctx.shadowColor = "#fbbf24";
          ctx.shadowBlur = 30;
          ctx.strokeStyle = "rgba(251, 191, 36, 0.5)";
          ctx.lineWidth = 8;
          ctx.strokeRect(table.x - 95, table.y - 95, 190, 190);
          ctx.shadowBlur = 0;
        }
      }

      // Neon "CASINO" sign
      ctx.save();
      ctx.shadowColor = "#ff1493";
      ctx.shadowBlur = 20;
      ctx.fillStyle = "#ff1493";
      ctx.font = "bold 60px Arial";
      ctx.textAlign = "center";
      ctx.fillText("üé∞ GRAND CASINO üé∞", canvas.width / 2, 80);
      ctx.shadowBlur = 0;
      ctx.restore();
    }

    function drawArcadeInterior() {
      // Retro carpet pattern
      ctx.fillStyle = "#2d1a3a";
      for (let i = 0; i < canvas.width; i += 80) {
        for (let j = 600; j < canvas.height; j += 80) {
          const color = ((i + j) / 80) % 2 === 0 ? "#2d1a3a" : "#3a1d2d";
          ctx.fillStyle = color;
          ctx.fillRect(i, j, 80, 80);
        }
      }

      // Draw arcade machines
      for (const machine of GameState.interior.arcadeMachines) {
        ctx.save();

        // Machine cabinet
        ctx.fillStyle = machine.theme;
        ctx.fillRect(machine.x, machine.y, machine.w, machine.h);

        // Screen area
        ctx.fillStyle = "#0e141d";
        ctx.fillRect(machine.x + 10, machine.y + 20, machine.w - 20, machine.h * 0.5);

        // Screen glow
        ctx.shadowColor = machine.theme;
        ctx.shadowBlur = 15;
        ctx.strokeStyle = machine.theme;
        ctx.lineWidth = 3;
        ctx.strokeRect(machine.x + 10, machine.y + 20, machine.w - 20, machine.h * 0.5);
        ctx.shadowBlur = 0;

        // Screen text
        ctx.fillStyle = machine.theme;
        ctx.font = "bold 16px 'Courier New'";
        ctx.textAlign = "center";
        ctx.fillText(machine.screen, machine.x + machine.w / 2, machine.y + 60);

        // Control panel
        ctx.fillStyle = shadeColor(machine.theme, -30);
        ctx.fillRect(machine.x, machine.y + machine.h * 0.7, machine.w, machine.h * 0.3);

        // Buttons
        for (let i = 0; i < 3; i++) {
          ctx.fillStyle = ['#ef4444', '#22c55e', '#3b82f6'][i];
          ctx.beginPath();
          ctx.arc(machine.x + 20 + i * 25, machine.y + machine.h * 0.85, 8, 0, Math.PI * 2);
          ctx.fill();
        }

        // Joystick
        ctx.fillStyle = "#ff0000";
        ctx.beginPath();
        ctx.arc(machine.x + machine.w - 25, machine.y + machine.h * 0.85, 10, 0, Math.PI * 2);
        ctx.fill();

        ctx.strokeStyle = "#8b0000";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(machine.x + machine.w - 25, machine.y + machine.h * 0.85);
        ctx.lineTo(machine.x + machine.w - 25, machine.y + machine.h * 0.75);
        ctx.stroke();

        ctx.restore();
      }

      // Leaderboard
      ctx.fillStyle = "rgba(0, 0, 0, 0.9)";
      ctx.fillRect(50, 150, 250, 300);
      ctx.strokeStyle = "#ffd700";
      ctx.lineWidth = 3;
      ctx.strokeRect(50, 150, 250, 300);

      ctx.fillStyle = "#ffd700";
      ctx.font = "bold 20px Arial";
      ctx.textAlign = "center";
      ctx.fillText("HIGH SCORES", 175, 185);

      const leaderboard = [
        { name: 'MISSY', score: 99999, color: '#ff6b9d' },
        { name: 'A1K', score: 85000, color: '#6aa8ff' },
        { name: 'YOU', score: 64210, color: '#ffd54f' },
        { name: 'BOT-42', score: 51200, color: '#9c27b0' },
        { name: 'CANDY', score: 49880, color: '#4dd0e1' }
      ];

      ctx.font = "14px 'Courier New'";
      ctx.textAlign = "left";
      for (let i = 0; i < leaderboard.length; i++) {
        const entry = leaderboard[i];
        const y = 215 + i * 45;

        ctx.fillStyle = entry.color;
        ctx.fillText(`${i + 1}. ${entry.name}`, 70, y);
        ctx.fillText(entry.score.toLocaleString(), 200, y);
      }

      // Prize counter
      ctx.fillStyle = "rgba(0, 0, 0, 0.9)";
      ctx.fillRect(canvas.width - 300, 150, 250, 300);
      ctx.strokeStyle = "#ffd700";
      ctx.lineWidth = 3;
      ctx.strokeRect(canvas.width - 300, 150, 250, 300);

      ctx.fillStyle = "#ffd700";
      ctx.font = "bold 20px Arial";
      ctx.textAlign = "center";
      ctx.fillText("PRIZE SHOP", canvas.width - 175, 185);

      ctx.font = "12px Arial";
      ctx.fillStyle = "#fff";
      ctx.fillText(`Tickets: ${GameState.arcadeTickets}`, canvas.width - 175, 210);

      const prizes = [
        { name: 'Candy Comet', tickets: 50, emoji: 'üç¨' },
        { name: 'Cake Slice', tickets: 120, emoji: 'üç∞' },
        { name: 'Diamond Token', tickets: 250, emoji: 'üíé' },
        { name: 'Starlight Plush', tickets: 400, emoji: '‚≠ê' },
        { name: 'Rainbow Pass', tickets: 650, emoji: 'üåà' }
      ];

      ctx.textAlign = "left";
      ctx.font = "11px Arial";
      for (let i = 0; i < prizes.length; i++) {
        const prize = prizes[i];
        const y = 240 + i * 45;

        ctx.font = "20px Arial";
        ctx.fillText(prize.emoji, canvas.width - 285, y);

        ctx.font = "11px Arial";
        ctx.fillStyle = GameState.arcadeTickets >= prize.tickets ? '#22c55e' : '#9ca3af';
        ctx.fillText(prize.name, canvas.width - 255, y - 5);
        ctx.fillText(`${prize.tickets} tickets`, canvas.width - 255, y + 10);
      }

      // Neon signs
      ctx.save();
      const pulse = 0.7 + Math.sin(GameState.animTime * 0.1) * 0.3;

      ctx.shadowColor = "#71c7ff";
      ctx.shadowBlur = 20;
      ctx.globalAlpha = pulse;
      ctx.fillStyle = "#71c7ff";
      ctx.font = "bold 30px Arial";
      ctx.textAlign = "center";
      ctx.fillText("ARCADE", canvas.width / 2, 180);
      ctx.restore();
    }

    function drawShopInterior() {
      // Shop sign
      ctx.fillStyle = "#fbbf24";
      ctx.font = "bold 50px Arial";
      ctx.textAlign = "center";
      ctx.fillText("üõí ITEM SHOP", canvas.width / 2, 80);

      // Counter (bigger and detailed)
      ctx.fillStyle = "#8b4513";
      ctx.fillRect(canvas.width / 2 - 250, 350, 500, 40);

      // Counter top
      ctx.fillStyle = "#a0522d";
      ctx.fillRect(canvas.width / 2 - 260, 345, 520, 10);

      // Cash register
      ctx.fillStyle = "#4a5568";
      ctx.fillRect(canvas.width / 2 - 40, 315, 80, 35);
      ctx.fillStyle = "#10b981";
      ctx.fillRect(canvas.width / 2 - 30, 325, 60, 20);

      // Item shelves (left side)
      for (let i = 0; i < 3; i++) {
        const sy = 250 + i * 100;
        ctx.fillStyle = "#6b4423";
        ctx.fillRect(100, sy, 150, 15);

        // Items on shelf
        const items = ['‚öîÔ∏è', 'üõ°Ô∏è', 'üß™', 'üíé'];
        for (let j = 0; j < 4; j++) {
          ctx.fillStyle = "#fff";
          ctx.font = "bold 20px Arial";
          ctx.fillText(items[j], 120 + j * 35, sy - 5);
        }
      }

      // Item shelves (right side)
      for (let i = 0; i < 3; i++) {
        const sy = 250 + i * 100;
        ctx.fillStyle = "#6b4423";
        ctx.fillRect(canvas.width - 250, sy, 150, 15);

        // Items on shelf
        const items = ['üó°Ô∏è', 'üèπ', '‚ú®', 'üîÆ'];
        for (let j = 0; j < 4; j++) {
          ctx.fillStyle = "#fff";
          ctx.font = "bold 20px Arial";
          ctx.fillText(items[j], canvas.width - 230 + j * 35, sy - 5);
        }
      }

      // Shopkeeper
      ctx.fillStyle = "#fbbf24";
      ctx.beginPath();
      ctx.arc(canvas.width / 2, 320, 15, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#fff";
      ctx.font = "bold 12px Arial";
      ctx.textAlign = "center";
      ctx.fillText("Shopkeeper", canvas.width / 2, 300);
    }

    function drawTowerInterior() {
      // Tower title
      ctx.save();
      ctx.shadowColor = "#a855f7";
      ctx.shadowBlur = 20;
      ctx.fillStyle = "#a855f7";
      ctx.font = "bold 60px Arial";
      ctx.textAlign = "center";
      ctx.fillText("üç¨ CANDY TOWER üç¨", canvas.width / 2, 80);
      ctx.shadowBlur = 0;
      ctx.restore();

      // Floor counter (BIG)
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(canvas.width / 2 - 150, 150, 300, 80);
      ctx.strokeStyle = "#fbbf24";
      ctx.lineWidth = 4;
      ctx.strokeRect(canvas.width / 2 - 150, 150, 300, 80);

      ctx.fillStyle = "#fbbf24";
      ctx.font = "bold 50px Arial";
      ctx.textAlign = "center";
      ctx.fillText("FLOOR 1", canvas.width / 2, 200);

      // Spiral stairs (visual)
      ctx.strokeStyle = "#9ca3af";
      ctx.lineWidth = 8;
      for (let i = 0; i < 3; i++) {
        const angle = i * (Math.PI / 3);
        const sx = canvas.width / 2 + Math.cos(angle) * 120;
        const sy = 350 + i * 50;
        const ex = canvas.width / 2 + Math.cos(angle + Math.PI / 3) * 120;
        const ey = 350 + (i + 1) * 50;

        ctx.beginPath();
        ctx.moveTo(sx, sy);
        ctx.lineTo(ex, ey);
        ctx.stroke();
      }

      // Reward chests
      const chests = [
        { x: 200, y: 450 },
        { x: canvas.width - 200, y: 450 },
      ];

      for (const chest of chests) {
        ctx.fillStyle = "#8b4513";
        ctx.fillRect(chest.x - 30, chest.y - 30, 60, 50);
        ctx.fillStyle = "#ffd700";
        ctx.fillRect(chest.x - 25, chest.y - 25, 50, 10);
        ctx.fillStyle = "#fff";
        ctx.font = "bold 30px Arial";
        ctx.textAlign = "center";
        ctx.fillText("üì¶", chest.x, chest.y + 10);
      }

      // Info text
      ctx.fillStyle = "#fff";
      ctx.font = "bold 20px Arial";
      ctx.textAlign = "center";
      ctx.fillText("Climb 300 floors | C-Rank to SOVEREIGN", canvas.width / 2, 550);
    }

    function drawArenaInterior() {
      // Arena title
      ctx.save();
      ctx.shadowColor = "#ef4444";
      ctx.shadowBlur = 20;
      ctx.fillStyle = "#ef4444";
      ctx.font = "bold 60px Arial";
      ctx.textAlign = "center";
      ctx.fillText("‚öîÔ∏è BATTLE ARENA ‚öîÔ∏è", canvas.width / 2, 80);
      ctx.shadowBlur = 0;
      ctx.restore();

      // Main combat circle (BIGGER)
      ctx.strokeStyle = "#fbbf24";
      ctx.lineWidth = 8;
      ctx.beginPath();
      ctx.arc(canvas.width / 2, 400, 250, 0, Math.PI * 2);
      ctx.stroke();

      // Inner circle
      ctx.strokeStyle = "#ef4444";
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.arc(canvas.width / 2, 400, 240, 0, Math.PI * 2);
      ctx.stroke();

      // Combat markers (X pattern)
      ctx.strokeStyle = "#9ca3af";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2 - 100, 300);
      ctx.lineTo(canvas.width / 2 + 100, 500);
      ctx.moveTo(canvas.width / 2 + 100, 300);
      ctx.lineTo(canvas.width / 2 - 100, 500);
      ctx.stroke();

      // Spectator stands (left)
      ctx.fillStyle = "#2d3748";
      ctx.fillRect(50, 250, 100, 300);
      ctx.fillStyle = "#4a5568";
      for (let i = 0; i < 5; i++) {
        ctx.fillRect(60, 260 + i * 60, 80, 50);
      }

      // Spectator stands (right)
      ctx.fillStyle = "#2d3748";
      ctx.fillRect(canvas.width - 150, 250, 100, 300);
      ctx.fillStyle = "#4a5568";
      for (let i = 0; i < 5; i++) {
        ctx.fillRect(canvas.width - 140, 260 + i * 60, 80, 50);
      }

      // Arena info
      ctx.fillStyle = "#fff";
      ctx.font = "bold 18px Arial";
      ctx.textAlign = "center";
      ctx.fillText("Enter the circle to battle!", canvas.width / 2, 200);
    }

    // ============================
    // NEW BUILDING INTERIORS
    // ============================

    function drawPhotoBoothInterior() {
      // Colorful backdrop
      const gradient = ctx.createLinearGradient(300, 200, 300, 550);
      gradient.addColorStop(0, "#FF69B4");
      gradient.addColorStop(0.5, "#9A6BFF");
      gradient.addColorStop(1, "#4169E1");
      ctx.fillStyle = gradient;
      ctx.fillRect(300, 200, 600, 350);

      // Camera setup
      ctx.fillStyle = "#000";
      ctx.fillRect(canvas.width / 2 - 50, 380, 100, 80);

      ctx.beginPath();
      ctx.arc(canvas.width / 2, 420, 40, 0, Math.PI * 2);
      ctx.fill();

      // Lens
      ctx.fillStyle = "#4169E1";
      ctx.beginPath();
      ctx.arc(canvas.width / 2, 420, 30, 0, Math.PI * 2);
      ctx.fill();

      // Flash bulbs around
      for (let i = 0; i < 6; i++) {
        ctx.fillStyle = "#FFD700";
        ctx.shadowColor = "#FFD700";
        ctx.shadowBlur = 20;
        ctx.beginPath();
        const angle = (i / 6) * Math.PI * 2;
        const x = canvas.width / 2 + Math.cos(angle) * 250;
        const y = 375 + Math.sin(angle) * 200;
        ctx.arc(x, y, 15, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;

      // Instructions
      ctx.fillStyle = "#fff";
      ctx.font = "bold 24px Arial";
      ctx.textAlign = "center";
      ctx.fillText("üì∏ Step into frame and press E to take photo!", canvas.width / 2, 180);

      // Frame outline
      ctx.strokeStyle = "#FFD700";
      ctx.lineWidth = 5;
      ctx.strokeRect(300, 200, 600, 350);
    }

    function drawQuestBoardInterior() {
      // Giant wooden board
      ctx.fillStyle = "#8B4513";
      ctx.fillRect(200, 150, canvas.width - 400, 400);

      // Wood grain
      for (let i = 0; i < 20; i++) {
        ctx.strokeStyle = "rgba(0, 0, 0, 0.2)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(200, 150 + i * 20);
        ctx.lineTo(canvas.width - 200, 160 + i * 20);
        ctx.stroke();
      }

      // Quest scrolls (3 columns)
      const quests = [
        { title: "üêâ Slay Dragon", reward: "10,000 XP", difficulty: "LEGENDARY" },
        { title: "‚öîÔ∏è Clear Dungeon", reward: "5,000 XP", difficulty: "HARD" },
        { title: "üåæ Harvest Crops", reward: "500 XP", difficulty: "EASY" },
        { title: "üé£ Catch 10 Fish", reward: "1,000 XP", difficulty: "MEDIUM" },
        { title: "üèÜ Win Race", reward: "2,000 XP", difficulty: "MEDIUM" },
        { title: "üíé Mine Gems", reward: "3,000 XP", difficulty: "HARD" },
      ];

      for (let i = 0; i < 6; i++) {
        const col = i % 3;
        const row = Math.floor(i / 3);
        const x = 250 + col * 350;
        const y = 200 + row * 180;

        // Scroll background
        ctx.fillStyle = "#FFF8DC";
        ctx.fillRect(x, y, 300, 140);
        ctx.strokeStyle = "#D2691E";
        ctx.lineWidth = 3;
        ctx.strokeRect(x, y, 300, 140);

        // Pin
        ctx.fillStyle = "#DC143C";
        ctx.beginPath();
        ctx.arc(x + 150, y + 10, 6, 0, Math.PI * 2);
        ctx.fill();

        // Quest details
        ctx.fillStyle = "#000";
        ctx.font = "bold 20px Arial";
        ctx.textAlign = "center";
        ctx.fillText(quests[i].title, x + 150, y + 50);

        ctx.font = "16px Arial";
        ctx.fillStyle = "#228B22";
        ctx.fillText(quests[i].reward, x + 150, y + 80);

        ctx.font = "bold 14px Arial";
        const diffColor = { EASY: "#22c55e", MEDIUM: "#eab308", HARD: "#ef4444", LEGENDARY: "#a855f7" };
        ctx.fillStyle = diffColor[quests[i].difficulty];
        ctx.fillText(quests[i].difficulty, x + 150, y + 110);
      }

      // Title
      ctx.fillStyle = "#FFD700";
      ctx.font = "bold 28px Arial";
      ctx.textAlign = "center";
      ctx.fillText("üìã QUEST BOARD - Press E near quest to accept", canvas.width / 2, 130);
    }

    function drawArchivesInterior() {
      // Bookshelves on both sides
      for (let side = 0; side < 2; side++) {
        const x = side === 0 ? 100 : canvas.width - 300;

        // Shelf structure
        ctx.fillStyle = "#8B4513";
        ctx.fillRect(x, 150, 200, 400);

        // Shelves (5 levels)
        for (let shelf = 0; shelf < 5; shelf++) {
          const y = 150 + shelf * 80;

          ctx.fillStyle = "#654321";
          ctx.fillRect(x, y, 200, 8);

          // Books on each shelf
          for (let book = 0; book < 8; book++) {
            const bx = x + 10 + book * 23;
            const bookColors = ["#8B0000", "#1E90FF", "#228B22", "#FFD700", "#9370DB"];
            ctx.fillStyle = bookColors[(shelf + book) % 5];
            ctx.fillRect(bx, y + 12, 18, 60);

            // Book spine detail
            ctx.strokeStyle = shadeColor(bookColors[(shelf + book) % 5], -30);
            ctx.lineWidth = 1;
            ctx.strokeRect(bx, y + 12, 18, 60);
          }
        }
      }

      // Reading area in center
      ctx.fillStyle = "#8B4513";
      ctx.fillRect(canvas.width / 2 - 100, 400, 200, 120);

      // Open book
      ctx.fillStyle = "#FFF8DC";
      ctx.fillRect(canvas.width / 2 - 80, 380, 160, 100);

      ctx.strokeStyle = "#8B4513";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2, 380);
      ctx.lineTo(canvas.width / 2, 480);
      ctx.stroke();

      // Book pages
      ctx.fillStyle = "#000";
      ctx.font = "12px Arial";
      ctx.textAlign = "left";
      const lines = ["Long ago, in the age", "of heroes, there was", "a great battle...", "", "The legends speak of", "ancient powers..."];
      for (let i = 0; i < lines.length; i++) {
        ctx.fillText(lines[i], canvas.width / 2 - 70, 400 + i * 15);
      }

      // Lamp
      ctx.fillStyle = "#FFD700";
      ctx.shadowColor = "#FFD700";
      ctx.shadowBlur = 30;
      ctx.beginPath();
      ctx.arc(canvas.width / 2, 250, 20, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;

      // Instructions
      ctx.fillStyle = "#fff";
      ctx.font = "bold 20px Arial";
      ctx.textAlign = "center";
      ctx.fillText("üìö Archives - Read lore and game history", canvas.width / 2, 130);
    }

    function drawBlacksmithInterior() {
      // Forge (left side)
      ctx.fillStyle = "#4a3020";
      ctx.fillRect(150, 300, 200, 180);

      // Fire
      ctx.shadowColor = "#ff6600";
      ctx.shadowBlur = 50;
      ctx.fillStyle = "#ff6600";
      ctx.fillRect(180, 330, 140, 100);

      ctx.fillStyle = "#ff3300";
      ctx.fillRect(200, 350, 100, 60);

      ctx.fillStyle = "#ffff00";
      ctx.fillRect(220, 370, 60, 30);
      ctx.shadowBlur = 0;

      // Flames
      for (let i = 0; i < 5; i++) {
        ctx.fillStyle = `rgba(255, ${100 + i * 30}, 0, ${0.8 - i * 0.15})`;
        ctx.beginPath();
        ctx.moveTo(200 + i * 25, 330);
        ctx.lineTo(210 + i * 25, 300 - Math.random() * 30);
        ctx.lineTo(220 + i * 25, 330);
        ctx.fill();
      }

      // Anvil (center)
      ctx.fillStyle = "#2d3748";
      ctx.fillRect(canvas.width / 2 - 60, 400, 120, 40);
      ctx.fillRect(canvas.width / 2 - 40, 380, 80, 20);
      ctx.fillRect(canvas.width / 2 - 20, 360, 40, 20);

      // Hammer on anvil
      ctx.fillStyle = "#4a5568";
      ctx.fillRect(canvas.width / 2 + 20, 370, 30, 15);

      ctx.strokeStyle = "#8B4513";
      ctx.lineWidth = 8;
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2 + 50, 377);
      ctx.lineTo(canvas.width / 2 + 100, 377);
      ctx.stroke();

      // Weapon rack (right side)
      ctx.fillStyle = "#8B4513";
      ctx.fillRect(canvas.width - 300, 200, 150, 250);

      // Weapons
      const weapons = ["‚öîÔ∏è", "üó°Ô∏è", "üî®", "ü™ì", "üèπ"];
      for (let i = 0; i < 5; i++) {
        ctx.fillStyle = "#FFD700";
        ctx.font = "40px Arial";
        ctx.textAlign = "center";
        ctx.fillText(weapons[i], canvas.width - 225, 250 + i * 50);
      }

      // Workbench
      ctx.fillStyle = "#8B4513";
      ctx.fillRect(400, 450, 300, 80);

      // Tools on bench
      ctx.fillStyle = "#4a5568";
      ctx.fillRect(420, 470, 15, 40);
      ctx.fillRect(460, 470, 15, 40);
      ctx.fillRect(500, 470, 15, 40);

      // Instructions
      ctx.fillStyle = "#fff";
      ctx.font = "bold 22px Arial";
      ctx.textAlign = "center";
      ctx.fillText("üî® Blacksmith - Upgrade weapons (+10 ATK for 1000 gold)", canvas.width / 2, 150);
    }

    function drawRacingTrackInterior() {
      // Track (oval)
      ctx.strokeStyle = "#4a5568";
      ctx.lineWidth = 60;
      ctx.beginPath();
      ctx.ellipse(canvas.width / 2, 350, 400, 200, 0, 0, Math.PI * 2);
      ctx.stroke();

      // Inner grass
      ctx.fillStyle = "#22c55e";
      ctx.beginPath();
      ctx.ellipse(canvas.width / 2, 350, 350, 150, 0, 0, Math.PI * 2);
      ctx.fill();

      // Starting line (checkered)
      const checkSize = 20;
      for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 2; j++) {
          ctx.fillStyle = (i + j) % 2 === 0 ? "#000" : "#fff";
          ctx.fillRect(canvas.width / 2 - 30 + j * checkSize, 250 + i * checkSize, checkSize, checkSize);
        }
      }

      // Finish line text
      ctx.fillStyle = "#fff";
      ctx.font = "bold 30px Arial";
      ctx.textAlign = "center";
      ctx.shadowColor = "#000";
      ctx.shadowBlur = 5;
      ctx.fillText("üèÅ START/FINISH", canvas.width / 2, 240);
      ctx.shadowBlur = 0;

      // Lap counter
      ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
      ctx.fillRect(canvas.width / 2 - 150, 330, 300, 60);
      ctx.strokeStyle = "#fbbf24";
      ctx.lineWidth = 3;
      ctx.strokeRect(canvas.width / 2 - 150, 330, 300, 60);

      ctx.fillStyle = "#fff";
      ctx.font = "bold 24px Arial";
      ctx.textAlign = "center";
      ctx.fillText("üèéÔ∏è Press E to start 3-lap race!", canvas.width / 2, 365);

      // Spectator stands
      for (let i = 0; i < 2; i++) {
        const x = i === 0 ? 50 : canvas.width - 150;
        ctx.fillStyle = "#2d3748";
        ctx.fillRect(x, 250, 100, 200);

        // Crowd (simple dots)
        for (let row = 0; row < 4; row++) {
          for (let col = 0; col < 5; col++) {
            ctx.fillStyle = ["#ff0000", "#0000ff", "#ffff00", "#00ff00"][Math.floor(Math.random() * 4)];
            ctx.beginPath();
            ctx.arc(x + 20 + col * 15, 270 + row * 45, 6, 0, Math.PI * 2);
            ctx.fill();
          }
        }
      }

      // Track markers
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const x = canvas.width / 2 + Math.cos(angle) * 350;
        const y = 350 + Math.sin(angle) * 180;

        ctx.fillStyle = "#fbbf24";
        ctx.fillRect(x - 5, y - 15, 10, 30);
      }
    }

    function drawFishingPierInterior() {
      // Water
      const waterGradient = ctx.createLinearGradient(0, 200, 0, 600);
      waterGradient.addColorStop(0, "#1e3a5f");
      waterGradient.addColorStop(1, "#0a1e3f");
      ctx.fillStyle = waterGradient;
      ctx.fillRect(0, 200, canvas.width, 400);

      // Waves
      for (let i = 0; i < 10; i++) {
        ctx.strokeStyle = `rgba(70, 130, 180, ${0.3 + Math.sin(GameState.animTime * 0.01 + i) * 0.2})`;
        ctx.lineWidth = 3;
        ctx.beginPath();
        const y = 250 + i * 35;
        ctx.moveTo(0, y);
        for (let x = 0; x < canvas.width; x += 50) {
          ctx.quadraticCurveTo(x + 25, y + Math.sin((x + GameState.animTime) * 0.02) * 10, x + 50, y);
        }
        ctx.stroke();
      }

      // Wooden dock planks
      ctx.fillStyle = "#8B7355";
      for (let i = 0; i < 15; i++) {
        ctx.fillRect(i * 90, 550, 80, 50);
        ctx.strokeStyle = "#654321";
        ctx.lineWidth = 2;
        ctx.strokeRect(i * 90, 550, 80, 50);
      }

      // Fishing rod
      ctx.strokeStyle = "#8B4513";
      ctx.lineWidth = 6;
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2, 600);
      ctx.lineTo(canvas.width / 2 - 50, 250);
      ctx.stroke();

      // Fishing line
      ctx.strokeStyle = "#666";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(canvas.width / 2 - 50, 250);
      const bobberY = 350 + Math.sin(GameState.animTime * 0.05) * 10;
      ctx.lineTo(canvas.width / 2, bobberY);
      ctx.stroke();

      // Bobber
      ctx.fillStyle = "#ff0000";
      ctx.beginPath();
      ctx.arc(canvas.width / 2, bobberY, 8, 0, Math.PI * 2);
      ctx.fill();

      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.stroke();

      // Fish swimming
      for (let i = 0; i < 5; i++) {
        const fishX = (GameState.animTime * 2 + i * 200) % canvas.width;
        const fishY = 300 + i * 50;
        const fishSize = 20 + i * 5;

        ctx.fillStyle = `rgba(255, 165, 0, ${0.6 + Math.sin(GameState.animTime * 0.1 + i) * 0.2})`;
        ctx.beginPath();
        ctx.ellipse(fishX, fishY, fishSize, fishSize * 0.6, 0, 0, Math.PI * 2);
        ctx.fill();

        // Fish tail
        ctx.beginPath();
        ctx.moveTo(fishX - fishSize, fishY);
        ctx.lineTo(fishX - fishSize * 1.5, fishY - 10);
        ctx.lineTo(fishX - fishSize * 1.5, fishY + 10);
        ctx.fill();
      }

      // Instructions
      ctx.fillStyle = "#fff";
      ctx.font = "bold 24px Arial";
      ctx.textAlign = "center";
      ctx.shadowColor = "#000";
      ctx.shadowBlur = 10;
      ctx.fillText("üé£ Press E when fish bites to catch!", canvas.width / 2, 180);

      ctx.font = "18px Arial";
      ctx.fillText("Catch: Common, Rare, Legendary fish!", canvas.width / 2, 210);
      ctx.shadowBlur = 0;
    }

    function drawFarmhouseInterior() {
      // Barn interior walls
      ctx.fillStyle = "#8B4513";
      ctx.fillRect(0, 100, canvas.width, 50);

      // Hay bales (background)
      for (let i = 0; i < 5; i++) {
        const x = 100 + i * 200;
        ctx.fillStyle = "#DAA520";
        ctx.fillRect(x, 180, 80, 80);

        // Hay texture
        for (let j = 0; j < 10; j++) {
          ctx.strokeStyle = "#B8860B";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x + Math.random() * 80, 180 + j * 8);
          ctx.lineTo(x + Math.random() * 80, 180 + j * 8 + 5);
          ctx.stroke();
        }
      }

      // Farm plots (6 plots in 2 rows)
      for (let row = 0; row < 2; row++) {
        for (let col = 0; col < 3; col++) {
          const x = 200 + col * 250;
          const y = 350 + row * 130;

          // Soil
          ctx.fillStyle = "#654321";
          ctx.fillRect(x, y, 200, 100);

          ctx.strokeStyle = "#4a3020";
          ctx.lineWidth = 3;
          ctx.strokeRect(x, y, 200, 100);

          // Crop state (simulated)
          const plotNum = row * 3 + col;
          if (plotNum < 3) {
            // Has crops
            const cropEmojis = ["üåæ", "üåΩ", "ü•ï"];
            ctx.font = "40px Arial";
            ctx.fillText(cropEmojis[plotNum], x + 100, y + 65);

            // Ready to harvest
            ctx.fillStyle = "#22c55e";
            ctx.font = "bold 14px Arial";
            ctx.textAlign = "center";
            ctx.fillText("READY!", x + 100, y - 5);
          } else {
            // Empty plot
            ctx.fillStyle = "#fff";
            ctx.font = "16px Arial";
            ctx.textAlign = "center";
            ctx.fillText("Empty Plot", x + 100, y + 55);
          }
        }
      }

      // Farming tools
      ctx.fillStyle = "#8B4513";
      ctx.fillRect(50, 350, 100, 200);

      const tools = ["ü™ì", "üî®", "ü™ö"];
      for (let i = 0; i < tools.length; i++) {
        ctx.font = "35px Arial";
        ctx.fillText(tools[i], 100, 400 + i * 60);
      }

      // Wheelbarrow
      ctx.fillStyle = "#4a5568";
      ctx.fillRect(canvas.width - 150, 450, 100, 60);

      ctx.beginPath();
      ctx.arc(canvas.width - 100, 510, 20, 0, Math.PI * 2);
      ctx.fill();

      // Instructions
      ctx.fillStyle = "#fff";
      ctx.font = "bold 22px Arial";
      ctx.textAlign = "center";
      ctx.fillText("üåæ Farm - Plant crops and harvest for rewards!", canvas.width / 2, 170);

      ctx.font = "16px Arial";
      ctx.fillText("Press E near plot to plant or harvest", canvas.width / 2, 200);
    }

    function drawTempleInterior() {
      // Divine background glow
      const glowGradient = ctx.createRadialGradient(canvas.width / 2, 300, 50, canvas.width / 2, 300, 400);
      glowGradient.addColorStop(0, "rgba(255, 215, 0, 0.3)");
      glowGradient.addColorStop(1, "rgba(255, 215, 0, 0)");
      ctx.fillStyle = glowGradient;
      ctx.fillRect(0, 150, canvas.width, 450);

      // Altar (center)
      ctx.fillStyle = "#E6E6FA";
      ctx.fillRect(canvas.width / 2 - 150, 350, 300, 150);

      // Altar top
      ctx.fillStyle = "#DAA520";
      ctx.fillRect(canvas.width / 2 - 160, 340, 320, 20);

      // Sacred flame
      ctx.save();
      ctx.shadowColor = "#FFD700";
      ctx.shadowBlur = 50;
      for (let i = 0; i < 3; i++) {
        const flameY = 320 - i * 30;
        const flameSize = 30 - i * 8;
        ctx.fillStyle = i === 0 ? "#ff3300" : i === 1 ? "#ff6600" : "#ffff00";
        ctx.beginPath();
        ctx.moveTo(canvas.width / 2 - flameSize, 340);
        ctx.lineTo(canvas.width / 2, flameY);
        ctx.lineTo(canvas.width / 2 + flameSize, 340);
        ctx.fill();
      }
      ctx.restore();

      // Pillars (4 pillars)
      for (let i = 0; i < 4; i++) {
        const x = i < 2 ? 200 : canvas.width - 250;
        const y = i % 2 === 0 ? 200 : 350;

        ctx.fillStyle = "#E6E6FA";
        ctx.fillRect(x, y, 50, 200);

        // Pillar capital
        ctx.fillStyle = "#DAA520";
        ctx.fillRect(x - 10, y, 70, 15);
        ctx.fillRect(x - 10, y + 185, 70, 15);

        // Fluting
        for (let j = 0; j < 5; j++) {
          ctx.strokeStyle = "rgba(0, 0, 0, 0.1)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(x + j * 10, y + 15);
          ctx.lineTo(x + j * 10, y + 185);
          ctx.stroke();
        }
      }

      // Blessing options
      const blessings = [
        { name: "XP Blessing", icon: "‚≠ê", color: "#3b82f6" },
        { name: "Gold Blessing", icon: "üí∞", color: "#eab308" },
        { name: "Luck Blessing", icon: "üçÄ", color: "#22c55e" }
      ];

      for (let i = 0; i < 3; i++) {
        const x = 250 + i * 350;
        const y = 480;

        // Blessing orb
        ctx.fillStyle = blessings[i].color;
        ctx.shadowColor = blessings[i].color;
        ctx.shadowBlur = 30;
        ctx.beginPath();
        ctx.arc(x, y, 40, 0, Math.PI * 2);
        ctx.fill();
        ctx.shadowBlur = 0;

        // Icon
        ctx.font = "40px Arial";
        ctx.textAlign = "center";
        ctx.fillText(blessings[i].icon, x, y + 15);

        // Label
        ctx.fillStyle = "#fff";
        ctx.font = "bold 16px Arial";
        ctx.fillText(blessings[i].name, x, y + 65);
      }

      // Instructions
      ctx.fillStyle = "#fff";
      ctx.font = "bold 24px Arial";
      ctx.textAlign = "center";
      ctx.shadowColor = "#000";
      ctx.shadowBlur = 10;
      ctx.fillText("‚õ™ Divine Temple - Receive divine blessings", canvas.width / 2, 170);

      ctx.font = "18px Arial";
      ctx.fillText("Press E near blessing orb to activate (+25% boost for 10 min)", canvas.width / 2, 200);
      ctx.shadowBlur = 0;

      // Divine particles
      for (let i = 0; i < 20; i++) {
        const x = 200 + Math.random() * (canvas.width - 400);
        const y = 150 + Math.random() * 400;
        const size = 2 + Math.random() * 4;

        ctx.fillStyle = `rgba(255, 215, 0, ${0.3 + Math.random() * 0.4})`;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawCelestialGatesInterior() {
      // Epic background
      const skyGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
      skyGradient.addColorStop(0, "#1a0033");
      skyGradient.addColorStop(0.5, "#330066");
      skyGradient.addColorStop(1, "#000033");
      ctx.fillStyle = skyGradient;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // Stars
      for (let i = 0; i < 100; i++) {
        const x = (i * 137) % canvas.width;
        const y = (i * 219) % 600;
        const size = 1 + (i % 3);

        ctx.fillStyle = "#fff";
        ctx.shadowColor = "#fff";
        ctx.shadowBlur = size * 3;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;

      // Massive celestial gates
      const gateGradient = ctx.createLinearGradient(canvas.width / 2 - 300, 200, canvas.width / 2 + 300, 500);
      gateGradient.addColorStop(0, "#FFD700");
      gateGradient.addColorStop(0.5, "#FFF8DC");
      gateGradient.addColorStop(1, "#FFD700");
      ctx.fillStyle = gateGradient;

      // Left door
      ctx.fillRect(canvas.width / 2 - 250, 200, 200, 350);
      ctx.strokeStyle = "#DAA520";
      ctx.lineWidth = 8;
      ctx.strokeRect(canvas.width / 2 - 250, 200, 200, 350);

      // Right door
      ctx.fillRect(canvas.width / 2 + 50, 200, 200, 350);
      ctx.strokeRect(canvas.width / 2 + 50, 200, 200, 350);

      // Ornate patterns
      for (let door = 0; door < 2; door++) {
        const doorX = door === 0 ? canvas.width / 2 - 150 : canvas.width / 2 + 150;

        for (let i = 0; i < 5; i++) {
          ctx.fillStyle = "#FF6347";
          ctx.shadowColor = "#FF6347";
          ctx.shadowBlur = 15;
          ctx.beginPath();
          ctx.arc(doorX, 250 + i * 70, 12, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      ctx.shadowBlur = 0;

      // Divine rays from gates
      ctx.save();
      ctx.globalAlpha = 0.4;
      for (let i = 0; i < 12; i++) {
        const angle = (i / 12) * Math.PI * 2;
        ctx.strokeStyle = "#FFD700";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(canvas.width / 2, 375);
        ctx.lineTo(
          canvas.width / 2 + Math.cos(angle) * 400,
          375 + Math.sin(angle) * 300
        );
        ctx.stroke();
      }
      ctx.restore();

      // Portal/challenge entrance
      ctx.save();
      ctx.shadowColor = "#a855f7";
      ctx.shadowBlur = 60;
      const portalGradient = ctx.createRadialGradient(canvas.width / 2, 375, 50, canvas.width / 2, 375, 150);
      portalGradient.addColorStop(0, "#a855f7");
      portalGradient.addColorStop(0.5, "#7c3aed");
      portalGradient.addColorStop(1, "rgba(124, 58, 237, 0)");
      ctx.fillStyle = portalGradient;
      ctx.beginPath();
      ctx.arc(canvas.width / 2, 375, 120, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      // Swirling portal effect
      ctx.save();
      ctx.translate(canvas.width / 2, 375);
      ctx.rotate(GameState.animTime * 0.02);
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        ctx.strokeStyle = `rgba(168, 85, 247, ${0.6 - i * 0.05})`;
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.arc(0, 0, 80 - i * 10, angle, angle + Math.PI / 4);
        ctx.stroke();
      }
      ctx.restore();

      // Challenge text
      ctx.fillStyle = "#fff";
      ctx.font = "bold 32px Arial";
      ctx.textAlign = "center";
      ctx.shadowColor = "#a855f7";
      ctx.shadowBlur = 20;
      ctx.fillText("üåü CELESTIAL GATES üåü", canvas.width / 2, 150);

      ctx.font = "bold 22px Arial";
      ctx.fillText("Press E to enter the Ultimate Challenge", canvas.width / 2, 190);

      ctx.font = "18px Arial";
      ctx.fillStyle = "#fbbf24";
      ctx.fillText("‚ö†Ô∏è Warning: Only the strongest heroes may pass ‚ö†Ô∏è", canvas.width / 2, 220);
      ctx.shadowBlur = 0;

      // Floating runes
      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2 + GameState.animTime * 0.01;
        const x = canvas.width / 2 + Math.cos(angle) * 300;
        const y = 375 + Math.sin(angle) * 200;

        ctx.fillStyle = "#FFD700";
        ctx.shadowColor = "#FFD700";
        ctx.shadowBlur = 20;
        ctx.font = "30px Arial";
        ctx.textAlign = "center";
        const runes = ["‚òÄÔ∏è", "üåô", "‚≠ê", "‚ú®", "üí´", "üîÆ", "üåü", "‚ö°"];
        ctx.fillText(runes[i], x, y);
      }
      ctx.shadowBlur = 0;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ADVANCED SPRITE RENDERING SYSTEM - PHASE 1
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    const SpriteSystem = {
      // Animation definitions for each character
      animations: {
        idle: { frames: 8, frameTime: 250, loop: true },
        walk: { frames: 8, frameTime: 125, loop: true },
        run: { frames: 8, frameTime: 83, loop: true },
        attack: { frames: 6, frameTime: 83, loop: false },
        jump: { frames: 4, frameTime: 100, loop: false },
        hurt: { frames: 3, frameTime: 150, loop: false },
        death: { frames: 6, frameTime: 200, loop: false }
      },
      
      // Color palettes for skins/elements
      palettes: {
        fire: {
          skin: ['#4a3428', '#5c4033', '#6d4c3d'],
          clothes: ['#1a1a1a', '#2a2a2a', '#3a3a3a', '#4a4a4a'],
          weapon: ['#ff0000', '#ff3333', '#ff6666', '#ff9999'],
          eyes: ['#ff0000', '#ff4444'],
          aura: 'rgba(255,80,0,',
          glow: '#ff5500'
        },
        ice: {
          skin: ['#4a3428', '#5c4033', '#6d4c3d'],
          clothes: ['#0a1a2a', '#1a2a3a', '#2a3a4a', '#3a4a5a'],
          weapon: ['#00ffff', '#33ffff', '#66ffff', '#99ffff'],
          eyes: ['#00ffff', '#44ffff'],
          aura: 'rgba(0,200,255,',
          glow: '#00ccff'
        },
        shadow: {
          skin: ['#4a3428', '#5c4033', '#6d4c3d'],
          clothes: ['#1a0a2a', '#2a1a3a', '#3a2a4a', '#4a3a5a'],
          weapon: ['#aa00ff', '#cc33ff', '#dd66ff', '#ee99ff'],
          eyes: ['#aa00ff', '#cc44ff'],
          aura: 'rgba(150,0,255,',
          glow: '#9900ff'
        },
        light: {
          skin: ['#4a3428', '#5c4033', '#6d4c3d'],
          clothes: ['#2a2a1a', '#3a3a2a', '#4a4a3a', '#5a5a4a'],
          weapon: ['#ffff00', '#ffff33', '#ffff66', '#ffff99'],
          eyes: ['#ffff00', '#ffff44'],
          aura: 'rgba(255,220,0,',
          glow: '#ffdd00'
        },
        nature: {
          skin: ['#4a3428', '#5c4033', '#6d4c3d'],
          clothes: ['#0a2a1a', '#1a3a2a', '#2a4a3a', '#3a5a4a'],
          weapon: ['#00ff00', '#33ff33', '#66ff66', '#99ff99'],
          eyes: ['#00ff00', '#44ff44'],
          aura: 'rgba(0,255,100,',
          glow: '#00ff66'
        },
        angel: {
          skin: ['#2a1a2a', '#1a0a1a', '#0a0a0a'],
          clothes: ['#000000', '#1a1a1a', '#2a2a2a'],
          weapon: ['#ffd700', '#ffef00', '#fff700'],
          eyes: ['#00ff00', '#44ff44'],
          aura: 'rgba(100,0,150,',
          glow: '#6600aa'
        },
        cyber: {
          skin: ['#4a3428', '#5c4033', '#6d4c3d'],
          clothes: ['#0a2a3a', '#1a3a4a', '#2a4a5a'],
          weapon: ['#00ffff', '#33ffff', '#66ffff'],
          eyes: ['#ff00ff', '#ff44ff'],
          aura: 'rgba(0,255,255,',
          glow: '#00ffff'
        }
      },
      
      // Get palette based on equipped skin
      getPalette: function(char) {
        const skinName = GameState.equippedSkins[char.name] || 'default';
        
        // Map skins to palettes
        const skinToPalette = {
          'Fire Demon': 'fire',
          'Ice Crystal': 'ice',
          'Shadow Assassin': 'shadow',
          'Light Warrior': 'light',
          'Forest Guardian': 'nature',
          'Angel': 'angel',
          'Cyber Ninja': 'cyber',
          'default': char.id === 'a1' ? 'fire' : char.id === 'missy' ? 'angel' : 'cyber'
        };
        
        return this.palettes[skinToPalette[skinName] || 'fire'];
      },
      
      // Draw pixel helper
      drawPixel: function(x, y, color) {
        ctx.fillStyle = color;
        ctx.fillRect(x, y, 1, 1);
      },
      
      // Draw rectangle helper
      drawRect: function(x, y, w, h, color) {
        ctx.fillStyle = color;
        ctx.fillRect(x, y, w, h);
      },
      
      // Draw A1 sprite with dual swords
      drawA1: function(centerX, centerY, frame, animState, palette) {
        let bobY = 0;
        let armAngle = 0;
        let legOffset = 0;
        
        if (animState === 'idle') {
          bobY = Math.sin(frame / 4 * Math.PI) * 1;
        } else if (animState === 'walk') {
          bobY = Math.sin(frame / 4 * Math.PI) * 2;
          legOffset = Math.sin(frame / 4 * Math.PI) * 3;
        } else if (animState === 'attack') {
          armAngle = (frame / 6) * 90;
        }
        
        // Background glow
        const gradient = ctx.createRadialGradient(centerX, centerY - bobY, 0, centerX, centerY - bobY, 25);
        gradient.addColorStop(0, palette.aura + '0.15)');
        gradient.addColorStop(0.5, palette.aura + '0.05)');
        gradient.addColorStop(1, palette.aura + '0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(centerX - 30, centerY - 40 - bobY, 60, 80);
        
        // Legs
        this.drawRect(centerX - 10, centerY + 20 - bobY + legOffset, 6, 16, palette.clothes[2]);
        this.drawRect(centerX - 10, centerY + 36 - bobY + legOffset, 6, 8, palette.skin[1]);
        this.drawRect(centerX + 4, centerY + 20 - bobY - legOffset, 6, 16, palette.clothes[2]);
        this.drawRect(centerX + 4, centerY + 36 - bobY - legOffset, 6, 8, palette.skin[1]);
        
        // Torso
        this.drawRect(centerX - 12, centerY + 4 - bobY, 24, 20, palette.clothes[1]);
        this.drawRect(centerX - 10, centerY + 6 - bobY, 20, 16, palette.clothes[2]);
        
        // Arms
        if (animState === 'walk') {
          this.drawRect(centerX - 16, centerY + 8 - bobY - legOffset, 5, 14, palette.skin[1]);
        } else {
          this.drawRect(centerX - 16, centerY + 8 - bobY, 5, 14, palette.skin[1]);
        }
        this.drawRect(centerX + 12, centerY + 8 - bobY + Math.sin(armAngle * Math.PI / 180) * 5, 5, 14, palette.skin[1]);
        
        // Head
        this.drawRect(centerX - 10, centerY - 16 - bobY, 20, 18, palette.skin[2]);
        this.drawRect(centerX - 6, centerY + 2 - bobY, 12, 4, palette.skin[1]);
        
        // Black baseball cap
        this.drawRect(centerX - 12, centerY - 20 - bobY, 24, 6, '#000000');
        this.drawRect(centerX - 14, centerY - 18 - bobY, 8, 3, '#000000');
        
        // Black curly hair (under cap)
        this.drawPixel(centerX - 11, centerY - 14 - bobY, '#000000');
        this.drawPixel(centerX - 10, centerY - 15 - bobY, '#000000');
        this.drawPixel(centerX - 12, centerY - 13 - bobY, '#000000');
        this.drawPixel(centerX - 9, centerY - 14 - bobY, '#111111');
        this.drawPixel(centerX + 11, centerY - 14 - bobY, '#000000');
        this.drawPixel(centerX + 10, centerY - 15 - bobY, '#000000');
        this.drawPixel(centerX + 12, centerY - 13 - bobY, '#000000');
        
        // Glowing RED eyes
        this.drawPixel(centerX - 6, centerY - 8 - bobY, '#ff0000');
        this.drawPixel(centerX - 5, centerY - 8 - bobY, '#ff3333');
        this.drawPixel(centerX + 5, centerY - 8 - bobY, '#ff0000');
        this.drawPixel(centerX + 6, centerY - 8 - bobY, '#ff3333');
        
        // Left sword (in LEFT hand)
        ctx.save();
        ctx.translate(centerX - 20, centerY + 10 - bobY);
        ctx.rotate((-45 + armAngle) * Math.PI / 180);
        this.drawRect(-2, -20, 4, 24, palette.weapon[0]);
        this.drawRect(-1, -20, 2, 24, palette.weapon[2]);
        this.drawPixel(1, -18, palette.weapon[3]);
        this.drawPixel(1, -10, palette.weapon[3]);
        this.drawPixel(1, -2, palette.weapon[3]);
        this.drawRect(-2, 4, 4, 6, palette.clothes[0]);
        ctx.restore();
        
        // Right sword (in RIGHT hand)
        ctx.save();
        ctx.translate(centerX + 20, centerY + 10 - bobY);
        ctx.rotate((45 - armAngle) * Math.PI / 180);
        this.drawRect(-2, -20, 4, 24, palette.weapon[0]);
        this.drawRect(-1, -20, 2, 24, palette.weapon[2]);
        this.drawPixel(-2, -18, palette.weapon[3]);
        this.drawPixel(-2, -10, palette.weapon[3]);
        this.drawPixel(-2, -2, palette.weapon[3]);
        this.drawRect(-2, 4, 4, 6, palette.clothes[0]);
        ctx.restore();
        
        // Weapon glow aura
        ctx.fillStyle = palette.weapon[0];
        ctx.globalAlpha = 0.3;
        ctx.beginPath();
        ctx.arc(centerX - 20, centerY - 5 - bobY, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.beginPath();
        ctx.arc(centerX + 20, centerY - 5 - bobY, 10, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      },
      
      // Draw Missy sprite with sword and pistol
      drawMissy: function(centerX, centerY, frame, animState, palette) {
        let bobY = 0;
        let legOffset = 0;
        let armSwing = 0;
        
        if (animState === 'idle') {
          bobY = Math.sin(frame / 4 * Math.PI) * 1;
        } else if (animState === 'walk') {
          bobY = Math.sin(frame / 4 * Math.PI) * 2;
          legOffset = Math.sin(frame / 4 * Math.PI) * 3;
          armSwing = Math.sin(frame / 4 * Math.PI) * 10;
        } else if (animState === 'attack') {
          armSwing = (frame / 6) * 45;
        }
        
        // Angel glow
        const gradient = ctx.createRadialGradient(centerX, centerY - bobY, 0, centerX, centerY - bobY, 30);
        gradient.addColorStop(0, palette.aura + '0.2)');
        gradient.addColorStop(0.5, palette.aura + '0.1)');
        gradient.addColorStop(1, palette.aura + '0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(centerX - 35, centerY - 45 - bobY, 70, 90);
        
        // Legs
        this.drawRect(centerX - 10, centerY + 20 - bobY + legOffset, 6, 16, palette.clothes[2]);
        this.drawRect(centerX - 10, centerY + 36 - bobY + legOffset, 6, 8, palette.skin[1]);
        this.drawRect(centerX + 4, centerY + 20 - bobY - legOffset, 6, 16, palette.clothes[2]);
        this.drawRect(centerX + 4, centerY + 36 - bobY - legOffset, 6, 8, palette.skin[1]);
        
        // Body
        this.drawRect(centerX - 12, centerY + 4 - bobY, 24, 20, palette.clothes[1]);
        this.drawRect(centerX - 10, centerY + 6 - bobY, 20, 16, palette.clothes[2]);
        
        // Orange cat chest mark
        this.drawRect(centerX - 4, centerY + 10 - bobY, 8, 6, '#FF8800');
        
        // Arms
        this.drawRect(centerX - 18, centerY + 8 - bobY + armSwing * 0.5, 6, 10, palette.skin[1]);
        this.drawRect(centerX + 12, centerY + 8 - bobY - armSwing * 0.5, 6, 10, palette.skin[1]);
        
        // Head
        this.drawRect(centerX - 10, centerY - 16 - bobY, 20, 18, palette.skin[0]);
        
        // Black twintails
        this.drawRect(centerX - 12, centerY - 23 - bobY, 4, 6, '#000000');
        this.drawRect(centerX + 8, centerY - 23 - bobY, 4, 6, '#000000');
        
        // Orange cat ear clips
        this.drawRect(centerX - 6, centerY - 28 - bobY, 12, 3, '#FF8800');
        
        // Eyes (green)
        this.drawRect(centerX - 4, centerY - 10 - bobY, 3, 3, '#00FF00');
        this.drawRect(centerX + 1, centerY - 10 - bobY, 3, 3, '#00FF00');
        
        // Sword (left hand)
        ctx.save();
        ctx.translate(centerX - 25, centerY + 14 - bobY);
        ctx.rotate((-30 + armSwing) * Math.PI / 180);
        this.drawRect(-3, -12, 6, 16, palette.weapon[0]);
        this.drawRect(-2, -12, 4, 16, palette.weapon[2]);
        ctx.restore();
        
        // Pistol (right hand)
        this.drawRect(centerX + 20, centerY + 3 - bobY - armSwing * 0.5, 2, 8, palette.weapon[0]);
        this.drawRect(centerX + 19, centerY + 7 - bobY - armSwing * 0.5, 6, 4, '#444444');
        
        // Cat tail (animated)
        ctx.save();
        const tailSwing = Math.sin(GameState.animTime * 0.1) * 20;
        ctx.beginPath();
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 4;
        ctx.moveTo(centerX + 10, centerY + 25 - bobY);
        ctx.bezierCurveTo(
          centerX + 15 + tailSwing, centerY + 30 - bobY,
          centerX + 20 + tailSwing, centerY + 35 - bobY,
          centerX + 18 + tailSwing, centerY + 42 - bobY
        );
        ctx.stroke();
        ctx.restore();
      },
      
      // Draw Unique/Companion sprite with dual pistols
      drawUnique: function(centerX, centerY, frame, animState, palette) {
        let bobY = 0;
        let legOffset = 0;
        let armAngle = 0;
        
        if (animState === 'idle') {
          bobY = Math.sin(frame / 4 * Math.PI) * 1;
        } else if (animState === 'walk') {
          bobY = Math.sin(frame / 4 * Math.PI) * 2;
          legOffset = Math.sin(frame / 4 * Math.PI) * 3;
        } else if (animState === 'attack') {
          armAngle = (frame / 6) * 30;
        }
        
        // Cyber glow
        const gradient = ctx.createRadialGradient(centerX, centerY - bobY, 0, centerX, centerY - bobY, 25);
        gradient.addColorStop(0, palette.aura + '0.15)');
        gradient.addColorStop(0.5, palette.aura + '0.05)');
        gradient.addColorStop(1, palette.aura + '0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(centerX - 30, centerY - 40 - bobY, 60, 80);
        
        // Legs
        this.drawRect(centerX - 10, centerY + 20 - bobY + legOffset, 6, 16, palette.clothes[2]);
        this.drawRect(centerX + 4, centerY + 20 - bobY - legOffset, 6, 16, palette.clothes[2]);
        
        // Body
        this.drawRect(centerX - 12, centerY + 4 - bobY, 24, 20, palette.clothes[1]);
        
        // Head
        this.drawRect(centerX - 10, centerY - 16 - bobY, 20, 18, palette.skin[1]);
        
        // Black hair (afro/curly)
        this.drawRect(centerX - 14, centerY - 12 - bobY, 3, 10, '#000000');
        this.drawRect(centerX + 11, centerY - 12 - bobY, 3, 10, '#000000');
        this.drawRect(centerX - 10, centerY - 20 - bobY, 20, 5, '#000000');
        
        // Cyber visor
        this.drawRect(centerX - 8, centerY - 10 - bobY, 16, 3, palette.eyes[0]);
        
        // Left pistol
        ctx.save();
        ctx.translate(centerX - 25, centerY + 14 - bobY);
        ctx.rotate((-20 + armAngle) * Math.PI / 180);
        this.drawRect(-3, -2, 6, 4, palette.weapon[0]);
        this.drawRect(-4, -1, 2, 2, palette.weapon[2]);
        ctx.restore();
        
        // Right pistol
        ctx.save();
        ctx.translate(centerX + 25, centerY + 14 - bobY);
        ctx.rotate((20 - armAngle) * Math.PI / 180);
        this.drawRect(-3, -2, 6, 4, palette.weapon[0]);
        this.drawRect(2, -1, 2, 2, palette.weapon[2]);
        ctx.restore();
      },
      
      // Update character animation state
      updateAnimation: function(char, deltaTime, isMoving) {
        if (!char.animTimer) char.animTimer = 0;
        if (!char.animState) char.animState = 'idle';
        if (!char.animFrame) char.animFrame = 0;
        
        // Determine animation state
        let targetAnim = 'idle';
        if (char.inCombat) {
          targetAnim = 'attack';
        } else if (isMoving) {
          targetAnim = 'walk';
        }
        
        // Reset if state changed
        if (char.animState !== targetAnim) {
          char.animState = targetAnim;
          char.animFrame = 0;
          char.animTimer = 0;
        }
        
        // Update frame timer
        const anim = this.animations[char.animState];
        char.animTimer += deltaTime;
        
        if (char.animTimer >= anim.frameTime) {
          char.animTimer = 0;
          char.animFrame++;
          
          if (char.animFrame >= anim.frames) {
            if (anim.loop) {
              char.animFrame = 0;
            } else {
              char.animFrame = anim.frames - 1;
              char.animState = 'idle'; // Return to idle after non-loop
            }
          }
        }
      },
      
      // Main render function
      renderCharacter: function(char, x, y) {
        ctx.save();
        
        const palette = this.getPalette(char);
        const frame = char.animFrame || 0;
        const animState = char.animState || 'idle';
        
        // Add equipment visual effects (aura/glow)
        this.renderEquipmentEffects(char, x, y);
        
        // Render based on character type
        if (char.id === 'a1') {
          this.drawA1(x, y, frame, animState, palette);
        } else if (char.id === 'missy') {
          this.drawMissy(x, y, frame, animState, palette);
        } else {
          this.drawUnique(x, y, frame, animState, palette);
        }
        
        // Add skin rarity glow effects
        this.renderSkinEffects(char, x, y);
        
        ctx.restore();
      },
      
      // Render equipment visual effects
      renderEquipmentEffects: function(char, x, y) {
        const equipped = GameState.equipped;
        
        // Weapon glow based on equipped weapon
        if (equipped.weapon) {
          const weaponColors = {
            'Legendary': '#FFD700',
            'Epic': '#9933ff',
            'Rare': '#0099ff',
            'Uncommon': '#00ff00',
            'Common': '#ffffff'
          };
          
          // Find weapon rarity (simplified - would check actual item data)
          const glowColor = weaponColors['Epic'] || '#ffffff';
          
          ctx.fillStyle = glowColor;
          ctx.globalAlpha = 0.2 + Math.sin(GameState.animTime * 0.1) * 0.1;
          ctx.beginPath();
          ctx.arc(x - 20, y - 5, 15, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.arc(x + 20, y - 5, 15, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
        }
        
        // Armor glow based on equipped armor
        if (equipped.chest) {
          ctx.fillStyle = 'rgba(100, 200, 255, 0.1)';
          ctx.beginPath();
          ctx.arc(x, y, 30, 0, Math.PI * 2);
          ctx.fill();
        }
      },
      
      // Render skin visual effects
      renderSkinEffects: function(char, x, y) {
        const skinName = GameState.equippedSkins[char.name] || 'default';
        
        // Add rarity glow for legendary skins
        const legendarySkins = ['Fire Demon', 'Ice Crystal', 'Shadow Assassin', 'Light Warrior'];
        
        if (legendarySkins.includes(skinName)) {
          const palette = this.getPalette(char);
          
          // Pulsing aura effect
          const pulseIntensity = 0.15 + Math.sin(GameState.animTime * 0.08) * 0.1;
          
          ctx.fillStyle = palette.aura + pulseIntensity + ')';
          ctx.beginPath();
          ctx.arc(x, y, 40 + Math.sin(GameState.animTime * 0.05) * 5, 0, Math.PI * 2);
          ctx.fill();
          
          // Particle effects
          for (let i = 0; i < 3; i++) {
            const angle = (GameState.animTime * 0.02 + i * (Math.PI * 2 / 3));
            const distance = 35 + Math.sin(GameState.animTime * 0.03 + i) * 5;
            const px = x + Math.cos(angle) * distance;
            const py = y + Math.sin(angle) * distance;
            
            ctx.fillStyle = palette.glow;
            ctx.globalAlpha = 0.6;
            ctx.beginPath();
            ctx.arc(px, py, 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
          }
        }
      }
    };
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // END SPRITE RENDERING SYSTEM
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function drawCharacter(x, y, char, isLeader = false) {
      ctx.save();

      // Calculate bobbing offset for name tag and HP bar
      const bobY = char.animState === 'walk' ? Math.sin(char.animFrame / 4 * Math.PI) * 2 : 
                   char.animState === 'idle' ? Math.sin(char.animFrame / 4 * Math.PI) * 1 : 0;

      // Shadow
      ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
      ctx.beginPath();
      ctx.ellipse(x, y + 30, 15, 5, 0, 0, Math.PI * 2);
      ctx.fill();

      // Use new sprite system for rendering
      SpriteSystem.renderCharacter(char, x, y);

      // NAME TAG
      ctx.fillStyle = "#fff";
      ctx.font = "bold 10px Arial";
      ctx.textAlign = "center";
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 3;
      ctx.strokeText(char.name, x, y - 45 - bobY);
      ctx.fillText(char.name, x, y - 45 - bobY);

      // HP BAR (show if damaged)
      if (char.hp < char.maxHp) {
        const barWidth = 50;
        const barHeight = 4;
        const barX = x - barWidth / 2;
        const barY = y - 55 - bobY;

        // Background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
        ctx.fillRect(barX, barY, barWidth, barHeight);

        // HP fill
        const hpPercent = char.hp / char.maxHp;
        ctx.fillStyle = hpPercent > 0.5 ? '#4ade80' : hpPercent > 0.25 ? '#fbbf24' : '#ef4444';
        ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);

        // Border
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        ctx.strokeRect(barX, barY, barWidth, barHeight);
      }

      if (char.id === "a1" && isLeader) {
        ctx.fillStyle = "#fbbf24";
        ctx.font = "bold 14px Arial";
        ctx.shadowColor = "#fbbf24";
        ctx.shadowBlur = 10;
        ctx.fillText("‚òÖ", x, y - 60 - bobY);
        ctx.shadowBlur = 0;
      }

      ctx.restore();
    }

    function drawHunter(hunter) {
      ctx.save();

      // Shadow
      ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
      ctx.beginPath();
      ctx.ellipse(hunter.x, hunter.y + 32, 14, 5, 0, 0, Math.PI * 2);
      ctx.fill();

      // Body (larger than party members)
      ctx.fillStyle = hunter.color;
      ctx.fillRect(hunter.x - 11, hunter.y - 14, 22, 28);

      // Head
      ctx.beginPath();
      ctx.arc(hunter.x, hunter.y - 22, 11, 0, Math.PI * 2);
      ctx.fill();
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2;
      ctx.stroke();

      // Rank badge
      const rankColors = { C: '#8bc34a', B: '#2196f3', S: '#9c27b0' };
      ctx.fillStyle = rankColors[hunter.rank] || '#666';
      ctx.beginPath();
      ctx.arc(hunter.x + 12, hunter.y - 28, 8, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#fff";
      ctx.font = "bold 10px Arial";
      ctx.textAlign = "center";
      ctx.fillText(hunter.rank, hunter.x + 12, hunter.y - 25);

      // Name
      ctx.fillStyle = "#fff";
      ctx.font = "bold 11px Arial";
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 3;
      ctx.strokeText(hunter.name, hunter.x, hunter.y - 38);
      ctx.fillText(hunter.name, hunter.x, hunter.y - 38);

      // Service indicator
      const serviceIcons = { shop: 'üõí', training: '‚öîÔ∏è', quests: 'üìã' };
      ctx.font = "14px Arial";
      ctx.fillText(serviceIcons[hunter.service] || 'üíº', hunter.x, hunter.y - 50);

      // Highlight if nearby
      if (GameState.nearestInteractive && GameState.nearestInteractive.type === 'hunter' && GameState.nearestInteractive.hunter === hunter) {
        ctx.strokeStyle = "#fbbf24";
        ctx.lineWidth = 3;
        ctx.strokeRect(hunter.x - 15, hunter.y - 35, 30, 50);
      }

      ctx.restore();
    }

    function drawChest(chest) {
      ctx.save();

      const x = chest.x;
      const y = chest.y;

      if (chest.opened) {
        // Opened chest (dimmed)
        ctx.globalAlpha = 0.4;
        ctx.fillStyle = "#4a5568";
        ctx.fillRect(x - 14, y - 10, 28, 20);
        ctx.strokeStyle = "#666";
        ctx.lineWidth = 2;
        ctx.strokeRect(x - 14, y - 10, 28, 20);

        ctx.fillStyle = "#fff";
        ctx.font = "12px Arial";
        ctx.textAlign = "center";
        ctx.fillText("EMPTY", x, y + 20);
        ctx.globalAlpha = 1;
      } else {
        // Closed chest with glow
        const glowIntensity = chest.type.glow;

        // Glow effect
        ctx.shadowColor = chest.type.color;
        ctx.shadowBlur = 20 * glowIntensity;

        // Chest body
        ctx.fillStyle = chest.type.color;
        ctx.fillRect(x - 14, y - 10, 28, 20);

        // Chest lid
        ctx.fillStyle = shadeColor(chest.type.color, 20);
        ctx.fillRect(x - 14, y - 12, 28, 4);

        ctx.shadowBlur = 0;

        // Lock
        ctx.fillStyle = "#FFD700";
        ctx.fillRect(x - 3, y, 6, 6);

        // Highlight border
        ctx.strokeStyle = shadeColor(chest.type.color, 50);
        ctx.lineWidth = 2;
        ctx.strokeRect(x - 14, y - 10, 28, 20);

        // Rarity badge
        ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
        ctx.fillRect(x - 16, y - 24, 32, 12);
        ctx.fillStyle = chest.type.color;
        ctx.font = "bold 9px Arial";
        ctx.textAlign = "center";
        ctx.fillText(chest.type.rarity, x, y - 16);

        // Particles for high-tier chests
        if (chest.rarity === 'epic' || chest.rarity === 'legendary') {
          for (let i = 0; i < 5; i++) {
            const angle = (GameState.animTime * 0.02 + i * Math.PI * 0.4);
            const px = x + Math.cos(angle) * 25;
            const py = y - 5 + Math.sin(angle) * 15;

            ctx.fillStyle = chest.type.color;
            ctx.globalAlpha = 0.6 + Math.sin(GameState.animTime * 0.05 + i) * 0.4;
            ctx.beginPath();
            ctx.arc(px, py, 2, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.globalAlpha = 1;
        }

        // Highlight if nearby
        if (GameState.nearestInteractive && GameState.nearestInteractive.type === 'chest' && GameState.nearestInteractive.chest === chest) {
          ctx.strokeStyle = "#fbbf24";
          ctx.lineWidth = 3;
          ctx.strokeRect(x - 18, y - 14, 36, 28);
        }
      }

      ctx.restore();
    }

    function drawComputer(computer) {
      ctx.save();

      const x = computer.x;
      const y = computer.y;

      // Desk
      ctx.fillStyle = "#253247";
      ctx.fillRect(x - 40, y, 140, 20);

      // Computer base
      ctx.fillStyle = "#2e3b55";
      ctx.fillRect(x, y - 28, 60, 28);

      // Monitor
      ctx.fillStyle = "#0e141d";
      ctx.fillRect(x + 70, y - 42, 48, 36);

      // Screen glow
      ctx.strokeStyle = "#00E5FF";
      ctx.shadowColor = "#00E5FF";
      ctx.shadowBlur = 10;
      ctx.lineWidth = 2;
      ctx.strokeRect(x + 70.5, y - 41.5, 47, 35);
      ctx.shadowBlur = 0;

      // Screen content (animated)
      ctx.fillStyle = "#00E5FF";
      ctx.globalAlpha = 0.7 + Math.sin(GameState.animTime * 0.05) * 0.3;
      ctx.font = "8px monospace";
      ctx.textAlign = "left";
      ctx.fillText(">>READY", x + 73, y - 28);
      ctx.fillText("GAMES_6", x + 73, y - 18);
      ctx.globalAlpha = 1;

      // Highlight if nearby
      if (GameState.nearestInteractive && GameState.nearestInteractive.type === 'computer') {
        ctx.strokeStyle = "#fbbf24";
        ctx.lineWidth = 3;
        ctx.strokeRect(x + 65, y - 46, 58, 44);
      }

      ctx.restore();
    }

    function drawIndoorCombat() {
      const combat = GameState.indoorCombat;

      // Draw enemies
      for (const enemy of combat.enemies) {
        ctx.save();

        // Shadow
        ctx.fillStyle = "rgba(0, 0, 0, 0.3)";
        ctx.beginPath();
        ctx.ellipse(enemy.x, enemy.y + 30, 12, 4, 0, 0, Math.PI * 2);
        ctx.fill();

        // Enemy body
        ctx.fillStyle = enemy.color;
        ctx.fillRect(enemy.x - 10, enemy.y - 13, 20, 26);

        // Head
        ctx.beginPath();
        ctx.arc(enemy.x, enemy.y - 20, 8, 0, Math.PI * 2);
        ctx.fill();

        // HP bar
        const hpPercent = enemy.hp / enemy.hpMax;
        ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
        ctx.fillRect(enemy.x - 15, enemy.y - 35, 30, 4);

        ctx.fillStyle = hpPercent > 0.5 ? '#22c55e' : hpPercent > 0.25 ? '#eab308' : '#ef4444';
        ctx.fillRect(enemy.x - 15, enemy.y - 35, 30 * hpPercent, 4);

        ctx.restore();
      }

      // Draw VFX
      for (const fx of combat.fx) {
        ctx.save();
        const alpha = fx.life / fx.maxLife;
        ctx.globalAlpha = alpha;

        if (fx.type === 'slash') {
          // Slash arc
          ctx.strokeStyle = '#ff6b35';
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.arc(fx.x, fx.y, 20, -Math.PI / 4, Math.PI / 4);
          ctx.stroke();
        } else if (fx.type === 'burst') {
          // Explosion burst
          const size = 15 * (1 - alpha);
          ctx.fillStyle = fx.color;
          ctx.beginPath();
          ctx.arc(fx.x, fx.y, size, 0, Math.PI * 2);
          ctx.fill();
        } else if (fx.type === 'beam') {
          // Beam attack
          ctx.strokeStyle = fx.color;
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(fx.x1, fx.y1);
          ctx.lineTo(fx.x2, fx.y2);
          ctx.stroke();
        }

        ctx.restore();
      }

      // Wave counter
      if (combat.enemies.length > 0) {
        ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
        ctx.fillRect(canvas.width - 150, 20, 130, 60);
        ctx.strokeStyle = "#ef4444";
        ctx.lineWidth = 2;
        ctx.strokeRect(canvas.width - 150, 20, 130, 60);

        ctx.fillStyle = "#fff";
        ctx.font = "bold 14px Arial";
        ctx.textAlign = "left";
        ctx.fillText(`Wave: ${combat.wave}`, canvas.width - 140, 45);
        ctx.fillText(`Enemies: ${combat.enemies.length}`, canvas.width - 140, 65);
      }
    }

    function drawPet(pet) {
      ctx.save();

      // Shadow
      ctx.fillStyle = "rgba(0, 0, 0, 0.2)";
      ctx.beginPath();
      ctx.ellipse(pet.x, pet.y + pet.h, 8, 3, 0, 0, Math.PI * 2);
      ctx.fill();

      // Pet body
      ctx.fillStyle = pet.color;

      if (pet.type === 'cat') {
        // Cat shape
        ctx.fillRect(pet.x - 8, pet.y - 6, 16, 12);

        // Cat head
        ctx.beginPath();
        ctx.arc(pet.x, pet.y - 10, 6, 0, Math.PI * 2);
        ctx.fill();

        // Ears
        ctx.beginPath();
        ctx.moveTo(pet.x - 5, pet.y - 14);
        ctx.lineTo(pet.x - 3, pet.y - 18);
        ctx.lineTo(pet.x - 1, pet.y - 14);
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(pet.x + 1, pet.y - 14);
        ctx.lineTo(pet.x + 3, pet.y - 18);
        ctx.lineTo(pet.x + 5, pet.y - 14);
        ctx.fill();

        // Tail
        ctx.lineWidth = 2;
        ctx.strokeStyle = pet.color;
        ctx.beginPath();
        ctx.moveTo(pet.x - 8, pet.y);
        ctx.quadraticCurveTo(pet.x - 12, pet.y - 8, pet.x - 10, pet.y - 12);
        ctx.stroke();
      } else if (pet.type === 'dog') {
        // Dog shape
        ctx.fillRect(pet.x - 9, pet.y - 7, 18, 14);

        // Dog head
        ctx.beginPath();
        ctx.arc(pet.x, pet.y - 11, 7, 0, Math.PI * 2);
        ctx.fill();

        // Ears (floppy)
        ctx.fillRect(pet.x - 8, pet.y - 12, 3, 6);
        ctx.fillRect(pet.x + 5, pet.y - 12, 3, 6);

        // Tail (wagging)
        const wag = Math.sin(GameState.animTime * 0.15) * 3;
        ctx.lineWidth = 3;
        ctx.strokeStyle = pet.color;
        ctx.beginPath();
        ctx.moveTo(pet.x - 9, pet.y);
        ctx.lineTo(pet.x - 14 + wag, pet.y - 5);
        ctx.stroke();
      }

      // Name tag
      ctx.fillStyle = "#fff";
      ctx.font = "8px Arial";
      ctx.textAlign = "center";
      ctx.strokeStyle = "#000";
      ctx.lineWidth = 2;
      ctx.strokeText(pet.name, pet.x, pet.y - 22);
      ctx.fillText(pet.name, pet.x, pet.y - 22);

      ctx.restore();
    }

    // ============================
    // UI FUNCTIONS
    // ============================

    function showToast(message) {
      const toast = document.createElement("div");
      toast.className = "toast";
      toast.textContent = message;
      document.body.appendChild(toast);
      setTimeout(() => toast.remove(), 3000);
    }

    function shadeColor(color, percent) {
      const num = parseInt(color.replace("#", ""), 16);
      const amt = Math.round(2.55 * percent);
      const R = Math.max(0, Math.min(255, (num >> 16) + amt));
      const G = Math.max(0, Math.min(255, ((num >> 8) & 0x00ff) + amt));
      const B = Math.max(0, Math.min(255, (num & 0x0000ff) + amt));
      return `#${((R << 16) | (G << 8) | B).toString(16).padStart(6, "0")}`;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ADVANCED COMBAT SYSTEM - PHASE 2
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    const CombatSystem = {
      // Enemy templates
      enemyTemplates: {
        goblin: {
          name: 'Goblin',
          hp: 80,
          maxHp: 80,
          atk: 15,
          def: 5,
          speed: 2,
          xpReward: 25,
          goldReward: 50,
          color: '#6B8E23',
          size: 20,
          aiPattern: 'chase',
          attackRange: 40,
          attackCooldown: 1500,
          specialMoves: []
        },
        orc: {
          name: 'Orc Warrior',
          hp: 150,
          maxHp: 150,
          atk: 25,
          def: 15,
          speed: 1.5,
          xpReward: 50,
          goldReward: 100,
          color: '#8B4513',
          size: 25,
          aiPattern: 'chargeAttack',
          attackRange: 50,
          attackCooldown: 2000,
          specialMoves: ['bash']
        },
        skeleton: {
          name: 'Skeleton',
          hp: 60,
          maxHp: 60,
          atk: 20,
          def: 3,
          speed: 2.5,
          xpReward: 30,
          goldReward: 60,
          color: '#E0E0E0',
          size: 18,
          aiPattern: 'ranged',
          attackRange: 200,
          attackCooldown: 1200,
          specialMoves: ['arrowShot']
        },
        boss_dragon: {
          name: 'Dragon Lord',
          hp: 500,
          maxHp: 500,
          atk: 50,
          def: 30,
          speed: 1,
          xpReward: 500,
          goldReward: 1000,
          color: '#DC143C',
          size: 40,
          aiPattern: 'boss',
          attackRange: 150,
          attackCooldown: 3000,
          specialMoves: ['fireBreath', 'tailSwipe', 'roar'],
          phases: [
            { hpThreshold: 0.75, specialMove: 'fireBreath' },
            { hpThreshold: 0.5, specialMove: 'tailSwipe' },
            { hpThreshold: 0.25, specialMove: 'rage' }
          ]
        }
      },
      
      // Spawn enemy
      spawnEnemy: function(templateId, x, y) {
        const template = this.enemyTemplates[templateId];
        if (!template) return null;
        
        const enemy = {
          ...template,
          id: 'enemy_' + Date.now() + '_' + Math.random(),
          x: x,
          y: y,
          vx: 0,
          vy: 0,
          lastAttackTime: 0,
          target: null,
          state: 'idle', // idle, chase, attack, hurt, death
          stateTimer: 0,
          invulnerable: false,
          invulnerableTimer: 0,
          statusEffects: []
        };
        
        GameState.enemies.push(enemy);
        return enemy;
      },
      
      // Update all enemies
      updateEnemies: function(dt) {
        for (let i = GameState.enemies.length - 1; i >= 0; i--) {
          const enemy = GameState.enemies[i];
          
          // Update invulnerability
          if (enemy.invulnerable) {
            enemy.invulnerableTimer -= dt;
            if (enemy.invulnerableTimer <= 0) {
              enemy.invulnerable = false;
            }
          }
          
          // Update status effects
          this.updateStatusEffects(enemy, dt);
          
          // Remove dead enemies
          if (enemy.hp <= 0) {
            this.onEnemyDeath(enemy);
            GameState.enemies.splice(i, 1);
            continue;
          }
          
          // AI behavior
          this.updateEnemyAI(enemy, dt);
          
          // Move enemy
          enemy.x += enemy.vx * dt / 16;
          enemy.y += enemy.vy * dt / 16;
          
          // Keep enemy in bounds
          enemy.x = Math.max(50, Math.min(WORLD.width - 50, enemy.x));
          enemy.y = Math.max(400, Math.min(600, enemy.y));
        }
      },
      
      // Enemy AI patterns
      updateEnemyAI: function(enemy, dt) {
        const leader = GameState.party[0];
        const dx = leader.x - enemy.x;
        const dy = leader.y - enemy.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        // Find nearest target
        enemy.target = leader;
        
        switch (enemy.aiPattern) {
          case 'chase':
            if (distance > enemy.attackRange) {
              const angle = Math.atan2(dy, dx);
              enemy.vx = Math.cos(angle) * enemy.speed;
              enemy.vy = Math.sin(angle) * enemy.speed;
              enemy.state = 'chase';
            } else {
              enemy.vx = 0;
              enemy.vy = 0;
              if (Date.now() - enemy.lastAttackTime > enemy.attackCooldown) {
                this.enemyAttack(enemy);
              }
            }
            break;
            
          case 'chargeAttack':
            if (distance > enemy.attackRange + 100) {
              const angle = Math.atan2(dy, dx);
              enemy.vx = Math.cos(angle) * enemy.speed;
              enemy.vy = Math.sin(angle) * enemy.speed;
            } else if (distance > enemy.attackRange) {
              // Charge attack
              const angle = Math.atan2(dy, dx);
              enemy.vx = Math.cos(angle) * enemy.speed * 3;
              enemy.vy = Math.sin(angle) * enemy.speed * 3;
            } else {
              enemy.vx = 0;
              enemy.vy = 0;
              if (Date.now() - enemy.lastAttackTime > enemy.attackCooldown) {
                this.enemyAttack(enemy);
              }
            }
            break;
            
          case 'ranged':
            if (distance > 250) {
              const angle = Math.atan2(dy, dx);
              enemy.vx = Math.cos(angle) * enemy.speed;
              enemy.vy = Math.sin(angle) * enemy.speed;
            } else if (distance < 150) {
              // Kite away
              const angle = Math.atan2(dy, dx);
              enemy.vx = -Math.cos(angle) * enemy.speed;
              enemy.vy = -Math.sin(angle) * enemy.speed;
            } else {
              enemy.vx = 0;
              enemy.vy = 0;
              if (Date.now() - enemy.lastAttackTime > enemy.attackCooldown) {
                this.enemyRangedAttack(enemy);
              }
            }
            break;
            
          case 'boss':
            this.updateBossAI(enemy, dt, distance, dx, dy);
            break;
        }
      },
      
      // Boss AI with phases
      updateBossAI: function(enemy, dt, distance, dx, dy) {
        const hpPercent = enemy.hp / enemy.maxHp;
        
        // Check phase triggers
        if (enemy.phases) {
          for (const phase of enemy.phases) {
            if (hpPercent <= phase.hpThreshold && !enemy[`phase${phase.hpThreshold}Triggered`]) {
              enemy[`phase${phase.hpThreshold}Triggered`] = true;
              this.triggerBossPhase(enemy, phase);
              break;
            }
          }
        }
        
        // Movement
        if (distance > 200) {
          const angle = Math.atan2(dy, dx);
          enemy.vx = Math.cos(angle) * enemy.speed;
          enemy.vy = Math.sin(angle) * enemy.speed;
        } else {
          enemy.vx = Math.sin(GameState.animTime * 0.02) * enemy.speed * 0.5;
          enemy.vy = 0;
        }
        
        // Special attacks
        if (Date.now() - enemy.lastAttackTime > enemy.attackCooldown) {
          const moveIndex = Math.floor(Math.random() * enemy.specialMoves.length);
          this.executeBossMove(enemy, enemy.specialMoves[moveIndex]);
          enemy.lastAttackTime = Date.now();
        }
      },
      
      // Trigger boss phase
      triggerBossPhase: function(enemy, phase) {
        this.createScreenShake(10);
        this.createHitFlash(30);
        
        // Show phase message
        showToast(`‚ö†Ô∏è ${enemy.name} enters Phase ${Math.floor((1 - phase.hpThreshold) * 4)}!`);
        
        // Increase stats
        enemy.atk *= 1.2;
        enemy.speed *= 1.1;
        enemy.attackCooldown *= 0.9;
      },
      
      // Execute boss special move
      executeBossMove: function(enemy, moveName) {
        switch (moveName) {
          case 'fireBreath':
            for (let i = 0; i < 8; i++) {
              const angle = (i / 8) * Math.PI * 2;
              this.createProjectile(enemy.x, enemy.y, angle, 5, enemy.atk * 1.5, '#FF4500', 'fire');
            }
            break;
            
          case 'tailSwipe':
            // AOE damage around boss
            for (const char of GameState.party) {
              const dx = char.x - enemy.x;
              const dy = char.y - enemy.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist < 150) {
                this.damageCharacter(char, enemy.atk * 2, 'physical');
              }
            }
            break;
            
          case 'roar':
            // Stun all characters
            for (const char of GameState.party) {
              this.applyStatusEffect(char, 'stun', 2000);
            }
            break;
            
          case 'arrowShot':
            const target = enemy.target || GameState.party[0];
            const angle = Math.atan2(target.y - enemy.y, target.x - enemy.x);
            this.createProjectile(enemy.x, enemy.y, angle, 8, enemy.atk, '#888888', 'arrow');
            break;
            
          case 'bash':
            const char = enemy.target || GameState.party[0];
            this.damageCharacter(char, enemy.atk * 1.5, 'physical');
            this.applyStatusEffect(char, 'stun', 500);
            break;
        }
      },
      
      // Enemy attack
      enemyAttack: function(enemy) {
        enemy.lastAttackTime = Date.now();
        enemy.state = 'attack';
        
        // Set character animation to attack
        enemy.animState = 'attack';
        enemy.animFrame = 0;
        
        // Damage target after a delay
        setTimeout(() => {
          const target = enemy.target || GameState.party[0];
          const dx = target.x - enemy.x;
          const dy = target.y - enemy.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < enemy.attackRange) {
            this.damageCharacter(target, enemy.atk, 'physical');
          }
        }, 300);
      },
      
      // Enemy ranged attack
      enemyRangedAttack: function(enemy) {
        enemy.lastAttackTime = Date.now();
        
        const target = enemy.target || GameState.party[0];
        const angle = Math.atan2(target.y - enemy.y, target.x - enemy.x);
        
        this.createProjectile(enemy.x, enemy.y, angle, 6, enemy.atk, enemy.color, 'arrow');
      },
      
      // Create projectile
      createProjectile: function(x, y, angle, speed, damage, color, type) {
        GameState.projectiles.push({
          x: x,
          y: y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          damage: damage,
          color: color,
          type: type,
          radius: type === 'fire' ? 8 : 5,
          lifetime: 3000,
          createdAt: Date.now()
        });
      },
      
      // Update projectiles
      updateProjectiles: function(dt) {
        const now = Date.now();
        
        for (let i = GameState.projectiles.length - 1; i >= 0; i--) {
          const proj = GameState.projectiles[i];
          
          // Update position
          proj.x += proj.vx * dt / 16;
          proj.y += proj.vy * dt / 16;
          
          // Check lifetime
          if (now - proj.createdAt > proj.lifetime) {
            GameState.projectiles.splice(i, 1);
            continue;
          }
          
          // Check collision with characters
          for (const char of GameState.party) {
            const dx = char.x - proj.x;
            const dy = char.y - proj.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance < 20) {
              this.damageCharacter(char, proj.damage, proj.type);
              GameState.projectiles.splice(i, 1);
              break;
            }
          }
        }
      },
      
      // Damage character
      damageCharacter: function(char, rawDamage, damageType) {
        // Calculate final damage
        const defense = char.def || 0;
        const damage = Math.max(1, Math.floor(rawDamage * (100 / (100 + defense))));
        
        char.hp = Math.max(0, char.hp - damage);
        
        // Create damage number
        this.createDamageNumber(char.x, char.y - 30, damage, '#ff0000');
        
        // Visual feedback
        char.animState = 'hurt';
        char.animFrame = 0;
        
        // Screen shake
        if (damage > 20) {
          this.createScreenShake(5);
        }
        
        // Check death
        if (char.hp <= 0) {
          char.animState = 'death';
          showToast(`üíÄ ${char.name} has fallen!`);
        }
      },
      
      // Damage enemy
      damageEnemy: function(enemy, rawDamage, damageType, isCrit = false) {
        if (enemy.invulnerable) return;
        
        // Calculate final damage
        const defense = enemy.def || 0;
        let damage = Math.max(1, Math.floor(rawDamage * (100 / (100 + defense))));
        
        if (isCrit) {
          damage *= 2;
        }
        
        enemy.hp = Math.max(0, enemy.hp - damage);
        
        // Create damage number
        const color = isCrit ? '#FFD700' : '#ffffff';
        this.createDamageNumber(enemy.x, enemy.y - enemy.size - 10, damage, color, isCrit);
        
        // Invulnerability frames
        enemy.invulnerable = true;
        enemy.invulnerableTimer = 100;
        
        // Visual feedback
        enemy.animState = 'hurt';
        
        // Screen shake for big hits
        if (damage > 50) {
          this.createScreenShake(3);
        }
      },
      
      // Create damage number
      createDamageNumber: function(x, y, value, color, isCrit = false) {
        GameState.damageNumbers.push({
          x: x + (Math.random() - 0.5) * 20,
          y: y,
          value: value,
          color: color,
          alpha: 1,
          vy: -2,
          lifetime: 1000,
          createdAt: Date.now(),
          scale: isCrit ? 1.5 : 1
        });
      },
      
      // Update damage numbers
      updateDamageNumbers: function(dt) {
        const now = Date.now();
        
        for (let i = GameState.damageNumbers.length - 1; i >= 0; i--) {
          const dmg = GameState.damageNumbers[i];
          
          dmg.y += dmg.vy;
          dmg.vy += 0.1; // Gravity
          dmg.alpha -= dt / 1000;
          
          if (now - dmg.createdAt > dmg.lifetime || dmg.alpha <= 0) {
            GameState.damageNumbers.splice(i, 1);
          }
        }
      },
      
      // Apply status effect
      applyStatusEffect: function(entity, effectType, duration) {
        entity.statusEffects = entity.statusEffects || [];
        entity.statusEffects.push({
          type: effectType,
          duration: duration,
          startTime: Date.now()
        });
      },
      
      // Update status effects
      updateStatusEffects: function(entity, dt) {
        if (!entity.statusEffects) return;
        
        const now = Date.now();
        
        for (let i = entity.statusEffects.length - 1; i >= 0; i--) {
          const effect = entity.statusEffects[i];
          
          if (now - effect.startTime > effect.duration) {
            entity.statusEffects.splice(i, 1);
            continue;
          }
          
          // Apply effect
          switch (effect.type) {
            case 'burn':
              if ((now - effect.startTime) % 500 < 16) {
                this.damageEnemy(entity, 5, 'fire');
              }
              break;
              
            case 'freeze':
              entity.speed *= 0.5;
              break;
              
            case 'stun':
              entity.vx = 0;
              entity.vy = 0;
              break;
          }
        }
      },
      
      // On enemy death
      onEnemyDeath: function(enemy) {
        // Rewards
        GameState.gold += enemy.goldReward;
        updateGoldDisplay();
        
        // XP
        for (const char of GameState.party) {
          char.xp = (char.xp || 0) + Math.floor(enemy.xpReward / GameState.party.length);
          
          // Level up check
          const xpNeeded = char.level * 100;
          if (char.xp >= xpNeeded) {
            char.xp -= xpNeeded;
            char.level++;
            char.maxHp += 20;
            char.hp = char.maxHp;
            char.atk += 5;
            char.def += 3;
            showToast(`‚≠ê ${char.name} reached Level ${char.level}!`);
          }
        }
        
        // Death VFX
        for (let i = 0; i < 10; i++) {
          const angle = (i / 10) * Math.PI * 2;
          const speed = 2 + Math.random() * 3;
          GameState.projectiles.push({
            x: enemy.x,
            y: enemy.y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed - 2,
            damage: 0,
            color: enemy.color,
            type: 'particle',
            radius: 3,
            lifetime: 500,
            createdAt: Date.now()
          });
        }
      },
      
      // Screen effects
      createScreenShake: function(intensity) {
        GameState.screenShake = Math.max(GameState.screenShake, intensity);
      },
      
      createHitFlash: function(duration) {
        GameState.hitFlash = Math.max(GameState.hitFlash, duration);
      },
      
      // Render enemies
      renderEnemies: function() {
        for (const enemy of GameState.enemies) {
          ctx.save();
          
          // Flashing when invulnerable
          if (enemy.invulnerable && Math.floor(GameState.animTime * 0.2) % 2 === 0) {
            ctx.globalAlpha = 0.5;
          }
          
          // Shadow
          ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
          ctx.beginPath();
          ctx.ellipse(enemy.x, enemy.y + enemy.size, enemy.size * 0.8, enemy.size * 0.3, 0, 0, Math.PI * 2);
          ctx.fill();
          
          // Body
          ctx.fillStyle = enemy.color;
          ctx.beginPath();
          ctx.arc(enemy.x, enemy.y, enemy.size, 0, Math.PI * 2);
          ctx.fill();
          
          // Eyes
          ctx.fillStyle = '#ff0000';
          ctx.fillRect(enemy.x - enemy.size * 0.3, enemy.y - enemy.size * 0.2, enemy.size * 0.2, enemy.size * 0.2);
          ctx.fillRect(enemy.x + enemy.size * 0.1, enemy.y - enemy.size * 0.2, enemy.size * 0.2, enemy.size * 0.2);
          
          // HP bar
          const barWidth = enemy.size * 2;
          const barHeight = 4;
          const barX = enemy.x - barWidth / 2;
          const barY = enemy.y - enemy.size - 10;
          
          ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
          ctx.fillRect(barX, barY, barWidth, barHeight);
          
          const hpPercent = enemy.hp / enemy.maxHp;
          ctx.fillStyle = hpPercent > 0.5 ? '#4ade80' : hpPercent > 0.25 ? '#fbbf24' : '#ef4444';
          ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);
          
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 1;
          ctx.strokeRect(barX, barY, barWidth, barHeight);
          
          // Status effect icons
          if (enemy.statusEffects) {
            let iconX = enemy.x - 15;
            for (const effect of enemy.statusEffects) {
              ctx.fillStyle = '#ffffff';
              ctx.font = '12px Arial';
              ctx.fillText(effect.type === 'burn' ? 'üî•' : effect.type === 'freeze' ? '‚ùÑÔ∏è' : '‚ö°', iconX, barY - 5);
              iconX += 15;
            }
          }
          
          ctx.restore();
        }
      },
      
      // Render projectiles
      renderProjectiles: function() {
        for (const proj of GameState.projectiles) {
          ctx.save();
          
          if (proj.type === 'fire') {
            ctx.fillStyle = proj.color;
            ctx.shadowColor = proj.color;
            ctx.shadowBlur = 10;
            ctx.beginPath();
            ctx.arc(proj.x, proj.y, proj.radius, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
          } else if (proj.type === 'arrow') {
            ctx.fillStyle = proj.color;
            const angle = Math.atan2(proj.vy, proj.vx);
            ctx.save();
            ctx.translate(proj.x, proj.y);
            ctx.rotate(angle);
            ctx.fillRect(-10, -2, 15, 4);
            ctx.beginPath();
            ctx.moveTo(5, 0);
            ctx.lineTo(8, -3);
            ctx.lineTo(8, 3);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
          } else {
            ctx.fillStyle = proj.color;
            ctx.beginPath();
            ctx.arc(proj.x, proj.y, proj.radius, 0, Math.PI * 2);
            ctx.fill();
          }
          
          ctx.restore();
        }
      },
      
      // Render damage numbers
      renderDamageNumbers: function() {
        for (const dmg of GameState.damageNumbers) {
          ctx.save();
          ctx.globalAlpha = dmg.alpha;
          
          ctx.font = `bold ${16 * dmg.scale}px Arial`;
          ctx.fillStyle = dmg.color;
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 3;
          ctx.textAlign = 'center';
          
          ctx.strokeText(dmg.value, dmg.x, dmg.y);
          ctx.fillText(dmg.value, dmg.x, dmg.y);
          
          ctx.restore();
        }
      }
    };
    
    // Convenience functions for game loop
    function updateEnemies(dt) {
      CombatSystem.updateEnemies(dt);
    }
    
    function updateProjectiles(dt) {
      CombatSystem.updateProjectiles(dt);
    }
    
    function updateDamageNumbers(dt) {
      CombatSystem.updateDamageNumbers(dt);
    }
    
    function updateRageShield(dt) {
      // Rage system update
      if (GameState.rageMode) {
        GameState.rageModeTimer -= dt;
        if (GameState.rageModeTimer <= 0) {
          GameState.rageMode = false;
          GameState.rage = 0;
        }
      }
      
      // Screen shake decay
      if (GameState.screenShake > 0) {
        GameState.screenShake *= 0.9;
        if (GameState.screenShake < 0.1) GameState.screenShake = 0;
      }
      
      // Hit flash decay
      if (GameState.hitFlash > 0) {
        GameState.hitFlash -= dt / 16;
        if (GameState.hitFlash < 0) GameState.hitFlash = 0;
      }
    }
    
    function updatePetRobotCombat(dt) {
      // Pet/Robot combat AI - attack nearby enemies
      const activePet = GameState.activePet;
      if (activePet && activePet.summonedAt) {
        for (const enemy of GameState.enemies) {
          const dx = enemy.x - activePet.x;
          const dy = enemy.y - activePet.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          
          if (distance < 100) {
            // Pet attacks
            if (Date.now() - (activePet.lastAttackTime || 0) > 1000) {
              CombatSystem.damageEnemy(enemy, 20, 'physical');
              activePet.lastAttackTime = Date.now();
            }
          }
        }
      }
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // END COMBAT SYSTEM
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // AAA PHASE 1: COMBO SYSTEM
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function updateComboSystem(dt) {
      // Combo timer countdown
      if (GameState.comboTimer > 0) {
        GameState.comboTimer -= dt;
        
        // Break combo if timer expires
        if (GameState.comboTimer <= 0) {
          breakCombo();
        }
      }
      
      // Update combo multiplier based on combo count
      if (GameState.comboCount >= 100) {
        GameState.comboMultiplier = 2.5;
      } else if (GameState.comboCount >= 50) {
        GameState.comboMultiplier = 2.0;
      } else if (GameState.comboCount >= 25) {
        GameState.comboMultiplier = 1.75;
      } else if (GameState.comboCount >= 10) {
        GameState.comboMultiplier = 1.5;
      } else {
        GameState.comboMultiplier = 1.0 + (GameState.comboCount * 0.05); // 5% per hit up to 10
      }
    }

    function addCombo(isHit = true) {
      if (!isHit) return;
      
      GameState.comboCount++;
      GameState.comboTimer = 3000; // 3 seconds to continue combo
      
      // Track max combo
      if (GameState.comboCount > GameState.maxCombo) {
        GameState.maxCombo = GameState.comboCount;
      }
      
      // Check for combo milestone rewards
      checkComboRewards();
      
      // Visual feedback for milestones
      if (GameState.comboCount === 10 || GameState.comboCount === 25 || 
          GameState.comboCount === 50 || GameState.comboCount === 100) {
        showToast(`üî• ${GameState.comboCount} HIT COMBO! ${GameState.comboMultiplier}x DAMAGE!`, 2000, '#ff6600');
        screenShake(8, 300);
        AudioSystem.playSound('combo');
      }
    }

    function breakCombo() {
      if (GameState.comboCount === 0) return;
      
      const comboCount = GameState.comboCount;
      GameState.comboCount = 0;
      GameState.comboMultiplier = 1.0;
      GameState.comboTimer = 0;
      
      if (comboCount >= 10) {
        showToast(`üíî Combo Broken! (${comboCount} hits)`, 1500, '#999999');
      }
    }

    function checkComboRewards() {
      GameState.comboMilestones.forEach(milestone => {
        if (GameState.comboCount === milestone && 
            !GameState.comboRewardsClaimed.includes(milestone)) {
          GameState.comboRewardsClaimed.push(milestone);
          
          // Award bonus gold and XP
          const goldBonus = milestone * 10;
          const xpBonus = milestone * 5;
          
          GameState.gold += goldBonus;
          gainXP(xpBonus);
          
          showToast(`üéÅ Combo Milestone! +${goldBonus}g +${xpBonus}xp`, 2500, '#fde047');
        }
      });
    }

    function renderComboUI() {
      if (GameState.comboCount === 0) return;
      
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      
      // Combo counter position (top center)
      const x = canvas.width / 2;
      const y = 100;
      
      // Pulse effect based on combo
      const pulse = 1.0 + Math.sin(Date.now() * 0.01) * 0.1;
      const scale = Math.min(1.0 + (GameState.comboCount / 100) * 0.5, 2.0) * pulse;
      
      ctx.save();
      ctx.translate(x, y);
      ctx.scale(scale, scale);
      
      // Combo count background
      const bgColor = GameState.comboCount >= 50 ? '#ff0000' : 
                      GameState.comboCount >= 25 ? '#ff6600' :
                      GameState.comboCount >= 10 ? '#ffaa00' : '#ffdd00';
      
      ctx.shadowColor = bgColor;
      ctx.shadowBlur = 20;
      ctx.fillStyle = bgColor;
      ctx.globalAlpha = 0.3;
      ctx.beginPath();
      ctx.arc(0, 0, 60, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
      
      // Combo count text
      ctx.font = 'bold 48px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 6;
      ctx.strokeText(GameState.comboCount.toString(), 0, 0);
      ctx.fillStyle = '#ffffff';
      ctx.fillText(GameState.comboCount.toString(), 0, 0);
      
      // "HIT COMBO" text
      ctx.font = 'bold 16px Arial';
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 3;
      ctx.strokeText('HIT COMBO', 0, -50);
      ctx.fillStyle = bgColor;
      ctx.fillText('HIT COMBO', 0, -50);
      
      // Multiplier text
      ctx.font = 'bold 20px Arial';
      ctx.strokeText(`${GameState.comboMultiplier.toFixed(1)}x DAMAGE`, 0, 50);
      ctx.fillStyle = '#fde047';
      ctx.fillText(`${GameState.comboMultiplier.toFixed(1)}x DAMAGE`, 0, 50);
      
      // Timer bar
      const timerPercent = Math.max(0, GameState.comboTimer / 3000);
      const barWidth = 100;
      const barHeight = 8;
      const barX = -barWidth / 2;
      const barY = 70;
      
      ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
      ctx.fillRect(barX, barY, barWidth, barHeight);
      
      ctx.fillStyle = timerPercent > 0.5 ? '#10b981' : timerPercent > 0.25 ? '#fbbf24' : '#ef4444';
      ctx.fillRect(barX, barY, barWidth * timerPercent, barHeight);
      
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 2;
      ctx.strokeRect(barX, barY, barWidth, barHeight);
      
      ctx.restore();
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // AAA PHASE 1: STATUS EFFECT SYSTEM
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const STATUS_EFFECTS = {
      BURN: { name: 'Burn', icon: 'üî•', color: '#ff6600', damagePerSec: 20, duration: 5000 },
      FREEZE: { name: 'Freeze', icon: '‚ùÑÔ∏è', color: '#66ccff', speedMult: 0.3, duration: 3000 },
      POISON: { name: 'Poison', icon: '‚ò†Ô∏è', color: '#00ff00', damagePerSec: 15, duration: 8000 },
      STUN: { name: 'Stun', icon: 'üí´', color: '#ffff00', speedMult: 0, duration: 2000 },
      SLOW: { name: 'Slow', icon: 'üêå', color: '#999999', speedMult: 0.5, duration: 4000 },
      BERSERK: { name: 'Berserk', icon: 'üò°', color: '#ff0000', damageMult: 1.5, duration: 6000 },
      SHIELD: { name: 'Shield', icon: 'üõ°Ô∏è', color: '#00aaff', defMult: 2.0, duration: 5000 },
      CURSE: { name: 'Curse', icon: 'üëπ', color: '#aa00ff', damageMult: 0.7, defMult: 0.7, duration: 7000 }
    };

    function applyStatusEffect(entityId, effectType, duration = null) {
      const effect = STATUS_EFFECTS[effectType];
      if (!effect) return;
      
      if (!GameState.statusEffects[entityId]) {
        GameState.statusEffects[entityId] = [];
      }
      
      // Check if already has this effect
      const existing = GameState.statusEffects[entityId].find(e => e.type === effectType);
      if (existing) {
        // Refresh duration
        existing.duration = duration || effect.duration;
        existing.startTime = Date.now();
        return;
      }
      
      // Add new status effect
      GameState.statusEffects[entityId].push({
        type: effectType,
        duration: duration || effect.duration,
        startTime: Date.now(),
        tickTimer: 0
      });
      
      // Visual feedback
      const entity = getEntityById(entityId);
      if (entity) {
        showToast(`${effect.icon} ${effect.name} applied!`, 1500, effect.color);
      }
    }

    function updateStatusEffects(dt) {
      const now = Date.now();
      
      Object.keys(GameState.statusEffects).forEach(entityId => {
        const effects = GameState.statusEffects[entityId];
        
        // Update each effect
        for (let i = effects.length - 1; i >= 0; i--) {
          const statusEffect = effects[i];
          const effectData = STATUS_EFFECTS[statusEffect.type];
          const elapsed = now - statusEffect.startTime;
          
          // Remove expired effects
          if (elapsed >= statusEffect.duration) {
            effects.splice(i, 1);
            continue;
          }
          
          // Apply effect tick damage (burn, poison)
          if (effectData.damagePerSec) {
            statusEffect.tickTimer += dt;
            if (statusEffect.tickTimer >= 1000) {
              statusEffect.tickTimer = 0;
              const entity = getEntityById(entityId);
              if (entity && entity.hp > 0) {
                entity.hp = Math.max(0, entity.hp - effectData.damagePerSec);
                createDamageNumber(entity.x, entity.y - 40, effectData.damagePerSec, effectData.color);
              }
            }
          }
        }
        
        // Clean up empty arrays
        if (effects.length === 0) {
          delete GameState.statusEffects[entityId];
        }
      });
    }

    function getEntityById(entityId) {
      // Check party members
      const partyMember = GameState.party.find(p => p.id === entityId);
      if (partyMember) return partyMember;
      
      // Check enemies
      const enemy = GameState.enemies.find(e => e.id === entityId);
      if (enemy) return enemy;
      
      return null;
    }

    function getStatusEffectMultipliers(entityId) {
      const effects = GameState.statusEffects[entityId] || [];
      let speedMult = 1.0;
      let damageMult = 1.0;
      let defMult = 1.0;
      
      effects.forEach(statusEffect => {
        const effectData = STATUS_EFFECTS[statusEffect.type];
        if (effectData.speedMult !== undefined) speedMult *= effectData.speedMult;
        if (effectData.damageMult !== undefined) damageMult *= effectData.damageMult;
        if (effectData.defMult !== undefined) defMult *= effectData.defMult;
      });
      
      return { speedMult, damageMult, defMult };
    }

    function renderStatusEffects() {
      const canvas = document.getElementById('gameCanvas');
      const ctx = canvas.getContext('2d');
      
      // Render status effect icons on enemies and party
      Object.keys(GameState.statusEffects).forEach(entityId => {
        const entity = getEntityById(entityId);
        if (!entity) return;
        
        const effects = GameState.statusEffects[entityId];
        const screenX = entity.x - GameState.camera.x;
        const screenY = entity.y - 60;
        
        // Don't render if off-screen
        if (screenX < -100 || screenX > canvas.width + 100) return;
        
        effects.forEach((statusEffect, index) => {
          const effectData = STATUS_EFFECTS[statusEffect.type];
          const iconX = screenX + (index * 16) - (effects.length * 8);
          const iconY = screenY;
          
          // Icon background
          ctx.fillStyle = effectData.color;
          ctx.globalAlpha = 0.7;
          ctx.fillRect(iconX - 8, iconY - 8, 16, 16);
          ctx.globalAlpha = 1.0;
          
          // Icon
          ctx.font = '12px Arial';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(effectData.icon, iconX, iconY);
          
          // Duration bar
          const elapsed = Date.now() - statusEffect.startTime;
          const percent = 1 - (elapsed / statusEffect.duration);
          ctx.fillStyle = effectData.color;
          ctx.fillRect(iconX - 8, iconY + 8, 16 * percent, 2);
        });
      });
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // AAA PHASE 1: SKILL COMBO SYSTEM
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const SKILL_COMBOS = {
      // Element combos
      'ICE-PHYSICAL': { name: 'Shatter', bonus: 2.0, description: 'Freeze then shatter for 2x damage', particles: '#66ccff' },
      'FIRE-PHYSICAL': { name: 'Ignite', bonus: 1.5, description: 'Burn then strike for 1.5x damage', particles: '#ff6600' },
      'LIGHTNING-ICE': { name: 'Superconductor', bonus: 2.5, description: 'Lightning + Ice = massive damage', particles: '#00ffff' },
      'SHADOW-LIGHT': { name: 'Eclipse', bonus: 3.0, description: 'Shadow + Light = devastating power', particles: '#ff00ff' },
      'PHYSICAL-FIRE': { name: 'Blazing Blade', bonus: 1.75, description: 'Strike then burn', particles: '#ff9900' },
      'ARCANE-SHADOW': { name: 'Void Rift', bonus: 2.25, description: 'Arcane + Shadow opens rift', particles: '#9900ff' },
      
      // Synergy bonuses
      'FIRE-FIRE': { name: 'Inferno', bonus: 1.3, description: 'Double fire skills', particles: '#ff3300' },
      'ICE-ICE': { name: 'Deep Freeze', bonus: 1.3, description: 'Double ice skills', particles: '#0099ff' },
      'LIGHTNING-LIGHTNING': { name: 'Chain Lightning', bonus: 1.4, description: 'Double lightning', particles: '#ffff00' }
    };

    function checkSkillCombo(currentSkill) {
      const now = Date.now();
      const timeSinceLastSkill = now - GameState.lastSkillCastTime;
      
      // Check if within combo window
      if (timeSinceLastSkill > GameState.skillComboWindow) {
        GameState.lastSkillCast = currentSkill.element;
        GameState.lastSkillCastTime = now;
        return 1.0; // No combo
      }
      
      // Check for combo
      const comboKey1 = `${GameState.lastSkillCast}-${currentSkill.element}`;
      const comboKey2 = `${currentSkill.element}-${GameState.lastSkillCast}`;
      
      const combo = SKILL_COMBOS[comboKey1] || SKILL_COMBOS[comboKey2];
      
      if (combo) {
        // Skill combo activated!
        showToast(`üí• ${combo.name} Combo! ${combo.bonus}x damage!`, 2500, combo.particles);
        screenShake(12, 300);
        
        // Combo particles
        const leader = GameState.party[0];
        for (let i = 0; i < 25; i++) {
          const angle = Math.random() * Math.PI * 2;
          const speed = 3 + Math.random() * 5;
          GameState.projectiles.push({
            x: leader.x,
            y: leader.y - 20,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed - 3,
            damage: 0,
            color: combo.particles,
            type: 'particle',
            radius: 6,
            lifetime: 1000,
            createdAt: Date.now()
          });
        }
        
        AudioSystem.playSound('skillCombo');
        
        // Update last skill
        GameState.lastSkillCast = currentSkill.element;
        GameState.lastSkillCastTime = now;
        
        return combo.bonus;
      }
      
      // No combo, just update last skill
      GameState.lastSkillCast = currentSkill.element;
      GameState.lastSkillCastTime = now;
      return 1.0;
    }

    function getSkillSynergy(skill1, skill2) {
      // Check if skills synergize
      if (skill1.element === skill2.element) {
        return 1.2; // Same element = 20% bonus
      }
      
      // Opposite elements clash
      if ((skill1.element === 'FIRE' && skill2.element === 'ICE') ||
          (skill1.element === 'ICE' && skill2.element === 'FIRE') ||
          (skill1.element === 'LIGHT' && skill2.element === 'SHADOW') ||
          (skill1.element === 'SHADOW' && skill2.element === 'LIGHT')) {
        return 0.8; // 20% penalty
      }
      
      return 1.0; // No synergy
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // AAA PHASE 2: SKILL TREE SYSTEM
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const SKILL_TREE_DATA = {
      A1: {
        combat: {
          name: 'Combat Mastery',
          nodes: {
            node1: { name: 'Attack +10%', bonus: { atk: 0.1 }, cost: 1, requires: null },
            node2: { name: 'Crit Chance +5%', bonus: { crit: 0.05 }, cost: 1, requires: 'node1' },
            node3: { name: 'Attack Speed +15%', bonus: { atkSpeed: 0.15 }, cost: 2, requires: 'node2' },
            node4: { name: 'Lifesteal 10%', bonus: { lifesteal: 0.1 }, cost: 3, requires: 'node3' },
            node5: { name: 'Crit Damage +50%', bonus: { critDmg: 0.5 }, cost: 4, requires: 'node4' }
          }
        },
        defense: {
          name: 'Tank Mastery',
          nodes: {
            node1: { name: 'HP +20%', bonus: { hp: 0.2 }, cost: 1, requires: null },
            node2: { name: 'Defense +10%', bonus: { def: 0.1 }, cost: 1, requires: 'node1' },
            node3: { name: 'Block +25%', bonus: { blockPower: 0.25 }, cost: 2, requires: 'node2' },
            node4: { name: 'Damage Reflect 15%', bonus: { reflect: 0.15 }, cost: 3, requires: 'node3' },
            node5: { name: 'Immortal (Survive fatal hit once)', bonus: { immortal: true }, cost: 5, requires: 'node4' }
          }
        },
        ultimate: {
          name: 'Ultimate Power',
          nodes: {
            node1: { name: 'All Stats +5%', bonus: { allStats: 0.05 }, cost: 2, requires: null },
            node2: { name: 'Skill Damage +20%', bonus: { skillDmg: 0.2 }, cost: 2, requires: 'node1' },
            node3: { name: 'Rage Duration +50%', bonus: { rageDuration: 0.5 }, cost: 3, requires: 'node2' },
            node4: { name: 'Berserk Mode (Low HP = High Damage)', bonus: { berserk: true }, cost: 4, requires: 'node3' },
            node5: { name: 'God Mode (All bonuses 2x)', bonus: { godMode: true }, cost: 10, requires: 'node4' }
          }
        }
      },
      Missy: {
        precision: {
          name: 'Precision Arts',
          nodes: {
            node1: { name: 'Accuracy +10%', bonus: { accuracy: 0.1 }, cost: 1, requires: null },
            node2: { name: 'Pierce Chance +15%', bonus: { pierce: 0.15 }, cost: 1, requires: 'node1' },
            node3: { name: 'Headshot Bonus +30%', bonus: { headshot: 0.3 }, cost: 2, requires: 'node2' },
            node4: { name: 'Multishot (Hit 2 enemies)', bonus: { multishot: 2 }, cost: 3, requires: 'node3' },
            node5: { name: 'Perfect Shot (Always crit)', bonus: { perfectShot: true }, cost: 5, requires: 'node4' }
          }
        },
        luck: {
          name: 'Fortune Favored',
          nodes: {
            node1: { name: 'Gold Find +20%', bonus: { goldFind: 0.2 }, cost: 1, requires: null },
            node2: { name: 'Rare Drop +10%', bonus: { rareDrop: 0.1 }, cost: 1, requires: 'node1' },
            node3: { name: 'Double XP Chance 25%', bonus: { doubleXp: 0.25 }, cost: 2, requires: 'node2' },
            node4: { name: 'Lucky Strike (Random 10x damage)', bonus: { luckyStrike: 0.1 }, cost: 3, requires: 'node3' },
            node5: { name: 'Jackpot (All rewards 5x)', bonus: { jackpot: true }, cost: 5, requires: 'node4' }
          }
        },
        divine: {
          name: 'Divine Grace',
          nodes: {
            node1: { name: 'Heal +10%', bonus: { healPower: 0.1 }, cost: 1, requires: null },
            node2: { name: 'Holy Damage +15%', bonus: { holyDmg: 0.15 }, cost: 1, requires: 'node1' },
            node3: { name: 'Angel Wings (Flight)', bonus: { flight: true }, cost: 2, requires: 'node2' },
            node4: { name: 'Resurrection (Auto-revive once)', bonus: { resurrection: true }, cost: 4, requires: 'node3' },
            node5: { name: 'Seraph Form (God-tier)', bonus: { seraph: true }, cost: 10, requires: 'node4' }
          }
        }
      },
      Unique: {
        tech: {
          name: 'Tech Warfare',
          nodes: {
            node1: { name: 'Beam Damage +15%', bonus: { beamDmg: 0.15 }, cost: 1, requires: null },
            node2: { name: 'Laser Penetration', bonus: { laserPierce: true }, cost: 1, requires: 'node1' },
            node3: { name: 'Weapon Overcharge +25%', bonus: { overcharge: 0.25 }, cost: 2, requires: 'node2' },
            node4: { name: 'Orbital Strike Access', bonus: { orbital: true }, cost: 3, requires: 'node3' },
            node5: { name: 'Singularity Weapon', bonus: { singularity: true }, cost: 5, requires: 'node4' }
          }
        },
        energy: {
          name: 'Energy Control',
          nodes: {
            node1: { name: 'Energy Regen +20%', bonus: { energyRegen: 0.2 }, cost: 1, requires: null },
            node2: { name: 'Shield Capacity +30%', bonus: { shieldCap: 0.3 }, cost: 1, requires: 'node1' },
            node3: { name: 'Plasma Damage +25%', bonus: { plasmaDmg: 0.25 }, cost: 2, requires: 'node2' },
            node4: { name: 'Overload (Convert HP to damage)', bonus: { overload: true }, cost: 3, requires: 'node3' },
            node5: { name: 'Fusion Core (Unlimited energy)', bonus: { fusionCore: true }, cost: 5, requires: 'node4' }
          }
        },
        cyber: {
          name: 'Cybernetic Enhancement',
          nodes: {
            node1: { name: 'Movement Speed +15%', bonus: { speed: 0.15 }, cost: 1, requires: null },
            node2: { name: 'Dodge Chance +10%', bonus: { dodge: 0.1 }, cost: 1, requires: 'node1' },
            node3: { name: 'Cyber Vision (See all enemies)', bonus: { cyberVision: true }, cost: 2, requires: 'node2' },
            node4: { name: 'Nano Repair (Regen HP)', bonus: { nanoRepair: 0.02 }, cost: 3, requires: 'node3' },
            node5: { name: 'Full Cyborg (Immune to status)', bonus: { fullCyborg: true }, cost: 5, requires: 'node4' }
          }
        }
      }
    };

    function unlockSkillNode(character, tree, nodeId) {
      const treeData = SKILL_TREE_DATA[character][tree];
      const node = treeData.nodes[nodeId];
      
      if (!node) return false;
      
      // Check if already unlocked
      if (GameState.skillTrees[character][tree][nodeId]) {
        showToast('‚ö†Ô∏è Already unlocked!', 1500, '#999999');
        return false;
      }
      
      // Check skill points
      if (GameState.skillPoints < node.cost) {
        showToast(`‚ö†Ô∏è Need ${node.cost} skill points!`, 1500, '#ef4444');
        return false;
      }
      
      // Check requirements
      if (node.requires && !GameState.skillTrees[character][tree][node.requires]) {
        showToast(`‚ö†Ô∏è Unlock previous node first!`, 1500, '#ef4444');
        return false;
      }
      
      // Unlock node
      GameState.skillTrees[character][tree][nodeId] = true;
      GameState.skillPoints -= node.cost;
      
      // Apply bonuses to character
      applySkillTreeBonus(character, node.bonus);
      
      showToast(`‚ú® Unlocked: ${node.name}!`, 2500, '#a78bfa');
      AudioSystem.playSound('skillUnlock');
      
      return true;
    }

    function applySkillTreeBonus(characterName, bonus) {
      const char = GameState.party.find(p => p.name === characterName);
      if (!char) return;
      
      // Apply bonuses
      if (bonus.atk) char.atk = Math.floor(char.atk * (1 + bonus.atk));
      if (bonus.def) char.def = Math.floor(char.def * (1 + bonus.def));
      if (bonus.hp) {
        char.maxHp = Math.floor(char.maxHp * (1 + bonus.hp));
        char.hp = char.maxHp;
      }
      if (bonus.speed) char.speed = (char.speed || 1) * (1 + bonus.speed);
      if (bonus.crit) char.critChance = (char.critChance || 0) + bonus.crit;
      if (bonus.critDmg) char.critDamage = (char.critDamage || 1.5) * (1 + bonus.critDmg);
      
      // Special bonuses stored as flags
      if (bonus.immortal) char.immortal = true;
      if (bonus.berserk) char.berserk = true;
      if (bonus.resurrection) char.resurrection = true;
      if (bonus.fullCyborg) char.fullCyborg = true;
    }

    function renderSkillTreeUI(character) {
      // This would be rendered in the bag system's Talents tab
      // For now, this is a placeholder for the UI rendering logic
      console.log(`Rendering skill tree for ${character}`);
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // AAA PHASE 2: CHARACTER BUILD SYSTEM
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function allocateAttributePoint(characterName, attribute) {
      if (GameState.attributePoints <= 0) {
        showToast('‚ö†Ô∏è No attribute points available!', 1500, '#ef4444');
        return false;
      }
      
      if (!GameState.attributes[characterName]) {
        showToast('‚ö†Ô∏è Invalid character!', 1500, '#ef4444');
        return false;
      }
      
      // Allocate point
      GameState.attributes[characterName][attribute]++;
      GameState.attributePoints--;
      
      // Apply stat changes to character
      applyAttributeBonuses(characterName);
      
      showToast(`‚ú® +1 ${attribute} for ${characterName}!`, 1500, '#10b981');
      AudioSystem.playSound('statUp');
      
      return true;
    }

    function applyAttributeBonuses(characterName) {
      const char = GameState.party.find(p => p.name === characterName);
      if (!char) return;
      
      const attrs = GameState.attributes[characterName];
      
      // STR: +2 ATK per point
      char.baseAtk = (char.baseAtk || 45) + (attrs.STR - 10) * 2;
      
      // DEX: +1% Crit, +0.5% Dodge per point
      char.critChance = (attrs.DEX - 5) * 0.01;
      char.dodgeChance = (attrs.DEX - 5) * 0.005;
      
      // INT: +5% Skill Damage per point
      char.skillDamageBonus = (attrs.INT - 5) * 0.05;
      
      // VIT: +10 HP per point
      char.baseMaxHp = (char.baseMaxHp || 100) + (attrs.VIT - 8) * 10;
      char.maxHp = char.baseMaxHp;
      
      // LUK: +2% Gold Find, +1% Rare Drop per point
      char.goldFindBonus = (attrs.LUK - 5) * 0.02;
      char.rareDropBonus = (attrs.LUK - 5) * 0.01;
    }

    const BUILD_PRESETS = {
      A1: {
        DPS: { STR: 25, DEX: 15, INT: 5, VIT: 10, LUK: 5 },
        Tank: { STR: 15, DEX: 5, INT: 5, VIT: 25, LUK: 5 },
        Hybrid: { STR: 15, DEX: 10, INT: 10, VIT: 15, LUK: 5 }
      },
      Missy: {
        DPS: { STR: 10, DEX: 25, INT: 10, VIT: 10, LUK: 15 },
        Crit: { STR: 15, DEX: 30, INT: 5, VIT: 10, LUK: 10 },
        Treasure: { STR: 10, DEX: 10, INT: 5, VIT: 10, LUK: 35 }
      },
      Unique: {
        Mage: { STR: 5, DEX: 10, INT: 30, VIT: 10, LUK: 5 },
        Balanced: { STR: 12, DEX: 12, INT: 12, VIT: 12, LUK: 12 },
        Glass: { STR: 5, DEX: 15, INT: 35, VIT: 5, LUK: 10 }
      }
    };

    function applyBuildPreset(characterName, presetName) {
      const preset = BUILD_PRESETS[characterName][presetName];
      if (!preset) {
        showToast('‚ö†Ô∏è Invalid build preset!', 1500, '#ef4444');
        return false;
      }
      
      // Reset and apply preset
      GameState.attributes[characterName] = { ...preset };
      applyAttributeBonuses(characterName);
      
      showToast(`‚úÖ Applied ${presetName} build!`, 2000, '#10b981');
      return true;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // AAA PHASE 2: CRAFTING & ENHANCEMENT SYSTEM
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const CRAFTING_RECIPES = {
      health_potion: { name: 'Health Potion', materials: { iron: 2, herbs: 3 }, result: 'item_potion_001', cost: 50 },
      mana_potion: { name: 'Mana Potion', materials: { crystal: 2, water: 1 }, result: 'item_potion_002', cost: 75 },
      steel_sword: { name: 'Steel Sword', materials: { iron: 5, coal: 3 }, result: 'gear_sword_001', cost: 200 },
      fire_sword: { name: 'Fire Blade', materials: { iron: 5, fire_gem: 1 }, result: 'gear_sword_fire', cost: 500 }
    };

    function craftItem(recipeId) {
      const recipe = CRAFTING_RECIPES[recipeId];
      if (!recipe) return false;
      
      // Check materials
      for (const [material, amount] of Object.entries(recipe.materials)) {
        const has = GameState.craftingMaterials[material] || 0;
        if (has < amount) {
          showToast(`‚ö†Ô∏è Need ${amount} ${material} (have ${has})`, 2000, '#ef4444');
          return false;
        }
      }
      
      // Check gold
      if (GameState.gold < recipe.cost) {
        showToast(`‚ö†Ô∏è Need ${recipe.cost} gold!`, 2000, '#ef4444');
        return false;
      }
      
      // Consume materials and gold
      for (const [material, amount] of Object.entries(recipe.materials)) {
        GameState.craftingMaterials[material] -= amount;
      }
      GameState.gold -= recipe.cost;
      
      // Add crafted item
      GameState.craftedItems.push({ id: recipe.result, craftedAt: Date.now() });
      
      showToast(`‚úÖ Crafted ${recipe.name}!`, 2500, '#10b981');
      AudioSystem.playSound('craft');
      
      return true;
    }

    function enhanceGear(itemId) {
      // Find item in inventory
      const item = GameState.inventory.gear.find(g => g.id === itemId);
      if (!item) return false;
      
      // Enhancement costs increase with level
      const currentLevel = item.enhanceLevel || 0;
      const cost = (currentLevel + 1) * 500;
      
      if (GameState.gold < cost) {
        showToast(`‚ö†Ô∏è Need ${cost} gold to enhance!`, 2000, '#ef4444');
        return false;
      }
      
      // Enhance item
      item.enhanceLevel = currentLevel + 1;
      item.attack = Math.floor((item.attack || 0) * 1.1); // 10% increase
      item.defense = Math.floor((item.defense || 0) * 1.1);
      item.hp = Math.floor((item.hp || 0) * 1.1);
      
      GameState.gold -= cost;
      
      showToast(`‚ú® Enhanced ${item.name} to +${item.enhanceLevel}!`, 2500, '#a78bfa');
      AudioSystem.playSound('enhance');
      
      return true;
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PHASE 3: QUEST SYSTEM
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function initializeQuests() {
      // Auto-start the first main quest
      if (GameState.activeQuests.length === 0) {
        startQuest('main_1');
      }
    }

    function startQuest(questId) {
      const questTemplate = [...QUESTS.main, ...QUESTS.side, ...QUESTS.daily].find(q => q.id === questId);
      if (!questTemplate || GameState.completedQuests.has(questId)) return;

      const quest = JSON.parse(JSON.stringify(questTemplate));
      GameState.activeQuests.push(quest);
      GameState.questProgress[questId] = { objectives: quest.objectives };
      
      showToast(`üìú New Quest: ${quest.name}`, 3000, '#22d3ee');
    }

    function updateQuestProgress(type, value = 1) {
      GameState.activeQuests.forEach(quest => {
        quest.objectives.forEach(obj => {
          if (obj.type === type) {
            obj.current = Math.min(obj.current + value, obj.count || 1);
            
            // Check if quest is complete
            if (quest.objectives.every(o => o.current >= (o.count || 1))) {
              completeQuest(quest.id);
            }
          }
        });
      });
    }

    function completeQuest(questId) {
      const questIndex = GameState.activeQuests.findIndex(q => q.id === questId);
      if (questIndex === -1) return;

      const quest = GameState.activeQuests[questIndex];
      GameState.activeQuests.splice(questIndex, 1);
      GameState.completedQuests.add(questId);
      
      // Give rewards
      if (quest.rewards.gold) {
        GameState.gold += quest.rewards.gold;
        showToast(`+${quest.rewards.gold} üí∞ Gold`, 2000, '#fde047');
      }
      if (quest.rewards.xp) {
        gainXP(quest.rewards.xp);
      }
      if (quest.rewards.item) {
        showToast(`+1 ${quest.rewards.item}`, 2000, '#a855f7');
      }
      
      // Unlock portal if specified
      if (quest.unlockPortal) {
        unlockPortal(quest.unlockPortal);
      }
      
      // Check achievement
      checkAchievement('QUEST_COMPLETED');
      
      // Start next quest if it exists
      if (quest.unlocks) {
        setTimeout(() => startQuest(quest.unlocks), 1000);
      }
      
      showToast(`‚úÖ Quest Complete: ${quest.name}`, 3000, '#10b981');
    }

    function unlockPortal(portalId) {
      const portal = ZONE_PORTALS.find(p => p.id === portalId);
      if (portal) {
        portal.unlocked = true;
        GameState.unlockedPortals.add(portalId);
        showToast(`üåÄ Portal Unlocked: ${portal.name}`, 3000, '#a855f7');
      }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PHASE 3: LEVEL & XP SYSTEM
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function gainXP(amount) {
      GameState.xp += amount;
      
      // Check for level up
      const xpNeeded = GameState.level * 100; // Simple formula: level * 100 XP per level
      if (GameState.xp >= xpNeeded) {
        GameState.level++;
        GameState.xp -= xpNeeded;
        
        // Level up rewards
        GameState.party.forEach(char => {
          char.maxHp += 20;
          char.hp = char.maxHp;
          char.atk += 5;
          char.def += 3;
        });
        
        showToast(`‚¨ÜÔ∏è LEVEL UP! Now Level ${GameState.level}!`, 3000, '#fde047');
        
        // AAA: Grant skill points and attribute points on level up
        GameState.skillPoints += 1;
        GameState.attributePoints += 3; // 3 attribute points per level
        showToast(`üåü +1 Skill Point +3 Attribute Points!`, 2000, '#a78bfa');
        
        // Check level achievements
        checkAchievement('LEVEL_5', GameState.level);
        checkAchievement('LEVEL_10', GameState.level);
        checkAchievement('LEVEL_20', GameState.level);
        
        // Play sound
        AudioSystem.playSound('levelup');
      }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PHASE 3: ACHIEVEMENT SYSTEM
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const ACHIEVEMENTS = {
      FIRST_ENEMY: { id: 'FIRST_ENEMY', name: 'First Blood', description: 'Defeat your first enemy', icon: '‚öîÔ∏è' },
      ENEMY_SLAYER_10: { id: 'ENEMY_SLAYER_10', name: 'Slayer', description: 'Defeat 10 enemies', icon: 'üíÄ', requirement: 10 },
      ENEMY_SLAYER_50: { id: 'ENEMY_SLAYER_50', name: 'Warrior', description: 'Defeat 50 enemies', icon: '‚öîÔ∏è', requirement: 50 },
      ENEMY_SLAYER_100: { id: 'ENEMY_SLAYER_100', name: 'Champion', description: 'Defeat 100 enemies', icon: 'üëë', requirement: 100 },
      QUEST_COMPLETED: { id: 'QUEST_COMPLETED', name: 'Quest Master', description: 'Complete your first quest', icon: 'üìú' },
      LEVEL_5: { id: 'LEVEL_5', name: 'Rising Star', description: 'Reach Level 5', icon: '‚≠ê', requirement: 5 },
      LEVEL_10: { id: 'LEVEL_10', name: 'Hero', description: 'Reach Level 10', icon: 'üåü', requirement: 10 },
      LEVEL_20: { id: 'LEVEL_20', name: 'Legend', description: 'Reach Level 20', icon: '‚ú®', requirement: 20 },
      GOLD_1000: { id: 'GOLD_1000', name: 'Wealthy', description: 'Accumulate 1000 gold', icon: 'üí∞', requirement: 1000 },
      GOLD_10000: { id: 'GOLD_10000', name: 'Rich', description: 'Accumulate 10000 gold', icon: 'üíé', requirement: 10000 },
      ALL_PETS: { id: 'ALL_PETS', name: 'Pet Collector', description: 'Collect all pets', icon: 'üêæ' },
      ALL_VEHICLES: { id: 'ALL_VEHICLES', name: 'Vehicle Collector', description: 'Collect all vehicles', icon: 'üöó' },
      ALL_ROBOTS: { id: 'ALL_ROBOTS', name: 'Robot Army', description: 'Collect all robots', icon: 'ü§ñ' },
      PORTAL_MASTER: { id: 'PORTAL_MASTER', name: 'Portal Master', description: 'Unlock all portals', icon: 'üåÄ' },
      RAGE_MASTER: { id: 'RAGE_MASTER', name: 'Rage Unleashed', description: 'Activate Rage Mode', icon: 'üò°' },
      SKILL_MASTER: { id: 'SKILL_MASTER', name: 'Skill Expert', description: 'Cast 100 skills', icon: '‚ú®', requirement: 100 }
    };

    function checkAchievement(achievementKey, currentValue) {
      const achievement = ACHIEVEMENTS[achievementKey];
      if (!achievement || GameState.achievements.has(achievement.id)) return;

      let unlocked = false;

      // Check if achievement is unlocked
      if (!achievement.requirement) {
        // Simple boolean achievement
        unlocked = true;
      } else {
        // Progress-based achievement
        if (!GameState.achievementProgress[achievementKey]) {
          GameState.achievementProgress[achievementKey] = 0;
        }
        GameState.achievementProgress[achievementKey] = currentValue || GameState.achievementProgress[achievementKey];
        unlocked = GameState.achievementProgress[achievementKey] >= achievement.requirement;
      }

      if (unlocked) {
        GameState.achievements.add(achievement.id);
        showToast(`üèÜ Achievement: ${achievement.name}`, 4000, '#fde047');
      }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PHASE 4: SAVE/LOAD SYSTEM
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    function saveGame() {
      try {
        const saveData = {
          version: '1.0',
          timestamp: Date.now(),
          gameState: {
            party: GameState.party,
            camera: GameState.camera,
            currentZone: GameState.currentZone,
            gold: GameState.gold,
            gems: GameState.gems,
            keys: GameState.keys,
            tickets: GameState.tickets,
            level: GameState.level,
            xp: GameState.xp,
            equipped: GameState.equipped,
            currentCharacter: GameState.currentCharacter,
            equippedSkins: GameState.equippedSkins,
            discoveredBuildings: Array.from(GameState.discoveredBuildings),
            unlockedPortals: Array.from(GameState.unlockedPortals),
            activeQuests: GameState.activeQuests,
            completedQuests: Array.from(GameState.completedQuests),
            questProgress: GameState.questProgress,
            discoveredZones: Array.from(GameState.discoveredZones),
            achievements: Array.from(GameState.achievements),
            achievementProgress: GameState.achievementProgress,
            collectedItems: Array.from(GameState.collectedItems),
            foundSecrets: Array.from(GameState.foundSecrets),
            tutorialComplete: GameState.tutorialComplete,
            tutorialStep: GameState.tutorialStep,
            inventory: GameState.inventory
          }
        };

        localStorage.setItem('cityMapGameSave', JSON.stringify(saveData));
        GameState.lastSaveTime = Date.now();
        showToast('üíæ Game Saved!', 2000, '#10b981');
        return true;
      } catch (error) {
        console.error('Save failed:', error);
        showToast('‚ùå Save Failed', 2000, '#ef4444');
        return false;
      }
    }

    function loadGame() {
      try {
        const saveDataString = localStorage.getItem('cityMapGameSave');
        if (!saveDataString) return false;

        const saveData = JSON.parse(saveDataString);
        const saved = saveData.gameState;

        // Restore game state
        GameState.party = saved.party || GameState.party;
        GameState.camera = saved.camera || GameState.camera;
        GameState.currentZone = saved.currentZone || GameState.currentZone;
        GameState.gold = saved.gold || 0;
        GameState.gems = saved.gems || 0;
        GameState.keys = saved.keys || GameState.keys;
        GameState.tickets = saved.tickets || 0;
        GameState.level = saved.level || 1;
        GameState.xp = saved.xp || 0;
        GameState.equipped = saved.equipped || GameState.equipped;
        GameState.currentCharacter = saved.currentCharacter || 'Missy';
        GameState.equippedSkins = saved.equippedSkins || GameState.equippedSkins;
        GameState.discoveredBuildings = new Set(saved.discoveredBuildings || []);
        GameState.unlockedPortals = new Set(saved.unlockedPortals || ['portal_train']);
        GameState.activeQuests = saved.activeQuests || [];
        GameState.completedQuests = new Set(saved.completedQuests || []);
        GameState.questProgress = saved.questProgress || {};
        GameState.discoveredZones = new Set(saved.discoveredZones || ['ENTRY']);
        GameState.achievements = new Set(saved.achievements || []);
        GameState.achievementProgress = saved.achievementProgress || {};
        GameState.collectedItems = new Set(saved.collectedItems || []);
        GameState.foundSecrets = new Set(saved.foundSecrets || []);
        GameState.tutorialComplete = saved.tutorialComplete || false;
        GameState.tutorialStep = saved.tutorialStep || 0;
        if (saved.inventory) GameState.inventory = saved.inventory;

        // Sync portal unlocked states
        ZONE_PORTALS.forEach(portal => {
          portal.unlocked = GameState.unlockedPortals.has(portal.id);
        });

        showToast('‚úÖ Game Loaded!', 2000, '#10b981');
        return true;
      } catch (error) {
        console.error('Load failed:', error);
        showToast('‚ùå Load Failed', 2000, '#ef4444');
        return false;
      }
    }

    function autoSave() {
      if (GameState.autoSaveEnabled) {
        saveGame();
      }
    }

    // Auto-save every 30 seconds
    setInterval(autoSave, GameState.autoSaveInterval);

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PHASE 5: TUTORIAL SYSTEM
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const TUTORIAL_STEPS = [
      { step: 0, title: 'Welcome!', text: 'Use Arrow Keys or WASD to move. Press E to interact.', trigger: 'movement' },
      { step: 1, title: 'Combat Basics', text: 'Press Attack button to fight enemies!', trigger: 'attack' },
      { step: 2, title: 'Skills', text: 'Press S1/S2/S3 to cast powerful skills!', trigger: 'skill' },
      { step: 3, title: 'Bag System', text: 'Press Bag button to open inventory!', trigger: 'bag' },
      { step: 4, title: 'Companions', text: 'Summon pets and robots to help you fight!', trigger: 'pet' },
      { step: 5, title: 'Portals', text: 'Complete quests to unlock portals to new zones!', trigger: 'portal' },
      { step: 6, title: 'Ready!', text: 'You\'re ready to explore! Good luck!', trigger: 'complete' }
    ];

    function showTutorial() {
      if (GameState.tutorialComplete) return;

      const currentStep = TUTORIAL_STEPS[GameState.tutorialStep];
      if (!currentStep) {
        GameState.tutorialComplete = true;
        return;
      }

      showToast(`üí° ${currentStep.title}: ${currentStep.text}`, 5000, '#3b82f6');
    }

    function advanceTutorial(trigger) {
      if (GameState.tutorialComplete) return;

      const currentStep = TUTORIAL_STEPS[GameState.tutorialStep];
      if (currentStep && currentStep.trigger === trigger) {
        GameState.tutorialStep++;
        setTimeout(showTutorial, 1000);
      }
    }

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PHASE 5: AUDIO SYSTEM (Placeholder)
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const AudioSystem = {
      bgMusic: null,
      sfxVolume: 0.8,
      musicVolume: 0.7,
      
      playSound(type) {
        if (!GameState.audioEnabled) return;
        
        // Placeholder for actual audio implementation
        // Would use Web Audio API or Howler.js in production
        console.log(`üîä Playing sound: ${type}`);
      },
      
      playMusic(track) {
        if (!GameState.audioEnabled) return;
        console.log(`üéµ Playing music: ${track}`);
      },
      
      stopMusic() {
        console.log('üéµ Music stopped');
      },
      
      setVolume(type, volume) {
        if (type === 'sfx') this.sfxVolume = volume;
        if (type === 'music') this.musicVolume = volume;
      }
    };

    // Sound effects mapping
    const SOUNDS = {
      attack: 'swoosh',
      hit: 'impact',
      skill: 'magic',
      levelup: 'fanfare',
      coin: 'pickup',
      button: 'click',
      portal: 'teleport',
      achievement: 'unlock'
    };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // PHASE 4: PERFORMANCE MONITORING
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    const PerformanceMonitor = {
      fps: 60,
      frameCount: 0,
      lastFpsUpdate: performance.now(),
      renderTime: 0,
      updateTime: 0,
      
      update() {
        this.frameCount++;
        const now = performance.now();
        if (now - this.lastFpsUpdate >= 1000) {
          this.fps = this.frameCount;
          this.frameCount = 0;
          this.lastFpsUpdate = now;
        }
      },
      
      startMeasure(label) {
        this[`${label}Start`] = performance.now();
      },
      
      endMeasure(label) {
        this[`${label}Time`] = performance.now() - this[`${label}Start`];
      },
      
      getStats() {
        return {
          fps: this.fps,
          renderTime: this.renderTime.toFixed(2),
          updateTime: this.updateTime.toFixed(2),
          totalTime: (this.renderTime + this.updateTime).toFixed(2)
        };
      }
    };

    // ============================
    // GAME LOOP
    // ============================

    let lastTime = performance.now();

    function gameLoop() {
      // PHASE 4: Performance monitoring
      PerformanceMonitor.update();
      PerformanceMonitor.startMeasure('update');
      
      const now = performance.now();
      const dt = Math.min((now - lastTime) / 1000, 0.1); // Delta time in seconds, capped
      lastTime = now;

      GameState.animTime += dt * 60; // Animation time tracker

      updateParty();
      updateIndoorCombat(dt);
      updatePets(dt);
      
      // Update sprite animations for all party members
      const isMoving = GameState.keys["ArrowLeft"] || GameState.keys["ArrowRight"] || 
                       GameState.keys["ArrowUp"] || GameState.keys["ArrowDown"];
      
      // PHASE 5: Tutorial trigger for movement
      if (isMoving && !GameState.tutorialComplete && GameState.tutorialStep === 0) {
        advanceTutorial('movement');
      }
      
      for (const char of GameState.party) {
        SpriteSystem.updateAnimation(char, dt * 1000, isMoving); // Pass delta in ms
      }
      
      // Update combat system
      if (GameState.mode === 'exterior') {
        updateEnemies(dt * 1000); // Pass delta in milliseconds
        updateDamageNumbers(dt * 1000);
        updateProjectiles(dt * 1000);
        updateRageShield(dt * 1000);
        updatePetRobotCombat(dt * 1000);
        updateComboSystem(dt * 1000); // AAA: Combo system
        updateStatusEffects(dt * 1000); // AAA: Status effects
      }
      
      PerformanceMonitor.endMeasure('update');
      PerformanceMonitor.startMeasure('render');
      
      render();
      
      PerformanceMonitor.endMeasure('render');
      requestAnimationFrame(gameLoop);
    }

    // ============================
    // MENU & SETTINGS SYSTEM
    // ============================

    function toggleMenu() {
      const menuPanel = document.getElementById('menuPanel');
      const settingsPanel = document.getElementById('settingsPanel');
      
      // Close settings if open
      settingsPanel.classList.remove('active');
      
      // Toggle menu
      menuPanel.classList.toggle('active');
    }

    function toggleSettings() {
      const menuPanel = document.getElementById('menuPanel');
      const settingsPanel = document.getElementById('settingsPanel');
      
      // Close menu if open
      menuPanel.classList.remove('active');
      
      // Toggle settings
      settingsPanel.classList.toggle('active');
    }

    function toggleSetting(element, settingName) {
      const toggleSwitch = element.querySelector('.toggle-switch');
      if (toggleSwitch) {
        toggleSwitch.classList.toggle('on');
        const isOn = toggleSwitch.classList.contains('on');
        showToast(`${settingName}: ${isOn ? 'ON' : 'OFF'}`);
      }
    }

    // PHASE 3: Quest Log Display
    function showQuestsLog() {
      let html = '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(20, 20, 40, 0.98); border: 2px solid rgba(167, 139, 250, 0.5); border-radius: 12px; padding: 24px; max-width: 600px; max-height: 70vh; overflow-y: auto; z-index: 10000;">';
      html += '<h2 style="color: #a78bfa; margin: 0 0 20px 0;">üìú Active Quests</h2>';
      if (GameState.activeQuests.length === 0) {
        html += '<p style="color: rgba(255,255,255,0.6);">No active quests!</p>';
      } else {
        GameState.activeQuests.forEach(q => {
          html += `<div style="background: rgba(167,139,250,0.1); border: 1px solid rgba(167,139,250,0.3); border-radius: 8px; padding: 12px; margin-bottom: 12px;">`;
          html += `<h3 style="color: #fde047; margin: 0 0 8px 0;">${q.name}</h3>`;
          html += `<p style="color: rgba(255,255,255,0.8); font-size: 14px;">${q.description}</p>`;
          html += `</div>`;
        });
      }
      html += `<p style="color: #10b981; margin-top: 20px;">‚úÖ Completed: ${GameState.completedQuests.size}</p>`;
      html += '<button onclick="this.parentElement.remove()" style="margin-top: 16px; padding: 8px 24px; background: rgba(167,139,250,0.3); border: 1px solid #a78bfa; border-radius: 6px; color: white; cursor: pointer;">Close</button>';
      html += '</div>';
      document.body.insertAdjacentHTML('beforeend', html);
    }

    // PHASE 3: Achievements Display
    function showAchievements() {
      let html = '<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(20, 20, 40, 0.98); border: 2px solid rgba(252, 211, 77, 0.5); border-radius: 12px; padding: 24px; max-width: 700px; max-height: 70vh; overflow-y: auto; z-index: 10000;">';
      html += '<h2 style="color: #fcd34d; margin: 0 0 20px 0;">üèÜ Achievements</h2>';
      html += `<p style="color: rgba(255,255,255,0.8); margin-bottom: 20px;">Unlocked: ${GameState.achievements.size} / ${Object.keys(ACHIEVEMENTS).length}</p>`;
      html += '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 12px;">';
      Object.values(ACHIEVEMENTS).forEach(ach => {
        const unlocked = GameState.achievements.has(ach.id);
        html += `<div style="background: ${unlocked ? 'rgba(252,211,77,0.2)' : 'rgba(100,100,100,0.1)'}; border: 1px solid ${unlocked ? 'rgba(252,211,77,0.5)' : 'rgba(100,100,100,0.3)'}; border-radius: 8px; padding: 12px; opacity: ${unlocked ? '1' : '0.5'};">`;
        html += `<div style="font-size: 32px; text-align: center; margin-bottom: 8px;">${ach.icon}</div>`;
        html += `<div style="color: ${unlocked ? '#fcd34d' : 'rgba(255,255,255,0.5)'}; font-weight: bold; font-size: 14px; text-align: center; margin-bottom: 4px;">${ach.name}</div>`;
        html += `<div style="color: rgba(255,255,255,0.6); font-size: 11px; text-align: center;">${ach.description}</div>`;
        html += `</div>`;
      });
      html += '</div>';
      html += '<button onclick="this.parentElement.remove()" style="margin-top: 20px; padding: 8px 24px; background: rgba(252,211,77,0.3); border: 1px solid #fcd34d; border-radius: 6px; color: white; cursor: pointer; width: 100%;">Close</button>';
      html += '</div>';
      document.body.insertAdjacentHTML('beforeend', html);
    }

    // Toggle game panels (party, controls, etc)
    function togglePanel(selector, name) {
      const panel = document.querySelector(selector);
      if (panel) {
        panel.classList.toggle('active');
        const isVisible = panel.classList.contains('active');
        showToast(`${name}: ${isVisible ? 'VISIBLE' : 'HIDDEN'}`);
        
        // Close menu after selection
        document.getElementById('menuPanel').classList.remove('active');
      }
    }

    // Toggle minimap
    function toggleMinimap() {
      const minimap = document.getElementById('minimapPanel');
      if (minimap) {
        if (minimap.style.display === 'none') {
          minimap.style.display = 'block';
          showToast('üó∫Ô∏è Minimap: VISIBLE');
        } else {
          minimap.style.display = 'none';
          showToast('üó∫Ô∏è Minimap: HIDDEN');
        }
        
        // Close menu
        document.getElementById('menuPanel').classList.remove('active');
      }
    }

    // Game speed control
    let gameSpeedMultiplier = 1.0;

    function updateGameSpeed(value) {
      gameSpeedMultiplier = parseFloat(value);
      document.getElementById('gameSpeedValue').textContent = gameSpeedMultiplier.toFixed(1) + 'x';
      showToast(`‚ö° Game speed: ${gameSpeedMultiplier.toFixed(1)}x`);
    }

    // ============================
    // INITIALIZATION
    // ============================

    window.onload = function () {
      showTinyLog("üéÆ City Map Game loaded! Press ‚Üí to explore!");
      showToast("üéÆ Welcome to the City!");
      updateGoldDisplay();
      updateBetDisplay();
      
      // PHASE 3-5: Initialize all systems
      loadGame(); // Try to load saved game
      initializeQuests(); // Start first quest
      showTutorial(); // Show first tutorial step
      
      gameLoop();
      
      // Setup menu and settings button listeners
      document.getElementById('menuBtn').addEventListener('click', toggleMenu);
      document.getElementById('settingsBtn').addEventListener('click', toggleSettings);
      
      // Setup game speed slider
      const speedSlider = document.getElementById('gameSpeedSlider');
      if (speedSlider) {
        speedSlider.addEventListener('input', (e) => {
          updateGameSpeed(e.target.value);
        });
      }
      
      // Close panels on ESC
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          document.getElementById('menuPanel').classList.remove('active');
          document.getElementById('settingsPanel').classList.remove('active');
        }
      });
    };

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // BAG SYSTEM INTEGRATION
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    // Export GameState for parent window access
    window.GameState = GameState;

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // MINIMAL BAG SYSTEM - CORE FUNCTIONALITY
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    window.BagSystem = {
      isOpen: false,
      activeTab: 'items',

      open() {
        document.getElementById('bagWindow').classList.add('open');
        this.isOpen = true;
        GameState.bagOpen = true;
        this.renderTabs();
        this.renderTab(this.activeTab);
        showToast('üéí Bag opened!');
        
        // PHASE 5: Tutorial trigger
        advanceTutorial('bag');
      },

      close() {
        document.getElementById('bagWindow').classList.remove('open');
        this.isOpen = false;
        GameState.bagOpen = false;
      },

      toggle() {
        this.isOpen ? this.close() : this.open();
      },

      renderTabs() {
        const tabsStrip = document.getElementById('bagTabsStrip');
        const tabs = [
          { id: 'items', icon: 'üì¶', label: 'Items' },
          { id: 'gear', icon: '‚öîÔ∏è', label: 'Gear' },
          { id: 'team', icon: 'üë•', label: 'Team' },
          { id: 'pets', icon: 'üêæ', label: 'Pets' },
          { id: 'skins', icon: 'üë§', label: 'Skins' },
          { id: 'talents', icon: '‚≠ê', label: 'Talents' },
          { id: 'vehicles', icon: 'üöó', label: 'Vehicles' },
          { id: 'ai', icon: 'ü§ñ', label: 'AI' },
          { id: 'alchemy', icon: '‚öóÔ∏è', label: 'Alchemy' },
          { id: 'skills', icon: 'üî∞', label: 'Skills' },
          { id: 'spirit', icon: '‚ú®', label: 'Spirit' },
          { id: 'supernatural', icon: 'üîÆ', label: 'Supernatural' },
          { id: 'quests', icon: 'üìú', label: 'Quests' },
          { id: 'map', icon: 'üó∫Ô∏è', label: 'Map' },
          { id: 'shop', icon: 'üè™', label: 'Shop' },
          { id: 'settings', icon: '‚öôÔ∏è', label: 'Settings' }
        ];

        tabsStrip.innerHTML = tabs.map(tab => `
          <div class="bag-tab ${tab.id === this.activeTab ? 'active' : ''}" onclick="window.BagSystem.renderTab('${tab.id}')">
            <span style="font-size: 11px;">${tab.icon}</span>
            <span style="font-size: 8px;">${tab.label}</span>
          </div>
        `).join('');
      },

      renderTab(tabId) {
        this.activeTab = tabId;
        this.renderTabs();
        
        if (tabId === 'items') this.renderItemsTab();
        else if (tabId === 'gear') this.renderGearTab();
        else if (tabId === 'team') this.renderTeamTab();
        else if (tabId === 'pets') this.renderPetsTab();
        else if (tabId === 'skins') this.renderSkinsTab();
        else if (tabId === 'talents') this.renderTalentsTab();
        else if (tabId === 'vehicles') this.renderVehiclesTab();
        else if (tabId === 'ai') this.renderAITab();
        else if (tabId === 'alchemy') this.renderAlchemyTab();
        else if (tabId === 'skills') this.renderSkillsTab();
        else if (tabId === 'spirit') this.renderSpiritTab();
        else if (tabId === 'supernatural') this.renderSupernaturalTab();
        else if (tabId === 'quests') this.renderQuestsTab();
        else if (tabId === 'map') this.renderMapTab();
        else if (tabId === 'shop') this.renderShopTab();
        else if (tabId === 'settings') this.renderSettingsTab();
      },

      renderItemsTab() {
        const container = document.getElementById('bagContent');
        const items = GameState.inventory.items || [];
        
        container.innerHTML = `
          <h3 style="color: #4fc3f7; margin-bottom: 16px;">üì¶ Items</h3>
          <div class="items-grid">
            ${items.map(item => `
              <div class="item-card">
                <div class="item-icon">${item.icon}</div>
                <div class="item-name">${item.name}</div>
                <div class="item-description">${item.category} x${item.quantity}</div>
              </div>
            `).join('')}
          </div>
        `;
      },

      renderGearTab() {
        const container = document.getElementById('bagContent');
        const gear = GameState.inventory.gear || [];
        
        container.innerHTML = `
          <h3 style="color: #4fc3f7; margin-bottom: 16px;">‚öîÔ∏è Gear & Equipment</h3>
          <div class="items-grid">
            ${gear.map(item => `
              <div class="item-card rarity-${item.rarity}">
                <div class="item-icon">${item.icon}</div>
                <div class="item-name">${item.name}</div>
                <div class="item-stats">
                  ${item.attack ? `<span class="item-stat">‚öîÔ∏è ${item.attack}</span>` : ''}
                  ${item.defense ? `<span class="item-stat">üõ°Ô∏è ${item.defense}</span>` : ''}
                  ${item.hp ? `<span class="item-stat">‚ù§Ô∏è ${item.hp}</span>` : ''}
                </div>
              </div>
            `).join('')}
          </div>
        `;
      },

      renderSkillsTab() {
        const container = document.getElementById('bagContent');
        const skills = GameState.inventory.skills || [];
        const currentChar = GameState.currentCharacter.toUpperCase();
        const charSkills = skills.filter(s => s.characterId === currentChar);
        
        container.innerHTML = `
          <h3 style="color: #4fc3f7; margin-bottom: 16px;">üî∞ ${GameState.currentCharacter} Skills (${charSkills.length} Total)</h3>
          <p style="color: rgba(207, 227, 255, 0.6); margin-bottom: 12px; font-size: 12px;">
            Slots 1-3 mapped to S1, S2, S3 HUD buttons. Additional skills available for manual casting.
          </p>
          <div class="items-grid">
            ${charSkills.map(skill => `
              <div class="item-card rarity-${skill.tier}">
                <div class="item-icon">${skill.icon}</div>
                <div class="item-name">${skill.name}</div>
                <div class="item-description">${skill.description}</div>
                <div class="item-stats">
                  <span class="item-stat">üí• ${skill.damage}</span>
                  <span class="item-stat">‚è±Ô∏è ${skill.cooldown}s</span>
                  ${skill.slot ? `<span class="item-stat">üìç S${skill.slot}</span>` : '<span class="item-stat" style="opacity: 0.5;">üìç Extra</span>'}
                  <span class="item-stat">${skill.element}</span>
                </div>
              </div>
            `).join('')}
          </div>
        `;
      },

      renderPetsTab() {
        const container = document.getElementById('bagContent');
        const pets = GameState.inventory.pets || [];
        const equipped = GameState.equipped.pet;
        
        container.innerHTML = `
          <h3 style="color: #4fc3f7; margin-bottom: 16px;">üêæ Pets (${pets.length} Available)</h3>
          ${equipped ? `
            <div style="margin-bottom: 16px; padding: 12px; background: rgba(56, 239, 125, 0.1); border: 2px solid rgba(56, 239, 125, 0.4); border-radius: 12px;">
              <strong>üü¢ Active Pet: ${equipped.icon} ${equipped.name}</strong> (${equipped.element.toUpperCase()})
              <button onclick="window.BagSystem.unequipPet()" style="margin-left: 12px; padding: 4px 12px; background: rgba(255, 59, 59, 0.3); border: 1px solid #ff3b3b; border-radius: 4px; color: white; cursor: pointer;">Recall</button>
            </div>
          ` : '<p style="color: rgba(207, 227, 255, 0.6); margin-bottom: 16px;">Click a pet to summon it!</p>'}
          <div class="items-grid">
            ${pets.map(pet => `
              <div class="item-card rarity-${pet.rarity}" onclick="window.BagSystem.equipPet('${pet.id}')">
                <div class="item-icon">${pet.icon}</div>
                <div class="item-name">${pet.name}</div>
                <div class="item-description">${pet.element.toUpperCase()} ‚Ä¢ ${pet.ability}</div>
                <div class="item-stats">
                  <span class="item-stat">‚öîÔ∏è ${pet.attack}</span>
                  <span class="item-stat">‚ù§Ô∏è ${pet.health}</span>
                  <span class="item-stat">üí® ${(pet.speed * 100).toFixed(0)}%</span>
                </div>
                <div style="font-size: 10px; margin-top: 4px; color: rgba(207, 227, 255, 0.6);">
                  ${pet.description.substring(0, 60)}...
                </div>
              </div>
            `).join('')}
          </div>
        `;
      },

      renderVehiclesTab() {
        const container = document.getElementById('bagContent');
        const vehicles = GameState.inventory.vehicles || [];
        const equipped = GameState.equipped.vehicle;
        
        container.innerHTML = `
          <h3 style="color: #4fc3f7; margin-bottom: 16px;">üöó Vehicles (${vehicles.length} Available)</h3>
          ${equipped ? `
            <div style="margin-bottom: 16px; padding: 12px; background: rgba(56, 239, 125, 0.1); border: 2px solid rgba(56, 239, 125, 0.4); border-radius: 12px;">
              <strong>üü¢ Riding: ${equipped.icon} ${equipped.name}</strong> (${(equipped.speed * 100).toFixed(0)}% speed)
              <button onclick="window.BagSystem.unequipVehicle()" style="margin-left: 12px; padding: 4px 12px; background: rgba(255, 59, 59, 0.3); border: 1px solid #ff3b3b; border-radius: 4px; color: white; cursor: pointer;">Exit</button>
            </div>
          ` : '<p style="color: rgba(207, 227, 255, 0.6); margin-bottom: 16px;">Click a vehicle to board it!</p>'}
          <div class="items-grid">
            ${vehicles.map(veh => `
              <div class="item-card" onclick="window.BagSystem.equipVehicle('${veh.id}')">
                <div class="item-icon">${veh.icon}</div>
                <div class="item-name">${veh.name}</div>
                <div class="item-description">${veh.category.toUpperCase()} ‚Ä¢ ${veh.type}</div>
                <div class="item-stats">
                  <span class="item-stat">‚ö° ${veh.speed.toFixed(1)}x</span>
                  <span class="item-stat">üéØ ${veh.agility.toFixed(1)}x</span>
                  <span class="item-stat">üõ°Ô∏è ${(veh.durability * 100).toFixed(0)}%</span>
                </div>
                <div style="font-size: 10px; margin-top: 4px; color: rgba(207, 227, 255, 0.6);">
                  ${veh.description}
                </div>
              </div>
            `).join('')}
          </div>
        `;
      },

      renderTeamTab() {
        const container = document.getElementById('bagContent');
        const party = GameState.party || [];
        
        container.innerHTML = `
          <h3 style="color: #4fc3f7; margin-bottom: 16px;">üë• Party Team</h3>
          <div class="items-grid">
            ${party.map(member => `
              <div class="item-card">
                <div style="font-size: 48px; text-align: center;">${member.id === 'a1' ? '‚öîÔ∏è' : member.id === 'missy' ? 'üòá' : 'ü§ñ'}</div>
                <div class="item-name">${member.name}</div>
                <div class="item-stats">
                  <span class="item-stat">‚ù§Ô∏è ${member.hp}/${member.maxHp}</span>
                  <span class="item-stat">‚öîÔ∏è ${member.atk}</span>
                  <span class="item-stat">üõ°Ô∏è ${member.def}</span>
                </div>
                <div class="item-description">Level ${member.level || 1} ‚Ä¢ ${member.xp || 0} XP</div>
              </div>
            `).join('')}
          </div>
        `;
      },

      renderSkinsTab() {
        const container = document.getElementById('bagContent');
        const skins = GameState.inventory.skins || { A1: [], Unique: [], Missy: [] };
        
        container.innerHTML = `
          <h3 style="color: #4fc3f7; margin-bottom: 16px;">üë§ Character Skins</h3>
          <p style="color: rgba(207, 227, 255, 0.6); margin-bottom: 16px;">Customize your characters with unlocked skins</p>
          
          ${['A1', 'Unique', 'Missy'].map(char => {
            const charSkins = skins[char] || [];
            return `
              <div style="margin-bottom: 20px;">
                <h4 style="color: #a78bfa; margin-bottom: 8px;">${char === 'A1' ? '‚öîÔ∏è' : char === 'Unique' ? 'ü§ñ' : 'üòá'} ${char} Skins (${charSkins.length})</h4>
                <div class="items-grid">
                  ${charSkins.map(skin => `
                    <div class="item-card rarity-${skin.rarity}" style="opacity: ${skin.unlocked ? 1 : 0.5};">
                      <div class="item-icon">${skin.unlocked ? '‚úÖ' : 'üîí'}</div>
                      <div class="item-name">${skin.name}</div>
                      <div class="item-description">${skin.description}</div>
                      <div style="font-size: 10px; margin-top: 4px; color: rgba(207, 227, 255, 0.6);">
                        ${skin.rarity.toUpperCase()}
                      </div>
                    </div>
                  `).join('')}
                </div>
              </div>
            `;
          }).join('')}
        `;
      },

      renderTalentsTab() {
        const container = document.getElementById('bagContent');
        container.innerHTML = `
          <h3 style="color: #4fc3f7; margin-bottom: 16px;">‚≠ê Talent Trees</h3>
          <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 12px;">
            <div class="item-card" style="background: linear-gradient(135deg, rgba(255, 100, 100, 0.1), rgba(255, 0, 0, 0.1));">
              <div class="item-icon">‚öîÔ∏è</div>
              <div class="item-name">Attack Tree</div>
              <div class="item-description">+5% ‚Üí +8% ‚Üí +12% ‚Üí +15% + Crit ‚Üí Berserker ‚Üí APEX HUNTER</div>
            </div>
            <div class="item-card" style="background: linear-gradient(135deg, rgba(100, 255, 100, 0.1), rgba(0, 255, 0, 0.1));">
              <div class="item-icon">üõ°Ô∏è</div>
              <div class="item-name">Defense Tree</div>
              <div class="item-description">+80 HP ‚Üí +120 HP ‚Üí +160 HP ‚Üí +200 HP + 10% DR ‚Üí Guardian ‚Üí FORTRESS</div>
            </div>
            <div class="item-card" style="background: linear-gradient(135deg, rgba(255, 100, 255, 0.1), rgba(200, 0, 255, 0.1));">
              <div class="item-icon">üíú</div>
              <div class="item-name">Recovery Tree</div>
              <div class="item-description">+6% LS ‚Üí +10% LS ‚Üí +15% LS + Regen ‚Üí Vampiric ‚Üí PHOENIX</div>
            </div>
            <div class="item-card" style="background: linear-gradient(135deg, rgba(100, 200, 255, 0.1), rgba(0, 150, 255, 0.1));">
              <div class="item-icon">‚ö°</div>
              <div class="item-name">Cooldown Tree</div>
              <div class="item-description">-8% CD ‚Üí -12% CD ‚Üí -15% CD + Speed ‚Üí Cascade ‚Üí TIME MASTER</div>
            </div>
            <div class="item-card" style="background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 180, 0, 0.1));">
              <div class="item-icon">üçÄ</div>
              <div class="item-name">Luck Tree</div>
              <div class="item-description">+8 Luck ‚Üí +15 Luck ‚Üí +25 Luck + Gold ‚Üí Fortune ‚Üí Jackpot ‚Üí GOLDEN TOUCH</div>
            </div>
            <div class="item-card" style="background: linear-gradient(135deg, rgba(50, 0, 100, 0.2), rgba(100, 0, 200, 0.2));">
              <div class="item-icon">üåë</div>
              <div class="item-name">Shadow Tree</div>
              <div class="item-description">+5% ATK ‚Üí +10% ATK ‚Üí +15% ATK ‚Üí +20% ATK ‚Üí SHADOW STRIKE</div>
            </div>
          </div>
        `;
      },

      renderAITab() {
        const container = document.getElementById('bagContent');
        const robots = GameState.inventory.robots || [];
        const equipped = GameState.equipped.robot;
        
        container.innerHTML = `
          <h3 style="color: #4fc3f7; margin-bottom: 16px;">ü§ñ AI Robots & Companions (${robots.length} Available)</h3>
          ${equipped ? `
            <div style="margin-bottom: 16px; padding: 12px; background: rgba(56, 239, 125, 0.1); border: 2px solid rgba(56, 239, 125, 0.4); border-radius: 12px;">
              <strong>üü¢ Active Robot: ${equipped.icon} ${equipped.name}</strong> (${equipped.tier.toUpperCase()})
              <button onclick="window.BagSystem.unequipRobot()" style="margin-left: 12px; padding: 4px 12px; background: rgba(255, 59, 59, 0.3); border: 1px solid #ff3b3b; border-radius: 4px; color: white; cursor: pointer;">Dismiss</button>
            </div>
          ` : '<p style="color: rgba(207, 227, 255, 0.6); margin-bottom: 16px;">Click a robot to summon it!</p>'}
          ${robots.length > 0 ? `
            <div class="items-grid">
              ${robots.map(robot => `
                <div class="item-card rarity-${robot.tier}" onclick="window.BagSystem.equipRobot('${robot.id}')">
                  <div class="item-icon">${robot.icon}</div>
                  <div class="item-name">${robot.name}</div>
                  <div class="item-description">${robot.type} - ${robot.tier.toUpperCase()}</div>
                  <div class="item-stats">
                    <span class="item-stat">‚ù§Ô∏è ${robot.hp}</span>
                    <span class="item-stat">‚öîÔ∏è ${robot.atk}</span>
                    <span class="item-stat">üõ°Ô∏è ${robot.def}</span>
                    <span class="item-stat">‚ö° ${robot.speed}</span>
                  </div>
                  <div style="font-size: 10px; margin-top: 4px; color: rgba(207, 227, 255, 0.6);">
                    ${robot.abilities.slice(0, 3).join(', ')}
                  </div>
                </div>
              `).join('')}
            </div>
          ` : '<p style="color: rgba(207, 227, 255, 0.6);">No robots available. Visit the shop to recruit AI companions!</p>'}
        `;
      },

      renderAlchemyTab() {
        const container = document.getElementById('bagContent');
        const items = GameState.inventory.items || [];
        
        container.innerHTML = `
          <h3 style="color: #4fc3f7; margin-bottom: 16px;">‚öóÔ∏è Alchemy & Fusion</h3>
          
          <div style="background: rgba(167, 139, 250, 0.1); border: 2px solid rgba(167, 139, 250, 0.3); border-radius: 12px; padding: 16px; margin-bottom: 16px;">
            <h4 style="color: #a78bfa; margin-bottom: 12px;">üß™ Quick Fusion</h4>
            <p style="font-size: 12px; color: rgba(207, 227, 255, 0.7); margin-bottom: 12px;">
              Click below to auto-fuse your items and get treasure boxes!
            </p>
            <div style="display: flex; gap: 8px;">
              <button onclick="window.BagSystem.quickFusion('items')" style="flex: 1; padding: 12px; background: rgba(167, 139, 250, 0.2); border: 2px solid rgba(167, 139, 250, 0.5); border-radius: 8px; color: #a78bfa; cursor: pointer; font-weight: bold;">
                ‚öóÔ∏è Fuse Items
              </button>
              <button onclick="window.BagSystem.quickFusion('gear')" style="flex: 1; padding: 12px; background: rgba(255, 182, 193, 0.2); border: 2px solid rgba(255, 182, 193, 0.5); border-radius: 8px; color: #ffb6c1; cursor: pointer; font-weight: bold;">
                ‚öîÔ∏è Fuse Gear
              </button>
            </div>
          </div>
          
          <div style="background: rgba(255, 215, 0, 0.1); border: 2px solid rgba(255, 215, 0, 0.3); border-radius: 12px; padding: 16px; margin-bottom: 16px;">
            <h4 style="color: #ffd700; margin-bottom: 8px;">üìñ Fusion Rules</h4>
            <div style="font-size: 12px; color: rgba(207, 227, 255, 0.7);">
              <p><strong>‚öóÔ∏è Standard:</strong> 3 same-type items of same rank ‚Üí 1 next rank</p>
              <p style="margin-top: 4px;"><strong>‚ú® Special:</strong> C Gear + B Gear + C Pet ‚Üí Premium loot</p>
              <p style="margin-top: 4px;"><strong>üì¶ Generic:</strong> Any 3 items ‚Üí Treasure box</p>
              <p style="margin-top: 8px; padding: 8px; background: rgba(0, 0, 0, 0.3); border-radius: 4px;">
                <strong>Treasure Box Rewards:</strong><br>
                C-Rank: 100-500g, 1-2 items<br>
                B-Rank: 500-1500g, 2-3 items<br>
                A-Rank: 1500-5000g, 2-4 items<br>
                S-Rank: 5000-15000g, 3-5 items + Guaranteed Legendary!
              </p>
            </div>
          </div>
          
          <div style="background: rgba(15, 24, 38, 0.9); border: 2px solid rgba(79, 195, 247, 0.3); border-radius: 12px; padding: 16px;">
            <h4 style="color: #4fc3f7; margin-bottom: 8px;">üì¶ Your Items</h4>
            ${items.length > 0 ? `
              <div style="font-size: 12px; color: rgba(207, 227, 255, 0.7);">
                ${items.map(item => `
                  <div style="padding: 6px; background: rgba(0, 0, 0, 0.3); margin-bottom: 4px; border-radius: 4px;">
                    ${item.icon} ${item.name} x${item.quantity}
                  </div>
                `).join('')}
              </div>
            ` : '<p style="font-size: 12px; color: rgba(207, 227, 255, 0.5);">No items available for fusion</p>'}
          </div>
        `;
      },

      quickFusion(type) {
        const items = type === 'items' ? (GameState.inventory.items || []) : (GameState.inventory.gear || []);
        
        if (items.length < 3) {
          showToast('‚ö†Ô∏è Need at least 3 items to fuse!');
          return;
        }
        
        // Simulate fusion - give treasure box reward
        const goldReward = 300 + Math.floor(Math.random() * 700);
        GameState.gold += goldReward;
        
        showToast(`‚öóÔ∏è Fusion complete! +${goldReward}g treasure!`);
        console.log(`üß™ Fused ${type}:`, items.slice(0, 3).map(i => i.name || i.id));
        
        this.renderAlchemyTab();
      },

      renderSpiritTab() {
        const container = document.getElementById('bagContent');
        const spirits = GameState.inventory.spirits || [];
        
        container.innerHTML = `
          <h3 style="color: #4fc3f7; margin-bottom: 16px;">‚ú® Spirit Companions</h3>
          ${spirits.length > 0 ? `
            <div class="items-grid">
              ${spirits.map(spirit => `
                <div class="item-card rarity-${spirit.rarity}">
                  <div class="item-icon">${spirit.icon}</div>
                  <div class="item-name">${spirit.name}</div>
                  <div class="item-description">${spirit.element.toUpperCase()} ‚Ä¢ ${spirit.rarity.toUpperCase()}</div>
                  <div class="item-stats">
                    <span class="item-stat">üí™ ${spirit.power}</span>
                    <span class="item-stat">‚öîÔ∏è ${spirit.attackDamage} dmg</span>
                  </div>
                  <div style="font-size: 10px; margin-top: 4px; color: rgba(207, 227, 255, 0.6);">
                    ${spirit.description}
                  </div>
                </div>
              `).join('')}
            </div>
          ` : '<p style="color: rgba(207, 227, 255, 0.6);">No spirits collected. Defeat enemies to capture spirits!</p>'}
        `;
      },

      renderSupernaturalTab() {
        const container = document.getElementById('bagContent');
        container.innerHTML = `
          <h3 style="color: #4fc3f7; margin-bottom: 16px;">üîÆ Supernatural Powers</h3>
          <div style="background: rgba(138, 43, 226, 0.1); border: 2px solid rgba(138, 43, 226, 0.4); border-radius: 12px; padding: 16px; margin-bottom: 16px;">
            <h4 style="color: #ba55d3; margin-bottom: 12px;">‚ö° Available Abilities</h4>
            <div style="display: grid; gap: 12px;">
              <div style="background: rgba(0, 0, 0, 0.3); padding: 12px; border-radius: 8px; border: 1px solid rgba(138, 43, 226, 0.3);">
                <strong style="color: #dda0dd;">üõ°Ô∏è Divine Barrier</strong> (12s CD, 5s duration)<br>
                <span style="font-size: 11px; color: rgba(207, 227, 255, 0.7);">+50 DEF, -30% damage taken</span>
              </div>
              <div style="background: rgba(0, 0, 0, 0.3); padding: 12px; border-radius: 8px; border: 1px solid rgba(138, 43, 226, 0.3);">
                <strong style="color: #dda0dd;">‚ö° Dash Nova</strong> (8s CD, 0.5s duration)<br>
                <span style="font-size: 11px; color: rgba(207, 227, 255, 0.7);">2x speed, +30 ATK, explosive damage</span>
              </div>
              <div style="background: rgba(0, 0, 0, 0.3); padding: 12px; border-radius: 8px; border: 1px solid rgba(138, 43, 226, 0.3);">
                <strong style="color: #dda0dd;">‚ú® Angelic Might</strong> (15s CD, 8s duration)<br>
                <span style="font-size: 11px; color: rgba(207, 227, 255, 0.7);">+100 ATK, +20% crit rate</span>
              </div>
              <div style="background: rgba(0, 0, 0, 0.3); padding: 12px; border-radius: 8px; border: 1px solid rgba(138, 43, 226, 0.3);">
                <strong style="color: #dda0dd;">üåü Radiant Burst</strong> (10s CD, 3s duration)<br>
                <span style="font-size: 11px; color: rgba(207, 227, 255, 0.7);">+50 ATK, 150 AoE radius</span>
              </div>
            </div>
          </div>
          <p style="color: rgba(207, 227, 255, 0.6); font-size: 12px;">
            Unlock supernatural abilities using essence. Combine spirits with abilities for enhanced effects!
          </p>
        `;
      },

      renderQuestsTab() {
        const container = document.getElementById('bagContent');
        container.innerHTML = `
          <h3 style="color: #4fc3f7; margin-bottom: 16px;">üìú Quests & Missions</h3>
          <div style="background: rgba(56, 239, 125, 0.1); border: 2px solid rgba(56, 239, 125, 0.3); border-radius: 12px; padding: 16px; margin-bottom: 12px;">
            <h4 style="color: #38ef7d;">üéØ Main Quest</h4>
            <strong>Journey to the Celestial Gates</strong><br>
            <span style="font-size: 12px; color: rgba(207, 227, 255, 0.7);">Travel through all zones and reach the final gates</span><br>
            <div style="margin-top: 8px; background: rgba(0, 0, 0, 0.3); height: 8px; border-radius: 4px; overflow: hidden;">
              <div style="width: 25%; height: 100%; background: linear-gradient(90deg, #38ef7d, #11998e);"></div>
            </div>
            <span style="font-size: 11px; color: rgba(207, 227, 255, 0.6);">Progress: 25%</span>
          </div>
          <div style="background: rgba(79, 195, 247, 0.1); border: 2px solid rgba(79, 195, 247, 0.3); border-radius: 12px; padding: 16px;">
            <h4 style="color: #4fc3f7;">üìã Side Quests</h4>
            <ul style="list-style: none; padding: 0; margin-top: 8px;">
              <li style="padding: 8px; background: rgba(0, 0, 0, 0.3); margin-bottom: 4px; border-radius: 4px; font-size: 12px;">
                ‚≠ê Defeat 100 enemies (${GameState.enemiesDefeated || 0}/100)
              </li>
              <li style="padding: 8px; background: rgba(0, 0, 0, 0.3); margin-bottom: 4px; border-radius: 4px; font-size: 12px;">
                ‚≠ê Collect 10,000 gold (${GameState.gold}/10,000)
              </li>
              <li style="padding: 8px; background: rgba(0, 0, 0, 0.3); margin-bottom: 4px; border-radius: 4px; font-size: 12px;">
                ‚≠ê Visit all buildings (Coming soon)
              </li>
            </ul>
          </div>
        `;
      },

      renderMapTab() {
        const container = document.getElementById('bagContent');
        container.innerHTML = `
          <h3 style="color: #4fc3f7; margin-bottom: 16px;">üó∫Ô∏è World Map</h3>
          <div style="background: rgba(79, 195, 247, 0.1); border: 2px solid rgba(79, 195, 247, 0.3); border-radius: 12px; padding: 16px; margin-bottom: 12px;">
            <h4 style="color: #4fc3f7; margin-bottom: 8px;">üèôÔ∏è Discovered Locations</h4>
            <div style="display: grid; gap: 8px;">
              <div style="padding: 8px; background: rgba(0, 0, 0, 0.3); border-radius: 6px; font-size: 12px;">
                üè† <strong>Starting Zone</strong> - Entry point
              </div>
              <div style="padding: 8px; background: rgba(0, 0, 0, 0.3); border-radius: 6px; font-size: 12px;">
                üèüÔ∏è <strong>Battle Arena</strong> - Combat training
              </div>
              <div style="padding: 8px; background: rgba(0, 0, 0, 0.3); border-radius: 6px; font-size: 12px;">
                üè™ <strong>Shop District</strong> - Buy items
              </div>
              <div style="padding: 8px; background: rgba(0, 0, 0, 0.2); border-radius: 6px; font-size: 12px; opacity: 0.5;">
                üèØ <strong>???</strong> - Locked
              </div>
            </div>
          </div>
          <p style="color: rgba(207, 227, 255, 0.6); font-size: 12px;">
            Explore the world to discover new locations. Fast travel unlocks after visiting each zone.
          </p>
        `;
      },

      renderShopTab() {
        const container = document.getElementById('bagContent');
        container.innerHTML = `
          <h3 style="color: #4fc3f7; margin-bottom: 16px;">üè™ Item Shop</h3>
          <div style="margin-bottom: 16px; padding: 12px; background: rgba(255, 215, 0, 0.1); border: 2px solid rgba(255, 215, 0, 0.3); border-radius: 12px;">
            <strong style="color: #ffd700;">üí∞ Your Gold: ${GameState.gold.toLocaleString()}g</strong>
          </div>
          <div class="items-grid">
            <div class="item-card" onclick="window.BagSystem.buyItem('hp_potion', 60)">
              <div class="item-icon">üß™</div>
              <div class="item-name">HP Potion</div>
              <div class="item-description">Heals 40% HP</div>
              <div class="item-stats">
                <span class="item-stat" style="color: #ffd700;">üí∞ 60g</span>
                <span class="item-stat">C-Rank</span>
              </div>
            </div>
            <div class="item-card" onclick="window.BagSystem.buyItem('rage_pill', 90)">
              <div class="item-icon">üíä</div>
              <div class="item-name">Rage Pill</div>
              <div class="item-description">+30 Rage</div>
              <div class="item-stats">
                <span class="item-stat" style="color: #ffd700;">üí∞ 90g</span>
                <span class="item-stat">C-Rank</span>
              </div>
            </div>
            <div class="item-card" onclick="window.BagSystem.buyItem('iron_sword', 150)">
              <div class="item-icon">üó°Ô∏è</div>
              <div class="item-name">Iron Sword</div>
              <div class="item-description">Basic iron sword</div>
              <div class="item-stats">
                <span class="item-stat">‚öîÔ∏è +10 ATK</span>
                <span class="item-stat" style="color: #ffd700;">üí∞ 150g</span>
              </div>
            </div>
            <div class="item-card" onclick="window.BagSystem.buyItem('steel_blade', 300)">
              <div class="item-icon">‚öîÔ∏è</div>
              <div class="item-name">Steel Blade</div>
              <div class="item-description">Sturdy steel weapon</div>
              <div class="item-stats">
                <span class="item-stat">‚öîÔ∏è +20 ATK</span>
                <span class="item-stat" style="color: #ffd700;">üí∞ 300g</span>
              </div>
            </div>
            <div class="item-card rarity-rare" onclick="window.BagSystem.buyItem('pet_box', 500)">
              <div class="item-icon">üéÅ</div>
              <div class="item-name">Pet Box</div>
              <div class="item-description">Random pet</div>
              <div class="item-stats">
                <span class="item-stat" style="color: #ffd700;">üí∞ 500g</span>
                <span class="item-stat">B-Rank</span>
              </div>
            </div>
            <div class="item-card rarity-rare" onclick="window.BagSystem.buyItem('vehicle_box', 750)">
              <div class="item-icon">üì¶</div>
              <div class="item-name">Vehicle Box</div>
              <div class="item-description">Random vehicle</div>
              <div class="item-stats">
                <span class="item-stat" style="color: #ffd700;">üí∞ 750g</span>
                <span class="item-stat">B-Rank</span>
              </div>
            </div>
          </div>
        `;
      },

      renderSettingsTab() {
        const container = document.getElementById('bagContent');
        container.innerHTML = `
          <h3 style="color: #4fc3f7; margin-bottom: 16px;">‚öôÔ∏è Settings</h3>
          <div style="display: grid; gap: 12px; max-width: 600px;">
            <div style="background: rgba(15, 24, 38, 0.9); padding: 16px; border-radius: 12px; border: 2px solid rgba(79, 195, 247, 0.3);">
              <h4 style="color: #4fc3f7; margin-bottom: 12px;">üéÆ Game Settings</h4>
              <div style="margin-bottom: 8px;">
                <label style="font-size: 12px; color: rgba(207, 227, 255, 0.8);">
                  <input type="checkbox" style="margin-right: 8px;" checked> Show damage numbers
                </label>
              </div>
              <div style="margin-bottom: 8px;">
                <label style="font-size: 12px; color: rgba(207, 227, 255, 0.8);">
                  <input type="checkbox" style="margin-right: 8px;" checked> Auto-loot items
                </label>
              </div>
              <div style="margin-bottom: 8px;">
                <label style="font-size: 12px; color: rgba(207, 227, 255, 0.8);">
                  <input type="checkbox" style="margin-right: 8px;"> Show minimap
                </label>
              </div>
            </div>
            <div style="background: rgba(15, 24, 38, 0.9); padding: 16px; border-radius: 12px; border: 2px solid rgba(167, 139, 250, 0.3);">
              <h4 style="color: #a78bfa; margin-bottom: 12px;">üîä Audio Settings</h4>
              <div style="margin-bottom: 12px;">
                <label style="font-size: 12px; color: rgba(207, 227, 255, 0.8); display: block; margin-bottom: 4px;">
                  Master Volume: <span>70%</span>
                </label>
                <input type="range" min="0" max="100" value="70" style="width: 100%;">
              </div>
              <div style="margin-bottom: 8px;">
                <label style="font-size: 12px; color: rgba(207, 227, 255, 0.8);">
                  <input type="checkbox" style="margin-right: 8px;" checked> Enable sound effects
                </label>
              </div>
              <div style="margin-bottom: 8px;">
                <label style="font-size: 12px; color: rgba(207, 227, 255, 0.8);">
                  <input type="checkbox" style="margin-right: 8px;" checked> Enable music
                </label>
              </div>
            </div>
            <div style="background: rgba(15, 24, 38, 0.9); padding: 16px; border-radius: 12px; border: 2px solid rgba(56, 239, 125, 0.3);">
              <h4 style="color: #38ef7d; margin-bottom: 12px;">üíæ Save/Load</h4>
              <div style="display: flex; gap: 8px;">
                <button style="flex: 1; padding: 8px; background: rgba(56, 239, 125, 0.2); border: 1px solid rgba(56, 239, 125, 0.5); border-radius: 6px; color: #38ef7d; cursor: pointer; font-size: 12px;">
                  üíæ Save Game
                </button>
                <button style="flex: 1; padding: 8px; background: rgba(79, 195, 247, 0.2); border: 1px solid rgba(79, 195, 247, 0.5); border-radius: 6px; color: #4fc3f7; cursor: pointer; font-size: 12px;">
                  üìÇ Load Game
                </button>
              </div>
            </div>
          </div>
        `;
      },

      buyItem(itemId, cost) {
        if (GameState.gold < cost) {
          showToast(`‚ö†Ô∏è Not enough gold! Need ${cost}g`);
          return;
        }
        GameState.gold -= cost;
        showToast(`‚úÖ Purchased for ${cost}g!`);
        this.renderShopTab();
      },

      equipPet(petId) {
        const pet = GameState.inventory.pets.find(p => p.id === petId);
        if (pet) {
          GameState.equipped.pet = pet;
          showToast(`üêæ Summoned ${pet.name}!`);
          this.renderPetsTab();
          
          // PHASE 3: Quest tracking & tutorial
          updateQuestProgress('summon_pet', 1);
          updateQuestProgress('equip', 'pet');
          advanceTutorial('pet');
          
          // PHASE 5: Audio
          AudioSystem.playSound('summon');
        }
      },

      unequipPet() {
        const pet = GameState.equipped.pet;
        if (pet) {
          GameState.equipped.pet = null;
          showToast(`üêæ Recalled ${pet.name}`);
          this.renderPetsTab();
        }
      },

      equipVehicle(vehicleId) {
        const vehicle = GameState.inventory.vehicles.find(v => v.id === vehicleId);
        if (vehicle) {
          GameState.equipped.vehicle = vehicle;
          showToast(`üöó Boarded ${vehicle.name}!`);
          this.renderVehiclesTab();
          
          // PHASE 3: Quest tracking
          updateQuestProgress('ride_vehicle', 1);
          updateQuestProgress('equip', 'vehicle');
        }
      },

      unequipVehicle() {
        const vehicle = GameState.equipped.vehicle;
        if (vehicle) {
          GameState.equipped.vehicle = null;
          showToast(`üöó Exited ${vehicle.name}`);
          this.renderVehiclesTab();
        }
      },

      equipRobot(robotId) {
        const robot = GameState.inventory.robots.find(r => r.id === robotId);
        if (robot) {
          GameState.equipped.robot = robot;
          showToast(`ü§ñ Summoned ${robot.name}!`);
          this.renderAITab();
          
          // PHASE 3: Quest tracking
          updateQuestProgress('summon_robot', 1);
          updateQuestProgress('equip', 'robot');
        }
      },

      unequipRobot() {
        const robot = GameState.equipped.robot;
        if (robot) {
          GameState.equipped.robot = null;
          showToast(`ü§ñ Dismissed ${robot.name}`);
          this.renderAITab();
        }
      }
    };

    // Listen for messages from bag system
    window.addEventListener('message', (event) => {
      if (event.data.type === 'BAG_SYSTEM_SYNC') {
        console.log('[CityMapGame] Received sync from bag system:', event.data.data);

        // Sync gold from bag system
        if (event.data.data.gold !== undefined) {
          GameState.gold = event.data.data.gold;
          updateGoldDisplay();
        }

        // Sync position if provided
        if (event.data.data.position && GameState.party[0]) {
          GameState.party[0].x = event.data.data.position.x || GameState.party[0].x;
          GameState.party[0].y = event.data.data.position.y || GameState.party[0].y;
          GameState.currentZone = event.data.data.position.zone || GameState.currentZone;
        }

        // Sync level if provided
        if (event.data.data.level && GameState.party[0]) {
          GameState.party[0].level = event.data.data.level;
        }
      }
    });

    // Notify parent when game state changes
    function notifyParent() {
      if (window.parent !== window) {
        window.parent.postMessage({
          type: 'MAP_GAME_UPDATE',
          data: {
            gold: GameState.gold,
            position: GameState.party[0] ? {
              x: GameState.party[0].x,
              y: GameState.party[0].y,
              zone: GameState.currentZone
            } : null
          }
        }, '*');
      }
    }

    // Notify parent periodically
    setInterval(notifyParent, 3000);

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // HUD CANDY BUTTON SYSTEM
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    (function() {
      // Button click handlers (not wired yet - ready for you to wire!)
      const buttons = document.querySelectorAll('[data-btn]');
      
      buttons.forEach(btn => {
        btn.addEventListener('click', function() {
          const btnType = this.dataset.btn;
          console.log('üç¨ HUD Button clicked:', btnType);
          
          // BAG BUTTON - Open inventory
          if (btnType === 'bag') {
            window.BagSystem.toggle();
          }
          
          // PET BUTTON - Toggle pet or open pets tab
          else if (btnType === 'pet') {
            const pet = GameState.equipped.pet;
            if (pet) {
              window.BagSystem.unequipPet();
            } else {
              window.BagSystem.open();
              window.BagSystem.renderTab('pets');
            }
          }
          
          // VEH BUTTON - Toggle vehicle or open vehicles tab
          else if (btnType === 'veh') {
            const vehicle = GameState.equipped.vehicle;
            if (vehicle) {
              window.BagSystem.unequipVehicle();
            } else {
              window.BagSystem.open();
              window.BagSystem.renderTab('vehicles');
            }
          }
          
          // SWITCH BUTTON - Change character
          else if (btnType === 'switch') {
            const characters = ['A1', 'Missy', 'Unique'];
            const currentIndex = characters.indexOf(GameState.currentCharacter);
            const nextIndex = (currentIndex + 1) % characters.length;
            GameState.currentCharacter = characters[nextIndex];
            showToast(`üîÑ Switched to ${characters[nextIndex]}!`);
          }
          
          // AI BUTTON - Toggle robot or open AI tab
          else if (btnType === 'ai') {
            const robot = GameState.equipped.robot;
            if (robot) {
              window.BagSystem.unequipRobot();
            } else {
              window.BagSystem.open();
              window.BagSystem.renderTab('ai');
            }
          }
          
          // SKILLS S1, S2, S3 - Cast character skills
          else if (btnType === 's1' || btnType === 's2' || btnType === 's3') {
            const char = GameState.currentCharacter.toUpperCase();
            const slotNum = parseInt(btnType[1]);
            const skill = GameState.inventory.skills.find(
              s => s.characterId === char && s.slot === slotNum
            );
            if (skill) {
              castSkill(skill);
            } else {
              showToast(`‚ö†Ô∏è No skill in slot ${slotNum}`);
            }
          }
          
          // ACT BUTTON - Enter buildings/pickup items
          else if (btnType === 'act') {
            // Simulate E key press for interactions
            const eKey = new KeyboardEvent('keydown', { key: 'e', code: 'KeyE' });
            document.dispatchEvent(eKey);
            showToast('üéÆ ACT button pressed!');
          }
          
          // ACT2 BUTTON - Additional interactions
          else if (btnType === 'act2') {
            showToast('üéÆ ACT2 button - Additional interactions!');
          }
          
          // ATTACK BUTTON - Melee attack
          else if (btnType === 'attack') {
            performMeleeAttack();
          }
          
          // JUMP BUTTON - Jump action
          else if (btnType === 'jump') {
            performJumpAttack();
          }
          
          // RAGE BUTTON - Rage mode
          else if (btnType === 'rage') {
            activateRageMode();
          }
          
          // SHIELD BUTTON - Block/dodge
          else if (btnType === 'shield') {
            activateShield();
          }
          
          // Catch-all for any other buttons
          else {
            showToast(`üéÆ ${btnType.toUpperCase()} button pressed!`);
          }
        });
      });
      
      // Joystick controller (adjusted for 30% smaller size)
      const root = document.getElementById('vj-root');
      const knob = document.getElementById('vj-knob');
      const radius = 41;
      let isActive = false;

      function getTouch(e) {
        return e.touches ? e.touches[0] : e;
      }

      function handleStart(e) {
        if (e.type === 'mousedown' && e.button !== 0) return;
        isActive = true;
        if (e.type === 'touchstart') e.preventDefault();
        handleMove(e);
      }

      function handleMove(e) {
        if (!isActive) return;

        const touch = getTouch(e);
        const rect = root.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;

        let dx = touch.clientX - centerX;
        let dy = touch.clientY - centerY;
        const distance = Math.sqrt(dx * dx + dy * dy);

        if (distance > radius) {
          const ratio = radius / distance;
          dx *= ratio;
          dy *= ratio;
        }

        knob.style.transform = `translate(${dx}px, ${dy}px)`;

        // TODO: Wire up joystick movement to game character
        const joyX = dx / radius;
        const joyY = dy / radius;
        // console.log('üïπÔ∏è Joystick:', joyX.toFixed(2), joyY.toFixed(2));
      }

      function handleEnd(e) {
        if (!isActive) return;
        isActive = false;
        knob.style.transform = 'translate(0, 0)';
      }

      // Attach joystick events
      root.addEventListener('touchstart', handleStart, { passive: false });
      root.addEventListener('touchmove', handleMove, { passive: false });
      root.addEventListener('touchend', handleEnd);
      root.addEventListener('touchcancel', handleEnd);
      root.addEventListener('mousedown', handleStart);
      document.addEventListener('mousemove', handleMove);
      document.addEventListener('mouseup', handleEnd);
      
      console.log('üç¨ HUD Candy System Loaded! All buttons ready for wiring.');
      showToast('üç¨ HUD Candy controls loaded!');
      
      // HUD Toggle functionality
      document.getElementById('hudHideBtn').addEventListener('click', function() {
        document.getElementById('hud-wrap').classList.add('hidden');
        this.style.display = 'none';
        document.getElementById('hudShowBtn').style.display = 'flex';
        showToast('üéÆ HUD Hidden');
      });

      document.getElementById('hudShowBtn').addEventListener('click', function() {
        document.getElementById('hud-wrap').classList.remove('hidden');
        this.style.display = 'none';
        document.getElementById('hudHideBtn').style.display = 'flex';
        showToast('üéÆ HUD Visible');
      });
    })();

  </script>

</body>

</html>