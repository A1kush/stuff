// ===== A1K Bag System =====
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // A1K BAG SYSTEM - CORE ENGINE
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    // Debug Mode Configuration - Global scope
    // Production mode: Set window.A1K_DEBUG_MODE = false to suppress debug logs
    // Development mode: Set window.A1K_DEBUG_MODE = true to show all logs
    // Errors are always shown regardless of debug mode
    const DEBUG = window.A1K_DEBUG_MODE || false;
    const debugLog = DEBUG ? console.log.bind(console) : () => {};
    const debugWarn = DEBUG ? console.warn.bind(console) : () => {};
    // Always show errors in production
    const debugError = console.error.bind(console);

    (function () {
      'use strict';

      const STYLESHEET_ID = 'a1k-bag-system-styles';
      const STYLESHEET_HREF = 'A1KBagSystem.css';

      const BAG_TEMPLATE = String.raw`
        <div class="bag-window" id="bagWindow">
          <div class="bag-titlebar" id="bagTitlebar">
            <div class="bag-titlebar-icon">ğŸ’</div>
            <div class="bag-titlebar-title">A1K ULTIMATE - All Features</div>
            <div class="bag-titlebar-controls">
              <button class="titlebar-btn minimize" id="minimizeBagBtn">âˆ’</button>
              <button class="titlebar-btn maximize" id="maximizeBagBtn">â–¡</button>
              <button class="titlebar-btn close" id="closeBagBtn">âœ•</button>
            </div>
          </div>
          <div class="bag-tabs-bar">
            <div class="bag-tabs-strip" id="bagTabsStrip"></div>
            <div class="bag-titlebar-controls"></div>
          </div>
          <div class="bag-currencies">
            <div class="currencies-strip" id="currenciesStrip"></div>
          </div>
          <div class="bag-actions">
            <div class="actions-row">
              <button class="auto-btn" id="openAllBtn">Open All</button>
              <button class="auto-btn" id="autoUpBtn">Auto Up</button>
              <button class="auto-btn" id="autoEqBtn">Auto Eq</button>
              <button class="auto-btn" id="autoFuseBtn">Auto Fuse</button>
              <button class="auto-btn" id="autoSellBtn">Auto Sell</button>
              <button class="auto-btn" id="autoAlchemyBtn" title="Auto Alchemy (1x)">AUTO ALCHEMY</button>
              <button class="auto-btn" id="autoAIBtn">Auto AI: OFF</button>
            </div>
          </div>
          <div class="bag-content-pane" id="bagContentPane"></div>
          <div class="bag-stats-footer">
            <div class="stats-left" id="bagStatsLeft"></div>
            <div class="stats-right" id="bagStatsRight"></div>
          </div>
          <div class="bag-diagnostics" id="bagDiagnostics">
            <div class="bag-diagnostics__header">Diagnostics</div>
            <div class="bag-diagnostics__content" id="bagDiagnosticsContent">
              <div class="bag-diagnostics__empty">All systems nominal.</div>
            </div>
          </div>
        </div>
      `.trim();

      const HUD_TEMPLATE = String.raw`
        <div id="hud-wrap">
          <div id="hud-left">
            <div class="utility-stack">
              <div class="utility-row top">
                <button class="utility-btn" data-btn="pet">Pet</button>
                <button class="utility-btn" data-btn="veh">Veh</button>
                <button class="utility-btn" data-btn="act">Act</button>
                <button class="utility-btn" data-btn="act2">Act2</button>
              </div>
              <div class="utility-row bot">
                <button class="utility-btn" data-btn="bag">Bag</button>
                <button class="utility-btn" data-btn="ai">AI</button>
                <button class="utility-btn" data-btn="switch">Switch</button>
              </div>
            </div>
            <div id="vj-root">
              <div id="vj-base"></div>
              <div id="vj-knob"></div>
            </div>
          </div>
          <div id="hud-right">
            <div class="skill-row">
              <button class="skill-pill s1" data-skill="S1" data-btn="s1" aria-label="Skill 1"></button>
              <button class="skill-pill s2" data-skill="S2" data-btn="s2" aria-label="Skill 2"></button>
              <button class="skill-pill s3" data-skill="S3" data-btn="s3" aria-label="Skill 3"></button>
            </div>
            <div class="btn-container">
              <button class="big-btn attack" data-btn="attack">ATTACK</button>
              <button class="big-btn jump" data-btn="jump">JUMP</button>
              <div class="rage-shield-container">
                <button class="rage-shield-btn rage" data-btn="rage">RAGE</button>
                <button class="rage-shield-btn shield" data-btn="shield">SHIELD</button>
              </div>
            </div>
          </div>
        </div>
      `.trim();

      const HUD_COLOR_PRESETS = [
        {
          id: 'candy-pink',
          label: 'Pink',
          values: {
            '--candy-pink': '#ffb6d9',
            '--candy-purple': '#fecfef',
            '--candy-yellow': '#ffecd2',
            '--candy-blue': '#a8edea',
            '--candy-orange': '#ffd1ff'
          }
        },
        {
          id: 'candy-blue',
          label: 'Blue',
          values: {
            '--candy-pink': '#a8edea',
            '--candy-purple': '#b5ccff',
            '--candy-yellow': '#e0f4ff',
            '--candy-blue': '#7dd3fc',
            '--candy-orange': '#c4f1ff'
          }
        },
        {
          id: 'candy-green',
          label: 'Green',
          values: {
            '--candy-pink': '#c8f8d1',
            '--candy-purple': '#92f2c0',
            '--candy-yellow': '#e6ffe0',
            '--candy-blue': '#8ef0d0',
            '--candy-orange': '#d5ffd4'
          }
        },
        {
          id: 'candy-gold',
          label: 'Gold',
          values: {
            '--candy-pink': '#ffdca8',
            '--candy-purple': '#ffe4b5',
            '--candy-yellow': '#ffe8a3',
            '--candy-blue': '#ffe0b2',
            '--candy-orange': '#ffcc80'
          }
        }
      ];

      // Tab Definitions (embedded for offline use)
      const ensureStylesheet = (href = STYLESHEET_HREF) => {
        if (document.getElementById(STYLESHEET_ID)) return;
        const link = document.createElement('link');
        link.id = STYLESHEET_ID;
        link.rel = 'stylesheet';
        link.href = href;
        document.head.appendChild(link);
      };

      const injectHtmlIfMissing = (selector, template) => {
        if (document.querySelector(selector)) return;
        const tpl = document.createElement('template');
        tpl.innerHTML = template;
        document.body.appendChild(tpl.content.cloneNode(true));
      };

      const ensureUiInjected = () => {
        ensureStylesheet();
        if (!document.querySelector('.toast-container')) {
          const toastTpl = document.createElement('template');
          toastTpl.innerHTML = '<div class=\"toast-container\"></div>';
          document.body.appendChild(toastTpl.content.cloneNode(true));
        }
        injectHtmlIfMissing('#bagWindow', BAG_TEMPLATE);
        injectHtmlIfMissing('#hud-wrap', HUD_TEMPLATE);
      };

      const applyColorPreset = (presetId) => {
        const preset = HUD_COLOR_PRESETS.find(p => p.id === presetId) || HUD_COLOR_PRESETS[0];
        Object.entries(preset.values).forEach(([variable, value]) => {
          document.documentElement.style.setProperty(variable, value);
        });
        return preset.id;
      };

      const TAB_DEFINITIONS = [
        { id: "items", label: "Items", icon: "ğŸ“¦", enabled: true, renderer: "renderItemsTab", order: 1 },
        { id: "gear", label: "Gear", icon: "âš”ï¸", enabled: true, renderer: "renderGearTab", order: 2 },
        { id: "team", label: "Team", icon: "ğŸ‘¥", enabled: true, renderer: "renderTeamTab", order: 3 },
        { id: "pets", label: "Pets", icon: "ğŸ¾", enabled: true, renderer: "renderPetsTab", order: 4 },
        { id: "skins", label: "Player", icon: "ğŸ‘¤", enabled: true, renderer: "renderSkinsTab", order: 5 },
        { id: "talents", label: "Talents", icon: "â­", enabled: true, renderer: "renderTalentsTab", order: 6 },
        { id: "vehicles", label: "Vehicles", icon: "ğŸš—", enabled: true, renderer: "renderVehiclesTab", order: 7 },
        { id: "ai", label: "AI", icon: "ğŸ¤–", enabled: true, renderer: "renderAITab", order: 8 },
        { id: "alchemy", label: "Alchemy", icon: "âš—ï¸", enabled: true, renderer: "renderAlchemyTab", order: 9 },
        { id: "skills", label: "Skills", icon: "ğŸ”°", enabled: true, renderer: "renderSkillsTab", order: 10 },
        { id: "spirit", label: "Spirit", icon: "âœ¨", enabled: true, renderer: "renderSpiritTab", order: 11 },
        { id: "supernatural", label: "Supernatural", icon: "ğŸ”®", enabled: true, renderer: "renderSupernaturalTab", order: 12 },
        { id: "quests", label: "Quests", icon: "ğŸ“œ", enabled: true, renderer: "renderQuestsTab", order: 13 },
        { id: "drops", label: "Drop Systems", icon: "ğŸ", enabled: true, renderer: "renderDropSystemsTab", order: 14 },
        { id: "bestiary", label: "Bestiary", icon: "ğŸ“–", enabled: true, renderer: "renderBestiaryTab", order: 15 },
        { id: "missions", label: "Mission Board", icon: "ğŸ—ºï¸", enabled: true, renderer: "renderMissionBoardTab", order: 16 },
        { id: "map", label: "Map", icon: "ğŸ—ºï¸", enabled: true, renderer: "renderMapTab", order: 17 },
        { id: "shop", label: "Shop", icon: "ğŸª", enabled: true, renderer: "renderShopTab", order: 18 },
        { id: "settings", label: "Settings", icon: "âš™ï¸", enabled: true, renderer: "renderSettingsTab", order: 19 },
        { id: "controls", label: "Controls", icon: "ğŸ•¹ï¸", enabled: true, renderer: "renderControlsTab", order: 20 }
      ];

      const FALLBACK_PERCENT_STATS = new Set([
        'critRate',
        'critDamage',
        'lifesteal',
        'armorPen',
        'block',
        'evade',
        'speed',
        'cooldownReduction',
        'elementalDamage',
        'elementalResist'
      ]);

      const GEAR_STAT_DISPLAY_ORDER = [
        'attack',
        'defense',
        'hp',
        'mp',
        'speed',
        'critRate',
        'critDamage',
        'lifesteal',
        'armorPen',
        'block',
        'evade',
        'cooldownReduction',
        'elementalDamage',
        'elementalResist'
      ];

      const GEAR_BADGE_THEME = {
        attack: { color: '#ff6b6b', background: 'rgba(255, 107, 107, 0.2)', icon: 'âš”ï¸' },
        defense: { color: '#4fc3f7', background: 'rgba(79, 195, 247, 0.2)', icon: 'ğŸ›¡ï¸' },
        hp: { color: '#38ef7d', background: 'rgba(56, 239, 125, 0.2)', icon: 'â¤ï¸' },
        mp: { color: '#7c4dff', background: 'rgba(124, 77, 255, 0.2)', icon: 'ğŸ”·' },
        speed: { color: '#ffd77a', background: 'rgba(255, 215, 122, 0.2)', icon: 'ğŸ’¨' },
        critRate: { color: '#ffa726', background: 'rgba(255, 167, 38, 0.2)', icon: 'ğŸ¯' },
        critDamage: { color: '#ff8a65', background: 'rgba(255, 138, 101, 0.2)', icon: 'ğŸ’¥' },
        lifesteal: { color: '#f06292', background: 'rgba(240, 98, 146, 0.2)', icon: 'ğŸ©¸' },
        armorPen: { color: '#ba68c8', background: 'rgba(186, 104, 200, 0.2)', icon: 'ğŸ—¡ï¸' },
        block: { color: '#64b5f6', background: 'rgba(100, 181, 246, 0.2)', icon: 'ğŸ›¡ï¸' },
        evade: { color: '#4dd0e1', background: 'rgba(77, 208, 225, 0.2)', icon: 'ğŸŒ€' },
        cooldownReduction: { color: '#90caf9', background: 'rgba(144, 202, 249, 0.2)', icon: 'â±ï¸' },
        elementalDamage: { color: '#ffb74d', background: 'rgba(255, 183, 77, 0.2)', icon: 'ğŸ”¥' },
        elementalResist: { color: '#81c784', background: 'rgba(129, 199, 132, 0.2)', icon: 'â„ï¸' }
      };

      function isPercentStat(statKey) {
        const percentSet = window.GearData?.percentStats || FALLBACK_PERCENT_STATS;
        return percentSet.has(statKey);
      }

      function formatGearStatValue(statKey, value) {
        if (value == null || Number.isNaN(value)) return null;
        if (isPercentStat(statKey)) {
          return `${(value * 100).toFixed(1)}%`;
        }
        return Math.round(value);
      }

      function formatGearBadge(statKey, value) {
        if (!value && value !== 0) return '';
        const theme = GEAR_BADGE_THEME[statKey] || { color: '#cfe3ff', background: 'rgba(207, 227, 255, 0.15)', icon: 'âœ¨' };
        const formatted = window.GearData?.formatStat(statKey, value) || `${theme.icon} ${formatGearStatValue(statKey, value)}`;
        return `<span class=\"stat-badge\" style=\"background: ${theme.background}; color: ${theme.color};\">${formatted}</span>`;
      }

      function formatGearStatText(statKey, value) {
        if (!value && value !== 0) return null;
        const labelMap = {
          attack: 'ATK',
          defense: 'DEF',
          hp: 'HP',
          mp: 'MP',
          speed: 'SPD',
          critRate: 'CRIT',
          critDamage: 'CRIT DMG',
          lifesteal: 'LIFESTEAL',
          armorPen: 'ARMOR PEN',
          block: 'BLOCK',
          evade: 'EVADE',
          cooldownReduction: 'CDR',
          elementalDamage: 'ELEM DMG',
          elementalResist: 'ELEM RES'
        };
        const label = labelMap[statKey] || statKey.toUpperCase();
        const isPercent = isPercentStat(statKey);
        if (isPercent) {
          const percent = (value * 100).toFixed(1);
          const sign = value >= 0 ? '+' : '';
          return `${sign}${percent}% ${label}`;
        }
        const rounded = Math.round(value);
        const sign = rounded >= 0 ? '+' : '';
        return `${sign}${rounded} ${label}`;
      }

      // Equipment Slots Configuration
      const EQUIPMENT_SLOTS_LEFT = [
        { id: "head", label: "Head" },
        { id: "chest", label: "Chest" },
        { id: "gloves", label: "Gloves" },
        { id: "pants", label: "Pants" },
        { id: "boots", label: "Boots" }
      ];

      const EQUIPMENT_SLOTS_RIGHT = [
        { id: "weapon", label: "Weapon" },
        { id: "offhand", label: "Off-hand" },
        { id: "ring1", label: "Ring 1" },
        { id: "ring2", label: "Ring 2" },
        { id: "necklace", label: "Necklace" }
      ];

      const diagnosticsState = {
        missingAssets: new Map(),
        scheduled: false,
      };

      const flushDiagnosticsPanel = () => {
        diagnosticsState.scheduled = false;
        if (window.BagSystem && typeof window.BagSystem.renderDiagnosticsPanel === 'function') {
          window.BagSystem.renderDiagnosticsPanel();
        }
      };

      const scheduleDiagnosticsUpdate = () => {
        if (diagnosticsState.scheduled) return;
        diagnosticsState.scheduled = true;
        const raf = window.requestAnimationFrame || function (cb) { return setTimeout(cb, 0); };
        raf(flushDiagnosticsPanel);
      };

      const recordMissingAsset = (path, source) => {
        if (!path) return;
        const key = String(path).trim();
        const entry =
          diagnosticsState.missingAssets.get(key) ?? {
            count: 0,
            sources: new Set(),
            lastSeen: 0,
          };
        entry.count += 1;
        entry.lastSeen = Date.now();
        if (source) {
          entry.sources.add(source);
        }
        diagnosticsState.missingAssets.set(key, entry);
        scheduleDiagnosticsUpdate();
      };

      window.BagDiagnostics = window.BagDiagnostics || {};
      window.BagDiagnostics.recordMissingAsset = (path, source = 'runtime') => recordMissingAsset(path, source);
      window.BagDiagnostics.clear = () => {
        diagnosticsState.missingAssets.clear();
        scheduleDiagnosticsUpdate();
      };
      window.BagDiagnostics.getState = () => ({
        missingAssets: Array.from(diagnosticsState.missingAssets.entries()).map(([assetPath, detail]) => ({
          path: assetPath,
          count: detail.count,
          lastSeen: detail.lastSeen,
          sources: Array.from(detail.sources ?? []),
        })),
      });

      window.__bagDiagnostics = diagnosticsState;

      // Test: Wrapping existing settings markup should create player/dev sections without losing original controls.
      const wrapDevSettingsLayout = (pane) => {
        if (!pane || pane.dataset.devSettingsWrapped === '1') {
          return;
        }
        const existingContent = document.createDocumentFragment();
        while (pane.firstChild) {
          existingContent.appendChild(pane.firstChild);
        }

        const tabBar = document.createElement('div');
        tabBar.className = 'settings-subtabs';
        tabBar.dataset.settingsTabs = '';
        tabBar.innerHTML = `
          <button type="button" class="settings-subtab active" data-tab="player">Player Settings</button>
          <button type="button" class="settings-subtab" data-tab="dev">Dev Settings</button>
        `;

        const sectionsWrapper = document.createElement('div');
        sectionsWrapper.className = 'settings-sections';

        const playerSection = document.createElement('div');
        playerSection.className = 'settings-section active';
        playerSection.dataset.settingsSection = 'player';
        playerSection.appendChild(existingContent);

        const devSection = document.createElement('div');
        devSection.className = 'settings-section';
        devSection.dataset.settingsSection = 'dev';
        devSection.innerHTML = `
          <div class="dev-tooling-card" id="devToolingCard">
            <h3>Developer Toolkit</h3>
            <p>Developer utilities are grouped here to avoid cluttering the main UI.</p>
            <div class="dev-tooling-grid" data-dev-tooling></div>
          </div>
        `;

        sectionsWrapper.appendChild(playerSection);
        sectionsWrapper.appendChild(devSection);

        pane.appendChild(tabBar);
        pane.appendChild(sectionsWrapper);
        pane.dataset.devSettingsWrapped = '1';
      };

      // Test: Dev Settings sub-tab toggles should switch visibility without throwing when elements are missing.
      const applyDevSettingsTabs = (root) => {
        if (!root) {
          return;
        }
        const tabBar = root.querySelector('[data-settings-tabs]');
        const sections = Array.from(root.querySelectorAll('[data-settings-section]'));
        if (!tabBar || sections.length === 0) {
          return;
        }
        if (tabBar.dataset.devTabsApplied === '1') {
          return;
        }
        const buttons = Array.from(tabBar.querySelectorAll('[data-tab]'));
        if (buttons.length === 0) {
          return;
        }
        tabBar.dataset.devTabsApplied = '1';

        const applyActive = (targetKey) => {
          for (const button of buttons) {
            const isMatch = button.dataset.tab === targetKey;
            button.classList.toggle('active', isMatch);
            button.setAttribute('aria-pressed', String(isMatch));
          }
          for (const section of sections) {
            const isMatch = section.dataset.settingsSection === targetKey;
            section.classList.toggle('active', isMatch);
            section.toggleAttribute('hidden', !isMatch);
          }
        };

        applyActive('player');

        for (const button of buttons) {
          button.addEventListener('click', () => {
            try {
              const key = button.dataset.tab;
              if (!key) {
                return;
              }
              applyActive(key);
            } catch (error) {
              debugError('[BagSettingsTabs] Failed to switch tab:', error);
            }
          });
        }
      };

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // CORE SLOTS CONFIGURATION (Equipment â†’ Core Mapping)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      const CORE_SLOTS_CONFIG = {
        weapon: { coreType: 'weapon', coreSuffix: 'weaponCore', category: 'weapon', label: 'Weapon Core', icon: 'âš”ï¸' },
        offhand: { coreType: 'weapon', coreSuffix: 'offhandCore', category: 'weapon', label: 'Offhand Core', icon: 'ğŸ›¡ï¸' },
        head: { coreType: 'armor', coreSuffix: 'headCore', category: 'armor', label: 'Head Core', icon: 'â›‘ï¸' },
        chest: { coreType: 'armor', coreSuffix: 'chestCore', category: 'armor', label: 'Chest Core', icon: 'ğŸ›¡ï¸' },
        gloves: { coreType: 'armor', coreSuffix: 'glovesCore', category: 'armor', label: 'Gloves Core', icon: 'ğŸ§¤' },
        pants: { coreType: 'armor', coreSuffix: 'pantsCore', category: 'armor', label: 'Pants Core', icon: 'ğŸ‘–' },
        boots: { coreType: 'armor', coreSuffix: 'bootsCore', category: 'armor', label: 'Boots Core', icon: 'ğŸ‘¢' },
        ring1: { coreType: 'accessory', coreSuffix: 'ring1Core', category: 'accessory', label: 'Ring Core', icon: 'ğŸ’' },
        ring2: { coreType: 'accessory', coreSuffix: 'ring2Core', category: 'accessory', label: 'Ring Core', icon: 'ğŸ’' },
        necklace: { coreType: 'accessory', coreSuffix: 'necklaceCore', category: 'accessory', label: 'Necklace Core', icon: 'ğŸ“¿' }
      };

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // CORES DATABASE (Equipment Enhancement Cores)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // SUPERNATURAL POWERS DATABASE (3 Categories: Elemental, Psychic, Cosmic)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      window.SUPERNATURAL_POWERS_DATABASE = {
        // ============================================================
        // CATEGORY 1: ELEMENTAL POWERS (Nature & Elements)
        // ============================================================
        
        // Common Elemental (Level 1+)
        power_flame_touch: {
          id: "power_flame_touch", name: "Flame Touch", category: "elemental", type: "active", rarity: "common", 
          icon: "ğŸ”¥", element: "fire", cost: 800, levelReq: 1, unlockReq: null,
          cooldown: 8000, duration: 5000, 
          bonuses: { attack: 15, fireDamage: 0.1 },
          description: "Imbue your attacks with fire, dealing bonus burn damage",
          visualEffect: "flame_aura"
        },
        power_frost_shield: {
          id: "power_frost_shield", name: "Frost Shield", category: "elemental", type: "active", rarity: "common",
          icon: "â„ï¸", element: "ice", cost: 800, levelReq: 1, unlockReq: null,
          cooldown: 10000, duration: 6000,
          bonuses: { defense: 20, damageReduction: 0.15 },
          description: "Summon a protective ice barrier that reduces incoming damage",
          visualEffect: "frost_barrier"
        },
        power_earth_blessing: {
          id: "power_earth_blessing", name: "Earth Blessing", category: "elemental", type: "passive", rarity: "common",
          icon: "ğŸŒ¿", element: "earth", cost: 1000, levelReq: 1, unlockReq: null,
          bonuses: { maxHp: 100, hpRegen: 2, defense: 5 },
          description: "Channel earth's vitality for permanent HP boost and regeneration",
          visualEffect: "earth_glow"
        },
        power_wind_step: {
          id: "power_wind_step", name: "Wind Step", category: "elemental", type: "active", rarity: "common",
          icon: "ğŸ’¨", element: "wind", cost: 700, levelReq: 1, unlockReq: null,
          cooldown: 6000, duration: 4000,
          bonuses: { speed: 40, evasion: 0.2 },
          description: "Become as swift as the wind, increasing movement and evasion",
          visualEffect: "wind_trail"
        },
        power_shock_burst: {
          id: "power_shock_burst", name: "Shock Burst", category: "elemental", type: "active", rarity: "common",
          icon: "âš¡", element: "electric", cost: 750, levelReq: 1, unlockReq: null,
          cooldown: 7000, duration: 1000,
          bonuses: { attack: 25, stunChance: 0.15 },
          description: "Release a burst of electricity, stunning nearby enemies",
          visualEffect: "lightning_pulse"
        },
        power_nature_harmony: {
          id: "power_nature_harmony", name: "Nature Harmony", category: "elemental", type: "passive", rarity: "common",
          icon: "ğŸƒ", element: "nature", cost: 900, levelReq: 1, unlockReq: null,
          bonuses: { xpGain: 0.1, goldFind: 0.08, hpRegen: 3 },
          description: "Attune with nature to gain XP, gold, and healing bonuses",
          visualEffect: "nature_particles"
        },
        
        // Uncommon Elemental (Level 5+)
        power_inferno_rage: {
          id: "power_inferno_rage", name: "Inferno Rage", category: "elemental", type: "active", rarity: "uncommon",
          icon: "ğŸ”¥", element: "fire", cost: 4000, levelReq: 5, unlockReq: "Deal 10,000 fire damage",
          cooldown: 12000, duration: 8000,
          bonuses: { attack: 40, fireDamage: 0.25, critRate: 0.1 },
          description: "Unleash inner flames for massive fire damage and crit rate boost",
          visualEffect: "inferno_aura"
        },
        power_blizzard_field: {
          id: "power_blizzard_field", name: "Blizzard Field", category: "elemental", type: "active", rarity: "uncommon",
          icon: "â„ï¸", element: "ice", cost: 4000, levelReq: 5, unlockReq: "Freeze 25 enemies",
          cooldown: 15000, duration: 10000,
          bonuses: { defense: 35, slowEffect: 0.3, aoe: 50 },
          description: "Create a freezing aura that slows and damages enemies in range",
          visualEffect: "blizzard_zone"
        },
        power_lightning_reflexes: {
          id: "power_lightning_reflexes", name: "Lightning Reflexes", category: "elemental", type: "passive", rarity: "uncommon",
          icon: "âš¡", element: "electric", cost: 4500, levelReq: 5, unlockReq: "Dodge 50 attacks",
          bonuses: { speed: 25, attackSpeed: 0.2, evasion: 0.15, critRate: 0.08 },
          description: "Move with lightning speed, gaining attack speed and evasion",
          visualEffect: "lightning_trail"
        },
        power_stone_fortress: {
          id: "power_stone_fortress", name: "Stone Fortress", category: "elemental", type: "passive", rarity: "uncommon",
          icon: "ğŸ—¿", element: "earth", cost: 4200, levelReq: 5, unlockReq: "Take 20,000 damage",
          bonuses: { defense: 30, maxHp: 200, damageReduction: 0.12, thorns: 0.05 },
          description: "Become as sturdy as stone with enhanced defense and thorns",
          visualEffect: "stone_skin"
        },
        
        // Rare Elemental (Level 15+)
        power_phoenix_rebirth: {
          id: "power_phoenix_rebirth", name: "Phoenix Rebirth", category: "elemental", type: "passive", rarity: "rare",
          icon: "ğŸ”¥", element: "fire", cost: 20000, levelReq: 15, unlockReq: "Die 5 times",
          bonuses: { reviveChance: 0.25, maxHp: 300, fireDamage: 0.2, hpRegen: 5 },
          description: "25% chance to revive with 50% HP when defeated (once per battle)",
          visualEffect: "phoenix_flames"
        },
        power_storm_mastery: {
          id: "power_storm_mastery", name: "Storm Mastery", category: "elemental", type: "active", rarity: "rare",
          icon: "â›ˆï¸", element: "storm", cost: 22000, levelReq: 15, unlockReq: "Cast 100 elemental skills",
          cooldown: 20000, duration: 12000,
          bonuses: { attack: 50, allElementalDamage: 0.3, chainLightning: 3 },
          description: "Command the storm, chaining lightning between up to 3 enemies",
          visualEffect: "storm_vortex"
        },
        power_absolute_zero: {
          id: "power_absolute_zero", name: "Absolute Zero", category: "elemental", type: "active", rarity: "rare",
          icon: "â„ï¸", element: "ice", cost: 25000, levelReq: 15, unlockReq: "Freeze 100 enemies",
          cooldown: 25000, duration: 8000,
          bonuses: { iceDamage: 0.4, slowEffect: 0.5, freezeChance: 0.2 },
          description: "Freeze time itself, slowing enemies to a crawl and chance to freeze",
          visualEffect: "absolute_zero"
        },
        
        // Epic Elemental (Level 30+)
        power_elemental_fusion: {
          id: "power_elemental_fusion", name: "Elemental Fusion", category: "elemental", type: "active", rarity: "epic",
          icon: "ğŸŒˆ", element: "prismatic", cost: 80000, levelReq: 30, unlockReq: "Master all 4 basic elements",
          cooldown: 30000, duration: 15000,
          bonuses: { attack: 80, allElementalDamage: 0.5, allStats: 30 },
          description: "Fuse all elements into prismatic power, gaining massive bonuses",
          visualEffect: "prismatic_aura"
        },
        power_nature_avatar: {
          id: "power_nature_avatar", name: "Nature Avatar", category: "elemental", type: "passive", rarity: "epic",
          icon: "ğŸŒ³", element: "nature", cost: 90000, levelReq: 30, unlockReq: "Heal 50,000 HP total",
          bonuses: { maxHp: 500, hpRegen: 10, defense: 40, lifesteal: 0.15, thornsDamage: 0.1 },
          description: "Transform into a nature avatar with powerful regeneration and thorns",
          visualEffect: "nature_form"
        },
        
        // Legendary Elemental (Level 50+)
        power_primordial_chaos: {
          id: "power_primordial_chaos", name: "Primordial Chaos", category: "elemental", type: "active", rarity: "legendary",
          icon: "ğŸŒªï¸", element: "chaos", cost: 500000, levelReq: 50, unlockReq: "Reach max level",
          cooldown: 60000, duration: 20000,
          bonuses: { attack: 150, allDamage: 0.75, allStats: 50, chaosProc: 0.3 },
          description: "Unleash primordial chaos, randomizing damage types for massive power",
          visualEffect: "chaos_storm"
        },
        
        // ============================================================
        // CATEGORY 2: PSYCHIC POWERS (Mind & Soul)
        // ============================================================
        
        // Common Psychic (Level 1+)
        power_mind_focus: {
          id: "power_mind_focus", name: "Mind Focus", category: "psychic", type: "passive", rarity: "common",
          icon: "ğŸ§ ", element: "psychic", cost: 100, levelReq: 1, unlockReq: null,
          bonuses: { xpGain: 0.15, skillDamage: 0.1, manaRegen: 3 },
          description: "Sharpen your mind to learn faster and deal more skill damage",
          visualEffect: "mind_glow"
        },
        power_telepathy: {
          id: "power_telepathy", name: "Telepathy", category: "psychic", type: "active", rarity: "common",
          icon: "ğŸ‘ï¸", element: "psychic", cost: 90, levelReq: 1, unlockReq: null,
          cooldown: 10000, duration: 8000,
          bonuses: { detection: 50, critRate: 0.12, accuracy: 0.1 },
          description: "Read enemy minds to predict attacks and increase crit chance",
          visualEffect: "psychic_eye"
        },
        power_soul_link: {
          id: "power_soul_link", name: "Soul Link", category: "psychic", type: "passive", rarity: "common",
          icon: "ğŸ’œ", element: "soul", cost: 110, levelReq: 1, unlockReq: null,
          bonuses: { lifesteal: 0.08, hpRegen: 2, maxHp: 80 },
          description: "Link your soul to life force, stealing HP from enemies",
          visualEffect: "soul_tendrils"
        },
        power_barrier: {
          id: "power_barrier", name: "Psychic Barrier", category: "psychic", type: "active", rarity: "common",
          icon: "ğŸ›¡ï¸", element: "psychic", cost: 100, levelReq: 1, unlockReq: null,
          cooldown: 12000, duration: 5000,
          bonuses: { defense: 30, magicResist: 0.2, reflectDamage: 0.1 },
          description: "Create a mental barrier that reduces and reflects damage",
          visualEffect: "psychic_shield"
        },
        
        // Uncommon Psychic (Level 5+)
        power_mind_crush: {
          id: "power_mind_crush", name: "Mind Crush", category: "psychic", type: "active", rarity: "uncommon",
          icon: "ğŸ§ ", element: "psychic", cost: 600, levelReq: 5, unlockReq: "Deal 15,000 psychic damage",
          cooldown: 15000, duration: 1000,
          bonuses: { attack: 60, stunChance: 0.25, psychicDamage: 0.3 },
          description: "Crush enemy minds with psychic force, high stun chance",
          visualEffect: "mind_crush_wave"
        },
        power_third_eye: {
          id: "power_third_eye", name: "Third Eye", category: "psychic", type: "passive", rarity: "uncommon",
          icon: "ğŸ‘ï¸", element: "psychic", cost: 650, levelReq: 5, unlockReq: "Discover 10 secrets",
          bonuses: { critRate: 0.15, critDamage: 0.2, luck: 20, itemFind: 0.1 },
          description: "See beyond reality, gaining crit chance and loot bonuses",
          visualEffect: "third_eye_glow"
        },
        power_astral_projection: {
          id: "power_astral_projection", name: "Astral Projection", category: "psychic", type: "active", rarity: "uncommon",
          icon: "ğŸ‘»", element: "astral", cost: 580, levelReq: 5, unlockReq: "Explore 15 zones",
          cooldown: 18000, duration: 10000,
          bonuses: { speed: 50, evasion: 0.3, invulnFrames: 0.1 },
          description: "Project your spirit, becoming ethereal with high evasion",
          visualEffect: "astral_form"
        },
        power_soul_harvest: {
          id: "power_soul_harvest", name: "Soul Harvest", category: "psychic", type: "passive", rarity: "uncommon",
          icon: "ğŸ’€", element: "soul", cost: 620, levelReq: 5, unlockReq: "Defeat 100 enemies",
          bonuses: { lifesteal: 0.15, hpOnKill: 20, xpGain: 0.12, damageVsLowHp: 0.2 },
          description: "Harvest enemy souls for healing and bonus damage vs wounded foes",
          visualEffect: "soul_absorb"
        },
        
        // Rare Psychic (Level 15+)
        power_precognition: {
          id: "power_precognition", name: "Precognition", category: "psychic", type: "passive", rarity: "rare",
          icon: "ğŸ”®", element: "psychic", cost: 3000, levelReq: 15, unlockReq: "Perfect dodge 20 attacks",
          bonuses: { evasion: 0.25, critRate: 0.2, firstStrike: 1, counterAttack: 0.15 },
          description: "See the future to dodge attacks and counter with critical strikes",
          visualEffect: "precog_shimmer"
        },
        power_telekinesis: {
          id: "power_telekinesis", name: "Telekinesis", category: "psychic", type: "active", rarity: "rare",
          icon: "ğŸŒ€", element: "psychic", cost: 3200, levelReq: 15, unlockReq: "Lift 100 objects",
          cooldown: 20000, duration: 12000,
          bonuses: { attack: 70, range: 100, pushBack: 0.3, magnetRange: 80 },
          description: "Control objects with your mind, pushing enemies and pulling loot",
          visualEffect: "telekinetic_field"
        },
        power_soul_reaper: {
          id: "power_soul_reaper", name: "Soul Reaper", category: "psychic", type: "active", rarity: "rare",
          icon: "ğŸ’€", element: "soul", cost: 3500, levelReq: 15, unlockReq: "Collect 500 souls",
          cooldown: 25000, duration: 15000,
          bonuses: { attack: 80, lifesteal: 0.25, deathMark: 0.2, soulBurn: 30 },
          description: "Mark enemies for death, draining their souls with each hit",
          visualEffect: "soul_reaper_aura"
        },
        
        // Epic Psychic (Level 30+)
        power_mind_over_matter: {
          id: "power_mind_over_matter", name: "Mind Over Matter", category: "psychic", type: "passive", rarity: "epic",
          icon: "ğŸ§ ", element: "psychic", cost: 12000, levelReq: 30, unlockReq: "Perfect 50 battles",
          bonuses: { allDamage: 0.35, magicPower: 0.4, cooldownReduction: 0.15, focus: 50 },
          description: "Transcend physical limits through sheer mental power",
          visualEffect: "transcendent_mind"
        },
        power_astral_dominion: {
          id: "power_astral_dominion", name: "Astral Dominion", category: "psychic", type: "active", rarity: "epic",
          icon: "âœ¨", element: "astral", cost: 13000, levelReq: 30, unlockReq: "Achieve 10 perfect runs",
          cooldown: 40000, duration: 20000,
          bonuses: { allStats: 60, invulnerable: 0.15, timeSlowField: 0.4 },
          description: "Dominate the astral plane, slowing enemies while you move normally",
          visualEffect: "astral_domain"
        },
        
        // Legendary Psychic (Level 50+)
        power_omniscience: {
          id: "power_omniscience", name: "Omniscience", category: "psychic", type: "passive", rarity: "legendary",
          icon: "ğŸŒŸ", element: "cosmic", cost: 60000, levelReq: 50, unlockReq: "Achieve perfect wisdom",
          bonuses: { allDamage: 0.5, critRate: 0.3, evasion: 0.3, xpGain: 0.5, goldFind: 0.4, allStats: 75 },
          description: "Know all, see all - ultimate awareness grants overwhelming power",
          visualEffect: "omniscient_aura"
        },
        
        // ============================================================
        // CATEGORY 3: COSMIC POWERS (Space, Time, Reality)
        // ============================================================
        
        // Common Cosmic (Level 1+)
        power_gravity_well: {
          id: "power_gravity_well", name: "Gravity Well", category: "cosmic", type: "active", rarity: "common",
          icon: "ğŸŒ‘", element: "gravity", cost: 120, levelReq: 1, unlockReq: null,
          cooldown: 9000, duration: 6000,
          bonuses: { magnetRange: 100, pullForce: 0.3, areaDamage: 15 },
          description: "Create a gravity well that pulls enemies and items toward you",
          visualEffect: "gravity_sphere"
        },
        power_time_dilation: {
          id: "power_time_dilation", name: "Time Dilation", category: "cosmic", type: "active", rarity: "common",
          icon: "â°", element: "time", cost: 100, levelReq: 1, unlockReq: null,
          cooldown: 12000, duration: 5000,
          bonuses: { attackSpeed: 0.3, movementSpeed: 0.2, cooldownReduction: 0.1 },
          description: "Slow time around you, increasing your attack and movement speed",
          visualEffect: "time_distortion"
        },
        power_void_affinity: {
          id: "power_void_affinity", name: "Void Affinity", category: "cosmic", type: "passive", rarity: "common",
          icon: "ğŸ•³ï¸", element: "void", cost: 130, levelReq: 1, unlockReq: null,
          bonuses: { voidDamage: 0.15, defense: 10, damageReduction: 0.08 },
          description: "Embrace the void to gain resistance and void damage boost",
          visualEffect: "void_wisps"
        },
        power_starlight: {
          id: "power_starlight", name: "Starlight Blessing", category: "cosmic", type: "passive", rarity: "common",
          icon: "â­", element: "cosmic", cost: 110, levelReq: 1, unlockReq: null,
          bonuses: { luck: 15, goldFind: 0.1, xpGain: 0.12, itemQuality: 0.08 },
          description: "Channel starlight for luck, gold, and XP bonuses",
          visualEffect: "star_particles"
        },
        
        // Uncommon Cosmic (Level 5+)
        power_black_hole: {
          id: "power_black_hole", name: "Black Hole", category: "cosmic", type: "active", rarity: "uncommon",
          icon: "âš«", element: "gravity", cost: 700, levelReq: 5, unlockReq: "Pull 50 enemies",
          cooldown: 18000, duration: 8000,
          bonuses: { aoe: 120, pullForce: 0.5, crushDamage: 50, vacuumEffect: 0.3 },
          description: "Summon a black hole that pulls and crushes all nearby enemies",
          visualEffect: "black_hole_vortex"
        },
        power_time_stop: {
          id: "power_time_stop", name: "Time Stop", category: "cosmic", type: "active", rarity: "uncommon",
          icon: "â¸ï¸", element: "time", cost: 750, levelReq: 5, unlockReq: "Stop time 10 times",
          cooldown: 20000, duration: 3000,
          bonuses: { freezeAll: 1, freeMoves: 5, bonusDamage: 0.4 },
          description: "Stop time completely for 3 seconds of free attacks",
          visualEffect: "timestop_field"
        },
        power_dimensional_shift: {
          id: "power_dimensional_shift", name: "Dimensional Shift", category: "cosmic", type: "active", rarity: "uncommon",
          icon: "ğŸŒŒ", element: "dimension", cost: 650, levelReq: 5, unlockReq: "Teleport 30 times",
          cooldown: 8000, duration: 4000,
          bonuses: { evasion: 0.4, phaseThroughWalls: 1, backstabDamage: 0.3 },
          description: "Phase through dimensions to evade and backstab enemies",
          visualEffect: "dimension_flicker"
        },
        power_cosmic_awareness: {
          id: "power_cosmic_awareness", name: "Cosmic Awareness", category: "cosmic", type: "passive", rarity: "uncommon",
          icon: "ğŸŒ ", element: "cosmic", cost: 680, levelReq: 5, unlockReq: "Explore entire map",
          bonuses: { detectionRange: 200, rareFindChance: 0.15, secretDetection: 1, visionRange: 50 },
          description: "Sense all nearby secrets, enemies, and rare items",
          visualEffect: "cosmic_sense"
        },
        
        // Rare Cosmic (Level 15+)
        power_void_walk: {
          id: "power_void_walk", name: "Void Walk", category: "cosmic", type: "active", rarity: "rare",
          icon: "ğŸ•³ï¸", element: "void", cost: 3500, levelReq: 15, unlockReq: "Survive void damage 50 times",
          cooldown: 15000, duration: 10000,
          bonuses: { invulnerable: 0.3, voidDamage: 0.35, phaseAttacks: 1, ignoreDef: 0.2 },
          description: "Walk through the void, becoming partially invulnerable",
          visualEffect: "void_walker"
        },
        power_chronos_blessing: {
          id: "power_chronos_blessing", name: "Chronos Blessing", category: "cosmic", type: "passive", rarity: "rare",
          icon: "â³", element: "time", cost: 3200, levelReq: 15, unlockReq: "Master time abilities",
          bonuses: { cooldownReduction: 0.25, attackSpeed: 0.3, movementSpeed: 0.25, hasteDuration: 0.2 },
          description: "Blessed by the god of time, all actions are faster",
          visualEffect: "time_halo"
        },
        power_reality_warp: {
          id: "power_reality_warp", name: "Reality Warp", category: "cosmic", type: "active", rarity: "rare",
          icon: "ğŸŒ€", element: "reality", cost: 3800, levelReq: 15, unlockReq: "Bend reality 25 times",
          cooldown: 22000, duration: 12000,
          bonuses: { randomElementProc: 0.4, allDamage: 0.3, confuseEnemies: 0.2, luckBoost: 30 },
          description: "Warp reality itself, randomizing damage types for chaos",
          visualEffect: "reality_ripples"
        },
        
        // Epic Cosmic (Level 30+)
        power_singularity: {
          id: "power_singularity", name: "Singularity", category: "cosmic", type: "active", rarity: "epic",
          icon: "âš«", element: "gravity", cost: 14000, levelReq: 30, unlockReq: "Create 100 gravity wells",
          cooldown: 35000, duration: 15000,
          bonuses: { aoe: 200, pullForce: 0.8, crushDamage: 150, blackHoleDamage: 100 },
          description: "Collapse space into a singularity, devastating all enemies in range",
          visualEffect: "singularity_core"
        },
        power_chrono_mastery: {
          id: "power_chrono_mastery", name: "Chrono Mastery", category: "cosmic", type: "passive", rarity: "epic",
          icon: "â°", element: "time", cost: 13500, levelReq: 30, unlockReq: "Perfect timing 100 times",
          bonuses: { cooldownReduction: 0.4, attackSpeed: 0.5, movementSpeed: 0.4, timeRewind: 0.1 },
          description: "Master of time, 10% chance to rewind fatal damage",
          visualEffect: "chrono_field"
        },
        
        // Legendary Cosmic (Level 50+)
        power_universe_heart: {
          id: "power_universe_heart", name: "Universe Heart", category: "cosmic", type: "passive", rarity: "legendary",
          icon: "ğŸ’«", element: "cosmic", cost: 70000, levelReq: 50, unlockReq: "Become one with cosmos",
          bonuses: { allStats: 100, allDamage: 0.6, allResistance: 0.4, regenAll: 10, cosmicPower: 1 },
          description: "Contain the heart of the universe, granting godlike power",
          visualEffect: "universe_core"
        },
        power_omega_reality: {
          id: "power_omega_reality", name: "Omega Reality", category: "cosmic", type: "active", rarity: "legendary",
          icon: "ğŸŒŒ", element: "reality", cost: 75000, levelReq: 50, unlockReq: "Rewrite reality",
          cooldown: 90000, duration: 30000,
          bonuses: { allStats: 150, allDamage: 1.0, invulnerable: 0.5, realityControl: 1 },
          description: "Become reality itself - ultimate power for 30 seconds",
          visualEffect: "omega_field"
        }
      };

      window.CORES_DATABASE = {
        // Common Weapon Cores (Level 1+)
        core_basic: { 
          id: "core_basic", name: "Basic Core", category: "weapon", rarity: "common", icon: "ğŸ”¹", element: "neutral", cost: 100,
          weaponSkill: { id: "spark_pulse", name: "Spark Pulse", cooldown: 4, trigger: "time", damage: 50, range: 80 }, 
          passiveEffects: ["+5% skill XP gain", "+3% attack"]
        },
        core_spark: { 
          id: "core_spark", name: "Spark Core", category: "weapon", rarity: "common", icon: "âš¡", element: "electric", cost: 150,
          weaponSkill: { id: "thunder_strike", name: "Thunder Strike", cooldown: 3.5, trigger: "damage", damage: 60, range: 70 }, 
          passiveEffects: ["+8% electric damage", "+5% attack speed"]
        },
        core_ember: { 
          id: "core_ember", name: "Ember Core", category: "weapon", rarity: "common", icon: "ğŸ”¥", element: "fire", cost: 150,
          weaponSkill: { id: "ember_bolt", name: "Ember Bolt", cooldown: 4, trigger: "time", damage: 55, range: 90 }, 
          passiveEffects: ["+8% fire damage", "+4% attack"]
        },
        
        // Uncommon Weapon Cores (Level 5+)
        core_fire: { 
          id: "core_fire", name: "Fire Core", category: "weapon", rarity: "uncommon", icon: "ğŸ”¥", element: "fire", cost: 800,
          weaponSkill: { id: "flame_burst", name: "Flame Burst", cooldown: 5, trigger: "damage", damage: 90, range: 100 }, 
          passiveEffects: ["+15% fire damage", "+8% attack", "+5% crit chance"]
        },
        core_ice: { 
          id: "core_ice", name: "Ice Core", category: "weapon", rarity: "uncommon", icon: "â„ï¸", element: "ice", cost: 800,
          weaponSkill: { id: "frost_nova", name: "Frost Nova", cooldown: 6, trigger: "time", damage: 80, range: 120 }, 
          passiveEffects: ["+15% ice damage", "+10% slow effect", "+5% defense"]
        },
        core_thunder: { 
          id: "core_thunder", name: "Thunder Core", category: "weapon", rarity: "uncommon", icon: "âš¡", element: "electric", cost: 800,
          weaponSkill: { id: "chain_lightning", name: "Chain Lightning", cooldown: 5.5, trigger: "combo", damage: 85, range: 110, comboThreshold: 2 }, 
          passiveEffects: ["+15% electric damage", "+8% attack speed", "+5% chain range"]
        },
        
        // Rare Weapon Cores (Level 15+)
        core_shadow: { 
          id: "core_shadow", name: "Shadow Core", category: "weapon", rarity: "rare", icon: "ğŸŒ™", element: "shadow", cost: 3500,
          weaponSkill: { id: "shadow_strike", name: "Shadow Strike", cooldown: 4.5, trigger: "combo", damage: 150, range: 90, comboThreshold: 3 }, 
          passiveEffects: ["+20% shadow damage", "+15% crit rate", "+10% attack"]
        },
        core_light: { 
          id: "core_light", name: "Light Core", category: "weapon", rarity: "rare", icon: "âœ¨", element: "light", cost: 3500,
          weaponSkill: { id: "divine_ray", name: "Divine Ray", cooldown: 7, trigger: "time", damage: 120, range: 200, heal: 50 }, 
          passiveEffects: ["+20% light damage", "+15% heal power", "+8% defense"]
        },
        core_poison: { 
          id: "core_poison", name: "Poison Core", category: "weapon", rarity: "rare", icon: "â˜ ï¸", element: "poison", cost: 3500,
          weaponSkill: { id: "toxic_burst", name: "Toxic Burst", cooldown: 6, trigger: "damage", damage: 100, range: 95, dot: 20 }, 
          passiveEffects: ["+20% poison damage", "+12% DoT duration", "+10% attack"]
        },
        
        // Epic Weapon Cores (Level 30+)
        core_inferno: { 
          id: "core_inferno", name: "Inferno Core", category: "weapon", rarity: "epic", icon: "ğŸ”¥", element: "fire", cost: 12000,
          weaponSkill: { id: "meteor_strike", name: "Meteor Strike", cooldown: 8, trigger: "combo", damage: 250, range: 150, comboThreshold: 4, aoe: 80 }, 
          passiveEffects: ["+30% fire damage", "+20% attack", "+15% AoE radius", "+10% crit damage"]
        },
        core_void: { 
          id: "core_void", name: "Void Core", category: "weapon", rarity: "epic", icon: "ğŸŒ€", element: "shadow", cost: 12000,
          weaponSkill: { id: "void_spiral", name: "Void Spiral", cooldown: 9, trigger: "combo", damage: 230, range: 130, comboThreshold: 4, lifesteal: 20 }, 
          passiveEffects: ["+30% shadow damage", "+18% crit rate", "+15% lifesteal", "+10% attack speed"]
        },
        
        // Legendary Weapon Cores (Level 50+)
        core_myth: { 
          id: "core_myth", name: "Myth Core", category: "weapon", rarity: "legendary", icon: "ğŸ”®", element: "neutral", cost: 60000,
          weaponSkill: { id: "eclipse_nova", name: "Eclipse Nova", cooldown: 10, trigger: "combo", damage: 300, range: 200, comboThreshold: 5, aoe: 120 }, 
          passiveEffects: ["+35% all damage", "+25% crit rate", "+20% attack", "+15% skill cooldown reduction"]
        },
        core_chaos: { 
          id: "core_chaos", name: "Chaos Core", category: "weapon", rarity: "legendary", icon: "ğŸŒªï¸", element: "chaos", cost: 60000,
          weaponSkill: { id: "chaos_storm", name: "Chaos Storm", cooldown: 12, trigger: "combo", damage: 320, range: 180, comboThreshold: 5, aoe: 100, random: true }, 
          passiveEffects: ["+40% random elemental damage", "+20% all stats", "+15% chaos proc chance", "+10% XP gain"]
        },
        
        // Common Armor Cores (Level 1+)
        core_stone: { 
          id: "core_stone", name: "Stone Core", category: "armor", rarity: "common", icon: "ğŸª¨", element: "earth", cost: 100,
          weaponSkill: null, 
          passiveEffects: ["+5% defense", "+50 HP", "+3% damage reduction"]
        },
        core_shell: { 
          id: "core_shell", name: "Shell Core", category: "armor", rarity: "common", icon: "ğŸš", element: "neutral", cost: 150,
          weaponSkill: null, 
          passiveEffects: ["+8% defense", "+70 HP", "+5% block chance"]
        },
        
        // Uncommon Armor Cores (Level 5+)
        core_iron: { 
          id: "core_iron", name: "Iron Core", category: "armor", rarity: "uncommon", icon: "âš™ï¸", element: "metal", cost: 800,
          weaponSkill: null, 
          passiveEffects: ["+12% defense", "+150 HP", "+8% damage reduction", "+5% thorns damage"]
        },
        core_crystal: { 
          id: "core_crystal", name: "Crystal Core", category: "armor", rarity: "uncommon", icon: "ğŸ’", element: "crystal", cost: 800,
          weaponSkill: null, 
          passiveEffects: ["+10% defense", "+120 HP", "+10% magic resistance", "+8% shield strength"]
        },
        
        // Rare Armor Cores (Level 15+)
        core_titan: { 
          id: "core_titan", name: "Titan Core", category: "armor", rarity: "rare", icon: "ğŸ—¿", element: "earth", cost: 3500,
          weaponSkill: null, 
          passiveEffects: ["+20% defense", "+300 HP", "+15% damage reduction", "+10% HP regeneration", "+8% knockback resistance"]
        },
        core_phoenix: { 
          id: "core_phoenix", name: "Phoenix Core", category: "armor", rarity: "rare", icon: "ğŸ”¥", element: "fire", cost: 3500,
          weaponSkill: null, 
          passiveEffects: ["+15% defense", "+250 HP", "+20% fire resistance", "+15% HP regeneration", "+10% revive chance"]
        },
        
        // Epic Armor Cores (Level 30+)
        core_fortress: { 
          id: "core_fortress", name: "Fortress Core", category: "armor", rarity: "epic", icon: "ğŸ°", element: "metal", cost: 12000,
          weaponSkill: null, 
          passiveEffects: ["+30% defense", "+500 HP", "+20% damage reduction", "+15% all resistance", "+12% thorns damage", "+10% HP regeneration"]
        },
        
        // Legendary Armor Cores (Level 50+)
        core_aegis: { 
          id: "core_aegis", name: "Aegis Core", category: "armor", rarity: "legendary", icon: "ğŸ›¡ï¸", element: "divine", cost: 60000,
          weaponSkill: null, 
          passiveEffects: ["+40% defense", "+800 HP", "+25% damage reduction", "+20% all resistance", "+15% thorns damage", "+15% HP regeneration", "+10% invulnerability duration"]
        },
        
        // Common Accessory Cores (Level 1+)
        core_charm: { 
          id: "core_charm", name: "Charm Core", category: "accessory", rarity: "common", icon: "ğŸ”¸", element: "neutral", cost: 100,
          weaponSkill: null, 
          passiveEffects: ["+5% luck", "+3% item drop rate", "+3% gold find"]
        },
        core_lucky: { 
          id: "core_lucky", name: "Lucky Core", category: "accessory", rarity: "common", icon: "ğŸ€", element: "neutral", cost: 150,
          weaponSkill: null, 
          passiveEffects: ["+8% luck", "+5% crit chance", "+5% item quality"]
        },
        
        // Uncommon Accessory Cores (Level 5+)
        core_swift: { 
          id: "core_swift", name: "Swift Core", category: "accessory", rarity: "uncommon", icon: "ğŸ’¨", element: "wind", cost: 800,
          weaponSkill: null, 
          passiveEffects: ["+15% movement speed", "+10% attack speed", "+8% cooldown reduction", "+5% dodge chance"]
        },
        core_wisdom: { 
          id: "core_wisdom", name: "Wisdom Core", category: "accessory", rarity: "uncommon", icon: "ğŸ“š", element: "arcane", cost: 800,
          weaponSkill: null, 
          passiveEffects: ["+15% XP gain", "+10% skill damage", "+8% mana regeneration", "+5% cooldown reduction"]
        },
        
        // Rare Accessory Cores (Level 15+)
        core_vampire: { 
          id: "core_vampire", name: "Vampire Core", category: "accessory", rarity: "rare", icon: "ğŸ§›", element: "shadow", cost: 3500,
          weaponSkill: null, 
          passiveEffects: ["+20% lifesteal", "+15% attack", "+10% crit damage", "+8% health on kill", "+5% damage reduction"]
        },
        core_fortune: { 
          id: "core_fortune", name: "Fortune Core", category: "accessory", rarity: "rare", icon: "ğŸ’°", element: "neutral", cost: 3500,
          weaponSkill: null, 
          passiveEffects: ["+25% gold find", "+20% item drop rate", "+15% luck", "+10% rare item chance", "+8% gem drop rate"]
        },
        
        // Epic Accessory Cores (Level 30+)
        core_infinity: { 
          id: "core_infinity", name: "Infinity Core", category: "accessory", rarity: "epic", icon: "â™¾ï¸", element: "arcane", cost: 12000,
          weaponSkill: null, 
          passiveEffects: ["+30% mana regeneration", "+25% cooldown reduction", "+20% skill damage", "+15% XP gain", "+10% cast speed", "+10% all stats"]
        },
        
        // Legendary Accessory Cores (Level 50+)
        core_omnipotent: { 
          id: "core_omnipotent", name: "Omnipotent Core", category: "accessory", rarity: "legendary", icon: "ğŸŒŸ", element: "divine", cost: 60000,
          weaponSkill: null, 
          passiveEffects: ["+50% all stats", "+30% XP gain", "+25% gold find", "+20% item drop rate", "+15% all damage", "+15% all resistance", "+10% movement speed"]
        }
      };

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // CORE STATS CALCULATOR (Core Passive Effects Integration)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      class CoreStatsCalculator {
        static parseEffect(effectStr) {
          // Parse effect strings like "+15% fire damage", "+50 HP", "+10% attack"
          const match = effectStr.match(/([+-])(\d+(?:\.\d+)?)(%?)\s*(.+)/);
          if (!match) return null;
          
          const [, sign, value, isPercent, stat] = match;
          return {
            value: parseFloat(value) * (sign === '-' ? -1 : 1),
            isPercent: isPercent === '%',
            stat: stat.trim().toLowerCase(),
            raw: effectStr
          };
        }
        
        static calculateCoreBonuses(equippedCores) {
          const bonuses = {
            attack: { flat: 0, percent: 0 },
            defense: { flat: 0, percent: 0 },
            hp: { flat: 0, percent: 0 },
            crit: { flat: 0, percent: 0 },
            speed: { flat: 0, percent: 0 },
            cooldown: { flat: 0, percent: 0 },
            damage: { flat: 0, percent: 0 },
            xp: { flat: 0, percent: 0 },
            gold: { flat: 0, percent: 0 },
            luck: { flat: 0, percent: 0 },
            other: []
          };
          
          // Iterate through all equipped cores
          Object.values(equippedCores).forEach(core => {
            if (!core || !core.passiveEffects) return;
            
            core.passiveEffects.forEach(effectStr => {
              const effect = this.parseEffect(effectStr);
              if (!effect) {
                bonuses.other.push(effectStr);
                return;
              }
              
              // Map stat names to categories
              const statMap = {
                'attack': 'attack',
                'atk': 'attack',
                'defense': 'defense',
                'def': 'defense',
                'hp': 'hp',
                'health': 'hp',
                'crit': 'crit',
                'crit rate': 'crit',
                'crit chance': 'crit',
                'speed': 'speed',
                'attack speed': 'speed',
                'movement speed': 'speed',
                'cooldown': 'cooldown',
                'cooldown reduction': 'cooldown',
                'damage': 'damage',
                'all damage': 'damage',
                'xp': 'xp',
                'xp gain': 'xp',
                'gold': 'gold',
                'gold find': 'gold',
                'luck': 'luck'
              };
              
              let category = statMap[effect.stat];
              if (!category) {
                // Check if it contains a mapped word
                for (const [key, value] of Object.entries(statMap)) {
                  if (effect.stat.includes(key)) {
                    category = value;
                    break;
                  }
                }
              }
              
              if (category && bonuses[category]) {
                if (effect.isPercent) {
                  bonuses[category].percent += effect.value;
                } else {
                  bonuses[category].flat += effect.value;
                }
              } else {
                bonuses.other.push(effectStr);
              }
            });
          });
          
          return bonuses;
        }
        
        static applyCoreEffects(baseStats, equippedCores) {
          const bonuses = this.calculateCoreBonuses(equippedCores);
          const finalStats = { ...baseStats };
          
          // Apply core bonuses to stats
          finalStats.ATK = Math.round(
            (finalStats.ATK + bonuses.attack.flat) * (1 + bonuses.attack.percent / 100)
          );
          finalStats.DEF = Math.round(
            (finalStats.DEF + bonuses.defense.flat) * (1 + bonuses.defense.percent / 100)
          );
          finalStats.HP = Math.round(
            (finalStats.HP + bonuses.hp.flat) * (1 + bonuses.hp.percent / 100)
          );
          
          // Store bonus breakdown for display
          finalStats.coreBonuses = bonuses;
          
          return finalStats;
        }
      }
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // CORE EQUIPMENT FUNCTIONS (Equip/Unequip Core Management)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      window.equipCoreToSlot = function(equipmentSlotId, core) {
        const coreConfig = CORE_SLOTS_CONFIG[equipmentSlotId];
        if (!coreConfig) {
          debugError('Invalid equipment slot:', equipmentSlotId);
          return false;
        }
        
        // Validate core category matches equipment slot
        if (core.category !== coreConfig.coreType) {
          debugError(`Core category ${core.category} doesn't match slot type ${coreConfig.coreType}`);
          alert(`âš ï¸ This ${core.category} core cannot be equipped to ${coreConfig.label}!\n\nUse a ${coreConfig.coreType} core instead.`);
          return false;
        }
        
        // Check if item is unlocked
        if (!window.isItemUnlocked(core)) {
          const levelReq = RARITY_REQUIREMENTS[core.rarity]?.level || 1;
          alert(`ğŸ”’ This core requires level ${levelReq}!`);
          return false;
        }
        
        // Store the core by the coreSuffix (e.g., 'weaponCore', 'headCore')
        const coreSlotKey = coreConfig.coreSuffix;
        window.gameState.equippedCores[coreSlotKey] = core;
        
        // Recalculate stats
        window.recalculateStats();
        
        debugLog(`âœ… Equipped ${core.name} to ${equipmentSlotId}`);
        return true;
      };
      
      window.unequipCore = function(equipmentSlotId) {
        const coreConfig = CORE_SLOTS_CONFIG[equipmentSlotId];
        if (!coreConfig) {
          debugError('Invalid equipment slot:', equipmentSlotId);
          return false;
        }
        
        const coreSlotKey = coreConfig.coreSuffix;
        const removedCore = window.gameState.equippedCores[coreSlotKey];
        
        if (!removedCore) {
          return false; // Nothing to unequip
        }
        
        delete window.gameState.equippedCores[coreSlotKey];
        
        // Recalculate stats
        window.recalculateStats();
        
        debugLog(`âœ… Unequipped ${removedCore.name} from ${equipmentSlotId}`);
        return true;
      };
      
      window.getCoreForSlot = function(equipmentSlotId) {
        const coreConfig = CORE_SLOTS_CONFIG[equipmentSlotId];
        if (!coreConfig) return null;
        
        const coreSlotKey = coreConfig.coreSuffix;
        return window.gameState.equippedCores[coreSlotKey] || null;
      };
      
      window.getAllEquippedCores = function() {
        return window.gameState.equippedCores || {};
      };
      
      window.getEquippedWeaponSkills = function() {
        const skills = [];
        const equippedCores = window.gameState.equippedCores || {};
        
        Object.entries(equippedCores).forEach(([slotKey, core]) => {
          if (core && core.weaponSkill) {
            skills.push({
              core: core,
              skill: core.weaponSkill,
              slot: slotKey
            });
          }
        });
        
        return skills;
      };
      
      window.recalculateStats = function() {
        if (window.BagSystem?.computePlayerStats) {
          const stats = window.BagSystem.computePlayerStats();
          window.gameState.currentStats = stats;
          return stats;
        }
        return { ATK: 100, DEF: 50, HP: 1000 };
      };
      
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // SUPERNATURAL POWER UNLOCK SYSTEM
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      window.canUnlockPower = function(power) {
        const playerLevel = window.gameState.playerLevel || 1;
        
        // Check level requirement
        if (playerLevel < power.levelReq) {
          return { canUnlock: false, reason: `Level ${power.levelReq} required` };
        }
        
        // Check if already unlocked
        if (window.isPowerUnlocked(power)) {
          return { canUnlock: false, reason: 'Already unlocked' };
        }
        
        // Check unlock requirement (quest/achievement)
        if (power.unlockReq) {
          // For demo purposes, uncommon+ powers need to be unlocked with essence
          const unlocked = window.gameState.unlockedPowers || [];
          if (!unlocked.includes(power.id)) {
            return { canUnlock: true, reason: `Unlock with essence`, needsEssence: true };
          }
        }
        
        // Common powers (no unlock req) - check if player has enough gold
        if (!power.unlockReq && power.rarity === 'common') {
          return { canUnlock: true, reason: 'Available for purchase' };
        }
        
        return { canUnlock: true, reason: 'Ready to unlock' };
      };
      
      window.isPowerUnlocked = function(power) {
        const unlockedPowers = window.gameState.unlockedPowers || [];
        // Common powers with no unlock requirement are always "unlocked" (just need to be purchased)
        if (!power.unlockReq && power.rarity === 'common') {
          return true;
        }
        // Others need to be in the unlocked list
        return unlockedPowers.includes(power.id);
      };
      
      window.unlockPower = function(powerId) {
        if (!window.gameState.unlockedPowers) {
          window.gameState.unlockedPowers = [];
        }
        
        if (!window.gameState.unlockedPowers.includes(powerId)) {
          window.gameState.unlockedPowers.push(powerId);
          debugLog(`âœ… Unlocked power: ${powerId}`);
          return true;
        }
        return false;
      };
      
      window.learnPower = function(power) {
        if (!window.gameState.inventory.abilities) {
          window.gameState.inventory.abilities = [];
        }
        
        // Check if already learned
        const existing = window.gameState.inventory.abilities.find(a => a.id === power.id);
        if (existing) {
          return { success: false, message: 'Already learned this power!' };
        }
        
        // Add to abilities inventory
        window.gameState.inventory.abilities.push({...power});
        
        return { success: true, message: `âœ… Learned ${power.name}!` };
      };

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // LEVEL-BASED RARITY UNLOCK SYSTEM (RPG Standard)
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      const RARITY_REQUIREMENTS = {
        common: { level: 1, goldCost: 0 },
        uncommon: { level: 5, goldCost: 500 },
        rare: { level: 15, goldCost: 2500 },
        epic: { level: 30, goldCost: 10000 },
        legendary: { level: 50, goldCost: 50000 }
      };
      
      // Make RARITY_REQUIREMENTS globally accessible
      window.RARITY_REQUIREMENTS = RARITY_REQUIREMENTS;

      const FLEX_SOCKET_UNLOCK_LEVEL = 20;
      
      // Helper function to ensure item has levelReq based on rarity
      window.normalizeItemLevelReq = function(item) {
        if (!item) return item;
        if (!item.levelReq && item.rarity) {
          item.levelReq = RARITY_REQUIREMENTS[item.rarity]?.level || 1;
        } else if (!item.levelReq) {
          item.levelReq = 1; // Default to level 1 if no rarity
        }
        return item;
      };

      // Check if item can be unlocked (works for pets, spirits, vehicles, robots, gear, etc.)
      window.canUnlockItem = function(item) {
        if (!item) return { canUnlock: false, reason: 'Item not found' };
        
        const playerLevel = window.gameState?.playerLevel || 1;
        const rarity = item.rarity || 'common';
        const req = RARITY_REQUIREMENTS[rarity];
        
        // Check level requirement
        const levelReq = item.levelReq || (req?.level || 1);
        if (playerLevel < levelReq) {
          return { canUnlock: false, reason: `Level ${levelReq} required` };
        }
        
        // Check if already unlocked
        if (window.isItemUnlocked(item)) {
          return { canUnlock: false, reason: 'Already unlocked' };
        }
        
        // Check unlock requirement (achievement/quest-based)
        if (item.unlockReq) {
          // Check if item is in unlockedItems list
          // Achievement tracking is implemented
          const unlockedItems = window.gameState?.unlockedItems || [];
          if (!unlockedItems.includes(item.id)) {
            // Check if unlock requirement can be met
            return { canUnlock: true, reason: `Requires: ${item.unlockReq}`, needsUnlock: true };
          }
        }
        
        // Check gold cost for rarity-based unlock
        if (req && req.goldCost > 0) {
          const gold = window.gameState?.gold || 0;
          if (gold < req.goldCost) {
            return { canUnlock: false, reason: `Need ${req.goldCost} gold to unlock` };
          }
        }
        
        // Common items (no unlock req) - available for purchase
        if (!item.unlockReq && rarity === 'common') {
          return { canUnlock: true, reason: 'Available for purchase' };
        }
        
        return { canUnlock: true, reason: 'Ready to unlock' };
      };

      // Check if item is unlocked (works for all item types)
      window.isItemUnlocked = function(item) {
        if (!item) return false;
        
        const unlockedItems = window.gameState?.unlockedItems || [];
        const rarity = item.rarity || 'common';
        const playerLevel = window.gameState?.playerLevel || 1;
        
        // Common items with no unlock requirement are always "unlocked" (just need to be purchased)
        if (!item.unlockReq && rarity === 'common') {
          return true;
        }
        
        // Check if explicitly unlocked
        if (unlockedItems.includes(item.id)) {
          return true;
        }
        
        // Auto-unlock if player level meets requirement and item has no unlockReq
        const req = RARITY_REQUIREMENTS[rarity];
        const levelReq = item.levelReq || (req?.level || 1);
        if (!item.unlockReq && playerLevel >= levelReq) {
          // Auto-add to unlocked list
          if (!window.gameState.unlockedItems) window.gameState.unlockedItems = [];
          if (!window.gameState.unlockedItems.includes(item.id)) {
            window.gameState.unlockedItems.push(item.id);
          }
          return true;
        }
        
        return false;
      };

      // Unlock item with gold
      window.unlockItemWithGold = function(item) {
        const req = RARITY_REQUIREMENTS[item.rarity];
        if (!req || req.goldCost === 0) return false;
        
        const playerLevel = window.gameState?.playerLevel || 1;
        const gold = window.gameState?.gold || 0;
        
        if (gold < req.goldCost) {
          alert(`Not enough gold! Need ${req.goldCost} gold.`);
          return false;
        }
        if (playerLevel >= req.level) {
          alert(`Already unlocked at your level!`);
          return false;
        }
        
        window.gameState.gold -= req.goldCost;
        if (!window.gameState.unlockedItems) window.gameState.unlockedItems = [];
        window.gameState.unlockedItems.push(item.id);
        
        alert(`Unlocked ${item.name || 'item'} for ${req.goldCost} gold!`);
        return true;
      };

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // BAG SYSTEM CLASS
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      // Bag System Class
      window.BagSystem = {
        isOpen: false,
        hudInitialized: false,
        autoAILoopInterval: null,
        autoAILoopIterations: 0,
        autoAILoopStartTime: null,
        autoAITaskQueue: [],
        autoAITaskTimeout: null,
        autoAITaskActive: false,
        autoAIClickHandler: null,
        engine: null,
        state: {
          activeTab: 'skills',
          itemsSubtab: 'inventory',
          alchemySlots: [null, null, null],
          alchemyResult: null,
          gearFilter: 'all',
          gearSort: 'power',
          vehicleFilter: 'all',
          vehicleSort: 'speed',
          petFilter: 'all',
          petSort: 'attack',
          spiritFilter: 'all',
          spiritSort: 'power',
          robotFilter: 'all',
          robotSort: 'atk',
          shopFilter: 'all',
          shopSort: 'cost',
          selectedCharacter: 'Missy',
          pinnedItems: new Set(),
          equipped: null,
          companionLoadouts: [],
          hudSettings: null
        },
        CHARACTER_SKILL_SLOTS: ['S1', 'S2', 'S3', 'S4', 'S5', 'X1', 'X2'],
        ULTIMATE_SLOT_KEYS: ['X1', 'X2'],

        SKILL_LEVELING_CONFIG: {
          maxLevel: 10,
          levelBonus: 0.08,
          cooldownReductionPerLevel: 0.05,
          baseGoldByTier: {
            starter: 50,
            common: 100,
            uncommon: 250,
            rare: 500,
            epic: 1200,
            legendary: 2500,
          },
        },

        SKILL_RANK_ORDER: ['E', 'D', 'C', 'B', 'A', 'S', 'SS', 'SSS'],

        SKILL_RANK_MULTIPLIERS: {
          E: 1.0,
          D: 1.2,
          C: 1.5,
          B: 2.0,
          A: 2.5,
          S: 3.0,
          SS: 4.0,
          SSS: 5.0,
        },

        ensureSkillMetadata(skill) {
          if (!skill) return null;
          if (typeof skill.level !== 'number' || skill.level < 1) {
            skill.level = 1;
          }
          if (!skill.rank) {
            skill.rank = 'E';
          }
          if (!skill.instance_id) {
            skill.instance_id = `skill_${skill.id}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          }
          if (!skill.baseStats || typeof skill.baseStats !== 'object') {
            const baseStats = {};
            const numericKeys = ['damage', 'cooldown', 'duration', 'heal', 'shield', 'dot', 'hot', 'ticks', 'radius', 'range', 'projectiles', 'hits', 'power'];
            numericKeys.forEach((key) => {
              if (typeof skill[key] === 'number' && !Number.isNaN(skill[key])) {
                baseStats[key] = skill[key];
              }
            });
            skill.baseStats = baseStats;
          }
          return skill;
        },

        ensureAllSkillsMetadata() {
          const skills = window.gameState?.inventory?.skills;
          if (!Array.isArray(skills)) return;
          skills.forEach((skill) => {
            this.ensureSkillMetadata(skill);
            if (skill.baseStats) {
              this.applySkillScaling(skill);
            }
          });
        },

        getSkillRankIndex(rank) {
          return this.SKILL_RANK_ORDER.indexOf(rank || 'E');
        },

        getNextSkillRank(rank) {
          const index = this.getSkillRankIndex(rank);
          if (index === -1 || index >= this.SKILL_RANK_ORDER.length - 1) {
            return null;
          }
          return this.SKILL_RANK_ORDER[index + 1];
        },

        getSkillRankMultiplier(rank) {
          return this.SKILL_RANK_MULTIPLIERS[rank] || 1;
        },

        countSkillCopies(skillId, rank = 'E') {
          const skills = window.gameState?.inventory?.skills || [];
          return skills.reduce((count, skill) => {
            const sameId = skill.id === skillId;
            const sameRank = (skill.rank || 'E') === (rank || 'E');
            return count + (sameId && sameRank ? 1 : 0);
          }, 0);
        },

        canFuseSkill(skill) {
          const rank = skill.rank || 'E';
          const copies = this.countSkillCopies(skill.id, rank);
          const hasNextRank = !!this.getNextSkillRank(rank);
          return copies >= 3 && hasNextRank;
        },

        calculateSkillLevelCost(skill) {
          this.ensureSkillMetadata(skill);
          const tierKey = (skill.tier || 'common').toLowerCase();
          const baseCost = this.SKILL_LEVELING_CONFIG.baseGoldByTier[tierKey] ?? this.SKILL_LEVELING_CONFIG.baseGoldByTier.common;
          const level = skill.level || 1;
          // Solo Leveling: Multiply upgrade costs by 100 for high-stakes economy
          return Math.round(baseCost * (level + 1) * 100);
        },

        applySkillScaling(skill) {
          this.ensureSkillMetadata(skill);
          const baseStats = skill.baseStats || {};
          const level = Math.min(skill.level || 1, this.SKILL_LEVELING_CONFIG.maxLevel);
          const rankMultiplier = this.getSkillRankMultiplier(skill.rank);
          const levelMultiplier = 1 + (level - 1) * this.SKILL_LEVELING_CONFIG.levelBonus;
          const totalMultiplier = levelMultiplier * rankMultiplier;
          Object.entries(baseStats).forEach(([key, value]) => {
            if (typeof value !== 'number' || Number.isNaN(value)) return;
            if (key.toLowerCase().includes('cooldown')) {
              const scaled = value / totalMultiplier;
              skill[key] = Math.max(0.3, parseFloat(scaled.toFixed(2)));
            } else {
              const scaled = value * totalMultiplier;
              const rounded = Math.abs(scaled) >= 10 ? Math.round(scaled) : parseFloat(scaled.toFixed(2));
              skill[key] = rounded;
            }
          });
          return skill;
        },

        upgradeSkillLevel(skillId, instanceId = null) {
          const skills = window.gameState?.inventory?.skills || [];
          if (!skills.length) {
            this.showToast('âŒ No skills available to upgrade.');
            return;
          }

          const skill = instanceId
            ? skills.find((entry) => entry.instance_id === instanceId)
            : skills.find((entry) => entry.id === skillId);

          if (!skill) {
            this.showToast('âŒ Skill not found in inventory.');
            return;
          }

          this.ensureSkillMetadata(skill);

          if (skill.level >= this.SKILL_LEVELING_CONFIG.maxLevel) {
            this.showToast('âš ï¸ Skill already at max level!');
            return;
          }

          const cost = this.calculateSkillLevelCost(skill);
          if ((window.gameState.gold || 0) < cost) {
            this.showToast(`ğŸ’° Need ${cost.toLocaleString()}g to upgrade!`);
            return;
          }

          window.gameState.gold -= cost;
          skill.level += 1;
          this.applySkillScaling(skill);
          this.refreshEquippedSkillReferences(skill);
          this.syncQuickSlotsToCharacter(skill.characterId || this.state.activeCharacter);

          this.showToast(`â¬†ï¸ ${skill.icon || 'âœ¨'} ${skill.name} upgraded to Lv.${skill.level}! (-${cost.toLocaleString()}g)`);
          this.emitEvent('skills:level-up', { skill });
          this.renderSkillsTab();
        },

        fuseSkillRank(skillId, rank = 'E') {
          const skills = window.gameState?.inventory?.skills || [];
          if (!skills.length) {
            this.showToast('âŒ No skills available to fuse.');
            return;
          }

          const normalizedRank = rank || 'E';
          const rankIndex = this.getSkillRankIndex(normalizedRank);
          if (rankIndex === -1) {
            this.showToast('âš ï¸ Invalid rank for fusion.');
            return;
          }

          const candidates = [];
          skills.forEach((skill, index) => {
            this.ensureSkillMetadata(skill);
            if (skill.id === skillId && (skill.rank || 'E') === normalizedRank) {
              candidates.push({ index, skill });
            }
          });

          if (candidates.length < 3) {
            this.showToast('âš ï¸ Need 3 copies of the same skill rank to fuse!');
            return;
          }

          const nextRank = this.getNextSkillRank(normalizedRank);
          if (!nextRank) {
            this.showToast('âœ¨ Skill already at highest rank!');
            return;
          }

          const [primary, ...rest] = candidates.slice(0, 3);
          const template = { ...primary.skill };
          const baseStats = { ...(template.baseStats || {}) };

          const removalIndexes = candidates.slice(0, 3).map(entry => entry.index).sort((a, b) => b - a);
          removalIndexes.forEach(idx => skills.splice(idx, 1));

          const fusedSkill = {
            ...template,
            level: 1,
            rank: nextRank,
            baseStats,
            instance_id: `skill_${template.id}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          };

          this.applySkillScaling(fusedSkill);
          skills.push(fusedSkill);

          this.showToast(`ğŸ’  ${template.icon || 'âœ¨'} ${template.name} fused to Rank ${nextRank}!`);
          this.emitEvent('skills:rank-up', { skill: fusedSkill, consumed: removalIndexes.length });
          this.renderSkillsTab();
        },

        normalizeGearItem(item) {
          if (!item) return item;
          if (window.GearData) {
            if (!item.templateId && window.GearData.lookup[item.id]) {
              item.templateId = item.id;
            }
            if (typeof item.upgradeLevel !== 'number') {
              item.upgradeLevel = item.upgradeLevel ?? item.level ?? 0;
            }
            window.GearData.applyStats(item);
            item.power = window.GearData.calculateItemPower(item);
          } else {
            item.power = (item.attack || 0) + (item.defense || 0) + (item.hp || 0);
          }
          return item;
        },

        normalizeGearCollection(collection = []) {
          return collection.map(item => this.normalizeGearItem(item));
        },

        getItemTypeKey(item) {
          if (!item) return null;
          const raw = (item.type || item.category || '').toString().trim().toLowerCase();
          if (!raw) return null;
          const aliasMap = {
            cores: 'core',
            core: 'core',
            boxes: 'box',
            box: 'box',
            container: 'box',
            containers: 'box',
            pets: 'pet',
            pet: 'pet',
            spirits: 'spirit',
            spirit: 'spirit',
            vehicles: 'vehicle',
            vehicle: 'vehicle',
            robots: 'robot',
            robot: 'robot',
            accessories: 'accessory',
            accessory: 'accessory',
            armor: 'armor',
            weapon: 'weapon',
            weapons: 'weapon',
            consumables: 'consumable',
            consumable: 'consumable',
            items: 'consumable',
            essences: 'essence',
            essence: 'essence',
            supernatural: 'supernatural',
            abilities: 'supernatural',
            set: 'set',
            gear: 'gear'
          };
          return aliasMap[raw] || raw;
        },

        getGearStatBadgesHTML(item) {
          if (!item) return '';
          this.normalizeGearItem(item);
          const stats = item.stats || {};
          const badges = [];
          GEAR_STAT_DISPLAY_ORDER.forEach(statKey => {
            const value = stats[statKey] ?? item[statKey];
            if (value) {
              badges.push(formatGearBadge(statKey, value));
            }
          });
          return badges.slice(0, 6).join('');
        },

        getGearPrimaryStatSummary(item) {
          if (!item) return '';
          this.normalizeGearItem(item);
          const stats = item.stats || {};
          const highlights = [];
          for (const statKey of GEAR_STAT_DISPLAY_ORDER) {
            const value = stats[statKey] ?? item[statKey];
            if (value) {
              const formatted = formatGearStatText(statKey, value);
              if (formatted) highlights.push(formatted);
            }
            if (highlights.length >= 3) break;
          }
          return highlights.join(' ');
        },

        getGearPower(item) {
          this.normalizeGearItem(item);
          return item.power || this.calculateItemPower(item);
        },

        calculateGearUpgradeCost(item, targetLevel) {
          let cost;
          if (window.GearData) {
            cost = window.GearData.calculateUpgradeCost(item, targetLevel);
          } else {
          const base = 500;
            cost = Math.round(base * targetLevel);
          }
          // Solo Leveling: Multiply upgrade costs by 100 for high-stakes economy
          return cost * 100;
        },

        performGearUpgrade(item, options = {}) {
          if (!item) return { upgraded: false, cost: 0, reason: 'INVALID_ITEM' };
          this.normalizeGearItem(item);
          const def = window.GearData?.getDefinition(item);
          const maxLevel = item.maxUpgradeLevel || def?.upgrade?.maxLevel || 10;
          const currentLevel = item.upgradeLevel || 0;
          if (currentLevel >= maxLevel) {
            return { upgraded: false, cost: 0, reason: 'MAX_LEVEL' };
          }

          const targetLevel = currentLevel + 1;
          const cost = this.calculateGearUpgradeCost(item, targetLevel);
          if (options.checkOnly) {
            return { upgraded: false, cost };
          }

          if (window.gameState.gold < cost) {
            return { upgraded: false, cost, reason: 'NO_GOLD' };
          }

          window.gameState.gold -= cost;
          item.upgradeLevel = targetLevel;

          // Recalculate stats based on upgrade level
          if (window.GearData && typeof window.GearData.applyStats === 'function') {
            window.GearData.applyStats(item, item.upgradeLevel);
          } else {
            // Fallback stat calculation
            if (item.attack) item.attack = Math.floor(item.attack * 1.2);
            if (item.defense) item.defense = Math.floor(item.defense * 1.2);
            if (item.hp) item.hp = Math.floor(item.hp * 1.2);
            if (item.mp) item.mp = Math.floor(item.mp * 1.2);
            if (item.speed) item.speed = Math.floor(item.speed * 1.1);
          }

          item.power = this.calculateItemPower(item);
          
          // Refresh gear displays if currently viewing gear tab
          if (this.state.activeTab === 'gear') {
            this.renderGearTab();
          }
          
          return { upgraded: true, cost, newLevel: item.upgradeLevel };
        },

        calculateBattlePower(finalStats) {
          // Battle Power calculation with weighted stats
          const weights = {
            attack: 2.0,
            defense: 1.8,
            hp: 0.5,
            mp: 0.2,
            speed: 10.0,
            critRate: 20.0,
            critDamage: 15.0,
            lifesteal: 12.0,
            cooldownReduction: 10.0
          };

          let bp = 0;
          bp += (finalStats.attack || 0) * weights.attack;
          bp += (finalStats.defense || 0) * weights.defense;
          bp += (finalStats.hp || 0) * weights.hp;
          bp += (finalStats.mp || 0) * weights.mp;
          bp += (finalStats.speed || 0) * weights.speed;
          bp += ((finalStats.critRate || 0) * 100) * weights.critRate; // Convert to percentage
          bp += ((finalStats.critDamage || 0) * 100) * weights.critDamage; // Convert to percentage
          bp += ((finalStats.lifesteal || 0) * 100) * weights.lifesteal; // Convert to percentage
          bp += ((finalStats.cooldownReduction || 0) * 100) * weights.cooldownReduction; // Convert to percentage

          return Math.round(bp);
        },

        computePlayerStats() {
          const baseStats = {
            hp: 100,
            mp: 50,
            attack: 10,
            defense: 5,
            speed: 1,
            critRate: 0.05,
            critDamage: 0.5,
            lifesteal: 0,
            armorPen: 0,
            block: 0,
            evade: 0,
            cooldownReduction: 0,
            elementalDamage: 0,
            elementalResist: 0
          };

          const totals = { ...baseStats };
          const equipped = window.gameState.equipped || {};
          const setCounts = {};

          Object.values(equipped).forEach(item => {
            if (!item) return;
            this.normalizeGearItem(item);
            const stats = item.stats || {};
            Object.entries(stats).forEach(([key, value]) => {
              if (value) totals[key] = (totals[key] || 0) + value;
            });
            if (item.set) {
              setCounts[item.set] = (setCounts[item.set] || 0) + 1;
            }
          });

          if (window.GearData?.getSetBonuses) {
            Object.entries(setCounts).forEach(([setId, pieces]) => {
              const bonuses = window.GearData.getSetBonuses(setId, pieces);
              Object.entries(bonuses).forEach(([key, value]) => {
                totals[key] = (totals[key] || 0) + value;
              });
            });
          }

          const talents = window.gameState.talents?.tree || [];
          talents.forEach(talent => {
            if (talent.currentLevel > 0) {
              const level = talent.currentLevel;
              if (talent.id === 'combat_1') totals.attack += 5 * level;
              if (talent.id === 'combat_2') totals.critRate += 0.1 * level;
              if (talent.id === 'combat_4') totals.attack = Math.floor(totals.attack * (1 + 0.2 * level));
              if (talent.id === 'combat_5') totals.attack = Math.floor(totals.attack * 1.25);
              if (talent.id === 'defense_1') totals.defense += 5 * level;
              if (talent.id === 'defense_2') totals.hp += 50 * level;
              if (talent.id === 'defense_5') {
                totals.defense = Math.floor(totals.defense * 1.3);
                totals.hp += 100;
              }
            }
          });

          // Apply Ability Point bonuses (Solo Leveling style)
          const pointsInStrength = window.gameState.pointsInStrength || 0;
          const pointsInVitality = window.gameState.pointsInVitality || 0;
          const pointsInAgility = window.gameState.pointsInAgility || 0;
          const pointsInIntelligence = window.gameState.pointsInIntelligence || 0;
          
          totals.attack += pointsInStrength * 2;
          totals.defense += Math.floor(pointsInVitality * 1.5);
          totals.hp += pointsInVitality * 10;
          totals.speed += pointsInAgility * 0.5;
          totals.critRate += pointsInAgility * 0.003; // 0.3% per point
          totals.mp += pointsInIntelligence * 5;
          totals.cooldownReduction += pointsInIntelligence * 0.002; // 0.2% per point

          const activeSynergies = this.getActiveSynergies();
          activeSynergies.forEach(syn => {
            if (syn.name === 'Unbreakable Warrior') {
              totals.attack += 50;
              totals.defense += 50;
            }
          });

          // Apply Pet stats (if equipped)
          const equippedPet = window.gameState.equipped?.pet;
          if (equippedPet) {
            if (equippedPet.attack) totals.attack += equippedPet.attack;
            if (equippedPet.defense) totals.defense += equippedPet.defense;
            if (equippedPet.health) totals.hp += equippedPet.health;
            if (equippedPet.hp) totals.hp += equippedPet.hp;
          }

          // Apply Spirit stats (if equipped)
          const equippedSpirit = window.gameState.equipped?.spirit;
          if (equippedSpirit && equippedSpirit.bonuses) {
            const bonuses = equippedSpirit.bonuses;
            // Apply flat bonuses
            if (bonuses.attack) totals.attack += bonuses.attack;
            if (bonuses.defense) totals.defense += bonuses.defense;
            if (bonuses.hp || bonuses.hpFlat) totals.hp += (bonuses.hp || bonuses.hpFlat);
            if (bonuses.mp) totals.mp += bonuses.mp;
            if (bonuses.speed) totals.speed += bonuses.speed;
            if (bonuses.critRate) totals.critRate += bonuses.critRate;
            if (bonuses.critDamage) totals.critDamage += bonuses.critDamage;
            if (bonuses.lifesteal) totals.lifesteal += bonuses.lifesteal;
            if (bonuses.cooldownReduction) totals.cooldownReduction += bonuses.cooldownReduction;
            // Apply multipliers
            if (bonuses.atkMul) totals.attack = Math.floor(totals.attack * (1 + bonuses.atkMul));
            if (bonuses.defMul) totals.defense = Math.floor(totals.defense * (1 + bonuses.defMul));
            if (bonuses.hpMul) totals.hp = Math.floor(totals.hp * (1 + bonuses.hpMul));
            if (bonuses.speedMul) totals.speed = totals.speed * (1 + bonuses.speedMul);
          }

          // Apply Supernatural passive abilities stats
          const abilities = window.gameState.inventory?.abilities || [];
          abilities.forEach(ability => {
            if (ability.type === 'passive' && ability.bonuses) {
              const bonuses = ability.bonuses;
              // Apply all stat bonuses from passive abilities
              Object.entries(bonuses).forEach(([key, value]) => {
                if (value && typeof value === 'number') {
                  // Handle percentage-based bonuses
                  if (key.includes('Mul') || key === 'xpGain' || key === 'goldFind' || key === 'damageReduction' || key === 'movementSpeed' || key === 'attackSpeed') {
                    // These are multipliers/percentages, skip direct addition
                    return;
                  }
                  // Apply flat bonuses
                  if (totals[key] !== undefined) {
                    totals[key] = (totals[key] || 0) + value;
                  } else if (key === 'maxHp') {
                    totals.hp = (totals.hp || 0) + value;
                  } else if (key === 'skillDamage' || key === 'allDamage') {
                    // These affect damage calculations but not base stats
                    return;
                  }
                }
              });
            }
          });

          const finalStats = window.CoreStatsCalculator
            ? window.CoreStatsCalculator.applyCoreEffects(totals, window.gameState.equippedCores || {})
            : totals;

          finalStats.attack = Math.round(finalStats.attack || 0);
          finalStats.defense = Math.round(finalStats.defense || 0);
          finalStats.hp = Math.round(finalStats.hp || 0);
          finalStats.mp = Math.round(finalStats.mp || 0);
          finalStats.speed = Number((finalStats.speed || 0).toFixed(2));
          finalStats.critRate = Number((finalStats.critRate || 0).toFixed(3));
          finalStats.critDamage = Number((finalStats.critDamage || 0).toFixed(3));
          finalStats.critChance = finalStats.critRate;
          finalStats.ATK = finalStats.attack;
          finalStats.DEF = finalStats.defense;
          finalStats.HP = finalStats.hp;

          // Calculate Battle Power
          finalStats.battlePower = this.calculateBattlePower(finalStats);

          return finalStats;
        },

        initializeAbilityPointsSystem() {
          // Ensure gameState exists
          if (!window.gameState) {
            window.gameState = {};
          }
          
          // Initialize Talent Points System (for talent tree)
          if (!window.gameState.talents || typeof window.gameState.talents !== 'object') {
            window.gameState.talents = {
              points: 0,
              tree: [],
              allocated: [],
              synergies: []
            };
          } else {
            // Ensure required properties exist
            if (typeof window.gameState.talents.points !== 'number') window.gameState.talents.points = 0;
            if (!Array.isArray(window.gameState.talents.tree)) window.gameState.talents.tree = [];
            if (!Array.isArray(window.gameState.talents.allocated)) window.gameState.talents.allocated = [];
            if (!Array.isArray(window.gameState.talents.synergies)) window.gameState.talents.synergies = [];
          }
          
          // Initialize Ability Points System (for stat allocation - Solo Leveling style)
          if (typeof window.gameState.abilityPoints !== 'number') window.gameState.abilityPoints = 0;
          if (typeof window.gameState.pointsInStrength !== 'number') window.gameState.pointsInStrength = 0;
          if (typeof window.gameState.pointsInVitality !== 'number') window.gameState.pointsInVitality = 0;
          if (typeof window.gameState.pointsInAgility !== 'number') window.gameState.pointsInAgility = 0;
          if (typeof window.gameState.pointsInIntelligence !== 'number') window.gameState.pointsInIntelligence = 0;
          
          // Initialize level tracking if missing
          if (typeof window.gameState.playerLevel !== 'number') {
            window.gameState.playerLevel = window.gameState.level || 1;
          }
          if (typeof window.gameState.xp !== 'number') window.gameState.xp = 0;
          if (typeof window.gameState.xpToNext !== 'number') {
            window.gameState.xpToNext = this.calculateXPForLevel(window.gameState.playerLevel || 1);
          }
          
          debugLog('[BagSystem] Ability Points System initialized');
        },

        calculateXPForLevel(level) {
          if (level <= 1) return 100;
          if (level <= 0) return 100; // Edge case handling
          return Math.floor(100 * Math.pow(1.5, level - 1));
        },

        handleLevelUp(newLevel, options = {}) {
          if (!window.gameState) {
            debugWarn('[BagSystem] Cannot handle level up: gameState not found');
            return;
          }
          
          const oldLevel = window.gameState.playerLevel || window.gameState.level || 1;
          const actualNewLevel = newLevel || oldLevel + 1;
          
          // Update level
          window.gameState.playerLevel = actualNewLevel;
          if (window.gameState.level !== actualNewLevel) {
            window.gameState.level = actualNewLevel;
          }
          
          // Grant ability points (3 per level, Solo Leveling style)
          const apGranted = options.abilityPoints !== undefined ? options.abilityPoints : 3;
          window.gameState.abilityPoints = (window.gameState.abilityPoints || 0) + apGranted;
          
          // Recalculate XP requirement for next level
          window.gameState.xpToNext = this.calculateXPForLevel(actualNewLevel);
          
          // Show level-up animation
          if (options.showAnimation !== false && typeof this.showLevelUpAnimation === 'function') {
            this.showLevelUpAnimation();
          }
          
          // Emit event for other systems
          if (typeof this.emitEvent === 'function') {
            this.emitEvent('level-up', {
              oldLevel,
              newLevel: actualNewLevel,
              abilityPointsGranted: apGranted,
              totalAbilityPoints: window.gameState.abilityPoints
            });
          }
          
          // Show toast notification
          if (typeof this.showToast === 'function') {
            this.showToast(`â¬†ï¸ Level Up! Level ${actualNewLevel} (+${apGranted} Ability Points)`);
          }
          
          debugLog(`[BagSystem] Level up: ${oldLevel} â†’ ${actualNewLevel}, +${apGranted} AP`);
        },

        gainXP(amount, options = {}) {
          if (!window.gameState || !amount || amount <= 0) {
            return { levelsGained: 0, newLevel: window.gameState?.playerLevel || window.gameState?.level || 1, xpRemaining: window.gameState?.xp || 0 };
          }
          
          const currentXP = window.gameState.xp || 0;
          const currentLevel = window.gameState.playerLevel || window.gameState.level || 1;
          const xpToNext = window.gameState.xpToNext || this.calculateXPForLevel(currentLevel);
          
          window.gameState.xp = currentXP + amount;
          
          // Check for level ups
          let levelsGained = 0;
          let newLevel = currentLevel;
          let remainingXP = window.gameState.xp;
          let currentXPToNext = xpToNext;
          
          while (remainingXP >= currentXPToNext) {
            remainingXP -= currentXPToNext;
            newLevel++;
            levelsGained++;
            currentXPToNext = this.calculateXPForLevel(newLevel);
          }
          
          // Update gameState
          window.gameState.xp = remainingXP;
          window.gameState.xpToNext = currentXPToNext;
          
          // Handle level ups
          if (levelsGained > 0) {
            for (let i = 0; i < levelsGained; i++) {
              this.handleLevelUp(currentLevel + i + 1, {
                showAnimation: i === levelsGained - 1, // Only show animation on final level
                abilityPoints: 3
              });
            }
          }
          
          return { levelsGained, newLevel, xpRemaining: remainingXP };
        },

        storageKeys: {
          companionUids: 'a1k_equipped_companion_uids_v1',
          companionLoadouts: 'a1k_companion_loadouts_v1'
        },

        ensureLoadoutSlots() {
          if (!Array.isArray(this.state.companionLoadouts)) {
            this.state.companionLoadouts = [];
          }
          const defaults = ['Loadout A', 'Loadout B', 'Loadout C'];
          while (this.state.companionLoadouts.length < defaults.length) {
            const index = this.state.companionLoadouts.length;
            this.state.companionLoadouts.push({
              id: `slot-${index + 1}`,
              name: defaults[index],
              petId: null,
              vehicleId: null,
              spiritId: null,
              updatedAt: 0
            });
          }
          if (this.state.companionLoadouts.length > defaults.length) {
            this.state.companionLoadouts.length = defaults.length;
          }
        },

        loadCompanionLoadouts() {
          try {
            const stored = JSON.parse(localStorage.getItem(this.storageKeys.companionLoadouts) || '[]');
            if (Array.isArray(stored)) {
              this.state.companionLoadouts = stored;
            }
          } catch (error) {
            debugWarn('[BagSystem] Failed to load companion loadouts', error);
            this.state.companionLoadouts = [];
          }
          this.ensureLoadoutSlots();
        },

        saveCompanionLoadouts() {
          this.ensureLoadoutSlots();
          try {
            localStorage.setItem(this.storageKeys.companionLoadouts, JSON.stringify(this.state.companionLoadouts));
          } catch (error) {
            debugWarn('[BagSystem] Failed to persist companion loadouts', error);
          }
        },

        getCompanionSummary(type, id) {
          if (!id) return { label: 'None', icon: type === 'vehicle' ? 'ğŸš—' : type === 'spirit' ? 'âœ¨' : 'ğŸ¾' };
          const inventory = window.gameState?.inventory || {};
          let collection = [];
          if (type === 'pet') collection = inventory.pets || [];
          if (type === 'vehicle') collection = inventory.vehicles || [];
          if (type === 'spirit') collection = inventory.spirits || [];
          const found = collection.find((entry) => entry?.id === id);
          if (found) {
            return { label: found.name || id, icon: found.icon || this.getDefaultIconForType(type) };
          }
          if (type === 'pet' && window.PetCollectionSystem?.getPetDefinition) {
            const def = window.PetCollectionSystem.getPetDefinition(id);
            if (def) return { label: def.name || id, icon: def.icon || 'ğŸ¾' };
          }
          if (type === 'vehicle' && window.VehicleCollectionSystem?.getVehicleDefinition) {
            const def = window.VehicleCollectionSystem.getVehicleDefinition(id);
            if (def) return { label: def.name || id, icon: def.icon || 'ğŸš—' };
          }
          return { label: id, icon: this.getDefaultIconForType(type) };
        },

        getDefaultIconForType(type) {
          switch (type) {
            case 'vehicle': return 'ğŸš—';
            case 'spirit': return 'âœ¨';
            case 'team': return 'ğŸ‘¥';
            default: return 'ğŸ¾';
          }
        },

        describeCompanionSlot(type, id) {
          const summary = this.getCompanionSummary(type, id);
          if (!summary || summary.label === 'None') {
            return 'None';
          }
          return `${summary.icon} ${summary.label}`;
        },

        findCompanionInInventory(type, id) {
          if (!id) return null;
          const inventory = window.gameState?.inventory || {};
          if (type === 'pet') return (inventory.pets || []).find(p => p.id === id) || null;
          if (type === 'vehicle') return (inventory.vehicles || []).find(v => v.id === id) || null;
          if (type === 'spirit') return (inventory.spirits || []).find(s => s.id === id) || null;
          return null;
        },

        saveCompanionLoadout(loadoutId) {
          this.ensureLoadoutSlots();
          const loadout = this.state.companionLoadouts.find((entry) => entry.id === loadoutId);
          if (!loadout) {
            this.showToast?.('âš ï¸ Loadout not found', '#f87171');
            return;
          }
          const equipped = this.state.equipped || {};
          loadout.petId = equipped.pet?.id || null;
          loadout.vehicleId = equipped.vehicle?.id || null;
          loadout.spiritId = equipped.spirit?.id || null;
          loadout.updatedAt = Date.now();
          this.saveCompanionLoadouts();
          this.showToast?.(`ğŸ’¾ Saved ${loadout.name}`);
          this.renderPetsTab();
        },

        applyCompanionLoadout(loadoutId) {
          this.ensureLoadoutSlots();
          const loadout = this.state.companionLoadouts.find((entry) => entry.id === loadoutId);
          if (!loadout) {
            this.showToast?.('âš ï¸ Loadout not found', '#f87171');
            return;
          }

          const applySlot = (slot, id) => {
            if (!id) return false;
            const item = this.findCompanionInInventory(slot, id);
            if (!item) {
              this.showToast?.(`âš ï¸ ${slot.charAt(0).toUpperCase() + slot.slice(1)} "${id}" not in inventory`, '#f87171');
              return false;
            }
            this.toggleCompanionActivation(slot, {
              ensureEquip: true,
              item,
              preferSpawn: true,
              origin: 'companion-loadout',
              showToast: true
            });
            return true;
          };

          let changed = false;
          changed = applySlot('pet', loadout.petId) || changed;
          changed = applySlot('vehicle', loadout.vehicleId) || changed;
          changed = applySlot('spirit', loadout.spiritId) || changed;

          if (!changed) {
            this.showToast?.('âš ï¸ Loadout empty or items missing', '#f87171');
          } else {
            this.showToast?.(`âœ… Applied ${loadout.name}`);
          }
          this.renderPetsTab();
          this.renderVehiclesTab?.();
          this.renderSpiritTab?.();
        },

        previewCompanionLoadout(loadoutId) {
          this.ensureLoadoutSlots();
          const loadout = this.state.companionLoadouts.find((entry) => entry.id === loadoutId);
          if (!loadout) {
            this.showToast?.('âš ï¸ Loadout not found', '#f87171');
            return;
          }
          const engine = this.ensureEngine();
          const manager = engine?.systems?.companion || (typeof resolveCompanionManager === 'function' ? resolveCompanionManager() : null);
          if (!manager?.previewSummonFx) {
            this.showToast?.('âš ï¸ Companion system warming up...', '#f87171');
            return;
          }

          const previewSlot = (slot, id) => {
            if (!id) return false;
            const item = this.findCompanionInInventory(slot, id);
            if (!item) return false;
            const sanitized = this.prepareEquippable(item, slot);
            manager.previewSummonFx(slot, { item: sanitized });
            return true;
          };

          let triggered = false;
          triggered = previewSlot('pet', loadout.petId) || triggered;
          triggered = previewSlot('vehicle', loadout.vehicleId) || triggered;
          triggered = previewSlot('spirit', loadout.spiritId) || triggered;

          if (triggered) {
            this.showToast?.(`âœ¨ Previewed ${loadout.name}`);
          } else {
            this.showToast?.('âš ï¸ Loadout has no companions to preview', '#f87171');
          }
        },

        renderCompanionLoadouts() {
          this.ensureLoadoutSlots();
          const formatSlotLine = (label, type, id) => {
            const value = this.describeCompanionSlot(type, id);
            return `<div style="display:flex;justify-content:space-between;font-size:11px;color:rgba(15,23,42,0.75);"><span>${label}</span><span>${value}</span></div>`;
          };
          return `
            <div class="companion-loadouts" style="margin-top: 28px;">
              <h3 style="margin: 0 0 12px 0; font-size: 16px; color: #ff80d8; display:flex; align-items:center; gap:8px;">
                <span>ğŸ¬</span> Chibi Loadouts
              </h3>
              <p style="margin: 0 0 16px 0; font-size: 11px; color: rgba(255, 255, 255, 0.65);">
                Save and swap candy-colored squads instantly.
              </p>
              <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 14px;">
                ${this.state.companionLoadouts.map((loadout, index) => `
                  <div class="loadout-card" data-loadout-id="${loadout.id}"
                       style="background: linear-gradient(145deg, rgba(255, 176, 240, 0.25), rgba(126, 212, 255, 0.25));
                              border: 2px solid rgba(255, 255, 255, 0.35);
                              border-radius: 18px;
                              padding: 16px;
                              box-shadow: 0 12px 24px rgba(15, 23, 42, 0.25);
                              backdrop-filter: blur(8px);">
                    <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:12px;">
                      <div style="display:flex; align-items:center; gap:8px;">
                        <span style="font-size: 18px;">ğŸ¡</span>
                        <span style="font-size: 13px; font-weight: 700; color: #ff9af0;">${loadout.name}</span>
                  </div>
                      <button type="button" class="loadout-btn rename" data-action="rename-loadout"
                              style="border:none;background:transparent;font-size:14px;cursor:pointer;color:#ffb6ff;"
                              title="Rename loadout">âœï¸</button>
                  </div>
                    <div style="background: rgba(255, 255, 255, 0.55); border-radius: 12px; padding: 12px; display:flex; flex-direction:column; gap:6px;">
                      ${formatSlotLine('ğŸ¾ Pet', 'pet', loadout.petId)}
                      ${formatSlotLine('ğŸš— Vehicle', 'vehicle', loadout.vehicleId)}
                      ${formatSlotLine('âœ¨ Spirit', 'spirit', loadout.spiritId)}
                    </div>
                    <div style="display:flex; gap:8px; margin-top:14px;">
                      <button type="button" class="loadout-btn apply" data-action="apply-loadout"
                              style="flex:1;padding:8px 0;border-radius:999px;border:none;background:linear-gradient(135deg,#ff80d8,#ffbdde);color:#52225c;font-weight:700;font-size:11px;cursor:pointer;">
                        Equip
                      </button>
                      <button type="button" class="loadout-btn preview" data-action="preview-loadout"
                              style="flex:1;padding:8px 0;border-radius:999px;border:none;background:linear-gradient(135deg,#88e0ff,#6ccfff);color:#04364f;font-weight:700;font-size:11px;cursor:pointer;">
                        Preview
                      </button>
                      <button type="button" class="loadout-btn save" data-action="save-loadout"
                              style="flex:1;padding:8px 0;border-radius:999px;border:none;background:linear-gradient(135deg,#caffbf,#9ef6a5);color:#0b3d2e;font-weight:700;font-size:11px;cursor:pointer;">
                        Save
                      </button>
                  </div>
                </div>
              `).join('')}
              </div>
            </div>
          `;
        },
        
        attachCompanionLoadoutHandlers(root) {
          if (!root) return;
          root.querySelectorAll('.loadout-btn').forEach(btn => {
            btn.addEventListener('click', (event) => {
              event.stopPropagation();
              const card = btn.closest('.loadout-card');
              if (!card) return;
              const loadoutId = card.dataset.loadoutId;
              const action = btn.dataset.action;
              if (action === 'apply-loadout') this.applyCompanionLoadout(loadoutId);
              else if (action === 'preview-loadout') this.previewCompanionLoadout(loadoutId);
              else if (action === 'save-loadout') this.saveCompanionLoadout(loadoutId);
              else if (action === 'rename-loadout') this.renameCompanionLoadout(loadoutId);
            });
          });
        },

        renameCompanionLoadout(loadoutId) {
          this.ensureLoadoutSlots();
          const loadout = this.state.companionLoadouts.find((entry) => entry.id === loadoutId);
          if (!loadout) {
            this.showToast?.('âš ï¸ Loadout not found', '#f87171');
            return;
          }
          const nextName = window.prompt('Enter loadout name:', loadout.name || 'Loadout');
          if (!nextName) {
            return;
          }
          loadout.name = nextName.trim().substring(0, 32) || loadout.name;
          loadout.updatedAt = Date.now();
          this.saveCompanionLoadouts();
        this.showToast?.('ğŸ¬ Loadout updated! Check the Team tab to see it in action.');
          if (this.state.activeTab === 'team') {
            this.renderTeamTab();
          } else {
          this.renderPetsTab();
          }
        },

        /**
         * Mirrors equipped companion data into legacy `st` structures so older systems
         * remain in sync with the primary bag state.
         */
        syncLegacyCompanionSlot(type, payload) {
          const normalizedType = String(type || '').toLowerCase();
          const legacy = window.st;
          if (!legacy) {
            return;
          }

          let clone = null;
          if (payload) {
            try {
              clone = typeof structuredClone === 'function'
                ? structuredClone(payload)
                : JSON.parse(JSON.stringify(payload));
            } catch (error) {
              debugWarn('[BagSystem] Structured clone fallback used for', normalizedType, error);
              clone = { ...payload };
            }
          }

          try {
            switch (normalizedType) {
              case 'pet': {
                const cfgSlotsRaw =
                  window.CFG?.companions?.petSlots ??
                  window.A1K_Config?.companions?.petSlots ??
                  legacy.petSlots ??
                  1;
                const parsed = Number(cfgSlotsRaw);
                const slots = Number.isFinite(parsed) && parsed > 0 ? Math.max(1, Math.floor(parsed)) : 1;
                legacy.petSlots = slots;
                if (!Array.isArray(legacy.equippedPets)) {
                  legacy.equippedPets = [];
                }
                if (legacy.equippedPets.length > slots) {
                  legacy.equippedPets.length = slots;
                }
                while (legacy.equippedPets.length < slots) {
                  legacy.equippedPets.push(null);
                }
                legacy.equippedPets[0] = clone;
                if (Array.isArray(legacy.activePets)) {
                  legacy.activePets = legacy.activePets.filter(
                    (pet) => pet && pet._slotIndex != null && pet._slotIndex < slots,
                  );
                }
                break;
              }
              case 'vehicle': {
                legacy.equippedVehicle = clone;
                break;
              }
              case 'spirit': {
                legacy.equippedSpirit = clone;
                break;
              }
              case 'robot': {
                legacy.equippedRobot = clone;
                break;
              }
              default:
                break;
            }
          } catch (error) {
            debugWarn('[BagSystem] Failed to sync legacy companion slot', normalizedType, error);
            this.showToast?.('âš ï¸ Companion sync issue â€“ check console for details.', '#ff6b6b');
          }
        },

        /**
         * Mirrors bag companion selections into the shared CompanionManager so
         * cooldowns, HUD badges, and persistence stay authoritative.
         */
        syncCompanionManager(type, payload) {
          const normalizedType = String(type || '').toLowerCase();
          if (!['pet', 'vehicle', 'spirit', 'team'].includes(normalizedType)) {
            return;
          }

          const engine = this.ensureEngine();
          const manager = engine?.systems?.companion;
          if (!manager) {
            return;
          }

          try {
            const sanitized = payload ? { ...payload } : null;
            manager.persistEquippedSlot?.(normalizedType, sanitized);
            manager.updateHudSnapshot?.('bag-sync', { type: normalizedType, uid: sanitized?.uid || null });
          } catch (error) {
            debugWarn('[BagSystem] Companion manager sync failed', normalizedType, error);
            this.showToast?.('âš ï¸ Companion manager sync failed.', '#ff6b6b');
          }
        },

        ensureEngine() {
          if (!this.engine || !this.engine.state?.isInitialized) {
            this.engine = window.A1K_Engine || this.engine || null;
          }
          return this.engine;
        },

        validateCompanionAssets() {
          if (this.__manifestValidationRunning) {
            return;
          }
          this.__manifestValidationRunning = true;
          if (typeof fetch !== 'function') {
            debugWarn('[BagSystem] Manifest validator skipped (fetch unavailable).');
            this.__manifestValidationRunning = false;
            return;
          }

          const normalizePath = (path) => String(path || '')
            .replace(/\\/g, '/')
            .replace(/^\.\//, '')
            .replace(/^\/+/, '')
            .trim()
            .toLowerCase();

          const manifestCandidates = [
            typeof window !== 'undefined' ? window.A1K_ALL_MANIFESTS_PATH : null,
            typeof window !== 'undefined' ? window.A1K_ASSET_MANIFEST_PATH : null,
            this.__resolvedAssetManifestPath || null,
            'all-manifests.json',
            '../../assets/all-manifests.json',
            '../assets/all-manifests.json',
            './assets/all-manifests.json',
            '../../assets/asset_manifest.json',
            '../assets/asset_manifest.json',
            './assets/asset_manifest.json',
            '../../../assets/asset_manifest.json',
            '../a1k bag system/assets/asset_manifest.json',
            '../../a1k bag system/assets/asset_manifest.json',
          ];

          const candidatePaths = manifestCandidates
            .map((candidate) => (typeof candidate === 'string' ? candidate.trim() : ''))
            .filter((candidate) => candidate.length > 0);

          const uniqueCandidates = [];
          candidatePaths.forEach((candidate) => {
            if (!uniqueCandidates.includes(candidate)) {
              uniqueCandidates.push(candidate);
            }
          });

          const attemptManifestFetch = (index = 0) => {
            if (index >= uniqueCandidates.length) {
              return Promise.reject(new Error('No asset manifest candidates resolved.'));
            }
            const targetPath = uniqueCandidates[index];
            return fetch(targetPath, { cache: 'no-store' })
              .then((response) => {
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                this.__resolvedAssetManifestPath = targetPath;
                return response.json();
              })
              .catch((error) => {
                debugWarn(`[BagSystem] Manifest fetch failed for ${targetPath}`, error);
                return attemptManifestFetch(index + 1);
              });
          };

          attemptManifestFetch()
            .then((manifest) => {
              // Handle new merged manifest structure (all-manifests.json)
              // If manifest has assetManifest key, use that; otherwise use manifest directly (backward compatibility)
              const assetManifest = manifest?.assetManifest || manifest;
              const assets = Array.isArray(assetManifest?.assets) ? assetManifest.assets : [];
              const assetPaths = new Set(assets.map((entry) => normalizePath(entry.path)));
              const missing = [];

              const inspectCollection = (entries, type) => {
                if (!entries) return;
                Object.values(entries).forEach((entry) => {
                  if (!entry || typeof entry !== 'object') return;
                  const spritePath = entry.spriteSheetUrl || entry.sprite || entry.spriteUrl;
                  if (!spritePath) return;
                  if (!assetPaths.has(normalizePath(spritePath))) {
                    missing.push({ type, id: entry.id || entry.name || 'unknown', path: spritePath });
                  }
                });
              };

              const petSystem = window.PetCollectionSystem;
              const vehicleSystem = window.VehicleCollectionSystem;
              const petEntries = petSystem?.manifestCache || petSystem?.petDatabase;
              const vehicleEntries = vehicleSystem?.manifestCache || vehicleSystem?.vehicleDatabase;
              inspectCollection(petEntries, 'Pet');
              inspectCollection(vehicleEntries, 'Vehicle');

              if (missing.length > 0) {
                debugWarn('[BagSystem] Companion manifest validation detected missing assets:', missing);
                if (typeof this.addSystemMessage === 'function') {
                  this.addSystemMessage('âš ï¸ Manifest validator detected missing companion sprites.', 'warning');
                  missing.slice(0, 10).forEach((entry) => {
                    this.addSystemMessage(`â€¢ ${entry.type}: ${entry.id} â†’ ${entry.path}`, 'error');
                  });
                  if (missing.length > 10) {
                    this.addSystemMessage(`â€¦and ${missing.length - 10} more. See console for full list.`, 'warning');
                  }
                }
                this.showToast?.('âš ï¸ Missing companion sprites detected. See log.', '#f87171');
              } else {
                debugLog('[BagSystem] Companion manifest validation passed.');
              }
            })
            .catch((error) => {
              debugWarn('[BagSystem] Companion manifest validation failed', error);
            })
            .finally(() => {
              this.__manifestValidationRunning = false;
            });
        },

        computeCompanionUid(type, item) {
          if (!item) return null;
          if (item.uid) return item.uid;
          const baseId = item.id || item.name || `${type}_${Date.now()}`;
          return `${type}_${String(baseId)}`.replace(/\s+/g, '_').toLowerCase();
        },

        isCompanionSpawned(type, item) {
          const engine = this.ensureEngine();
          const manager = engine?.systems?.companion;
          if (!manager || typeof manager.isSpawned !== 'function') {
            return false;
          }
          const uid = this.computeCompanionUid(type, item);
          if (!uid) return false;
          try {
            return !!manager.isSpawned(uid);
          } catch (error) {
            debugWarn('[BagSystem] Failed to query companion spawn status', error);
            return false;
          }
        },

        prepareEquippable(item, type) {
          if (!item) return null;
          const clone = { ...item };
          clone.type = type;
          clone.uid = this.computeCompanionUid(type, clone);
          clone.id = clone.id || clone.uid;
          if (type === 'spirit' && !clone.vfx_uid) {
            clone.vfx_uid = `${clone.uid}::pending_vfx`;
          }
          return clone;
        },

        toggleCompanionActivation(type, options = {}) {
          const normalized = String(type || '').toLowerCase();
          if (!['pet', 'vehicle', 'spirit', 'team', 'robot'].includes(normalized)) {
            debugWarn('[BagSystem] Unsupported companion slot for activation', type);
            return false;
          }

          const {
            ensureEquip = false,
            item = null,
            preferSpawn = false,
            forceRecall = false,
            origin = 'bag',
            showToast = false,
          } = options;

          const engine = this.ensureEngine();
          const manager = engine?.systems?.companion;
          if (!manager || typeof manager.toggleCompanion !== 'function') {
            if (showToast !== false) {
              this.showToast?.('âš ï¸ Companion system warming up...', '#ff6b6b');
            }
            return false;
          }

          const slotRenderMap = {
            pet: () => this.renderPetsTab?.(),
            vehicle: () => this.renderVehiclesTab?.(),
            spirit: () => this.renderSpiritTab?.(),
            team: () => this.renderTeamTab?.(),
            robot: () => this.renderAITab?.(),
          };

          let equippedSlot =
            this.state.equipped?.[normalized] ||
            window.gameState?.equipped?.[normalized] ||
            null;

          const ensureEquippedItem = (candidate) => {
            if (!candidate) return;
            const candidateUid = this.computeCompanionUid(normalized, candidate);
            const currentUid = equippedSlot?.uid || null;
            const currentId = equippedSlot?.id || null;
            const matches =
              (candidateUid && currentUid && candidateUid === currentUid) ||
              (candidate.id && currentId && candidate.id === currentId);
            if (matches) return;
            switch (normalized) {
              case 'pet':
                this.equipPet(candidate);
                break;
              case 'vehicle':
                this.equipVehicle(candidate);
                break;
              case 'spirit':
                this.equipSpirit(candidate);
                break;
              case 'robot':
                this.equipRobot(candidate);
                break;
              default:
                break;
            }
            equippedSlot =
              this.state.equipped?.[normalized] ||
              window.gameState?.equipped?.[normalized] ||
              null;
          };

          if (ensureEquip && item) {
            ensureEquippedItem(item);
          }

          const equipped =
            manager.getEquippedItem?.(normalized) ||
            equippedSlot ||
            null;

          if (!equipped) {
            if (showToast !== false) {
              const friendlyName = normalized.charAt(0).toUpperCase() + normalized.slice(1);
              this.showToast?.(`Equip a ${friendlyName} first.`, '#ff6b6b');
            }
            return false;
          }

          const isActive =
            typeof manager.isSpawned === 'function'
              ? manager.isSpawned(equipped.uid)
              : false;

          if (forceRecall) {
            if (isActive) {
              manager.toggleCompanion(normalized);
            } else if (showToast) {
              this.showToast?.(`${equipped.name || normalized} already stowed.`, '#ffd77a');
            }
            setTimeout(() => {
              slotRenderMap[normalized]?.call(this);
              this.updateStats?.();
            }, 80);
            return true;
          }

          if (preferSpawn && isActive) {
            if (showToast) {
              this.showToast?.(`${equipped.name || normalized} already active.`, '#7af8c8');
            }
            return true;
          }

          manager.toggleCompanion(normalized);
          setTimeout(() => {
            slotRenderMap[normalized]?.call(this);
            this.updateStats?.();
          }, 80);
          return true;
        },

        loadEquippedCompanionUids() {
          if (typeof localStorage === 'undefined') return;
          let stored = {};
          try {
            stored = JSON.parse(localStorage.getItem(this.storageKeys.companionUids) || '{}') || {};
          } catch (_) {
            stored = {};
          }

          const slots = ['pet', 'spirit', 'vehicle'];
          let changed = false;

          slots.forEach((slot) => {
            const current = window.gameState.equipped?.[slot];
            if (!current) {
              if (stored[slot]) {
                changed = true;
                delete stored[slot];
              }
              return;
            }

            const savedEntry = stored[slot];
            if (savedEntry?.uid) {
              const matchesId = !savedEntry.id || savedEntry.id === current.id || savedEntry.id === current.name;
              if (matchesId) {
                current.uid = savedEntry.uid;
              }
            }

            const prepared = this.prepareEquippable(current, slot);
            window.gameState.equipped[slot] = prepared;
            this.state.equipped[slot] = prepared;

            const savedUid = stored[slot]?.uid;
            const savedId = stored[slot]?.id;
            if (prepared.uid && (savedUid !== prepared.uid || savedId !== (prepared.id || prepared.name))) {
              stored[slot] = { id: prepared.id || prepared.name || slot, uid: prepared.uid };
              changed = true;
            }
          });

          if (changed) {
            try {
              if (Object.keys(stored).length) {
                localStorage.setItem(this.storageKeys.companionUids, JSON.stringify(stored));
              } else {
                localStorage.removeItem(this.storageKeys.companionUids);
              }
            } catch (_) { /* no-op */ }
          }
        },

        persistCompanionUids() {
          if (typeof localStorage === 'undefined') return;
          const slots = ['pet', 'spirit', 'vehicle'];
          const payload = {};
          let hasData = false;

          slots.forEach((slot) => {
            const equipped = this.state.equipped?.[slot];
            if (equipped?.uid) {
              payload[slot] = { id: equipped.id || equipped.name || slot, uid: equipped.uid };
              hasData = true;
            }
          });

          try {
            if (hasData) {
              localStorage.setItem(this.storageKeys.companionUids, JSON.stringify(payload));
            } else {
              localStorage.removeItem(this.storageKeys.companionUids);
            }
          } catch (_) { /* swallow */ }
        },

        clearActiveCompanions(options = {}) {
          const engine = this.ensureEngine();
          const companionSystem = engine?.systems?.companion;
          if (companionSystem) {
            try { companionSystem.despawnAllByType('pet'); } catch (_) { }
            try { companionSystem.despawnAllByType('spirit'); } catch (_) { }
            try { companionSystem.despawnAllByType('vehicle'); } catch (_) { }
          }

          const slots = ['pet', 'spirit', 'vehicle'];
          let cleared = false;
          slots.forEach((slot) => {
            if (this.state.equipped?.[slot]) {
              this.state.equipped[slot] = null;
              if (window.gameState?.equipped) {
                window.gameState.equipped[slot] = null;
              }
              this.syncLegacyCompanionSlot(slot, null);
              this.syncCompanionManager(slot, null);
              cleared = true;
            }
          });

          if (cleared) {
            this.persistCompanionUids();
            this.renderPetsTab?.();
            this.renderVehiclesTab?.();
            this.renderSpiritTab?.();
            if (!options.silent) {
              this.showToast?.('ğŸš¨ All companions recalled.');
            }
          }
          return cleared;
        },

        ensureHudState() {
          const hudWrap = document.getElementById('hud-wrap');
          const leftCluster = document.getElementById('hud-left');
          const rightCluster = document.getElementById('hud-right');
          if (!hudWrap || !leftCluster || !rightCluster) return;

          if (!this.state.hudSettings) {
            const leftStyles = window.getComputedStyle(leftCluster);
            const rightStyles = window.getComputedStyle(rightCluster);
            this.state.hudSettings = {
              visible: hudWrap.style.display !== 'none',
              leftMargin: parseInt(leftStyles.marginLeft, 10) || 40,
              rightMargin: parseInt(rightStyles.marginRight, 10) || 147,
              bottomMargin: parseInt(rightStyles.marginBottom, 10) || 40,
              palette: HUD_COLOR_PRESETS[0].id
            };
          }
        },

        applyHudVisibility() {
          const hudWrap = document.getElementById('hud-wrap');
          if (!hudWrap || !this.state.hudSettings) return;
          hudWrap.style.display = this.state.hudSettings.visible ? 'grid' : 'none';
        },

        applyHudLayout() {
          if (!this.state.hudSettings) return;
          const leftCluster = document.getElementById('hud-left');
          const rightCluster = document.getElementById('hud-right');
          if (leftCluster) {
            leftCluster.style.marginLeft = `${this.state.hudSettings.leftMargin}px`;
            leftCluster.style.marginBottom = `${this.state.hudSettings.bottomMargin}px`;
          }
          if (rightCluster) {
            rightCluster.style.marginRight = `${this.state.hudSettings.rightMargin}px`;
            rightCluster.style.marginBottom = `${this.state.hudSettings.bottomMargin}px`;
          }
        },

        applyHudColors(presetId) {
          if (!this.state.hudSettings) return;
          const appliedId = applyColorPreset(presetId ?? this.state.hudSettings.palette);
          this.state.hudSettings.palette = appliedId;
        },

        applyHudSettings() {
          if (!this.state.hudSettings) return;
          this.applyHudVisibility();
          this.applyHudLayout();
          this.applyHudColors(this.state.hudSettings.palette);
        },

        initializeHud() {
          if (this.hudInitialized) return;
          const hudWrap = document.getElementById('hud-wrap');
          const joystickRoot = document.getElementById('vj-root');
          const joystickKnob = document.getElementById('vj-knob');
          if (!hudWrap || !joystickRoot || !joystickKnob) {
            debugWarn('[BagSystem] HUD elements missing; skipping HUD initialization.');
            return;
          }

          this.ensureHudState();

          const bagSystem = this;
          const HUD = window.HUD = window.HUD || {};

          const skillSelector = (id) => document.querySelector(`.skill-row [data-skill=\"${id}\"]`);

          const setSkillReady = (id, ready = true) => {
            const el = skillSelector(id);
            if (el) el.classList.toggle('ready', !!ready);
          };

          const setJoystickReady = (ready = true) => {
            joystickRoot.classList.toggle('ready', !!ready);
          };

          HUD.setSkillReady = setSkillReady;
          HUD.setJoystickReady = setJoystickReady;
          HUD.setAllReady = (ready = true) => {
            setSkillReady('S1', ready);
            setSkillReady('S2', ready);
            setSkillReady('S3', ready);
            setJoystickReady(ready);
          };

          this.hud = {
            setSkillReady,
            setJoystickReady,
            setAllReady: HUD.setAllReady
          };

          const radius = 59;
          let isActive = false;

          const getTouch = (e) => (e.touches ? e.touches[0] : e);

          const emitHudEvent = (name, detail) => {
            window.dispatchEvent(new CustomEvent(name, { detail }));
          };

          const handleJoystickStart = (e) => {
            if (e.type === 'mousedown' && e.button !== 0) return;
            isActive = true;
            if (e.type === 'touchstart') e.preventDefault();
            handleJoystickMove(e);
          };

          const handleJoystickMove = (e) => {
            if (!isActive) return;
            const touch = getTouch(e);
            const rect = joystickRoot.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;

            let dx = touch.clientX - centerX;
            let dy = touch.clientY - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);

            if (distance > radius) {
              const ratio = radius / distance;
              dx *= ratio;
              dy *= ratio;
            }

            joystickKnob.style.transform = `translate(${dx}px, ${dy}px)`;

            emitHudEvent('A1K_HUD:joystick_move', {
              x: dx / radius,
              y: dy / radius,
              distance: distance / radius
            });

            if (e.type === 'touchmove') e.preventDefault();
          };

          const handleJoystickEnd = () => {
            if (!isActive) return;
            isActive = false;
            joystickKnob.style.transform = 'translate(0, 0)';
            emitHudEvent('A1K_HUD:joystick_end', { x: 0, y: 0 });
          };

          joystickRoot.addEventListener('touchstart', handleJoystickStart, { passive: false });
          joystickRoot.addEventListener('touchmove', handleJoystickMove, { passive: false });
          joystickRoot.addEventListener('touchend', handleJoystickEnd);
          joystickRoot.addEventListener('touchcancel', handleJoystickEnd);
          joystickRoot.addEventListener('mousedown', handleJoystickStart);
          document.addEventListener('mousemove', handleJoystickMove);
          document.addEventListener('mouseup', handleJoystickEnd);

          hudWrap.querySelectorAll('[data-btn]').forEach((btn) => {
            const buttonId = btn.dataset.btn;
            btn.addEventListener('click', () => {
              emitHudEvent('A1K_HUD:button_click', { button: buttonId });
              if (buttonId === 'bag') {
                bagSystem.toggle();
              } else if (buttonId === 'veh') {
                if (window.vehicleManager) {
                  window.vehicleManager.toggleSpawn();
                }
              }
            });
            btn.addEventListener('mouseenter', () => emitHudEvent('A1K_HUD:button_hover', { button: buttonId }));
            btn.addEventListener('mouseleave', () => emitHudEvent('A1K_HUD:button_leave', { button: buttonId }));
          });

          // Demo ready sequences (retain original staggered glow)
          setTimeout(() => setSkillReady('S1', true), 800);
          setTimeout(() => setSkillReady('S2', true), 1600);
          setTimeout(() => setSkillReady('S3', true), 2400);
          setTimeout(() => setJoystickReady(true), 3200);

          this.applyHudSettings();
          this.hudInitialized = true;
        },

        renderControlsTab() {
          ensureUiInjected();
          this.ensureHudState();
          const settings = this.state.hudSettings;
          const pane = document.getElementById('bagContentPane');
          if (!pane || !settings) return;

          pane.innerHTML = `
            <div class="hud-controls">
              <section>
                <h3>Visibility</h3>
                <label class="hud-toggle">
                  <input type="checkbox" id="hudVisibilityToggle" ${settings.visible ? 'checked' : ''}>
                  Show On-Screen Controls
                </label>
              </section>
              <section>
                <h3>Position</h3>
                <div class="hud-control-row">
                  <label for="hudLeftMargin">Left Margin</label>
                  <input type="range" id="hudLeftMargin" min="0" max="240" value="${settings.leftMargin}" data-value-target="hudLeftMarginValue">
                  <span class="hud-control-value" id="hudLeftMarginValue">${settings.leftMargin}px</span>
                </div>
                <div class="hud-control-row">
                  <label for="hudRightMargin">Right Margin</label>
                  <input type="range" id="hudRightMargin" min="0" max="320" value="${settings.rightMargin}" data-value-target="hudRightMarginValue">
                  <span class="hud-control-value" id="hudRightMarginValue">${settings.rightMargin}px</span>
                </div>
                <div class="hud-control-row">
                  <label for="hudBottomMargin">Bottom Margin</label>
                  <input type="range" id="hudBottomMargin" min="0" max="200" value="${settings.bottomMargin}" data-value-target="hudBottomMarginValue">
                  <span class="hud-control-value" id="hudBottomMarginValue">${settings.bottomMargin}px</span>
                </div>
              </section>
              <section>
                <h3>Color Presets</h3>
                <div class="hud-color-grid">
                  ${HUD_COLOR_PRESETS.map(preset => `
                    <button class="hud-color-btn ${preset.id === settings.palette ? 'active' : ''}" data-hud-color="${preset.id}">
                      ${preset.label}
                    </button>
                  `).join('')}
                </div>
              </section>
            </div>
          `;

          const visibilityToggle = pane.querySelector('#hudVisibilityToggle');
          if (visibilityToggle) {
            visibilityToggle.addEventListener('change', (event) => {
              this.state.hudSettings.visible = !!event.target.checked;
              this.applyHudVisibility();
            });
          }

          const bindSlider = (selector, key) => {
            const input = pane.querySelector(selector);
            if (!input) return;
            input.addEventListener('input', (event) => {
              const value = Number(event.target.value);
              this.state.hudSettings[key] = value;
              const display = pane.querySelector(`#${event.target.dataset.valueTarget}`);
              if (display) {
                display.textContent = `${value}px`;
              }
              this.applyHudLayout();
            });
          };

          bindSlider('#hudLeftMargin', 'leftMargin');
          bindSlider('#hudRightMargin', 'rightMargin');
          bindSlider('#hudBottomMargin', 'bottomMargin');

          pane.querySelectorAll('[data-hud-color]').forEach((button) => {
            button.addEventListener('click', () => {
              this.applyHudColors(button.dataset.hudColor);
              this.renderControlsTab();
            });
          });
        },

        async init() {
          this.engine = window.A1K_Engine || this.engine || null;
          ensureUiInjected();
          this.initializeHud();
          this.ensureHudState();
          this.applyHudSettings();

          window.gameState = window.gameState || {};
          window.gameState.settings = window.gameState.settings || {};
          const persistedState = this.loadPersistedGameState();
          if (persistedState) {
            this.applyPersistedSnapshot(persistedState);
          }
          
          // Initialize Ability Points System (must be after gameState initialization)
          try {
            this.initializeAbilityPointsSystem();
          } catch (error) {
            debugError('[BagSystem] Failed to initialize Ability Points System:', error);
          }
          
          // Initialize skill usage analytics
          this.initSkillUsageAnalytics();
          
          // Expose equippedSkills on window for quick debugging in console
          // Dual-structure: { A1: {S1-S7, X1-X2}, MISSY: {...}, UNIQUE: {...}, slot1-3: quick slots }
          window.equippedSkills = window.gameState.equippedSkills;
          
          const hydratedCharacter = this.ensureCurrentCharacter();
          this.syncQuickSlotsToCharacter(hydratedCharacter);
          if (!window.gameState.equipped) {
            window.gameState.equipped = { head: null, chest: null, gloves: null, pants: null, boots: null, weapon: null, offhand: null, ring1: null, ring2: null, necklace: null, vehicle: null, pet: null, spirit: null, robot: null };
          }
          if (window.gameState.inventory?.gear) {
            window.gameState.inventory.gear = this.normalizeGearCollection(window.gameState.inventory.gear);
          }
          Object.entries(window.gameState.equipped).forEach(([slot, item]) => {
            if (item) {
              window.gameState.equipped[slot] = this.normalizeGearItem(item);
            }
          });
          this.state.equipped = window.gameState.equipped;
          this.loadCompanionLoadouts();
          this.loadEquippedCompanionUids();

          this.syncLegacyCompanionSlot('pet', this.state.equipped.pet);
          this.syncLegacyCompanionSlot('vehicle', this.state.equipped.vehicle);
          this.syncLegacyCompanionSlot('spirit', this.state.equipped.spirit);
          this.syncLegacyCompanionSlot('robot', this.state.equipped.robot);
          this.syncCompanionManager('pet', this.state.equipped.pet);
          this.syncCompanionManager('vehicle', this.state.equipped.vehicle);
          this.syncCompanionManager('spirit', this.state.equipped.spirit);

          this.renderTabs();
          this.renderCurrencies();
          this.attachEventListeners();
          this.renderTab('items');
          this.updateStats();
          this.renderDiagnosticsPanel();
          this.updateAutoAIButton();
          if (window.gameState.settings.autoAI) {
            this.startAutoAILoop();
          }
          this.validateCompanionAssets();
          debugLog('[BagSystem] Initialized');
        },

        open() {
          document.getElementById('bagWindow').classList.add('open');
          this.isOpen = true;
          window.gameState.bagOpen = true;
          this.renderTab(this.state.activeTab);
          this.updateStats();
          this.renderDiagnosticsPanel();
        },

        close() {
          document.getElementById('bagWindow').classList.remove('open');
          this.isOpen = false;
          window.gameState.bagOpen = false;
        },

        toggle() {
          this.isOpen ? this.close() : this.open();
        },

        renderTabs() {
          const tabsStrip = document.getElementById('bagTabsStrip');
          const enabledTabs = TAB_DEFINITIONS.filter(t => t.enabled).sort((a, b) => a.order - b.order);

          tabsStrip.innerHTML = enabledTabs.map(tab => `
            <button class="bag-tab ${tab.id === this.state.activeTab ? 'active' : ''}" 
                    data-tab="${tab.id}">
              <span class="tab-icon">${tab.icon}</span>
              <span class="tab-label">${tab.label}</span>
            </button>
          `).join('');

          tabsStrip.querySelectorAll('.bag-tab').forEach(btn => {
            btn.addEventListener('click', () => {
              const tabId = btn.dataset.tab;
              this.state.activeTab = tabId;
              this.renderTabs();
              this.renderTab(tabId);
            });
          });
        },

        renderCurrencies() {
          const strip = document.getElementById('currenciesStrip');
          const currencies = [
            { icon: 'ğŸ’°', label: 'Gold', value: window.gameState.gold },
            { icon: 'ğŸ’', label: 'Gems', value: window.gameState.gems },
            { icon: 'ğŸ”‘', label: 'Keys', value: window.gameState.keys },
            { icon: 'ğŸŸï¸', label: 'Tickets', value: window.gameState.tickets }
          ];

          strip.innerHTML = currencies.map(c => `
            <div class="currency-item">
              <div class="currency-icon">${c.icon}</div>
              <div class="currency-details">
                <div class="currency-label">${c.label}</div>
                <div class="currency-value">${c.value.toLocaleString()}</div>
              </div>
            </div>
          `).join('');
        },

        renderDiagnosticsPanel() {
          const container = document.getElementById('bagDiagnosticsContent');
          if (!container) return;
          const diagnostics = window.BagDiagnostics?.getState?.()?.missingAssets ?? [];
          const escape = (value) =>
            String(value)
              .replace(/&/g, '&amp;')
              .replace(/</g, '&lt;')
              .replace(/>/g, '&gt;')
              .replace(/"/g, '&quot;')
              .replace(/'/g, '&#39;');

          if (diagnostics.length === 0) {
            container.innerHTML = '<div class="bag-diagnostics__empty">All systems nominal.</div>';
            return;
          }

          const sorted = diagnostics
            .slice()
            .sort((a, b) => {
              if (b.count !== a.count) return b.count - a.count;
              return a.path.localeCompare(b.path);
            });

          container.innerHTML = sorted
            .map((entry) => {
              const sources =
                Array.isArray(entry.sources) && entry.sources.length > 0
                  ? `<span class="bag-diagnostics__sources">${escape(entry.sources.join(', '))}</span>`
                  : '';
              return `
                <div class="bag-diagnostics__item">
                  <span class="bag-diagnostics__path">${escape(entry.path)}</span>
                  <span class="bag-diagnostics__count">Ã—${entry.count}</span>
                  ${sources}
                </div>
              `;
            })
            .join('');
        },

        renderTab(tabId) {
          const tab = TAB_DEFINITIONS.find(t => t.id === tabId);
          if (!tab || !this[tab.renderer]) return;

          // Check requirements for specific tabs
          const requirementMap = {
            'pets': 'pets',
            'vehicles': 'vehicles',
            'spirits': 'spirits',
            'spirit': 'spirits'
          };

          const reqKey = requirementMap[tabId];
          if (reqKey) {
            const reqCheck = this.checkRequirements(reqKey);
            if (!reqCheck.met) {
              // Show requirement error instead of rendering tab
              const pane = document.getElementById('bagContentPane');
              if (pane) {
                pane.innerHTML = `
                  <div style="padding: 40px; text-align: center; background: linear-gradient(135deg, rgba(255, 107, 53, 0.2), rgba(255, 82, 82, 0.2)); border-radius: 16px; border: 3px solid rgba(255, 107, 53, 0.6);">
                    <div style="font-size: 48px; margin-bottom: 20px;">ğŸ”’</div>
                    <h2 style="color: #ff6b35; font-size: 24px; margin-bottom: 16px; font-weight: 700;">${this.REQUIREMENTS[reqKey].name} Locked</h2>
                    <div style="color: rgba(207, 227, 255, 0.9); font-size: 14px; line-height: 1.8; background: rgba(0, 0, 0, 0.4); padding: 20px; border-radius: 12px; border: 1px solid rgba(255, 107, 53, 0.3);">
                      <div style="font-weight: 700; color: #ffd700; margin-bottom: 12px;">Requirements:</div>
                      ${reqCheck.message.split('\n').slice(1).map(line => `<div style="margin: 8px 0;">${line}</div>`).join('')}
                      <div style="margin-top: 20px; padding-top: 16px; border-top: 1px solid rgba(255, 107, 53, 0.3); color: rgba(207, 227, 255, 0.7); font-size: 12px;">
                        ğŸ’¡ Complete these requirements to unlock ${this.REQUIREMENTS[reqKey].name}!
                      </div>
                    </div>
                  </div>
                `;
              }
              this.showToast(`ğŸ”’ ${this.REQUIREMENTS[reqKey].name} locked - check requirements!`);
              return;
            }
          }

          // Requirements met, render the tab
          this[tab.renderer]();
        this.applyCandyDecor(document.getElementById('bagContentPane'));
        },

      applyCandyDecor(rootElement) {
        const target = rootElement instanceof HTMLElement
          ? rootElement
          : (typeof rootElement === 'string'
            ? document.querySelector(rootElement)
            : document.getElementById('bagContentPane'));

        if (!target) {
          return;
        }

        target.classList.add('candy-pane');

        const ensureTransition = (el, transitions) => {
          const existing = el.style.transition || '';
          const list = Array.isArray(transitions) ? transitions : [transitions];
          const missing = list.filter(token => !existing.includes(token));
          if (missing.length === 0) return existing;
          return existing
            ? `${existing}, ${missing.join(', ')}`
            : missing.join(', ');
        };

        target.querySelectorAll('.filter-chip').forEach(chip => {
          chip.style.borderRadius = chip.style.borderRadius || '999px';
          chip.style.transition = ensureTransition(chip, ['transform 0.2s ease', 'box-shadow 0.22s ease']);
          chip.dataset.candySfx = chip.dataset.candySfx || 'ui-click';
          if (!chip.dataset.candyClickBound) {
            chip.dataset.candyClickBound = '1';
            chip.addEventListener('click', () => {
              if (chip.disabled || chip.getAttribute('disabled') !== null) return;
              if (typeof this.playCandySfx === 'function') {
                this.playCandySfx(chip.dataset.candySfx || 'ui-click');
              }
            });
          }
        });

        target.querySelectorAll('[class*="card"]').forEach(card => {
          card.style.borderRadius = card.style.borderRadius || '18px';
          card.style.backdropFilter = card.style.backdropFilter || 'blur(12px)';
          card.style.boxShadow = card.style.boxShadow || '0 18px 36px rgba(10, 16, 35, 0.35)';
          card.style.border = card.style.border || '1px solid rgba(255, 255, 255, 0.18)';
          card.style.transition = ensureTransition(card, ['transform 0.2s ease', 'box-shadow 0.22s ease']);
          card.dataset.candyBaseShadow = card.style.boxShadow || card.dataset.candyBaseShadow || '';
          card.dataset.candyBaseTransform = card.style.transform || card.dataset.candyBaseTransform || '';
          if (!card.dataset.candyCardHover) {
            card.dataset.candyCardHover = '1';
            card.addEventListener('mouseenter', () => {
              card.style.transform = 'translateY(-2px) scale(1.012)';
              card.style.boxShadow = '0 26px 52px rgba(10, 16, 35, 0.48)';
            });
            card.addEventListener('mouseleave', () => {
              card.style.transform = card.dataset.candyBaseTransform || '';
              card.style.boxShadow = card.dataset.candyBaseShadow || '';
            });
          }
        });

        const buttonSelector = '.item-action-btn, .gear-action-btn, .pet-action-btn, .vehicle-action-btn, .robot-action-btn, .spirit-action-btn, .skin-action-btn, .buy-btn, .shop-filter-btn, .mission-action-btn, .quest-action-btn, .loadout-card button, button[data-team-action], .candy-button';
        target.querySelectorAll(buttonSelector).forEach(btn => {
          btn.classList.add('candy-button');
          btn.style.borderRadius = btn.style.borderRadius || '999px';
          btn.style.transition = ensureTransition(btn, ['transform 0.2s ease', 'box-shadow 0.22s ease', 'filter 0.22s ease']);
          btn.dataset.candyBaseShadow = btn.style.boxShadow || btn.dataset.candyBaseShadow || '';
          btn.dataset.candyBaseTransform = btn.style.transform || btn.dataset.candyBaseTransform || '';
          if (!btn.dataset.candySfx) {
            if (btn.dataset.action === 'equip' || btn.dataset.teamAction === 'open-tab') {
              btn.dataset.candySfx = 'equip';
            } else if (btn.dataset.action === 'upgrade') {
              btn.dataset.candySfx = 'upgrade';
            } else if (btn.dataset.action === 'bulk-open') {
              btn.dataset.candySfx = 'quest-progress';
            } else {
              btn.dataset.candySfx = 'ui-click';
            }
          }
          if (!btn.dataset.candyButtonHover) {
            btn.dataset.candyButtonHover = '1';
            btn.addEventListener('mouseenter', () => {
              if (btn.disabled || btn.getAttribute('disabled') !== null) return;
              btn.style.transform = 'translateY(-1px) scale(1.02)';
              btn.style.boxShadow = '0 18px 36px rgba(10, 16, 35, 0.45)';
            });
            btn.addEventListener('mouseleave', () => {
              btn.style.transform = btn.dataset.candyBaseTransform || '';
              btn.style.boxShadow = btn.dataset.candyBaseShadow || '';
            });
          }
          if (!btn.dataset.candyClickBound) {
            btn.dataset.candyClickBound = '1';
            btn.addEventListener('click', () => {
              if (btn.disabled || btn.getAttribute('disabled') !== null) return;
              if (typeof this.playCandySfx === 'function') {
                this.playCandySfx(btn.dataset.candySfx || 'ui-click');
              }
            });
          }
        });

        target.querySelectorAll('.items-grid').forEach(grid => {
          grid.style.gap = grid.style.gap || '10px';
        });

        target.querySelectorAll('.filter-sort-controls').forEach(group => {
          group.style.background = group.style.background || 'rgba(12, 20, 34, 0.38)';
          group.style.borderRadius = group.style.borderRadius || '14px';
          group.style.padding = group.style.padding || '10px 12px';
          group.style.boxShadow = group.style.boxShadow || '0 14px 28px rgba(10, 16, 35, 0.32)';
          group.style.backdropFilter = group.style.backdropFilter || 'blur(10px)';
        });

        target.querySelectorAll('table').forEach(table => {
          table.style.borderCollapse = table.style.borderCollapse || 'separate';
          table.style.borderSpacing = table.style.borderSpacing || '0 8px';
        });
      },

        renderItemsTab() {
          const pane = document.getElementById('bagContentPane');
          const subtab = this.state.itemsSubtab || 'inventory';

          pane.innerHTML = `
            <!-- Subtab Navigation -->
            <div style="display: flex; gap: 8px; margin-bottom: 16px; border-bottom: 2px solid rgba(79, 195, 247, 0.3); padding-bottom: 8px;">
              <button class="filter-chip ${subtab === 'inventory' ? 'active' : ''}" data-subtab="inventory">ğŸ“¦ Inventory</button>
              <button class="filter-chip ${subtab === 'alchemy' ? 'active' : ''}" data-subtab="alchemy">âš—ï¸ Alchemy</button>
            </div>
            
            <div id="subtab-content"></div>
          `;

          // Attach subtab listeners
          pane.querySelectorAll('.filter-chip[data-subtab]').forEach(btn => {
            btn.addEventListener('click', () => {
              this.state.itemsSubtab = btn.dataset.subtab;
              this.renderItemsTab();
            });
          });

          // Render the active subtab
          if (subtab === 'inventory') {
            this.renderItemsInventorySubtab();
          } else if (subtab === 'alchemy') {
            this.renderAlchemyWorkspace();
          }

          this.applyCandyDecor(pane);
        },

        renderItemsInventorySubtab() {
          const container = document.getElementById('subtab-content');
          const items = window.gameState.inventory.items || [];

          if (items.length === 0) {
            container.innerHTML = `
              <div class="tab-empty">
                <div class="empty-icon">ğŸ“¦</div>
                <p>No items in inventory</p>
                <p class="empty-hint">Items will appear here</p>
              </div>
            `;
            return;
          }

          container.innerHTML = `
            <div class="items-grid">
              ${items.map(item => {
            const isContainer = item.category === 'container';
            const isConsumable = item.category === 'consumable';

            return `
                <div class="item-card">
                  <div class="item-quantity">${item.quantity}</div>
                  <div class="item-icon">${item.icon}</div>
                  <div class="item-name">${item.name}</div>
                  <div class="item-category">${item.category}</div>
                    <div class="item-actions">
                      ${isContainer ? `
                        <button class="item-action-btn" data-action="open" data-item-id="${item.id}">Open</button>
                        ${item.quantity >= 10 ? `<button class="item-action-btn bulk" data-action="bulk-open" data-item-id="${item.id}">Bulk x10</button>` : ''}
                      ` : isConsumable ? `
                        <button class="item-action-btn" data-action="use" data-item-id="${item.id}">Use</button>
                        ${item.quantity >= 5 ? `<button class="item-action-btn bulk" data-action="use-multiple" data-item-id="${item.id}">Use x5</button>` : ''}
                      ` : `
                        <button class="item-action-btn" data-action="use" data-item-id="${item.id}">Use</button>
                      `}
                    </div>
                  </div>
                `;
          }).join('')}
            </div>
          `;

          // Attach action button listeners
          container.querySelectorAll('.item-action-btn').forEach(btn => {
            btn.addEventListener('click', () => {
              const action = btn.dataset.action;
              const itemId = btn.dataset.itemId;

              if (action === 'open') this.openContainer(itemId);
              else if (action === 'bulk-open') this.bulkOpenContainer(itemId, 10);
              else if (action === 'use') this.useItem(itemId);
              else if (action === 'use-multiple') this.useMultiple(itemId, 5);
            });
          });

          this.applyCandyDecor(container);
        },

        renderAlchemyWorkspace() {
          const container = document.getElementById('subtab-content');
          if (!container) return; // Exit if container doesn't exist (not in Items tab)
          
          const allItems = [...(window.gameState.inventory.items || []), ...(window.gameState.inventory.gear || [])];

          container.innerHTML = `
            <!-- Alchemy Workspace -->
            <div style="background: rgba(0, 0, 0, 0.3); border: 2px solid rgba(167, 139, 250, 0.4); border-radius: 12px; padding: 16px; margin-bottom: 16px;">
              <h3 style="color: #a78bfa; font-size: 14px; margin-bottom: 12px;">âš—ï¸ Fusion Workspace</h3>
              
              <div style="display: flex; align-items: center; gap: 12px; justify-content: center; margin-bottom: 16px;">
                ${[0, 1, 2].map(slotIndex => {
            const slotItem = this.state.alchemySlots[slotIndex];
            return `
                    <div class="alchemy-slot" data-slot="${slotIndex}" style="width: 80px; height: 90px; background: rgba(0, 0, 0, 0.4); border: 2px dashed rgba(255, 255, 255, 0.3); border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s ease;">
                      ${slotItem ? `
                        <div style="font-size: 24px;">${slotItem.icon}</div>
                        <div style="font-size: 6px; color: #cfe3ff; margin-top: 4px;">${slotItem.name}</div>
                      ` : `
                        <div style="font-size: 20px; opacity: 0.3;">â“</div>
                        <div style="font-size: 6px; color: rgba(207, 227, 255, 0.3);">Slot ${slotIndex + 1}</div>
                      `}
                    </div>
                  `;
          }).join('')}
                
                <div style="font-size: 24px; color: #ffd77a;">â†’</div>
                
                <div class="alchemy-result" style="width: 90px; height: 100px; background: linear-gradient(135deg, rgba(255, 215, 122, 0.1), rgba(255, 107, 53, 0.1)), rgba(0, 0, 0, 0.4); border: 2px solid rgba(255, 215, 122, 0.5); border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center;">
                  ${this.state.alchemyResult ? `
                    <div style="font-size: 28px;">${this.state.alchemyResult.icon}</div>
                    <div style="font-size: 7px; color: #ffd77a; margin-top: 4px; font-weight: 700;">${this.state.alchemyResult.name}</div>
                  ` : `
                    <div style="font-size: 24px; opacity: 0.3;">âœ¨</div>
                    <div style="font-size: 6px; color: rgba(207, 227, 255, 0.3);">Result</div>
                  `}
                </div>
              </div>

              <div style="display: flex; gap: 8px; justify-content: center;">
                <button class="gear-action-btn" onclick="window.BagSystem.performCraft()" ${!this.state.alchemyResult ? 'disabled' : ''} style="background: linear-gradient(135deg, #38ef7d, #4fc3f7); padding: 6px 16px; font-size: 8px;">
                  âœ¨ Craft Now
                </button>
                <button class="gear-action-btn" onclick="window.BagSystem.clearAlchemySlots()" style="background: linear-gradient(135deg, #ff6b35, #ff3b3b); padding: 6px 16px; font-size: 8px;">
                  Clear
                </button>
              </div>
            </div>

            <!-- Available Items -->
            <h4 style="color: #4fc3f7; font-size: 12px; margin-bottom: 10px;">ğŸ“¦ Your Items (Click to Add to Slot)</h4>
            <div class="items-grid">
              ${allItems.map(item => {
                const availableQty = this.getItemQuantity(item.id);
                const slotsUsed = this.state.alchemySlots.filter(slot => slot && slot.id === item.id).length;
                const isMaxedOut = slotsUsed >= availableQty;
                
                return `
                <div class="item-card draggable-alchemy-item" data-item-id="${item.id}" style="cursor: ${isMaxedOut ? 'not-allowed' : 'pointer'}; opacity: ${isMaxedOut ? '0.5' : '1'};">
                  ${availableQty > 1 ? `<div class="item-quantity">${availableQty - slotsUsed}/${availableQty}</div>` : ''}
                  ${slotsUsed > 0 ? `<div style="position: absolute; top: 2px; right: 2px; background: rgba(56, 239, 125, 0.8); color: #000; border-radius: 50%; width: 14px; height: 14px; font-size: 8px; display: flex; align-items: center; justify-content: center; font-weight: 700;">âœ“</div>` : ''}
                  <div class="item-icon" style="font-size: 20px;">${item.icon}</div>
                  <div class="item-name" style="font-size: 6px;">${item.name}</div>
                  ${item.rarity ? `<div style="font-size: 5px; color: rgba(207, 227, 255, 0.5);">${item.rarity}</div>` : ''}
                  ${isMaxedOut ? `<div style="font-size: 5px; color: #ff6b35; font-weight: 700;">All Used</div>` : ''}
                </div>
              `}).join('')}
            </div>
          `;

          // Attach click handlers for adding items to slots
          // Attach item click handlers (with debounce to prevent stuck state)
          let clickTimeout = null;
          container.querySelectorAll('.draggable-alchemy-item').forEach(itemEl => {
            itemEl.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();
              
              // Prevent rapid double-clicks
              if (clickTimeout) return;
              clickTimeout = setTimeout(() => {
                clickTimeout = null;
              }, 200);
              
              const itemId = itemEl.dataset.itemId;
              const item = allItems.find(i => i.id === itemId);
              if (item) {
                // Visual feedback - flash the item
                itemEl.style.opacity = '0.5';
                itemEl.style.transform = 'scale(0.95)';
                setTimeout(() => {
                  if (itemEl) {
                    itemEl.style.opacity = '1';
                    itemEl.style.transform = 'scale(1)';
                  }
                }, 300);
                
                this.addToAlchemySlot(item);
              }
            });
          });
          container.querySelectorAll('.draggable-alchemy-item').forEach(itemEl => {
            itemEl.addEventListener('dblclick', (e) => {
              e.preventDefault();
              e.stopPropagation();
              const itemId = itemEl.dataset.itemId;
              const item = allItems.find(i => i.id === itemId);
              if (item) this.addToAlchemySlot(item);
            });
          });

        this.applyCandyDecor(container);

          // Attach slot click handlers for removing items (with visual feedback)
          container.querySelectorAll('.alchemy-slot').forEach(slotEl => {
            slotEl.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();
              
              const slotIndex = parseInt(slotEl.dataset.slot);
              if (this.state.alchemySlots[slotIndex]) {
                // Visual feedback - shake the slot
                slotEl.style.transform = 'scale(0.9)';
                setTimeout(() => {
                  if (slotEl) slotEl.style.transform = 'scale(1)';
                }, 200);
                
              this.removeFromAlchemySlot(slotIndex);
              }
            });
          });
          
          // === STEP 1: Add Drag-and-Drop to renderAlchemyWorkspace ===
          // Make items draggable
          container.querySelectorAll('.draggable-alchemy-item').forEach(itemEl => {
            itemEl.draggable = true;
            itemEl.style.cursor = 'grab';
            
            itemEl.addEventListener('dragstart', (e) => {
              const itemId = itemEl.dataset.itemId;
              e.dataTransfer.effectAllowed = 'move';
              e.dataTransfer.setData('text/plain', itemId);
              itemEl.style.opacity = '0.5';
              itemEl.style.cursor = 'grabbing';
            });
            
            itemEl.addEventListener('dragend', (e) => {
              itemEl.style.opacity = '1';
              itemEl.style.cursor = 'grab';
            });
          });
          
          // Make alchemy slots accept drops
          container.querySelectorAll('.alchemy-slot').forEach(slotEl => {
            slotEl.addEventListener('dragover', (e) => {
              e.preventDefault();
              e.dataTransfer.dropEffect = 'move';
              slotEl.style.borderColor = 'rgba(56, 239, 125, 0.8)';
              slotEl.style.borderStyle = 'solid';
              slotEl.style.transform = 'scale(1.05)';
              slotEl.style.boxShadow = '0 0 20px rgba(56, 239, 125, 0.5)';
            });
            
            slotEl.addEventListener('dragleave', (e) => {
              slotEl.style.borderColor = 'rgba(255, 255, 255, 0.3)';
              slotEl.style.borderStyle = 'dashed';
              slotEl.style.transform = 'scale(1)';
              slotEl.style.boxShadow = 'none';
            });
            
            slotEl.addEventListener('drop', (e) => {
              e.preventDefault();
              const itemId = e.dataTransfer.getData('text/plain');
              const item = allItems.find(i => i.id === itemId);
              
              if (item) {
                const slotIndex = parseInt(slotEl.dataset.slot);
                
                // Check quantity validation
                const slotsUsed = this.state.alchemySlots.filter(slot => slot && slot.id === item.id).length;
                const availableQuantity = this.getItemQuantity(item.id);
                
                // If this slot already has this item, allow it (replacing)
                const currentSlotHasSameItem = this.state.alchemySlots[slotIndex] && this.state.alchemySlots[slotIndex].id === item.id;
                
                if (!currentSlotHasSameItem && slotsUsed >= availableQuantity) {
                  this.showToast(`âš ï¸ You only have ${availableQuantity} of this item! Already used in ${slotsUsed} slot(s).`);
                  slotEl.style.borderColor = 'rgba(255, 107, 53, 0.8)';
                  setTimeout(() => {
                    slotEl.style.borderColor = 'rgba(255, 255, 255, 0.3)';
                    slotEl.style.borderStyle = 'dashed';
                    slotEl.style.transform = 'scale(1)';
                    slotEl.style.boxShadow = 'none';
                  }, 300);
                  return;
                }
                
                // Replace item in slot
                this.state.alchemySlots[slotIndex] = item;
                this.calculateAlchemyResult();
                this.renderAlchemyWorkspace();
                this.showToast(`Added ${item.icon} ${item.name} to slot ${slotIndex + 1}`);
              }
              
              // Reset visual
              slotEl.style.borderColor = 'rgba(255, 255, 255, 0.3)';
              slotEl.style.borderStyle = 'dashed';
              slotEl.style.transform = 'scale(1)';
              slotEl.style.boxShadow = 'none';
            });
          });
        },

        renderGearTab() {
          const pane = document.getElementById('bagContentPane');
          const equipped = window.gameState.equipped || {};
          let gear = window.gameState.inventory.gear || [];
          gear = this.normalizeGearCollection(gear);

          // Handle cores filter separately
          let displayItems = [];
          if (this.state.gearFilter === 'cores') {
            // Show all cores from CORES_DATABASE
            displayItems = Object.values(window.CORES_DATABASE);
          } else {
            // Apply normal gear filter
            displayItems = gear;
          if (this.state.gearFilter !== 'all') {
              displayItems = displayItems.filter(g => g.category === this.state.gearFilter);
            }
          }

          // Apply sort
          if (this.state.gearSort === 'power') {
            displayItems.sort((a, b) => ((b.attack || 0) + (b.defense || 0) + (b.hp || 0)) -
              ((a.attack || 0) + (a.defense || 0) + (a.hp || 0)));
          }
          
          // Use displayItems instead of gear for rendering
          gear = displayItems;
          const gearCountMap = gear.reduce((acc, item) => {
            if (!item) return acc;
            const key = item.templateId || item.baseId || item.id || item.name;
            if (!key) return acc;
            acc[key] = (acc[key] || 0) + 1;
            return acc;
          }, {});

          const renderSlot = (slot) => {
            const item = equipped[slot.id];
            const isEmpty = !item;
            const slotStyle = isEmpty 
              ? 'style="animation: pulse 2s infinite; border-color: rgba(255, 255, 255, 0.2);"'
              : 'style="animation: slot-glow 2s infinite; border-color: rgba(56, 239, 125, 0.8); box-shadow: 0 0 20px rgba(56, 239, 125, 0.6);"';
            
            // Get core for this slot
            const equippedCore = window.getCoreForSlot ? window.getCoreForSlot(slot.id) : null;
            const coreConfig = CORE_SLOTS_CONFIG[slot.id];
            const hasCoreSlot = coreConfig !== undefined;
            
            return `
              <div class="equipment-slot-wrapper" style="position: relative; margin-bottom: 1px;">
                <div class="equipment-slot-v2 ${item ? 'has-item' : ''}" data-slot="${slot.id}" ${slotStyle} title="${item ? 'âœ¨ ' + item.name + ' (Equipped)&#10;Double-click to unequip' : 'ğŸ”˜ ' + slot.label + ' Slot&#10;Click item to equip'}">
                <div class="slot-label">${slot.label}</div>
                ${item ? `
                  <div class="equipped-item">
                    <div class="equipped-icon">${item.icon || 'âš”ï¸'}</div>
                    <div class="equipped-name">${item.name}</div>
                  </div>
                ` : `<div class="slot-empty" style="opacity: 0.5;">Empty</div>`}
                </div>
                
                ${hasCoreSlot ? `
                  <div class="core-slot" 
                       data-equipment-slot="${slot.id}" 
                       data-core-type="${coreConfig.coreType}"
                       onclick="window.BagSystem.showCoreEquipMenu('${slot.id}')"
                       style="
                         margin-top: 1px;
                         padding: 1px 3px;
                         background: ${equippedCore ? 'linear-gradient(135deg, rgba(100, 150, 255, 0.2), rgba(80, 120, 200, 0.2))' : 'linear-gradient(135deg, rgba(50, 70, 100, 0.3), rgba(40, 60, 90, 0.3))'};
                         border: 1px solid ${equippedCore ? 'rgba(150, 200, 255, 0.5)' : 'rgba(100, 150, 255, 0.2)'};
                         border-radius: 4px;
                         font-size: 6px;
                         text-align: center;
                         cursor: pointer;
                         transition: all 0.3s ease;
                         box-shadow: ${equippedCore ? '0 0 12px rgba(100, 150, 255, 0.4), 0 2px 6px rgba(0, 0, 0, 0.4)' : '0 1px 4px rgba(0, 0, 0, 0.3)'};
                         height: 16px;
                         display: flex;
                         align-items: center;
                         justify-content: center;
                         overflow: hidden;
                       "
                       title="${equippedCore ? equippedCore.name + ' (' + equippedCore.element + ')' : 'Click to equip ' + coreConfig.label}">
                    ${equippedCore ? `
                      <div style="display: flex; align-items: center; justify-content: center; gap: 4px;">
                        <span style="font-size: 16px;">${equippedCore.icon}</span>
                        <div style="flex: 1; text-align: left; line-height: 1.2;">
                          <div style="font-weight: bold; color: #9a6bff;">${equippedCore.name}</div>
                          <div style="font-size: 9px; color: rgba(255, 255, 255, 0.6);">${equippedCore.element || 'neutral'}</div>
                        </div>
                        <button onclick="event.stopPropagation(); window.unequipCore('${slot.id}'); window.BagSystem.renderGearTab();" 
                                style="padding: 2px 6px; background: rgba(255, 0, 0, 0.3); border: 1px solid #ff6b6b; border-radius: 4px; color: white; font-size: 10px; cursor: pointer;">âœ•</button>
                      </div>
                    ` : `
                      <div style="opacity: 0.5;">
                        <div>ğŸ’  Core Slot</div>
                        <div style="font-size: 8px; color: rgba(255, 255, 255, 0.5);">${coreConfig.coreType}</div>
                      </div>
                    `}
                  </div>
                ` : ''}
              </div>
            `;
          };

          pane.innerHTML = `
            <div class="paper-doll-v2">
              <!-- Left: Armor Slots -->
              <div class="armor-slots">
                <div class="slot-group-label">ğŸ›¡ ARMOR</div>
                ${EQUIPMENT_SLOTS_LEFT.map(renderSlot).join('')}
              </div>
              
              <!-- Center Top: Character Display -->
              <div class="character-panel">
                <div class="character-display">
                  <canvas id="gearCharacterCanvas" width="240" height="260" style="image-rendering: pixelated; image-rendering: -webkit-optimize-contrast;"></canvas>
                </div>
                </div>
                
              <!-- Center Bottom: Stats -->
              <div class="stats-panel">
                ${(() => {
                  const stats = this.computePlayerStats();
                  window.gameState.currentStats = stats;
                  const speedDisplay = (stats.speed || 0).toFixed(2);
                  const critDisplay = ((stats.critRate || stats.critChance || 0) * 100).toFixed(1);
                  return `
                  <div class="stat-compact">
                    <span class="stat-label">ATK</span>
                    <span class="stat-val">${stats.attack}</span>
                  </div>
                  <div class="stat-compact">
                    <span class="stat-label">DEF</span>
                    <span class="stat-val">${stats.defense}</span>
                  </div>
                  <div class="stat-compact">
                    <span class="stat-label">HP</span>
                    <span class="stat-val">${stats.hp}</span>
                  </div>
                  <div class="stat-compact">
                    <span class="stat-label">SPD</span>
                    <span class="stat-val">${speedDisplay}</span>
                  </div>
                  <div class="stat-compact">
                    <span class="stat-label">CRIT%</span>
                    <span class="stat-val">${critDisplay}</span>
                  </div>
                  `;
                })()}
              </div>
              
              <!-- Right: Weapons & Accessories -->
              <div class="weapons-accessories-slots">
                <div class="slot-group-label">âš” EQUIPMENT</div>
                ${EQUIPMENT_SLOTS_RIGHT.map(renderSlot).join('')}
              </div>
            </div>

            <div class="gear-inventory-section">
              <div class="inventory-header">
                <h3>Gear Inventory (${gear.length})</h3>
                <div class="filter-sort-controls">
                  <div class="filter-chips">
                    <button class="filter-chip ${this.state.gearFilter === 'all' ? 'active' : ''}" data-filter="all">All</button>
                    <button class="filter-chip ${this.state.gearFilter === 'weapon' ? 'active' : ''}" data-filter="weapon">Weapons</button>
                    <button class="filter-chip ${this.state.gearFilter === 'armor' ? 'active' : ''}" data-filter="armor">Armor</button>
                    <button class="filter-chip ${this.state.gearFilter === 'accessory' ? 'active' : ''}" data-filter="accessory">Accessories</button>
                    <button class="filter-chip ${this.state.gearFilter === 'cores' ? 'active' : ''}" data-filter="cores" style="background: ${this.state.gearFilter === 'cores' ? 'linear-gradient(135deg, #9a6bff, #8a2be2)' : 'rgba(0, 0, 0, 0.3)'}; border-color: ${this.state.gearFilter === 'cores' ? '#9a6bff' : 'rgba(255, 255, 255, 0.2)'};">ğŸ’  Cores</button>
                  </div>
                  <select class="sort-dropdown" id="gearSort">
                    <option value="power" ${this.state.gearSort === 'power' ? 'selected' : ''}>Sort: Power</option>
                    <option value="name" ${this.state.gearSort === 'name' ? 'selected' : ''}>Sort: Name</option>
                    <option value="rarity" ${this.state.gearSort === 'rarity' ? 'selected' : ''}>Sort: Rarity</option>
                  </select>
                </div>
              </div>
              
              ${gear.length === 0 ? `
                <div class="tab-empty">
                  <div class="empty-icon">âš”ï¸</div>
                  <p>No gear matches filter</p>
                </div>
              ` : `
                <div style="margin-bottom: 12px; display: flex; justify-content: space-between; align-items: center;">
                  <div style="font-size: 11px; color: rgba(207, 227, 255, 0.7);">
                    ğŸ’¡ Click item to equip | Right-click for options
                  </div>
                  <button id="unequipAllBtn" class="gear-action-btn" style="padding: 6px 14px; background: linear-gradient(135deg, #ff6b35, #ff3b3b); border: 2px solid white;">
                    ğŸ—‘ï¸ Unequip All
                  </button>
                </div>
                <div class="gear-items-grid">
                  ${gear.map(item => {
                    // Check if this is a core (has passiveEffects property)
                    const isCore = item.passiveEffects !== undefined;
                    const isUnlocked = window.isItemUnlocked(item);
                    const levelReq = RARITY_REQUIREMENTS[item.rarity]?.level || 1;
                    const itemKey = item?.templateId || item?.baseId || item?.id || item?.name;
                    const duplicateCount = itemKey ? gearCountMap[itemKey] : 0;
                    const duplicateBadge = duplicateCount > 1
                      ? `<div style="position: absolute; top: 6px; right: 6px; background: rgba(0, 0, 0, 0.75); color: #fff; border-radius: 12px; padding: 1px 6px; font-size: 10px; font-weight: 700; letter-spacing: 0.5px; box-shadow: 0 2px 6px rgba(0,0,0,0.4);">x${duplicateCount}</div>`
                      : '';
                    
                    if (isCore) {
                      // Render core card
                      return `
                        <div class="gear-item-card core-card ${!isUnlocked ? 'locked' : ''}" 
                             data-item-id="${item.id}"
                             data-rarity="${item.rarity}"
                             style="cursor: ${isUnlocked ? 'pointer' : 'not-allowed'}; transition: all 0.3s ease; position: relative; ${this.getRarityStyle(item.rarity)}; 
                                    ${!isUnlocked ? 'opacity: 0.6; filter: grayscale(50%);' : ''}"
                             ${isUnlocked ? `ondblclick="window.BagSystem.equipCoreFromInventory('${item.id}'); return false;" title="ğŸ’  ${item.name} (${item.element})&#10;Double-click to equip"` : ''}>
                          ${!isUnlocked ? `<div style="position: absolute; top: 8px; right: 8px; background: rgba(255, 0, 0, 0.8); padding: 2px 8px; border-radius: 8px; font-size: 10px; font-weight: bold; z-index: 1;">ğŸ”’ Lv${levelReq}</div>` : ''}
                          ${duplicateBadge}
                          <div class="gear-item-icon" style="font-size: 40px;">${item.icon || 'ğŸ’ '}</div>
                      <div class="gear-item-name">${item.name}</div>
                          <div class="gear-rarity" style="text-transform: uppercase; font-weight: bold; color: #9a6bff;">${item.rarity} | ${item.element}</div>
                          ${item.weaponSkill ? `
                            <div style="background: rgba(255, 200, 0, 0.15); border-left: 2px solid #ffc800; padding: 4px 6px; margin: 6px 0; font-size: 9px;">
                              <strong>âš”ï¸ ${item.weaponSkill.name}</strong><br>
                              DMG: ${item.weaponSkill.damage} | CD: ${item.weaponSkill.cooldown}s
                            </div>
                          ` : ''}
                          <div class="gear-item-stats" style="font-size: 9px; text-align: left;">
                            ${item.passiveEffects.slice(0, 2).map(e => `<div style="margin: 2px 0;">â€¢ ${e}</div>`).join('')}
                            ${item.passiveEffects.length > 2 ? `<div style="color: rgba(255, 255, 255, 0.5); font-style: italic;">+${item.passiveEffects.length - 2} more</div>` : ''}
                          </div>
                          <div class="gear-actions">
                            ${isUnlocked ? `
                              <button class="gear-action-btn" onclick="event.stopPropagation(); window.BagSystem.equipCoreFromInventory('${item.id}')" style="transition: all 0.2s ease; background: linear-gradient(135deg, #9a6bff, #8a2be2);">ğŸ’  Equip Core</button>
                            ` : `
                              <button class="gear-action-btn" disabled style="opacity: 0.5; cursor: not-allowed;">ğŸ”’ Locked</button>
                            `}
                          </div>
                        </div>
                      `;
                    } else {
                      // Render normal gear card
                      return `
                        <div class="gear-item-card clickable-gear-card" 
                             data-item-id="${item.id}" 
                             data-item-slot="${item.slot}"
                             data-rarity="${item.rarity || 'common'}"
                             title="${item.name}&#10;${item.rarity ? item.rarity.toUpperCase() : 'COMMON'}${this.getGearPrimaryStatSummary(item) ? '&#10;' + this.getGearPrimaryStatSummary(item) : ''}&#10;Click to equip"
                             style="cursor: pointer; transition: all 0.3s ease; position: relative; ${this.getRarityStyle(item.rarity)}">
                          ${duplicateBadge}
                          <div class="gear-item-icon" style="${this.getIconAnimation(item.category)}">${item.icon || 'âš”ï¸'}</div>
                          <div class="gear-item-name">${item.name}${item.upgradeLevel ? `<span style="color: #9a6bff; margin-left: 4px;">+${item.upgradeLevel}</span>` : ''}</div>
                          ${item.rarity ? `<div class="gear-rarity" style="text-transform: uppercase; font-weight: bold;">${item.rarity}</div>` : ''}
                      <div class="gear-item-stats">
                            ${this.getGearStatBadgesHTML(item)}
                      </div>
                      <div class="gear-actions">
                            <button class="gear-action-btn equip" data-action="equip" data-item-id="${item.id}" style="transition: all 0.3s ease; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);">âš¡ Equip</button>
                            ${(item.maxUpgradeLevel ?? 10) > (item.upgradeLevel || 0)
                              ? `<button class="gear-action-btn upgrade" data-action="upgrade" data-item-id="${item.id}" style="transition: all 0.3s ease; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);">â¬†ï¸ Upgrade (${this.calculateGearUpgradeCost(item, (item.upgradeLevel || 0) + 1)}g)</button>`
                              : `<button class="gear-action-btn upgrade" disabled style="opacity: 0.5; cursor: not-allowed;">MAX</button>`}
                            <button class="gear-action-btn fuse" data-action="fuse" data-item-id="${item.id}" style="transition: all 0.3s ease; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);">ğŸ”® Fuse</button>
                      </div>
                    </div>
                      `;
                    }
                  }).join('')}
                </div>
              `}
            </div>
          `;

          // Attach filter/sort listeners
          pane.querySelectorAll('.filter-chip').forEach(chip => {
            chip.addEventListener('click', () => {
              this.state.gearFilter = chip.dataset.filter;
              this.renderGearTab();
            });
          });

          const sortSelect = pane.querySelector('#gearSort');
          if (sortSelect) {
            sortSelect.addEventListener('change', (e) => {
              this.state.gearSort = e.target.value;
              this.renderGearTab();
            });
          }

          // Attach gear action buttons
          pane.querySelectorAll('.gear-action-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
              e.stopPropagation(); // Prevent card click from firing
              const action = btn.dataset.action;
              const itemId = btn.dataset.itemId;
              const item = window.gameState.inventory.gear.find(i => i.id === itemId);

              if (action === 'equip' && item) this.equipItem(item);
              else if (action === 'upgrade' && item) this.upgradeGear(itemId);
              else if (action === 'fuse' && item) this.fuseGear(itemId);
            });
          });
          
          // Click-to-equip on gear cards
          pane.querySelectorAll('.clickable-gear-card').forEach(card => {
            // Single click to equip
            card.addEventListener('click', (e) => {
              // Don't trigger if clicking on buttons
              if (e.target.closest('.gear-action-btn')) return;
              
              const itemId = card.dataset.itemId;
              const item = window.gameState.inventory.gear.find(i => i.id === itemId);
              if (item) {
                this.equipItemWithAnimation(item, card);
              }
            });
            
            // Right-click context menu
            card.addEventListener('contextmenu', (e) => {
              e.preventDefault();
              const itemId = card.dataset.itemId;
              const item = window.gameState.inventory.gear.find(i => i.id === itemId);
              if (item) {
                this.showGearContextMenu(e, item, false);
              }
            });
            
            // Hover effect
            card.addEventListener('mouseenter', () => {
              card.style.transform = 'translateY(-4px)';
              card.style.boxShadow = '0 8px 20px rgba(0, 229, 255, 0.4)';
            });
            card.addEventListener('mouseleave', () => {
              card.style.transform = 'translateY(0)';
              card.style.boxShadow = '';
            });
          });
          
          // Double-click to unequip on equipped slots
          pane.querySelectorAll('.equipment-slot-v2').forEach(slot => {
            let clickCount = 0;
            let clickTimer = null;
            
            slot.addEventListener('click', () => {
              clickCount++;
              
              if (clickCount === 1) {
                clickTimer = setTimeout(() => {
                  clickCount = 0;
                }, 300);
              } else if (clickCount === 2) {
                clearTimeout(clickTimer);
                clickCount = 0;
                
                // Double-click detected - unequip
                const slotId = slot.dataset.slot;
                const item = window.gameState.equipped[slotId];
                if (item) {
                  this.unequipItem(slotId, item);
                }
              }
            });
            
            // Right-click context menu for equipped items
            slot.addEventListener('contextmenu', (e) => {
              e.preventDefault();
              const slotId = slot.dataset.slot;
              const item = window.gameState.equipped[slotId];
              if (item) {
                this.showGearContextMenu(e, item, true);
              }
            });
          });
          
          // Unequip All button
          const unequipAllBtn = document.getElementById('unequipAllBtn');
          if (unequipAllBtn) {
            unequipAllBtn.addEventListener('click', () => this.unequipAll());
          }
          
          // Render character sprite with equipped gear
          setTimeout(() => {
            this.renderGearCharacterSprite();
            this.startGearCharacterAnimation(); // Start continuous animation
          }, 100);
        },

        equipItem(item) {
          // Use item.slot if available, otherwise fall back to name-based detection
          let slot = item.slot;
          item = this.normalizeGearItem(item);
          
          // Handle ring slots - use ring1 if empty, otherwise ring2
          if (slot === 'ring') {
            slot = window.gameState.equipped.ring1 ? 'ring2' : 'ring1';
          }
          
          // Fallback for items without slot property (backwards compatibility)
          if (!slot) {
          const slotMap = {
            weapon: 'weapon',
            armor: item.name.includes('Helmet') ? 'head' :
              item.name.includes('Armor') || item.name.includes('Vest') ? 'chest' :
                item.name.includes('Gauntlet') ? 'gloves' :
                  item.name.includes('Pants') ? 'pants' : 'boots',
            accessory: item.name.includes('Ring') ? (window.gameState.equipped.ring1 ? 'ring2' : 'ring1') : 'necklace'
          };
            slot = slotMap[item.category];
          }

          if (slot) {
            window.gameState.equipped[slot] = item;
            this.showToast(`âœ… Equipped ${item.name}`);
            this.playCandySfx('equip');
            this.renderGearTab();
            this.updateStats();
            
            // Narrate event
            this.narrateEvent('equip', `Equipped ${item.name}`);
            
            // Add visual feedback animation
            setTimeout(() => {
              const slotEl = document.querySelector(`[data-slot="${slot}"]`);
              if (slotEl) {
                // Flash animation
                slotEl.style.animation = 'none';
                setTimeout(() => {
                  slotEl.style.animation = 'equip-flash 0.5s, slot-glow 2s infinite 0.5s';
                }, 10);
                
                // Show floating stat text
                this.showFloatingStats(slotEl, item);
                
                // Trigger particle effect
                const rect = slotEl.getBoundingClientRect();
                this.createParticleEffect('equip', rect.left + rect.width/2, rect.top + rect.height/2);
              }
            }, 100);
          }
        },

        showFloatingStats(element, item) {
          item = this.normalizeGearItem(item);
          const summary = this.getGearPrimaryStatSummary(item);
          
          if (!summary) return;
          
          const floatingText = document.createElement('div');
          floatingText.style.cssText = `
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #38ef7d;
            font-size: 14px;
            font-weight: bold;
            pointer-events: none;
            z-index: 10000;
            text-shadow: 0 0 10px rgba(56, 239, 125, 0.8);
            animation: float-up 1s ease-out forwards;
          `;
          floatingText.textContent = summary;
          
          // Add animation
          const style = document.createElement('style');
          style.textContent = `
            @keyframes float-up {
              0% { opacity: 1; transform: translate(-50%, -50%); }
              100% { opacity: 0; transform: translate(-50%, -150%); }
            }
          `;
          document.head.appendChild(style);
          
          element.style.position = 'relative';
          element.appendChild(floatingText);
          
          setTimeout(() => {
            floatingText.remove();
            style.remove();
          }, 1000);
        },

        equipItemWithAnimation(item, sourceElement) {
          // Visual feedback: item flies from source to slot
          const slot = this.getTargetSlotForItem(item);
          if (!slot) return;
          
          // Check if item is epic/legendary and slot is occupied
          const currentItem = window.gameState.equipped[slot];
          if (currentItem && (item.rarity === 'epic' || item.rarity === 'legendary')) {
            this.showConfirmDialog(
              `Replace ${currentItem.name} with ${item.name}?`,
              () => this.equipItem(item),
              () => this.showToast('âŒ Equip cancelled')
            );
            return;
          }
          
          // Animate item flying to slot
          if (sourceElement) {
            this.animateItemFly(sourceElement, slot);
          }
          
          // Equip the item
          setTimeout(() => this.equipItem(item), 300);
        },

        getTargetSlotForItem(item) {
          let slot = item.slot;
          if (slot === 'ring') {
            slot = window.gameState.equipped.ring1 ? 'ring2' : 'ring1';
          }
          return slot;
        },

        animateItemFly(sourceEl, targetSlot) {
          // Create flying item clone
          const clone = sourceEl.cloneNode(true);
          clone.style.cssText = `
            position: fixed;
            pointer-events: none;
            z-index: 10000;
            transition: all 0.3s ease-in-out;
            opacity: 0.8;
          `;
          
          const sourceRect = sourceEl.getBoundingClientRect();
          clone.style.left = sourceRect.left + 'px';
          clone.style.top = sourceRect.top + 'px';
          clone.style.width = sourceRect.width + 'px';
          clone.style.height = sourceRect.height + 'px';
          
          document.body.appendChild(clone);
          
          // Find target slot position
          const targetEl = document.querySelector(`[data-slot="${targetSlot}"]`);
          if (targetEl) {
            const targetRect = targetEl.getBoundingClientRect();
            setTimeout(() => {
              clone.style.left = targetRect.left + 'px';
              clone.style.top = targetRect.top + 'px';
              clone.style.transform = 'scale(0.5)';
              clone.style.opacity = '0';
            }, 10);
          }
          
          setTimeout(() => clone.remove(), 350);
        },

        unequipItem(slotId, item) {
          // Check if epic/legendary - require confirmation
          if (item.rarity === 'epic' || item.rarity === 'legendary') {
            this.showConfirmDialog(
              `Unequip ${item.name}?`,
              () => this.performUnequip(slotId, item),
              () => this.showToast('âŒ Unequip cancelled')
            );
            return;
          }
          
          this.performUnequip(slotId, item);
        },

        performUnequip(slotId, item) {
          // Return item to inventory
          window.gameState.inventory.gear.push(item);
          window.gameState.equipped[slotId] = null;
          
          this.showToast(`ğŸ”“ Unequipped ${item.name}`);
          this.renderGearTab();
          this.updateStats();
        },

        unequipAll() {
          const equipped = window.gameState.equipped;
          const slots = ['head', 'chest', 'gloves', 'pants', 'boots', 'weapon', 'offhand', 'ring1', 'ring2', 'necklace'];
          
          let unequippedCount = 0;
          
          slots.forEach(slot => {
            const item = equipped[slot];
            if (item) {
              window.gameState.inventory.gear.push(item);
              equipped[slot] = null;
              unequippedCount++;
            }
          });
          
          if (unequippedCount > 0) {
            this.showToast(`ğŸ—‘ï¸ Unequipped ${unequippedCount} items!`);
            this.renderGearTab();
            this.updateStats();
          } else {
            this.showToast('âœ… No items equipped');
          }
        },
        
        equipCoreFromInventory(coreId) {
          const core = window.CORES_DATABASE[coreId];
          if (!core) {
            this.showToast('âš ï¸ Core not found!');
            return;
          }
          
          // Check if unlocked
          if (!window.isItemUnlocked(core)) {
            const levelReq = RARITY_REQUIREMENTS[core.rarity]?.level || 1;
            this.showToast(`ğŸ”’ Requires level ${levelReq}!`);
            return;
          }
          
          // Find available slots for this core type
          const availableSlots = Object.entries(CORE_SLOTS_CONFIG)
            .filter(([slotId, config]) => config.coreType === core.category)
            .map(([slotId]) => slotId);
          
          if (availableSlots.length === 0) {
            this.showToast('âš ï¸ No compatible slots for this core!');
            return;
          }
          
          // If only one slot, equip directly
          if (availableSlots.length === 1) {
            window.equipCoreToSlot(availableSlots[0], core);
            this.renderGearTab();
            this.showToast(`âœ… Equipped ${core.name} to ${availableSlots[0]}!`);
            return;
          }
          
          // Multiple slots available - show selection menu
          this.showCoreSlotSelectionMenu(core, availableSlots);
        },
        
        showCoreSlotSelectionMenu(core, availableSlots) {
          const modal = document.createElement('div');
          modal.id = 'coreSlotSelectModal';
          modal.style.cssText = `
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 99999;
            animation: fadeIn 0.2s ease;
          `;
          
          const rarityColors = {
            common: '#9e9e9e',
            uncommon: '#4caf50',
            rare: '#2196f3',
            epic: '#9c27b0',
            legendary: '#ff9800'
          };
          const borderColor = rarityColors[core.rarity] || '#9e9e9e';
          
          modal.innerHTML = `
            <div style="background: linear-gradient(135deg, rgba(30, 30, 60, 0.95), rgba(15, 15, 35, 0.95));
                        border: 3px solid ${borderColor};
                        border-radius: 16px;
                        padding: 24px;
                        max-width: 500px;
                        box-shadow: 0 0 40px rgba(138, 43, 226, 0.6);">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
                <h3 style="color: ${borderColor}; margin: 0;">Select Equipment Slot</h3>
                <button onclick="document.getElementById('coreSlotSelectModal').remove()" 
                        style="padding: 4px 12px; background: rgba(255, 0, 0, 0.3); border: 2px solid #ff6b6b; border-radius: 8px; color: white; cursor: pointer;">âœ•</button>
              </div>
              
              <div style="margin-bottom: 16px; padding: 12px; background: rgba(138, 43, 226, 0.2); border: 2px solid ${borderColor}; border-radius: 8px;">
                <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                  <span style="font-size: 32px;">${core.icon}</span>
                  <div>
                    <div style="font-weight: 700; color: ${borderColor};">${core.name}</div>
                    <div style="font-size: 11px; color: rgba(255, 255, 255, 0.6);">${core.rarity} | ${core.element}</div>
                  </div>
                </div>
              </div>
              
              <div style="color: rgba(255, 255, 255, 0.8); font-size: 12px; margin-bottom: 12px;">
                Choose which equipment to enhance:
              </div>
              
              <div style="display: flex; flex-direction: column; gap: 10px;">
                ${availableSlots.map(slotId => {
                  const currentCore = window.getCoreForSlot(slotId);
                  const slotConfig = CORE_SLOTS_CONFIG[slotId];
                  return `
                    <button onclick="window.equipCoreToSlot('${slotId}', window.CORES_DATABASE['${core.id}']); window.BagSystem.renderGearTab(); document.getElementById('coreSlotSelectModal').remove(); window.BagSystem.showToast('âœ… Equipped ${core.name}!');"
                            style="padding: 12px;
                                   background: ${currentCore ? 'rgba(138, 43, 226, 0.2)' : 'rgba(0, 0, 0, 0.3)'};
                                   border: 2px solid ${currentCore ? '#9a6bff' : 'rgba(255, 255, 255, 0.3)'};
                                   border-radius: 8px;
                                   color: white;
                                   cursor: pointer;
                                   transition: all 0.2s ease;
                                   text-align: left;"
                            onmouseover="this.style.background='rgba(138, 43, 226, 0.4)'; this.style.borderColor='#9a6bff';"
                            onmouseout="this.style.background='${currentCore ? 'rgba(138, 43, 226, 0.2)' : 'rgba(0, 0, 0, 0.3)'}'; this.style.borderColor='${currentCore ? '#9a6bff' : 'rgba(255, 255, 255, 0.3)'}';">
                      <div style="font-weight: 700; margin-bottom: 4px;">${slotConfig.icon} ${slotConfig.label}</div>
                      <div style="font-size: 10px; color: rgba(255, 255, 255, 0.7);">
                        ${currentCore ? `Current: ${currentCore.name} â†’ Will replace` : 'Empty slot'}
                      </div>
                    </button>
                  `;
                }).join('')}
              </div>
            </div>
          `;
          
          document.body.appendChild(modal);
          
          // Close on outside click
          modal.addEventListener('click', (e) => {
            if (e.target === modal) {
              modal.remove();
            }
          });
        },
        
        showCoreEquipMenu(equipmentSlotId) {
          const coreConfig = CORE_SLOTS_CONFIG[equipmentSlotId];
          if (!coreConfig) return;
          
          // Get available cores from CORES_DATABASE
          const availableCores = Object.values(window.CORES_DATABASE).filter(core => 
            core.category === coreConfig.coreType
          );
          
          if (availableCores.length === 0) {
            this.showToast(`âš ï¸ No ${coreConfig.coreType} cores available!`);
            return;
          }
          
          // Create modal with core selection
          const modal = document.createElement('div');
          modal.id = 'coreEquipModal';
          modal.style.cssText = `
            position: fixed;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 99999;
            animation: fadeIn 0.2s ease;
          `;
          
          const content = document.createElement('div');
          content.style.cssText = `
            background: linear-gradient(135deg, rgba(30, 30, 60, 0.95), rgba(15, 15, 35, 0.95));
            border: 3px solid #9a6bff;
            border-radius: 16px;
            padding: 24px;
            max-width: 600px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 0 40px rgba(138, 43, 226, 0.6);
          `;
          
          const playerLevel = window.gameState.playerLevel || 1;
          
          content.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
              <h3 style="color: #9a6bff; margin: 0;">Select ${coreConfig.label}</h3>
              <button onclick="document.getElementById('coreEquipModal').remove()" 
                      style="padding: 4px 12px; background: rgba(255, 0, 0, 0.3); border: 2px solid #ff6b6b; border-radius: 8px; color: white; cursor: pointer;">âœ•</button>
            </div>
            <div style="color: rgba(255, 255, 255, 0.7); font-size: 12px; margin-bottom: 16px;">
              Equipment: ${equipmentSlotId} | Core Type: ${coreConfig.coreType}
            </div>
            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 12px;">
              ${availableCores.map(core => {
                const isUnlocked = window.isItemUnlocked(core);
                const levelReq = RARITY_REQUIREMENTS[core.rarity]?.level || 1;
                const isLevelMet = playerLevel >= levelReq;
                
                const rarityColors = {
                  common: '#9e9e9e',
                  uncommon: '#4caf50',
                  rare: '#2196f3',
                  epic: '#9c27b0',
                  legendary: '#ff9800'
                };
                const borderColor = rarityColors[core.rarity] || '#9e9e9e';
                
                return `
                  <div class="core-select-card" 
                       data-core-id="${core.id}"
                       onclick="${isUnlocked ? `window.equipCoreToSlot('${equipmentSlotId}', window.CORES_DATABASE['${core.id}']); window.BagSystem.renderGearTab(); document.getElementById('coreEquipModal').remove();` : ''}"
                       style="
                         padding: 12px;
                         background: ${isUnlocked ? 'rgba(138, 43, 226, 0.1)' : 'rgba(0, 0, 0, 0.4)'};
                         border: 2px solid ${isUnlocked ? borderColor : '#444'};
                         border-radius: 12px;
                         cursor: ${isUnlocked ? 'pointer' : 'not-allowed'};
                         transition: all 0.2s ease;
                         opacity: ${isUnlocked ? '1' : '0.5'};
                         position: relative;
                       ">
                    ${!isUnlocked ? `<div style="position: absolute; top: 8px; right: 8px; background: rgba(255, 0, 0, 0.8); padding: 2px 8px; border-radius: 8px; font-size: 10px; font-weight: bold;">ğŸ”’ Lv${levelReq}</div>` : ''}
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 8px;">
                      <span style="font-size: 32px;">${core.icon}</span>
                      <div style="flex: 1;">
                        <div style="font-weight: bold; color: ${borderColor};">${core.name}</div>
                        <div style="font-size: 10px; color: rgba(255, 255, 255, 0.6); text-transform: uppercase;">${core.rarity} | ${core.element}</div>
                      </div>
                    </div>
                    ${core.weaponSkill ? `
                      <div style="background: rgba(255, 200, 0, 0.1); border-left: 3px solid #ffc800; padding: 6px; margin-bottom: 8px; font-size: 10px;">
                        <strong>âš”ï¸ ${core.weaponSkill.name}</strong><br>
                        DMG: ${core.weaponSkill.damage} | CD: ${core.weaponSkill.cooldown}s<br>
                        Trigger: ${core.weaponSkill.trigger}
                      </div>
                    ` : ''}
                    <div style="font-size: 10px; color: rgba(255, 255, 255, 0.8);">
                      ${core.passiveEffects.slice(0, 3).map(e => `<div>â€¢ ${e}</div>`).join('')}
                      ${core.passiveEffects.length > 3 ? `<div style="color: rgba(255, 255, 255, 0.5); font-style: italic;">+${core.passiveEffects.length - 3} more...</div>` : ''}
                    </div>
                    ${isUnlocked ? '' : `
                      <div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255, 255, 255, 0.2); text-align: center; font-size: 10px; color: #ff6b6b;">
                        Reach level ${levelReq} to unlock
                      </div>
                    `}
                  </div>
                `;
              }).join('')}
            </div>
          `;
          
          modal.appendChild(content);
          document.body.appendChild(modal);
          
          // Close on outside click
          modal.addEventListener('click', (e) => {
            if (e.target === modal) {
              modal.remove();
            }
          });
        },

        showGearContextMenu(event, item, isEquipped) {
          // Remove any existing context menu
          const existingMenu = document.getElementById('gearContextMenu');
          if (existingMenu) existingMenu.remove();
          
          // Create context menu
          const menu = document.createElement('div');
          menu.id = 'gearContextMenu';
          menu.style.cssText = `
            position: fixed;
            left: ${event.clientX}px;
            top: ${event.clientY}px;
            background: rgba(10, 18, 32, 0.98);
            border: 2px solid rgba(0, 229, 255, 0.6);
            border-radius: 8px;
            padding: 8px;
            z-index: 10001;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.6);
            min-width: 150px;
          `;
          
          const options = [];
          
          if (!isEquipped) {
            options.push({ label: 'âš”ï¸ Equip', action: () => this.equipItem(item) });
            options.push({ label: 'â¬†ï¸ Upgrade', action: () => this.upgradeGear(item.id) });
            options.push({ label: 'ğŸ’° Sell', action: () => this.sellItem(item) });
          } else {
            options.push({ label: 'ğŸ”“ Unequip', action: () => this.performUnequip(this.findSlotForItem(item), item) });
            options.push({ label: 'â¬†ï¸ Upgrade', action: () => this.upgradeGear(item.id) });
          }
          
          options.push({ label: 'ğŸ“Š Compare', action: () => this.compareItem(item) });
          options.push({ label: 'âŒ Cancel', action: () => menu.remove() });
          
          options.forEach(opt => {
            const btn = document.createElement('button');
            btn.textContent = opt.label;
            btn.style.cssText = `
              display: block;
              width: 100%;
              padding: 8px 12px;
              margin-bottom: 4px;
              background: rgba(0, 229, 255, 0.1);
              border: 1px solid rgba(0, 229, 255, 0.3);
              border-radius: 4px;
              color: #00e5ff;
              font-size: 11px;
              cursor: pointer;
              text-align: left;
              transition: all 0.2s ease;
            `;
            btn.addEventListener('mouseenter', () => {
              btn.style.background = 'rgba(0, 229, 255, 0.3)';
            });
            btn.addEventListener('mouseleave', () => {
              btn.style.background = 'rgba(0, 229, 255, 0.1)';
            });
            btn.addEventListener('click', () => {
              opt.action();
              menu.remove();
            });
            menu.appendChild(btn);
          });
          
          document.body.appendChild(menu);
          
          // Close menu when clicking outside
          const closeMenu = (e) => {
            if (!menu.contains(e.target)) {
              menu.remove();
              document.removeEventListener('click', closeMenu);
            }
          };
          setTimeout(() => document.addEventListener('click', closeMenu), 10);
        },

        findSlotForItem(item) {
          const equipped = window.gameState.equipped;
          for (const [slot, equippedItem] of Object.entries(equipped)) {
            if (equippedItem === item) return slot;
          }
          return null;
        },

        showConfirmDialog(message, onConfirm, onCancel) {
          // Create modal overlay
          const overlay = document.createElement('div');
          overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 10002;
            display: flex;
            align-items: center;
            justify-content: center;
          `;
          
          const dialog = document.createElement('div');
          dialog.style.cssText = `
            background: rgba(10, 18, 32, 0.98);
            border: 3px solid rgba(0, 229, 255, 0.6);
            border-radius: 12px;
            padding: 24px;
            max-width: 400px;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.8);
          `;
          
          dialog.innerHTML = `
            <div style="font-size: 16px; color: #00e5ff; margin-bottom: 20px; text-align: center;">
              ${message}
            </div>
            <div style="display: flex; gap: 12px; justify-content: center;">
              <button id="confirmYes" style="padding: 12px 24px; background: linear-gradient(135deg, #38ef7d, #4fc3f7); border: 2px solid white; border-radius: 8px; color: white; font-weight: bold; cursor: pointer; font-size: 13px;">
                âœ“ Yes
              </button>
              <button id="confirmNo" style="padding: 12px 24px; background: linear-gradient(135deg, #ff6b35, #ff3b3b); border: 2px solid white; border-radius: 8px; color: white; font-weight: bold; cursor: pointer; font-size: 13px;">
                âœ• No
              </button>
            </div>
          `;
          
          overlay.appendChild(dialog);
          document.body.appendChild(overlay);
          
          document.getElementById('confirmYes').addEventListener('click', () => {
            onConfirm();
            overlay.remove();
          });
          
          document.getElementById('confirmNo').addEventListener('click', () => {
            if (onCancel) onCancel();
            overlay.remove();
          });
        },

        sellItem(item) {
          this.normalizeGearItem(item);
          const basePrice = item.basePrice || window.GearData?.getDefinition(item)?.price || 100;
          const power = this.calculateItemPower(item);
          const sellPrice = Math.max(50, Math.round(basePrice * 0.6 + power * 0.3));
          
          this.showConfirmDialog(
            `Sell ${item.name} for ${sellPrice}g?`,
            () => {
              // Remove from inventory
              const gear = window.gameState.inventory.gear;
              const index = gear.indexOf(item);
              if (index !== -1) {
                gear.splice(index, 1);
                window.gameState.gold += sellPrice;
                this.showToast(`ğŸ’° Sold ${item.name} for ${sellPrice}g!`);
                this.renderGearTab();
              }
            }
          );
        },

        compareItem(item) {
          const currentSlot = this.getTargetSlotForItem(item);
          const equippedItem = window.gameState.equipped[currentSlot];
          this.normalizeGearItem(item);
          if (equippedItem) this.normalizeGearItem(equippedItem);
          
          const itemSummary = this.getGearPrimaryStatSummary(item) || 'No primary stats';
          const itemPower = this.getGearPower(item);
          
          let comparison = `ğŸ“Š ${item.icon} ${item.name} (Power ${itemPower})\n${itemSummary}\n`;
          
          if (equippedItem) {
            const equippedPower = this.getGearPower(equippedItem);
            const equippedSummary = this.getGearPrimaryStatSummary(equippedItem) || 'No primary stats';
            comparison += `\nvs ${equippedItem.icon} ${equippedItem.name} (Power ${equippedPower})\n${equippedSummary}\n\n`;
            
            const diffs = [];
            GEAR_STAT_DISPLAY_ORDER.forEach(statKey => {
              const newVal = item.stats?.[statKey] ?? item[statKey];
              const oldVal = equippedItem.stats?.[statKey] ?? equippedItem[statKey];
              const delta = (newVal || 0) - (oldVal || 0);
              if (Math.abs(delta) > 0.0001) {
                const formatted = formatGearStatText(statKey, delta);
                if (formatted) diffs.push(formatted);
              }
            });
            if (diffs.length) {
              comparison += `Difference: ${diffs.join(', ')}`;
            } else {
              comparison += 'Difference: No significant changes';
            }
          } else {
            comparison += `\nNo item in ${currentSlot} slot`;
          }
          
          this.showToast(comparison);
        },

        // â•â•â• PARTICLE EFFECT SYSTEM â•â•â•
        createParticleEffect(type, x, y, overrides = {}) {
          const container = document.createElement('div');
          container.style.cssText = `
            position: fixed;
            left: ${x}px;
            top: ${y}px;
            pointer-events: none;
            z-index: 9999;
          `;
          
          const configs = {
            equip: { count: 15, colors: ['#38ef7d'], emoji: ['âœ¨'], duration: 1000 },
            levelup: { count: 30, colors: ['#ffd77a'], emoji: ['â­'], duration: 1500 },
            upgrade: { count: 20, colors: ['#9333ea'], emoji: ['âš¡'], duration: 1200 },
            open: { count: 25, colors: ['#ff6b9d'], emoji: ['ğŸ‰'], duration: 1300 },
            'raid-entry': {
              count: 24,
              colors: ['#ff9a9e', '#a78bfa', '#8df5ff', '#ffd77a'],
              emoji: ['ğŸ¬', 'ğŸ­', 'âœ¨', 'ğŸ†'],
              duration: 1500
            },
            'raid-contrail': {
              count: 18,
              colors: ['#8df5ff', '#ffd77a', '#ffffff'],
              emoji: ['âœ¦', 'â‹†'],
              duration: 1200
            },
            'raid-recap': {
              count: 32,
              colors: ['#ffd77a', '#8df5ff', '#ff9a9e'],
              emoji: ['âœ¨', 'ğŸ­', 'ğŸ‰'],
              duration: 1800
            }
          };
          
          const base = configs[type] || configs.equip;
          const config = {
            ...base,
            count: overrides.count || base.count,
            colors: overrides.colors
              || (overrides.color ? [overrides.color] : base.colors),
            emoji: overrides.emoji || base.emoji,
            duration: overrides.duration || base.duration
          };
          
          for (let i = 0; i < config.count; i++) {
            const particle = document.createElement('div');
            const emojiOptions = Array.isArray(config.emoji) ? config.emoji : [config.emoji];
            particle.textContent = emojiOptions[Math.floor(Math.random() * emojiOptions.length)] || 'âœ¨';
            const colors = Array.isArray(config.colors) ? config.colors : [config.colors];
            const color = colors[Math.floor(Math.random() * colors.length)] || '#ffffff';
            
            const angle = (Math.PI * 2 * i) / config.count;
            const velocity = 50 + Math.random() * 100;
            const xVel = Math.cos(angle) * velocity;
            const yVel = Math.sin(angle) * velocity - 50;
            
            particle.style.cssText = `
              position: absolute;
              font-size: ${8 + Math.random() * 12}px;
              color: ${color};
              filter: drop-shadow(0 0 4px ${color});
              animation: particle-fade ${config.duration}ms ease-out forwards;
              transform: translate(${xVel}px, ${yVel}px);
            `;
            
            container.appendChild(particle);
          }
          
          // Add particle fade animation
          if (!document.getElementById('particle-fade-style')) {
            const style = document.createElement('style');
            style.id = 'particle-fade-style';
            style.textContent = `
              @keyframes particle-fade {
                0% { opacity: 1; transform: translate(0, 0) scale(1); }
                100% { opacity: 0; transform: translate(var(--x), var(--y)) scale(0); }
              }
            `;
            document.head.appendChild(style);
          }
          
          document.body.appendChild(container);
          setTimeout(() => container.remove(), config.duration);
        },

      playAudioLayer(layerId, config = {}) {
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        if (!AudioContext) return null;
        const ctx = window.__candyToneCtx || new AudioContext();
        window.__candyToneCtx = ctx;
        if (ctx.state === 'suspended') {
          ctx.resume().catch(() => {});
        }
        this.audioLayers = this.audioLayers || {};
        this.stopAudioLayer(layerId, { immediate: true });
        try {
          const oscillator = ctx.createOscillator();
          const gain = ctx.createGain();
          oscillator.type = config.waveform || 'sine';
          oscillator.frequency.setValueAtTime(config.frequency || 420, ctx.currentTime);
          gain.gain.setValueAtTime(config.gain ?? 0.12, ctx.currentTime);
          oscillator.connect(gain).connect(ctx.destination);
          oscillator.start();
          this.audioLayers[layerId] = { oscillator, gain, ctx };
          if (config.duration) {
            const stopTime = ctx.currentTime + config.duration;
            gain.gain.setTargetAtTime(0, stopTime - 0.25, 0.25);
            oscillator.stop(stopTime + 0.05);
            window.setTimeout(() => this.stopAudioLayer(layerId), config.duration * 1000);
          }
          return layerId;
        } catch (error) {
          debugWarn('[BagSystem] playAudioLayer failed', error);
          return null;
        }
      },

      stopAudioLayer(layerId, options = {}) {
        this.audioLayers = this.audioLayers || {};
        const layer = this.audioLayers[layerId];
        if (!layer) return;
        try {
          const now = layer.ctx.currentTime;
          if (options.immediate) {
            layer.gain.gain.cancelScheduledValues(now);
            layer.gain.gain.setValueAtTime(0, now);
            layer.oscillator.stop(now);
          } else {
            layer.gain.gain.setTargetAtTime(0, now, 0.2);
            layer.oscillator.stop(now + 0.25);
          }
        } catch (error) {
          debugWarn('[BagSystem] stopAudioLayer error', error);
        }
        delete this.audioLayers[layerId];
      },

      stopAllAudioLayers() {
        if (!this.audioLayers) return;
        Object.keys(this.audioLayers).forEach(id => this.stopAudioLayer(id, { immediate: true }));
      },

        playCandySfx(effectId = 'ui-click', options = {}) {
          const soundApi = window.CandySound || window.SoloLevelingSound || window.candySound;
          if (soundApi) {
            if (typeof soundApi.play === 'function') {
              try {
                soundApi.play(effectId, options);
                return;
              } catch (error) {
                debugWarn('[CandySfx] External sound API play failed', error);
              }
            }
            const effectFn = soundApi.effects?.[effectId];
            if (typeof effectFn === 'function') {
              try {
                effectFn(options);
                return;
              } catch (error) {
                debugWarn('[CandySfx] External effect function failed', error);
              }
            }
          }

          const AudioContext = window.AudioContext || window.webkitAudioContext;
          if (!AudioContext) return;

          try {
            const ctx = window.__candyToneCtx || new AudioContext();
            window.__candyToneCtx = ctx;
            if (ctx.state === 'suspended') {
              ctx.resume().catch(() => {});
            }

            const freqMap = {
              'quest-complete': [660, 880],
              'level-up': [523, 784, 988],
              'equip': [610],
              'ui-click': [520],
              'auto-equip': [560, 640],
              'shop-buy': [720, 960],
              'quest-progress': [600, 760],
            };

            const sequence = freqMap[effectId] || freqMap['ui-click'];
            let start = ctx.currentTime + 0.02;
            const duration = options.duration || 0.14;

            sequence.forEach((freq, index) => {
              const osc = ctx.createOscillator();
              const gain = ctx.createGain();
              osc.frequency.value = freq;
              osc.type = index === sequence.length - 1 ? 'triangle' : 'sine';
              gain.gain.value = 0.0018;

              osc.connect(gain);
              gain.connect(ctx.destination);

              const noteStart = start + index * duration * 0.55;
              const noteEnd = noteStart + duration;
              gain.gain.setValueAtTime(gain.gain.value, noteStart);
              gain.gain.exponentialRampToValueAtTime(0.00001, noteEnd);
              osc.start(noteStart);
              osc.stop(noteEnd + 0.01);
            });
          } catch (error) {
            debugWarn('[CandySfx] Web Audio playback failed', error);
          }
        },

        // Check if item is owned
        isItemOwned(item) {
          if (item.type === 'pet') {
            return window.gameState.inventory.pets?.some(p => p.name === item.name);
          } else if (item.type === 'spirit') {
            return window.gameState.inventory.spirits?.some(s => s.name === item.name);
          } else if (item.type === 'vehicle') {
            return window.gameState.inventory.vehicles?.some(v => v.name === item.name);
          } else if (item.type === 'robot') {
            return window.gameState.inventory.robots?.some(r => r.name === item.name);
          } else if (item.category === 'supernatural') {
            return window.gameState.inventory.abilities?.some(a => a.id === item.id);
          }
          return false;
        },

        getRarityStyle(rarity) {
          const styles = {
            common: 'border-color: rgba(156, 163, 175, 0.5); animation: rarity-common 2s infinite;',
            uncommon: 'border-color: rgba(34, 197, 94, 0.7); animation: rarity-uncommon 2s infinite;',
            rare: 'border-color: rgba(59, 130, 246, 0.8); animation: rarity-rare 2s infinite;',
            epic: 'border-color: rgba(147, 51, 234, 0.9); animation: rarity-epic 1.5s infinite;',
            legendary: 'border-color: rgba(255, 215, 0, 1); animation: rarity-legendary 1s infinite;'
          };
          return styles[rarity] || styles.common;
        },

        getIconAnimation(category) {
          const animations = {
            weapon: 'animation: weapon-shine 2s infinite;',
            armor: 'animation: armor-pulse 2s infinite;',
            accessory: 'animation: accessory-sparkle 2s infinite;',
            container: 'animation: container-shake 0.5s infinite;',
            consumable: 'animation: potion-swirl 3s infinite;'
          };
          return animations[category] || '';
        },

        // â•â•â• SHOP SYSTEM â•â•â•
        renderShopTab() {
          const pane = document.getElementById('bagContentPane');
          const shop = window.gameState.shop;
          const shopFilter = this.state.shopFilter || 'all';
          const shopSort = this.state.shopSort || 'price-low';
          
          // Update daily price fluctuation
          this.updateShopPrices();
          
          // Filter shop items
          let items = [...shop.inventory];
          if (shopFilter !== 'all') {
            items = items.filter(item => {
              // Special handling for cores filter - match items with weaponSkill or passiveEffects
              if (shopFilter === 'cores' || shopFilter === 'core') {
                return item.id?.includes('core_') || item.weaponSkill || item.passiveEffects;
              }
              // Support both category and type properties for flexible filtering
              return item.category === shopFilter || item.type === shopFilter;
            });
          }
          
          // Hide owned items filter
          const hideOwned = this.state.shopHideOwned || false;
          if (hideOwned) {
            items = items.filter(item => !this.isItemOwned(item));
          }
          
          // Sort shop items
          if (shopSort === 'price-low') {
            items.sort((a, b) => this.calculatePrice(a) - this.calculatePrice(b));
          } else if (shopSort === 'price-high') {
            items.sort((a, b) => this.calculatePrice(b) - this.calculatePrice(a));
          } else if (shopSort === 'power') {
            items.sort((a, b) => this.calculateItemPower(b) - this.calculateItemPower(a));
          }
          
          // AI recommendations
          const recommendations = this.getShopRecommendations();
          
          // Collection Progress
          const ownedPets = window.gameState.inventory.pets?.length || 0;
          const ownedSpirits = window.gameState.inventory.spirits?.length || 0;
          const ownedVehicles = window.gameState.inventory.vehicles?.length || 0;
          const ownedRobots = window.gameState.inventory.robots?.length || 0;
          const totalPets = 5; // AVAILABLE_PETS.length
          const totalSpirits = 5; // AVAILABLE_SPIRITS.length
          const totalVehicles = 5; // AVAILABLE_VEHICLES.length
          const totalRobots = 5; // AVAILABLE_ROBOTS.length
          
          pane.innerHTML = `
            <div style="margin-bottom: 20px;">
              <h2 style="font-size: 22px; color: #ffd77a; margin-bottom: 10px;">ğŸª Merchant Shop</h2>
              <p style="color: rgba(207, 227, 255, 0.7); font-size: 13px;">
                Buy powerful items to enhance your journey!
              </p>
            </div>
            
            <!-- Collection Progress Tracker -->
            <div style="background: linear-gradient(135deg, rgba(56, 239, 125, 0.15), rgba(79, 195, 247, 0.15)); border: 2px solid rgba(56, 239, 125, 0.4); border-radius: 12px; padding: 16px; margin-bottom: 20px;">
              <h3 style="color: #38ef7d; font-size: 14px; margin-bottom: 12px;">ğŸ“Š Collection Progress</h3>
              <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px;">
                <div style="background: rgba(0, 0, 0, 0.3); border-radius: 8px; padding: 10px;">
                  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                    <span style="font-size: 12px; color: #ff9a9e;">ğŸ¾ Pets</span>
                    <span style="font-size: 11px; color: #cfe3ff;">${ownedPets}/${totalPets}</span>
                  </div>
                  <div style="background: rgba(0, 0, 0, 0.3); border-radius: 4px; height: 8px; overflow: hidden;">
                    <div style="background: linear-gradient(90deg, #ff9a9e, #fecfef); height: 100%; width: ${(ownedPets/totalPets)*100}%; transition: width 0.3s;"></div>
                  </div>
                </div>
                <div style="background: rgba(0, 0, 0, 0.3); border-radius: 8px; padding: 10px;">
                  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                    <span style="font-size: 12px; color: #ffd1ff;">âœ¨ Spirits</span>
                    <span style="font-size: 11px; color: #cfe3ff;">${ownedSpirits}/${totalSpirits}</span>
                  </div>
                  <div style="background: rgba(0, 0, 0, 0.3); border-radius: 4px; height: 8px; overflow: hidden;">
                    <div style="background: linear-gradient(90deg, #ffd1ff, #ffecd2); height: 100%; width: ${(ownedSpirits/totalSpirits)*100}%; transition: width 0.3s;"></div>
                  </div>
                </div>
                <div style="background: rgba(0, 0, 0, 0.3); border-radius: 8px; padding: 10px;">
                  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                    <span style="font-size: 12px; color: #00e5ff;">ğŸš— Vehicles</span>
                    <span style="font-size: 11px; color: #cfe3ff;">${ownedVehicles}/${totalVehicles}</span>
                  </div>
                  <div style="background: rgba(0, 0, 0, 0.3); border-radius: 4px; height: 8px; overflow: hidden;">
                    <div style="background: linear-gradient(90deg, #00e5ff, #7af8c8); height: 100%; width: ${(ownedVehicles/totalVehicles)*100}%; transition: width 0.3s;"></div>
                  </div>
                </div>
                <div style="background: rgba(0, 0, 0, 0.3); border-radius: 8px; padding: 10px;">
                  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                    <span style="font-size: 12px; color: #5ba3ff;">ğŸ¤– Robots</span>
                    <span style="font-size: 11px; color: #cfe3ff;">${ownedRobots}/${totalRobots}</span>
                  </div>
                  <div style="background: rgba(0, 0, 0, 0.3); border-radius: 4px; height: 8px; overflow: hidden;">
                    <div style="background: linear-gradient(90deg, #5ba3ff, #8a2be2); height: 100%; width: ${(ownedRobots/totalRobots)*100}%; transition: width 0.3s;"></div>
                  </div>
                </div>
              </div>
            </div>

            <!-- AI Recommendations -->
            ${recommendations.length > 0 ? `
              <div style="background: linear-gradient(135deg, rgba(167, 139, 250, 0.2), rgba(0, 229, 255, 0.2)); border: 2px solid rgba(167, 139, 250, 0.5); border-radius: 12px; padding: 16px; margin-bottom: 20px;">
                <h3 style="color: #a78bfa; font-size: 14px; margin-bottom: 12px;">ğŸ¤– AI Recommends:</h3>
                <div style="display: flex; gap: 12px; overflow-x: auto;">
                  ${recommendations.map(item => `
                    <div class="shop-recommendation-card" data-item-id="${item.id}" style="min-width: 140px; background: rgba(0, 0, 0, 0.4); border: 2px solid rgba(56, 239, 125, 0.6); border-radius: 8px; padding: 12px; cursor: pointer;">
                      <div style="font-size: 28px; text-align: center; margin-bottom: 8px;">${item.icon}</div>
                      <div style="font-size: 10px; color: #38ef7d; font-weight: 600; text-align: center; margin-bottom: 6px;">${item.name}</div>
                      <div style="font-size: 9px; color: rgba(207, 227, 255, 0.7); text-align: center; margin-bottom: 8px;">${item.reason}</div>
                      <button class="buy-btn" data-item-id="${item.id}" style="width: 100%; padding: 6px; background: linear-gradient(135deg, #38ef7d, #4fc3f7); border: 2px solid white; border-radius: 6px; color: white; font-weight: bold; font-size: 9px; cursor: pointer;">
                        ${this.calculatePrice(item)}g
                      </button>
                    </div>
                  `).join('')}
                </div>
              </div>
            ` : ''}

            <!-- Filter and Sort Controls -->
            <div style="display: flex; gap: 12px; margin-bottom: 16px; flex-wrap: wrap;">
              <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                <button class="shop-filter-btn ${shopFilter === 'all' ? 'active' : ''}" data-filter="all" style="padding: 8px 16px; background: ${shopFilter === 'all' ? 'linear-gradient(135deg, #38ef7d, #4fc3f7)' : 'rgba(0, 0, 0, 0.5)'}; border: 2px solid ${shopFilter === 'all' ? '#38ef7d' : 'rgba(79, 195, 247, 0.4)'}; border-radius: 6px; color: white; font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s;">All</button>
                <button class="shop-filter-btn ${shopFilter === 'weapon' ? 'active' : ''}" data-filter="weapon" style="padding: 8px 16px; background: ${shopFilter === 'weapon' ? 'linear-gradient(135deg, #ff6b6b, #ff8e8e)' : 'rgba(0, 0, 0, 0.5)'}; border: 2px solid ${shopFilter === 'weapon' ? '#ff6b6b' : 'rgba(79, 195, 247, 0.4)'}; border-radius: 6px; color: white; font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s;">âš”ï¸ Weapons</button>
                <button class="shop-filter-btn ${shopFilter === 'armor' ? 'active' : ''}" data-filter="armor" style="padding: 8px 16px; background: ${shopFilter === 'armor' ? 'linear-gradient(135deg, #4fc3f7, #00e5ff)' : 'rgba(0, 0, 0, 0.5)'}; border: 2px solid ${shopFilter === 'armor' ? '#4fc3f7' : 'rgba(79, 195, 247, 0.4)'}; border-radius: 6px; color: white; font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s;">ğŸ›¡ï¸ Armor</button>
                <button class="shop-filter-btn ${shopFilter === 'accessory' ? 'active' : ''}" data-filter="accessory" style="padding: 8px 16px; background: ${shopFilter === 'accessory' ? 'linear-gradient(135deg, #a78bfa, #c4b5fd)' : 'rgba(0, 0, 0, 0.5)'}; border: 2px solid ${shopFilter === 'accessory' ? '#a78bfa' : 'rgba(79, 195, 247, 0.4)'}; border-radius: 6px; color: white; font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s;">ğŸ’ Accessories</button>
                <button class="shop-filter-btn ${shopFilter === 'core' ? 'active' : ''}" data-filter="core" style="padding: 8px 16px; background: ${shopFilter === 'core' ? 'linear-gradient(135deg, #9a6bff, #8a2be2)' : 'rgba(0, 0, 0, 0.5)'}; border: 2px solid ${shopFilter === 'core' ? '#9a6bff' : 'rgba(79, 195, 247, 0.4)'}; border-radius: 6px; color: white; font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s;">ğŸ’  Cores</button>
                <button class="shop-filter-btn ${shopFilter === 'supernatural' ? 'active' : ''}" data-filter="supernatural" style="padding: 8px 16px; background: ${shopFilter === 'supernatural' ? 'linear-gradient(135deg, #a78bfa, #c4b5fd)' : 'rgba(0, 0, 0, 0.5)'}; border: 2px solid ${shopFilter === 'supernatural' ? '#a78bfa' : 'rgba(79, 195, 247, 0.4)'}; border-radius: 6px; color: white; font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s;">ğŸ”® Powers</button>
                <button class="shop-filter-btn ${shopFilter === 'consumable' ? 'active' : ''}" data-filter="consumable" style="padding: 8px 16px; background: ${shopFilter === 'consumable' ? 'linear-gradient(135deg, #38ef7d, #56f89a)' : 'rgba(0, 0, 0, 0.5)'}; border: 2px solid ${shopFilter === 'consumable' ? '#38ef7d' : 'rgba(79, 195, 247, 0.4)'}; border-radius: 6px; color: white; font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s;">ğŸ§ª Consumables</button>
                <button class="shop-filter-btn ${shopFilter === 'pet' ? 'active' : ''}" data-filter="pet" style="padding: 8px 16px; background: ${shopFilter === 'pet' ? 'linear-gradient(135deg, #ff9a9e, #fecfef)' : 'rgba(0, 0, 0, 0.5)'}; border: 2px solid ${shopFilter === 'pet' ? '#ff9a9e' : 'rgba(79, 195, 247, 0.4)'}; border-radius: 6px; color: white; font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s;">ğŸ¾ Pets</button>
                <button class="shop-filter-btn ${shopFilter === 'spirit' ? 'active' : ''}" data-filter="spirit" style="padding: 8px 16px; background: ${shopFilter === 'spirit' ? 'linear-gradient(135deg, #ffd1ff, #ffecd2)' : 'rgba(0, 0, 0, 0.5)'}; border: 2px solid ${shopFilter === 'spirit' ? '#ffd1ff' : 'rgba(79, 195, 247, 0.4)'}; border-radius: 6px; color: white; font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s;">âœ¨ Spirits</button>
                <button class="shop-filter-btn ${shopFilter === 'vehicle' ? 'active' : ''}" data-filter="vehicle" style="padding: 8px 16px; background: ${shopFilter === 'vehicle' ? 'linear-gradient(135deg, #00e5ff, #7af8c8)' : 'rgba(0, 0, 0, 0.5)'}; border: 2px solid ${shopFilter === 'vehicle' ? '#00e5ff' : 'rgba(79, 195, 247, 0.4)'}; border-radius: 6px; color: white; font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s;">ğŸš— Vehicles</button>
                <button class="shop-filter-btn ${shopFilter === 'robot' ? 'active' : ''}" data-filter="robot" style="padding: 8px 16px; background: ${shopFilter === 'robot' ? 'linear-gradient(135deg, #5ba3ff, #8a2be2)' : 'rgba(0, 0, 0, 0.5)'}; border: 2px solid ${shopFilter === 'robot' ? '#5ba3ff' : 'rgba(79, 195, 247, 0.4)'}; border-radius: 6px; color: white; font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s;">ğŸ¤– Robots</button>
                <button class="shop-filter-btn ${shopFilter === 'box' ? 'active' : ''}" data-filter="box" style="padding: 8px 16px; background: ${shopFilter === 'box' ? 'linear-gradient(135deg, #ffd700, #ffed4e)' : 'rgba(0, 0, 0, 0.5)'}; border: 2px solid ${shopFilter === 'box' ? '#ffd700' : 'rgba(79, 195, 247, 0.4)'}; border-radius: 6px; color: white; font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s;">ğŸ Boxes</button>
                <button class="shop-filter-btn ${shopFilter === 'essence' ? 'active' : ''}" data-filter="essence" style="padding: 8px 16px; background: ${shopFilter === 'essence' ? 'linear-gradient(135deg, #cd7fff, #9b59b6)' : 'rgba(0, 0, 0, 0.5)'}; border: 2px solid ${shopFilter === 'essence' ? '#cd7fff' : 'rgba(79, 195, 247, 0.4)'}; border-radius: 6px; color: white; font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s;">ğŸ’ Essence</button>
              </div>
              <select id="shopSortSelect" style="padding: 6px 12px; background: rgba(0, 0, 0, 0.5); border: 2px solid rgba(79, 195, 247, 0.4); border-radius: 6px; color: #4fc3f7; font-size: 11px;">
                <option value="price-low" ${shopSort === 'price-low' ? 'selected' : ''}>Price: Low to High</option>
                <option value="price-high" ${shopSort === 'price-high' ? 'selected' : ''}>Price: High to Low</option>
                <option value="power" ${shopSort === 'power' ? 'selected' : ''}>Sort: Power</option>
                <option value="name" ${shopSort === 'name' ? 'selected' : ''}>Sort: Name</option>
              </select>
              <button id="shopHideOwnedBtn" style="padding: 8px 16px; background: ${hideOwned ? 'linear-gradient(135deg, #ff6b6b, #ff8e8e)' : 'rgba(0, 0, 0, 0.5)'}; border: 2px solid ${hideOwned ? '#ff6b6b' : 'rgba(79, 195, 247, 0.4)'}; border-radius: 6px; color: white; font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.2s;">
                ${hideOwned ? 'ğŸ‘ï¸ Show All' : 'ğŸš« Hide Owned'}
              </button>
            </div>

            <!-- Shop Items Grid -->
            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 12px;">
              ${items.map(item => {
                const price = this.calculatePrice(item);
                const canAfford = window.gameState.gold >= price;
                const isOwned = this.isItemOwned(item);
                const isLocked = !this.isItemUnlocked(item);
                const canEquip = this.canEquipItem(item);
                
                // Check if supernatural power is already learned
                let isLearned = false;
                if (item.category === 'supernatural') {
                  isLearned = !!window.gameState.inventory?.abilities?.find(a => a.id === item.id);
                }
                
                return `
                  <div class="shop-item-card" data-item-id="${item.id}" style="position: relative; background: rgba(0, 0, 0, 0.4); border: 2px solid rgba(79, 195, 247, 0.4); border-radius: 12px; padding: 16px; cursor: pointer; transition: all 0.2s ease; ${this.getRarityStyle(item.rarity)} ${isOwned || isLearned ? 'opacity: 0.6; filter: grayscale(50%);' : ''}">
                    ${isOwned ? '<div style="position: absolute; top: 8px; right: 8px; background: rgba(56, 239, 125, 0.9); color: white; padding: 4px 8px; border-radius: 6px; font-size: 9px; font-weight: bold; z-index: 10;">âœ“ OWNED</div>' : ''}
                    ${isLearned ? '<div style="position: absolute; top: 8px; right: 8px; background: rgba(56, 239, 125, 0.9); color: white; padding: 4px 8px; border-radius: 6px; font-size: 9px; font-weight: bold; z-index: 10;">âœ“ OWNED</div>' : ''}
                    ${isLocked ? '<div style="position: absolute; top: 8px; left: 8px; background: rgba(255, 107, 107, 0.9); color: white; padding: 4px 8px; border-radius: 6px; font-size: 9px; font-weight: bold; z-index: 10;">ğŸ”’ LOCKED</div>' : ''}
                    ${!canEquip && !isOwned && !isLearned ? '<div style="position: absolute; top: 8px; left: 8px; background: rgba(255, 193, 7, 0.9); color: black; padding: 4px 8px; border-radius: 6px; font-size: 9px; font-weight: bold; z-index: 10;">âš ï¸ LVL ${item.levelReq || 1}</div>' : ''}
                    <div style="font-size: 36px; text-align: center; margin-bottom: 10px; ${this.getIconAnimation(item.category)}">${item.icon}</div>
                    <div style="font-size: 12px; color: #cfe3ff; font-weight: 600; text-align: center; margin-bottom: 6px;">${item.name}</div>
                    <div style="font-size: 9px; color: #ffd77a; text-align: center; margin-bottom: 10px; text-transform: uppercase;">${item.rarity}</div>
                    <div style="display: flex; flex-wrap: wrap; gap: 4px; justify-content: center; margin-bottom: 12px;">
                      ${item.attack ? `<span class="stat-badge" style="background: rgba(255, 107, 107, 0.2); color: #ff6b6b; font-size: 9px;">ATK +${item.attack}</span>` : ''}
                      ${item.defense ? `<span class="stat-badge" style="background: rgba(79, 195, 247, 0.2); color: #4fc3f7; font-size: 9px;">DEF +${item.defense}</span>` : ''}
                      ${item.hp ? `<span class="stat-badge" style="background: rgba(56, 239, 125, 0.2); color: #38ef7d; font-size: 9px;">HP +${item.hp}</span>` : ''}
                    </div>
                    <button class="buy-btn" data-item-id="${item.id}" ${!canAfford || isOwned || isLearned ? 'disabled' : ''} style="width: 100%; padding: 10px; background: ${canAfford && !isOwned && !isLearned ? 'linear-gradient(135deg, #38ef7d, #4fc3f7)' : 'rgba(100, 100, 100, 0.5)'}; border: 2px solid white; border-radius: 8px; color: white; font-weight: bold; font-size: 12px; cursor: ${canAfford && !isOwned && !isLearned ? 'pointer' : 'not-allowed'};">
                      ${isOwned ? 'âœ“ OWNED' : isLearned ? 'âœ“ Owned' : `ğŸ’° ${price}g`}
                    </button>
                  </div>
                `;
              }).join('')}
            </div>
          `;
          
          // Attach filter listeners
          pane.querySelectorAll('.shop-filter-btn').forEach(btn => {
            btn.addEventListener('click', () => {
              this.state.shopFilter = btn.dataset.filter;
              this.renderShopTab();
            });
          });
          
          // Attach sort listener
          const sortSelect = document.getElementById('shopSortSelect');
          if (sortSelect) {
            sortSelect.addEventListener('change', (e) => {
              this.state.shopSort = e.target.value;
              this.renderShopTab();
            });
          }
          
          // Attach hide owned toggle listener
          const hideOwnedBtn = document.getElementById('shopHideOwnedBtn');
          if (hideOwnedBtn) {
            hideOwnedBtn.addEventListener('click', () => {
              this.state.shopHideOwned = !this.state.shopHideOwned;
              this.renderShopTab();
            });
          }
          
          // Attach buy buttons
          pane.querySelectorAll('.buy-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
              e.stopPropagation();
              const itemId = btn.dataset.itemId;
              const item = shop.inventory.find(i => i.id === itemId);
              if (item) {
                this.buyShopItem(item);
              }
            });
          });
        },

        updateShopPrices() {
          const shop = window.gameState.shop;
          const now = Date.now();
          const daysPassed = Math.floor((now - shop.lastUpdate) / (1000 * 60 * 60 * 24));
          
          if (daysPassed >= 1) {
            // Update price fluctuation daily
            shop.priceFluctuation = 0.8 + Math.random() * 0.4; // 80% to 120%
            shop.lastUpdate = now;
          }
        },

        // â•â•â• SOLO LEVELING ECONOMY: Ranked Cost Formula â•â•â•
        // Cost = (Base * (Level * 2)) + Rarity_Multiplier
        getRankedCost(item) {
          const rarity = (item.rarity || 'common').toLowerCase();
          const level = item.levelReq || item.level || 1;
          const baseCost = 500 * (level * 2);
          
          const rarityMultiplier = {
            common: 50000,
            uncommon: 250000,
            rare: 1000000,
            epic: 5000000,
            legendary: 10000000
          };
          
          return baseCost + (rarityMultiplier[rarity] || 50000);
        },

        calculatePrice(item) {
          // Use Solo Leveling ranked cost formula
          let finalPrice = this.getRankedCost(item);
          
          // Apply shop price fluctuation if available
          const fluctuation = window.gameState.shop?.priceFluctuation || 1.0;
          finalPrice *= fluctuation;
          
          // â•â•â• TALENT DISCOUNT â•â•â•
          const merchantTalent = window.gameState.talents?.tree?.find(t => t.id === 'economy_2');
          if (merchantTalent && merchantTalent.currentLevel > 0) {
            const discount = 0.15 * merchantTalent.currentLevel;
            finalPrice *= (1 - discount);
          }
          
          // â•â•â• EQUIPMENT QUALITY BONUS â•â•â•
          // Wearing high-quality gear gives merchant respect
          const equipped = window.gameState.equipped;
          const epicCount = Object.values(equipped).filter(i => i && i.rarity === 'epic').length;
          const legendaryCount = Object.values(equipped).filter(i => i && i.rarity === 'legendary').length;
          
          if (legendaryCount > 0) {
            finalPrice *= 0.9; // 10% discount for legendary gear
          } else if (epicCount >= 3) {
            finalPrice *= 0.95; // 5% discount for 3+ epic items
          }
          
          return Math.floor(finalPrice);
        },

        getShopRecommendations() {
          const stats = window.gameState.currentStats;
          const equipped = window.gameState.equipped;
          const shop = window.gameState.shop.inventory;
          const recommendations = [];
          
          // Recommend weapon if low attack
          if (stats.attack < 50 && (!equipped.weapon || equipped.weapon.attack < 50)) {
            const bestWeapon = shop.find(i => i.category === 'weapon' && i.attack >= 50);
            if (bestWeapon) {
              recommendations.push({ ...bestWeapon, reason: '+ATK needed' });
            }
          }
          
          // Recommend armor if low HP
          if (stats.hp < 200 && (!equipped.chest || equipped.chest.hp < 80)) {
            const bestArmor = shop.find(i => i.slot === 'chest' && i.hp >= 80);
            if (bestArmor) {
              recommendations.push({ ...bestArmor, reason: '+HP needed' });
            }
          }
          
          // Recommend legendary if player has gold
          if (window.gameState.gold > 15000) {
            const legendary = shop.find(i => i.rarity === 'legendary');
            if (legendary && !recommendations.find(r => r.id === legendary.id)) {
              recommendations.push({ ...legendary, reason: 'Best in shop!' });
            }
          }
          
          return recommendations.slice(0, 3); // Max 3 recommendations
        },

        buyShopItem(item) {
          const price = this.getRankedCost(item);
          
          // Check if player has enough gold
          if (window.gameState.gold < price) {
            this.showToast('ğŸ’° Not enough gold!');
            return;
          }
          
          // Confirmation for expensive items
          if (price > 1000) {
            this.showPurchaseConfirmation(item, price);
            return;
          }
          
          this.completePurchase(item, price);
        },

        showPurchaseConfirmation(item, price) {
          this.showConfirmDialog(
            `Purchase ${item.icon} ${item.name} for ${price}g?`,
            () => this.completePurchase(item, price),
            () => this.showToast('âŒ Purchase cancelled')
          );
        },

        completePurchase(item, price) {
          // Duplicate Purchase Prevention
          // Check if already owned (for unique items like pets, spirits, vehicles, robots)
          if (item.type === 'pet') {
            const existing = window.gameState.inventory.pets?.find(p => p.name === item.name);
            if (existing) {
              this.showToast('âš ï¸ You already own this pet!');
              return;
            }
          } else if (item.type === 'spirit') {
            const existing = window.gameState.inventory.spirits?.find(s => s.name === item.name);
            if (existing) {
              this.showToast('âš ï¸ You already own this spirit!');
              return;
            }
          } else if (item.type === 'vehicle') {
            const existing = window.gameState.inventory.vehicles?.find(v => v.name === item.name);
            if (existing) {
              this.showToast('âš ï¸ You already own this vehicle!');
              return;
            }
          } else if (item.type === 'robot') {
            const existing = window.gameState.inventory.robots?.find(r => r.name === item.name);
            if (existing) {
              this.showToast('âš ï¸ You already own this robot!');
              return;
            }
          }
          
          // Deduct gold
          window.gameState.gold -= price;
          
          // Add item to inventory
          if (item.category === 'weapon' || item.category === 'armor' || item.category === 'accessory') {
            const newItem = { ...item, id: 'owned_' + Date.now() + '_' + Math.random() };
            delete newItem.basePrice;
            this.normalizeGearItem(newItem);
            window.gameState.inventory.gear.push(newItem);
          } else if (item.category === 'core') {
            // Cores go to gear inventory (special handling)
            const newItem = { ...item, id: 'owned_' + Date.now() + '_' + Math.random() };
            delete newItem.basePrice;
            // Keep all core properties (passiveEffects, weaponSkill, element, etc.)
            this.normalizeGearItem(newItem);
            window.gameState.inventory.gear.push(newItem);
            
            // Show special message for cores
            this.showToast(`âœ… Purchased ${item.icon} ${item.name}! Check Gear Tab â†’ Cores Filter`);
          } else if (item.category === 'supernatural') {
            // Supernatural powers - add to inventory (NOT auto-equipped)
            if (!window.gameState.inventory.powers) {
              window.gameState.inventory.powers = [];
            }

            // Check if already owned
            const existing = window.gameState.inventory.powers.find(p => p.id === item.id);
            if (existing) {
              this.showToast('âš ï¸ You already own this power!');
              window.gameState.gold += price; // Refund
              return;
            }

            // Add power to inventory (immediately usable - no activation cost)
            const powerData = { 
              ...item,
              level: 1,         // Start at level 1
              equipped: false,  // Can be equipped for free
              active: false     // Activates when equipped
            };
            delete powerData.basePrice;
            window.gameState.inventory.powers.push(powerData);

            // Show special message for powers
            this.showToast(`âœ… Purchased ${item.icon} ${item.name}! Equip it in Supernatural Tab`);
          } else if (item.type === 'pet') {
            // Individual pet purchase
            if (!window.gameState.inventory.pets) window.gameState.inventory.pets = [];
            const newItem = { ...item, id: 'owned_' + Date.now() + '_' + Math.random() };
            delete newItem.basePrice;
            window.gameState.inventory.pets.push(newItem);
            this.showToast(`âœ… Purchased ${item.icon} ${item.name}! Check Pet Tab`);
          } else if (item.type === 'spirit') {
            // Individual spirit purchase
            if (!window.gameState.inventory.spirits) window.gameState.inventory.spirits = [];
            const newItem = { ...item, id: 'owned_' + Date.now() + '_' + Math.random() };
            delete newItem.basePrice;
            window.gameState.inventory.spirits.push(newItem);
            this.showToast(`âœ… Purchased ${item.icon} ${item.name}! Check Spirit Tab`);
          } else if (item.type === 'vehicle') {
            // Individual vehicle purchase
            if (!window.gameState.inventory.vehicles) window.gameState.inventory.vehicles = [];
            const newItem = { ...item, id: 'owned_' + Date.now() + '_' + Math.random() };
            delete newItem.basePrice;
            window.gameState.inventory.vehicles.push(newItem);
            this.showToast(`âœ… Purchased ${item.icon} ${item.name}! Check Vehicle Tab`);
          } else if (item.type === 'robot') {
            // Individual robot purchase
            if (!window.gameState.inventory.robots) window.gameState.inventory.robots = [];
            const newItem = { ...item, id: 'owned_' + Date.now() + '_' + Math.random() };
            delete newItem.basePrice;
            window.gameState.inventory.robots.push(newItem);
            this.showToast(`âœ… Purchased ${item.icon} ${item.name}! Check Robot Tab`);
          } else if (item.type === 'box' && item.contains && Array.isArray(item.contains)) {
            // Starter Set Boxes - check if all items already owned
            const ownedCount = item.contains.filter(containedItem => {
              const itemType = containedItem.type || 'item';
              if (itemType === 'pet') {
                return window.gameState.inventory.pets?.some(p => p.name === containedItem.name);
              } else if (itemType === 'spirit') {
                return window.gameState.inventory.spirits?.some(s => s.name === containedItem.name);
              } else if (itemType === 'vehicle') {
                return window.gameState.inventory.vehicles?.some(v => v.name === containedItem.name);
              } else if (itemType === 'robot') {
                return window.gameState.inventory.robots?.some(r => r.name === containedItem.name);
              }
              return false;
            }).length;
            
            if (ownedCount === item.contains.length) {
              this.showToast('âš ï¸ You already own everything in this box!');
              window.gameState.gold += price; // Refund
              return;
            }
            
            // Automatically open and add all contained items
            let itemsAdded = 0;
            const addedItems = [];
            
            item.contains.forEach(containedItem => {
              const itemType = containedItem.type || 'item';
              
              // Check if already owned before adding
              let alreadyOwned = false;
              if (itemType === 'pet') {
                alreadyOwned = window.gameState.inventory.pets?.some(p => p.name === containedItem.name);
              } else if (itemType === 'spirit') {
                alreadyOwned = window.gameState.inventory.spirits?.some(s => s.name === containedItem.name);
              } else if (itemType === 'vehicle') {
                alreadyOwned = window.gameState.inventory.vehicles?.some(v => v.name === containedItem.name);
              } else if (itemType === 'robot') {
                alreadyOwned = window.gameState.inventory.robots?.some(r => r.name === containedItem.name);
              }
              
              if (alreadyOwned) {
                return; // Skip this item
              }
              
              const newItem = { ...containedItem };
              delete newItem.type;
              delete newItem.basePrice;
              newItem.id = 'owned_' + Date.now() + '_' + Math.random();
              
              // Add to appropriate inventory
              if (itemType === 'pet') {
                if (!window.gameState.inventory.pets) window.gameState.inventory.pets = [];
                window.gameState.inventory.pets.push(newItem);
                itemsAdded++;
                addedItems.push(`ğŸ¾ ${newItem.name}`);
              } else if (itemType === 'spirit') {
                if (!window.gameState.inventory.spirits) window.gameState.inventory.spirits = [];
                window.gameState.inventory.spirits.push(newItem);
                itemsAdded++;
                addedItems.push(`âœ¨ ${newItem.name}`);
              } else if (itemType === 'vehicle') {
                if (!window.gameState.inventory.vehicles) window.gameState.inventory.vehicles = [];
                window.gameState.inventory.vehicles.push(newItem);
                itemsAdded++;
                addedItems.push(`ğŸš— ${newItem.name}`);
              } else if (itemType === 'robot') {
                if (!window.gameState.inventory.robots) window.gameState.inventory.robots = [];
                window.gameState.inventory.robots.push(newItem);
                itemsAdded++;
                addedItems.push(`ğŸ¤– ${newItem.name}`);
              } else if (itemType === 'gear') {
                if (!window.gameState.inventory.gear) window.gameState.inventory.gear = [];
                this.normalizeGearItem(newItem);
                window.gameState.inventory.gear.push(newItem);
                itemsAdded++;
                addedItems.push(`âš”ï¸ ${newItem.name}`);
              }
            });
            
            // Show special message for boxes
            this.showToast(`ğŸ Opened ${item.icon} ${item.name}! Received ${itemsAdded} items!`);
            this.addSystemMessage(`ğŸ“¦ BOX OPENED: ${item.name} - ${itemsAdded} items added to inventory!`, 'reward');
            
            // Visual effects
            this.createParticleEffect('open', window.innerWidth / 2, window.innerHeight / 2);
            for (let i = 0; i < 3; i++) {
              setTimeout(() => {
                this.createParticleEffect('levelup', 
                  window.innerWidth / 2 + (Math.random() - 0.5) * 200, 
                  window.innerHeight / 2 + (Math.random() - 0.5) * 200);
              }, i * 200);
            }
          } else {
            // Consumables/containers (regular)
            const existing = window.gameState.inventory.items.find(i => i.name === item.name);
            if (existing) {
              existing.quantity = (existing.quantity || 1) + 1;
            } else {
              const newItem = { ...item, id: 'owned_' + Date.now() };
              delete newItem.basePrice;
              window.gameState.inventory.items.push(newItem);
            }
          }
          
          // Log transaction
          window.gameState.shop.transactionHistory.unshift({
            type: 'buy',
            item: item.name,
            price: price,
            timestamp: Date.now()
          });
          
          // Visual feedback
          if (item.category !== 'core') {
            this.showToast(`âœ… Purchased ${item.icon} ${item.name} for ${price}g!`);
          }
          this.createParticleEffect('open', window.innerWidth / 2, window.innerHeight / 2);
          this.playCandySfx('shop-buy');
          
          // Update displays
          this.syncAllSystems();
          this.renderShopTab();
          
          // Check for achievements after purchase
          checkAndUnlockAchievements();
        },

        // â•â•â• TALENT SYSTEM â•â•â•
        renderTalentsTab() {
          const pane = document.getElementById('bagContentPane');
          const talentData = window.gameState.talents;
          
          pane.innerHTML = `
            <div style="margin-bottom: 20px;">
              <h2 style="font-size: 22px; color: #a78bfa; margin-bottom: 10px;">â­ Talent Tree</h2>
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <p style="color: rgba(207, 227, 255, 0.7); font-size: 13px;">
                  Unlock powerful talents to enhance your character!
                </p>
                <div style="display: flex; gap: 12px;">
                  <div style="padding: 8px 16px; background: rgba(167, 139, 250, 0.2); border: 2px solid rgba(167, 139, 250, 0.5); border-radius: 8px;">
                    <span style="color: #a78bfa; font-weight: bold;">â­ Talent Points: ${talentData?.points || 0}</span>
                  </div>
                  <button id="resetTalentsBtn" style="padding: 8px 16px; background: linear-gradient(135deg, #ff6b35, #ff3b3b); border: 2px solid white; border-radius: 8px; color: white; font-weight: bold; font-size: 11px; cursor: pointer;">
                    ğŸ”„ Reset (500g)
                  </button>
                </div>
              </div>
            </div>

            <!-- Talent Tree Canvas -->
            <div style="background: rgba(0, 0, 0, 0.4); border: 2px solid rgba(167, 139, 250, 0.4); border-radius: 12px; padding: 20px; margin-bottom: 20px;">
              <canvas id="talentTreeCanvas" width="700" height="400" style="display: block; margin: 0 auto; cursor: pointer;"></canvas>
            </div>

            <!-- Active Synergies -->
            <div style="background: rgba(0, 0, 0, 0.3); border: 2px solid rgba(255, 215, 122, 0.4); border-radius: 12px; padding: 16px;">
              <h3 style="color: #ffd77a; font-size: 14px; margin-bottom: 12px;">âœ¨ Active Synergies</h3>
              <div id="synergiesDisplay" style="display: flex; flex-direction: column; gap: 8px;">
                ${this.getActiveSynergies().map(syn => `
                  <div style="padding: 12px; background: rgba(255, 215, 122, 0.1); border: 1px solid rgba(255, 215, 122, 0.3); border-radius: 8px;">
                    <div style="font-weight: bold; color: #ffd77a; margin-bottom: 4px;">${syn.name}</div>
                    <div style="font-size: 11px; color: rgba(207, 227, 255, 0.8);">${syn.bonus}</div>
                  </div>
                `).join('')}
                ${this.getActiveSynergies().length === 0 ? '<div style="text-align: center; padding: 20px; color: rgba(207, 227, 255, 0.5);">No synergies active. Unlock talents to discover powerful combinations!</div>' : ''}
              </div>
            </div>
          `;
          
          // Render talent tree on canvas
          setTimeout(() => this.renderTalentTreeCanvas(), 100);
          
          // Attach reset button
          const resetBtn = document.getElementById('resetTalentsBtn');
          if (resetBtn) {
            resetBtn.addEventListener('click', () => this.resetTalents());
          }
        },

        renderTalentTreeCanvas() {
          const canvas = document.getElementById('talentTreeCanvas');
          if (!canvas) return;
          
          const ctx = canvas.getContext('2d');
          const talents = window.gameState.talents.tree;
          
          // Clear canvas
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          
          // Draw connections first
          talents.forEach(talent => {
            if (talent.prereq) {
              const prereqTalent = talents.find(t => t.id === talent.prereq);
              if (prereqTalent) {
                ctx.beginPath();
                ctx.moveTo(prereqTalent.x, prereqTalent.y);
                ctx.lineTo(talent.x, talent.y);
                ctx.strokeStyle = talent.currentLevel > 0 ? 'rgba(91, 163, 255, 0.55)' : 'rgba(60, 70, 90, 0.35)';
                ctx.lineWidth = 3;
                ctx.stroke();
              }
            }
          });
          
          // Draw talent nodes
          talents.forEach(talent => {
            const isUnlocked = talent.currentLevel > 0;
            const isMaxed = talent.currentLevel >= talent.maxLevel;
            const canUnlock = this.canUnlockTalent(talent);
            
            // Node circle
            ctx.beginPath();
            ctx.arc(talent.x, talent.y, 30, 0, Math.PI * 2);
            
            if (isMaxed) {
              ctx.fillStyle = 'rgba(147, 197, 253, 0.25)';
              ctx.strokeStyle = 'rgba(96, 165, 250, 0.95)';
            } else if (isUnlocked) {
              ctx.fillStyle = 'rgba(91, 163, 255, 0.18)';
              ctx.strokeStyle = 'rgba(91, 163, 255, 0.85)';
            } else if (canUnlock) {
              ctx.fillStyle = 'rgba(126, 212, 255, 0.12)';
              ctx.strokeStyle = 'rgba(126, 212, 255, 0.6)';
            } else {
              ctx.fillStyle = 'rgba(50, 50, 50, 0.3)';
              ctx.strokeStyle = 'rgba(100, 100, 100, 0.4)';
            }
            
            ctx.lineWidth = 3;
            ctx.fill();
            ctx.stroke();
            
            // Icon
            ctx.font = '24px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillStyle = isUnlocked ? '#fff' : '#888';
            ctx.fillText(talent.icon, talent.x, talent.y);
            
            // Level indicator
            if (talent.currentLevel > 0) {
              ctx.font = 'bold 10px Arial';
              ctx.fillStyle = '#ffd77a';
              ctx.fillText(`${talent.currentLevel}/${talent.maxLevel}`, talent.x, talent.y + 20);
            }
          });
          
          // Add click handler to canvas
          let glowTimer = null;
          canvas.onclick = (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // Check if clicked on a talent
            talents.forEach(talent => {
              const dist = Math.sqrt((x - talent.x) ** 2 + (y - talent.y) ** 2);
              if (dist < 30) {
                this.handleTalentClick(talent);
                canvas.style.transition = 'box-shadow 0.35s ease';
                canvas.style.boxShadow = '0 0 25px rgba(91, 163, 255, 0.75)';
                if (glowTimer) clearTimeout(glowTimer);
                glowTimer = setTimeout(() => {
                  canvas.style.boxShadow = 'none';
                }, 350);
              }
            });
          };
          
          // Add hover tooltip
          canvas.onmousemove = (e) => {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            let hoveredTalent = null;
            talents.forEach(talent => {
              const dist = Math.sqrt((x - talent.x) ** 2 + (y - talent.y) ** 2);
              if (dist < 30) {
                hoveredTalent = talent;
              }
            });
            
            if (hoveredTalent) {
              canvas.title = `${hoveredTalent.name}\n${hoveredTalent.effect}\nLevel: ${hoveredTalent.currentLevel}/${hoveredTalent.maxLevel}`;
            } else {
              canvas.title = '';
            }
          };
        },

        canUnlockTalent(talent) {
          if (window.gameState.talents.points <= 0) return false;
          if (talent.currentLevel >= talent.maxLevel) return false;
          
          if (talent.prereq) {
            const prereqTalent = window.gameState.talents.tree.find(t => t.id === talent.prereq);
            if (!prereqTalent || prereqTalent.currentLevel === 0) return false;
          }
          
          return true;
        },

        handleTalentClick(talent) {
          if (!talent) return;
          if (this.canUnlockTalent(talent)) {
            talent.currentLevel += 1;
            window.gameState.talents.points -= 1;
            const allocated = window.gameState.talents.allocated || (window.gameState.talents.allocated = []);
            if (!allocated.includes(talent.id)) {
              allocated.push(talent.id);
            }
            this.showToast(`â­ Unlocked ${talent.name}!`);
            // Trigger celebratory particle burst so players immediately notice the unlock
            this.createParticleEffect?.('levelup', window.innerWidth / 2, window.innerHeight / 2);
            this.applyTalentEffects();
            this.renderTalentsTab();
          } else if (talent.currentLevel >= talent.maxLevel) {
            this.showToast('âœ“ Talent maxed out!');
          } else if (window.gameState.talents.points <= 0) {
            this.showToast('âŒ No talent points available!');
          } else {
            this.showToast('ğŸ”’ Unlock prerequisite talent first!');
          }
        },

        resetTalents() {
          const resetCost = 500;
          
          if (window.gameState.gold < resetCost) {
            this.showToast('ğŸ’° Need 500g to reset talents!');
            return;
          }
          
          this.showConfirmDialog(
            `Reset all talents for ${resetCost}g?`,
            () => {
              window.gameState.gold -= resetCost;
              
              // Reset all talents
              window.gameState.talents.tree.forEach(talent => {
                window.gameState.talents.points += talent.currentLevel;
                talent.currentLevel = 0;
              });
              window.gameState.talents.allocated = [];
              
              this.showToast(`ğŸ”„ Talents reset! +${window.gameState.talents.points} points`);
              this.applyTalentEffects();
              this.renderTalentsTab();
            }
          );
        },

        getActiveSynergies() {
          const synergies = window.gameState.talents.synergies;
          const active = [];
          
          synergies.forEach(syn => {
            const allUnlocked = syn.talents.every(talentId => {
              const talent = window.gameState.talents.tree.find(t => t.id === talentId);
              return talent && talent.currentLevel === talent.maxLevel;
            });
            
            if (allUnlocked) {
              active.push(syn);
            }
          });
          
          return active;
        },

        applyTalentEffects() {
          // Recalculate stats with talent bonuses
          this.updateStats();
          
          // Additional talent effects can be applied here
          // For now, just update the stats display
        },

        processAICommand(command) {
          const cmd = command.toLowerCase().trim();
          const kb = window.AIKnowledgeBase;
          
          // Add to conversation context
          kb.conversationContext.push({ role: 'user', message: command, timestamp: Date.now() });
          if (kb.conversationContext.length > 10) kb.conversationContext.shift();
          
          this.logAIAction(`Command: ${command}`, 'command');
          
          // â•â•â• CONVERSATIONAL AI â•â•â•
          // Greetings
          if (kb.greetings.patterns.some(p => cmd.includes(p))) {
            const response = kb.greetings.responses[Math.floor(Math.random() * kb.greetings.responses.length)];
            this.addSystemMessage(response, 'info');
            kb.conversationContext.push({ role: 'ai', message: response });
            return;
          }
          
          // Farewells
          if (kb.farewells.patterns.some(p => cmd.includes(p))) {
            const response = kb.farewells.responses[Math.floor(Math.random() * kb.farewells.responses.length)];
            this.addSystemMessage(response, 'info');
            kb.conversationContext.push({ role: 'ai', message: response });
            return;
          }
          
          // Gratitude
          if (kb.gratitude.patterns.some(p => cmd.includes(p))) {
            const response = kb.gratitude.responses[Math.floor(Math.random() * kb.gratitude.responses.length)];
            this.addSystemMessage(response, 'success');
            kb.conversationContext.push({ role: 'ai', message: response });
            return;
          }
          
          // Status check
          if (kb.status.patterns.some(p => cmd.includes(p))) {
            const stats = window.gameState.currentStats;
            const itemCount = (window.gameState.inventory.gear || []).length + (window.gameState.inventory.items || []).length;
            let response = kb.status.responses[Math.floor(Math.random() * kb.status.responses.length)];
            response = response.replace('{hp}', stats.hp).replace('{atk}', stats.attack).replace('{def}', stats.defense);
            response = response.replace('{itemCount}', itemCount).replace('{gold}', window.gameState.gold.toLocaleString());
            this.addSystemMessage(response, 'info');
            kb.conversationContext.push({ role: 'ai', message: response });
            return;
          }
          
          // â•â•â• NATURAL LANGUAGE QUERIES â•â•â•
          // Need weapon/better weapon
          if (cmd.includes('need weapon') || cmd.includes('better weapon') || cmd.includes('weapon upgrade')) {
            kb.lastTopic = 'weapon';
            const currentWeapon = window.gameState.equipped.weapon;
            const shopWeapon = window.gameState.shop.inventory.find(i => i.category === 'weapon' && i.attack > (currentWeapon?.attack || 0));
            
            if (shopWeapon) {
              this.addSystemMessage(`ğŸ—¡ï¸ I recommend ${shopWeapon.icon} ${shopWeapon.name} (+${shopWeapon.attack} ATK) for ${this.calculatePrice(shopWeapon)}g`, 'reward');
              this.addSystemMessage(`Tip: ${kb.tips.equipment}`, 'info');
            } else {
              this.addSystemMessage(`âš”ï¸ You have the best weapon available! Current: ${currentWeapon?.name || 'None'}`, 'info');
            }
            return;
          }
          
          // Need gold/farming
          if (cmd.includes('need gold') || cmd.includes('farming gold') || cmd.includes('how to get gold')) {
            kb.lastTopic = 'gold';
            this.addSystemMessage(`ğŸ’° GOLD FARMING GUIDE:`, 'reward');
            this.addSystemMessage(kb.strategies.goldFarm, 'info');
            this.addSystemMessage(`Current gold: ${window.gameState.gold.toLocaleString()}g`, 'info');
            return;
          }
          
          // Build advice/optimization
          if (cmd.includes('optimize') || cmd.includes('build advice') || cmd.includes('what should i do') || cmd.includes('help me')) {
            kb.lastTopic = 'build';
            const stats = window.gameState.currentStats;
            
            this.addSystemMessage(`ğŸ§  AI BUILD ANALYSIS:`, 'reward');
            
            // Analyze stats
            if (stats.attack > stats.defense * 2) {
              this.addSystemMessage(`You're a glass cannon! (ATK ${stats.attack}, DEF ${stats.defense})`, 'info');
              this.addSystemMessage(`Recommendation: Invest in Defense talents or buy Titan Plate`, 'info');
            } else if (stats.defense > stats.attack * 2) {
              this.addSystemMessage(`You're a tank! (DEF ${stats.defense}, ATK ${stats.attack})`, 'info');
              this.addSystemMessage(`Recommendation: Add some ATK gear to speed up combat`, 'info');
            } else {
              this.addSystemMessage(`Balanced build detected! (ATK ${stats.attack}, DEF ${stats.defense})`, 'success');
              this.addSystemMessage(`Good job! Consider specializing for end-game content`, 'info');
            }
            
            return;
          }
          
          // â•â•â• AUTOMATION COMMANDS â•â•â•
          if (cmd === 'auto equip' || cmd === 'equip best') {
            this.autoEquip();
            this.logAIAction('Auto-equipped best gear', 'success');
            return;
          }
          
          if (cmd === 'auto upgrade' || cmd === 'upgrade all') {
            this.autoUpgrade();
            this.logAIAction('Auto-upgraded items', 'success');
            return;
          }
          
          if (cmd === 'auto fuse' || cmd === 'fuse all') {
            this.autoFuse();
            this.logAIAction('Auto-fused items', 'success');
            return;
          }
          
          if (cmd === 'auto sell' || cmd === 'sell junk') {
            this.autoSell();
            this.logAIAction('Auto-sold junk items', 'success');
            return;
          }
          
          if (cmd === 'open all' || cmd === 'open containers') {
            this.openAll();
            this.logAIAction('Opened all containers', 'success');
            return;
          }
          
          if (cmd === 'all auto' || cmd === 'do everything') {
            this.openAll();
            this.autoEquip();
            this.autoUpgrade();
            this.autoFuse();
            this.logAIAction('Executed all automation', 'success');
            return;
          }
          
          // â•â•â• TTS CONTROLS â•â•â•
          if (cmd === 'voice on' || cmd === 'enable voice' || cmd === 'speak') {
            window.gameState.textToSpeech.enabled = true;
            this.addSystemMessage('ğŸ”Š Voice enabled!', 'success');
            this.speak('Voice enabled. I can now speak to you!');
            return;
          }
          
          if (cmd === 'voice off' || cmd === 'disable voice' || cmd === 'mute') {
            window.gameState.textToSpeech.enabled = false;
            this.stopSpeaking();
            this.addSystemMessage('ğŸ”‡ Voice disabled', 'info');
            return;
          }
          
          if (cmd === 'stop speaking' || cmd === 'shut up' || cmd === 'quiet') {
            this.stopSpeaking();
            return;
          }
          
          // â•â•â• NAVIGATION â•â•â•
          const navMap = {
            'gear': 'gear', 'equipment': 'gear',
            'inventory': 'items', 'items': 'items',
            'shop': 'shop', 'store': 'shop',
            'talents': 'talents', 'skills': 'talents',
            'alchemy': 'alchemy', 'craft': 'alchemy',
            'map': 'map', 'world': 'map',
            'quests': 'quests', 'missions': 'quests'
          };
          
          for (const [keyword, tab] of Object.entries(navMap)) {
            if (cmd === keyword || cmd === `go to ${keyword}` || cmd === `show ${keyword}`) {
              this.state.activeTab = tab;
              this.renderTab(tab);
              this.logAIAction(`Navigated to ${tab} tab`, 'info');
              return;
            }
          }
          
          // â•â•â• INFORMATION â•â•â•
          if (cmd === 'stats' || cmd === 'status' || cmd === 'my stats') {
            const stats = window.gameState.currentStats;
            this.addSystemMessage(`ğŸ“Š HP: ${stats.hp} | ATK: ${stats.attack} | DEF: ${stats.defense}`, 'info');
            this.addSystemMessage(`ğŸ’° Gold: ${window.gameState.gold.toLocaleString()}g | ğŸ’ Gems: ${window.gameState.gems}`, 'info');
            return;
          }
          
          if (cmd === 'help' || cmd === 'commands') {
            this.addSystemMessage('ğŸ’¡ Try: auto equip, optimize, buy [item], need gold, hi, stats, talents', 'info');
            this.addSystemMessage('ğŸ§  Or just chat: "hey", "how are you?", "help me get stronger"', 'info');
            return;
          }
          
          // â•â•â• MACRO SYSTEM â•â•â•
          if (cmd === 'start recording' || cmd === 'record macro') {
            window.gameState.aiMacros.recording = true;
            window.gameState.aiMacros.currentRecording = [];
            this.addSystemMessage(`ğŸ”´ Recording macro... Type commands, then "stop recording"`, 'reward');
            return;
          }
          
          if (cmd === 'stop recording') {
            if (!window.gameState.aiMacros.recording) {
              this.addSystemMessage(`âŒ Not recording. Type "start recording" first`, 'error');
              return;
            }
            window.gameState.aiMacros.recording = false;
            this.addSystemMessage(`â¹ï¸ Recorded ${window.gameState.aiMacros.currentRecording.length} commands`, 'success');
            this.addSystemMessage(`Type "save macro as [name]" to save it`, 'info');
            return;
          }
          
          if (cmd.startsWith('save macro as ')) {
            const macroName = cmd.replace('save macro as ', '').trim();
            window.gameState.aiMacros.saved[macroName] = [...window.gameState.aiMacros.currentRecording];
            this.addSystemMessage(`ğŸ’¾ Macro "${macroName}" saved with ${window.gameState.aiMacros.currentRecording.length} commands`, 'success');
            window.gameState.aiMacros.currentRecording = [];
            return;
          }
          
          if (cmd.startsWith('run ') || cmd.startsWith('execute ')) {
            const macroName = cmd.replace('run ', '').replace('execute ', '').trim();
            const macro = window.gameState.aiMacros.saved[macroName];
            if (macro) {
              this.addSystemMessage(`â–¶ï¸ Executing macro "${macroName}"...`, 'reward');
              macro.forEach((command, index) => {
                setTimeout(() => this.processAICommand(command), index * 500);
              });
              return;
            } else {
              this.addSystemMessage(`âŒ Macro "${macroName}" not found`, 'error');
              return;
            }
          }
          
          // â•â•â• COMMAND ALIASES â•â•â•
          const aliases = window.gameState.aiAliases;
          if (aliases[cmd]) {
            this.addSystemMessage(`ğŸ“ Running alias "${cmd}"...`, 'info');
            aliases[cmd].forEach((command, index) => {
              setTimeout(() => this.processAICommand(command), index * 300);
            });
            return;
          }
          
          // â•â•â• SCHEDULED ACTIONS â•â•â•
          if (cmd.startsWith('remind me in ')) {
            const match = cmd.match(/remind me in (\\d+) (second|minute|hour)s? to (.+)/);
            if (match) {
              const [, amount, unit, task] = match;
              const ms = amount * (unit === 'hour' ? 3600000 : unit === 'minute' ? 60000 : 1000);
              
              setTimeout(() => {
                this.addSystemMessage(`â° REMINDER: ${task}`, 'warning');
                this.showToast(`â° ${task}`);
              }, ms);
              
              this.addSystemMessage(`â° Reminder set for ${amount} ${unit}(s)`, 'success');
              return;
            }
          }
          
          if (cmd.startsWith('every ') && cmd.includes(' do ')) {
            const match = cmd.match(/every (\\d+) (second|minute)s? do (.+)/);
            if (match) {
              const [, amount, unit, task] = match;
              const ms = amount * (unit === 'minute' ? 60000 : 1000);
              const taskId = 'task_' + Date.now();
              
              window.gameState.aiScheduler.intervals[taskId] = setInterval(() => {
                this.processAICommand(task);
              }, ms);
              
              this.addSystemMessage(`ğŸ” Scheduled "${task}" every ${amount} ${unit}(s). ID: ${taskId}`, 'success');
              this.addSystemMessage(`To stop: type "stop ${taskId}"`, 'info');
              return;
            }
          }
          
          if (cmd.startsWith('stop task_')) {
            const taskId = cmd.replace('stop ', '');
            if (window.gameState.aiScheduler.intervals[taskId]) {
              clearInterval(window.gameState.aiScheduler.intervals[taskId]);
              delete window.gameState.aiScheduler.intervals[taskId];
              this.addSystemMessage(`â¹ï¸ Stopped scheduled task ${taskId}`, 'success');
              return;
            }
          }
          
          // â•â•â• AI LEARNING & SUGGESTIONS â•â•â•
          // Track user behavior
          window.gameState.aiLearning.behaviorPatterns.push({
            command: command,
            timestamp: Date.now(),
            context: {
              tab: this.state.activeTab,
              gold: window.gameState.gold,
              equipped: Object.keys(window.gameState.equipped).filter(k => window.gameState.equipped[k]).length
            }
          });
          
          // Keep only last 50 patterns
          if (window.gameState.aiLearning.behaviorPatterns.length > 50) {
            window.gameState.aiLearning.behaviorPatterns.shift();
          }
          
          // If recording macro, add command to recording
          if (window.gameState.aiMacros.recording) {
            window.gameState.aiMacros.currentRecording.push(command);
            this.addSystemMessage(`ğŸ”´ Recorded: ${command}`, 'info');
          }
          
          // â•â•â• FALLBACK: SMART ASSISTANCE â•â•â•
          if (cmd.includes('how') || cmd.includes('what') || cmd.includes('why')) {
            this.addSystemMessage(`ğŸ¤” Analyzing question...`, 'info');
            this.addSystemMessage(`${kb.tips.equipment}`, 'info');
            this.addSystemMessage(`Type "help" or just chat!`, 'info');
            return;
          }
          
          // Unknown command
          this.logAIAction(`Unknown: ${command}`, 'warning');
          this.addSystemMessage(`â“ Not sure about "${command}". Try "help"!`, 'warning');
        },

        logAIAction(action, type = 'info') {
          const sl = window.gameState.soloLevelingSystem;
          if (!sl.aiActions) sl.aiActions = [];
          
          sl.aiActions.unshift({
            timestamp: Date.now(),
            action: action,
            type: type
          });
          
          // Keep only last 50 actions
          if (sl.aiActions.length > 50) {
            sl.aiActions = sl.aiActions.slice(0, 50);
          }
          
          // Also show in system messages
          const icons = {
            command: 'âŒ¨ï¸',
            success: 'âœ…',
            error: 'âŒ',
            info: 'â„¹ï¸',
            warning: 'âš ï¸'
          };
          this.addSystemMessage(`${icons[type] || 'â„¹ï¸'} ${action}`, type);
        },

        addSystemMessage(message, type = 'system') {
          const terminal = document.getElementById('systemMessageTerminal');
          if (!terminal) return;
          
          const colorMap = {
            system: '#00e5ff',
            info: '#4fc3f7',
            success: '#38ef7d',
            error: '#ff6b6b',
            warning: '#ffd77a',
            reward: '#a78bfa',
            command: '#00e5ff'
          };
          
          const color = colorMap[type] || colorMap.system;
          const timestamp = new Date().toLocaleTimeString();
          
          const messageEl = document.createElement('div');
          messageEl.style.cssText = `
            padding: 8px 12px;
            margin-bottom: 6px;
            background: rgba(0, 0, 0, 0.3);
            border-left: 3px solid ${color};
            border-radius: 4px;
            font-size: 11px;
            color: ${color};
            font-family: 'Courier New', monospace;
            animation: slideInLeft 0.3s ease;
          `;
          messageEl.innerHTML = `<span style="opacity: 0.6;">[${timestamp}]</span> ${message}`;
          
          terminal.insertBefore(messageEl, terminal.firstChild);
          
          // Keep only last 20 messages
          while (terminal.children.length > 20) {
            terminal.removeChild(terminal.lastChild);
          }
          
          // Speak message if TTS enabled
          if (window.gameState.textToSpeech.enabled) {
            this.speak(message);
          }
        },

        // â•â•â• TEXT-TO-SPEECH SYSTEM â•â•â•
        speak(text) {
          if (!window.speechSynthesis) {
            debugWarn('Text-to-speech not supported in this browser');
            return;
          }
          
          const tts = window.gameState.textToSpeech;
          if (!tts.enabled) return;
          
          // Cancel any ongoing speech
          window.speechSynthesis.cancel();
          
          // Clean text for speaking (remove emojis and special chars)
          const cleanText = text.replace(/[^\w\s.,!?-]/g, '').trim();
          if (!cleanText) return;
          
          const utterance = new SpeechSynthesisUtterance(cleanText);
          utterance.rate = tts.rate;
          utterance.pitch = tts.pitch;
          utterance.volume = tts.volume;
          
          // Use selected voice if available
          if (tts.selectedVoice) {
            const voices = window.speechSynthesis.getVoices();
            const voice = voices.find(v => v.name === tts.selectedVoice);
            if (voice) utterance.voice = voice;
          }
          
          // Visual indicator when speaking
          this.showSpeakingIndicator();
          
          utterance.onend = () => {
            this.hideSpeakingIndicator();
          };
          
          window.speechSynthesis.speak(utterance);
        },

        showSpeakingIndicator() {
          let indicator = document.getElementById('aiSpeakingIndicator');
          if (!indicator) {
            indicator = document.createElement('div');
            indicator.id = 'aiSpeakingIndicator';
            indicator.style.cssText = `
              position: fixed;
              bottom: 20px;
              right: 20px;
              padding: 12px 20px;
              background: linear-gradient(135deg, #00e5ff, #a78bfa);
              border: 2px solid white;
              border-radius: 20px;
              color: white;
              font-weight: bold;
              font-size: 13px;
              z-index: 10003;
              animation: pulse 1s infinite;
            `;
            indicator.innerHTML = 'ğŸ”Š AI Speaking...';
            document.body.appendChild(indicator);
          }
          indicator.style.display = 'block';
        },

        hideSpeakingIndicator() {
          const indicator = document.getElementById('aiSpeakingIndicator');
          if (indicator) {
            indicator.style.display = 'none';
          }
        },

        toggleTTS() {
          window.gameState.textToSpeech.enabled = !window.gameState.textToSpeech.enabled;
          const status = window.gameState.textToSpeech.enabled ? 'ON' : 'OFF';
          this.showToast(`ğŸ”Š Voice ${status}`);
          
          if (window.gameState.textToSpeech.enabled) {
            this.speak("Voice enabled. I can now speak to you!");
          }
        },

        stopSpeaking() {
          if (window.speechSynthesis) {
            window.speechSynthesis.cancel();
            this.hideSpeakingIndicator();
            this.showToast('ğŸ”‡ Speech stopped');
          }
        },

        narrateEvent(eventType, message) {
          const tts = window.gameState.textToSpeech;
          if (tts.enabled && tts.narrateEvents[eventType]) {
            this.speak(message);
          }
        },

        syncAllSystems() {
          // â•â•â• CENTRAL SYNCHRONIZATION HUB - UPDATES EVERYTHING â•â•â•
          
          // 1. Update calculated stats (includes talents and equipment)
          this.updateStats();
          
          // 2. Update character sprite if in gear tab
          if (this.state.activeTab === 'gear') {
            setTimeout(() => this.renderGearCharacterSprite(), 50);
          }
          
          // 3. Update shop prices (affected by talents and equipment)
          this.updateShopPrices();
          
          // 4. Check for new synergies
          const synergies = this.getActiveSynergies();
          if (synergies.length > 0) {
            synergies.forEach(syn => {
              if (!this.state.notifiedSynergies) this.state.notifiedSynergies = [];
              if (!this.state.notifiedSynergies.includes(syn.name)) {
                this.addSystemMessage(`âœ¨ SYNERGY UNLOCKED: ${syn.name}! Bonus: ${syn.bonus}`, 'reward');
                this.narrateEvent('achievement', `Synergy unlocked: ${syn.name}`);
                this.state.notifiedSynergies.push(syn.name);
              }
            });
          }
          
          // 5. Update any active tab display
          if (this.state.activeTab) {
            this.renderTab(this.state.activeTab);
          }
          
          // 6. Emit custom event for external systems
          window.dispatchEvent(new CustomEvent('gameStateChanged', {
            detail: {
              stats: window.gameState.currentStats,
              equipped: window.gameState.equipped,
              gold: window.gameState.gold,
              talents: window.gameState.talents,
              timestamp: Date.now()
            }
          }));
          
          // 7. Update header/footer displays everywhere
          this.updateHeaderStats();
          this.renderCurrencies();
        },

        renderCurrencies() {
          // Update currency display in header
          const goldEl = document.querySelector('[data-currency="gold"]');
          const gemsEl = document.querySelector('[data-currency="gems"]');
          const keysEl = document.querySelector('[data-currency="keys"]');
          const ticketsEl = document.querySelector('[data-currency="tickets"]');
          
          if (goldEl) goldEl.textContent = window.gameState.gold.toLocaleString();
          if (gemsEl) gemsEl.textContent = window.gameState.gems;
          if (keysEl) keysEl.textContent = window.gameState.keys;
          if (ticketsEl) ticketsEl.textContent = window.gameState.tickets;
        },

        // â•â•â• UNDO/REDO SYSTEM â•â•â•
        saveStateForUndo(action) {
          const snapshot = {
            action: action,
            timestamp: Date.now(),
            state: {
              gold: window.gameState.gold,
              equipped: JSON.parse(JSON.stringify(window.gameState.equipped)),
              inventory: JSON.parse(JSON.stringify(window.gameState.inventory)),
              talents: JSON.parse(JSON.stringify(window.gameState.talents))
            }
          };
          
          window.gameState.undoStack.push(snapshot);
          
          // Keep only last 10 actions
          if (window.gameState.undoStack.length > 10) {
            window.gameState.undoStack.shift();
          }
          
          // Clear redo stack when new action performed
          window.gameState.redoStack = [];
        },

        undo() {
          if (window.gameState.undoStack.length === 0) {
            this.showToast('âŒ Nothing to undo');
            return;
          }
          
          // Save current state to redo stack
          const currentState = {
            action: 'redo point',
            timestamp: Date.now(),
            state: {
              gold: window.gameState.gold,
              equipped: JSON.parse(JSON.stringify(window.gameState.equipped)),
              inventory: JSON.parse(JSON.stringify(window.gameState.inventory)),
              talents: JSON.parse(JSON.stringify(window.gameState.talents))
            }
          };
          window.gameState.redoStack.push(currentState);
          
          // Restore previous state
          const previousState = window.gameState.undoStack.pop();
          window.gameState.gold = previousState.state.gold;
          window.gameState.equipped = previousState.state.equipped;
          window.gameState.inventory = previousState.state.inventory;
          window.gameState.talents = previousState.state.talents;
          
          this.showToast(`â†©ï¸ Undid: ${previousState.action}`);
          this.syncAllSystems();
        },

        redo() {
          if (window.gameState.redoStack.length === 0) {
            this.showToast('âŒ Nothing to redo');
            return;
          }
          
          const nextState = window.gameState.redoStack.pop();
          window.gameState.gold = nextState.state.gold;
          window.gameState.equipped = nextState.state.equipped;
          window.gameState.inventory = nextState.state.inventory;
          window.gameState.talents = nextState.state.talents;
          
          this.showToast('â†ªï¸ Redid action');
          this.syncAllSystems();
        },

        // â•â•â• INVENTORY MANAGEMENT â•â•â•
        checkInventorySpace() {
          const gearCount = (window.gameState.inventory.gear || []).length;
          const itemCount = (window.gameState.inventory.items || []).length;
          const totalCount = gearCount + itemCount;
          const maxSize = window.gameState.maxInventorySize;
          
          if (totalCount >= maxSize) {
            this.showInventoryFullDialog();
            return false;
          }
          
          if (totalCount >= maxSize * 0.9) {
            this.showToast(`âš ï¸ Inventory almost full: ${totalCount}/${maxSize}`, 'warning');
          }
          
          return true;
        },

        showInventoryFullDialog() {
          const overlay = document.createElement('div');
          overlay.style.cssText = `
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 10004;
            display: flex;
            align-items: center;
            justify-content: center;
          `;
          
          overlay.innerHTML = `
            <div style="background: linear-gradient(135deg, rgba(15, 24, 38, 0.98), rgba(10, 18, 32, 0.98)); border: 3px solid rgba(255, 107, 107, 0.8); border-radius: 16px; padding: 32px; max-width: 500px; box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9);">
              <div style="font-size: 48px; text-align: center; margin-bottom: 16px;">ğŸ’</div>
              <h2 style="color: #ff6b6b; font-size: 24px; text-align: center; margin-bottom: 12px;">Inventory Full!</h2>
              <p style="color: rgba(207, 227, 255, 0.8); text-align: center; margin-bottom: 24px;">
                You've reached the maximum inventory size. What would you like to do?
              </p>
              <div style="display: flex; flex-direction: column; gap: 12px;">
                <button id="autoSellJunkBtn" style="padding: 14px; background: linear-gradient(135deg, #38ef7d, #4fc3f7); border: 2px solid white; border-radius: 10px; color: white; font-weight: bold; font-size: 14px; cursor: pointer;">
                  ğŸ’° Auto-Sell Junk Items
                </button>
                <button id="goToInventoryBtn" style="padding: 14px; background: linear-gradient(135deg, #ffd77a, #ff6b35); border: 2px solid white; border-radius: 10px; color: white; font-weight: bold; font-size: 14px; cursor: pointer;">
                  ğŸ“¦ Manage Inventory
                </button>
                <button id="closeFullDialogBtn" style="padding: 14px; background: rgba(100, 100, 100, 0.5); border: 2px solid white; border-radius: 10px; color: white; font-weight: bold; font-size: 14px; cursor: pointer;">
                  âœ• Cancel
                </button>
              </div>
            </div>
          `;
          
          document.body.appendChild(overlay);
          
          document.getElementById('autoSellJunkBtn').onclick = () => {
            this.autoSell();
            overlay.remove();
          };
          
          document.getElementById('goToInventoryBtn').onclick = () => {
            this.state.activeTab = 'items';
            this.renderTab('items');
            overlay.remove();
          };
          
          document.getElementById('closeFullDialogBtn').onclick = () => {
            overlay.remove();
          };
        },

        // â•â•â• ERROR HANDLING â•â•â•
        handleError(error, context) {
          debugError(`[BagSystem Error in ${context}]:`, error);
          
          window.gameState.errorLog.push({
            error: error.message || error.toString(),
            context: context,
            timestamp: Date.now(),
            stack: error.stack
          });
          
          // Keep only last 20 errors
          if (window.gameState.errorLog.length > 20) {
            window.gameState.errorLog.shift();
          }
          
          this.showToast(`âš ï¸ Error: ${error.message || 'Something went wrong'}`, 'error');
        },

        reportBug() {
          const errorReport = window.gameState.errorLog.map(e => 
            `[${new Date(e.timestamp).toLocaleString()}] ${e.context}: ${e.error}`
          ).join('\n\n');
          
          const reportText = `=== A1K BUG REPORT ===\n\n${errorReport}\n\nGame State:\nGold: ${window.gameState.gold}\nEquipped Items: ${Object.keys(window.gameState.equipped).filter(k => window.gameState.equipped[k]).length}`;
          
          navigator.clipboard.writeText(reportText).then(() => {
            this.showToast('ğŸ“‹ Bug report copied to clipboard!');
          });
        },

        // â•â•â• SAVE/LOAD SYSTEM â•â•â•
        saveGame(slotName = 'auto') {
          try {
            const saveData = {
              version: '1.0',
              timestamp: Date.now(),
              state: {
                gold: window.gameState.gold,
                gems: window.gameState.gems,
                keys: window.gameState.keys,
                tickets: window.gameState.tickets,
                equipped: window.gameState.equipped,
                inventory: window.gameState.inventory,
                talents: window.gameState.talents,
                shop: window.gameState.shop,
                currentStats: window.gameState.currentStats
              }
            };
            
            // Validate save data
            if (!this.validateSaveData(saveData)) {
              throw new Error('Save data validation failed');
            }
            
            const saveKey = `a1k_save_${slotName}`;
            localStorage.setItem(saveKey, JSON.stringify(saveData));
            window.gameState.saveSlots[slotName] = saveData;
            
            this.showToast(`ğŸ’¾ Game saved to ${slotName}!`);
            return true;
          } catch (error) {
            this.handleError(error, 'saveGame');
            return false;
          }
        },

        loadGame(slotName) {
          try {
            const saveKey = `a1k_save_${slotName}`;
            const saveData = localStorage.getItem(saveKey);
            
            if (!saveData) {
              this.showToast(`âŒ No save found in slot: ${slotName}`);
              return false;
            }
            
            const data = JSON.parse(saveData);
            
            if (!this.validateSaveData(data)) {
              throw new Error('Corrupted save file');
            }
            
            // Restore state
            window.gameState.gold = data.state.gold;
            window.gameState.gems = data.state.gems;
            window.gameState.keys = data.state.keys;
            window.gameState.tickets = data.state.tickets;
            window.gameState.equipped = data.state.equipped;
            window.gameState.inventory = data.state.inventory;
            window.gameState.talents = data.state.talents;
            window.gameState.currentStats = data.state.currentStats;
            
            this.showToast(`ğŸ“‚ Game loaded from ${slotName}!`);
            this.syncAllSystems();
            return true;
          } catch (error) {
            this.handleError(error, 'loadGame');
            return false;
          }
        },

        validateSaveData(data) {
          if (!data || !data.state) return false;
          if (typeof data.state.gold !== 'number') return false;
          if (!data.state.inventory || !Array.isArray(data.state.inventory.gear)) return false;
          return true;
        },

        autoSave() {
          const now = Date.now();
          const timeSinceLastSave = now - window.gameState.lastAutoSave;
          
          // Auto-save every 5 minutes
          if (timeSinceLastSave > 300000) {
            this.saveGame('auto');
            window.gameState.lastAutoSave = now;
          }
        },

        // â•â•â• PERFORMANCE OPTIMIZATION â•â•â•
        debounce(func, wait) {
          let timeout;
          return function executedFunction(...args) {
            const later = () => {
              clearTimeout(timeout);
              func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
          };
        },

        throttle(func, limit) {
          let inThrottle;
          return function(...args) {
            if (!inThrottle) {
              func.apply(this, args);
              inThrottle = true;
              setTimeout(() => inThrottle = false, limit);
            }
          };
        },

        optimizeRendering() {
          // Use requestAnimationFrame for smooth animations
          if (!this.animationFrameId) {
            const animate = () => {
              // Update any active animations
              if (this.state.activeTab === 'skins') {
                this.animateCharacterSprites();
              }
              
              if (this.state.activeTab === 'gear') {
                this.renderGearCharacterSprite();
              }
              
              this.animationFrameId = requestAnimationFrame(animate);
            };
            this.animationFrameId = requestAnimationFrame(animate);
          }
        },

        stopAnimations() {
          if (this.animationFrameId) {
            cancelAnimationFrame(this.animationFrameId);
            this.animationFrameId = null;
          }
        },

        showLoadingState(message = 'Loading...') {
          let loader = document.getElementById('a1k-loader');
          if (!loader) {
            loader = document.createElement('div');
            loader.id = 'a1k-loader';
            loader.style.cssText = `
              position: fixed;
              top: 50%;
              left: 50%;
              transform: translate(-50%, -50%);
              padding: 24px 40px;
              background: rgba(10, 18, 32, 0.98);
              border: 3px solid rgba(0, 229, 255, 0.8);
              border-radius: 16px;
              z-index: 10005;
              box-shadow: 0 20px 60px rgba(0, 0, 0, 0.9);
            `;
            loader.innerHTML = `
              <div style="font-size: 36px; text-align: center; margin-bottom: 12px; animation: pulse 1s infinite;">âš™ï¸</div>
              <div style="color: #00e5ff; font-size: 16px; font-weight: bold; text-align: center;">${message}</div>
            `;
            document.body.appendChild(loader);
          }
        },

        hideLoadingState() {
          const loader = document.getElementById('a1k-loader');
          if (loader) loader.remove();
        },

        async performHeavyOperation(operation, operationName = 'Processing') {
          this.showLoadingState(operationName);
          
          return new Promise((resolve) => {
            setTimeout(() => {
              try {
                const result = operation();
                this.hideLoadingState();
                resolve(result);
              } catch (error) {
                this.handleError(error, operationName);
                this.hideLoadingState();
                resolve(null);
              }
            }, 50); // Small delay to show loader
          });
        },

        // Memory management
        cleanupMemory() {
          // Clear old conversation context
          if (window.AIKnowledgeBase.conversationContext.length > 10) {
            window.AIKnowledgeBase.conversationContext = window.AIKnowledgeBase.conversationContext.slice(-10);
          }
          
          // Clear old error logs
          if (window.gameState.errorLog.length > 20) {
            window.gameState.errorLog = window.gameState.errorLog.slice(-20);
          }
          
          // Clear old AI actions
          if (window.gameState.soloLevelingSystem?.aiActions?.length > 50) {
            window.gameState.soloLevelingSystem.aiActions = window.gameState.soloLevelingSystem.aiActions.slice(-50);
          }
          
          // Clear old shop transactions
          if (window.gameState.shop.transactionHistory.length > 30) {
            window.gameState.shop.transactionHistory = window.gameState.shop.transactionHistory.slice(-30);
          }
        },

        calculateItemPower(item) {
          if (!item) return 0;
          this.normalizeGearItem(item);
          if (window.GearData) {
            return window.GearData.calculateItemPower(item);
          }
          const stats = item.stats || item;
          const weights = {
            attack: 1.0,
            defense: 0.85,
            hp: 0.15,
            mp: 0.12,
            speed: 150,
            critRate: 220,
            critDamage: 140,
            lifesteal: 260,
            armorPen: 210,
            block: 170,
            evade: 170,
            cooldownReduction: 200
          };
          let raw = 0;
          Object.entries(weights).forEach(([key, weight]) => {
            const value = stats[key] ?? item[key];
            if (value) {
              if (isPercentStat(key)) {
                raw += value * weight;
              } else {
                raw += Number(value) * weight;
              }
            }
          });
          const rarityMultiplier = {
            legendary: 5,
            epic: 4,
            rare: 3,
            uncommon: 2,
            common: 1
          };
          const multiplier = rarityMultiplier[item.rarity] || 1;
          return Math.round(raw * multiplier);
        },

        autoEquip() {
          const gear = window.gameState.inventory.gear || [];
          const slots = ['head', 'chest', 'gloves', 'pants', 'boots', 'weapon', 'offhand', 'ring1', 'ring2', 'necklace'];
          
          let equippedCount = 0;
          let companionCount = 0;
          let coreCount = 0;
          
          slots.forEach(slotName => {
            // Find all items that can go in this slot
            let candidates = gear.filter(item => {
              if (slotName === 'ring1' || slotName === 'ring2') {
                return item.slot === 'ring';
              }
              return item.slot === slotName;
            });
            
            // Skip if no candidates
            if (candidates.length === 0) return;
            
            // Sort by power (highest first)
            candidates.sort((a, b) => this.calculateItemPower(b) - this.calculateItemPower(a));
            
            // Get the best item
            const bestItem = candidates[0];
            
            // Check if current equipped item is better
            const currentItem = window.gameState.equipped[slotName];
            if (currentItem && this.calculateItemPower(currentItem) >= this.calculateItemPower(bestItem)) {
              return; // Already have better or equal item equipped
            }
            
            // Equip the best item
            window.gameState.equipped[slotName] = bestItem;
            
            // Remove from inventory
            const itemIndex = gear.indexOf(bestItem);
            if (itemIndex !== -1) {
              gear.splice(itemIndex, 1);
            }
            
            equippedCount++;
          });
          
          const inventory = window.gameState.inventory || {};
          const equipped = window.gameState.equipped || {};
          
          const selectBestCompanion = (collection, type) => {
            if (!Array.isArray(collection) || collection.length === 0) return null;
            let bestItem = null;
            let bestScore = -Infinity;
            collection.forEach(item => {
              if (!item) return;
              const check = typeof this.canEquipItem === 'function' ? this.canEquipItem(item, type) : { canEquip: true };
              if (!check.canEquip) return;
              const score = getCompanionPowerScore(item);
              if (score > bestScore) {
                bestScore = score;
                bestItem = item;
              }
            });
            return bestItem;
          };
          
          const maybeEquipCompanion = (type, bestItem, equipCallback, currentItem) => {
            if (!bestItem) return;
            const currentId = currentItem?.id || currentItem?.uid;
            const bestId = bestItem?.id || bestItem?.uid;
            if (currentId === bestId) return;
            const beforeId = currentId;
            equipCallback.call(this, bestItem);
            const afterItem = (window.gameState.equipped || {})[type];
            const afterId = afterItem?.id || afterItem?.uid;
            if (afterId && afterId !== beforeId) {
              companionCount += 1;
            }
          };
          
          maybeEquipCompanion('pet', selectBestCompanion(inventory.pets, 'pet'), this.equipPet, equipped.pet);
          maybeEquipCompanion('vehicle', selectBestCompanion(inventory.vehicles, 'vehicle'), this.equipVehicle, equipped.vehicle);
          maybeEquipCompanion('spirit', selectBestCompanion(inventory.spirits, 'spirit'), this.equipSpirit, equipped.spirit);
          maybeEquipCompanion('robot', selectBestCompanion(inventory.robots, 'robot'), this.equipRobot, equipped.robot);
          
          const equipBestCores = () => {
            if (!window.CORES_DATABASE || !CORE_SLOTS_CONFIG) return;
            window.gameState.equippedCores = window.gameState.equippedCores || {};
            const equippedCores = window.gameState.equippedCores;
            Object.entries(CORE_SLOTS_CONFIG).forEach(([slotName, config]) => {
              const slotKey = config.coreSuffix;
              const currentCore = equippedCores[slotKey];
              const candidates = Object.values(window.CORES_DATABASE).filter(core => core?.category === config.coreType);
              if (!candidates.length) return;
              let bestCore = null;
              let bestScore = -Infinity;
              candidates.forEach(core => {
                const score = getCorePowerScore(core);
                if (score > bestScore) {
                  bestScore = score;
                  bestCore = core;
                }
              });
              if (!bestCore) return;
              if (currentCore?.id === bestCore.id) return;
              window.equipCoreToSlot(slotName, bestCore);
              coreCount += 1;
            });
          };
          
          equipBestCores();
          
          const totalChanges = equippedCount + companionCount + coreCount;
          if (equippedCount > 0) {
            this.renderGearTab();
          }
          
          if (totalChanges > 0) {
            const details = [];
            if (equippedCount > 0) details.push(`${equippedCount} gear`);
            if (companionCount > 0) details.push(`${companionCount} companions`);
            if (coreCount > 0) details.push(`${coreCount} cores`);
            if (details.length > 0) {
              this.showToast(`âš™ï¸ Auto-equipped ${details.join(', ')}!`);
            } else {
              this.showToast('âš™ï¸ Auto-equipped loadout!');
            }
            this.updateStats();
            this.playCandySfx('auto-equip');
          } else {
            this.showToast('âœ… Already using best loadout!');
          }
        },

        autoUpgrade() {
          const gear = this.normalizeGearCollection(window.gameState.inventory.gear || []);
          let upgradedCount = 0;
          let goldSpent = 0;
          
          gear.forEach(item => {
            const rank = (item.rank || '').toUpperCase();
            const rarity = (item.rarity || '').toLowerCase();
            if (rank === 'A' || rank.startsWith('S') || rarity === 'legendary') {
              return;
            }
            const result = this.performGearUpgrade(item);
            if (result.upgraded) {
              upgradedCount += 1;
              goldSpent += result.cost;
            }
          });
          
          if (upgradedCount > 0) {
            this.showToast(`â¬†ï¸ Upgraded ${upgradedCount} items for ${goldSpent}g!`);
            this.renderGearTab();
            this.updateStats();
          } else {
            this.showToast('ğŸ’° Not enough gold to upgrade items!');
          }
        },

        openAllContainers() {
          const items = window.gameState.inventory.items || [];
          const containers = items.filter(item => item.category === 'container');
          
          if (containers.length === 0) {
            this.showToast('ğŸ“¦ No containers to open!');
            return;
          }
          
          let totalGold = 0;
          let itemsGained = 0;
          
          containers.forEach(container => {
            const quantity = container.quantity || 1;
            
            for (let i = 0; i < quantity; i++) {
              // Random rewards based on container type
              const goldReward = Math.floor(Math.random() * 500) + 100;
              totalGold += goldReward;
              itemsGained += Math.floor(Math.random() * 3) + 1;
            }
            
            // Remove container from inventory
            const index = items.indexOf(container);
            if (index !== -1) {
              items.splice(index, 1);
            }
          });
          
          window.gameState.gold += totalGold;
          
          this.showToast(`ğŸ“¦ Opened ${containers.length} containers! +${totalGold}g, +${itemsGained} items!`);
          this.renderItemsTab();
        },

        openAll() {
          // Alias for openAllContainers
          this.openAllContainers();
        },

        updateStats() {
          const totalStats = this.computePlayerStats();
          window.gameState.currentStats = totalStats;
          const footer = document.querySelector('.bag-footer-stats');
          if (footer) {
            footer.innerHTML = `
              <span style="color: #ff6b6b;">HP: ${totalStats.hp}</span>
              <span style="color: #ffd77a;">ATK: ${totalStats.attack}</span>
              <span style="color: #4fc3f7;">DEF: ${totalStats.defense}</span>
              <span style="color: #9a6bff;">CRIT: ${(totalStats.critRate || totalStats.critChance || 0).toFixed(2)}</span>
            `;
          }
          
          // Also update header if it exists
          this.updateHeaderStats();
        },

        updateHeaderStats() {
          const stats = window.gameState.currentStats || { hp: 100, attack: 10, defense: 5 };
          const headerStats = document.querySelector('.bag-header .bag-footer-stats');
          if (headerStats) {
            headerStats.innerHTML = `
              <span style="color: #ff6b6b;">HP: ${stats.hp}</span>
              <span style="color: #ffd77a;">ATK: ${stats.attack}</span>
              <span style="color: #4fc3f7;">DEF: ${stats.defense}</span>
              <span style="color: #9a6bff;">CRIT: ${(stats.critRate || stats.critChance || 0).toFixed(2)}</span>
            `;
          }
        },

        renderGearCharacterSprite() {
          const canvas = document.getElementById('gearCharacterCanvas');
          if (!canvas) return;
          
          const ctx = canvas.getContext('2d');
          if (!ctx) return;

          this.ensurePaperDollTestbed();
          
          // Clear canvas
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          
          // Get current character (default defensively seeded via ensureCurrentCharacter)
          const charKey = this.ensureCurrentCharacter();
          const currentChar = charKey === 'MISSY' ? 'Missy' : charKey === 'UNIQUE' ? 'Unique' : 'A1';
          const equipped = window.gameState.equipped || {};
          
          // Simple idle animation time
          const time = Date.now() / 1000;
          const palette = this.getPaperDollPalette(currentChar);
          
          // Set canvas center - TEST 4: Moving Missy down more
          ctx.save();
          ctx.translate(120, 130); // Canvas center for 240x260
          ctx.scale(2.1, 2.1); // Make Missy bigger
          
          // Position adjustment: Moving down from -70 to -55 (15px down)
          ctx.translate(-64, -55); // Y changed from -70 to -55 (moved down)

          this.drawPaperDollBackdrop(ctx, palette, time);
          
          // Draw character sprite based on type
          if (currentChar === 'A1') {
            this.drawWarriorSprite(ctx, 'idle', time, palette);
          } else if (currentChar === 'Missy') {
            this.drawCatAngelSprite(ctx, 'idle', time, palette);
          } else if (currentChar === 'Unique') {
            this.drawCyborgSprite(ctx, 'idle', time, palette);
          }
          
          // Add equipment visual effects
          this.addEquipmentGlows(ctx, equipped);
          
          ctx.restore();
        },

        // Start continuous animation for gear character
        startGearCharacterAnimation() {
          if (this.gearAnimationId) {
            cancelAnimationFrame(this.gearAnimationId);
          }
          
          const animate = () => {
            if (this.state.activeTab === 'gear') {
              this.renderGearCharacterSprite();
              this.gearAnimationId = requestAnimationFrame(animate);
            }
          };
          
          this.gearAnimationId = requestAnimationFrame(animate);
        },

        addEquipmentGlows(ctx, equipped) {
          // Add visual effects based on equipped items
          // Weapon glow
          if (equipped.weapon) {
            const rarity = equipped.weapon.rarity;
            const glowColor = rarity === 'epic' ? 'rgba(147, 51, 234, 0.6)' : 
                            rarity === 'rare' ? 'rgba(59, 130, 246, 0.6)' :
                            rarity === 'uncommon' ? 'rgba(34, 197, 94, 0.6)' : 
                            'rgba(156, 163, 175, 0.3)';
            
            ctx.save();
            ctx.shadowColor = glowColor;
            ctx.shadowBlur = 15;
            ctx.globalAlpha = 0.3;
            
            // Draw weapon glow effect (simple circle near right hand)
            ctx.beginPath();
            ctx.arc(18, 10, 8, 0, Math.PI * 2);
            ctx.fillStyle = glowColor;
            ctx.fill();
            ctx.restore();
          }
          
          // Helmet glow
          if (equipped.head) {
            ctx.save();
            ctx.shadowColor = 'rgba(255, 215, 0, 0.5)';
            ctx.shadowBlur = 10;
            ctx.globalAlpha = 0.2;
            
            // Draw helmet glow around head area
            ctx.beginPath();
            ctx.arc(0, -28, 14, 0, Math.PI * 2);
            ctx.strokeStyle = 'rgba(255, 215, 0, 0.6)';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();
          }
          
          // Chest armor glow
          if (equipped.chest) {
            ctx.save();
            ctx.shadowColor = 'rgba(100, 200, 255, 0.4)';
            ctx.shadowBlur = 12;
            ctx.globalAlpha = 0.15;
            
            // Draw chest glow around body
            ctx.beginPath();
            ctx.rect(-14, 0, 28, 38);
            ctx.strokeStyle = 'rgba(100, 200, 255, 0.5)';
            ctx.lineWidth = 2;
            ctx.stroke();
            ctx.restore();
          }
        },

        getPaperDollPalette(character) {
          const cached = window.PolishConfig?.getCached?.();
          const palettes = cached?.paperDoll?.characters || {};
          const key = typeof character === 'string' ? character.toLowerCase() : 'missy';
          const fallback = {
            base: '#4b5563',
            highlight: '#9ca3af',
            shadow: '#1f2937',
            accent: '#fbbf24',
            emissive: 'rgba(96, 165, 250, 0.55)'
          };
          return { ...fallback, ...(palettes[key] || {}) };
        },

        drawPaperDollBackdrop(ctx, palette, time) {
          const cached = window.PolishConfig?.getCached?.();
          const backdrop = cached?.paperDoll?.backdrop || {};
          const haloColor = backdrop.haloColor || palette.emissive || 'rgba(255, 214, 102, 0.3)';
          const shadowColor = backdrop.floorShadow || 'rgba(15, 23, 42, 0.4)';

          ctx.save();
          ctx.globalAlpha = 0.75;
          ctx.fillStyle = haloColor;
          ctx.beginPath();
          ctx.ellipse(0, -18 + Math.sin(time * 0.6) * 2, 28, 30, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();

          ctx.save();
          ctx.globalAlpha = 0.42;
          ctx.fillStyle = shadowColor;
          ctx.beginPath();
          ctx.ellipse(0, 46, 24, 6.5, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        },

        ensurePaperDollTestbed() {
          if (this._paperDollQAInjected) return;
          const cached = window.PolishConfig?.getCached?.();
          const qaId = cached?.paperDoll?.qaButtonId || 'qaPaperDollTest';
          if (document.getElementById(qaId)) {
            this._paperDollQAInjected = true;
            return;
          }

          const container = document.querySelector('.paper-doll-container');
          if (!container) return;

          const button = document.createElement('button');
          button.id = qaId;
          button.type = 'button';
          button.textContent = 'QA: Cycle Paper Dolls';
          button.style.margin = '12px 0';
          button.style.padding = '6px 12px';
          button.style.borderRadius = '8px';
          button.style.border = '1px solid rgba(148, 163, 184, 0.3)';
          button.style.background = 'linear-gradient(135deg, rgba(96,165,250,0.2), rgba(236,72,153,0.2))';
          button.style.color = '#e2e8f0';
          button.style.fontSize = '12px';
          button.style.cursor = 'pointer';
          button.style.transition = 'transform 0.2s ease';
          button.onmouseenter = () => { button.style.transform = 'translateY(-1px)'; };
          button.onmouseleave = () => { button.style.transform = 'translateY(0)'; };
          button.addEventListener('click', () => this.runPaperDollTestbedCycle());

          container.parentElement?.insertBefore(button, container);
          this._paperDollQAInjected = true;
        },

        runPaperDollTestbedCycle() {
          const sequence = ['A1', 'MISSY', 'UNIQUE'];
          const previous = this.ensureCurrentCharacter();
          this.state.activeTab = 'gear';

          let index = 0;
          const step = () => {
            if (index >= sequence.length) {
              window.gameState.currentCharacter = previous || 'A1';
              this.renderGearCharacterSprite();
              return;
            }
            window.gameState.currentCharacter = sequence[index];
            this.renderGearCharacterSprite();
            index += 1;
            setTimeout(step, 420);
          };

          step();
        },

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CHARACTER SPRITE DRAWING FUNCTIONS (ANIMATED)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        drawCatAngelSprite(ctx, animation, time, palette) {
          const bounce = Math.sin(time * 2) * 2; // Floating bounce
          const breathe = Math.sin(time * 1.5) * 0.5; // Breathing effect
          const colors = palette || this.getPaperDollPalette('missy');
          
          ctx.save();
          ctx.translate(0, bounce); // Apply bounce
          
          // Shadow (floating effect)
          ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
          ctx.beginPath();
          ctx.ellipse(0, 45, 12, 4, 0, 0, Math.PI * 2);
          ctx.fill();
          
          // Pink wings (behind character)
          ctx.save();
          const wingGradient = ctx.createLinearGradient(-20, -10, 20, 18);
          wingGradient.addColorStop(0, colors.highlight || '#f472b6');
          wingGradient.addColorStop(1, colors.base || '#fbb6ce');
          ctx.fillStyle = wingGradient;
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
          ctx.lineWidth = 1;
          
          // Left wing
          ctx.beginPath();
          ctx.moveTo(-8, -5);
          ctx.bezierCurveTo(-20, -10, -25, 5, -18, 15);
          ctx.bezierCurveTo(-15, 18, -10, 10, -8, 5);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          
          // Right wing
          ctx.beginPath();
          ctx.moveTo(8, -5);
          ctx.bezierCurveTo(20, -10, 25, 5, 18, 15);
          ctx.bezierCurveTo(15, 18, 10, 10, 8, 5);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          ctx.restore();
          
          // Body (black rectangle with breathe effect)
          const bodyGradient = ctx.createLinearGradient(-6, 0, 6, 18);
          bodyGradient.addColorStop(0, colors.shadow || '#b83280');
          bodyGradient.addColorStop(1, colors.base || '#fbb6ce');
          ctx.fillStyle = bodyGradient;
          ctx.fillRect(-6, 0 + breathe, 12, 18);
          
          // Orange chest detail
          ctx.fillStyle = colors.accent || '#ffd56a';
          ctx.fillRect(-2, 2 + breathe, 4, 3);
          
          // Head (black circle)
          ctx.fillStyle = colors.base || '#fbb6ce';
          ctx.beginPath();
          ctx.arc(0, -12 + breathe, 10, 0, Math.PI * 2);
          ctx.fill();
          
          // Cat ears
          ctx.fillStyle = colors.shadow || '#b83280';
          ctx.beginPath();
          ctx.moveTo(-6, -18 + breathe);
          ctx.lineTo(-9, -24 + breathe);
          ctx.lineTo(-3, -20 + breathe);
          ctx.closePath();
          ctx.fill();
          
          ctx.beginPath();
          ctx.moveTo(6, -18 + breathe);
          ctx.lineTo(9, -24 + breathe);
          ctx.lineTo(3, -20 + breathe);
          ctx.closePath();
          ctx.fill();
          
          // Glowing eyes (with pulse animation)
          const eyeGlow = 0.3 + Math.sin(time * 3) * 0.2; // Pulse effect
          ctx.save();
          ctx.shadowColor = colors.emissive || 'rgba(255, 221, 146, 0.75)';
          ctx.shadowBlur = 8 + Math.sin(time * 3) * 3;
          ctx.fillStyle = colors.emissive || '#ffd56a';
          ctx.globalAlpha = 0.9;
          ctx.fillRect(-5, -14 + breathe, 3, 3); // Left eye
          ctx.fillRect(2, -14 + breathe, 3, 3);  // Right eye
          ctx.restore();
          
          // Halo (golden glow with rotation)
          ctx.save();
          ctx.rotate(time * 0.5); // Slow rotation
          ctx.strokeStyle = colors.accent || '#ffd56a';
          ctx.lineWidth = 2;
          ctx.shadowColor = colors.emissive || 'rgba(255, 221, 146, 0.75)';
          ctx.shadowBlur = 10;
          ctx.beginPath();
          ctx.arc(0, -28 + breathe, 8, 0, Math.PI * 2);
          ctx.stroke();
          
          // Halo sparkles
          for (let i = 0; i < 4; i++) {
            const angle = (time * 2 + i * Math.PI / 2);
            const x = Math.cos(angle) * 10;
            const y = -28 + breathe + Math.sin(angle) * 10;
            ctx.fillStyle = 'rgba(255, 255, 100, 0.6)';
            ctx.beginPath();
            ctx.arc(x, y, 1, 0, Math.PI * 2);
            ctx.fill();
          }
          ctx.restore();
          
          // ARMS - Drawing prominently with animation
          const armSwing = Math.sin(time * 1.5) * 3;
          
          // Left arm (sticks out to the left)
          ctx.fillStyle = '#3a3a3a';
          ctx.fillRect(-14, 3 + breathe + armSwing * 0.5, 7, 11);
          
          // Left hand (glowing yellow orb)
          ctx.save();
          ctx.fillStyle = '#ffeb3b';
          ctx.shadowColor = 'rgba(255, 235, 59, 1)';
          ctx.shadowBlur = 10;
          ctx.beginPath();
          ctx.arc(-11, 15 + breathe + armSwing * 0.5, 3.5, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
          
          // Right arm (sticks out to the right)
          ctx.fillStyle = colors.shadow || '#b83280';
          ctx.fillRect(7, 3 + breathe - armSwing * 0.5, 7, 11);
          
          // Right hand (glowing yellow orb)
          ctx.save();
          ctx.fillStyle = colors.emissive || '#ffd56a';
          ctx.shadowColor = colors.emissive || 'rgba(255, 235, 59, 1)';
          ctx.shadowBlur = 10;
          ctx.beginPath();
          ctx.arc(11, 15 + breathe - armSwing * 0.5, 3.5, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
          
          // Legs
          ctx.fillStyle = colors.shadow || '#b83280';
          ctx.fillRect(-5, 18 + breathe, 3, 8);  // Left leg
          ctx.fillRect(2, 18 + breathe, 3, 8);   // Right leg
          
          // Feet
          ctx.fillStyle = colors.shadow || '#b83280';
          ctx.fillRect(-6, 26 + breathe, 4, 2);
          ctx.fillRect(2, 26 + breathe, 4, 2);
          
          // Tail (curved with slight movement)
          ctx.strokeStyle = colors.shadow || '#b83280';
          ctx.lineWidth = 2.5;
          ctx.beginPath();
          ctx.moveTo(-6, 12 + breathe);
          const tailWave = Math.sin(time * 2) * 1;
          ctx.bezierCurveTo(-12, 14 + breathe + tailWave, -14, 8 + breathe + tailWave, -10, 4 + breathe);
          ctx.stroke();
          
          ctx.restore();
        },

        drawWarriorSprite(ctx, animation, time, palette) {
          const colors = palette || this.getPaperDollPalette('a1');
          const bounce = Math.sin(time * 1.8) * 1.4;
          const sway = Math.sin(time * 1.1) * 0.05;
          
          ctx.save();
          ctx.translate(0, bounce);
          ctx.rotate(sway);

          const armorGradient = ctx.createLinearGradient(-10, -6, 12, 24);
          armorGradient.addColorStop(0, colors.shadow || '#1e3a8a');
          armorGradient.addColorStop(0.5, colors.base || '#4169e1');
          armorGradient.addColorStop(1, colors.highlight || '#60a5fa');
          ctx.fillStyle = armorGradient;
          ctx.fillRect(-9, -2, 18, 26);

          ctx.fillStyle = colors.accent || '#ff6347';
          ctx.beginPath();
          ctx.moveTo(0, 6);
          ctx.lineTo(6, 12);
          ctx.lineTo(0, 18);
          ctx.lineTo(-6, 12);
          ctx.closePath();
          ctx.fill();

          const headGradient = ctx.createLinearGradient(-8, -18, 8, -2);
          headGradient.addColorStop(0, colors.highlight || '#60a5fa');
          headGradient.addColorStop(1, colors.base || '#4169e1');
          ctx.fillStyle = headGradient;
          ctx.beginPath();
          ctx.arc(0, -14, 9, 0, Math.PI * 2);
          ctx.fill();

          ctx.save();
          ctx.shadowColor = colors.emissive || 'rgba(96, 165, 250, 0.6)';
          ctx.shadowBlur = 8;
          ctx.fillStyle = colors.emissive || '#60a5fa';
          ctx.fillRect(-4, -16, 3, 3);
          ctx.fillRect(1, -16, 3, 3);
          ctx.restore();

          ctx.save();
          ctx.translate(14, 4);
          ctx.rotate(-0.3 + Math.sin(time * 2.2) * 0.08);
          ctx.fillStyle = colors.emissive || 'rgba(96, 165, 250, 0.6)';
          ctx.globalAlpha = 0.75;
          ctx.beginPath();
          ctx.moveTo(0, -16);
          ctx.lineTo(3, -2);
          ctx.lineTo(-3, -2);
          ctx.closePath();
          ctx.fill();
          ctx.restore();

          ctx.strokeStyle = 'rgba(15, 23, 42, 0.6)';
          ctx.lineWidth = 1.2;
          ctx.strokeRect(-9, -2, 18, 26);

          ctx.restore();
        },

        drawCyborgSprite(ctx, animation, time, palette) {
          const colors = palette || this.getPaperDollPalette('unique');
          const bounce = Math.sin(time * 1.6) * 1.3;
          const armDrift = Math.sin(time * 2.4) * 3;
          
          ctx.save();
          ctx.translate(0, bounce);

          const torsoGradient = ctx.createLinearGradient(-8, -2, 10, 26);
          torsoGradient.addColorStop(0, colors.shadow || '#334155');
          torsoGradient.addColorStop(0.5, colors.base || '#94a3b8');
          torsoGradient.addColorStop(1, colors.highlight || '#cbd5f5');
          ctx.fillStyle = torsoGradient;
          ctx.fillRect(-8, -2, 16, 26);

          ctx.strokeStyle = colors.emissive || 'rgba(56, 189, 248, 0.65)';
          ctx.lineWidth = 1.1;
          ctx.beginPath();
          ctx.moveTo(-4, 2);
          ctx.lineTo(-4, 10);
          ctx.moveTo(4, 2);
          ctx.lineTo(4, 10);
          ctx.stroke();

          ctx.fillStyle = colors.base || '#94a3b8';
          ctx.beginPath();
          ctx.arc(0, -14, 9, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = colors.emissive || '#38bdf8';
          ctx.fillRect(-6, -17, 12, 4);

          ctx.save();
          ctx.translate(10, 8);
          ctx.rotate(0.1 + armDrift * 0.01);
          ctx.fillStyle = colors.shadow || '#334155';
          ctx.fillRect(-2, -2, 12, 5);
          ctx.fillStyle = colors.emissive || '#38bdf8';
          ctx.fillRect(8, -1, 4, 3);
          ctx.restore();

          ctx.fillStyle = colors.shadow || '#334155';
          ctx.fillRect(-12, 6 + armDrift * 0.1, 4, 12);

          ctx.restore();
        },

        // Helper function to check if item can be equipped (level, unlock, ownership)
        canEquipItem(item, itemType = 'item') {
          if (!item) return { canEquip: false, reason: 'Item not found' };
          
          // Check if item is owned (in inventory)
          const playerLevel = window.gameState.playerLevel || 1;
          let isOwned = false;
          
          if (itemType === 'pet') {
            isOwned = (window.gameState.inventory.pets || []).some(p => p.id === item.id);
          } else if (itemType === 'spirit') {
            isOwned = (window.gameState.inventory.spirits || []).some(s => s.id === item.id);
          } else if (itemType === 'vehicle') {
            isOwned = (window.gameState.inventory.vehicles || []).some(v => v.id === item.id);
          } else if (itemType === 'robot') {
            isOwned = (window.gameState.inventory.robots || []).some(r => r.id === item.id);
          }
          
          if (!isOwned) {
            return { canEquip: false, reason: 'Item not owned. Purchase from shop first!' };
          }
          
          // Check level requirement (derive from rarity if levelReq not set)
          const rarity = item.rarity || 'common';
          const rarityReqs = window.RARITY_REQUIREMENTS || {
            common: { level: 1, goldCost: 0 },
            uncommon: { level: 5, goldCost: 500 },
            rare: { level: 15, goldCost: 2500 },
            epic: { level: 30, goldCost: 10000 },
            legendary: { level: 50, goldCost: 50000 }
          };
          const levelReq = item.levelReq || (rarityReqs[rarity]?.level || 1);
          
          if (playerLevel < levelReq) {
            return { canEquip: false, reason: `Level ${levelReq} required` };
          }
          
          // Check unlock requirement
          const unlockCheck = window.isItemUnlocked ? window.isItemUnlocked(item) : true;
          if (!unlockCheck) {
            // Check why it's not unlocked
            const unlockResult = window.canUnlockItem ? window.canUnlockItem(item) : { canUnlock: true };
            if (!unlockResult.canUnlock && item.unlockReq) {
              return { canEquip: false, reason: `Unlock required: ${item.unlockReq}` };
            }
            return { canEquip: false, reason: 'Item not unlocked yet' };
          }
          
          return { canEquip: true, reason: '' };
        },

        equipVehicle(vehicle) {
          const check = this.canEquipItem(vehicle, 'vehicle');
          if (!check.canEquip) {
            this.showToast(`ğŸ”’ ${check.reason}`);
            return;
          }

          const engine = this.ensureEngine();
          const previous = window.gameState.equipped.vehicle;
          if (previous && engine?.systems?.companion) {
            engine.systems.companion.despawn(previous.uid || previous.id);
          }

          const equippedVehicle = this.prepareEquippable(vehicle, 'vehicle');
          window.gameState.equipped.vehicle = equippedVehicle;
          this.state.equipped.vehicle = equippedVehicle;

          if (window.vehicleManager) {
            window.vehicleManager.onVehicleEquipped(equippedVehicle);
          }

          this.syncLegacyCompanionSlot('vehicle', equippedVehicle);
          this.syncCompanionManager('vehicle', equippedVehicle);

          this.showToast(`ğŸš— ${equippedVehicle.name} ready to be called.`);
          this.playCandySfx('equip');
          this.renderVehiclesTab();
          this.updateStats();
          this.persistCompanionUids();
        },

        unequipVehicle() {
          const vehicle = window.gameState.equipped.vehicle;
          if (vehicle) {
            const engine = this.ensureEngine();
            if (engine?.systems?.companion) {
              engine.systems.companion.despawn(vehicle.uid || vehicle.id);
            }
            window.gameState.equipped.vehicle = null;
            this.state.equipped.vehicle = null;

            if (window.vehicleManager) {
              window.vehicleManager.onVehicleUnequipped();
            }

            this.syncLegacyCompanionSlot('vehicle', null);
            this.syncCompanionManager('vehicle', null);

            this.showToast(`ğŸš— ${vehicle.name} stowed.`);
            this.renderVehiclesTab();
            this.updateStats();
            this.persistCompanionUids();
          }
        },

        equipPet(pet) {
          const check = this.canEquipItem(pet, 'pet');
          if (!check.canEquip) {
            this.showToast(`ğŸ”’ ${check.reason}`);
            return;
          }

          const engine = this.ensureEngine();
          const previous = window.gameState.equipped.pet;
          if (previous && engine?.systems?.companion) {
            engine.systems.companion.despawn(previous.uid || previous.id);
          }

          const equippedPet = this.prepareEquippable(pet, 'pet');
          window.gameState.equipped.pet = equippedPet;
          this.state.equipped.pet = equippedPet;

          this.syncLegacyCompanionSlot('pet', equippedPet);
          this.syncCompanionManager('pet', equippedPet);

          this.showToast(`ğŸ¾ ${equippedPet.name} ready to be called.`);
          this.playCandySfx('equip');
          this.renderPetsTab();
          this.updateStats();
          this.persistCompanionUids();
        },

        unequipPet() {
          const pet = window.gameState.equipped.pet;
          if (pet) {
            const engine = this.ensureEngine();
            if (engine?.systems?.companion) {
              engine.systems.companion.despawn(pet.uid || pet.id);
            }
            window.gameState.equipped.pet = null;
            this.state.equipped.pet = null;

            this.syncLegacyCompanionSlot('pet', null);
            this.syncCompanionManager('pet', null);

            this.showToast(`ğŸ¾ ${pet.name} recalled.`);
            this.renderPetsTab();
            this.updateStats();
            this.persistCompanionUids();
          }
        },

        equipSpirit(spirit) {
          const check = this.canEquipItem(spirit, 'spirit');
          if (!check.canEquip) {
            this.showToast(`ğŸ”’ ${check.reason}`);
            return;
          }

          const engine = this.ensureEngine();
          const previous = window.gameState.equipped.spirit;
          if (previous && engine?.systems?.companion) {
            engine.systems.companion.despawn(previous.uid || previous.id);
          }

          const equippedSpirit = this.prepareEquippable(spirit, 'spirit');
          window.gameState.equipped.spirit = equippedSpirit;
          this.state.equipped.spirit = equippedSpirit;

          this.syncLegacyCompanionSlot('spirit', equippedSpirit);
          this.syncCompanionManager('spirit', equippedSpirit);

          this.showToast(`âœ¨ ${equippedSpirit.name} ready to be summoned.`);
          this.playCandySfx('equip');
          this.renderSpiritTab();
          this.updateStats();
          this.persistCompanionUids();
        },

        unequipSpirit() {
          const spirit = window.gameState.equipped.spirit;
          if (spirit) {
            const engine = this.ensureEngine();
            if (engine?.systems?.companion) {
              engine.systems.companion.despawn(spirit.uid || spirit.id);
            }
            window.gameState.equipped.spirit = null;
            this.state.equipped.spirit = null;

            this.syncLegacyCompanionSlot('spirit', null);
            this.syncCompanionManager('spirit', null);

            this.showToast(`âœ¨ ${spirit.name} dismissed.`);
            this.renderSpiritTab();
            this.updateStats();
            this.persistCompanionUids();
          }
        },

        equipRobot(robot) {
          const check = this.canEquipItem(robot, 'robot');
          if (!check.canEquip) {
            this.showToast(`ğŸ”’ ${check.reason}`);
            return;
          }
          
          window.gameState.equipped.robot = robot;
          this.state.equipped.robot = robot;
          this.syncLegacyCompanionSlot('robot', robot);
          this.showToast(`ğŸ¤– Equipped ${robot.name}`);
          this.playCandySfx('equip');
          this.renderAITab();
          this.updateStats();
        },

        unequipRobot() {
          const robot = window.gameState.equipped.robot;
          if (robot) {
            window.gameState.equipped.robot = null;
            this.state.equipped.robot = null;
            this.syncLegacyCompanionSlot('robot', null);
            this.showToast(`ğŸ¤– Recalled ${robot.name}`);
            this.renderAITab();
            this.updateStats();
          }
        },

        equipSkin(character, skinId) {
          window.gameState.equippedSkins[character] = skinId;
          const skin = window.gameState.skins[character].find(s => s.id === skinId);
          this.showToast(`ğŸ‘¤ Equipped ${skin.name} on ${character}`);
          this.renderSkinsTab();
        },

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Action functions for all item types
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // Container Actions
        getRandomArrayValue(arr, fallback = null) {
          if (!Array.isArray(arr) || arr.length === 0) return fallback;
          return arr[Math.floor(Math.random() * arr.length)];
        },

        generateRandomMysteryBoxReward() {
          const roll = Math.random();
          const rarityPool = ['common', 'uncommon', 'rare', 'epic', 'legendary'];
          const iconPool = {
            pet: ['ğŸ•', 'ğŸˆ', 'ğŸ‰', 'ğŸ¦Š', 'ğŸ¦…', 'ğŸº'],
            vehicle: ['ğŸš—', 'ğŸï¸', 'ğŸ›¸', 'ğŸ›©ï¸', 'ğŸ›»', 'ğŸš€'],
            robot: ['ğŸ¤–', 'ğŸ› ï¸', 'ğŸ›°ï¸', 'âš™ï¸', 'ğŸ”©'],
            spirit: ['ğŸ”¥', 'â„ï¸', 'ğŸ’¨', 'âš¡', 'ğŸŒŠ', 'ğŸŒªï¸'],
            gear: ['âš”ï¸', 'ğŸ›¡ï¸', 'ğŸ¦¾', 'ğŸ¦¿', 'ğŸ’', 'ğŸª–']
          };

          const makeId = (prefix) => `${prefix}_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
          const reward = { type: null, item: null, amount: 0 };

          if (roll < 0.30) {
            reward.type = 'pet';
            reward.item = {
              id: makeId('pet'),
              name: `${this.getRandomArrayValue(['Flare', 'Nimbus', 'Shadow', 'Aurora', 'Bolt', 'Luna'])} Companion`,
              icon: this.getRandomArrayValue(iconPool.pet, 'ğŸ¾'),
              rarity: this.getRandomArrayValue(rarityPool),
              type: 'pet',
              category: 'pet',
              attack: Math.floor(Math.random() * 40) + 20,
              defense: Math.floor(Math.random() * 30) + 15,
              hp: Math.floor(Math.random() * 150) + 50,
              speed: Math.floor(Math.random() * 5) + 5,
              level: 1
            };
          } else if (roll < 0.50) {
            reward.type = 'vehicle';
            reward.item = {
              id: makeId('vehicle'),
              name: `${this.getRandomArrayValue(['Hyper', 'Nebula', 'Thunder', 'Solar', 'Phantom'])} ${this.getRandomArrayValue(['Cruiser', 'Runner', 'Racer', 'Speeder'])}`,
              icon: this.getRandomArrayValue(iconPool.vehicle, 'ğŸš—'),
              rarity: this.getRandomArrayValue(rarityPool),
              type: 'vehicle',
              category: 'vehicle',
              speed: Math.floor(Math.random() * 40) + 20,
              attack: Math.floor(Math.random() * 20),
              defense: Math.floor(Math.random() * 20),
              hp: Math.floor(Math.random() * 120) + 60
            };
          } else if (roll < 0.65) {
            reward.type = 'robot';
            reward.item = {
              id: makeId('robot'),
              name: `${this.getRandomArrayValue(['Sentinel', 'Aegis', 'Breaker', 'Stalker', 'Guardian'])} Bot`,
              icon: this.getRandomArrayValue(iconPool.robot, 'ğŸ¤–'),
              rarity: this.getRandomArrayValue(rarityPool),
              type: 'robot',
              category: 'robot',
              attack: Math.floor(Math.random() * 35) + 15,
              defense: Math.floor(Math.random() * 35) + 15,
              hp: Math.floor(Math.random() * 160) + 70
            };
          } else if (roll < 0.80) {
            reward.type = 'spirit';
            reward.item = {
              id: makeId('spirit'),
              name: `${this.getRandomArrayValue(['Ember', 'Frost', 'Gale', 'Volt', 'Tide', 'Aurora'])} Spirit`,
              icon: this.getRandomArrayValue(iconPool.spirit, 'âœ¨'),
              rarity: this.getRandomArrayValue(rarityPool),
              type: 'spirit',
              category: 'spirit',
              element: this.getRandomArrayValue(['fire', 'ice', 'wind', 'electric', 'water', 'light', 'shadow']),
              attack: Math.floor(Math.random() * 30) + 10,
              defense: Math.floor(Math.random() * 25) + 10,
              hp: Math.floor(Math.random() * 140) + 40
            };
          } else if (roll < 0.90) {
            reward.type = 'skill';
            const skillsDb = window.UNIFIED_SKILLS_DB || [];
            const pool = skillsDb.length ? skillsDb : (window.gameState.inventory.skills || []);
            const baseSkill = this.getRandomArrayValue(pool);
            if (baseSkill) {
              reward.item = {
                ...JSON.parse(JSON.stringify(baseSkill)),
                id: makeId('skill'),
                unlocked: true,
                level: baseSkill.level || 1
              };
            } else {
              reward.type = 'gold';
              reward.amount = Math.floor(Math.random() * 1500) + 500;
            }
          } else if (roll < 0.95) {
            reward.type = 'gear';
            const gearKeys = window.GearData ? Object.keys(window.GearData.lookup || {}) : [];
            if (gearKeys.length > 0) {
              const templateId = this.getRandomArrayValue(gearKeys);
              reward.item = window.GearData.createInstance(templateId, {
                upgradeLevel: Math.floor(Math.random() * 3)
              });
            } else {
              reward.type = 'gold';
              reward.amount = Math.floor(Math.random() * 2000) + 800;
            }
          } else {
            reward.type = 'gold';
            reward.amount = Math.floor(Math.random() * 2500) + 1000;
          }

          return reward;
        },

        applyMysteryBoxReward(reward, sourceItemName = 'Mystery Box') {
          if (!reward) return;

          const messages = {
            pet: 'ğŸ¾ Adopted',
            vehicle: 'ğŸš— Unlocked',
            robot: 'ğŸ¤– Activated',
            spirit: 'âœ¨ Summoned',
            skill: 'ğŸ”° Learned',
            gear: 'âš”ï¸ Acquired',
            gold: 'ğŸ’° Found'
          };

          if (reward.type === 'gold') {
            const bonus = reward.amount || 0;
            window.gameState.gold += bonus;
            this.showToast(`${messages.gold} ${bonus.toLocaleString()} gold from ${sourceItemName}!`);
            this.addSystemMessage(`ğŸ’° MYSTERY BONUS: ${bonus.toLocaleString()} gold`, 'reward');
            return;
          }

          if (!reward.item) return;

          const item = reward.item;
          let inventoryRef = null;
          switch (reward.type) {
            case 'pet':
              window.gameState.inventory.pets = window.gameState.inventory.pets || [];
              inventoryRef = window.gameState.inventory.pets;
              break;
            case 'vehicle':
              window.gameState.inventory.vehicles = window.gameState.inventory.vehicles || [];
              inventoryRef = window.gameState.inventory.vehicles;
              break;
            case 'robot':
              window.gameState.inventory.robots = window.gameState.inventory.robots || [];
              inventoryRef = window.gameState.inventory.robots;
              break;
            case 'spirit':
              window.gameState.inventory.spirits = window.gameState.inventory.spirits || [];
              inventoryRef = window.gameState.inventory.spirits;
              break;
            case 'skill':
              window.gameState.inventory.skills = window.gameState.inventory.skills || [];
              inventoryRef = window.gameState.inventory.skills;
              break;
            case 'gear':
              window.gameState.inventory.gear = window.gameState.inventory.gear || [];
              inventoryRef = window.gameState.inventory.gear;
              break;
            default:
              window.gameState.inventory.items = window.gameState.inventory.items || [];
              inventoryRef = window.gameState.inventory.items;
              item.category = item.category || 'misc';
              break;
          }

          inventoryRef.push(item);

          const icon = item.icon || messages[reward.type] || 'ğŸ';
          const name = item.name || 'Mystery Reward';
          this.showToast(`${messages[reward.type] || 'ğŸ Reward'} ${icon} ${name}!`);
          this.addSystemMessage(`ğŸ ${sourceItemName}: ${name} added to inventory`, 'reward');
        },

        openContainer(itemId) {
          const item = window.gameState.inventory.items.find(i => i.id === itemId);
          if (!item || item.quantity <= 0) return;

          // Decrease quantity
          item.quantity--;
          if (item.quantity === 0) {
            window.gameState.inventory.items = window.gameState.inventory.items.filter(i => i.id !== itemId);
          }

          const nameLower = (item.name || '').toLowerCase();
          const idLower = (item.id || '').toLowerCase();
          const isMysteryBox = nameLower.includes('mystery') || nameLower.includes('treasure') || idLower.includes('mystery') || idLower.includes('treasure');

          if (isMysteryBox) {
            const reward = this.generateRandomMysteryBoxReward();
            this.applyMysteryBoxReward(reward, item.name || 'Mystery Box');
            this.syncAllSystems();
            this.renderItemsTab();
            return;
          }

          // Roll random loot based on container type
          const lootTable = {
            item_chest_001: { gold: [50, 150], items: ['Health Potion', 'Mana Potion'] },
            item_chest_002: { gold: [100, 300], items: ['Health Potion', 'Mana Potion', 'Iron Sword'] }
          };

          const loot = lootTable[itemId] || { gold: [10, 50], items: [] };
          const goldGain = Math.floor(Math.random() * (loot.gold[1] - loot.gold[0])) + loot.gold[0];
          window.gameState.gold += goldGain;

          this.showToast(`ğŸ“¦ Opened ${item.name}! +${goldGain} gold`);
          this.syncAllSystems();
          this.renderItemsTab();
        },

        bulkOpenContainer(itemId, count) {
          const item = window.gameState.inventory.items.find(i => i.id === itemId);
          if (!item || item.quantity < count) {
            this.showToast(`âš ï¸ Not enough ${item ? item.name : 'items'}`);
            return;
          }

          let totalGold = 0;
          for (let i = 0; i < count; i++) {
            const goldGain = Math.floor(Math.random() * 250) + 50;
            totalGold += goldGain;
          }

          item.quantity -= count;
          if (item.quantity === 0) {
            window.gameState.inventory.items = window.gameState.inventory.items.filter(i => i.id !== itemId);
          }

          window.gameState.gold += totalGold;
          this.showToast(`ğŸ“¦ Opened ${count}x ${item.name}! +${totalGold} gold`);
          this.syncAllSystems();
          this.renderItemsTab();
        },

        // Consumable Actions
        useItem(itemId) {
          const item = window.gameState.inventory.items.find(i => i.id === itemId);
          if (!item || item.quantity <= 0) return;

          item.quantity--;
          if (item.quantity === 0) {
            window.gameState.inventory.items = window.gameState.inventory.items.filter(i => i.id !== itemId);
          }

          // Apply item effects
          if (item.name.includes('Health Potion')) {
            this.showToast(`ğŸ§ª Used ${item.name}! +40% HP`);
          } else if (item.name.includes('Mana Potion')) {
            this.showToast(`ğŸ’™ Used ${item.name}! +50% MP`);
          } else if (item.xpAmount || item.id?.includes('xp_box') || item.name?.includes('XP Box')) {
            // Handle XP Boxes
            const xpAmount = item.xpAmount || (item.id?.includes('low') ? 50 : item.id?.includes('mid') ? 150 : item.id?.includes('high') ? 400 : 100);
            if (typeof this.gainXP === 'function') {
              const result = this.gainXP(xpAmount);
              if (result.levelsGained > 0) {
                this.showToast(`â­ Used ${item.name}! +${xpAmount} XP (Level Up!)`);
              } else {
                this.showToast(`â­ Used ${item.name}! +${xpAmount} XP`);
              }
            } else {
              // Fallback if gainXP not available
              window.gameState.xp = (window.gameState.xp || 0) + xpAmount;
              this.showToast(`â­ Used ${item.name}! +${xpAmount} XP`);
            }
          } else {
            this.showToast(`âœ¨ Used ${item.name}!`);
          }

          this.syncAllSystems();
          this.renderItemsTab();
        },

        useMultiple(itemId, count) {
          const item = window.gameState.inventory.items.find(i => i.id === itemId);
          if (!item || item.quantity < count) {
            this.showToast(`âš ï¸ Not enough ${item ? item.name : 'items'}`);
            return;
          }

          item.quantity -= count;
          if (item.quantity === 0) {
            window.gameState.inventory.items = window.gameState.inventory.items.filter(i => i.id !== itemId);
          }

          this.showToast(`âœ¨ Used ${count}x ${item.name}!`);
          this.syncAllSystems();
          this.renderItemsTab();
        },

        // Gear Actions
        upgradeGear(itemId) {
          const item = window.gameState.inventory.gear.find(i => i.id === itemId);
          if (!item) return;

          const result = this.performGearUpgrade(item);
          if (!result.upgraded) {
            if (result.reason === 'NO_GOLD') {
              this.showToast(`âš ï¸ Need ${result.cost} gold to upgrade`);
            } else if (result.reason === 'MAX_LEVEL') {
              this.showToast('âœ¨ Item already at max upgrade level');
            } else {
              this.showToast('âš ï¸ Unable to upgrade item right now');
            }
            return;
          }

          this.showToast(`â¬†ï¸ ${item.name} upgraded to +${item.upgradeLevel}! (âˆ’${result.cost}g)`);
          this.syncAllSystems();
          this.renderGearTab();
          this.updateStats();
        },

        fuseGear(itemId) {
          const item = window.gameState.inventory.gear.find(i => i.id === itemId);
          if (!item) return;

          // Check if player has 3 of the same rarity
          const sameRarity = window.gameState.inventory.gear.filter(g => g.rarity === item.rarity);
          if (sameRarity.length < 3) {
            this.showToast(`âš ï¸ Need 3 ${item.rarity} items to fuse`);
            return;
          }

          // Remove 3 items of same rarity
          for (let i = 0; i < 3; i++) {
            const idx = window.gameState.inventory.gear.findIndex(g => g.rarity === item.rarity);
            if (idx !== -1) window.gameState.inventory.gear.splice(idx, 1);
          }

          // Create upgraded item
          const rarityMap = { common: 'uncommon', uncommon: 'rare', rare: 'epic', epic: 'legendary' };
          const newRarity = rarityMap[item.rarity] || 'legendary';

          this.showToast(`âœ¨ Fused 3x ${item.rarity} â†’ 1x ${newRarity} item!`);
          this.syncAllSystems();
          this.renderGearTab();
        },

        // Pet Actions
        feedPet(petId) {
          if (window.PetCollectionSystem?.feedPet) {
            const result = window.PetCollectionSystem.feedPet(petId, { source: 'bag-ui' });
            if (result?.success) {
              const petName = result.pet?.name || petId;
              if (result.leveledUp) {
                this.showToast(`ğŸ‰ ${petName} reached Lv.${result.level}!`);
          } else {
                const xpForNext = typeof result.xpForNext === 'number' ? result.xpForNext : '???';
                this.showToast(`ğŸ– ${petName} gained ${result.xpGain} XP (${result.xp}/${xpForNext})`);
          }
          this.syncAllSystems();
          this.renderPetsTab();
              return;
            }
          }
          this.showToast('âš ï¸ Unable to feed pet right now.');
        },

        previewPetFx(petId) {
          const pet = window.gameState.inventory.pets.find(p => p.id === petId);
          if (!pet) {
            this.showToast('âš ï¸ Pet data not ready for preview.');
            return;
          }
          const engine = this.ensureEngine();
          const manager = engine?.systems?.companion || (typeof resolveCompanionManager === 'function' ? resolveCompanionManager() : null);
          if (!manager || typeof manager.previewSummonFx !== 'function') {
            this.showToast('âš ï¸ Companion system warming up...', '#ff6b6b');
            return;
          }
          const sanitized = this.prepareEquippable(pet, 'pet');
          try {
            manager.previewSummonFx('pet', { item: sanitized });
            this.showToast(`âœ¨ Previewing ${pet.name || pet.id} FX`);
          } catch (error) {
            debugWarn('[BagSystem] Failed to preview pet FX', error);
            this.showToast('âš ï¸ Unable to preview FX (see console)', '#ff6b6b');
          }
        },

        evolvePet(petId) {
          if (window.PetCollectionSystem?.evolvePet) {
            const result = window.PetCollectionSystem.evolvePet(petId, { source: 'bag-ui' });
            if (result?.success) {
              const petName = result.pet?.name || petId;
              this.showToast(`ğŸŒŸ ${petName} evolved!`);
          this.syncAllSystems();
          this.renderPetsTab();
              return;
            }
            if (result?.reason === 'INSUFFICIENT_LEVEL') {
              this.showToast('âš ï¸ Pet must reach the required level to evolve');
              return;
            }
            if (result?.reason === 'INSUFFICIENT_GOLD') {
              this.showToast(`âš ï¸ Need ${result.cost} gold to evolve`);
              return;
            }
          }
          this.showToast('âš ï¸ Unable to evolve pet right now.');
        },

        // Vehicle Actions
        upgradeVehicle(vehicleId) {
          const vehicle = window.gameState.inventory.vehicles.find(v => v.id === vehicleId);
          if (!vehicle) return;

          // Solo Leveling: Multiply upgrade costs by 100 for high-stakes economy
          const upgradeCost = 800 * 100;
          if (window.gameState.gold < upgradeCost) {
            this.showToast(`âš ï¸ Need ${upgradeCost.toLocaleString()} gold to upgrade`);
            return;
          }

          vehicle.speed = parseFloat((vehicle.speed * 1.15).toFixed(2));
          vehicle.durability = parseFloat((vehicle.durability * 1.15).toFixed(2));

          window.gameState.gold -= upgradeCost;
          this.showToast(`â¬†ï¸ Upgraded ${vehicle.name}! +15% speed & durability`);
          this.syncAllSystems();
          this.renderVehiclesTab();
        },

        customizeVehicle(vehicleId) {
          const vehicle = window.gameState.inventory.vehicles.find(v => v.id === vehicleId);
          if (!vehicle) return;

          const colors = ['ğŸ”´', 'ğŸ”µ', 'ğŸŸ¢', 'ğŸŸ¡', 'ğŸŸ£', 'ğŸŸ '];
          const randomColor = colors[Math.floor(Math.random() * colors.length)];

          this.showToast(`ğŸ¨ Customized ${vehicle.name} with ${randomColor} color!`);
        },

        // Robot Actions
        repairRobot(robotId) {
          const robot = window.gameState.inventory.robots.find(r => r.id === robotId);
          if (!robot) return;

          const repairCost = 300;
          if (window.gameState.gold < repairCost) {
            this.showToast(`âš ï¸ Need ${repairCost} gold to repair`);
            return;
          }

          window.gameState.gold -= repairCost;
          this.showToast(`ğŸ”§ Repaired ${robot.name}! HP restored to max`);
          this.syncAllSystems();
          this.renderAITab();
        },

        upgradeRobot(robotId) {
          const robot = window.gameState.inventory.robots.find(r => r.id === robotId);
          if (!robot) return;

          const upgradeCost = 1000;
          if (window.gameState.gold < upgradeCost) {
            this.showToast(`âš ï¸ Need ${upgradeCost} gold to upgrade`);
            return;
          }

          robot.atk = Math.floor(robot.atk * 1.2);
          robot.def = Math.floor(robot.def * 1.2);
          robot.hp = Math.floor(robot.hp * 1.2);

          window.gameState.gold -= upgradeCost;
          this.showToast(`â¬†ï¸ Upgraded ${robot.name}! +20% ATK/DEF/HP`);
          this.syncAllSystems();
          this.renderAITab();
        },

        // Spirit Actions
        enhanceSpirit(spiritId) {
          const spirit = window.gameState.inventory.spirits.find(s => s.id === spiritId);
          if (!spirit) return;

          const enhanceCost = 500;
          if (window.gameState.gold < enhanceCost) {
            this.showToast(`âš ï¸ Need ${enhanceCost} gold to enhance`);
            return;
          }

          spirit.power = Math.floor(spirit.power * 1.1);
          spirit.attackDamage = Math.floor(spirit.attackDamage * 1.1);

          window.gameState.gold -= enhanceCost;
          this.showToast(`âœ¨ Enhanced ${spirit.name}! +10% power`);
          this.syncAllSystems();
          this.renderSpiritTab();
        },

        mergeSpirits(spiritId) {
          const spirit = window.gameState.inventory.spirits.find(s => s.id === spiritId);
          if (!spirit) return;

          const sameElement = window.gameState.inventory.spirits.filter(s => s.element === spirit.element);
          if (sameElement.length < 2) {
            this.showToast(`âš ï¸ Need 2 ${spirit.element} spirits to merge`);
            return;
          }

          // Remove 2 spirits of same element
          for (let i = 0; i < 2; i++) {
            const idx = window.gameState.inventory.spirits.findIndex(s => s.element === spirit.element);
            if (idx !== -1) window.gameState.inventory.spirits.splice(idx, 1);
          }

          this.showToast(`ğŸŒŸ Merged 2x ${spirit.element} spirits into stronger spirit!`);
          this.syncAllSystems();
          this.renderSpiritTab();
        },

        // Skin Actions
        previewSkin(character, skinId) {
          const skin = window.gameState.skins[character].find(s => s.id === skinId);
          if (!skin) return;

          this.showToast(`ğŸ‘ï¸ Previewing ${skin.name} for ${character}`);
          // In full implementation, this would show a modal with 8-bit sprite preview
        },

        unlockSkin(character, skinId) {
          const skin = window.gameState.skins[character].find(s => s.id === skinId);
          if (!skin) return;

          const unlockCost = 1500;
          if (window.gameState.gold < unlockCost) {
            this.showToast(`âš ï¸ Need ${unlockCost} gold to unlock`);
            return;
          }

          skin.unlocked = true;
          window.gameState.gold -= unlockCost;
          this.showToast(`ğŸ”“ Unlocked ${skin.name} for ${character}!`);
          this.syncAllSystems();
          this.renderSkinsTab();
        },

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // 8-bit sprite system for supernatural abilities
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // CHIBI CANDY VECTOR SPRITE SYSTEM (from ALL_SYSTEMS_CHIBI_DEMO)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        drawCandyAbility(canvasId, abilityId) {
          const canvas = document.getElementById(canvasId);
          if (!canvas) return;

          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const cx = 24, cy = 24;
          const pulse = Math.sin(Date.now() * 0.004) * 0.5 + 0.5;

          if (abilityId === 'divine_barrier') {
            // Golden Shield with glow
            ctx.shadowColor = '#FFD700';
            ctx.shadowBlur = 8;

            const grad = ctx.createRadialGradient(cx, cy, 3, cx, cy, 11);
            grad.addColorStop(0, '#FFF');
            grad.addColorStop(0.4, '#FFD700');
            grad.addColorStop(0.8, '#FFA500');
            grad.addColorStop(1, '#FF8C00');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.moveTo(cx, cy - 11);
            ctx.quadraticCurveTo(cx + 9, cy - 6, cx + 9, cy + 2);
            ctx.quadraticCurveTo(cx + 7, cy + 8, cx, cy + 12);
            ctx.quadraticCurveTo(cx - 7, cy + 8, cx - 9, cy + 2);
            ctx.quadraticCurveTo(cx - 9, cy - 6, cx, cy - 11);
            ctx.closePath();
            ctx.fill();

            ctx.shadowBlur = 0;
            ctx.strokeStyle = '#8B4513';
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Cross
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 1.5;
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.moveTo(cx, cy - 6);
            ctx.lineTo(cx, cy + 6);
            ctx.moveTo(cx - 5, cy);
            ctx.lineTo(cx + 5, cy);
            ctx.stroke();
            ctx.globalAlpha = 1;

          } else if (abilityId === 'dash_nova') {
            // Lightning Bolt
            ctx.shadowColor = '#00FFFF';
            ctx.shadowBlur = 10;

            const grad = ctx.createLinearGradient(cx, cy - 12, cx, cy + 12);
            grad.addColorStop(0, '#FFF');
            grad.addColorStop(0.3, '#00FFFF');
            grad.addColorStop(0.7, '#0080FF');
            grad.addColorStop(1, '#4169E1');
            ctx.fillStyle = grad;

            ctx.beginPath();
            ctx.moveTo(cx + 3, cy - 11);
            ctx.lineTo(cx - 2, cy - 1);
            ctx.lineTo(cx + 2, cy - 1);
            ctx.lineTo(cx - 4, cy + 11);
            ctx.lineTo(cx + 1, cy + 2);
            ctx.lineTo(cx - 2, cy + 2);
            ctx.closePath();
            ctx.fill();

            ctx.shadowBlur = 0;
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1.2;
            ctx.stroke();

            // Electric sparks
            ctx.strokeStyle = '#FFF';
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.7 + pulse * 0.3;
            for (let i = 0; i < 4; i++) {
              const angle = (i / 4) * Math.PI * 2;
              const r = 10;
              ctx.beginPath();
              ctx.moveTo(cx + Math.cos(angle) * r, cy + Math.sin(angle) * r);
              ctx.lineTo(cx + Math.cos(angle) * (r + 2), cy + Math.sin(angle) * (r + 2));
              ctx.stroke();
            }
            ctx.globalAlpha = 1;

          } else if (abilityId === 'angelic_might') {
            // Angel Wings
            ctx.shadowColor = '#FFE6F0';
            ctx.shadowBlur = 12;

            const grad = ctx.createRadialGradient(cx, cy, 2, cx, cy, 12);
            grad.addColorStop(0, '#FFF');
            grad.addColorStop(0.5, '#FFE6F0');
            grad.addColorStop(0.8, '#FFB6D9');
            grad.addColorStop(1, '#FF69B4');

            // Left wing
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.moveTo(cx - 2, cy);
            ctx.bezierCurveTo(cx - 11, cy - 8, cx - 10, cy - 1, cx - 6, cy + 4);
            ctx.bezierCurveTo(cx - 8, cy + 2, cx - 9, cy + 5, cx - 11, cy + 7);
            ctx.bezierCurveTo(cx - 8, cy + 4, cx - 5, cy + 2, cx - 2, cy + 2);
            ctx.closePath();
            ctx.fill();

            // Right wing
            ctx.beginPath();
            ctx.moveTo(cx + 2, cy);
            ctx.bezierCurveTo(cx + 11, cy - 8, cx + 10, cy - 1, cx + 6, cy + 4);
            ctx.bezierCurveTo(cx + 8, cy + 2, cx + 9, cy + 5, cx + 11, cy + 7);
            ctx.bezierCurveTo(cx + 8, cy + 4, cx + 5, cy + 2, cx + 2, cy + 2);
            ctx.closePath();
            ctx.fill();

            ctx.shadowBlur = 0;
            ctx.strokeStyle = '#FF1493';
            ctx.lineWidth = 1;
            ctx.stroke();

            // Halo
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 1.5;
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.arc(cx, cy - 8, 4, 0, Math.PI * 2);
            ctx.stroke();
            ctx.globalAlpha = 1;

          } else if (abilityId === 'flame_dash') {
            // Triple Flames
            ctx.shadowColor = '#FF4500';
            ctx.shadowBlur = 10;

            for (let i = 0; i < 3; i++) {
              const xOff = (i - 1) * 7;
              const yOff = Math.abs(i - 1) * 2;

              const grad = ctx.createLinearGradient(cx + xOff, cy + yOff - 8, cx + xOff, cy + yOff + 8);
              grad.addColorStop(0, '#FFFF00');
              grad.addColorStop(0.3, '#FFA500');
              grad.addColorStop(0.6, '#FF4500');
              grad.addColorStop(1, '#8B0000');

              ctx.fillStyle = grad;
              ctx.beginPath();
              ctx.moveTo(cx + xOff, cy + yOff + 6);
              ctx.quadraticCurveTo(cx + xOff - 4, cy + yOff + 2, cx + xOff - 3, cy + yOff - 4);
              ctx.quadraticCurveTo(cx + xOff - 2, cy + yOff - 8, cx + xOff, cy + yOff - 10);
              ctx.quadraticCurveTo(cx + xOff + 2, cy + yOff - 8, cx + xOff + 3, cy + yOff - 4);
              ctx.quadraticCurveTo(cx + xOff + 4, cy + yOff + 2, cx + xOff, cy + yOff + 6);
              ctx.closePath();
              ctx.fill();

              ctx.strokeStyle = '#8B0000';
              ctx.lineWidth = 1;
              ctx.stroke();
            }
            ctx.shadowBlur = 0;

          } else if (abilityId === 'radiant_burst') {
            // 8-Pointed Star
            ctx.shadowColor = '#FFFF00';
            ctx.shadowBlur = 15;

            const grad = ctx.createRadialGradient(cx, cy, 2, cx, cy, 10);
            grad.addColorStop(0, '#FFF');
            grad.addColorStop(0.4, '#FFFF00');
            grad.addColorStop(0.8, '#FFD700');
            grad.addColorStop(1, '#FFA500');

            for (let i = 0; i < 8; i++) {
              const angle = (i / 8) * Math.PI * 2 - Math.PI / 2;
              const angle2 = ((i + 0.5) / 8) * Math.PI * 2 - Math.PI / 2;

              ctx.fillStyle = grad;
              ctx.beginPath();
              ctx.moveTo(cx, cy);
              ctx.lineTo(cx + Math.cos(angle) * 11, cy + Math.sin(angle) * 11);
              ctx.lineTo(cx + Math.cos(angle2) * 5, cy + Math.sin(angle2) * 5);
              ctx.closePath();
              ctx.fill();

              ctx.strokeStyle = '#FF8C00';
              ctx.lineWidth = 1;
              ctx.stroke();
            }

            ctx.shadowBlur = 0;
            ctx.fillStyle = '#FFF';
            ctx.beginPath();
            ctx.arc(cx, cy, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 1.5;
            ctx.stroke();

          } else if (abilityId === 'eternal_wisdom') {
            // Magic Book
            ctx.shadowColor = '#9370DB';
            ctx.shadowBlur = 8;

            const bookGrad = ctx.createLinearGradient(cx - 6, cy - 8, cx + 6, cy + 8);
            bookGrad.addColorStop(0, '#9370DB');
            bookGrad.addColorStop(0.5, '#8A2BE2');
            bookGrad.addColorStop(1, '#6A0DAD');
            ctx.fillStyle = bookGrad;
            ctx.fillRect(cx - 6, cy - 8, 12, 16);

            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1.5;
            ctx.strokeRect(cx - 6, cy - 8, 12, 16);

            // Pages
            ctx.fillStyle = '#FFF8DC';
            ctx.fillRect(cx - 5, cy - 7, 10, 14);
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 0.5;
            ctx.strokeRect(cx - 5, cy - 7, 10, 14);

            // Runes
            ctx.strokeStyle = '#FFD700';
            ctx.lineWidth = 1;
            for (let i = 0; i < 3; i++) {
              ctx.beginPath();
              ctx.moveTo(cx - 4, cy - 4 + i * 4);
              ctx.lineTo(cx + 4, cy - 4 + i * 4);
              ctx.stroke();
            }
            ctx.shadowBlur = 0;

          } else if (abilityId === 'warriors_heart') {
            // Candy Heart
            ctx.shadowColor = '#FF1493';
            ctx.shadowBlur = 12;

            const heartGrad = ctx.createRadialGradient(cx, cy, 3, cx, cy, 12);
            heartGrad.addColorStop(0, '#FFF');
            heartGrad.addColorStop(0.3, '#FFB6C1');
            heartGrad.addColorStop(0.7, '#FF69B4');
            heartGrad.addColorStop(1, '#FF1493');

            ctx.fillStyle = heartGrad;
            ctx.beginPath();
            ctx.moveTo(cx, cy + 8);
            ctx.bezierCurveTo(cx - 10, cy + 4, cx - 10, cy - 4, cx, cy - 8);
            ctx.bezierCurveTo(cx + 10, cy - 4, cx + 10, cy + 4, cx, cy + 8);
            ctx.closePath();
            ctx.fill();

            ctx.shadowBlur = 0;
            ctx.strokeStyle = '#8B0000';
            ctx.lineWidth = 1.5;
            ctx.stroke();

            // Highlight
            ctx.fillStyle = '#FFF';
            ctx.globalAlpha = 0.6;
            ctx.beginPath();
            ctx.arc(cx - 3, cy - 2, 3, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;
          }
        },

        drawChibiGhost(canvasId, spiritId) {
          const canvas = document.getElementById(canvasId);
          if (!canvas) return;

          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const cx = 24, cy = 24;
          const bob = Math.sin(Date.now() * 0.003) * 2;

          const spiritColors = {
            dark_soul: ['#7c3aed', '#9b59b6', '#d5c9e8'],
            light_soul: ['#FFD700', '#FFA500', '#FFFFE0'],
            golden_spirit: ['#FFD700', '#FFB300', '#FFFFE0'],
            tech_essence: ['#0080FF', '#00BFFF', '#E0FFFF'],
            storm_wisp: ['#4169E1', '#00BFFF', '#FFFFFF'],
            guardian_sand: ['#8B4513', '#D2691E', '#F4A460'],
            ember_fox: ['#FF4500', '#FFA500', '#FFFF00']
          };

          const col = spiritColors[spiritId] || ['#9b59b6', '#c084fc', '#e9d5ff'];

          // Glow aura
          ctx.shadowColor = col[1];
          ctx.shadowBlur = 15;

          // Ghost body
          const bodyGrad = ctx.createRadialGradient(cx, cy - 2 + bob, 3, cx, cy - 2 + bob, 16);
          bodyGrad.addColorStop(0, col[2]);
          bodyGrad.addColorStop(0.6, col[1]);
          bodyGrad.addColorStop(1, col[0]);

          ctx.fillStyle = bodyGrad;
          ctx.globalAlpha = 0.85;
          ctx.beginPath();
          ctx.arc(cx, cy - 2 + bob, 14, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;

          // Wavy tail
          ctx.fillStyle = col[1];
          ctx.globalAlpha = 0.7;
          ctx.beginPath();
          ctx.moveTo(cx - 10, cy + 10 + bob);
          ctx.quadraticCurveTo(cx - 5, cy + 14 + bob, cx, cy + 12 + bob);
          ctx.quadraticCurveTo(cx + 5, cy + 10 + bob, cx + 10, cy + 14 + bob);
          ctx.lineTo(cx + 10, cy + 8 + bob);
          ctx.lineTo(cx - 10, cy + 8 + bob);
          ctx.closePath();
          ctx.fill();
          ctx.globalAlpha = 1;

          ctx.shadowBlur = 0;

          // Outline
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(cx, cy - 2 + bob, 14, 0, Math.PI);
          ctx.stroke();

          // Cute eyes
          ctx.fillStyle = '#000';
          ctx.beginPath();
          ctx.arc(cx - 5, cy - 5 + bob, 3, 0, Math.PI * 2);
          ctx.arc(cx + 5, cy - 5 + bob, 3, 0, Math.PI * 2);
          ctx.fill();

          // Eye sparkle
          ctx.fillStyle = '#FFF';
          ctx.beginPath();
          ctx.arc(cx - 4, cy - 6 + bob, 1, 0, Math.PI * 2);
          ctx.arc(cx + 6, cy - 6 + bob, 1, 0, Math.PI * 2);
          ctx.fill();

          // Mouth
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.arc(cx, cy + 2 + bob, 4, 0, Math.PI);
          ctx.stroke();
        },

        drawCandyIcon(canvasId, itemType) {
          const canvas = document.getElementById(canvasId);
          if (!canvas) return;

          const ctx = canvas.getContext('2d');
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          const cx = 12, cy = 12;

          if (itemType === 'chest' || itemType === 'giftbox') {
            // Candy Gift Box
            ctx.shadowColor = '#FFD700';
            ctx.shadowBlur = 6;

            const boxGrad = ctx.createLinearGradient(cx - 8, cy - 6, cx + 8, cy + 6);
            boxGrad.addColorStop(0, '#FF69B4');
            boxGrad.addColorStop(0.5, '#FFB6D9');
            boxGrad.addColorStop(1, '#FF1493');
            ctx.fillStyle = boxGrad;
            ctx.fillRect(cx - 8, cy - 4, 16, 12);

            ctx.strokeStyle = '#8B0045';
            ctx.lineWidth = 1.5;
            ctx.strokeRect(cx - 8, cy - 4, 16, 12);

            // Ribbon
            ctx.fillStyle = '#FFD700';
            ctx.fillRect(cx - 1, cy - 6, 2, 14);
            ctx.fillRect(cx - 8, cy - 2, 16, 2);

            // Bow
            ctx.beginPath();
            ctx.arc(cx - 4, cy - 6, 3, 0, Math.PI * 2);
            ctx.arc(cx + 4, cy - 6, 3, 0, Math.PI * 2);
            ctx.fill();

            ctx.shadowBlur = 0;

          } else if (itemType === 'potion') {
            // Candy Potion Bottle
            ctx.shadowColor = '#00FFFF';
            ctx.shadowBlur = 8;

            const potionGrad = ctx.createLinearGradient(cx - 4, cy - 6, cx + 4, cy + 6);
            potionGrad.addColorStop(0, '#00FFFF');
            potionGrad.addColorStop(0.5, '#0080FF');
            potionGrad.addColorStop(1, '#4169E1');

            // Bottle body
            ctx.fillStyle = potionGrad;
            ctx.globalAlpha = 0.8;
            ctx.beginPath();
            ctx.roundRect(cx - 4, cy - 4, 8, 10, 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            // Bottle outline
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1.5;
            ctx.strokeRect(cx - 4, cy - 4, 8, 10);

            // Cork
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(cx - 3, cy - 6, 6, 2);

            // Bubbles
            ctx.fillStyle = '#FFF';
            ctx.globalAlpha = 0.6;
            ctx.beginPath();
            ctx.arc(cx - 2, cy, 1.5, 0, Math.PI * 2);
            ctx.arc(cx + 2, cy + 2, 1, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalAlpha = 1;

            ctx.shadowBlur = 0;
          }
        },

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Alchemy upgrade system & probability tables
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        ALCHEMY_TIER_COSTS: {
          1: { cost: 0, name: 'Novice Alchemist', color: '#9ca3af' },
          2: { cost: 10000, name: 'Apprentice', color: '#22c55e' },
          3: { cost: 25000, name: 'Expert', color: '#3b82f6' },
          4: { cost: 40000, name: 'Master', color: '#9333ea' },
          5: { cost: 100000, name: 'Grandmaster', color: '#ffd700' }
        },
        
        OUTCOME_PROBABILITIES: {
          tier1: { perfect: 0.05, great: 0.15, good: 0.40, basic: 0.30, failure: 0.10 },
          tier2: { perfect: 0.10, great: 0.20, good: 0.45, basic: 0.20, failure: 0.05 },
          tier3: { perfect: 0.15, great: 0.25, good: 0.45, basic: 0.13, failure: 0.02 },
          tier4: { perfect: 0.20, great: 0.30, good: 0.40, basic: 0.09, failure: 0.01 },
          tier5: { perfect: 0.25, great: 0.35, good: 0.30, basic: 0.05, failure: 0.05 }
        },
        
        RECIPE_VARIATIONS: {
          weapon: [
            { name: 'Sword', icon: 'âš”ï¸', atkBonus: 1.0 },
            { name: 'Axe', icon: 'ğŸª“', atkBonus: 1.2, speedPenalty: 0.8 },
            { name: 'Mace', icon: 'ğŸ”¨', atkBonus: 1.1, defBonus: 1.1 },
            { name: 'Staff', icon: 'ğŸª„', atkBonus: 0.9, special: 'magic' },
            { name: 'Bow', icon: 'ğŸ¹', atkBonus: 0.95, speedBonus: 1.2 },
            { name: 'Dagger', icon: 'ğŸ—¡ï¸', atkBonus: 0.85, speedBonus: 1.4 }
          ],
          pet: [
            { name: 'Combat', icon: 'ğŸ•â€ğŸ¦º', atkBonus: 1.3, hpBonus: 1.1 },
            { name: 'Support', icon: 'ğŸˆ', defBonus: 1.3, hpBonus: 1.2 },
            { name: 'Scout', icon: 'ğŸ¦', speedBonus: 1.5, atkBonus: 0.8 },
            { name: 'Tank', icon: 'ğŸ¢', hpBonus: 1.6, defBonus: 1.3, atkPenalty: 0.7 },
            { name: 'Hybrid', icon: 'ğŸ¦Š', balanced: true }
          ],
          armor: [
            { name: 'Light', icon: 'ğŸ§¥', defBonus: 0.8, speedBonus: 1.3 },
            { name: 'Medium', icon: 'ğŸ›¡ï¸', balanced: true },
            { name: 'Heavy', icon: 'âš”ï¸', defBonus: 1.4, hpBonus: 1.2, speedPenalty: 0.7 },
            { name: 'Robe', icon: 'ğŸ‘˜', defBonus: 0.7, special: 'magic' },
            { name: 'Plate', icon: 'ğŸ›¡ï¸', defBonus: 1.5, hpBonus: 1.3, speedPenalty: 0.6 }
          ],
          vehicle: [
            { name: 'Racer', icon: 'ğŸï¸', speedBonus: 1.5 },
            { name: 'Tank', icon: 'ğŸš™', hpBonus: 1.5, speedPenalty: 0.7 },
            { name: 'Hover', icon: 'ğŸ›¸', speedBonus: 1.3, special: 'flight' }
          ],
          robot: [
            { name: 'Combat', icon: 'ğŸ¤–', atkBonus: 1.3, defBonus: 1.1 },
            { name: 'Defense', icon: 'ğŸ›¡ï¸', defBonus: 1.4, hpBonus: 1.2 },
            { name: 'Scout', icon: 'ğŸ”­', speedBonus: 1.4 }
          ]
        },
        
        RARE_AFFIXES: [
          { name: 'of Power', stat: 'attack', bonus: 0.15, tier: 2 },
          { name: 'of Fortitude', stat: 'defense', bonus: 0.15, tier: 2 },
          { name: 'of Vitality', stat: 'hp', bonus: 0.20, tier: 2 },
          { name: 'of Swiftness', stat: 'speed', bonus: 0.25, tier: 2 },
          { name: 'of the Titan', stat: 'all', bonus: 0.10, tier: 3 },
          { name: 'of Excellence', stat: 'all', bonus: 0.15, tier: 4 },
          { name: 'of Mastery', stat: 'primary', bonus: 0.25, tier: 4 },
          { name: 'of Legends', stat: 'all', bonus: 0.25, tier: 5 }
        ],
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ALCHEMY UPGRADE & RANDOM OUTCOME FUNCTIONS
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        upgradeAlchemyTier(tier) {
          const upgrades = window.gameState.alchemyUpgrades;
          const tierData = this.ALCHEMY_TIER_COSTS[tier];
          
          if (!tierData) {
            this.showToast('âš ï¸ Invalid tier!');
            return;
          }
          
          if (upgrades.unlockedTiers.includes(tier)) {
            this.showToast('âš ï¸ Tier already unlocked!');
            return;
          }
          
          // Require sequential unlocking - must unlock previous tier first
          if (tier > 1 && !upgrades.unlockedTiers.includes(tier - 1)) {
            this.showToast(`âŒ Unlock ${this.ALCHEMY_TIER_COSTS[tier - 1].name} (Tier ${tier - 1}) first!`);
            return;
          }
          
          if (window.gameState.gold < tierData.cost) {
            this.showToast(`âŒ Need ${tierData.cost.toLocaleString()}g to unlock ${tierData.name}!`);
            return;
          }
          
          // Unlock tier
          window.gameState.gold -= tierData.cost;
          upgrades.currentTier = tier;
          upgrades.unlockedTiers.push(tier);
          upgrades.totalSpent += tierData.cost;
          
          // Update bonus rates progressively
          if (tier >= 2) upgrades.bonusRates.rareAffixChance = 0.05;
          if (tier >= 3) upgrades.bonusRates.rareAffixChance = 0.10;
          if (tier >= 4) upgrades.bonusRates.rareAffixChance = 0.20;
          if (tier >= 5) {
            upgrades.bonusRates.rareAffixChance = 0.30;
            upgrades.bonusRates.doubleOutputChance = 0.10;
          }
          
          this.showToast(`ğŸ‰ Unlocked ${tierData.name}! Total invested: ${upgrades.totalSpent.toLocaleString()}g`);
          this.addSystemMessage(`âš—ï¸ ALCHEMY MASTERY: Reached ${tierData.name} tier! Better recipes unlocked!`, 'reward');
          this.createParticleEffect('levelup', window.innerWidth / 2, window.innerHeight / 2);
          this.renderAlchemyTab();
        },
        
        upgradeAllAlchemyTiers() {
          const upgrades = window.gameState.alchemyUpgrades;
          const currentTier = upgrades.currentTier;
          
          // Calculate total cost for remaining tiers
          let totalCost = 0;
          const tiersToUnlock = [];
          for (let tier = currentTier + 1; tier <= 5; tier++) {
            if (!upgrades.unlockedTiers.includes(tier)) {
              totalCost += this.ALCHEMY_TIER_COSTS[tier].cost;
              tiersToUnlock.push(tier);
            }
          }
          
          if (tiersToUnlock.length === 0) {
            this.showToast('âœ… All tiers already unlocked!');
            return;
          }
          
          if (window.gameState.gold < totalCost) {
            this.showToast(`âŒ Need ${totalCost.toLocaleString()}g to unlock all remaining tiers! (Have: ${window.gameState.gold.toLocaleString()}g)`);
            return;
          }
          
          // Unlock all remaining tiers
          window.gameState.gold -= totalCost;
          upgrades.totalSpent += totalCost;
          
          tiersToUnlock.forEach(tier => {
            upgrades.currentTier = tier;
            upgrades.unlockedTiers.push(tier);
          });
          
          // Update bonus rates to max
          upgrades.bonusRates.rareAffixChance = 0.30;
          upgrades.bonusRates.doubleOutputChance = 0.10;
          
          this.showToast(`ğŸ‰ Unlocked ${tiersToUnlock.length} tiers! Total invested: ${upgrades.totalSpent.toLocaleString()}g`);
          this.addSystemMessage(`âš—ï¸ ALCHEMY GRANDMASTER: Unlocked all tiers! Maximum alchemy power achieved!`, 'reward');
          this.createParticleEffect('celebration', window.innerWidth / 2, window.innerHeight / 2);
          this.renderAlchemyTab();
        },
        
        rollRandomOutcome(probabilityTable) {
          const roll = Math.random();
          let cumulative = 0;
          
          for (const [outcome, probability] of Object.entries(probabilityTable)) {
            cumulative += probability;
            if (roll <= cumulative) {
              return outcome;
            }
          }
          return 'good'; // Fallback
        },
        
        generateRandomVariation(baseType) {
          const variations = this.RECIPE_VARIATIONS[baseType];
          if (!variations || variations.length === 0) return null;
          
          return variations[Math.floor(Math.random() * variations.length)];
        },
        
        applyRareAffix(item, tier) {
          const availableAffixes = this.RARE_AFFIXES.filter(a => a.tier <= tier);
          if (availableAffixes.length === 0) return item;
          
          const affix = availableAffixes[Math.floor(Math.random() * availableAffixes.length)];
          
          // Apply affix bonus
          if (affix.stat === 'all') {
            if (item.attack) item.attack = Math.floor(item.attack * (1 + affix.bonus));
            if (item.defense) item.defense = Math.floor(item.defense * (1 + affix.bonus));
            if (item.hp) item.hp = Math.floor(item.hp * (1 + affix.bonus));
            if (item.speed) item.speed = Math.floor(item.speed * (1 + affix.bonus));
          } else if (affix.stat === 'primary') {
            // Boost highest stat
            const stats = { attack: item.attack || 0, defense: item.defense || 0, hp: item.hp || 0, speed: item.speed || 0 };
            const primary = Object.keys(stats).reduce((a, b) => stats[a] > stats[b] ? a : b);
            if (item[primary]) item[primary] = Math.floor(item[primary] * (1 + affix.bonus));
          } else if (item[affix.stat]) {
            item[affix.stat] = Math.floor(item[affix.stat] * (1 + affix.bonus));
          }
          
          item.name += ' ' + affix.name;
          item.hasAffix = true;
          
          return item;
        },
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ALCHEMY DRAG-DROP LOGIC
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        getItemQuantity(itemId) {
          // Check how many of this item are available across all inventories
          let totalQuantity = 0;
          
          // Check items inventory (stackable)
          const item = window.gameState.inventory.items?.find(i => i.id === itemId);
          if (item) {
            totalQuantity = item.quantity || 1;
          }
          
          // Check gear inventory (non-stackable, count occurrences)
          const gearCount = window.gameState.inventory.gear?.filter(g => g.id === itemId).length || 0;
          totalQuantity += gearCount;
          
          // Check pets inventory (non-stackable)
          const petCount = window.gameState.inventory.pets?.filter(p => p.id === itemId).length || 0;
          totalQuantity += petCount;
          
          // Check spirits inventory (non-stackable)
          const spiritCount = window.gameState.inventory.spirits?.filter(s => s.id === itemId).length || 0;
          totalQuantity += spiritCount;
          
          // Check vehicles inventory (non-stackable)
          const vehicleCount = window.gameState.inventory.vehicles?.filter(v => v.id === itemId).length || 0;
          totalQuantity += vehicleCount;
          
          // Check robots inventory (non-stackable)
          const robotCount = window.gameState.inventory.robots?.filter(r => r.id === itemId).length || 0;
          totalQuantity += robotCount;
          
          return totalQuantity;
        },

        addToAlchemySlot(item) {
          // Find first empty slot
          const emptySlotIndex = this.state.alchemySlots.findIndex(slot => slot === null);
          if (emptySlotIndex === -1) {
            this.showToast('âš ï¸ All slots are full! Remove an item first.');
            return;
          }
          
          // Check how many times this item is already in alchemy slots
          const slotsUsed = this.state.alchemySlots.filter(slot => slot && slot.id === item.id).length;
          
          // Check available quantity
          const availableQuantity = this.getItemQuantity(item.id);
          
        // Some templates may not track quantity; default to 1 when present in inventory
        const effectiveQuantity = availableQuantity > 0 ? availableQuantity : 1;
        
          // Validate quantity
        if (slotsUsed >= effectiveQuantity) {
          this.showToast(`âš ï¸ You only have ${effectiveQuantity} of this item! Already used in ${slotsUsed} slot(s).`);
            return;
          }

          // Clone item to prevent reference issues
          this.state.alchemySlots[emptySlotIndex] = { ...item };
          this.calculateAlchemyResult();
          
          // Force re-render with small delay to prevent stuck state
          setTimeout(() => {
            if (this.state.activeTab === 'items' && this.state.itemsSubtab === 'alchemy') {
              this.renderAlchemyWorkspace();
            } else if (this.state.activeTab === 'alchemy') {
              this.renderAlchemyTab();
            }
          }, 10);
        },

        removeFromAlchemySlot(slotIndex) {
          if (this.state.alchemySlots[slotIndex]) {
            this.state.alchemySlots[slotIndex] = null;
            this.calculateAlchemyResult();
            
            // Force re-render with small delay
            setTimeout(() => {
              if (this.state.activeTab === 'items' && this.state.itemsSubtab === 'alchemy') {
                this.renderAlchemyWorkspace();
              } else if (this.state.activeTab === 'alchemy') {
                this.renderAlchemyTab();
              }
            }, 10);
          }
        },

        clearAlchemySlots() {
          this.state.alchemySlots = [null, null, null];
          this.state.alchemyResult = null;
          
          // Force re-render
          setTimeout(() => {
            if (this.state.activeTab === 'items' && this.state.itemsSubtab === 'alchemy') {
              this.renderAlchemyWorkspace();
            } else if (this.state.activeTab === 'alchemy') {
              this.renderAlchemyTab();
            }
          }, 10);
        },

        calculateAlchemyResult() {
          const slots = this.state.alchemySlots.filter(s => s !== null);
          if (slots.length !== 3) {
            this.state.alchemyResult = null;
            return;
          }

          // Calculate total value of input items for reward scaling
          let totalValue = 0;
          slots.forEach(item => {
            const baseCost = item.cost || item.basePrice || 100;
            const statsValue = (item.attack || 0) + (item.defense || 0) + (item.hp || 0) / 2 + (item.speed || 0) * 10;
            const rarityMult = {
              common: 1, uncommon: 2, rare: 4, epic: 8, legendary: 15
            }[item.rarity || 'common'] || 1;
            totalValue += (baseCost + statsValue) * rarityMult;
          });
          
          this.state.alchemyInputValue = totalValue;

          // === ENDLESS ALCHEMY COMBOS: Cross-Type Recipes ===
          const normalizedTypes = slots.map(item => this.getItemTypeKey(item) || 'unknown');
          const typeCounts = {};
          normalizedTypes.forEach(type => {
            typeCounts[type] = (typeCounts[type] || 0) + 1;
          });
          const typeSet = new Set();
          normalizedTypes.forEach(type => {
            typeSet.add(type);
            if (type === 'core') typeSet.add('cores');
            if (type === 'box') typeSet.add('container');
            if (type === 'consumable') typeSet.add('items');
          });
          const types = normalizedTypes;
          const scrollCount = typeCounts.scroll || 0;
          const boxCount = typeCounts.box || 0;
          const consumableCount = typeCounts.consumable || 0;
          if (types.includes('unknown')) {
            debugWarn('[ALCHEMY] Items missing type/category detected:', slots.map(item => item?.name));
          }
          const rarities = slots.map(s => s.rarity).filter(r => r);
          const avgRarity = rarities.length > 0 ? rarities[0] : 'common';
          const rarityMap = { common: 'uncommon', uncommon: 'rare', rare: 'epic', epic: 'legendary' };
          const newRarity = rarityMap[avgRarity] || 'rare';
          const tier = window.gameState.alchemyUpgrades.currentTier;
          
          // Calculate combined stats for combos
          const totalAttack = Math.floor(slots.reduce((sum, s) => sum + (s.attack || 0), 0) * 2);
          const totalDefense = Math.floor(slots.reduce((sum, s) => sum + (s.defense || 0), 0) * 2);
          const totalHP = Math.floor(slots.reduce((sum, s) => sum + (s.hp || 0), 0) * 2);
          const totalSpeed = Math.floor(slots.reduce((sum, s) => sum + (s.speed || 0), 0) * 2);
          
          // Master recipes (Tier 5 only)
          if (tier >= 5) {
            // MASTER RECIPE 1: Pet + Spirit + Robot + Weapon (if all epic+)
            const allEpicPlus = rarities.every(r => r === 'epic' || r === 'legendary');
            if (allEpicPlus && typeSet.has('pet') && typeSet.has('spirit') && typeSet.has('robot')) {
              this.state.alchemyResult = {
                icon: 'ğŸ‘‘',
                name: 'Ultimate Guardian',
                rarity: 'legendary',
                type: 'pet',
                category: 'pet',
                attack: totalAttack * 1.5 || 100,
                defense: totalDefense * 1.5 || 80,
                hp: totalHP * 1.5 || 300,
                description: 'MASTER RECIPE: The ultimate fusion of all companion types',
                inputValue: totalValue,
                isEvolved: true,
                isMasterRecipe: true
              };
              return;
            }
            
            // MASTER RECIPE 2: Weapon + Armor + Accessory + Core (if all rare+)
            const allRarePlus = rarities.every(r => r === 'rare' || r === 'epic' || r === 'legendary');
            if (allRarePlus && typeSet.has('weapon') && typeSet.has('armor') && (typeSet.has('core') || typeSet.has('cores'))) {
              this.state.alchemyResult = {
                icon: 'âš”ï¸ğŸ‘‘',
                name: 'Legendary Battle Set',
                rarity: 'legendary',
                type: 'set',
                category: 'gear',
                attack: totalAttack * 1.8 || 120,
                defense: totalDefense * 1.8 || 100,
                hp: totalHP * 1.5 || 250,
                description: 'MASTER RECIPE: Perfect combat equipment set',
                inputValue: totalValue,
                isEvolved: true,
                isMasterRecipe: true
              };
              return;
            }
            
            // MASTER RECIPE 3: Spirit + Essence + Core (all same element if possible)
            if (typeSet.has('spirit') && typeSet.has('essence') && (typeSet.has('core') || typeSet.has('cores'))) {
              this.state.alchemyResult = {
                icon: 'ğŸ’«',
                name: 'Primordial Essence',
                rarity: 'legendary',
                type: 'essence',
                category: 'essence',
                description: 'MASTER RECIPE: Pure elemental energy condensed',
                inputValue: totalValue,
                isEvolved: true,
                isMasterRecipe: true,
                quantity: 5
              };
              return;
            }
          }
          
          // COMBO 1: AI + Pet + Supernatural = Better Companion
          if (typeSet.has('robot') && typeSet.has('pet') && (typeSet.has('supernatural') || typeSet.has('spirit'))) {
            this.state.alchemyResult = {
              icon: 'ğŸ¤–âœ¨ğŸ¾',
              name: 'Cyber-Mystic Companion',
              rarity: newRarity,
              type: 'pet',
              category: 'pet',
              attack: totalAttack || 25,
              defense: totalDefense || 20,
              hp: totalHP || 100,
              description: 'Fusion of AI intelligence, pet loyalty, and mystical power',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true
            };
            return;
          }
          
          // COMBO 2: Weapon + Armor + Accessory = Complete Warrior Set
          if (typeSet.has('weapon') && typeSet.has('armor') && typeSet.has('accessory')) {
            this.state.alchemyResult = {
              icon: 'âš”ï¸ğŸ›¡ï¸ğŸ’',
              name: 'Complete Warrior Set',
              rarity: newRarity,
              type: 'set',
              category: 'gear',
              attack: totalAttack || 30,
              defense: totalDefense || 25,
              hp: totalHP || 80,
              description: 'Perfectly balanced combat equipment set',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true
            };
            return;
          }
          
          // COMBO 3: Pet + Spirit + Core = Elemental Pet
          if (typeSet.has('pet') && typeSet.has('spirit') && (typeSet.has('core') || typeSet.has('cores'))) {
            this.state.alchemyResult = {
              icon: 'ğŸ”¥ğŸ•',
              name: 'Elemental Battle Pet',
              rarity: newRarity,
              type: 'pet',
              category: 'pet',
              attack: totalAttack || 30,
              defense: totalDefense || 15,
              hp: totalHP || 120,
              description: 'Pet infused with elemental spirit and core power',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true
            };
            return;
          }
          
          // COMBO 4: Vehicle + Robot + Core = Mecha Vehicle
          if (typeSet.has('vehicle') && typeSet.has('robot') && (typeSet.has('core') || typeSet.has('cores'))) {
            this.state.alchemyResult = {
              icon: 'ğŸ¤–ğŸš—',
              name: 'AI-Enhanced Mech Vehicle',
              rarity: newRarity,
              type: 'vehicle',
              category: 'vehicle',
              speed: totalSpeed || 50,
              attack: totalAttack || 20,
              defense: totalDefense || 30,
              description: 'Self-driving combat vehicle with AI core',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true
            };
            return;
          }
          
          // COMBO 5: Scroll + Essence + Consumable = Magic Elixir
          if (typeSet.has('scroll') && typeSet.has('essence') && typeSet.has('consumable')) {
            this.state.alchemyResult = {
              icon: 'ğŸ§ªâœ¨',
              name: 'Mystic Elixir',
              rarity: newRarity,
              type: 'consumable',
              category: 'consumable',
              quantity: 3,
              description: 'Powerful magical potion combining scroll knowledge, essence power, and consumable effects',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true
            };
            return;
          }
          
          // COMBO 6: Pet + Vehicle + Robot = Mobile Companion Base
          if (typeSet.has('pet') && typeSet.has('vehicle') && typeSet.has('robot')) {
            this.state.alchemyResult = {
              icon: 'ğŸ ğŸš—',
              name: 'Mobile Companion HQ',
              rarity: newRarity,
              type: 'vehicle',
              category: 'vehicle',
              speed: totalSpeed || 30,
              hp: totalHP || 200,
              description: 'Mobile base that houses your pets and robots',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true
            };
            return;
          }
          
          // COMBO 7: Spirit + Core + Weapon = Elemental Weapon
          if (typeSet.has('spirit') && (typeSet.has('core') || typeSet.has('cores')) && typeSet.has('weapon')) {
            this.state.alchemyResult = {
              icon: 'âš”ï¸ğŸ”¥',
              name: 'Elemental Enchanted Blade',
              rarity: newRarity,
              type: 'weapon',
              category: 'weapon',
              attack: totalAttack || 40,
              description: 'Weapon infused with spirit element and core technology',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true
            };
            return;
          }
          
          // COMBO 8: Armor + Accessory + Consumable = Battle Armor
          if (typeSet.has('armor') && typeSet.has('accessory') && typeSet.has('consumable')) {
            this.state.alchemyResult = {
              icon: 'ğŸ›¡ï¸ğŸ’ª',
              name: 'Fortified Battle Suit',
              rarity: newRarity,
              type: 'armor',
              category: 'armor',
              defense: totalDefense || 35,
              hp: totalHP || 150,
              description: 'Enhanced armor with accessory bonuses and consumable effects',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true
            };
            return;
          }
          
          // COMBO 9: Pet + Vehicle + Consumable = Racing Companion
          if (typeSet.has('pet') && typeSet.has('vehicle') && typeSet.has('consumable')) {
            this.state.alchemyResult = {
              icon: 'ğŸï¸ğŸ•',
              name: 'Racing Companion',
              rarity: newRarity,
              type: 'pet',
              category: 'pet',
              speed: totalSpeed || 40,
              attack: totalAttack || 15,
              hp: totalHP || 90,
              description: 'Pet trained for speed with vehicle enhancements',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true
            };
            return;
          }
          
          // COMBO 10: Robot + Armor + Core = Combat Bot
          if (typeSet.has('robot') && typeSet.has('armor') && (typeSet.has('core') || typeSet.has('cores'))) {
            this.state.alchemyResult = {
              icon: 'ğŸ¤–ğŸ›¡ï¸',
              name: 'Armored Combat Bot',
              rarity: newRarity,
              type: 'robot',
              category: 'robot',
              attack: totalAttack || 35,
              defense: totalDefense || 40,
              hp: totalHP || 150,
              description: 'Heavily armored robot with upgraded core',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true
            };
            return;
          }
          
          // COMBO 11: Weapon + Spirit + Essence = Magic Weapon
          if (typeSet.has('weapon') && typeSet.has('spirit') && typeSet.has('essence')) {
            this.state.alchemyResult = {
              icon: 'ğŸª„âš”ï¸',
              name: 'Spirit-Forged Weapon',
              rarity: newRarity,
              type: 'weapon',
              category: 'weapon',
              attack: totalAttack || 45,
              description: 'Weapon blessed by spirits and essence magic',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true
            };
            return;
          }
          
          // COMBO 12: Pet + Spirit + Vehicle = Celestial Mount
          if (typeSet.has('pet') && typeSet.has('spirit') && typeSet.has('vehicle')) {
            this.state.alchemyResult = {
              icon: 'ğŸ‰âœ¨',
              name: 'Celestial Mount',
              rarity: newRarity,
              type: 'vehicle',
              category: 'vehicle',
              speed: totalSpeed || 60,
              hp: totalHP || 180,
              description: 'Flying mount created from pet, spirit, and vehicle',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true
            };
            return;
          }
          
          // COMBO 13: Scroll + Weapon + Armor = Spellblade Set
          if (typeSet.has('scroll') && typeSet.has('weapon') && typeSet.has('armor')) {
            this.state.alchemyResult = {
              icon: 'âš”ï¸ğŸ“œ',
              name: 'Spellblade Battle Set',
              rarity: newRarity,
              type: 'set',
              category: 'gear',
              attack: totalAttack || 35,
              defense: totalDefense || 30,
              description: 'Weapon and armor enchanted with scroll magic',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true
            };
            return;
          }
          
          // COMBO 14: Essence + Core + Accessory = Power Artifact
          if (typeSet.has('essence') && (typeSet.has('core') || typeSet.has('cores')) && typeSet.has('accessory')) {
            this.state.alchemyResult = {
              icon: 'ğŸ’ğŸ’',
              name: 'Power Artifact',
              rarity: newRarity,
              type: 'accessory',
              category: 'accessory',
              attack: Math.floor(totalAttack * 0.8) || 20,
              defense: Math.floor(totalDefense * 0.8) || 20,
              hp: Math.floor(totalHP * 0.6) || 50,
              description: 'Artifact combining essence power, core energy, and accessory magic',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true
            };
            return;
          }
          
          // COMBO 15: Box + Consumable + Essence = Premium Box
          if (typeSet.has('box') && typeSet.has('consumable') && typeSet.has('essence')) {
            this.state.alchemyResult = {
              icon: 'ğŸâœ¨',
              name: 'Premium Mystery Box',
              rarity: 'rare',
              type: 'box',
              category: 'container',
              quantity: 1,
              description: 'Enhanced treasure box with guaranteed rare items',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true
            };
            return;
          }
          
          // COMBO 16: Pet + Robot + Accessory = Cyber Pet
          if (typeSet.has('pet') && typeSet.has('robot') && typeSet.has('accessory')) {
            this.state.alchemyResult = {
              icon: 'ğŸ¤–ğŸ•',
              name: 'Cyber-Enhanced Pet',
              rarity: newRarity,
              type: 'pet',
              category: 'pet',
              attack: totalAttack || 28,
              defense: totalDefense || 22,
              hp: totalHP || 110,
              description: 'Pet upgraded with robotic enhancements and accessory boosts',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true
            };
            return;
          }
          
          // COMBO 17: Vehicle + Spirit + Scroll = Flying Chariot
          if (typeSet.has('vehicle') && typeSet.has('spirit') && typeSet.has('scroll')) {
            this.state.alchemyResult = {
              icon: 'ğŸ›¸âœ¨',
              name: 'Spirit-Fueled Chariot',
              rarity: newRarity,
              type: 'vehicle',
              category: 'vehicle',
              speed: totalSpeed || 70,
              description: 'Flying vehicle powered by spirit magic and scroll enchantments',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true
            };
            return;
          }
          
          // COMBO 18: Weapon + Robot + Core = Melee Bot
          if (typeSet.has('weapon') && typeSet.has('robot') && (typeSet.has('core') || typeSet.has('cores'))) {
            this.state.alchemyResult = {
              icon: 'ğŸ¤–âš”ï¸',
              name: 'Melee Combat Bot',
              rarity: newRarity,
              type: 'robot',
              category: 'robot',
              attack: totalAttack || 50,
              defense: totalDefense || 25,
              hp: totalHP || 120,
              description: 'Robot specialized in melee combat with weapon integration',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true
            };
            return;
          }
          
          // COMBO 19: Armor + Pet + Consumable = Pet Armor
          if (typeSet.has('armor') && typeSet.has('pet') && typeSet.has('consumable')) {
            this.state.alchemyResult = {
              icon: 'ğŸ•ğŸ›¡ï¸',
              name: 'Armored Battle Pet',
              rarity: newRarity,
              type: 'pet',
              category: 'pet',
              attack: totalAttack || 20,
              defense: totalDefense || 30,
              hp: totalHP || 140,
              description: 'Pet equipped with protective armor and consumable enhancements',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true
            };
            return;
          }
          
          // COMBO 20: Spirit + Essence + Scroll = Elemental Scroll
          if (typeSet.has('spirit') && typeSet.has('essence') && typeSet.has('scroll')) {
            this.state.alchemyResult = {
              icon: 'ğŸ“œğŸ”¥',
              name: 'Elemental Master Scroll',
              rarity: newRarity,
              type: 'scroll',
              category: 'scroll',
              quantity: 2,
              description: 'Ultimate scroll combining spirit power, essence energy, and scroll knowledge',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true
            };
            return;
          }
          
          // === NEW COMBOS: Elemental Fusion Recipes ===
          
          // COMBO 21: Essence + Essence + Spirit = Elemental Catalyst (if 2+ essence)
          const essenceCount = slots.filter(s => s.type === 'essence' || s.category === 'essence').length;
          if (essenceCount >= 2 && typeSet.has('spirit')) {
            this.state.alchemyResult = {
              icon: 'ğŸ”¥ğŸ’§âœ¨',
              name: 'Elemental Catalyst',
              rarity: newRarity,
              type: 'essence',
              category: 'essence',
              quantity: 5,
              description: 'Powerful elemental essence that amplifies all magical effects',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true
            };
            return;
          }
          
          // COMBO 22: Essence + Essence + Core = Nature's Blessing
          if (essenceCount >= 2 && (typeSet.has('core') || typeSet.has('cores'))) {
            this.state.alchemyResult = {
              icon: 'ğŸŒ¿ğŸ’«',
              name: "Nature's Blessing",
              rarity: newRarity,
              type: 'essence',
              category: 'essence',
              quantity: 3,
              description: 'Pure nature essence with core energy infusion',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true
            };
            return;
          }
          
          // COMBO 23: Scroll + Scroll + Scroll = Spell Tome (3 same type)
          if (scrollCount === 3) {
            this.state.alchemyResult = {
              icon: 'ğŸ“–âœ¨',
              name: 'Ancient Spell Tome',
              rarity: newRarity,
              type: 'scroll',
              category: 'scroll',
              quantity: 1,
              description: 'Compilation of powerful scrolls into a legendary tome',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true
            };
            return;
          }
          
          // === NEW COMBOS: Gear Enhancement Recipes ===
          
          // COMBO 24: Weapon + Scroll + Essence = Enchanted Weapon
          if (typeSet.has('weapon') && typeSet.has('scroll') && typeSet.has('essence')) {
            this.state.alchemyResult = {
              icon: 'âš”ï¸ğŸ”®',
              name: 'Enchanted Legendary Blade',
              rarity: newRarity,
              type: 'weapon',
              category: 'weapon',
              attack: totalAttack * 1.3 || 45,
              description: 'Weapon permanently enchanted with scroll magic and essence power',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true
            };
            return;
          }
          
          // COMBO 25: Armor + Consumable + Core = Reinforced Armor
          if (typeSet.has('armor') && typeSet.has('consumable') && (typeSet.has('core') || typeSet.has('cores'))) {
            this.state.alchemyResult = {
              icon: 'ğŸ›¡ï¸âš¡',
              name: 'Core-Reinforced Armor',
              rarity: newRarity,
              type: 'armor',
              category: 'armor',
              defense: totalDefense * 1.4 || 40,
              hp: totalHP * 1.2 || 150,
              description: 'Armor reinforced with core technology and consumable enhancements',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true
            };
            return;
          }
          
          // COMBO 26: Accessory + Spirit + Essence = Blessed Accessory
          if (typeSet.has('accessory') && typeSet.has('spirit') && typeSet.has('essence')) {
            this.state.alchemyResult = {
              icon: 'ğŸ’âœ¨ğŸ”®',
              name: 'Blessed Divine Accessory',
              rarity: newRarity,
              type: 'accessory',
              category: 'accessory',
              attack: Math.floor(totalAttack * 0.7) || 15,
              defense: Math.floor(totalDefense * 0.7) || 15,
              hp: Math.floor(totalHP * 0.9) || 70,
              description: 'Accessory blessed with spirit essence and magical power',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true
            };
            return;
          }
          
          // === NEW COMBOS: Companion Fusion Recipes ===
          
          // COMBO 27: Robot + Spirit + Core = Sentient AI Companion
          if (typeSet.has('robot') && typeSet.has('spirit') && (typeSet.has('core') || typeSet.has('cores'))) {
            this.state.alchemyResult = {
              icon: 'ğŸ¤–ğŸ‘»ğŸ’«',
              name: 'Sentient AI Guardian',
              rarity: newRarity,
              type: 'robot',
              category: 'robot',
              attack: totalAttack * 1.2 || 55,
              defense: totalDefense * 1.2 || 35,
              hp: totalHP * 1.2 || 140,
              description: 'Self-aware AI with spirit consciousness and advanced core',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true
            };
            return;
          }
          
          // COMBO 28: Vehicle + Pet + Robot = Mounted Combat Unit
          if (typeSet.has('vehicle') && typeSet.has('pet') && typeSet.has('robot')) {
            this.state.alchemyResult = {
              icon: 'ğŸš—ğŸ•ğŸ¤–',
              name: 'Mobile Combat Squad',
              rarity: newRarity,
              type: 'vehicle',
              category: 'vehicle',
              speed: totalSpeed || 60,
              attack: totalAttack || 35,
              defense: totalDefense || 30,
              hp: totalHP || 180,
              description: 'Vehicle with pet and robot crew for maximum combat efficiency',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true
            };
            return;
          }
          
          // === NEW COMBOS: Utility Recipes ===
          
          // COMBO 29: Box + Box + Essence = Blessed Chest (2+ boxes)
          if (boxCount >= 2 && typeSet.has('essence')) {
            this.state.alchemyResult = {
              icon: 'ğŸâœ¨ğŸ’',
              name: 'Blessed Treasure Chest',
              rarity: 'epic',
              type: 'box',
              category: 'container',
              quantity: 1,
              description: 'Sacred chest blessed with essence, guaranteed epic+ rewards',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true
            };
            return;
          }
          
          // COMBO 30: Scroll + Scroll + Consumable = Mega Potion Recipe
          if (scrollCount >= 2 && typeSet.has('consumable')) {
            this.state.alchemyResult = {
              icon: 'ğŸ§ªğŸ“œ',
              name: 'Mega Restoration Elixir',
              rarity: newRarity,
              type: 'consumable',
              category: 'consumable',
              quantity: 5,
              description: 'Scroll-enhanced super potion with amplified effects',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true
            };
            return;
          }
          
          // COMBO 31: Consumable + Consumable + Consumable = Ultimate Potion (3 same type)
          if (consumableCount === 3) {
            this.state.alchemyResult = {
              icon: 'ğŸ§ªğŸ§ªğŸ§ª',
              name: 'Ultimate Mega Potion',
              rarity: 'rare',
              type: 'consumable',
              category: 'consumable',
              quantity: 10,
              description: 'Triple-concentrated ultimate restoration potion',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true
            };
            return;
          }
          
          // === NEW COMBOS: Rare Combination Recipes (Tier 3+) ===
          
          // COMBO 32: Epic Weapon + Epic Armor + Epic Accessory = Legendary Set (Tier 3+)
          const allEpic = rarities.every(r => r === 'epic');
          if (tier >= 3 && allEpic && typeSet.has('weapon') && typeSet.has('armor') && typeSet.has('accessory')) {
            this.state.alchemyResult = {
              icon: 'âš”ï¸ğŸ›¡ï¸ğŸ’ğŸ‘‘',
              name: 'Legendary Warlord Set',
              rarity: 'legendary',
              type: 'set',
              category: 'gear',
              attack: totalAttack * 1.5 || 80,
              defense: totalDefense * 1.5 || 70,
              hp: totalHP * 1.3 || 200,
              description: 'TIER 3+ EXCLUSIVE: Complete legendary equipment set forged from epic gear',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true,
              tierExclusive: true
            };
            return;
          }
          
          // COMBO 33: Legendary Pet + Legendary Spirit + Legendary Robot = Divine Guardian (Tier 4+)
          const allLegendary = rarities.every(r => r === 'legendary');
          if (tier >= 4 && allLegendary && typeSet.has('pet') && typeSet.has('spirit') && typeSet.has('robot')) {
            this.state.alchemyResult = {
              icon: 'ğŸ‘‘ğŸ‰ğŸ¤–âœ¨',
              name: 'Divine Ultimate Guardian',
              rarity: 'legendary',
              type: 'pet',
              category: 'pet',
              attack: totalAttack * 2.0 || 150,
              defense: totalDefense * 2.0 || 120,
              hp: totalHP * 2.0 || 400,
              description: 'TIER 4+ EXCLUSIVE: The ultimate companion - a fusion of legendary entities',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true,
              tierExclusive: true
            };
            return;
          }
          
          // === NEW COMBOS: Tier-Specific Recipes ===
          
          // COMBO 34: Any 3 Epic items = Transcendent Crystal (Tier 4+)
          if (tier >= 4 && rarities.every(r => r === 'epic' || r === 'legendary') && rarities.filter(r => r === 'epic').length >= 2) {
            this.state.alchemyResult = {
              icon: 'ğŸ’ğŸ”®âœ¨',
              name: 'Transcendent Power Crystal',
              rarity: 'legendary',
              type: 'core',
              category: 'cores',
              quantity: 1,
              description: 'TIER 4+ EXCLUSIVE: Crystallized power from epic items - grants immense power',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true,
              tierExclusive: true
            };
            return;
          }
          
          // COMBO 35: Any 3 Legendary items = Primordial Essence (Tier 5 only)
          if (tier >= 5 && allLegendary) {
            this.state.alchemyResult = {
              icon: 'ğŸŒŸğŸ’«ğŸ‘‘',
              name: 'Primordial Creation Essence',
              rarity: 'legendary',
              type: 'essence',
              category: 'essence',
              quantity: 10,
              description: 'TIER 5 EXCLUSIVE: Pure creation essence - the origin of all power',
              inputValue: totalValue,
              isEvolved: true,
              isCombo: true,
              tierExclusive: true,
              isMasterRecipe: true
            };
            return;
          }
          
          // === EVOLUTION RECIPES: Type-Specific Upgrades (if no combo matches) ===
          
          // Check if all 3 items are the same type
          if (new Set(types).size === 1 && types[0]) {
            const itemType = types[0];
            const baseRarity = rarities.length > 0 ? rarities[0] : 'common';
            const rarityMap = { common: 'uncommon', uncommon: 'rare', rare: 'epic', epic: 'legendary' };
            const newRarity = rarityMap[baseRarity] || 'legendary';
            
            // Calculate combined stats
            const totalAttack = Math.floor(slots.reduce((sum, s) => sum + (s.attack || 0), 0) * 1.5);
            const totalDefense = Math.floor(slots.reduce((sum, s) => sum + (s.defense || 0), 0) * 1.5);
            const totalHP = Math.floor(slots.reduce((sum, s) => sum + (s.hp || 0), 0) * 1.5);
            const totalSpeed = Math.floor(slots.reduce((sum, s) => sum + (s.speed || 0), 0) * 1.5);
            
            // PET EVOLUTION
            if (itemType === 'pet') {
              this.state.alchemyResult = {
                icon: 'ğŸ•â€ğŸ¦º',
                name: `Enhanced ${newRarity} Companion`,
                rarity: newRarity,
                type: 'pet',
                category: 'pet',
                attack: totalAttack || 10,
                defense: totalDefense || 8,
                hp: totalHP || 50,
                description: `Evolved from ${slots[0].name} and others`,
                inputValue: totalValue,
                isEvolved: true
              };
              return;
            }
            
            // SPIRIT EVOLUTION
            if (itemType === 'spirit') {
              const elements = ['Fire', 'Water', 'Wind', 'Earth', 'Light'];
              const randomElement = elements[Math.floor(Math.random() * elements.length)];
              this.state.alchemyResult = {
                icon: 'âœ¨',
                name: `Greater ${randomElement} Spirit`,
                rarity: newRarity,
                type: 'spirit',
                category: 'spirit',
                attack: totalAttack || 12,
                defense: totalDefense || 10,
                hp: totalHP || 60,
                description: `Powerful evolved spirit`,
                inputValue: totalValue,
                isEvolved: true
              };
              return;
            }
            
            // VEHICLE EVOLUTION
            if (itemType === 'vehicle') {
              this.state.alchemyResult = {
                icon: 'ğŸï¸',
                name: `Turbo ${newRarity} Vehicle`,
                rarity: newRarity,
                type: 'vehicle',
                category: 'vehicle',
                speed: totalSpeed || 15,
                description: `High-performance evolved vehicle`,
                inputValue: totalValue,
                isEvolved: true
              };
              return;
            }
            
            // ROBOT EVOLUTION
            if (itemType === 'robot') {
              this.state.alchemyResult = {
                icon: 'ğŸ¤–',
                name: `Advanced ${newRarity} Bot`,
                rarity: newRarity,
                type: 'robot',
                category: 'robot',
                attack: totalAttack || 15,
                defense: totalDefense || 12,
                hp: totalHP || 80,
                description: `Upgraded combat robot`,
                inputValue: totalValue,
                isEvolved: true
              };
              return;
            }
            
            // WEAPON EVOLUTION
            if (itemType === 'weapon') {
              this.state.alchemyResult = {
                icon: 'âš”ï¸',
                name: `Forged ${newRarity} Blade`,
                rarity: newRarity,
                type: 'weapon',
                category: 'weapon',
                attack: totalAttack || 20,
                description: `Reforged powerful weapon`,
                inputValue: totalValue,
                isEvolved: true
              };
              return;
            }
            
            // ARMOR EVOLUTION
            if (itemType === 'armor') {
              this.state.alchemyResult = {
                icon: 'ğŸ›¡ï¸',
                name: `Reinforced ${newRarity} Armor`,
                rarity: newRarity,
                type: 'armor',
                category: 'armor',
                defense: totalDefense || 18,
                hp: totalHP || 60,
                description: `Strengthened protective gear`,
                inputValue: totalValue,
                isEvolved: true
              };
              return;
            }
            
            // ACCESSORY EVOLUTION
            if (itemType === 'accessory') {
              this.state.alchemyResult = {
                icon: 'ğŸ’',
                name: `Enchanted ${newRarity} Charm`,
                rarity: newRarity,
                type: 'accessory',
                category: 'accessory',
                attack: Math.floor(totalAttack * 0.7) || 5,
                defense: Math.floor(totalDefense * 0.7) || 5,
                hp: Math.floor(totalHP * 0.5) || 15,
                description: `Magically enhanced accessory`,
                inputValue: totalValue,
                isEvolved: true
              };
              return;
            }
          }

          // Fusion Rule: 3 same rarity (mixed types) â†’ Box
          if (rarities.length === 3 && new Set(rarities).size === 1) {
            const rarityMap = { common: 'uncommon', uncommon: 'rare', rare: 'epic', epic: 'legendary' };
            const newRarity = rarityMap[rarities[0]] || 'legendary';
            this.state.alchemyResult = {
              icon: 'ğŸ',
              name: `${newRarity.toUpperCase()} Gear Box`,
              rarity: newRarity,
              type: 'fusion',
              inputValue: totalValue
            };
            return;
          }

          // Generic: Any 3 items â†’ Treasure Box
          this.state.alchemyResult = {
            icon: 'ğŸ“¦',
            name: 'Mystery Treasure Box',
            type: 'generic',
            inputValue: totalValue
          };
        },

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // REQUIREMENTS SYSTEM - Level, Gold, Rank Requirements for Features
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        REQUIREMENTS: {
          ai: {
            level: 5,
            gold: 1000,
            rank: 1,
            name: 'AI System'
          },
          pets: {
            level: 1,
            gold: 0,
            rank: 0,
            name: 'Pets Collection'
          },
          vehicles: {
            level: 10,
            gold: 5000,
            rank: 2,
            name: 'Vehicles Collection'
          },
          spirits: {
            level: 15,
            gold: 10000,
            rank: 3,
            name: 'Spirit Collection'
          },
          autoAlchemy: {
            level: 3,
            gold: 500,
            rank: 1,
            name: 'Auto Alchemy'
          }
        },

        checkRequirements(feature) {
          const req = this.REQUIREMENTS[feature];
          if (!req) return { met: true, message: '' };
          
          const player = window.gameState;
          const issues = [];
          
          if (player.level < req.level) {
            issues.push(`Level ${req.level} required (you are level ${player.level})`);
          }
          if (player.gold < req.gold) {
            issues.push(`${req.gold.toLocaleString()} gold required (you have ${player.gold.toLocaleString()})`);
          }
          if (player.rank < req.rank) {
            issues.push(`Rank ${req.rank} required (you are rank ${player.rank})`);
          }
          
          if (issues.length > 0) {
            return {
              met: false,
              message: `âŒ ${req.name} Requirements Not Met:\n${issues.join('\n')}`
            };
          }
          
          return { met: true, message: '' };
        },

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // UNIVERSAL UPGRADE SYSTEM - Upgrade any item type
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        upgradeItem(itemId, itemType) {
          // Find item in correct inventory
          let item = null;
          let inventory = null;
          
          switch(itemType) {
            case 'gear':
              this.upgradeGear(itemId);
              return;
            case 'pet':
              inventory = window.gameState.inventory.pets;
              item = inventory?.find(i => i.id === itemId);
              break;
            case 'spirit':
              inventory = window.gameState.inventory.spirits;
              item = inventory?.find(i => i.id === itemId);
              break;
            case 'vehicle':
              inventory = window.gameState.inventory.vehicles;
              item = inventory?.find(i => i.id === itemId);
              break;
            case 'robot':
              inventory = window.gameState.inventory.robots;
              item = inventory?.find(i => i.id === itemId);
              break;
            case 'power':
              inventory = window.gameState.inventory.powers;
              item = inventory?.find(i => i.id === itemId);
              break;
            default:
              this.showToast('âŒ Unknown item type for upgrade!');
              return;
          }
          
          if (!item) {
            this.showToast('âŒ Item not found!');
            return;
          }
          
          // Initialize level if not set
          if (!item.level) item.level = 1;
          
          // Calculate upgrade cost (base: 100 gold per level)
          const baseCost = 100;
          const rarityMultiplier = {
            common: 1,
            uncommon: 2,
            rare: 5,
            epic: 10,
            legendary: 20
          }[item.rarity || 'common'] || 1;
          
          const upgradeCost = Math.floor(baseCost * (item.level + 1) * rarityMultiplier);
          
          // Check if player can afford
          if (window.gameState.gold < upgradeCost) {
            this.showToast(`âŒ Need ${upgradeCost.toLocaleString()}g to upgrade!`);
            return;
          }
          
          // Deduct gold
          window.gameState.gold -= upgradeCost;
          
          // Upgrade item
          const oldLevel = item.level;
          item.level += 1;
          
          // Apply stat increases (+10% base stats per level)
          const statMultiplier = 1.1;
          if (item.attack) item.attack = Math.floor(item.attack * statMultiplier);
          if (item.defense) item.defense = Math.floor(item.defense * statMultiplier);
          if (item.hp) item.hp = Math.floor(item.hp * statMultiplier);
          if (item.speed) item.speed = Math.floor(item.speed * statMultiplier);
          if (item.mana) item.mana = Math.floor(item.mana * statMultiplier);
          
          // Enhance effects if they exist
          if (item.effects && Array.isArray(item.effects)) {
            item.effects.forEach(effect => {
              if (effect.value) {
                effect.value = Math.floor(effect.value * statMultiplier);
              }
            });
          }
          
          // Show success
          this.showToast(`âœ¨ Upgraded ${item.icon || ''} ${item.name} to Lv${item.level}! (âˆ’${upgradeCost.toLocaleString()}g)`);
          debugLog(`[UPGRADE] ${item.name}: Lv${oldLevel} â†’ Lv${item.level} | Cost: ${upgradeCost}g`);
          
          // Refresh the current view
          this.renderTab(this.state.activeTab);
          this.renderCurrencies();
        },

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // UNIVERSAL FUSE SYSTEM - Fuse 3 copies into enhanced item
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        fuseDuplicates(baseItemId, itemType) {
          // Find all copies of this item
          let inventory = null;
          let itemCopies = [];
          
          switch(itemType) {
            case 'pet':
              inventory = window.gameState.inventory.pets;
              itemCopies = inventory?.filter(i => i.id.startsWith(baseItemId) || i.id === baseItemId) || [];
              break;
            case 'spirit':
              inventory = window.gameState.inventory.spirits;
              itemCopies = inventory?.filter(i => i.id.startsWith(baseItemId) || i.id === baseItemId) || [];
              break;
            case 'vehicle':
              inventory = window.gameState.inventory.vehicles;
              itemCopies = inventory?.filter(i => i.id.startsWith(baseItemId) || i.id === baseItemId) || [];
              break;
            case 'robot':
              inventory = window.gameState.inventory.robots;
              itemCopies = inventory?.filter(i => i.id.startsWith(baseItemId) || i.id === baseItemId) || [];
              break;
            case 'power':
              inventory = window.gameState.inventory.powers;
              itemCopies = inventory?.filter(i => i.id.startsWith(baseItemId) || i.id === baseItemId) || [];
              break;
            case 'gear':
              inventory = window.gameState.inventory.gear;
              itemCopies = inventory?.filter(i => i.id.startsWith(baseItemId) || i.id === baseItemId) || [];
              break;
            default:
              this.showToast('âŒ Unknown item type for fuse!');
              return;
          }
          
          if (itemCopies.length < 3) {
            this.showToast(`âŒ Need 3 copies to fuse! You have ${itemCopies.length}`);
            return;
          }
          
          // Keep the first copy, enhance it, remove the other 2
          const keepItem = itemCopies[0];
          const removeItems = itemCopies.slice(1, 3);
          
          // Remove 2 copies from inventory
          removeItems.forEach(itemToRemove => {
            const index = inventory.indexOf(itemToRemove);
            if (index !== -1) inventory.splice(index, 1);
          });
          
          // Enhance the kept item
          if (!keepItem.level) keepItem.level = 1;
          keepItem.level += 2; // +2 levels from fusing
          
          // Boost stats by 20%
          const statBoost = 1.2;
          if (keepItem.attack) keepItem.attack = Math.floor(keepItem.attack * statBoost);
          if (keepItem.defense) keepItem.defense = Math.floor(keepItem.defense * statBoost);
          if (keepItem.hp) keepItem.hp = Math.floor(keepItem.hp * statBoost);
          if (keepItem.speed) keepItem.speed = Math.floor(keepItem.speed * statBoost);
          if (keepItem.mana) keepItem.mana = Math.floor(keepItem.mana * statBoost);
          
          // Enhance effects
          if (keepItem.effects && Array.isArray(keepItem.effects)) {
            keepItem.effects.forEach(effect => {
              if (effect.value) {
                effect.value = Math.floor(effect.value * statBoost);
              }
            });
          }
          
          // Mark as fused
          keepItem.name = `Fused ${keepItem.name}`;
          
          // Show success
          this.showToast(`ğŸŒŸ FUSED! ${keepItem.icon || ''} ${keepItem.name} is now Lv${keepItem.level} with +20% stats!`);
          debugLog(`[FUSE] ${keepItem.name}: 3 copies â†’ 1 enhanced (Lv${keepItem.level})`);
          
          // Refresh the current view
          this.renderTab(this.state.activeTab);
        },

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // AUTO ALCHEMY - Performs one automatic alchemy craft
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        performAutoAlchemy() {
          // Check requirements
          const reqCheck = this.checkRequirements('autoAlchemy');
          if (!reqCheck.met) {
            this.showToast(reqCheck.message.split('\n')[0]); // Show first line
            debugWarn('[AUTO ALCHEMY] Requirements not met:', reqCheck.message);
            return;
          }

          // Check if slots are already filled
          const filledSlots = this.state.alchemySlots.filter(s => s !== null).length;
          if (filledSlots >= 3) {
            // Slots already filled, just perform the craft
            if (this.state.alchemyResult) {
              this.performCraft();
              this.showToast('âœ¨ Auto Alchemy: Crafted automatically!');
              return;
            } else {
              this.calculateAlchemyResult();
              if (this.state.alchemyResult) {
                this.performCraft();
                this.showToast('âœ¨ Auto Alchemy: Crafted automatically!');
                return;
              }
            }
          }

          // Collect all available items from inventory with smart selection metadata
          const availableItems = [];
          const typeBuckets = new Map();
          const rarityOrder = { common: 1, uncommon: 2, rare: 3, epic: 4, legendary: 5 };
          const shouldSkipAlchemyItem = (entry) => {
            if (!entry) return false;
            const rank = (entry.rank || '').toUpperCase();
            const rarity = (entry.rarity || '').toLowerCase();
            return rank.startsWith('S') || rarity === 'legendary';
          };
          const rarityScore = (item) => rarityOrder[(item.rarity || '').toLowerCase()] || 99;
          const registerCandidate = (entry, source) => {
            if (!entry) return;
            const cloned = { ...entry, source };
            cloned.typeKey = this.getItemTypeKey(cloned) || 'unknown';
            cloned.__autoKey = `${source}:${entry.instanceId || entry.id || entry.name || 'item'}:${availableItems.length}`;
            availableItems.push(cloned);
            if (!typeBuckets.has(cloned.typeKey)) typeBuckets.set(cloned.typeKey, []);
            typeBuckets.get(cloned.typeKey).push(cloned);
          };
          
          // Get all pets
          if (window.gameState.inventory.pets) {
            window.gameState.inventory.pets.forEach(pet => {
              if (shouldSkipAlchemyItem(pet)) return;
              registerCandidate(pet, 'pets');
            });
          }
          
          // Get all spirits
          if (window.gameState.inventory.spirits) {
            window.gameState.inventory.spirits.forEach(spirit => {
              if (shouldSkipAlchemyItem(spirit)) return;
              registerCandidate(spirit, 'spirits');
            });
          }
          
          // Get all vehicles
          if (window.gameState.inventory.vehicles) {
            window.gameState.inventory.vehicles.forEach(vehicle => {
              if (shouldSkipAlchemyItem(vehicle)) return;
              registerCandidate(vehicle, 'vehicles');
            });
          }
          
          // Get all robots
          if (window.gameState.inventory.robots) {
            window.gameState.inventory.robots.forEach(robot => {
              if (shouldSkipAlchemyItem(robot)) return;
              registerCandidate(robot, 'robots');
            });
          }
          
          // Get all gear
          if (window.gameState.inventory.gear) {
            window.gameState.inventory.gear.forEach(gear => {
              if (shouldSkipAlchemyItem(gear)) return;
              registerCandidate(gear, 'gear');
            });
          }
          
          // Get all items (consumables, boxes, etc.)
          if (window.gameState.inventory.items) {
            window.gameState.inventory.items.forEach(item => {
              if (shouldSkipAlchemyItem(item)) return;
              if (item.quantity && item.quantity > 0) {
                // For items with quantity, we can use multiple
                for (let i = 0; i < Math.min(item.quantity, 3); i++) {
                  const cloned = { ...item, quantity: 1 };
                  registerCandidate(cloned, 'items');
                }
              } else {
                registerCandidate(item, 'items');
              }
            });
          }

          if (availableItems.length < 3) {
            this.showToast('âŒ Not enough items for alchemy! Need at least 3 items.');
            return;
          }

          // Sort each bucket so we burn the lowest-rarity duplicates first
          typeBuckets.forEach(bucket => bucket.sort((a, b) => rarityScore(a) - rarityScore(b)));

          const pickByTypes = (typeList, validator) => {
            const selection = [];
            const usedKeys = new Set();
            for (const type of typeList) {
              const bucket = typeBuckets.get(type);
              if (!bucket || bucket.length === 0) return null;
              const candidate = bucket.find(item => !usedKeys.has(item.__autoKey));
              if (!candidate) return null;
              selection.push(candidate);
              usedKeys.add(candidate.__autoKey);
            }
            if (validator && !validator(selection)) return null;
            return selection;
          };

          const comboDefinitions = [
            { types: ['weapon', 'armor', 'accessory'] },
            { types: ['pet', 'spirit', 'core'] },
            { types: ['vehicle', 'robot', 'core'] },
            { types: ['scroll', 'essence', 'consumable'] },
            { types: ['pet', 'vehicle', 'robot'] },
            { types: ['pet', 'spirit', 'robot'] },
            { types: ['armor', 'accessory', 'consumable'] },
            { types: ['weapon', 'spirit', 'essence'] },
            { types: ['core', 'core', 'core'], validator: (items) => items.length === 3 }
          ];

          let selectedItems = null;

          // Strategy 1: combo-first (prioritized list)
          for (const combo of comboDefinitions) {
            const selection = pickByTypes(combo.types, combo.validator);
            if (selection && selection.length === 3) {
              selectedItems = selection;
              break;
            }
          }

          // Strategy 2: evolution recipes (3 of same type)
          if (!selectedItems) {
            for (const [type, bucket] of typeBuckets.entries()) {
              if (type === 'unknown') continue;
              if (bucket.length >= 3) {
                selectedItems = bucket.slice(0, 3);
                break;
              }
            }
          }

          // Strategy 3: fallback to lowest rarity unique items
          if (!selectedItems) {
            const pool = [...availableItems].sort((a, b) => rarityScore(a) - rarityScore(b));
            selectedItems = pool.slice(0, 3);
          }

          if (!selectedItems || selectedItems.length < 3) {
            this.showToast('âŒ Could not select 3 items for alchemy!');
            return;
          }

          // Fill alchemy slots
          const cleanedSelection = selectedItems.slice(0, 3).map(item => {
            const clone = { ...item };
            delete clone.__autoKey;
            delete clone.typeKey;
            return clone;
          });
          this.state.alchemySlots = cleanedSelection;
          
          // Calculate result
          this.calculateAlchemyResult();
          
          if (!this.state.alchemyResult) {
            debugWarn('[AUTO ALCHEMY] Failed to create recipe with selection:', cleanedSelection.map(i => i.id || i.name));
            this.showToast('âŒ Auto Alchemy: Could not create valid recipe!');
            this.state.alchemySlots = [null, null, null];
            return;
          }

          // Perform the craft
          this.performCraft();
          
          this.showToast(`âœ¨ Auto Alchemy: Used ${cleanedSelection.map(i => i.icon || '?').join(' ')} â†’ Crafted automatically!`);
          debugLog('[AUTO ALCHEMY] Performed automatic alchemy:', {
            inputs: cleanedSelection.map(i => ({ name: i.name, type: i.type || i.category || this.getItemTypeKey(i) })),
            result: this.state.alchemyResult?.name
          });
        },

        performCraft() {
          if (!this.state.alchemyResult) {
            this.showToast('âš ï¸ No valid recipe!');
            return;
          }

          // STEP 3: Remove items from inventory (handle all item types)
          this.state.alchemySlots.forEach(item => {
            if (item) {
              if (item.quantity) {
                // It's a consumable/container
                const itemsInventory = window.gameState.inventory.items;
                if (Array.isArray(itemsInventory)) {
                  const invIndex = itemsInventory.findIndex(i => i.id === item.id);
                  if (invIndex !== -1) {
                    itemsInventory[invIndex].quantity = (itemsInventory[invIndex].quantity || 0) - 1;
                    if (itemsInventory[invIndex].quantity <= 0) {
                      itemsInventory.splice(invIndex, 1);
                    }
                  }
                }
              } else if (item.type === 'pet' || item.category === 'pet') {
                // Remove from pets inventory
                const petIndex = window.gameState.inventory.pets?.findIndex(p => p.id === item.id);
                if (petIndex !== -1) window.gameState.inventory.pets.splice(petIndex, 1);
              } else if (item.type === 'spirit' || item.category === 'spirit') {
                // Remove from spirits inventory
                const spiritIndex = window.gameState.inventory.spirits?.findIndex(s => s.id === item.id);
                if (spiritIndex !== -1) window.gameState.inventory.spirits.splice(spiritIndex, 1);
              } else if (item.type === 'vehicle' || item.category === 'vehicle') {
                // Remove from vehicles inventory
                const vehicleIndex = window.gameState.inventory.vehicles?.findIndex(v => v.id === item.id);
                if (vehicleIndex !== -1) window.gameState.inventory.vehicles.splice(vehicleIndex, 1);
              } else if (item.type === 'robot' || item.category === 'robot') {
                // Remove from robots inventory
                const robotIndex = window.gameState.inventory.robots?.findIndex(r => r.id === item.id);
                if (robotIndex !== -1) window.gameState.inventory.robots.splice(robotIndex, 1);
              } else {
                // It's gear
                const gearIndex = window.gameState.inventory.gear.findIndex(g => g.id === item.id);
                if (gearIndex !== -1) window.gameState.inventory.gear.splice(gearIndex, 1);
              }
            }
          });

          // Add result to inventory
          const result = this.state.alchemyResult;
          
          // === IMPROVED REWARD FORMULA (1k-10k range) ===
          const inputValue = result.inputValue || this.state.alchemyInputValue || 300;
          
          // Base reward: 2x to 5x the input value
          let goldReward = inputValue * (2 + Math.random() * 3);
          
          // Rarity bonus multiplier
          const rarityBonus = {
            common: 1.0,
            uncommon: 1.5,
            rare: 2.5,
            epic: 4.0,
            legendary: 6.0
          }[result.rarity || 'uncommon'] || 1.5;
          
          goldReward *= rarityBonus;
          
          // Type bonus
          if (result.type === 'fusion') {
            goldReward *= 1.5; // Fusion recipes give 50% more
          }
          
          // Ensure minimum 1k, cap at 10k
          goldReward = Math.max(1000, Math.min(10000, Math.floor(goldReward)));
          
          // Random variance Â±10%
          goldReward = Math.floor(goldReward * (0.9 + Math.random() * 0.2));
          
          // Apply random outcomes & formulas
          const tier = window.gameState.alchemyUpgrades.currentTier;
          const probTable = this.OUTCOME_PROBABILITIES[`tier${tier}`] || this.OUTCOME_PROBABILITIES.tier1;
          const outcomeQuality = this.rollRandomOutcome(probTable);
          
          // Quality multipliers
          const qualityMultipliers = {
            perfect: 1.25,
            great: 1.15,
            good: 1.0,
            basic: 0.90,
            failure: 0.50
          };
          
          const qualityMult = qualityMultipliers[outcomeQuality] || 1.0;
          
          // === ADD EVOLVED ITEMS TO CORRECT INVENTORY ===
          if (result.isEvolved) {
            // Apply random variation for the item type
            const variation = this.generateRandomVariation(result.type);
            
            // This is an evolved item - add to specific inventory based on type
            let evolvedItem = {
              id: 'evolved_' + Date.now() + '_' + Math.random(),
              name: result.name,
              icon: result.icon,
              rarity: result.rarity || 'uncommon',
              type: result.type,
              category: result.category,
              attack: Math.floor((result.attack || 0) * qualityMult),
              defense: Math.floor((result.defense || 0) * qualityMult),
              hp: Math.floor((result.hp || 0) * qualityMult),
              speed: Math.floor((result.speed || 0) * qualityMult),
              description: result.description + ' (Alchemy Evolved)',
              levelReq: window.RARITY_REQUIREMENTS?.[result.rarity]?.level || 1,
              craftQuality: outcomeQuality
            };
            
            // Apply variation bonuses if available
            if (variation) {
              evolvedItem.name = `${variation.name} ${evolvedItem.name}`;
              evolvedItem.icon = variation.icon;
              
              if (variation.atkBonus && evolvedItem.attack) {
                evolvedItem.attack = Math.floor(evolvedItem.attack * variation.atkBonus);
              }
              if (variation.defBonus && evolvedItem.defense) {
                evolvedItem.defense = Math.floor(evolvedItem.defense * variation.defBonus);
              }
              if (variation.hpBonus && evolvedItem.hp) {
                evolvedItem.hp = Math.floor(evolvedItem.hp * variation.hpBonus);
              }
              if (variation.speedBonus && evolvedItem.speed) {
                evolvedItem.speed = Math.floor(evolvedItem.speed * variation.speedBonus);
              }
              if (variation.speedPenalty && evolvedItem.speed) {
                evolvedItem.speed = Math.floor(evolvedItem.speed * variation.speedPenalty);
              }
              if (variation.atkPenalty && evolvedItem.attack) {
                evolvedItem.attack = Math.floor(evolvedItem.attack * variation.atkPenalty);
              }
            }
            
            // Apply rare affix
            const affixRoll = Math.random();
            const affixChance = window.gameState.alchemyUpgrades.bonusRates.rareAffixChance;
            if (affixRoll < affixChance && outcomeQuality !== 'failure') {
              evolvedItem = this.applyRareAffix(evolvedItem, tier);
            }
            
            // Handle failure outcomes
            if (outcomeQuality === 'failure') {
              const failureType = Math.random();
              if (failureType < 0.4) {
                // Partial failure - still get item but very weak
                this.showToast('âš ï¸ Alchemy partially failed! Got weak item...');
                this.addSystemMessage('âš ï¸ PARTIAL FAILURE: Craft succeeded but item is weakened', 'warning');
              } else if (failureType < 0.8) {
                // Complete failure - get 50% gold back
                const refundGold = Math.floor(goldReward * 0.5);
                window.gameState.gold += refundGold;
                this.showToast(`ğŸ’¥ Alchemy FAILED! Refunded ${refundGold.toLocaleString()}g`);
                this.addSystemMessage('ğŸ’¥ COMPLETE FAILURE: Items lost, partial refund given', 'warning');
                this.clearAlchemySlots();
                this.syncAllSystems();
                return;
              } else {
                // Explosion - lose everything
                this.showToast('ğŸ’¥ EXPLOSION! All items destroyed!');
                this.addSystemMessage('ğŸ’¥ CRITICAL FAILURE: Alchemy explosion! Items lost!', 'warning');
                this.createParticleEffect('explosion', window.innerWidth / 2, window.innerHeight / 2);
                this.clearAlchemySlots();
                this.syncAllSystems();
                return;
              }
            }
            
            // Quality indicators in toast
            const qualityEmoji = {
              perfect: 'â­',
              great: 'âœ¨',
              good: 'âœ“',
              basic: 'â—‹',
              failure: 'âš ï¸'
            };
            const qualityText = outcomeQuality.toUpperCase();
            
            // Add to correct inventory array
            debugLog('ğŸ”§ [ALCHEMY DEBUG] Adding evolved item:', evolvedItem);
            debugLog('ğŸ”§ [ALCHEMY DEBUG] Item type:', result.type, '| Category:', result.category);
            
            let itemAdded = false;
            let addedLocation = '';
            
            if (result.type === 'pet') {
              if (!window.gameState.inventory.pets) window.gameState.inventory.pets = [];
              window.gameState.inventory.pets.push(evolvedItem);
              itemAdded = true;
              addedLocation = 'Pets Tab';
              const msg = result.isCombo ? `ğŸ‰ COMBO [${qualityText}]: ${qualityEmoji[outcomeQuality]} ${evolvedItem.name}!` : `ğŸ¾ ${qualityText}: ${qualityEmoji[outcomeQuality]} ${evolvedItem.name}!`;
              this.showToast(msg);
              debugLog('âœ… [ALCHEMY] Added to PETS inventory. Total pets:', window.gameState.inventory.pets.length);
            } else if (result.type === 'spirit') {
              if (!window.gameState.inventory.spirits) window.gameState.inventory.spirits = [];
              window.gameState.inventory.spirits.push(evolvedItem);
              itemAdded = true;
              addedLocation = 'Spirit Tab';
              const msg = result.isCombo ? `ğŸ‰ COMBO [${qualityText}]: ${qualityEmoji[outcomeQuality]} ${evolvedItem.name}!` : `âœ¨ ${qualityText}: ${qualityEmoji[outcomeQuality]} ${evolvedItem.name}!`;
              this.showToast(msg);
              debugLog('âœ… [ALCHEMY] Added to SPIRITS inventory. Total spirits:', window.gameState.inventory.spirits.length);
            } else if (result.type === 'vehicle') {
              if (!window.gameState.inventory.vehicles) window.gameState.inventory.vehicles = [];
              window.gameState.inventory.vehicles.push(evolvedItem);
              itemAdded = true;
              addedLocation = 'Vehicles Tab';
              const msg = result.isCombo ? `ğŸ‰ COMBO [${qualityText}]: ${qualityEmoji[outcomeQuality]} ${evolvedItem.name}!` : `ğŸš— ${qualityText}: ${qualityEmoji[outcomeQuality]} ${evolvedItem.name}!`;
              this.showToast(msg);
              debugLog('âœ… [ALCHEMY] Added to VEHICLES inventory. Total vehicles:', window.gameState.inventory.vehicles.length);
            } else if (result.type === 'robot') {
              if (!window.gameState.inventory.robots) window.gameState.inventory.robots = [];
              window.gameState.inventory.robots.push(evolvedItem);
              itemAdded = true;
              addedLocation = 'Robots (AI Tab)';
              const msg = result.isCombo ? `ğŸ‰ COMBO [${qualityText}]: ${qualityEmoji[outcomeQuality]} ${evolvedItem.name}!` : `ğŸ¤– ${qualityText}: ${qualityEmoji[outcomeQuality]} ${evolvedItem.name}!`;
              this.showToast(msg);
              debugLog('âœ… [ALCHEMY] Added to ROBOTS inventory. Total robots:', window.gameState.inventory.robots.length);
            } else if (result.type === 'weapon' || result.type === 'armor' || result.type === 'accessory' || result.type === 'set') {
              if (!window.gameState.inventory.gear) window.gameState.inventory.gear = [];
              evolvedItem.slot = result.type === 'set' ? 'weapon' : result.type; // Set gear slot
            this.normalizeGearItem(evolvedItem);
              window.gameState.inventory.gear.push(evolvedItem);
              itemAdded = true;
              addedLocation = 'Gear Tab';
              const msg = result.isCombo ? `ğŸ‰ COMBO [${qualityText}]: ${qualityEmoji[outcomeQuality]} ${evolvedItem.name}!` : `âš”ï¸ ${qualityText}: ${qualityEmoji[outcomeQuality]} ${evolvedItem.name}!`;
              this.showToast(msg);
              debugLog('âœ… [ALCHEMY] Added to GEAR inventory. Total gear:', window.gameState.inventory.gear.length);
            } else if (result.type === 'consumable' || result.type === 'scroll' || result.type === 'box' || result.type === 'essence' || result.type === 'core' || result.type === 'cores') {
              if (!window.gameState.inventory.items) window.gameState.inventory.items = [];
              window.gameState.inventory.items.push(evolvedItem);
              itemAdded = true;
              addedLocation = 'Items Tab';
              const msg = result.isMasterRecipe ? `ğŸ‘‘ MASTER [${qualityText}]: ${qualityEmoji[outcomeQuality]} ${evolvedItem.name}!` : 
                          result.isCombo ? `ğŸ‰ COMBO [${qualityText}]: ${qualityEmoji[outcomeQuality]} ${evolvedItem.name}!` : 
                          `âœ¨ ${qualityText}: ${qualityEmoji[outcomeQuality]} ${evolvedItem.name}!`;
              this.showToast(msg);
              debugLog('âœ… [ALCHEMY] Added to ITEMS inventory. Total items:', window.gameState.inventory.items.length);
            } else {
              // Check if it's a supernatural power
              if (result.type === 'supernatural' || result.category === 'supernatural' || result.element) {
                if (!window.gameState.inventory.powers) window.gameState.inventory.powers = [];
                evolvedItem.level = 1;
                evolvedItem.equipped = false;
                evolvedItem.active = false;
                window.gameState.inventory.powers.push(evolvedItem);
                itemAdded = true;
                addedLocation = 'Supernatural Tab';
                this.showToast(`âœ¨ ${qualityText}: ${qualityEmoji[outcomeQuality]} ${evolvedItem.name}!`);
                debugLog(`âœ… [ALCHEMY] SUPERNATURAL POWER ADDED: ${evolvedItem.name} â†’ ${addedLocation}`);
              } else {
                // FALLBACK: If type doesn't match anything, add to items as a safe default
                debugWarn('âš ï¸ [ALCHEMY] Unknown item type, adding to ITEMS as fallback:', result.type);
                if (!window.gameState.inventory.items) window.gameState.inventory.items = [];
                window.gameState.inventory.items.push(evolvedItem);
                itemAdded = true;
                addedLocation = 'Items Tab (Fallback)';
                this.showToast(`âœ¨ ${qualityText}: ${qualityEmoji[outcomeQuality]} ${evolvedItem.name}!`);
              }
            }
            
            // Add summary message showing where to find the item
            if (itemAdded) {
              this.addSystemMessage(`ğŸ“¦ ITEM ADDED: ${evolvedItem.name} â†’ Check ${addedLocation}!`, 'reward');
            }
            
            // Increment craft count
            window.gameState.alchemyUpgrades.craftCount++;
            
            // Track discovered recipes
            const recipeKey = result.isCombo ? `combo_${evolvedItem.name}` : `evolution_${result.type}`;
            if (!window.gameState.alchemyUpgrades.discoveredRecipes.includes(recipeKey)) {
              window.gameState.alchemyUpgrades.discoveredRecipes.push(recipeKey);
              this.addSystemMessage(`ğŸ“– NEW RECIPE DISCOVERED: ${evolvedItem.name}!`, 'reward');
            }
            
            // System messages
            if (result.isMasterRecipe) {
              this.addSystemMessage(`ğŸ‘‘ MASTER RECIPE DISCOVERED [${qualityText}]! ${evolvedItem.name} - LEGENDARY TIER!`, 'reward');
              this.createParticleEffect('celebration', window.innerWidth / 2, window.innerHeight / 2);
            } else if (evolvedItem.hasAffix) {
              this.addSystemMessage(`ğŸŒŸ RARE AFFIX APPLIED! Item enhanced with special bonus!`, 'reward');
            }
            
            if (result.isCombo && !result.isMasterRecipe) {
              this.addSystemMessage(`ğŸ‰ ALCHEMY COMBO [${qualityText}]: ${result.rarity.toUpperCase()} ${evolvedItem.name}!`, 'reward');
            } else if (!result.isMasterRecipe) {
              this.addSystemMessage(`âš—ï¸ EVOLUTION [${qualityText}]: Created ${result.rarity.toUpperCase()} ${evolvedItem.name}!`, 'reward');
            }
          } else {
            // It's a box/container - add to items inventory
            const craftedItem = {
              id: 'crafted_' + Date.now() + '_' + Math.random(),
              name: result.name,
              icon: result.icon,
              rarity: result.rarity || 'uncommon',
              type: result.type,
              category: 'container',
              description: `Crafted via alchemy. Value: ${goldReward}g`,
              quantity: 1,
              value: goldReward
            };
            
              debugLog('ğŸ”§ [ALCHEMY DEBUG] Adding box/container item:', craftedItem);
            
            if (!window.gameState.inventory.items) {
              window.gameState.inventory.items = [];
            }
            window.gameState.inventory.items.push(craftedItem);
            
            debugLog('âœ… [ALCHEMY] Added box to ITEMS inventory. Total items:', window.gameState.inventory.items.length);
            
            this.showToast(`âœ¨ Crafted ${result.icon} ${result.name}! +${goldReward.toLocaleString()}g`);
            this.addSystemMessage(`âš—ï¸ ALCHEMY SUCCESS: Created ${result.name} worth ${goldReward.toLocaleString()}g! Check Items tab!`, 'reward');
            this.addSystemMessage(`ğŸ“¦ BOX ADDED: ${result.name} â†’ Check Items Tab!`, 'reward');
          }
          
          // Give gold bonus
          window.gameState.gold += goldReward;

          // Visual effects
          this.createParticleEffect('levelup', window.innerWidth / 2, window.innerHeight / 2);
          
          // Clear result so UI no longer shows the crafted item
          this.state.alchemyResult = null;

          this.clearAlchemySlots();
          this.syncAllSystems();
          
          // STEP 2: Re-render the correct alchemy view
          const currentTab = this.state.activeTab;
          if (currentTab === 'alchemy') {
            // Main alchemy tab is active
            this.renderAlchemyTab();
          } else if (currentTab === 'items' && this.state.itemsSubtab === 'alchemy') {
            // Alchemy workspace in Items tab is active
            this.renderAlchemyWorkspace();
          }
          
          // Also refresh Items tab to show the new crafted item
          if (currentTab === 'items') {
            this.renderItemsInventorySubtab();
          }
        },

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        calculateEquipmentStat(stat) {
          let total = 0;
          const equipped = window.gameState.equipped || {};
          Object.values(equipped).forEach(item => {
            if (item && item[stat]) total += item[stat];
          });
          return total;
        },

        renderPetsTab() {
          const pane = document.getElementById('bagContentPane');
          const equippedPet = window.gameState.equipped.pet;
          let pets = window.gameState.inventory.pets || [];

          const engine = this.ensureEngine();
          const companionManager = engine?.systems?.companion;
          const activePetUid = equippedPet ? this.computeCompanionUid('pet', equippedPet) : null;
          const isActivePetSummoned = activePetUid && companionManager?.isSpawned
            ? !!companionManager.isSpawned(activePetUid)
            : false;
          const activePetBadge = isActivePetSummoned
            ? '<span style="display:inline-flex;align-items:center;padding:4px 10px;border-radius:999px;background:rgba(122,248,200,0.18);color:#7af8c8;border:1px solid rgba(122,248,200,0.55);font-size:11px;text-transform:uppercase;letter-spacing:0.6px;font-weight:700;">Summoned</span>'
            : '<span style="display:inline-flex;align-items:center;padding:4px 10px;border-radius:999px;background:rgba(129,199,255,0.12);color:#81c7ff;border:1px solid rgba(129,199,255,0.4);font-size:11px;text-transform:uppercase;letter-spacing:0.6px;font-weight:700;">Ready</span>';
          const self = this;

          // Apply filter
          if (this.state.petFilter !== 'all') {
            pets = pets.filter(p => p.element === this.state.petFilter);
          }

          // Apply sort
          if (this.state.petSort === 'attack') {
            pets.sort((a, b) => b.attack - a.attack);
          } else if (this.state.petSort === 'health') {
            pets.sort((a, b) => b.health - a.health);
          } else if (this.state.petSort === 'cost') {
            pets.sort((a, b) => a.cost - b.cost);
          } else if (this.state.petSort === 'name') {
            pets.sort((a, b) => a.name.localeCompare(b.name));
          }

          const getElementColor = (element) => {
            const colors = {
              fire: '#ff6b35', ice: '#87ceeb', electric: '#ffeb3b',
              earth: '#8b4513', wind: '#b0e0e6', arcane: '#9b59b6',
              dark: '#7c3aed', light: '#ffd93d', tech: '#74b9ff',
              nature: '#4CAF50', shadow: '#ff69b4'
            };
            return colors[element] || '#4fc3f7';
          };

          const getRarityColor = (rarity) => {
            const colors = {
              common: '#95a5a6', uncommon: '#27ae60', rare: '#3498db',
              epic: '#9b59b6', legendary: '#f39c12'
            };
            return colors[rarity] || '#95a5a6';
          };

          pane.innerHTML = `
            ${equippedPet ? `
              <div style="background: rgba(0, 0, 0, 0.4); border: 2px solid rgba(122, 248, 200, 0.6); border-radius: 12px; padding: 16px; margin-bottom: 20px; animation: petGlow 2s ease-in-out infinite;">
                <h3 style="color: #7af8c8; margin-bottom: 12px; font-size: 16px; display:flex; align-items:center; gap:10px;">ğŸ¾ Active Companion ${activePetBadge}</h3>
                <div style="display: flex; align-items: center; gap: 16px; flex-wrap: wrap;">
                  <div style="font-size: 48px;">${equippedPet.icon}</div>
                  <div style="flex: 1;">
                    <div style="font-size: 18px; font-weight: 700; color: #7af8c8; margin-bottom: 4px;">${equippedPet.name}</div>
                    <div style="font-size: 12px; color: rgba(207, 227, 255, 0.7); margin-bottom: 8px;">${equippedPet.description}</div>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                      <span style="padding: 4px 10px; background: rgba(255, 107, 53, 0.2); border-radius: 6px; font-size: 11px; color: #ff6b35;">
                        âš”ï¸ ATK: ${equippedPet.attack}
                      </span>
                      <span style="padding: 4px 10px; background: rgba(56, 239, 125, 0.2); border-radius: 6px; font-size: 11px; color: #38ef7d;">
                        â¤ï¸ HP: ${equippedPet.health}
                      </span>
                      <span style="padding: 4px 10px; background: rgba(0, 229, 255, 0.2); border-radius: 6px; font-size: 11px; color: #00e5ff;">
                        âš¡ Speed: ${equippedPet.speed.toFixed(1)}
                      </span>
                      <span style="padding: 4px 10px; background: rgba(167, 139, 250, 0.2); border-radius: 6px; font-size: 11px; color: #a78bfa;">
                        âœ¨ ${equippedPet.ability} (${equippedPet.abilityDamage} dmg)
                      </span>
                      <span style="padding: 4px 10px; background: ${getElementColor(equippedPet.element)}33; border: 1px solid ${getElementColor(equippedPet.element)}; border-radius: 6px; font-size: 11px; text-transform: uppercase; color: ${getElementColor(equippedPet.element)};">
                        ${equippedPet.element}
                      </span>
                    </div>
                  </div>
                  <button class="gear-equip-btn" onclick="window.BagSystem.unequipPet()" style="width: auto; padding: 10px 20px;">
                    Recall Pet
                  </button>
                </div>
              </div>
            ` : ''}
            <div class="inventory-header">
              <h3>Pet Collection (${pets.length})</h3>
              <div class="filter-sort-controls">
                <div class="filter-chips">
                  <button class="filter-chip ${this.state.petFilter === 'all' ? 'active' : ''}" data-filter="all">All</button>
                  <button class="filter-chip ${this.state.petFilter === 'fire' ? 'active' : ''}" data-filter="fire">ğŸ”¥ Fire</button>
                  <button class="filter-chip ${this.state.petFilter === 'ice' ? 'active' : ''}" data-filter="ice">â„ï¸ Ice</button>
                  <button class="filter-chip ${this.state.petFilter === 'electric' ? 'active' : ''}" data-filter="electric">âš¡ Electric</button>
                  <button class="filter-chip ${this.state.petFilter === 'arcane' ? 'active' : ''}" data-filter="arcane">âœ¨ Arcane</button>
                  <button class="filter-chip ${this.state.petFilter === 'dark' ? 'active' : ''}" data-filter="dark">ğŸ‘¹ Dark</button>
                </div>
                <select class="sort-dropdown" id="petSort">
                  <option value="attack" ${this.state.petSort === 'attack' ? 'selected' : ''}>Sort: Attack</option>
                  <option value="health" ${this.state.petSort === 'health' ? 'selected' : ''}>Sort: Health</option>
                  <option value="cost" ${this.state.petSort === 'cost' ? 'selected' : ''}>Sort: Cost</option>
                  <option value="name" ${this.state.petSort === 'name' ? 'selected' : ''}>Sort: Name</option>
                </select>
              </div>
            </div>

            ${pets.length === 0 ? `
              <div class="tab-empty">
                <div class="empty-icon">ğŸ¾</div>
                <p>No pets match filter</p>
              </div>
            ` : `
              <div class="gear-items-grid">
                ${pets.map(pet => (() => {
            const candidateUid = self.computeCompanionUid('pet', pet);
            const isEquipped = !!equippedPet && (equippedPet.uid === candidateUid || equippedPet.id === pet.id);
            let isSummoned = false;
            if (candidateUid && companionManager?.isSpawned) {
              try {
                isSummoned = !!companionManager.isSpawned(candidateUid);
              } catch (_) {
                isSummoned = false;
              }
            }
            const badgeMarkup = isSummoned
              ? '<div style="position: absolute; top: 8px; right: 8px; background: rgba(122, 248, 200, 0.9); color: #000; padding: 4px 8px; border-radius: 6px; font-size: 10px; font-weight: 700;">SUMMONED</div>'
              : (isEquipped ? '<div style="position: absolute; top: 8px; right: 8px; background: rgba(129, 199, 255, 0.9); color: #000; padding: 4px 8px; border-radius: 6px; font-size: 10px; font-weight: 700;">READY</div>' : '');
            const equipCheck = typeof self.canEquipItem === 'function'
              ? self.canEquipItem(pet, 'pet')
              : { canEquip: true };
            const buttonIntent = isSummoned ? 'recall' : (isEquipped ? 'summon' : 'equip');
            const buttonLabel = isSummoned ? 'Recall' : (isEquipped ? 'Summon' : 'Equip');
            const buttonDisabled = (!equipCheck.canEquip && !isEquipped) ? 'disabled' : '';
            return `
                    <div class="gear-item-card pet-card ${isEquipped ? 'equipped-pet' : ''}" data-pet-id="${pet.id}" style="border-color: ${getElementColor(pet.element)};">
                      ${badgeMarkup}
                      <div class="gear-item-icon" style="font-size: 40px;">${pet.icon}</div>
                      <div class="gear-item-name">${pet.name}</div>
                      <div style="font-size: 10px; padding: 3px 8px; background: ${getRarityColor(pet.rarity)}; border-radius: 6px; margin: 4px 0; text-transform: uppercase; color: #fff;">${pet.rarity}</div>
                      <div class="gear-item-stats">
                        <span class="stat-badge" style="background: rgba(255, 107, 53, 0.2); color: #ff6b35;">
                          âš”ï¸ ${pet.attack}
                        </span>
                        <span class="stat-badge" style="background: rgba(56, 239, 125, 0.2); color: #38ef7d;">
                          â¤ï¸ ${pet.health}
                        </span>
                        <span class="stat-badge" style="background: rgba(0, 229, 255, 0.2); color: #00e5ff;">
                          âš¡ ${pet.speed.toFixed(1)}
                        </span>
                      </div>
                      <div style="font-size: 10px; color: ${getElementColor(pet.element)}; margin: 6px 0; text-transform: uppercase; font-weight: 700;">${pet.element}</div>
                      <div style="font-size: 9px; color: rgba(167, 139, 250, 0.8); margin-bottom: 4px;">âœ¨ ${pet.ability} (${pet.abilityDamage} dmg)</div>
                      <div style="font-size: 10px; color: rgba(255, 215, 122, 0.8); margin: 6px 0;">ğŸ’° ${pet.cost.toLocaleString()} g</div>
                      <div style="font-size: 9px; color: rgba(207, 227, 255, 0.5); font-style: italic; margin-bottom: 10px; height: 28px; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;">
                        ${pet.description}
                      </div>
                      <div class="pet-actions" style="display: flex; flex-direction: column; gap: 4px;">
                        <button class="pet-action-btn summon" data-action="summon" data-intent="${buttonIntent}" data-pet-id="${pet.id}" ${buttonDisabled}>
                          ${buttonLabel}
                        </button>
                        <button class="pet-action-btn preview" data-action="preview" data-pet-id="${pet.id}" style="font-size: 9px; padding: 4px 8px;">
                          Preview FX
                        </button>
                        <button class="pet-action-btn feed" data-action="feed" data-pet-id="${pet.id}" style="font-size: 9px; padding: 4px 8px;">
                          Feed
                        </button>
                        ${pet.level >= 10 ? `<button class="pet-action-btn evolve" data-action="evolve" data-pet-id="${pet.id}" style="font-size: 9px; padding: 4px 8px; background: linear-gradient(135deg, #f39c12, #ff6b35);">Evolve</button>` : ''}
                      </div>
                    </div>
                  `;
          })()).join('')}
              </div>
            `}
          `;

          // Attach filter listeners
          pane.querySelectorAll('.filter-chip').forEach(chip => {
            chip.addEventListener('click', () => {
              this.state.petFilter = chip.dataset.filter;
              this.renderPetsTab();
            });
          });

          // Attach sort listener
          const sortSelect = pane.querySelector('#petSort');
          if (sortSelect) {
            sortSelect.addEventListener('change', (e) => {
              this.state.petSort = e.target.value;
              this.renderPetsTab();
            });
          }

          // Attach pet action buttons
          pane.querySelectorAll('.pet-action-btn').forEach(btn => {
            btn.addEventListener('click', () => {
              const action = btn.dataset.action;
              const petId = btn.dataset.petId;
              const pet = window.gameState.inventory.pets.find(p => p.id === petId);

              if (action === 'summon' && pet) {
                const intent = btn.dataset.intent || 'summon';
                if (intent === 'equip') {
                  // Just equip the pet without summoning
                  this.equipPet(pet);
                } else {
                  this.toggleCompanionActivation('pet', {
                    ensureEquip: true,
                    item: pet,
                    preferSpawn: intent !== 'recall',
                    forceRecall: intent === 'recall',
                    origin: 'pets-tab',
                    showToast: false,
                  });
                }
              }
              else if (action === 'preview' && pet) this.previewPetFx(petId);
              else if (action === 'feed' && pet) this.feedPet(petId);
              else if (action === 'evolve' && pet) this.evolvePet(petId);
            });
          });

        },

        renderSkinsTab() {
          const pane = document.getElementById('bagContentPane');
          
          // Initialize skin subtab (default to Stats for Ability Points)
          if (!this.state.skinSubtab) {
            this.state.skinSubtab = 'stats';
          }
          
          const skins = window.gameState.skins || {};
          const selectedChar = this.state.selectedCharacter || 'Missy';
          const characterSkins = skins[selectedChar] || [];
          const equippedSkin = window.gameState.equippedSkins[selectedChar];

          const getRarityColor = (rarity) => {
            const colors = { common: '#95a5a6', rare: '#3498db', epic: '#9b59b6', legendary: '#f39c12' };
            return colors[rarity] || '#95a5a6';
          };

          pane.innerHTML = `
            <div style="padding: 20px;">
              <div style="margin-bottom: 20px;">
                <h2 style="font-size: 22px; color: #ffd77a; margin-bottom: 10px;">ğŸ‘¤ Player</h2>
                <p style="color: rgba(207, 227, 255, 0.7); font-size: 13px; margin-bottom: 20px;">
                  Manage your stats and customize your character's appearance!
                </p>
              </div>
              
              <!-- Player Subtabs -->
              <div style="display: flex; gap: 8px; margin-bottom: 20px; border-bottom: 2px solid rgba(79, 195, 247, 0.2); padding-bottom: 10px;">
                <button class="skin-subtab-btn ${this.state.skinSubtab === 'stats' ? 'active' : ''}" data-subtab="stats" style="padding: 10px 20px; background: ${this.state.skinSubtab === 'stats' ? 'rgba(56, 239, 125, 0.3)' : 'rgba(0, 0, 0, 0.3)'}; border: 2px solid ${this.state.skinSubtab === 'stats' ? 'rgba(56, 239, 125, 0.6)' : 'rgba(79, 195, 247, 0.3)'}; border-radius: 8px; color: ${this.state.skinSubtab === 'stats' ? '#38ef7d' : 'rgba(207, 227, 255, 0.7)'}; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.3s ease;">
                  âš¡ Stats
                </button>
                <button class="skin-subtab-btn ${this.state.skinSubtab === 'characters' ? 'active' : ''}" data-subtab="characters" style="padding: 10px 20px; background: ${this.state.skinSubtab === 'characters' ? 'rgba(91, 163, 255, 0.3)' : 'rgba(0, 0, 0, 0.3)'}; border: 2px solid ${this.state.skinSubtab === 'characters' ? 'rgba(91, 163, 255, 0.6)' : 'rgba(79, 195, 247, 0.3)'}; border-radius: 8px; color: ${this.state.skinSubtab === 'characters' ? '#5ba3ff' : 'rgba(207, 227, 255, 0.7)'}; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.3s ease;">
                  ğŸ‘¥ Characters
                </button>
                <button class="skin-subtab-btn ${this.state.skinSubtab === 'skins' ? 'active' : ''}" data-subtab="skins" style="padding: 10px 20px; background: ${this.state.skinSubtab === 'skins' ? 'rgba(255, 215, 122, 0.3)' : 'rgba(0, 0, 0, 0.3)'}; border: 2px solid ${this.state.skinSubtab === 'skins' ? 'rgba(255, 215, 122, 0.6)' : 'rgba(79, 195, 247, 0.3)'}; border-radius: 8px; color: ${this.state.skinSubtab === 'skins' ? '#ffd77a' : 'rgba(207, 227, 255, 0.7)'}; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.3s ease;">
                  ğŸ¨ Skins
                </button>
                <button class="skin-subtab-btn ${this.state.skinSubtab === 'cosmetics' ? 'active' : ''}" data-subtab="cosmetics" style="padding: 10px 20px; background: ${this.state.skinSubtab === 'cosmetics' ? 'rgba(167, 139, 250, 0.3)' : 'rgba(0, 0, 0, 0.3)'}; border: 2px solid ${this.state.skinSubtab === 'cosmetics' ? 'rgba(167, 139, 250, 0.6)' : 'rgba(79, 195, 247, 0.3)'}; border-radius: 8px; color: ${this.state.skinSubtab === 'cosmetics' ? '#a78bfa' : 'rgba(207, 227, 255, 0.7)'}; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.3s ease;">
                  âœ¨ Cosmetics
                </button>
              </div>
              
              <div id="skin-subtab-content"></div>
            </div>
          `;
          
          // Render the active subtab
          this.renderSkinSubtab();
          
          // Attach subtab button listeners
          setTimeout(() => {
            document.querySelectorAll('.skin-subtab-btn').forEach(btn => {
              btn.addEventListener('click', () => {
                this.state.skinSubtab = btn.getAttribute('data-subtab');
                this.renderSkinsTab();
              });
            });
          }, 50);
        },
        
        renderSkinSubtab() {
          const container = document.getElementById('skin-subtab-content');
          if (!container) return;
          
          if (this.state.skinSubtab === 'stats') {
            this.renderStatsSubtab(container);
          } else if (this.state.skinSubtab === 'characters') {
            this.renderCharacterSprites();
          } else if (this.state.skinSubtab === 'skins') {
            this.renderSkinsSubtab(container);
          } else if (this.state.skinSubtab === 'cosmetics') {
            this.renderCosmeticsSubtab(container);
          }
        },
        
        renderStatsSubtab(container) {
          // Error handling: Check container exists
          if (!container) {
            debugError('[BagSystem] renderStatsSubtab: container not found');
            return;
          }
          
          // Error handling: Check gameState exists
          if (!window.gameState) {
            container.innerHTML = '<div style="color: #ff6b6b; padding: 20px; text-align: center;">âŒ Game state not initialized! Please refresh the page.</div>';
            return;
          }
          
          const abilityPoints = window.gameState.abilityPoints || 0;
          const pointsInStrength = window.gameState.pointsInStrength || 0;
          const pointsInVitality = window.gameState.pointsInVitality || 0;
          const pointsInAgility = window.gameState.pointsInAgility || 0;
          const pointsInIntelligence = window.gameState.pointsInIntelligence || 0;
          
          // Calculate stat bonuses
          const strengthBonus = pointsInStrength * 2;
          const vitalityDefBonus = Math.floor(pointsInVitality * 1.5);
          const vitalityHpBonus = pointsInVitality * 10;
          const agilitySpeedBonus = (pointsInAgility * 0.5).toFixed(1);
          const agilityCritBonus = (pointsInAgility * 0.3).toFixed(1);
          const intelligenceMpBonus = pointsInIntelligence * 5;
          const intelligenceCdBonus = (pointsInIntelligence * 0.2).toFixed(1);
          
          container.innerHTML = `
            <div style="background: rgba(0, 0, 0, 0.3); border: 2px solid rgba(56, 239, 125, 0.4); border-radius: 12px; padding: 20px;">
              <div style="margin-bottom: 20px; text-align: center;">
                <div style="padding: 12px 24px; background: linear-gradient(135deg, rgba(255, 154, 158, 0.3), rgba(254, 207, 239, 0.3)); border: 2px solid rgba(56, 239, 125, 0.6); border-radius: 12px; display: inline-block;">
                  <span style="color: #38ef7d; font-weight: bold; font-size: 18px;">âš¡ Ability Points Available: ${abilityPoints}</span>
                </div>
                <p style="color: rgba(207, 227, 255, 0.7); font-size: 12px; margin-top: 8px;">
                  Allocate ability points to enhance your character's stats!
                </p>
              </div>
              
              <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 16px;">
                <!-- Strength -->
                <div style="background: rgba(255, 107, 107, 0.1); border: 2px solid rgba(255, 107, 107, 0.4); border-radius: 12px; padding: 16px;">
                  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                    <div>
                      <h3 style="color: #ff6b6b; font-size: 16px; margin-bottom: 4px;">âš”ï¸ Strength</h3>
                      <p style="color: rgba(207, 227, 255, 0.7); font-size: 11px;">Increases Attack Damage</p>
                    </div>
                    <div style="text-align: right;">
                      <div style="color: #ff6b6b; font-size: 20px; font-weight: bold;">${pointsInStrength}</div>
                      <div style="color: rgba(207, 227, 255, 0.6); font-size: 10px;">+${strengthBonus} Attack</div>
                    </div>
                  </div>
                  <button class="ability-point-btn" data-stat="strength" ${abilityPoints <= 0 ? 'disabled' : ''} style="width: 100%; padding: 10px; background: ${abilityPoints <= 0 ? 'rgba(0, 0, 0, 0.3)' : 'linear-gradient(135deg, rgba(255, 107, 107, 0.3), rgba(255, 154, 158, 0.2))'}; border: 2px solid ${abilityPoints <= 0 ? 'rgba(255, 107, 107, 0.2)' : 'rgba(255, 107, 107, 0.6)'}; border-radius: 8px; color: ${abilityPoints <= 0 ? 'rgba(207, 227, 255, 0.4)' : '#ff6b6b'}; font-weight: bold; font-size: 14px; cursor: ${abilityPoints <= 0 ? 'not-allowed' : 'pointer'}; transition: all 0.3s ease;" ${abilityPoints <= 0 ? '' : 'onmouseover="this.style.transform=\'scale(1.05)\'; this.style.boxShadow=\'0 4px 12px rgba(255, 107, 107, 0.4)\';" onmouseout="this.style.transform=\'scale(1)\'; this.style.boxShadow=\'none\';"'}>
                    + Add Point
                  </button>
                </div>
                
                <!-- Vitality -->
                <div style="background: rgba(79, 195, 247, 0.1); border: 2px solid rgba(79, 195, 247, 0.4); border-radius: 12px; padding: 16px;">
                  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                    <div>
                      <h3 style="color: #4fc3f7; font-size: 16px; margin-bottom: 4px;">ğŸ›¡ï¸ Vitality</h3>
                      <p style="color: rgba(207, 227, 255, 0.7); font-size: 11px;">Increases HP & Defense</p>
                    </div>
                    <div style="text-align: right;">
                      <div style="color: #4fc3f7; font-size: 20px; font-weight: bold;">${pointsInVitality}</div>
                      <div style="color: rgba(207, 227, 255, 0.6); font-size: 10px;">+${vitalityHpBonus} HP, +${vitalityDefBonus} Def</div>
                    </div>
                  </div>
                  <button class="ability-point-btn" data-stat="vitality" ${abilityPoints <= 0 ? 'disabled' : ''} style="width: 100%; padding: 10px; background: ${abilityPoints <= 0 ? 'rgba(0, 0, 0, 0.3)' : 'linear-gradient(135deg, rgba(79, 195, 247, 0.3), rgba(122, 213, 255, 0.2))'}; border: 2px solid ${abilityPoints <= 0 ? 'rgba(79, 195, 247, 0.2)' : 'rgba(79, 195, 247, 0.6)'}; border-radius: 8px; color: ${abilityPoints <= 0 ? 'rgba(207, 227, 255, 0.4)' : '#4fc3f7'}; font-weight: bold; font-size: 14px; cursor: ${abilityPoints <= 0 ? 'not-allowed' : 'pointer'}; transition: all 0.3s ease;" ${abilityPoints <= 0 ? '' : 'onmouseover="this.style.transform=\'scale(1.05)\'; this.style.boxShadow=\'0 4px 12px rgba(79, 195, 247, 0.4)\';" onmouseout="this.style.transform=\'scale(1)\'; this.style.boxShadow=\'none\';"'}>
                    + Add Point
                  </button>
                </div>
                
                <!-- Agility -->
                <div style="background: rgba(56, 239, 125, 0.1); border: 2px solid rgba(56, 239, 125, 0.4); border-radius: 12px; padding: 16px;">
                  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                    <div>
                      <h3 style="color: #38ef7d; font-size: 16px; margin-bottom: 4px;">ğŸ’¨ Agility</h3>
                      <p style="color: rgba(207, 227, 255, 0.7); font-size: 11px;">Increases Speed & Crit Rate</p>
                    </div>
                    <div style="text-align: right;">
                      <div style="color: #38ef7d; font-size: 20px; font-weight: bold;">${pointsInAgility}</div>
                      <div style="color: rgba(207, 227, 255, 0.6); font-size: 10px;">+${agilitySpeedBonus} Speed, +${agilityCritBonus}% Crit</div>
                    </div>
                  </div>
                  <button class="ability-point-btn" data-stat="agility" ${abilityPoints <= 0 ? 'disabled' : ''} style="width: 100%; padding: 10px; background: ${abilityPoints <= 0 ? 'rgba(0, 0, 0, 0.3)' : 'linear-gradient(135deg, rgba(56, 239, 125, 0.3), rgba(122, 248, 200, 0.2))'}; border: 2px solid ${abilityPoints <= 0 ? 'rgba(56, 239, 125, 0.2)' : 'rgba(56, 239, 125, 0.6)'}; border-radius: 8px; color: ${abilityPoints <= 0 ? 'rgba(207, 227, 255, 0.4)' : '#38ef7d'}; font-weight: bold; font-size: 14px; cursor: ${abilityPoints <= 0 ? 'not-allowed' : 'pointer'}; transition: all 0.3s ease;" ${abilityPoints <= 0 ? '' : 'onmouseover="this.style.transform=\'scale(1.05)\'; this.style.boxShadow=\'0 4px 12px rgba(56, 239, 125, 0.4)\';" onmouseout="this.style.transform=\'scale(1)\'; this.style.boxShadow=\'none\';"'}>
                    + Add Point
                  </button>
                </div>
                
                <!-- Intelligence -->
                <div style="background: rgba(167, 139, 250, 0.1); border: 2px solid rgba(167, 139, 250, 0.4); border-radius: 12px; padding: 16px;">
                  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                    <div>
                      <h3 style="color: #a78bfa; font-size: 16px; margin-bottom: 4px;">ğŸ§  Intelligence</h3>
                      <p style="color: rgba(207, 227, 255, 0.7); font-size: 11px;">Increases Mana & Cooldown Reduction</p>
                    </div>
                    <div style="text-align: right;">
                      <div style="color: #a78bfa; font-size: 20px; font-weight: bold;">${pointsInIntelligence}</div>
                      <div style="color: rgba(207, 227, 255, 0.6); font-size: 10px;">+${intelligenceMpBonus} MP, +${intelligenceCdBonus}% CDR</div>
                    </div>
                  </div>
                  <button class="ability-point-btn" data-stat="intelligence" ${abilityPoints <= 0 ? 'disabled' : ''} style="width: 100%; padding: 10px; background: ${abilityPoints <= 0 ? 'rgba(0, 0, 0, 0.3)' : 'linear-gradient(135deg, rgba(167, 139, 250, 0.3), rgba(233, 215, 255, 0.2))'}; border: 2px solid ${abilityPoints <= 0 ? 'rgba(167, 139, 250, 0.2)' : 'rgba(167, 139, 250, 0.6)'}; border-radius: 8px; color: ${abilityPoints <= 0 ? 'rgba(207, 227, 255, 0.4)' : '#a78bfa'}; font-weight: bold; font-size: 14px; cursor: ${abilityPoints <= 0 ? 'not-allowed' : 'pointer'}; transition: all 0.3s ease;" ${abilityPoints <= 0 ? '' : 'onmouseover="this.style.transform=\'scale(1.05)\'; this.style.boxShadow=\'0 4px 12px rgba(167, 139, 250, 0.4)\';" onmouseout="this.style.transform=\'scale(1)\'; this.style.boxShadow=\'none\';"'}>
                    + Add Point
                  </button>
                </div>
              </div>
            </div>
          `;
          
          // Attach ability point button listeners
          setTimeout(() => {
            container.querySelectorAll('.ability-point-btn').forEach(btn => {
              btn.addEventListener('click', () => {
                const stat = btn.getAttribute('data-stat');
                if (stat && !btn.disabled) {
                  this.spendAbilityPoint(stat);
                }
              });
            });
          }, 50);
        },
        
        spendAbilityPoint(stat) {
          // Error handling: Check gameState exists
          if (!window.gameState) {
            if (typeof this.showToast === 'function') {
              this.showToast('âŒ Game state not initialized!');
            }
            debugError('[BagSystem] spendAbilityPoint: gameState not found');
            return;
          }
          
          // Error handling: Check ability points available
          if (!window.gameState.abilityPoints || window.gameState.abilityPoints <= 0) {
            if (typeof this.showToast === 'function') {
              this.showToast('âŒ No ability points available!');
            }
            return;
          }
          
          const statMap = {
            'strength': 'pointsInStrength',
            'vitality': 'pointsInVitality',
            'agility': 'pointsInAgility',
            'intelligence': 'pointsInIntelligence'
          };
          
          const statName = statMap[stat];
          // Error handling: Validate stat name
          if (!statName) {
            if (typeof this.showToast === 'function') {
              this.showToast('âŒ Invalid stat!');
            }
            debugError('[BagSystem] Invalid stat:', stat);
            return;
          }
          
          // Ensure stat counter exists before incrementing
          if (typeof window.gameState[statName] !== 'number') {
            window.gameState[statName] = 0;
          }
          
          window.gameState.abilityPoints--;
          window.gameState[statName] = (window.gameState[statName] || 0) + 1;
          
          const statLabels = {
            'strength': 'Strength',
            'vitality': 'Vitality',
            'agility': 'Agility',
            'intelligence': 'Intelligence'
          };
          
          this.showToast(`âš¡ +1 ${statLabels[stat]}! (${window.gameState.abilityPoints} AP remaining)`);
          
          // Recalculate player stats
          this.computePlayerStats();
          
          // Refresh stats subtab
          if (this.state.activeTab === 'skins' && this.state.skinSubtab === 'stats') {
            this.renderStatsSubtab(document.getElementById('skin-subtab-content'));
          }
        },
        
        showLevelUpAnimation() {
          const abilityPoints = window.gameState.abilityPoints || 0;
          const newLevel = window.gameState.playerLevel || window.gameState.level || 1;
          
          // Remove existing banner if present
          const existingBanner = document.getElementById('level-up-banner');
          if (existingBanner) {
            existingBanner.remove();
          }
          
          // Create banner element
          const banner = document.createElement('div');
          banner.id = 'level-up-banner';
          banner.innerHTML = `
            <div style="text-align: center;">
              <div style="font-size: 48px; font-weight: 900; color: #fff; text-shadow: 0 0 20px #ff00ff, 0 0 40px #ff00ff, 0 0 60px #ff00ff; margin-bottom: 16px; animation: levelUpPop 0.5s ease-out;">
                LEVEL UP!
              </div>
              <div style="font-size: 24px; font-weight: 700; color: #ffd77a; text-shadow: 0 0 15px rgba(255, 215, 122, 0.8); margin-bottom: 8px;">
                Level ${newLevel}
              </div>
              <div style="font-size: 18px; font-weight: 600; color: #38ef7d; text-shadow: 0 0 10px rgba(56, 239, 125, 0.6);">
                âš¡ You have ${abilityPoints} Ability Points to spend!
              </div>
            </div>
          `;
          
          // Style the banner
          banner.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.5);
            background: linear-gradient(135deg, rgba(255, 154, 158, 0.95) 0%, rgba(254, 207, 239, 0.95) 50%, rgba(255, 236, 210, 0.95) 100%);
            border: 4px solid rgba(255, 255, 255, 0.8);
            border-radius: 20px;
            padding: 40px 60px;
            z-index: 10000;
            box-shadow: 0 0 50px rgba(255, 105, 180, 0.6), inset 0 0 30px rgba(255, 255, 255, 0.3);
            opacity: 0;
            pointer-events: none;
            animation: levelUpBanner 0.6s ease-out forwards;
          `;
          
          // Add CSS animation if not already added
          if (!document.getElementById('level-up-animations')) {
            const style = document.createElement('style');
            style.id = 'level-up-animations';
            style.textContent = `
              @keyframes levelUpBanner {
                0% {
                  transform: translate(-50%, -50%) scale(0.5);
                  opacity: 0;
                }
                50% {
                  transform: translate(-50%, -50%) scale(1.1);
                  opacity: 1;
                }
                100% {
                  transform: translate(-50%, -50%) scale(1);
                  opacity: 1;
                }
              }
              @keyframes levelUpPop {
                0%, 100% {
                  transform: scale(1);
                }
                50% {
                  transform: scale(1.15);
                }
              }
            `;
            document.head.appendChild(style);
          }
          
          document.body.appendChild(banner);
          
          // Remove banner after 3 seconds
          setTimeout(() => {
            if (banner.parentNode) {
              banner.style.animation = 'levelUpBanner 0.4s ease-in reverse';
              banner.style.opacity = '0';
              setTimeout(() => {
                if (banner.parentNode) {
                  banner.remove();
                }
              }, 400);
            }
          }, 3000);
          
          // Create particle burst effect (if available)
          if (typeof this.createParticleEffect === 'function') {
            this.createParticleEffect('levelup', window.innerWidth / 2, window.innerHeight / 2);
          }
        },
        
        ensureQuestRecapStyles() {
          if (this.state.questRecapStylesInjected) return;
          const style = document.createElement('style');
          style.id = 'quest-recap-styles';
          style.textContent = `
            @keyframes questRecapFadeIn {
              0% { opacity: 0; transform: translateY(25px) scale(0.95); }
              100% { opacity: 1; transform: translateY(0) scale(1); }
            }
            @keyframes candyConfettiFall {
              0% { transform: translateY(-20px) rotate(0deg); opacity: 1; }
              100% { transform: translateY(180px) rotate(360deg); opacity: 0; }
            }
            .quest-recap-overlay {
              position: fixed;
              inset: 0;
              background: rgba(8, 12, 24, 0.55);
              backdrop-filter: blur(12px);
              display: flex;
              justify-content: center;
              align-items: center;
              z-index: 99999;
              opacity: 0;
              transition: opacity 200ms ease;
            }
            .quest-recap-overlay__inner {
              background: linear-gradient(145deg, rgba(255, 154, 158, 0.85), rgba(254, 207, 239, 0.9), rgba(255, 236, 210, 0.85));
              border: 3px solid rgba(255, 255, 255, 0.6);
              border-radius: 24px;
              box-shadow: 0 24px 60px rgba(10, 13, 35, 0.35);
              padding: 28px 32px;
              width: min(420px, 90vw);
              color: #331a38;
              position: relative;
              transform-origin: center;
            }
            .quest-recap-overlay.quest-recap-visible {
              opacity: 1;
            }
            .quest-recap-card {
              animation: questRecapFadeIn 350ms cubic-bezier(0.16, 1, 0.3, 1);
            }
            .quest-recap-close {
              position: absolute;
              top: 14px;
              right: 14px;
              width: 32px;
              height: 32px;
              border-radius: 50%;
              border: none;
              background: rgba(255, 255, 255, 0.75);
              color: #ff6abf;
              font-weight: 700;
              cursor: pointer;
              transition: transform 150ms ease, background 150ms ease;
            }
            .quest-recap-close:hover {
              transform: scale(1.08);
              background: rgba(255, 255, 255, 0.95);
            }
            .quest-recap-title {
              display: flex;
              align-items: center;
              gap: 12px;
              font-size: 18px;
              font-weight: 800;
              letter-spacing: 0.4px;
            }
            .quest-recap-grid {
              display: grid;
              grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
              gap: 10px;
              margin-top: 18px;
            }
            .quest-recap-pill {
              background: rgba(255, 255, 255, 0.55);
              border-radius: 999px;
              padding: 8px 12px;
              font-size: 12px;
              font-weight: 600;
              color: #3d2252;
              display: inline-flex;
              align-items: center;
              gap: 6px;
              box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.6);
            }
            .quest-recap-description {
              margin-top: 10px;
              font-size: 12px;
              color: rgba(51, 26, 56, 0.75);
            }
            .candy-confetti-piece {
              position: absolute;
              width: 10px;
              height: 16px;
              border-radius: 6px;
              opacity: 0;
              pointer-events: none;
            }
            .candy-confetti-piece.animate {
              animation: candyConfettiFall 800ms ease-out forwards;
            }
          `;
          document.head.appendChild(style);
          this.state.questRecapStylesInjected = true;
        },
        
        showQuestRecapPopup(quest = {}, options = {}) {
          this.state = this.state || {};
          this.ensureQuestRecapStyles();
          
          if (this.state.activeQuestRecapOverlay) {
            this.state.activeQuestRecapOverlay.remove();
            this.state.activeQuestRecapOverlay = null;
          }
          
          const {
            name = 'Quest Complete',
            icon = quest.icon || 'ğŸ¬',
            rewards = quest.rewards || {},
            description = quest.description || 'Sweet victory! Rewards have been delivered to your inventory.'
          } = quest || {};
          
          const overlay = document.createElement('div');
          overlay.className = 'quest-recap-overlay';
          
          const rewardPills = [];
          if (typeof rewards.exp === 'number') rewardPills.push(`<span class="quest-recap-pill">âœ¨ <strong>+${rewards.exp}</strong> EXP</span>`);
          if (typeof rewards.gold === 'number') rewardPills.push(`<span class="quest-recap-pill">ğŸ’° <strong>+${rewards.gold.toLocaleString()}</strong> gold</span>`);
          if (Array.isArray(rewards.items) && rewards.items.length > 0) {
            rewards.items.forEach(item => {
              const label = typeof item === 'string' ? item : item?.name || 'Mystery Item';
              rewardPills.push(`<span class="quest-recap-pill">ğŸ ${label}</span>`);
            });
          }
          if (rewards.token) rewardPills.push(`<span class="quest-recap-pill">ğŸ… ${rewards.token}</span>`);
          if (rewards.title) rewardPills.push(`<span class="quest-recap-pill">ğŸ‘‘ Title: ${rewards.title}</span>`);
          
          const recapCard = document.createElement('div');
          recapCard.className = 'quest-recap-overlay__inner quest-recap-card';
          recapCard.innerHTML = `
            <button class="quest-recap-close" data-close="true">Ã—</button>
            <div class="quest-recap-title">
              <span style="font-size: 32px;">${icon}</span>
              <div>
                <div style="font-size: 12px; letter-spacing: 0.6px; text-transform: uppercase; color: rgba(61, 34, 82, 0.6);">Quest Complete</div>
                <div>${name}</div>
              </div>
            </div>
            <p class="quest-recap-description">${description}</p>
            ${rewardPills.length > 0 ? `<div class="quest-recap-grid">${rewardPills.join('')}</div>` : ''}
          `;
          
          overlay.appendChild(recapCard);
          document.body.appendChild(overlay);
          
          requestAnimationFrame(() => {
            overlay.classList.add('quest-recap-visible');
          });
          
          const cleanup = () => {
            if (!overlay.parentNode) return;
            overlay.classList.remove('quest-recap-visible');
            setTimeout(() => {
              overlay.remove();
            }, 220);
            if (this.state.activeQuestRecapOverlay === overlay) {
              this.state.activeQuestRecapOverlay = null;
            }
          };
          
          overlay.addEventListener('click', (event) => {
            if (event.target === overlay) cleanup();
          });
          recapCard.querySelector('[data-close]').addEventListener('click', cleanup);
          
          const lifetime = options.duration ?? 4500;
          setTimeout(cleanup, lifetime);
          
          this.state.activeQuestRecapOverlay = overlay;
        },
        
        createConfettiEffect(x = window.innerWidth / 2, y = window.innerHeight / 2, options = {}) {
          this.state = this.state || {};
          this.ensureQuestRecapStyles();
          
          const colors = options.colors || ['#ff9a9e', '#fecfef', '#a8edea', '#ffecd2', '#b9fbc0'];
          const count = options.count || 36;
          const spread = options.spread || 220;
          const fallDistance = options.fallDistance || 180;
          
          if (!this.state.candyConfettiLayer) {
            const layer = document.createElement('div');
            layer.style.cssText = `
              position: fixed;
              inset: 0;
              pointer-events: none;
              overflow: visible;
              z-index: 99998;
            `;
            document.body.appendChild(layer);
            this.state.candyConfettiLayer = layer;
          }
          
          for (let i = 0; i < count; i += 1) {
            const piece = document.createElement('span');
            piece.className = 'candy-confetti-piece';
            const offsetX = (Math.random() - 0.5) * spread;
            const offsetY = (Math.random() - 0.3) * (spread / 1.5);
            const size = options.size ?? (8 + Math.random() * 6);
            piece.style.left = `${x + offsetX}px`;
            piece.style.top = `${y + offsetY}px`;
            piece.style.width = `${size}px`;
            piece.style.height = `${Math.max(10, size * 1.5)}px`;
            piece.style.background = colors[Math.floor(Math.random() * colors.length)];
            piece.style.opacity = '1';
            piece.style.transform = `translateY(${-Math.random() * fallDistance}px) rotate(${Math.random() * 180}deg)`;
            piece.style.animationDuration = `${600 + Math.random() * 400}ms`;
            piece.style.animationDelay = `${Math.random() * 120}ms`;
            
            this.state.candyConfettiLayer.appendChild(piece);
            
            requestAnimationFrame(() => {
              piece.classList.add('animate');
            });
            
            setTimeout(() => {
              piece.remove();
            }, 1200);
          }
        },
        
        renderCharactersSubtab(container) {
          const skins = window.gameState.skins || {};
          const selectedChar = this.state.selectedCharacter || 'Missy';
          
          container.innerHTML = `
            <div>
              <h3 style="color: #4fc3f7; margin-bottom: 16px;">ğŸ‘¥ Available Characters</h3>
              
              <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 16px;">
                ${['Missy', 'A1', 'Unique'].map(char => `
                  <div class="character-card ${selectedChar === char ? 'selected' : ''}" data-char="${char}" style="background: ${selectedChar === char ? 'rgba(91, 163, 255, 0.2)' : 'rgba(0, 0, 0, 0.4)'}; border: 2px solid ${selectedChar === char ? 'rgba(91, 163, 255, 0.6)' : 'rgba(79, 195, 247, 0.4)'}; border-radius: 12px; padding: 20px; text-align: center; cursor: pointer; transition: all 0.3s ease;">
                    <div style="font-size: 64px; margin-bottom: 12px;">
                      ${char === 'A1' ? 'âš”ï¸' : char === 'Unique' ? 'ğŸ¥·' : 'ğŸ§™â€â™€ï¸'}
                    </div>
                    <h4 style="color: #4fc3f7; font-size: 16px; margin-bottom: 6px;">${char}</h4>
                    <div style="font-size: 11px; color: rgba(207, 227, 255, 0.7); margin-bottom: 12px;">
                      ${char === 'A1' ? 'The fearless warrior' : char === 'Unique' ? 'The stealthy rogue' : 'The powerful mage'}
                    </div>
                    <div style="font-size: 10px; color: #ffd77a;">
                      ${(skins[char] || []).length} skins available
                    </div>
                    ${selectedChar === char ? '<div style="margin-top: 10px; color: #4cd137; font-size: 11px; font-weight: 600;">âœ“ Selected</div>' : ''}
                  </div>
                `).join('')}
              </div>
            </div>
          `;
          
          // Attach character selection
          setTimeout(() => {
            container.querySelectorAll('.character-card').forEach(card => {
              card.addEventListener('click', () => {
                this.state.selectedCharacter = card.getAttribute('data-char');
                this.renderSkinsTab();
              });
            });
          }, 50);
        },
        
        renderSkinsSubtab(container) {
          const skins = window.gameState.skins || {};
          const selectedChar = this.state.selectedCharacter || 'Missy';
          const characterSkins = skins[selectedChar] || [];
          const equippedSkin = window.gameState.equippedSkins[selectedChar];
          
          const getRarityColor = (rarity) => {
            const colors = { common: '#95a5a6', rare: '#3498db', epic: '#9b59b6', legendary: '#f39c12' };
            return colors[rarity] || '#95a5a6';
          };
          
          container.innerHTML = `
            <div>
              <!-- Current Character Display -->
              <div style="background: rgba(0, 0, 0, 0.4); border: 2px solid rgba(79, 195, 247, 0.4); border-radius: 12px; padding: 16px; margin-bottom: 20px;">
                <div style="display: flex; align-items: center; gap: 16px;">
                  <div style="font-size: 64px;">
                    ${selectedChar === 'A1' ? 'âš”ï¸' : selectedChar === 'Unique' ? 'ğŸ¥·' : 'ğŸ§™â€â™€ï¸'}
                  </div>
                  <div>
                    <h3 style="color: #4fc3f7; font-size: 18px; margin-bottom: 4px;">${selectedChar}</h3>
                    <div style="font-size: 12px; color: rgba(207, 227, 255, 0.7);">
                      ${selectedChar === 'A1' ? 'The fearless warrior' : selectedChar === 'Unique' ? 'The stealthy rogue' : 'The powerful mage'}
                    </div>
                    <div style="font-size: 11px; color: #ffd77a; margin-top: 6px;">
                      Current Skin: <strong>${characterSkins.find(s => s.id === equippedSkin)?.name || 'Default'}</strong>
                    </div>
                  </div>
                </div>
              </div>

              <!-- Skins Grid -->
              <h3 style="color: #4fc3f7; margin-bottom: 12px;">Available Skins (${characterSkins.length})</h3>
            <div class="gear-items-grid">
              ${characterSkins.map(skin => {
            const isEquipped = equippedSkin === skin.id;
            const isLocked = !skin.unlocked;
            return `
                  <div class="gear-item-card skin-card ${isEquipped ? 'equipped-skin' : ''} ${isLocked ? 'locked-skin' : ''}" data-skin-id="${skin.id}" style="border-color: ${getRarityColor(skin.rarity)}; ${isLocked ? 'opacity: 0.6; cursor: not-allowed;' : ''}">
                    ${isEquipped ? '<div style="position: absolute; top: 8px; right: 8px; background: rgba(79, 195, 247, 0.9); color: #fff; padding: 4px 8px; border-radius: 6px; font-size: 10px; font-weight: 700;">EQUIPPED</div>' : ''}
                    ${isLocked ? '<div style="position: absolute; top: 8px; left: 8px; font-size: 24px;">ğŸ”’</div>' : ''}
                    <div class="gear-item-icon" style="font-size: 48px;">
                      ${selectedChar === 'A1' ? 'âš”ï¸' : selectedChar === 'Unique' ? 'ğŸ¥·' : 'ğŸ§™â€â™€ï¸'}
                    </div>
                    <div class="gear-item-name">${skin.name}</div>
                    <div style="font-size: 10px; padding: 3px 8px; background: ${getRarityColor(skin.rarity)}; border-radius: 6px; margin: 4px 0; text-transform: uppercase; color: #fff; font-weight: 700;">
                      ${skin.rarity}
                    </div>
                    <div style="font-size: 9px; color: rgba(207, 227, 255, 0.5); font-style: italic; margin: 8px 0; height: 32px; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;">
                      ${skin.description}
                    </div>
                    ${skin.unlock && isLocked ? `
                      <div style="font-size: 9px; color: rgba(255, 215, 122, 0.8); margin-top: 8px; padding: 6px; background: rgba(0, 0, 0, 0.3); border-radius: 6px;">
                        ğŸ”“ ${skin.unlock}
                      </div>
                    ` : ''}
                    <div class="skin-actions" style="display: flex; flex-direction: column; gap: 4px;">
                      <button class="skin-action-btn equip" data-action="equip" data-skin-id="${skin.id}" ${isEquipped || isLocked ? 'disabled' : ''}>
                        ${isLocked ? 'Locked' : isEquipped ? 'Equipped' : 'Equip'}
                      </button>
                      <button class="skin-action-btn preview" data-action="preview" data-skin-id="${skin.id}" data-char="${selectedChar}" style="font-size: 9px; padding: 4px 8px;">
                        Preview
                      </button>
                      ${isLocked ? `<button class="skin-action-btn unlock" data-action="unlock" data-skin-id="${skin.id}" style="font-size: 9px; padding: 4px 8px;">Unlock</button>` : ''}
                    </div>
                  </div>
                `;
          }).join('')}
            </div>
          `;
          
          // Attach skin action buttons
          setTimeout(() => {
            container.querySelectorAll('.skin-action-btn').forEach(btn => {
              btn.addEventListener('click', () => {
                const action = btn.dataset.action;
                const skinId = btn.dataset.skinId;
                const character = btn.dataset.char || this.state.selectedCharacter;
                const skins = window.gameState.skins || {};
                const characterSkins = skins[character] || [];
                const skin = characterSkins.find(s => s.id === skinId);

                if (action === 'equip' && skin && skin.unlocked) this.equipSkin(character, skinId);
                else if (action === 'preview' && skin) this.previewSkin(character, skinId);
                else if (action === 'unlock' && skin) this.unlockSkin(character, skinId);
              });
            });
          }, 50);
        },
        
        renderCosmeticsSubtab(container) {
          container.innerHTML = `
            <div>
              <h3 style="color: #a78bfa; margin-bottom: 16px;">âœ¨ Cosmetic Items</h3>
              
              <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 16px;">
                <!-- Wings -->
                <div style="background: rgba(0, 0, 0, 0.4); border: 2px solid rgba(167, 139, 250, 0.4); border-radius: 12px; padding: 16px;">
                  <div style="font-size: 48px; text-align: center; margin-bottom: 12px;">ğŸ‘¼</div>
                  <h4 style="color: #a78bfa; font-size: 14px; margin-bottom: 6px;">Angel Wings</h4>
                  <div style="font-size: 11px; color: rgba(207, 227, 255, 0.7); margin-bottom: 10px;">Majestic white wings</div>
                  <div style="font-size: 10px; color: #f39c12; margin-bottom: 10px;">legendary</div>
                  <button style="width: 100%; padding: 8px; background: rgba(76, 209, 55, 0.3); border: 2px solid rgba(76, 209, 55, 0.5); border-radius: 6px; color: #4cd137; font-size: 11px; font-weight: 600; cursor: pointer;">
                    âœ“ Equipped
                  </button>
                </div>
                
                <!-- Halo -->
                <div style="background: rgba(0, 0, 0, 0.4); border: 2px solid rgba(255, 215, 122, 0.4); border-radius: 12px; padding: 16px;">
                  <div style="font-size: 48px; text-align: center; margin-bottom: 12px;">ğŸ˜‡</div>
                  <h4 style="color: #ffd77a; font-size: 14px; margin-bottom: 6px;">Golden Halo</h4>
                  <div style="font-size: 11px; color: rgba(207, 227, 255, 0.7); margin-bottom: 10px;">Divine golden halo</div>
                  <div style="font-size: 10px; color: #f39c12; margin-bottom: 10px;">legendary</div>
                  <button style="width: 100%; padding: 8px; background: rgba(76, 209, 55, 0.3); border: 2px solid rgba(76, 209, 55, 0.5); border-radius: 6px; color: #4cd137; font-size: 11px; font-weight: 600; cursor: pointer;">
                    âœ“ Equipped
                  </button>
                </div>
                
                <!-- Trail Effect -->
                <div style="background: rgba(0, 0, 0, 0.4); border: 2px solid rgba(79, 195, 247, 0.4); border-radius: 12px; padding: 16px;">
                  <div style="font-size: 48px; text-align: center; margin-bottom: 12px;">âœ¨</div>
                  <h4 style="color: #4fc3f7; font-size: 14px; margin-bottom: 6px;">Star Trail</h4>
                  <div style="font-size: 11px; color: rgba(207, 227, 255, 0.7); margin-bottom: 10px;">Sparkle trail effect</div>
                  <div style="font-size: 10px; color: #9b59b6; margin-bottom: 10px;">epic</div>
                  <button style="width: 100%; padding: 8px; background: rgba(91, 163, 255, 0.3); border: 2px solid rgba(91, 163, 255, 0.5); border-radius: 6px; color: #5ba3ff; font-size: 11px; font-weight: 600; cursor: pointer;">
                    Equip
                  </button>
                </div>
                
                <!-- Aura -->
                <div style="background: rgba(0, 0, 0, 0.4); border: 2px solid rgba(255, 107, 107, 0.4); border-radius: 12px; padding: 16px;">
                  <div style="font-size: 48px; text-align: center; margin-bottom: 12px;">ğŸ”¥</div>
                  <h4 style="color: #ff6b6b; font-size: 14px; margin-bottom: 6px;">Flame Aura</h4>
                  <div style="font-size: 11px; color: rgba(207, 227, 255, 0.7); margin-bottom: 10px;">Fiery aura effect</div>
                  <div style="font-size: 10px; color: #9b59b6; margin-bottom: 10px;">epic</div>
                  <button style="width: 100%; padding: 8px; background: rgba(91, 163, 255, 0.3); border: 2px solid rgba(91, 163, 255, 0.5); border-radius: 6px; color: #5ba3ff; font-size: 11px; font-weight: 600; cursor: pointer;">
                    Equip
                  </button>
                </div>
              </div>
              
              <div style="margin-top: 20px; padding: 12px; background: rgba(167, 139, 250, 0.1); border: 1px solid rgba(167, 139, 250, 0.3); border-radius: 8px; font-size: 11px; color: rgba(207, 227, 255, 0.7);">
                ğŸ’¡ Cosmetic items don't affect stats - they're purely for customization!
              </div>
            </div>
          `;
        },
        
        renderCharacterSprites() {
          const contentDiv = document.getElementById('skin-subtab-content');
          if (!contentDiv) {
            debugWarn('skin-subtab-content not found');
            return;
          }

          const characters = [
            { id: 'A1', name: 'A1 (Warrior)', icon: 'âš”ï¸', description: 'The fearless dual-sword warrior' },
            { id: 'Missy', name: 'Missy (Cat Angel)', icon: 'ğŸ±', description: 'Angelic cat gunner with fortune powers' },
            { id: 'Unique', name: 'Unique (Cyborg)', icon: 'ğŸ¤–', description: 'High-tech cyborg rifle operative' }
          ];

          const styleOptions = [
            { value: 'type-1-hd-pixel-art', label: 'HD Pixel Art' },
            { value: 'type-11-retro-8bit', label: 'Retro 8-bit' },
            { value: 'type-7-chibi-kawaii', label: 'Chibi Kawaii' },
            { value: 'type-2-vector-cel-shaded', label: 'Vector Cel-Shaded' },
            { value: 'type-3-3d-prerendered', label: '3D Prerendered' },
            { value: 'type-5-hybrid-enhanced', label: 'Hybrid Enhanced' },
            { value: 'type-9-lowpoly-3d', label: 'Low-Poly 3D' },
            { value: 'type-13-stained-glass', label: 'Stained Glass' },
            { value: 'type-14-comic-halftone', label: 'Comic Halftone' }
          ];

          const animationOptions = ['idle', 'walk', 'run', 'attack', 'jump', 'die'];

          contentDiv.innerHTML = `
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px;">
              ${characters.map(char => {
            const spriteState = window.gameState.characterSprites[char.id] || {};
            const currentStyle = spriteState.style || 'type-1-hd-pixel-art';
            const currentAnim = spriteState.animation || 'idle';

            return `
                  <div class="sprite-viewer-card">
                    <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                      <div style="font-size: 48px;">${char.icon}</div>
                      <div>
                        <h3 style="color: #4fc3f7; font-size: 16px; margin-bottom: 4px;">${char.name}</h3>
                        <p style="font-size: 11px; color: rgba(207, 227, 255, 0.6);">${char.description}</p>
                      </div>
                    </div>

                    <div class="sprite-canvas-container">
                      <canvas id="sprite_${char.id}" width="128" height="128" style="image-rendering: pixelated; image-rendering: -webkit-optimize-contrast; width: 256px; height: 256px;"></canvas>
                    </div>

                    <div style="margin-bottom: 12px;">
                      <label style="display: block; font-size: 11px; color: rgba(207, 227, 255, 0.7); margin-bottom: 6px;">Art Style:</label>
                      <select class="sort-dropdown" data-char="${char.id}" data-control="style" style="width: 100%; padding: 8px; background: rgba(0, 0, 0, 0.5); border: 1px solid rgba(79, 195, 247, 0.3); border-radius: 6px; color: #cfe3ff; font-size: 12px;">
                        ${styleOptions.map(style => `
                          <option value="${style.value}" ${currentStyle === style.value ? 'selected' : ''}>${style.label}</option>
                        `).join('')}
                      </select>
                    </div>

                    <div style="margin-bottom: 12px;">
                      <label style="display: block; font-size: 11px; color: rgba(207, 227, 255, 0.7); margin-bottom: 6px;">Animation:</label>
                      <div style="display: flex; gap: 4px; flex-wrap: wrap;">
                        ${animationOptions.map(anim => `
                          <button class="filter-chip ${currentAnim === anim ? 'active' : ''}" data-char="${char.id}" data-anim="${anim}" style="font-size: 10px; padding: 6px 12px;">
                            ${anim.toUpperCase()}
                          </button>
                        `).join('')}
                      </div>
                    </div>

                    <div style="background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(79, 195, 247, 0.2); border-radius: 6px; padding: 10px; margin-top: 12px;">
                      <h4 style="color: #4fc3f7; font-size: 12px; margin-bottom: 8px;">ğŸ¨ Customization</h4>
                      
                      <div style="margin-bottom: 8px;">
                        <label style="display: block; font-size: 10px; color: rgba(207, 227, 255, 0.7); margin-bottom: 4px;">Animation Speed:</label>
                        <input type="range" min="0.5" max="2" step="0.1" value="${spriteState.animSpeed || 1}" 
                               data-char="${char.id}" data-control="speed" 
                               style="width: 100%; height: 6px; background: rgba(0, 0, 0, 0.5); border-radius: 3px; outline: none; cursor: pointer;"
                               oninput="var val = (this.value - 0.5) / 1.5 * 100; this.style.background = 'linear-gradient(to right, #4fc3f7 0%, #4fc3f7 ' + val + '%, rgba(0, 0, 0, 0.5) ' + val + '%, rgba(0, 0, 0, 0.5) 100%)'">
                        <div style="font-size: 9px; color: rgba(207, 227, 255, 0.5); text-align: center; margin-top: 2px;">
                          ${spriteState.animSpeed || 1}x
                        </div>
                      </div>
                      
                      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 10px;">
                        <button class="auto-btn" data-char="${char.id}" data-action="color-swap" style="padding: 6px 10px; font-size: 10px; transition: all 0.2s;">ğŸ¨ Colors</button>
                        <button class="auto-btn" data-char="${char.id}" data-action="equipment" style="padding: 6px 10px; font-size: 10px; transition: all 0.2s;">âš”ï¸ Equipment</button>
                        <button class="auto-btn" data-char="${char.id}" data-action="scale" style="padding: 6px 10px; font-size: 10px; transition: all 0.2s;">ğŸ“ Scale</button>
                        <button class="auto-btn" data-char="${char.id}" data-action="export" style="padding: 6px 10px; font-size: 10px; transition: all 0.2s;">ğŸ’¾ Export</button>
                      </div>
                    </div>
                    
                    <div style="margin-top: 8px; padding: 8px; background: rgba(0, 0, 0, 0.2); border-radius: 6px; font-size: 9px; color: rgba(207, 227, 255, 0.6);">
                      <div>ğŸ’¡ <strong>Tips:</strong></div>
                      <div style="margin-top: 4px;">â€¢ Change animation speed for slow-mo or fast-forward</div>
                      <div>â€¢ Try different animations to see particle effects</div>
                      <div>â€¢ Each character has unique visual effects!</div>
                    </div>
                  </div>
                `;
          }).join('')}
            </div>
          `;

          // Attach event listeners for style selectors
          contentDiv.querySelectorAll('select[data-control="style"]').forEach(select => {
            select.addEventListener('change', (e) => {
              const charId = e.target.dataset.char;
              if (!window.gameState.characterSprites[charId]) {
                window.gameState.characterSprites[charId] = {};
              }
              window.gameState.characterSprites[charId].style = e.target.value;
              this.renderCharacterSprites();
            });
          });

          // Attach event listeners for animation speed sliders
          contentDiv.querySelectorAll('input[data-control="speed"]').forEach(slider => {
            slider.addEventListener('input', (e) => {
              const charId = e.target.dataset.char;
              const speed = parseFloat(e.target.value);
              if (!window.gameState.characterSprites[charId]) {
                window.gameState.characterSprites[charId] = {};
              }
              window.gameState.characterSprites[charId].animSpeed = speed;
              // Update display
              const display = e.target.parentElement.querySelector('div');
              if (display) display.textContent = speed.toFixed(1) + 'x';
            });
          });

          // Attach event listeners for animation buttons
          contentDiv.querySelectorAll('button[data-anim]').forEach(btn => {
            btn.addEventListener('click', () => {
              const charId = btn.dataset.char;
              const anim = btn.dataset.anim;
              window.gameState.characterSprites[charId].animation = anim;
              this.renderCharacterSprites();
            });
          });

          // Attach event listeners for customization actions
          contentDiv.querySelectorAll('button[data-action]').forEach(btn => {
            btn.addEventListener('click', () => {
              const charId = btn.dataset.char;
              const action = btn.dataset.action;
              this.handleSpriteCustomization(charId, action);
            });
          });

          // Start animating the sprites
          this.animateCharacterSprites();
        },

        animateCharacterSprites() {
          let lastFrameTime = performance.now();
          let frameCount = 0;
          let fps = 60;

          const animate = (currentTime) => {
            // Calculate FPS
            const deltaTime = currentTime - lastFrameTime;
            frameCount++;
            if (deltaTime >= 1000) {
              fps = Math.round((frameCount * 1000) / deltaTime);
              frameCount = 0;
              lastFrameTime = currentTime;
            }

            // Only animate visible sprites (performance optimization)
            ['A1', 'Missy', 'Unique'].forEach(charId => {
              const canvas = document.getElementById(`sprite_${charId}`);
              if (canvas && canvas.offsetParent !== null) {
                this.drawCharacterSprite(charId);
              }
            });

            requestAnimationFrame(animate);
          };
          animate(performance.now());
        },

        drawCharacterSprite(charId) {
          const canvas = document.getElementById(`sprite_${charId}`);
          if (!canvas) return;

          const ctx = canvas.getContext('2d');
          ctx.imageSmoothingEnabled = false;

          const spriteState = window.gameState.characterSprites[charId] || {};
          const anim = spriteState.animation || 'idle';
          const time = Date.now() * 0.001;

          // Clear canvas
          ctx.clearRect(0, 0, canvas.width, canvas.height);

          // Draw based on character type
          if (charId === 'A1') {
            this.drawWarriorSprite(ctx, anim, time);
          } else if (charId === 'Missy') {
            this.drawCatAngelSprite(ctx, anim, time);
          } else if (charId === 'Unique') {
            this.drawCyborgSprite(ctx, anim, time);
          }
        },

        drawWarriorSprite(ctx, anim, time) {
          const cx = 64, cy = 64;
          const bob = Math.sin(time * 3) * 2;
          const spriteState = window.gameState.characterSprites['A1'] || {};
          const animSpeed = spriteState.animSpeed || 1;
          const speedTime = time * animSpeed;

          const shadowSize = anim === 'run' ? 22 : anim === 'jump' ? 15 : 20;
          ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
          ctx.beginPath();
          ctx.ellipse(cx, cy + 50, shadowSize, 6, 0, 0, Math.PI * 2);
          ctx.fill();

          const bodyOffset = anim === 'walk' ? Math.sin(speedTime * 4) * 2 : 0;
          const bodyY = cy - 10 + bob + bodyOffset;

          const legSpeed = anim === 'run' ? speedTime * 6 : speedTime * 4;
          const leftLegSwing = Math.sin(legSpeed) * (anim === 'run' ? 15 : 10);
          const rightLegSwing = Math.sin(legSpeed + Math.PI) * (anim === 'run' ? 15 : 10);
          
          ctx.fillStyle = '#0a0a0a';
          ctx.strokeStyle = '#1a1a1a';
          ctx.lineWidth = 6;
          
          ctx.beginPath();
          ctx.moveTo(cx - 6, bodyY + 35);
          ctx.lineTo(cx - 6 + leftLegSwing, bodyY + 50);
          ctx.stroke();
          ctx.fillStyle = '#1a1a1a';
          ctx.fillRect(cx - 9 + leftLegSwing, bodyY + 48, 8, 4);
          
          ctx.strokeStyle = '#0a0a0a';
          ctx.beginPath();
          ctx.moveTo(cx + 6, bodyY + 35);
          ctx.lineTo(cx + 6 + rightLegSwing, bodyY + 50);
          ctx.stroke();
          ctx.fillStyle = '#1a1a1a';
          ctx.fillRect(cx + 3 + rightLegSwing, bodyY + 48, 8, 4);

          const bodyGrad = ctx.createLinearGradient(cx - 12, bodyY, cx + 12, bodyY + 40);
          bodyGrad.addColorStop(0, '#1a1a1a');
          bodyGrad.addColorStop(0.5, '#2a2a2a');
          bodyGrad.addColorStop(1, '#1a1a1a');
          ctx.fillStyle = bodyGrad;
          ctx.fillRect(cx - 12, bodyY, 24, 40);

          ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(cx - 12, bodyY + 15);
          ctx.lineTo(cx + 12, bodyY + 15);
          ctx.stroke();

          const armSwing = anim === 'walk' || anim === 'run' ? Math.sin(speedTime * 4) * 8 : 0;
          const leftArmX = cx - 18 + (anim === 'attack' ? -5 : armSwing);
          const rightArmX = cx + 18 - (anim === 'attack' ? -5 : armSwing);
          const armY = bodyY + 10;
          
          ctx.lineWidth = 5;
          ctx.strokeStyle = '#1a1a1a';
          ctx.beginPath();
          ctx.moveTo(cx - 12, bodyY + 8);
          ctx.lineTo(leftArmX, armY + (anim === 'attack' ? 5 : 0));
          ctx.stroke();
          ctx.fillStyle = '#4a3428';
          ctx.beginPath();
          ctx.arc(leftArmX, armY + (anim === 'attack' ? 5 : 0), 3, 0, Math.PI * 2);
          ctx.fill();
          
          ctx.strokeStyle = '#1a1a1a';
          ctx.beginPath();
          ctx.moveTo(cx + 12, bodyY + 8);
          ctx.lineTo(rightArmX, armY + (anim === 'attack' ? 5 : 0));
          ctx.stroke();
          ctx.fillStyle = '#4a3428';
          ctx.beginPath();
          ctx.arc(rightArmX, armY + (anim === 'attack' ? 5 : 0), 3, 0, Math.PI * 2);
          ctx.fill();

          const headY = cy - 28 + bob;
          const headGrad = ctx.createRadialGradient(cx, headY - 5, 0, cx, headY, 12);
          headGrad.addColorStop(0, '#5c4033');
          headGrad.addColorStop(1, '#4a3428');
          ctx.fillStyle = headGrad;
          ctx.beginPath();
          ctx.arc(cx, headY, 12, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = '#000';
          ctx.beginPath();
          ctx.arc(cx, headY - 4, 12, Math.PI, Math.PI * 2);
          ctx.fill();
          ctx.fillRect(cx - 8, headY - 7, 16, 10);

          ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
          ctx.beginPath();
          ctx.arc(cx - 3, headY - 8, 3, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = '#1a1a2a';
          ctx.fillRect(cx - 10, headY - 2, 20, 4);
          ctx.fillRect(cx - 8, headY + 2, 16, 3);

          const eyeGlow = 0.5 + Math.sin(time * 4) * 0.5;
          ctx.fillStyle = `rgba(255, 0, 0, ${0.7 + eyeGlow * 0.3})`;
          ctx.shadowColor = '#ff0000';
          ctx.shadowBlur = 8 * eyeGlow;
          ctx.fillRect(cx - 6, headY - 1, 4, 3);
          ctx.fillRect(cx + 2, headY - 1, 4, 3);
          ctx.shadowBlur = 0;

          const swordGlow = 0.7 + Math.sin(time * 6) * 0.3;
          ctx.strokeStyle = `rgba(255, ${Math.floor(100 * swordGlow)}, ${Math.floor(100 * swordGlow)}, 1)`;
          ctx.lineWidth = 3;
          ctx.shadowColor = '#ff0000';
          ctx.shadowBlur = 12 * swordGlow;

          const swordAngle = anim === 'attack' ? Math.sin(time * 15) * 0.3 : 0;

          ctx.save();
          ctx.translate(leftArmX, cy + 10 + bob);
          ctx.rotate(swordAngle);
          ctx.beginPath();
          ctx.moveTo(0, -30);
          ctx.lineTo(0, 30);
          ctx.stroke();
          ctx.fillStyle = '#333';
          ctx.fillRect(-2, 25, 4, 8);
          ctx.restore();

          ctx.save();
          ctx.translate(rightArmX, cy + 10 + bob);
          ctx.rotate(-swordAngle);
          ctx.beginPath();
          ctx.moveTo(0, -30);
          ctx.lineTo(0, 30);
          ctx.stroke();
          ctx.fillStyle = '#333';
          ctx.fillRect(-2, 25, 4, 8);
          ctx.restore();

          ctx.shadowBlur = 0;

          if (anim === 'attack') {
            for (let i = 0; i < 8; i++) {
              const angle = (time * 10 + i * Math.PI / 4) % (Math.PI * 2);
              const dist = 35 + Math.sin(time * 15) * 8;
              const px = cx + Math.cos(angle) * dist;
              const py = cy + Math.sin(angle) * dist;
              ctx.fillStyle = `rgba(255, ${100 + i * 20}, 0, 0.8)`;
              ctx.beginPath();
              ctx.arc(px, py, 2, 0, Math.PI * 2);
              ctx.fill();
            }

            const slashAngle = time * 15;
            ctx.strokeStyle = 'rgba(255, 100, 0, 0.6)';
            ctx.lineWidth = 3;
            ctx.shadowColor = '#ff6600';
            ctx.shadowBlur = 15;
            ctx.beginPath();
            ctx.arc(cx, cy, 30 + Math.sin(time * 15) * 5, slashAngle - 0.5, slashAngle + 0.5);
            ctx.stroke();
            ctx.shadowBlur = 0;
          }
        },

        drawCatAngelSprite(ctx, anim, time) {
          const cx = 64, cy = 64;
          const bob = Math.sin(time * 3) * 2;
          const spriteState = window.gameState.characterSprites['Missy'] || {};
          const animSpeed = spriteState.animSpeed || 1;
          const speedTime = time * animSpeed;

          const shadowSize = anim === 'run' ? 20 : anim === 'jump' ? 12 : 18;
          ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
          ctx.beginPath();
          ctx.ellipse(cx, cy + 50, shadowSize, 5, 0, 0, Math.PI * 2);
          ctx.fill();

          const wingFlap = anim === 'run' || anim === 'attack' ? Math.sin(time * 8) * 0.2 : 0;
          const wingAngleL = -0.5 + wingFlap;
          const wingAngleR = 0.5 - wingFlap;
          const wingY = cy - 10 + bob;

          const wingGradL = ctx.createRadialGradient(cx - 18, wingY, 0, cx - 18, wingY, 18);
          wingGradL.addColorStop(0, '#ffe0f0');
          wingGradL.addColorStop(1, '#ffb6d9');
          ctx.fillStyle = wingGradL;
          ctx.globalAlpha = 0.85;
          ctx.save();
          ctx.translate(cx - 18, wingY);
          ctx.rotate(wingAngleL);
          ctx.beginPath();
          ctx.ellipse(0, 0, 15, 22, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();

          const wingGradR = ctx.createRadialGradient(cx + 18, wingY, 0, cx + 18, wingY, 18);
          wingGradR.addColorStop(0, '#ffe0f0');
          wingGradR.addColorStop(1, '#ffb6d9');
          ctx.fillStyle = wingGradR;
          ctx.save();
          ctx.translate(cx + 18, wingY);
          ctx.rotate(wingAngleR);
          ctx.beginPath();
          ctx.ellipse(0, 0, 15, 22, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
          ctx.globalAlpha = 1;

          ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
          ctx.lineWidth = 1;
          for (let i = 0; i < 3; i++) {
            ctx.beginPath();
            ctx.moveTo(cx - 18 - 10, wingY + i * 5 - 10);
            ctx.quadraticCurveTo(cx - 18, wingY + i * 5 - 5, cx - 18 + 10, wingY + i * 5);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(cx + 18 - 10, wingY + i * 5 - 10);
            ctx.quadraticCurveTo(cx + 18, wingY + i * 5 - 5, cx + 18 + 10, wingY + i * 5);
            ctx.stroke();
          }

          const bodyOffset = anim === 'walk' ? Math.sin(speedTime * 4) * 1.5 : 0;
          const bodyY = cy - 8 + bob + bodyOffset;

          const missyLegSpeed = anim === 'run' ? speedTime * 6 : speedTime * 4;
          const missyLeftLegSwing = anim === 'walk' || anim === 'run' ? Math.sin(missyLegSpeed) * (anim === 'run' ? 12 : 8) : 0;
          const missyRightLegSwing = anim === 'walk' || anim === 'run' ? Math.sin(missyLegSpeed + Math.PI) * (anim === 'run' ? 12 : 8) : 0;
          
          ctx.lineWidth = 5;
          ctx.strokeStyle = '#0a0a0a';
          ctx.beginPath();
          ctx.moveTo(cx - 5, bodyY + 30);
          ctx.lineTo(cx - 5 + missyLeftLegSwing, bodyY + 45);
          ctx.stroke();
          ctx.fillStyle = '#1a1a1a';
          ctx.fillRect(cx - 8 + missyLeftLegSwing, bodyY + 43, 7, 3);
          
          ctx.strokeStyle = '#0a0a0a';
          ctx.beginPath();
          ctx.moveTo(cx + 5, bodyY + 30);
          ctx.lineTo(cx + 5 + missyRightLegSwing, bodyY + 45);
          ctx.stroke();
          ctx.fillStyle = '#1a1a1a';
          ctx.fillRect(cx + 2 + missyRightLegSwing, bodyY + 43, 7, 3);

          const bodyGrad = ctx.createLinearGradient(cx - 10, bodyY, cx + 10, bodyY + 35);
          bodyGrad.addColorStop(0, '#0a0a0a');
          bodyGrad.addColorStop(0.5, '#1a1a1a');
          bodyGrad.addColorStop(1, '#0a0a0a');
          ctx.fillStyle = bodyGrad;
          ctx.fillRect(cx - 10, bodyY, 20, 35);

          ctx.fillStyle = '#ff6b35';
          ctx.fillRect(cx - 3, bodyY + 10, 6, 4);

          const headY = cy - 25 + bob;
          ctx.fillStyle = '#000';
          ctx.beginPath();
          ctx.arc(cx, headY, 14, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = 'rgba(50, 50, 50, 0.6)';
          ctx.beginPath();
          ctx.arc(cx - 4, headY - 2, 5, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = '#000';
          ctx.beginPath();
          ctx.moveTo(cx - 10, headY - 7);
          ctx.lineTo(cx - 6, headY - 15);
          ctx.lineTo(cx - 2, headY - 7);
          ctx.fill();
          ctx.fillStyle = '#ff6b35';
          ctx.beginPath();
          ctx.moveTo(cx - 8, headY - 9);
          ctx.lineTo(cx - 6, headY - 13);
          ctx.lineTo(cx - 4, headY - 9);
          ctx.fill();
          ctx.fillStyle = '#000';
          ctx.beginPath();
          ctx.moveTo(cx + 2, headY - 7);
          ctx.lineTo(cx + 6, headY - 15);
          ctx.lineTo(cx + 10, headY - 7);
          ctx.fill();
          ctx.fillStyle = '#ff6b35';
          ctx.beginPath();
          ctx.moveTo(cx + 4, headY - 9);
          ctx.lineTo(cx + 6, headY - 13);
          ctx.lineTo(cx + 8, headY - 9);
          ctx.fill();

          const eyeGlow = 0.6 + Math.sin(time * 5) * 0.4;
          ctx.fillStyle = `rgba(0, ${Math.floor(200 + eyeGlow * 55)}, 0, 1)`;
          ctx.shadowColor = '#00ff00';
          ctx.shadowBlur = 6 * eyeGlow;
          ctx.fillRect(cx - 8, headY - 1, 5, 4);
          ctx.fillRect(cx + 3, headY - 1, 5, 4);
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(cx - 6, headY - 0.5, 2, 1.5);
          ctx.fillRect(cx + 4, headY - 0.5, 2, 1.5);
          ctx.shadowBlur = 0;

          const haloGlow = 0.7 + Math.sin(time * 3) * 0.3;
          ctx.strokeStyle = `rgba(255, ${Math.floor(200 + haloGlow * 55)}, 0, 1)`;
          ctx.lineWidth = 2;
          ctx.shadowColor = '#ffd700';
          ctx.shadowBlur = 12 * haloGlow;
          ctx.beginPath();
          ctx.arc(cx, headY - 20, 8, 0, Math.PI * 2);
          ctx.stroke();
          ctx.strokeStyle = `rgba(255, 215, 0, ${0.3 * haloGlow})`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(cx, headY - 20, 10, 0, Math.PI * 2);
          ctx.stroke();
          ctx.shadowBlur = 0;

          const gunX = cx + 12 + (anim === 'attack' ? Math.sin(time * 10) * 3 : 0);
          const gunY = cy + 5 + bob;

          const gunGrad = ctx.createLinearGradient(gunX, gunY, gunX + 15, gunY);
          gunGrad.addColorStop(0, '#333');
          gunGrad.addColorStop(0.5, '#555');
          gunGrad.addColorStop(1, '#333');
          ctx.fillStyle = gunGrad;
          ctx.fillRect(gunX, gunY, 12, 4);

          ctx.fillStyle = '#222';
          ctx.fillRect(gunX + 12, gunY, 3, 4);

          if (anim === 'attack') {
            const flashPhase = Math.floor(time * 10) % 2;
            if (flashPhase === 0) {
              ctx.fillStyle = 'rgba(255, 200, 0, 0.8)';
              ctx.fillRect(gunX + 15, gunY - 1, 4, 6);
              for (let i = 0; i < 5; i++) {
                const angle = (time * 20 + i * 0.5) % (Math.PI * 2);
                const dist = 8 + i * 2;
                ctx.fillStyle = `rgba(255, ${150 + i * 20}, 0, 0.6)`;
                ctx.beginPath();
                ctx.arc(gunX + 17 + Math.cos(angle) * dist, gunY + 2 + Math.sin(angle) * dist, 1.5, 0, Math.PI * 2);
                ctx.fill();
              }
            }
          }

          const tailSway = Math.sin(time * 2) * 3;
          ctx.strokeStyle = '#000';
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(cx - 8, cy + 25 + bob);
          ctx.quadraticCurveTo(cx - 12 + tailSway, cy + 30 + bob, cx - 10 + tailSway, cy + 35 + bob);
          ctx.stroke();

          if (anim === 'attack' || anim === 'idle') {
            for (let i = 0; i < 3; i++) {
              const coinAngle = time * 2 + i * Math.PI * 2 / 3;
              const coinDist = 25 + Math.sin(time * 3 + i) * 5;
              const coinX = cx + Math.cos(coinAngle) * coinDist;
              const coinY = cy + Math.sin(coinAngle) * coinDist;
              ctx.fillStyle = '#ffd700';
              ctx.beginPath();
              ctx.arc(coinX, coinY, 2, 0, Math.PI * 2);
              ctx.fill();
              ctx.strokeStyle = '#ffaa00';
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.arc(coinX, coinY, 2, 0, Math.PI * 2);
              ctx.stroke();
            }
          }
        },

        drawCyborgSprite(ctx, anim, time) {
          const cx = 64, cy = 64;
          const bob = Math.sin(time * 3) * 2;
          const spriteState = window.gameState.characterSprites['Unique'] || {};
          const animSpeed = spriteState.animSpeed || 1;
          const speedTime = time * animSpeed;

          const shadowSize = anim === 'run' ? 22 : anim === 'jump' ? 15 : 20;
          ctx.fillStyle = 'rgba(0, 0, 0, 0.35)';
          ctx.beginPath();
          ctx.ellipse(cx, cy + 50, shadowSize, 6, 0, 0, Math.PI * 2);
          ctx.fill();

          const bodyY = cy - 12 + bob;
          
          const cyborgLegSpeed = anim === 'run' ? speedTime * 6 : speedTime * 4;
          const cyborgLeftLegSwing = anim === 'walk' || anim === 'run' ? Math.sin(cyborgLegSpeed) * (anim === 'run' ? 14 : 10) : 0;
          const cyborgRightLegSwing = anim === 'walk' || anim === 'run' ? Math.sin(cyborgLegSpeed + Math.PI) * (anim === 'run' ? 14 : 10) : 0;
          
          ctx.lineWidth = 6;
          ctx.strokeStyle = '#3a2a5a';
          ctx.beginPath();
          ctx.moveTo(cx - 6, bodyY + 38);
          ctx.lineTo(cx - 6 + cyborgLeftLegSwing, bodyY + 52);
          ctx.stroke();
          ctx.strokeStyle = '#00ffff';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(cx - 6, bodyY + 42);
          ctx.lineTo(cx - 6 + cyborgLeftLegSwing, bodyY + 48);
          ctx.stroke();
          ctx.fillStyle = '#2a1a4a';
          ctx.fillRect(cx - 9 + cyborgLeftLegSwing, bodyY + 50, 8, 4);
          ctx.fillStyle = '#00ccff';
          ctx.fillRect(cx - 8 + cyborgLeftLegSwing, bodyY + 51, 6, 1);
          
          ctx.strokeStyle = '#3a2a5a';
          ctx.lineWidth = 6;
          ctx.beginPath();
          ctx.moveTo(cx + 6, bodyY + 38);
          ctx.lineTo(cx + 6 + cyborgRightLegSwing, bodyY + 52);
          ctx.stroke();
          ctx.strokeStyle = '#00ffff';
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(cx + 6, bodyY + 42);
          ctx.lineTo(cx + 6 + cyborgRightLegSwing, bodyY + 48);
          ctx.stroke();
          ctx.fillStyle = '#2a1a4a';
          ctx.fillRect(cx + 2 + cyborgRightLegSwing, bodyY + 50, 8, 4);
          ctx.fillStyle = '#00ccff';
          ctx.fillRect(cx + 3 + cyborgRightLegSwing, bodyY + 51, 6, 1);

          const bodyGrad = ctx.createLinearGradient(cx, bodyY - 18, cx, bodyY + 30);
          bodyGrad.addColorStop(0, '#5a4a7a');
          bodyGrad.addColorStop(0.3, '#4a3a6a');
          bodyGrad.addColorStop(0.7, '#3a2a5a');
          bodyGrad.addColorStop(1, '#2a1a4a');
          ctx.fillStyle = bodyGrad;
          ctx.fillRect(cx - 14, bodyY, 28, 42);

          const plateGlow = 0.6 + Math.sin(time * 4) * 0.4;
          ctx.fillStyle = `rgba(0, ${Math.floor(200 + plateGlow * 55)}, ${Math.floor(200 + plateGlow * 55)}, 1)`;
          ctx.shadowColor = '#00ffff';
          ctx.shadowBlur = 8 * plateGlow;
          ctx.fillRect(cx - 14, bodyY + 7, 28, 3);
          ctx.fillRect(cx - 10, bodyY + 12, 20, 2);
          ctx.fillRect(cx - 16, bodyY - 5, 6, 8);
          ctx.fillRect(cx + 10, bodyY - 5, 6, 8);
          ctx.shadowBlur = 0;

          const headY = cy - 28 + bob;
          const headGrad = ctx.createRadialGradient(cx, headY - 3, 0, cx, headY, 14);
          headGrad.addColorStop(0, '#4a3a6a');
          headGrad.addColorStop(1, '#3a2a4a');
          ctx.fillStyle = headGrad;
          ctx.beginPath();
          ctx.arc(cx, headY, 14, 0, Math.PI * 2);
          ctx.fill();

          const visorGlow = 0.7 + Math.sin(time * 5) * 0.3;
          const visorGrad = ctx.createLinearGradient(cx - 8, headY - 6, cx + 8, headY);
          visorGrad.addColorStop(0, `rgba(255, ${Math.floor(80 + visorGlow * 40)}, ${Math.floor(40 + visorGlow * 20)}, 1)`);
          visorGrad.addColorStop(1, `rgba(255, ${Math.floor(100 + visorGlow * 50)}, ${Math.floor(50 + visorGlow * 25)}, 1)`);
          ctx.fillStyle = visorGrad;
          ctx.fillRect(cx - 8, headY - 6, 16, 6);

          const scanY = headY - 6 + (Math.sin(time * 8) * 0.5 + 0.5) * 6;
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(cx - 8, scanY);
          ctx.lineTo(cx + 8, scanY);
          ctx.stroke();

          const eyePulse = 0.5 + Math.sin(time * 6) * 0.5;
          ctx.fillStyle = `rgba(255, 0, 0, ${0.8 + eyePulse * 0.2})`;
          ctx.shadowColor = '#ff0000';
          ctx.shadowBlur = 6 * eyePulse;
          ctx.fillRect(cx - 6, headY - 2, 4, 2);
          ctx.fillRect(cx + 2, headY - 2, 4, 2);
          ctx.shadowBlur = 0;

          const rifleX = cx + 18;
          const rifleY = cy + bob;
          const rifleGlow = anim === 'attack' ? 1.0 : 0.6 + Math.sin(time * 3) * 0.4;

          const rifleGrad = ctx.createLinearGradient(rifleX, rifleY, rifleX + 20, rifleY);
          rifleGrad.addColorStop(0, '#00aaff');
          rifleGrad.addColorStop(0.5, `rgba(0, ${Math.floor(200 + rifleGlow * 55)}, 255, 1)`);
          rifleGrad.addColorStop(1, '#0088ff');
          ctx.strokeStyle = rifleGrad;
          ctx.lineWidth = 3;
          ctx.shadowColor = '#00ffff';
          ctx.shadowBlur = 12 * rifleGlow;
          ctx.beginPath();
          ctx.moveTo(rifleX, rifleY);
          ctx.lineTo(rifleX + 20, rifleY);
          ctx.stroke();

          ctx.fillStyle = '#0088aa';
          ctx.fillRect(rifleX + 20, rifleY - 1, 4, 3);
          ctx.fillStyle = `rgba(0, ${Math.floor(255 * rifleGlow)}, 255, ${rifleGlow})`;
          ctx.beginPath();
          ctx.arc(rifleX + 8, rifleY, 2, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = '#ff6633';
          ctx.fillRect(rifleX + 24, rifleY - 2, 4, 4);

          if (anim === 'attack') {
            for (let i = 0; i < 6; i++) {
              const angle = (time * 15 + i * Math.PI / 3) % (Math.PI * 2);
              const dist = 30 + Math.sin(time * 20 + i) * 5;
              ctx.fillStyle = `rgba(0, ${Math.floor(150 + i * 20)}, 255, 0.7)`;
              ctx.beginPath();
              ctx.arc(rifleX + 12 + Math.cos(angle) * dist * 0.3, rifleY + Math.sin(angle) * dist * 0.3, 1.5, 0, Math.PI * 2);
              ctx.fill();
            }
          }

          ctx.shadowBlur = 0;
        },

        handleSpriteCustomization(charId, action) {
          if (action === 'export') {
            const canvas = document.getElementById(`sprite_${charId}`);
            if (canvas) {
              canvas.toBlob((blob) => {
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = `${charId}_sprite_${Date.now()}.png`;
                link.href = url;
                link.click();
                URL.revokeObjectURL(url);
                this.showToast(`ğŸ’¾ ${charId} sprite exported!`);
              }, 'image/png');
            }
          } else if (action === 'scale') {
            const canvas = document.getElementById(`sprite_${charId}`);
            if (canvas) {
              const currentScale = window.gameState.characterSprites[charId].scale || 2;
              const newScale = currentScale === 2 ? 3 : currentScale === 3 ? 4 : 2;
              if (!window.gameState.characterSprites[charId]) {
                window.gameState.characterSprites[charId] = {};
              }
              window.gameState.characterSprites[charId].scale = newScale;
              canvas.style.width = `${128 * newScale}px`;
              canvas.style.height = `${128 * newScale}px`;
              this.showToast(`ğŸ“ ${charId} scale set to ${newScale}x`);
            }
          } else {
            const messages = {
              'color-swap': `ğŸ¨ Color customization for ${charId} coming soon!`,
              'equipment': `âš”ï¸ Equipment overlay for ${charId} coming soon!`
            };
            this.showToast(messages[action] || 'Feature coming soon!');
          }
        },

        renderTalentsTab() {
          const pane = document.getElementById('bagContentPane');
          const talents = window.gameState.inventory.talents || {};

          const laneNames = {
            atk: 'âš”ï¸ Attack Lane',
            def: 'ğŸ›¡ï¸ Defense Lane',
            recovery: 'ğŸ’š Recovery Lane',
            cooldown: 'â±ï¸ Cooldown Lane',
            luck: 'ğŸ€ Luck Lane',
            shadow: 'ğŸŒ‘ Shadow Lane',
            spirit: 'ğŸ‘» Spirit Lane',
            lightning: 'âš¡ Lightning Lane',
            void: 'ğŸ•³ï¸ Void Lane',
            phoenix: 'ğŸ”¥ Phoenix Lane',
            monarch: 'ğŸ‘‘ Monarch Lane',
            supernatural: 'âœ¨ Supernatural Lane',
            ultimates: 'ğŸ† Ultimate Powers'
          };

          pane.innerHTML = `
            <div style="margin-bottom: 20px;">
              <h2 style="font-size: 22px; color: #ffd77a; margin-bottom: 10px;">ğŸŒŸ Talent Tree System</h2>
              <p style="color: rgba(207, 227, 255, 0.7); font-size: 13px; margin-bottom: 20px;">
                Unlock powerful talents to enhance your character! Each lane offers unique progression paths.
              </p>
            </div>

            ${Object.keys(talents).map(laneKey => {
            const lane = talents[laneKey];
            const laneName = laneNames[laneKey] || laneKey.toUpperCase();
            const isSuper = laneKey === 'supernatural';
            const isCross = laneKey === 'ultimates';

            const isElemental = ['shadow', 'spirit', 'lightning', 'void', 'phoenix', 'monarch'].includes(laneKey);
            
            return `
                <div class="talent-lane-container" style="background: rgba(0, 0, 0, 0.3); border: 2px solid ${isSuper ? 'rgba(167, 139, 250, 0.4)' : isCross ? 'rgba(255, 215, 122, 0.4)' : isElemental ? 'rgba(255, 107, 53, 0.4)' : 'rgba(79, 195, 247, 0.3)'}; border-radius: 12px; padding: 16px; margin-bottom: 16px;">
                  <h3 style="color: ${isSuper ? '#a78bfa' : isCross ? '#ffd77a' : isElemental ? '#ff6b35' : '#4fc3f7'}; font-size: 16px; margin-bottom: 12px; display: flex; align-items: center; gap: 8px;">
                    ${laneName}
                    ${isSuper ? '<span style="font-size: 10px; background: rgba(167, 139, 250, 0.3); padding: 3px 8px; border-radius: 6px;">S-RANK</span>' : ''}
                    ${isCross ? '<span style="font-size: 10px; background: rgba(255, 215, 122, 0.3); padding: 3px 8px; border-radius: 6px;">CROSS-SYSTEM</span>' : ''}
                    ${isElemental ? '<span style="font-size: 10px; background: rgba(255, 107, 53, 0.3); padding: 3px 8px; border-radius: 6px;">ELEMENTAL</span>' : ''}
                  </h3>
                  <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    ${lane.map(talent => {
              const isUltimate = talent.ultimate;
              return `
                        <div class="talent-node ${isUltimate ? 'ultimate-node' : ''}" style="
                          background: ${isUltimate ? 'radial-gradient(ellipse at 30% 20%, rgba(255, 215, 122, 0.2), rgba(255, 107, 53, 0.1))' : 'rgba(0, 0, 0, 0.4)'};
                          border: 2px solid ${isUltimate ? 'rgba(255, 215, 122, 0.6)' : 'rgba(79, 195, 247, 0.3)'};
                          border-radius: 10px;
                          padding: 12px;
                          min-width: 160px;
                          cursor: pointer;
                          transition: all 0.2s ease;
                        ">
                          <div style="font-weight: 700; font-size: 12px; color: ${isUltimate ? '#ffd77a' : '#cfe3ff'}; margin-bottom: 4px;">
                            ${talent.name}
                          </div>
                          <div style="font-size: 10px; color: rgba(255, 215, 122, 0.8); margin-bottom: 8px;">
                            ğŸ’ Cost: ${talent.cost} AP
                          </div>
                          <div style="font-size: 9px; color: rgba(207, 227, 255, 0.6); line-height: 1.4;">
                            ${talent.description}
                          </div>
                          ${talent.tier ? `<div style="font-size: 9px; color: rgba(79, 195, 247, 0.5); margin-top: 6px;">Tier ${talent.tier}</div>` : ''}
                        </div>
                      `;
            }).join('')}
                  </div>
                </div>
              `;
          }).join('')}

            <div style="background: rgba(0, 0, 0, 0.4); border: 2px solid rgba(79, 195, 247, 0.3); border-radius: 12px; padding: 16px; margin-top: 20px;">
              <h3 style="color: #4fc3f7; margin-bottom: 10px;">ğŸ“Š Talent Statistics</h3>
              <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 12px; font-size: 12px; color: rgba(207, 227, 255, 0.8);">
                <div>Total Talents: <strong style="color: #ffd77a;">68</strong></div>
                <div>Total Lanes: <strong style="color: #ffd77a;">13</strong></div>
                <div>Elemental Lanes: <strong style="color: #ff6b35;">6</strong></div>
                <div>Ultimate Talents: <strong style="color: #ffd77a;">17</strong></div>
                <div>Cross-System Talents: <strong style="color: #ffd77a;">4</strong></div>
                <div>S-Rank Lane: <strong style="color: #a78bfa;">Supernatural</strong></div>
                <div>Equippable Skills: <strong style="color: #38ef7d;">7</strong></div>
                <div>Max AP Required: <strong style="color: #ff6b35;">900+</strong></div>
              </div>
            </div>
          `;
        },

        renderVehiclesTab() {
          const pane = document.getElementById('bagContentPane');
          const equippedVehicle = window.gameState.equipped.vehicle;
          let vehicles = window.gameState.inventory.vehicles || [];

          const engine = this.ensureEngine();
          const companionManager = engine?.systems?.companion;
          const activeVehicleUid = equippedVehicle ? this.computeCompanionUid('vehicle', equippedVehicle) : null;
          const isVehicleSummoned = activeVehicleUid && companionManager?.isSpawned
            ? !!companionManager.isSpawned(activeVehicleUid)
            : false;
          const vehicleStatusBadge = isVehicleSummoned
            ? '<span style="display:inline-flex;align-items:center;padding:4px 10px;border-radius:999px;background:rgba(0,229,255,0.18);color:#00e5ff;border:1px solid rgba(0,229,255,0.55);font-size:11px;text-transform:uppercase;letter-spacing:0.6px;font-weight:700;">Called</span>'
            : '<span style="display:inline-flex;align-items:center;padding:4px 10px;border-radius:999px;background:rgba(129,199,255,0.12);color:#81c7ff;border:1px solid rgba(129,199,255,0.4);font-size:11px;text-transform:uppercase;letter-spacing:0.6px;font-weight:700;">Ready</span>';
          const self = this;

          // Apply filter
          if (this.state.vehicleFilter !== 'all') {
            vehicles = vehicles.filter(v => v.category === this.state.vehicleFilter);
          }

          // Apply sort
          if (this.state.vehicleSort === 'speed') {
            vehicles.sort((a, b) => b.speed - a.speed);
          } else if (this.state.vehicleSort === 'cost') {
            vehicles.sort((a, b) => a.cost - b.cost);
          } else if (this.state.vehicleSort === 'name') {
            vehicles.sort((a, b) => a.name.localeCompare(b.name));
          }

          const formatStatChip = (emoji, label, value) => {
            if (value == null) return '';
            const display = typeof value === 'number' ? (Math.abs(value) >= 100 ? Math.round(value) : value.toFixed(1)) : value;
            return `<span style="display:inline-flex;align-items:center;gap:4px;padding:4px 10px;border-radius:999px;background:rgba(0,229,255,0.18);color:#00e5ff;font-size:10px;font-weight:700;">${emoji} ${label} ${display}</span>`;
          };

          const getCategoryLabel = (vehicle) => vehicle.category ? vehicle.category.toUpperCase() : 'UNSPECIFIED';

          const renderEquippedCard = () => {
            if (!equippedVehicle) {
              return `
                <div style="background: linear-gradient(145deg, rgba(132, 218, 255, 0.25), rgba(144, 255, 222, 0.25));
                            border: 2px dashed rgba(132, 218, 255, 0.65);
                            border-radius: 18px;
                            padding: 24px;
                            min-height: 240px;
                            display:flex;
                            flex-direction:column;
                            align-items:center;
                            justify-content:center;
                            gap:14px;
                            box-shadow: 0 12px 32px rgba(10, 15, 35, 0.25);
                            backdrop-filter: blur(10px);">
                  <div style="font-size:52px;opacity:0.45;">ğŸš—</div>
                  <div style="font-size:14px;color:rgba(255,255,255,0.75);text-align:center;">
                    No vehicle equipped. Pick a ride from the candy garage.
                    </div>
                  <button class="gear-action-btn" onclick="window.BagSystem.renderTab('vehicles')" style="padding:10px 26px;font-size:12px;border-radius:999px;">
                    Browse Vehicles
                  </button>
                  </div>
              `;
            }

            const chips = [
              formatStatChip('ğŸš€', 'Speed', equippedVehicle.speed),
              formatStatChip('âš¡', 'Agility', equippedVehicle.agility),
              formatStatChip('ğŸ›¡ï¸', 'Durability', equippedVehicle.durability),
              formatStatChip('ğŸ‘¥', 'Capacity', equippedVehicle.capacity),
              formatStatChip('ğŸ·ï¸', 'Type', getCategoryLabel(equippedVehicle))
            ].join('');

            return `
              <div style="background: linear-gradient(145deg, rgba(132, 218, 255, 0.3), rgba(144, 255, 222, 0.28));
                          border: 2px solid rgba(132, 218, 255, 0.6);
                          border-radius: 18px;
                          padding: 24px;
                          min-height: 240px;
                          display:flex;
                          flex-direction:column;
                          gap:16px;
                          box-shadow: 0 20px 40px rgba(9, 14, 38, 0.45);
                          backdrop-filter: blur(10px);">
                <div style="display:flex;justify-content:space-between;align-items:center;">
                  <div style="display:flex;align-items:center;gap:12px;">
                    <span style="font-size:48px;text-shadow:0 6px 14px rgba(0,0,0,0.25);">${equippedVehicle.icon}</span>
                    <div>
                      <div style="font-size:13px;color:#89e6ff;text-transform:uppercase;letter-spacing:0.6px;">Current Vehicle</div>
                      <div style="font-size:18px;color:#ffffff;font-weight:700;">${equippedVehicle.name}</div>
                      <div style="font-size:11px;color:${vehicleStatusBadge.includes('Called') ? '#7df9ff' : '#89e6ff'};">${vehicleStatusBadge.replace(/<[^>]+>/g, '')}</div>
                    </div>
                  </div>
                  <button class="gear-equip-btn" onclick="window.BagSystem.unequipVehicle()" style="padding:10px 22px;font-size:11px;border-radius:999px;">
                    Exit Vehicle
                  </button>
                </div>
                <div style="display:flex;flex-wrap:wrap;gap:8px;">
                  ${chips}
              </div>
                <div style="font-size:12px;color:rgba(255,255,255,0.75);line-height:1.6;">
                  ${equippedVehicle.description || 'Ready to cruise the neon highways.'}
                </div>
              </div>
            `;
          };

          const renderVehicleListItem = (vehicle) => {
            const candidateUid = self.computeCompanionUid('vehicle', vehicle);
            const isEquipped = !!equippedVehicle && (equippedVehicle.uid === candidateUid || equippedVehicle.id === vehicle.id);
            let isSummoned = false;
            if (candidateUid && companionManager?.isSpawned) {
              try {
                isSummoned = !!companionManager.isSpawned(candidateUid);
              } catch (_) {
                isSummoned = false;
              }
            }
            const badgeMarkup = isSummoned
              ? '<div style="position: absolute; top: 10px; right: 10px; background: rgba(0, 229, 255, 0.95); color: #00111a; padding: 4px 8px; border-radius: 999px; font-size: 10px; font-weight: 700;">CALLED</div>'
              : (isEquipped ? '<div style="position: absolute; top: 10px; right: 10px; background: rgba(129, 199, 255, 0.9); color: #00111a; padding: 4px 8px; border-radius: 999px; font-size: 10px; font-weight: 700;">EQUIPPED</div>' : '');
            const equipCheck = typeof self.canEquipItem === 'function'
              ? self.canEquipItem(vehicle, 'vehicle')
              : { canEquip: true };
            const buttonIntent = isSummoned ? 'recall' : (isEquipped ? 'summon' : 'equip');
            const buttonLabel = isSummoned ? 'Recall' : (isEquipped ? 'Call' : 'Equip');
            const buttonDisabled = (!equipCheck.canEquip && !isEquipped) ? 'disabled' : '';
            return `
              <div class="vehicle-card"
                   style="position:relative;background:rgba(0,0,0,0.42);border:2px solid rgba(0,229,255,0.35);border-radius:14px;padding:14px;margin-bottom:12px;display:flex;gap:12px;align-items:flex-start;">
                      ${badgeMarkup}
                <div style="font-size:32px;">${vehicle.icon}</div>
                <div style="flex:1;display:flex;flex-direction:column;gap:6px;">
                  <div style="display:flex;justify-content:space-between;align-items:center;">
                    <div>
                      <div style="font-size:13px;color:#89e6ff;font-weight:700;">${vehicle.name}</div>
                      <div style="font-size:10px;color:rgba(207,227,255,0.55);text-transform:uppercase;letter-spacing:0.5px;">${vehicle.type}</div>
                      </div>
                    <div style="font-size:11px;color:#ffd77a;font-weight:700;">ğŸ’° ${vehicle.cost.toLocaleString()} g</div>
                  </div>
                  <div style="display:flex;flex-wrap:wrap;gap:6px;">
                    ${formatStatChip('ğŸš€', 'SPD', vehicle.speed)}
                    ${formatStatChip('âš¡', 'AGI', vehicle.agility)}
                    ${formatStatChip('ğŸ›¡ï¸', 'DUR', vehicle.durability)}
                    ${formatStatChip('ğŸ‘¥', 'CAP', vehicle.capacity)}
                    ${formatStatChip('ğŸ·ï¸', 'Type', getCategoryLabel(vehicle))}
                  </div>
                  <div style="font-size:10px;color:rgba(207,227,255,0.55);line-height:1.4;height:32px;overflow:hidden;text-overflow:ellipsis;">
                        ${vehicle.description}
                      </div>
                  <div style="display:flex;gap:6px;">
                    <button class="vehicle-action-btn board" data-action="board" data-intent="${buttonIntent}" data-vehicle-id="${vehicle.id}" ${buttonDisabled}
                            style="flex:1;padding:6px 0;border-radius:999px;font-size:10px;">
                          ${buttonLabel}
                        </button>
                    <button class="vehicle-action-btn upgrade" data-action="upgrade" data-vehicle-id="${vehicle.id}"
                            style="flex:1;padding:6px 0;border-radius:999px;font-size:10px;">
                          Upgrade
                        </button>
                    <button class="vehicle-action-btn customize" data-action="customize" data-vehicle-id="${vehicle.id}"
                            style="padding:6px 12px;border-radius:999px;font-size:10px;">
                      Tune
                        </button>
                  </div>
                      </div>
                    </div>
                  `;
          };

          pane.innerHTML = `
            <div style="display:flex;flex-direction:column;gap:18px;padding:20px;">
              <div>
                <h2 style="font-size:22px;color:#7de7ff;margin:0 0 8px;">ğŸš˜ Vehicle Hangar</h2>
                <p style="font-size:12px;color:rgba(255,255,255,0.72);margin:0;">
                  Swap rides instantly. Equipped vehicles appear on the left, garage inventory on the right.
                </p>
              </div>
              <div style="display:grid;grid-template-columns:minmax(0,1.2fr) minmax(0,0.8fr);gap:18px;align-items:start;">
                <div>
                  ${renderEquippedCard()}
                </div>
                <div>
                  <div class="inventory-header" style="margin-bottom:12px;">
                    <div style="font-size:14px;color:#cfeeff;font-weight:700;">Garage (${vehicles.length})</div>
                    <div class="filter-sort-controls" style="margin-top:10px;">
                      <div class="filter-chips" style="flex-wrap:wrap;gap:6px;">
                        <button class="filter-chip ${this.state.vehicleFilter === 'all' ? 'active' : ''}" data-filter="all">All</button>
                        <button class="filter-chip ${this.state.vehicleFilter === 'ground' ? 'active' : ''}" data-filter="ground">Ground</button>
                        <button class="filter-chip ${this.state.vehicleFilter === 'hover' ? 'active' : ''}" data-filter="hover">Hover</button>
                        <button class="filter-chip ${this.state.vehicleFilter === 'air' ? 'active' : ''}" data-filter="air">Air</button>
                      </div>
                      <select class="sort-dropdown" id="vehicleSort" style="margin-top:8px;">
                        <option value="speed" ${this.state.vehicleSort === 'speed' ? 'selected' : ''}>Sort: Speed</option>
                        <option value="cost" ${this.state.vehicleSort === 'cost' ? 'selected' : ''}>Sort: Cost</option>
                        <option value="name" ${this.state.vehicleSort === 'name' ? 'selected' : ''}>Sort: Name</option>
                      </select>
                    </div>
                  </div>
                  ${vehicles.length === 0 ? `
                    <div class="tab-empty">
                      <div class="empty-icon">ğŸš—</div>
                      <p>No vehicles match filter</p>
                    </div>
                  ` : `
                    <div style="max-height:420px; overflow-y:auto; padding-right:12px; padding-left:4px;">
                      ${vehicles.map(renderVehicleListItem).join('')}
              </div>
            `}
                </div>
              </div>
            </div>
          `;

          // Attach filter listeners
          pane.querySelectorAll('.filter-chip').forEach(chip => {
            chip.addEventListener('click', () => {
              this.state.vehicleFilter = chip.dataset.filter;
              this.renderVehiclesTab();
            });
          });

          // Attach sort listener
          const sortSelect = pane.querySelector('#vehicleSort');
          if (sortSelect) {
            sortSelect.addEventListener('change', (e) => {
              this.state.vehicleSort = e.target.value;
              this.renderVehiclesTab();
            });
          }

          // Attach vehicle action buttons
          pane.querySelectorAll('.vehicle-action-btn').forEach(btn => {
            btn.addEventListener('click', () => {
              const action = btn.dataset.action;
              const vehicleId = btn.dataset.vehicleId;
              const vehicle = window.gameState.inventory.vehicles.find(v => v.id === vehicleId);

              if (action === 'board' && vehicle) {
                const intent = btn.dataset.intent || 'summon';
                if (intent === 'equip') {
                  // Just equip the vehicle without summoning
                  this.equipVehicle(vehicle);
                } else {
                  this.toggleCompanionActivation('vehicle', {
                    ensureEquip: true,
                    item: vehicle,
                    preferSpawn: intent !== 'recall',
                    forceRecall: intent === 'recall',
                    origin: 'vehicles-tab',
                    showToast: false,
                  });
                }
              }
              else if (action === 'upgrade' && vehicle) this.upgradeVehicle(vehicleId);
              else if (action === 'customize' && vehicle) this.customizeVehicle(vehicleId);
            });
          });
        },

        renderAITab() {
          const pane = document.getElementById('bagContentPane');
          
          // Initialize AI subtab state
          if (!this.state.aiSubtab) {
            this.state.aiSubtab = 'robots';
          }
          
          // Initialize Solo Leveling System data
          if (!window.gameState.soloLevelingSystem) {
            window.gameState.soloLevelingSystem = {
              level: window.gameState.level || 1,
              exp: 0,
              expToNext: 100,
              hp: 100,
              maxHp: 100,
              mp: 50,
              maxMp: 50,
              stats: {
                strength: 10,
                agility: 10,
                intelligence: 10,
                vitality: 10,
                sense: 10
              },
              dailyQuests: this.generateDailyQuests(),
              lastDailyReset: Date.now(),
              messages: [
                { text: "Welcome, Player. I am the System.", time: Date.now(), type: "system" }
              ],
              statPoints: 0,
              // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              // AI AUTONOMY SYSTEM
              // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
              aiRequests: [],
              aiAutoMode: false,
              aiMonitoring: false,
              aiActions: [],
              aiSettings: {
                autoApproveBelow: 100,
                healthThreshold: 30,
                mpThreshold: 20,
                inventoryThreshold: 90,
                autoSell: true,
                autoBuyPotions: true,
                proactiveMode: false
              }
            };
          }
          
          // Initialize AI autonomy fields if they don't exist (for existing saves)
          const sl = window.gameState.soloLevelingSystem;
          if (!sl.aiRequests) sl.aiRequests = [];
          if (!sl.aiActions) sl.aiActions = [];
          if (typeof sl.aiAutoMode === 'undefined') sl.aiAutoMode = false;
          if (typeof sl.aiMonitoring === 'undefined') sl.aiMonitoring = false;
          if (!sl.aiSettings) {
            sl.aiSettings = {
              autoApproveBelow: 100,
              healthThreshold: 30,
              mpThreshold: 20,
              inventoryThreshold: 90,
              autoSell: true,
              autoBuyPotions: true,
              proactiveMode: false
            };
          }
          
          // Start AI monitoring if enabled
          if (sl.aiMonitoring && !this.aiMonitorInterval) {
            this.startAIMonitoring();
          }
          
          // Check if daily quests need reset
          const now = Date.now();
          const daysPassed = Math.floor((now - window.gameState.soloLevelingSystem.lastDailyReset) / (1000 * 60 * 60 * 24));
          if (daysPassed >= 1) {
            window.gameState.soloLevelingSystem.dailyQuests = this.generateDailyQuests();
            window.gameState.soloLevelingSystem.lastDailyReset = now;
            this.addSystemMessage("Daily quests have been refreshed.", "system");
          }

          pane.innerHTML = `
            <div style="padding: 20px;">
              <!-- AI Subtabs -->
              <div style="display: flex; gap: 8px; margin-bottom: 20px; border-bottom: 2px solid rgba(79, 195, 247, 0.2); padding-bottom: 10px;">
                <button class="ai-subtab-btn ${this.state.aiSubtab === 'robots' ? 'active' : ''}" data-subtab="robots" style="padding: 10px 20px; background: ${this.state.aiSubtab === 'robots' ? 'rgba(91, 163, 255, 0.3)' : 'rgba(0, 0, 0, 0.3)'}; border: 2px solid ${this.state.aiSubtab === 'robots' ? 'rgba(91, 163, 255, 0.6)' : 'rgba(79, 195, 247, 0.3)'}; border-radius: 8px; color: ${this.state.aiSubtab === 'robots' ? '#5ba3ff' : 'rgba(207, 227, 255, 0.7)'}; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.3s ease;">
                  ğŸ¬ AI Robots
                </button>
                <button class="ai-subtab-btn ${this.state.aiSubtab === 'system' ? 'active' : ''}" data-subtab="system" style="padding: 10px 20px; background: ${this.state.aiSubtab === 'system' ? 'rgba(0, 229, 255, 0.3)' : 'rgba(0, 0, 0, 0.3)'}; border: 2px solid ${this.state.aiSubtab === 'system' ? 'rgba(0, 229, 255, 0.6)' : 'rgba(79, 195, 247, 0.3)'}; border-radius: 8px; color: ${this.state.aiSubtab === 'system' ? '#00e5ff' : 'rgba(207, 227, 255, 0.7)'}; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.3s ease;">
                  âš¡ A1K System
                </button>
              </div>
              
              <!-- Subtab Content -->
              <div id="ai-subtab-content"></div>
            </div>
          `;
          
          // Render the active subtab
          this.renderAISubtab();
          
          // Attach subtab button listeners
          setTimeout(() => {
            document.querySelectorAll('.ai-subtab-btn').forEach(btn => {
              btn.addEventListener('click', () => {
                this.state.aiSubtab = btn.getAttribute('data-subtab');
                this.renderAITab();
              });
            });
          }, 50);
        },
        
        renderAISubtab() {
          const container = document.getElementById('ai-subtab-content');
          if (!container) return;
          
          if (this.state.aiSubtab === 'robots') {
            this.renderRobotsSubtab(container);
          } else if (this.state.aiSubtab === 'system') {
            this.renderSoloLevelingSubtab(container);
          }
        },
        
        renderRobotsSubtab(container) {
          const equippedRobot = window.gameState.equipped.robot;
          let robots = window.gameState.inventory.robots || [];

          // Apply filter
          if (this.state.robotFilter !== 'all') {
            robots = robots.filter(r => r.type === this.state.robotFilter);
          }

          // Apply sort
          if (this.state.robotSort === 'atk') {
            robots.sort((a, b) => b.atk - a.atk);
          } else if (this.state.robotSort === 'hp') {
            robots.sort((a, b) => b.hp - a.hp);
          } else if (this.state.robotSort === 'cost') {
            robots.sort((a, b) => a.cost - b.cost);
          } else if (this.state.robotSort === 'name') {
            robots.sort((a, b) => a.name.localeCompare(b.name));
          }

          const getTierColor = (tier) => {
            const colors = {
              common: '#ffffff', uncommon: '#4CAF50', rare: '#3498db',
              epic: '#9b59b6', legendary: '#f39c12'
            };
            return colors[tier] || '#ffffff';
          };

          container.innerHTML = `
            ${equippedRobot ? `
              <div style="background: rgba(0, 0, 0, 0.4); border: 2px solid rgba(91, 163, 255, 0.6); border-radius: 12px; padding: 16px; margin-bottom: 20px; animation: robotGlow 2s ease-in-out infinite;">
                <h3 style="color: #5ba3ff; margin-bottom: 12px; font-size: 16px;">ğŸ¬ Deployed Robot</h3>
                <div style="display: flex; align-items: center; gap: 16px; flex-wrap: wrap;">
                  <div style="font-size: 48px;">${equippedRobot.icon}</div>
                  <div style="flex: 1;">
                    <div style="font-size: 18px; font-weight: 700; color: #5ba3ff; margin-bottom: 4px;">${equippedRobot.name}</div>
                    <div style="font-size: 12px; color: rgba(207, 227, 255, 0.7); margin-bottom: 8px;">${equippedRobot.description}</div>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                      <span style="padding: 4px 10px; background: rgba(56, 239, 125, 0.2); border-radius: 6px; font-size: 11px; color: #38ef7d;">
                        â¤ï¸ HP: ${equippedRobot.hp}
                      </span>
                      <span style="padding: 4px 10px; background: rgba(255, 107, 53, 0.2); border-radius: 6px; font-size: 11px; color: #ff6b35;">
                        âš”ï¸ ATK: ${equippedRobot.atk}
                      </span>
                      <span style="padding: 4px 10px; background: rgba(0, 229, 255, 0.2); border-radius: 6px; font-size: 11px; color: #00e5ff;">
                        ğŸ›¡ï¸ DEF: ${equippedRobot.def}
                      </span>
                      <span style="padding: 4px 10px; background: rgba(167, 139, 250, 0.2); border-radius: 6px; font-size: 11px; color: #a78bfa;">
                        âš¡ Speed: ${equippedRobot.speed}
                      </span>
                    </div>
                    <div style="font-size: 10px; color: rgba(255, 215, 122, 0.8); margin-top: 8px;">
                      ğŸ”¹ Abilities: ${equippedRobot.abilities.join(', ')}
                    </div>
                    <div style="font-size: 10px; color: rgba(207, 227, 255, 0.6); margin-top: 4px;">
                      ğŸ® Modes: ${equippedRobot.modes.join(', ')}
                    </div>
                  </div>
                  <button class="gear-equip-btn" onclick="window.BagSystem.unequipRobot()" style="width: auto; padding: 10px 20px;">
                    Recall Robot
                  </button>
                </div>
              </div>
            ` : ''}

            <div class="inventory-header">
              <h3>Robot Arsenal (${robots.length})</h3>
              <div class="filter-sort-controls">
                <div class="filter-chips">
                  <button class="filter-chip ${this.state.robotFilter === 'all' ? 'active' : ''}" data-filter="all">All</button>
                  <button class="filter-chip ${this.state.robotFilter === 'combat_bot' ? 'active' : ''}" data-filter="combat_bot">ğŸ¤– Combat</button>
                  <button class="filter-chip ${this.state.robotFilter === 'support_drone' ? 'active' : ''}" data-filter="support_drone">ğŸ›¸ Support</button>
                  <button class="filter-chip ${this.state.robotFilter === 'mech' ? 'active' : ''}" data-filter="mech">ğŸ¦¾ Mech</button>
                  <button class="filter-chip ${this.state.robotFilter === 'infiltrator' ? 'active' : ''}" data-filter="infiltrator">ğŸ¥· Stealth</button>
                  <button class="filter-chip ${this.state.robotFilter === 'ranged_specialist' ? 'active' : ''}" data-filter="ranged_specialist">ğŸ¯ Ranged</button>
                </div>
                <select class="sort-dropdown" id="robotSort">
                  <option value="atk" ${this.state.robotSort === 'atk' ? 'selected' : ''}>Sort: Attack</option>
                  <option value="hp" ${this.state.robotSort === 'hp' ? 'selected' : ''}>Sort: HP</option>
                  <option value="cost" ${this.state.robotSort === 'cost' ? 'selected' : ''}>Sort: Cost</option>
                  <option value="name" ${this.state.robotSort === 'name' ? 'selected' : ''}>Sort: Name</option>
                </select>
              </div>
            </div>

            ${robots.length === 0 ? `
              <div class="tab-empty">
                <div class="empty-icon">ğŸ¤–</div>
                <p>No robots match filter</p>
              </div>
            ` : `
              <div class="gear-items-grid">
                ${robots.map(robot => {
            const isEquipped = equippedRobot && equippedRobot.id === robot.id;
            return `
                    <div class="gear-item-card robot-card ${isEquipped ? 'equipped-robot' : ''}" data-robot-id="${robot.id}" style="border-color: ${getTierColor(robot.tier)};">
                      ${isEquipped ? '<div style="position: absolute; top: 8px; right: 8px; background: rgba(91, 163, 255, 0.9); color: #fff; padding: 4px 8px; border-radius: 6px; font-size: 10px; font-weight: 700;">DEPLOYED</div>' : ''}
                      <div class="gear-item-icon" style="font-size: 40px;">${robot.icon}</div>
                      <div class="gear-item-name">${robot.name}</div>
                      <div style="font-size: 10px; padding: 3px 8px; background: ${getTierColor(robot.tier)}; border-radius: 6px; margin: 4px 0; text-transform: uppercase; color: #000; font-weight: 700;">${robot.tier}</div>
                      <div class="gear-item-stats">
                        <span class="stat-badge" style="background: rgba(56, 239, 125, 0.2); color: #38ef7d;">
                          â¤ï¸ ${robot.hp}
                        </span>
                        <span class="stat-badge" style="background: rgba(255, 107, 53, 0.2); color: #ff6b35;">
                          âš”ï¸ ${robot.atk}
                        </span>
                        <span class="stat-badge" style="background: rgba(0, 229, 255, 0.2); color: #00e5ff;">
                          ğŸ›¡ï¸ ${robot.def}
                        </span>
                        <span class="stat-badge" style="background: rgba(167, 139, 250, 0.2); color: #a78bfa;">
                          âš¡ ${robot.speed}
                        </span>
                      </div>
                      <div style="font-size: 9px; color: rgba(255, 215, 122, 0.8); margin: 6px 0; height: 32px; overflow: hidden;">
                        ğŸ”¹ ${robot.abilities.slice(0, 3).join(', ')}
                      </div>
                      <div style="font-size: 10px; color: rgba(255, 215, 122, 0.8); margin: 6px 0;">ğŸ’° ${robot.cost.toLocaleString()} g</div>
                      <div style="font-size: 9px; color: rgba(207, 227, 255, 0.5); font-style: italic; margin-bottom: 10px; height: 28px; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;">
                        ${robot.description}
                      </div>
                      <div class="robot-actions" style="display: flex; flex-direction: column; gap: 4px;">
                        <button class="robot-action-btn deploy" data-action="equip" data-robot-id="${robot.id}" ${isEquipped ? 'disabled' : ''}>
                          ${isEquipped ? 'Equipped' : 'Equip'}
                        </button>
                        <button class="robot-action-btn repair" data-action="repair" data-robot-id="${robot.id}" style="font-size: 9px; padding: 4px 8px;">
                          Repair
                        </button>
                        <button class="robot-action-btn upgrade" data-action="upgrade" data-robot-id="${robot.id}" style="font-size: 9px; padding: 4px 8px;">
                          Upgrade
                        </button>
                      </div>
                    </div>
                  `;
          }).join('')}
              </div>
            `}
          `;

          // Attach filter listeners
          setTimeout(() => {
            container.querySelectorAll('.filter-chip').forEach(chip => {
              chip.addEventListener('click', () => {
                this.state.robotFilter = chip.dataset.filter;
                this.renderAITab();
              });
            });

            // Attach sort listener
            const sortSelect = container.querySelector('#robotSort');
            if (sortSelect) {
              sortSelect.addEventListener('change', (e) => {
                this.state.robotSort = e.target.value;
                this.renderAITab();
              });
            }

            // Attach robot action buttons
            container.querySelectorAll('.robot-action-btn').forEach(btn => {
              btn.addEventListener('click', () => {
                const action = btn.dataset.action;
                const robotId = btn.dataset.robotId;
                const robot = window.gameState.inventory.robots.find(r => r.id === robotId);

              if (action === 'equip' && robot) this.equipRobot(robot);
                else if (action === 'repair' && robot) this.repairRobot(robotId);
                else if (action === 'upgrade' && robot) this.upgradeRobot(robotId);
              });
            });
          }, 100);
        },
        
        renderSoloLevelingSubtab(container) {
          const sl = window.gameState.soloLevelingSystem;
          const expPercent = (sl.exp / sl.expToNext) * 100;
          const hpPercent = (sl.hp / sl.maxHp) * 100;
          const mpPercent = (sl.mp / sl.maxMp) * 100;
          
          container.innerHTML = `
            <div style="max-width: 100%; overflow-y: auto; max-height: calc(100vh - 250px);">
              
              <!-- System Header -->
              <div style="background: linear-gradient(135deg, rgba(0, 229, 255, 0.15), rgba(167, 139, 250, 0.15)); border: 2px solid rgba(0, 229, 255, 0.3); border-radius: 16px; padding: 20px; margin-bottom: 20px; box-shadow: 0 8px 32px rgba(0, 229, 255, 0.2);">
                <div style="display: flex; align-items: center; gap: 16px; margin-bottom: 16px;">
                  <div style="font-size: 48px; filter: drop-shadow(0 0 10px rgba(0, 229, 255, 0.6));">ğŸ®</div>
                  <div style="flex: 1;">
                    <h2 style="margin: 0; color: #00e5ff; font-size: 24px; text-shadow: 0 0 10px rgba(0, 229, 255, 0.5);">A1K SYSTEM</h2>
                    <p style="margin: 4px 0 0 0; color: rgba(207, 227, 255, 0.7); font-size: 13px;">Intelligent Game Assistant</p>
                  </div>
                  <div style="text-align: right;">
                    <div style="font-size: 28px; font-weight: 700; color: #a78bfa;">Lv. ${sl.level}</div>
                    <div style="font-size: 11px; color: rgba(167, 139, 250, 0.7);">${sl.statPoints > 0 ? `+${sl.statPoints} Stat Points` : 'Player'}</div>
                  </div>
                </div>
                
                <!-- EXP Bar -->
                <div style="margin-bottom: 8px;">
                  <div style="display: flex; justify-content: space-between; font-size: 11px; color: rgba(207, 227, 255, 0.7); margin-bottom: 4px;">
                    <span>EXP</span>
                    <span>${sl.exp} / ${sl.expToNext}</span>
                  </div>
                  <div style="height: 12px; background: rgba(0, 0, 0, 0.4); border-radius: 6px; overflow: hidden; border: 1px solid rgba(79, 195, 247, 0.3);">
                    <div style="height: 100%; width: ${expPercent}%; background: linear-gradient(90deg, #4fc3f7, #00e5ff); transition: width 0.5s ease; box-shadow: 0 0 10px rgba(0, 229, 255, 0.6);"></div>
                  </div>
                </div>
                
                <!-- HP and MP Bars -->
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                  <div>
                    <div style="display: flex; justify-content: space-between; font-size: 11px; color: rgba(255, 107, 107, 0.9); margin-bottom: 4px;">
                      <span>â¤ï¸ HP</span>
                      <span>${sl.hp} / ${sl.maxHp}</span>
                    </div>
                    <div style="height: 10px; background: rgba(0, 0, 0, 0.4); border-radius: 5px; overflow: hidden; border: 1px solid rgba(255, 107, 107, 0.3);">
                      <div style="height: 100%; width: ${hpPercent}%; background: linear-gradient(90deg, #ff6b6b, #ff4757); transition: width 0.3s ease;"></div>
                    </div>
                  </div>
                  <div>
                    <div style="display: flex; justify-content: space-between; font-size: 11px; color: rgba(79, 195, 247, 0.9); margin-bottom: 4px;">
                      <span>ğŸ’™ MP</span>
                      <span>${sl.mp} / ${sl.maxMp}</span>
                    </div>
                    <div style="height: 10px; background: rgba(0, 0, 0, 0.4); border-radius: 5px; overflow: hidden; border: 1px solid rgba(79, 195, 247, 0.3);">
                      <div style="height: 100%; width: ${mpPercent}%; background: linear-gradient(90deg, #4fc3f7, #5f27cd); transition: width 0.3s ease;"></div>
                    </div>
                  </div>
                </div>
              </div>
              
              <!-- Stats Panel -->
              <div style="background: rgba(0, 0, 0, 0.3); border: 2px solid rgba(79, 195, 247, 0.3); border-radius: 12px; padding: 16px; margin-bottom: 20px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
                  <h3 style="margin: 0; color: #4fc3f7; font-size: 16px;">ğŸ“Š Player Stats</h3>
                  ${sl.statPoints > 0 ? `<span style="background: rgba(167, 139, 250, 0.3); color: #a78bfa; padding: 4px 12px; border-radius: 6px; font-size: 12px; font-weight: 600;">+${sl.statPoints} Available</span>` : ''}
                </div>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px;">
                  ${Object.entries(sl.stats).map(([stat, value]) => `
                    <div style="display: flex; align-items: center; justify-content: space-between; padding: 10px; background: rgba(0, 0, 0, 0.3); border-radius: 8px; border: 1px solid rgba(79, 195, 247, 0.2);">
                      <div style="display: flex; align-items: center; gap: 8px;">
                        <span style="font-size: 18px;">${this.getStatIcon(stat)}</span>
                        <div>
                          <div style="font-size: 11px; color: rgba(207, 227, 255, 0.6); text-transform: uppercase;">${stat}</div>
                          <div style="font-size: 18px; font-weight: 700; color: #fff;">${value}</div>
                        </div>
                      </div>
                      ${sl.statPoints > 0 ? `<button class="stat-plus-btn" data-stat="${stat}" style="width: 28px; height: 28px; border-radius: 50%; background: rgba(0, 229, 255, 0.2); border: 2px solid rgba(0, 229, 255, 0.4); color: #00e5ff; font-size: 16px; font-weight: 700; cursor: pointer; transition: all 0.3s ease;">+</button>` : ''}
                    </div>
                  `).join('')}
                </div>
              </div>
              
              <!-- Character Skill Context (for AI recommendations) -->
              <div style="background: rgba(0, 0, 0, 0.3); border: 2px solid rgba(255, 215, 122, 0.3); border-radius: 12px; padding: 16px; margin-bottom: 20px;">
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
                  <span style="font-size: 20px;">âš”ï¸</span>
                  <h3 style="margin: 0; color: #ffd77a; font-size: 16px;">Current Skill Loadouts</h3>
                </div>
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;">
                  ${['A1', 'UNIQUE', 'MISSY'].map(charId => {
                    const summary = this.getCharacterEquippedSkillsSummary(charId);
                    const charInfo = { A1: { name: 'A1', icon: 'âš”ï¸', color: '#ff6b6b' }, UNIQUE: { name: 'Unique', icon: 'âš¡', color: '#00e5ff' }, MISSY: { name: 'Missy', icon: 'ğŸŒ™', color: '#a78bfa' } }[charId];
                    return `
                      <div style="background: rgba(0, 0, 0, 0.4); border: 1px solid ${charInfo.color}40; border-radius: 8px; padding: 10px;">
                        <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 6px;">
                          <span style="font-size: 16px;">${charInfo.icon}</span>
                          <span style="font-size: 11px; color: ${charInfo.color}; font-weight: 600;">${charInfo.name}</span>
                          <span style="font-size: 9px; color: rgba(207, 227, 255, 0.5); margin-left: auto;">${summary.totalEquipped}/7</span>
                        </div>
                        ${summary.skills.length > 0 ? `
                          <div style="display: flex; flex-wrap: wrap; gap: 3px; margin-top: 4px;">
                            ${summary.skills.slice(0, 3).map(skill => `
                              <div style="background: ${charInfo.color}20; border: 1px solid ${charInfo.color}40; border-radius: 4px; padding: 2px 4px; font-size: 8px;" 
                                   title="${skill.name} | ğŸ’¥ ${skill.damage} | â±ï¸ ${skill.cooldown}s">
                                ${skill.icon} ${skill.slot}
                              </div>
                            `).join('')}
                            ${summary.skills.length > 3 ? `<div style="font-size: 7px; color: rgba(207, 227, 255, 0.4); padding: 2px;">+${summary.skills.length - 3}</div>` : ''}
                          </div>
                        ` : `
                          <div style="font-size: 8px; color: rgba(207, 227, 255, 0.3); text-align: center; padding: 4px;">Empty</div>
                        `}
                      </div>
                    `;
                  }).join('')}
                </div>
                <div style="font-size: 9px; color: rgba(207, 227, 255, 0.5); margin-top: 8px; padding-top: 8px; border-top: 1px solid rgba(255, 215, 122, 0.2);">
                  ğŸ’¡ AI uses this context to recommend optimal skill combinations and strategies.
                </div>
              </div>
              
              <!-- Daily Quests -->
              <div style="background: rgba(0, 0, 0, 0.3); border: 2px solid rgba(255, 215, 122, 0.3); border-radius: 12px; padding: 16px; margin-bottom: 20px;">
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
                  <span style="font-size: 20px;">â˜€ï¸</span>
                  <h3 data-daily-quests-link style="margin: 0; color: #ffd77a; font-size: 16px; text-decoration: underline dotted rgba(255, 215, 122, 0.4); cursor: pointer;">Daily Quests</h3>
                  <span style="font-size: 11px; color: rgba(255, 215, 122, 0.6); margin-left: auto;">${sl.dailyQuests.filter(q => q.completed).length} / ${sl.dailyQuests.length} Complete</span>
                </div>
                <div style="display: flex; flex-direction: column; gap: 12px;">
                  ${sl.dailyQuests.map(quest => {
                    const progress = Math.min((quest.progress || 0) / quest.requirement, 1) * 100;
                    return `
                      <div style="background: rgba(0, 0, 0, 0.4); border: 2px solid ${quest.completed ? 'rgba(76, 209, 55, 0.4)' : 'rgba(255, 215, 122, 0.3)'}; border-radius: 10px; padding: 14px; position: relative; ${quest.completed ? 'opacity: 0.7;' : ''}">
                        ${quest.completed ? '<div style="position: absolute; top: 12px; right: 12px; color: #4cd137; font-size: 24px;">âœ“</div>' : ''}
                        <div style="display: flex; gap: 12px; margin-bottom: 8px;">
                          <span style="font-size: 28px;">${quest.icon}</span>
                          <div style="flex: 1;">
                            <div style="font-size: 14px; font-weight: 600; color: #fff; margin-bottom: 4px;">${quest.name}</div>
                            <div style="font-size: 11px; color: rgba(207, 227, 255, 0.6); margin-bottom: 8px;">${quest.description}</div>
                            
                            <!-- Progress Bar -->
                            <div style="margin-bottom: 8px;">
                              <div style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(207, 227, 255, 0.5); margin-bottom: 3px;">
                                <span>Progress</span>
                                <span>${quest.progress || 0} / ${quest.requirement}</span>
                              </div>
                              <div style="height: 6px; background: rgba(0, 0, 0, 0.5); border-radius: 3px; overflow: hidden;">
                                <div style="height: 100%; width: ${progress}%; background: ${quest.completed ? 'linear-gradient(90deg, #4cd137, #6dd15f)' : 'linear-gradient(90deg, #ffd77a, #ffeb3b)'}; transition: width 0.3s ease;"></div>
                              </div>
                            </div>
                            
                            <!-- Rewards -->
                            <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 8px;">
                              ${quest.rewards.exp ? `<span style="font-size: 10px; padding: 3px 8px; background: rgba(79, 195, 247, 0.2); color: #4fc3f7; border-radius: 4px; border: 1px solid rgba(79, 195, 247, 0.3);">+${quest.rewards.exp} EXP</span>` : ''}
                              ${quest.rewards.gold ? `<span style="font-size: 10px; padding: 3px 8px; background: rgba(255, 215, 122, 0.2); color: #ffd77a; border-radius: 4px; border: 1px solid rgba(255, 215, 122, 0.3);">+${quest.rewards.gold} Gold</span>` : ''}
                              ${quest.rewards.item ? `<span style="font-size: 10px; padding: 3px 8px; background: rgba(167, 139, 250, 0.2); color: #a78bfa; border-radius: 4px; border: 1px solid rgba(167, 139, 250, 0.3);">${quest.rewards.item}</span>` : ''}
                            </div>
                            
                            ${!quest.completed && quest.progress >= quest.requirement ? `
                              <button class="complete-quest-btn" data-quest-id="${quest.id}" style="padding: 8px 16px; background: linear-gradient(135deg, rgba(76, 209, 55, 0.3), rgba(76, 209, 55, 0.5)); border: 2px solid rgba(76, 209, 55, 0.6); border-radius: 8px; color: #4cd137; font-weight: 600; font-size: 12px; cursor: pointer; width: 100%; transition: all 0.3s ease;">
                                âœ… Complete Quest
                              </button>
                            ` : ''}
                          </div>
                        </div>
                        ${quest.penalty ? `<div style="font-size: 10px; color: rgba(255, 107, 107, 0.8); margin-top: 8px; padding: 6px; background: rgba(255, 107, 107, 0.1); border-radius: 6px; border: 1px solid rgba(255, 107, 107, 0.2);">âš ï¸ Penalty: ${quest.penalty}</div>` : ''}
                      </div>
                    `;
                  }).join('')}
                </div>
                
                <!-- Quick Action Buttons for Testing -->
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-top: 12px;">
                  <button id="progressQuestBtn" style="padding: 10px; background: rgba(0, 229, 255, 0.2); border: 2px solid rgba(0, 229, 255, 0.4); border-radius: 8px; color: #00e5ff; font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.3s ease;">
                    ğŸ“ˆ Progress Quests (Test)
                  </button>
                  <button id="resetDailyBtn" style="padding: 10px; background: rgba(255, 215, 122, 0.2); border: 2px solid rgba(255, 215, 122, 0.4); border-radius: 8px; color: #ffd77a; font-size: 11px; font-weight: 600; cursor: pointer; transition: all 0.3s ease;">
                    ğŸ”„ Reset Daily Quests
                  </button>
                </div>
              </div>
              
              <!-- AI Command Terminal -->
              <div style="background: rgba(0, 0, 0, 0.3); border: 2px solid rgba(0, 229, 255, 0.3); border-radius: 12px; padding: 16px; margin-bottom: 20px;">
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
                  <span style="font-size: 20px;">ğŸ§ </span>
                  <h3 style="margin: 0; color: #00e5ff; font-size: 16px;">AI Command Terminal</h3>
                  <button id="showCommandsBtn" style="margin-left: auto; padding: 4px 12px; background: rgba(0, 229, 255, 0.2); border: 2px solid rgba(0, 229, 255, 0.4); border-radius: 6px; color: #00e5ff; font-size: 10px; font-weight: 600; cursor: pointer;">
                    ğŸ“‹ Help
                  </button>
                </div>
                
                <!-- Command Input -->
                <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                  <input 
                    type="text" 
                    id="aiCommandInput" 
                    placeholder="Type a command... (e.g., 'auto equip', 'help', 'teleport city')"
                    style="flex: 1; padding: 12px; background: rgba(0, 0, 0, 0.5); border: 2px solid rgba(0, 229, 255, 0.4); border-radius: 8px; color: #fff; font-size: 13px; font-family: 'Courier New', monospace; outline: none; transition: all 0.3s ease;"
                    onkeypress="if(event.key==='Enter') document.getElementById('sendCommandBtn').click()"
                  />
                  <button id="sendCommandBtn" style="padding: 12px 20px; background: linear-gradient(135deg, rgba(0, 229, 255, 0.3), rgba(0, 229, 255, 0.5)); border: 2px solid rgba(0, 229, 255, 0.6); border-radius: 8px; color: #00e5ff; font-weight: 600; font-size: 13px; cursor: pointer; transition: all 0.3s ease;">
                    â¤ Send
                  </button>
                </div>
                
                <!-- Quick Command Buttons -->
                <div id="quickCommandsDiv" style="display: none; margin-bottom: 12px; padding: 12px; background: rgba(0, 0, 0, 0.4); border-radius: 8px; border: 1px solid rgba(0, 229, 255, 0.2); max-height: 400px; overflow-y: auto;">
                  <div style="font-size: 11px; color: #00e5ff; font-weight: 600; margin-bottom: 8px;">ğŸ’¡ Available Commands (40+):</div>
                  
                  <div style="margin-bottom: 12px;">
                    <div style="font-size: 10px; color: #ffd77a; font-weight: 600; margin-bottom: 4px;">ğŸ§  ADVANCED AI COMMANDS:</div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 6px; font-size: 10px; color: rgba(207, 227, 255, 0.8); line-height: 1.6;">
                      <div><strong>analyze</strong> - Scan game state</div>
                      <div><strong>optimize</strong> - AI auto-improve</div>
                      <div><strong>find [item]</strong> - Search inventory</div>
                      <div><strong>best gear</strong> - Top 5 items</div>
                      <div><strong>wealth</strong> - Net worth</div>
                      <div><strong>explain [topic]</strong> - Learn features</div>
                      <div><strong>ai info</strong> - AI capabilities</div>
                      <div><strong>tutorial</strong> - Show guide</div>
                    </div>
                  </div>
                  
                  <div style="margin-bottom: 12px;">
                    <div style="font-size: 10px; color: #4fc3f7; font-weight: 600; margin-bottom: 4px;">ğŸ¤– AUTOMATION:</div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 6px; font-size: 10px; color: rgba(207, 227, 255, 0.8); line-height: 1.6;">
                      <div><strong>auto equip</strong> - Equip best gear</div>
                      <div><strong>auto upgrade</strong> - Upgrade all gear</div>
                      <div><strong>auto fuse</strong> - Fuse items</div>
                      <div><strong>auto sell</strong> - Sell junk</div>
                      <div><strong>open all</strong> - Open containers</div>
                      <div><strong>all auto</strong> - Run everything</div>
                    </div>
                  </div>
                  
                  <div style="margin-bottom: 12px;">
                    <div style="font-size: 10px; color: #a78bfa; font-weight: 600; margin-bottom: 4px;">ğŸ“ NAVIGATION:</div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 6px; font-size: 10px; color: rgba(207, 227, 255, 0.8); line-height: 1.6;">
                      <div><strong>alchemy</strong> - Alchemy tab</div>
                      <div><strong>inventory</strong> - Items tab</div>
                      <div><strong>shop</strong> - Shop tab</div>
                      <div><strong>map</strong> - Map tab</div>
                      <div><strong>gear</strong> - Gear tab</div>
                      <div><strong>quests</strong> - Open Quests tab</div>
                    </div>
                  </div>
                  
                  <div style="margin-bottom: 12px;">
                    <div style="font-size: 10px; color: #38ef7d; font-weight: 600; margin-bottom: 4px;">â„¹ï¸ INFORMATION:</div>
                    <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); gap: 6px; font-size: 10px; color: rgba(207, 227, 255, 0.8); line-height: 1.6;">
                      <div><strong>stats</strong> - Player stats</div>
                      <div><strong>status</strong> - Full status</div>
                      <div><strong>quest info</strong> - Quest status</div>
                      <div><strong>help</strong> - All commands</div>
                    </div>
                  </div>
                  
                  <div style="font-size: 9px; color: rgba(207, 227, 255, 0.6); margin-top: 8px; padding: 8px; background: rgba(0, 229, 255, 0.05); border-radius: 4px;">
                    ğŸ’¬ <strong>Natural Language Supported!</strong><br>
                    Try: "how many robots do I have?" or "optimize my game"
                  </div>
                </div>
                
                <!-- Command Suggestions -->
                <div id="commandSuggestions" style="display: none; margin-bottom: 8px; padding: 8px; background: rgba(0, 229, 255, 0.1); border: 1px solid rgba(0, 229, 255, 0.3); border-radius: 6px; font-size: 11px; color: #00e5ff;">
                  ğŸ’¡ Suggestions will appear here...
                </div>
              </div>
              
              <!-- AI AUTONOMY CONTROLS -->
              <div style="background: rgba(0, 0, 0, 0.3); border: 2px solid rgba(167, 139, 250, 0.3); border-radius: 12px; padding: 16px; margin-bottom: 20px;">
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
                  <span style="font-size: 20px;">ğŸ¤–</span>
                  <h3 style="margin: 0; color: #a78bfa; font-size: 16px;">AI Autonomy</h3>
                  <button id="toggleSettingsBtn" style="margin-left: auto; padding: 4px 12px; background: rgba(167, 139, 250, 0.2); border: 2px solid rgba(167, 139, 250, 0.4); border-radius: 6px; color: #a78bfa; font-size: 10px; font-weight: 600; cursor: pointer;">
                    âš™ï¸ Settings
                  </button>
                </div>
                
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-bottom: 12px;">
                  <button id="toggleAIMonitorBtn" style="padding: 10px; background: ${sl.aiMonitoring ? 'rgba(76, 209, 55, 0.2)' : 'rgba(255, 107, 107, 0.2)'}; border: 2px solid ${sl.aiMonitoring ? 'rgba(76, 209, 55, 0.4)' : 'rgba(255, 107, 107, 0.4)'}; border-radius: 8px; color: ${sl.aiMonitoring ? '#4cd137' : '#ff6b6b'}; font-size: 12px; font-weight: 600; cursor: pointer;">
                    ${sl.aiMonitoring ? 'âœ… Monitoring: ON' : 'â­• Monitoring: OFF'}
                  </button>
                  <button id="toggleAIAutoBtn" style="padding: 10px; background: ${sl.aiAutoMode ? 'rgba(76, 209, 55, 0.2)' : 'rgba(255, 107, 107, 0.2)'}; border: 2px solid ${sl.aiAutoMode ? 'rgba(76, 209, 55, 0.4)' : 'rgba(255, 107, 107, 0.4)'}; border-radius: 8px; color: ${sl.aiAutoMode ? '#4cd137' : '#ff6b6b'}; font-size: 12px; font-weight: 600; cursor: pointer;">
                    ${sl.aiAutoMode ? 'âš¡ Auto Mode: ON' : 'ğŸ”’ Auto Mode: OFF'}
                  </button>
                </div>
                
                <!-- SETTINGS PANEL (collapsible) -->
                <div id="aiSettingsPanel" style="display: none; margin-top: 12px; padding: 12px; background: rgba(0, 0, 0, 0.4); border-radius: 8px; border: 1px solid rgba(167, 139, 250, 0.3);">
                  <div style="font-size: 11px; color: #a78bfa; font-weight: 600; margin-bottom: 12px;">âš™ï¸ AI SETTINGS</div>
                  
                  <!-- Health Threshold -->
                  <div style="margin-bottom: 12px;">
                    <div style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(207, 227, 255, 0.8); margin-bottom: 4px;">
                      <span>â¤ï¸ Health Threshold</span>
                      <span id="healthThresholdValue">${sl.aiSettings.healthThreshold}%</span>
                    </div>
                    <input type="range" id="healthThresholdSlider" min="10" max="80" value="${sl.aiSettings.healthThreshold}" style="width: 100%; cursor: pointer;" />
                  </div>
                  
                  <!-- MP Threshold -->
                  <div style="margin-bottom: 12px;">
                    <div style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(207, 227, 255, 0.8); margin-bottom: 4px;">
                      <span>ğŸ’™ Mana Threshold</span>
                      <span id="mpThresholdValue">${sl.aiSettings.mpThreshold}%</span>
                    </div>
                    <input type="range" id="mpThresholdSlider" min="10" max="80" value="${sl.aiSettings.mpThreshold}" style="width: 100%; cursor: pointer;" />
                  </div>
                  
                  <!-- Inventory Threshold -->
                  <div style="margin-bottom: 12px;">
                    <div style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(207, 227, 255, 0.8); margin-bottom: 4px;">
                      <span>ğŸ’ Inventory Threshold</span>
                      <span id="inventoryThresholdValue">${sl.aiSettings.inventoryThreshold}%</span>
                    </div>
                    <input type="range" id="inventoryThresholdSlider" min="50" max="100" value="${sl.aiSettings.inventoryThreshold}" style="width: 100%; cursor: pointer;" />
                  </div>
                  
                  <!-- Auto Approve Limit -->
                  <div style="margin-bottom: 12px;">
                    <div style="display: flex; justify-content: space-between; font-size: 10px; color: rgba(207, 227, 255, 0.8); margin-bottom: 4px;">
                      <span>ğŸ’° Auto-Approve Below</span>
                      <span id="autoApproveValue">${sl.aiSettings.autoApproveBelow}g</span>
                    </div>
                    <input type="range" id="autoApproveSlider" min="0" max="500" step="50" value="${sl.aiSettings.autoApproveBelow}" style="width: 100%; cursor: pointer;" />
                  </div>
                  
                  <!-- Toggle Switches -->
                  <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 6px; font-size: 10px;">
                    <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                      <input type="checkbox" id="autoBuyPotionsToggle" ${sl.aiSettings.autoBuyPotions ? 'checked' : ''} />
                      <span>ğŸ’Š Auto Buy Potions</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                      <input type="checkbox" id="autoSellToggle" ${sl.aiSettings.autoSell ? 'checked' : ''} />
                      <span>ğŸ’° Auto Sell Junk</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 6px; cursor: pointer;">
                      <input type="checkbox" id="proactiveModeToggle" ${sl.aiSettings.proactiveMode ? 'checked' : ''} />
                      <span>ğŸ¯ Proactive Mode</span>
                    </label>
                  </div>
                  
                  <div style="margin-top: 12px; padding: 8px; background: rgba(0, 229, 255, 0.1); border-radius: 6px; font-size: 9px; color: rgba(207, 227, 255, 0.7); line-height: 1.4;">
                    ğŸ’¡ Changes are saved automatically. Proactive Mode makes AI suggest actions without being asked.
                  </div>
                </div>
                
                <div style="font-size: 10px; color: rgba(207, 227, 255, 0.6); line-height: 1.5;">
                  <strong>Monitoring:</strong> AI watches your health, resources, and inventory<br>
                  <strong>Auto Mode:</strong> AI executes all actions automatically without asking
                </div>
              </div>
              
              <!-- AI REQUESTS PANEL -->
              ${sl.aiRequests.filter(r => r.status === 'pending').length > 0 ? `
              <div style="background: rgba(0, 0, 0, 0.3); border: 2px solid rgba(255, 215, 122, 0.3); border-radius: 12px; padding: 16px; margin-bottom: 20px;">
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
                  <span style="font-size: 20px;">ğŸ“‹</span>
                  <h3 style="margin: 0; color: #ffd77a; font-size: 16px;">AI Requests</h3>
                  <span style="background: rgba(255, 215, 122, 0.3); color: #ffd77a; padding: 4px 10px; border-radius: 6px; font-size: 11px; font-weight: 600; margin-left: auto;">
                    ${sl.aiRequests.filter(r => r.status === 'pending').length} Pending
                  </span>
                </div>
                
                <div style="display: flex; flex-direction: column; gap: 12px;">
                  ${sl.aiRequests.filter(r => r.status === 'pending').map(req => {
                    const priorityColors = {
                      critical: { bg: 'rgba(255, 107, 107, 0.2)', border: 'rgba(255, 107, 107, 0.4)', text: '#ff6b6b', icon: 'ğŸ”´' },
                      high: { bg: 'rgba(255, 165, 0, 0.2)', border: 'rgba(255, 165, 0, 0.4)', text: '#ffa500', icon: 'ğŸŸ ' },
                      medium: { bg: 'rgba(255, 215, 122, 0.2)', border: 'rgba(255, 215, 122, 0.4)', text: '#ffd77a', icon: 'ğŸŸ¡' },
                      low: { bg: 'rgba(76, 209, 55, 0.2)', border: 'rgba(76, 209, 55, 0.4)', text: '#4cd137', icon: 'ğŸŸ¢' }
                    };
                    const colors = priorityColors[req.priority] || priorityColors.medium;
                    
                    return `
                      <div style="background: ${colors.bg}; border: 2px solid ${colors.border}; border-radius: 10px; padding: 12px;">
                        <div style="display: flex; align-items: start; gap: 10px; margin-bottom: 10px;">
                          <span style="font-size: 24px;">${colors.icon}</span>
                          <div style="flex: 1;">
                            <div style="font-size: 13px; font-weight: 600; color: #fff; margin-bottom: 4px;">${req.reason}</div>
                            <div style="font-size: 10px; color: rgba(207, 227, 255, 0.5);">
                              ${req.data.cost ? `Cost: ${req.data.cost} gold | ` : ''}Priority: ${req.priority.toUpperCase()}
                            </div>
                          </div>
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px;">
                          <button class="approve-request-btn" data-request-id="${req.id}" style="padding: 8px; background: rgba(76, 209, 55, 0.3); border: 2px solid rgba(76, 209, 55, 0.5); border-radius: 6px; color: #4cd137; font-size: 11px; font-weight: 600; cursor: pointer;">
                            âœ… APPROVE
                          </button>
                          <button class="deny-request-btn" data-request-id="${req.id}" style="padding: 8px; background: rgba(255, 107, 107, 0.3); border: 2px solid rgba(255, 107, 107, 0.5); border-radius: 6px; color: #ff6b6b; font-size: 11px; font-weight: 600; cursor: pointer;">
                            âŒ DENY
                          </button>
                        </div>
                      </div>
                    `;
                  }).join('')}
                </div>
              </div>
              ` : ''}
              
              <!-- AI ACTION LOG -->
              ${sl.aiActions.length > 0 ? `
              <div style="background: rgba(0, 0, 0, 0.3); border: 2px solid rgba(76, 209, 55, 0.3); border-radius: 12px; padding: 16px; margin-bottom: 20px;">
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
                  <span style="font-size: 20px;">ğŸ“Š</span>
                  <h3 style="margin: 0; color: #4cd137; font-size: 16px;">AI Action Log</h3>
                  <span style="background: rgba(76, 209, 55, 0.3); color: #4cd137; padding: 4px 10px; border-radius: 6px; font-size: 11px; font-weight: 600; margin-left: auto;">
                    ${sl.aiActions.length} Actions
                  </span>
                  <button id="clearLogBtn" style="padding: 4px 10px; background: rgba(255, 107, 107, 0.2); border: 2px solid rgba(255, 107, 107, 0.4); border-radius: 6px; color: #ff6b6b; font-size: 10px; font-weight: 600; cursor: pointer;">
                    ğŸ—‘ï¸ Clear
                  </button>
                </div>
                <div style="max-height: 200px; overflow-y: auto; display: flex; flex-direction: column; gap: 8px;">
                  ${sl.aiActions.slice(-10).reverse().map(action => {
                    const timeAgo = Math.floor((Date.now() - action.executedAt) / 1000);
                    const timeStr = timeAgo < 60 ? `${timeAgo}s ago` : `${Math.floor(timeAgo / 60)}m ago`;
                    
                    return `
                      <div style="padding: 10px; background: rgba(76, 209, 55, 0.1); border-left: 3px solid #4cd137; border-radius: 6px;">
                        <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 4px;">
                          <div style="font-size: 12px; color: #fff; font-weight: 600;">${action.reason}</div>
                          <div style="font-size: 9px; color: rgba(207, 227, 255, 0.5);">${timeStr}</div>
                        </div>
                        <div style="font-size: 10px; color: rgba(207, 227, 255, 0.6);">
                          Type: ${action.type} | Priority: ${action.priority}
                          ${action.data.cost ? ` | Cost: ${action.data.cost}g` : ''}
                        </div>
                      </div>
                    `;
                  }).join('')}
                </div>
              </div>
              ` : ''}
              
              <!-- System Messages -->
              <div style="background: rgba(0, 0, 0, 0.3); border: 2px solid rgba(167, 139, 250, 0.3); border-radius: 12px; padding: 16px;">
                <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
                  <span style="font-size: 20px;">ğŸ’¬</span>
                  <h3 style="margin: 0; color: #a78bfa; font-size: 16px;">System Messages</h3>
                </div>
                <div id="systemMessages" style="max-height: 300px; overflow-y: auto; display: flex; flex-direction: column; gap: 10px;">
                  ${sl.messages.slice(-20).reverse().map(msg => `
                    <div style="padding: 12px; background: ${
                      msg.type === 'system' ? 'rgba(0, 229, 255, 0.1)' : 
                      msg.type === 'reward' ? 'rgba(76, 209, 55, 0.1)' : 
                      msg.type === 'command' ? 'rgba(255, 215, 122, 0.1)' :
                      msg.type === 'error' ? 'rgba(255, 107, 107, 0.1)' :
                      'rgba(167, 139, 250, 0.1)'
                    }; border-left: 3px solid ${
                      msg.type === 'system' ? '#00e5ff' : 
                      msg.type === 'reward' ? '#4cd137' : 
                      msg.type === 'command' ? '#ffd77a' :
                      msg.type === 'error' ? '#ff6b6b' :
                      '#a78bfa'
                    }; border-radius: 6px;">
                      <div style="font-size: 12px; color: #fff; margin-bottom: 4px; ${msg.type === 'command' ? 'font-family: \'Courier New\', monospace;' : ''}">${msg.text}</div>
                      <div style="font-size: 9px; color: rgba(207, 227, 255, 0.4);">${new Date(msg.time).toLocaleTimeString()}</div>
                    </div>
                  `).join('')}
                </div>
              </div>
              
            </div>
          `;
          
          // Attach event listeners
          setTimeout(() => {
            // Stat increase buttons
            container.querySelectorAll('.stat-plus-btn').forEach(btn => {
              btn.addEventListener('click', () => {
                const stat = btn.getAttribute('data-stat');
                this.increaseStat(stat);
              });
            });
            
            // Complete quest buttons
            container.querySelectorAll('.complete-quest-btn').forEach(btn => {
              btn.addEventListener('click', () => {
                const questId = btn.getAttribute('data-quest-id');
                this.completeQuest(questId);
              });
            });
            
            const dailyLink = container.querySelector('[data-daily-quests-link]');
            if (dailyLink) {
              dailyLink.addEventListener('click', () => {
                window.BagSystem.state.activeTab = 'quests';
                window.BagSystem.renderTabs();
                window.BagSystem.renderTab('quests');
              });
            }
            
            // Progress quests (test button)
            container.querySelector('#progressQuestBtn')?.addEventListener('click', () => {
              this.progressAllQuests();
            });
            
            // Reset daily quests
            container.querySelector('#resetDailyBtn')?.addEventListener('click', () => {
              this.resetDailyQuests();
            });
            
            // Command input system
            const commandInput = document.getElementById('aiCommandInput');
            const sendBtn = document.getElementById('sendCommandBtn');
            const showCommandsBtn = document.getElementById('showCommandsBtn');
            
            if (sendBtn && commandInput) {
              sendBtn.addEventListener('click', () => {
                const command = commandInput.value.trim();
                if (command) {
                  this.processAICommand(command);
                  commandInput.value = '';
                }
              });
            }
            
            if (showCommandsBtn) {
              showCommandsBtn.addEventListener('click', () => {
                const div = document.getElementById('quickCommandsDiv');
                if (div) {
                  div.style.display = div.style.display === 'none' ? 'block' : 'none';
                }
              });
            }
            
            // AI AUTONOMY CONTROLS
            const toggleAIMonitorBtn = document.getElementById('toggleAIMonitorBtn');
            const toggleAIAutoBtn = document.getElementById('toggleAIAutoBtn');
            
            if (toggleAIMonitorBtn) {
              toggleAIMonitorBtn.addEventListener('click', () => {
                const sl = window.gameState.soloLevelingSystem;
                if (sl.aiMonitoring) {
                  this.stopAIMonitoring();
                } else {
                  this.startAIMonitoring();
                }
                this.renderAITab();
              });
            }
            
            if (toggleAIAutoBtn) {
              toggleAIAutoBtn.addEventListener('click', () => {
                const sl = window.gameState.soloLevelingSystem;
                sl.aiAutoMode = !sl.aiAutoMode;
                this.addSystemMessage(`ğŸ¤– Auto Mode ${sl.aiAutoMode ? 'ENABLED' : 'DISABLED'}`, 'system');
                this.renderAITab();
              });
            }
            
            // AI REQUEST BUTTONS
            container.querySelectorAll('.approve-request-btn').forEach(btn => {
              btn.addEventListener('click', () => {
                const requestId = btn.getAttribute('data-request-id');
                this.approveAIRequest(requestId);
              });
            });
            
            container.querySelectorAll('.deny-request-btn').forEach(btn => {
              btn.addEventListener('click', () => {
                const requestId = btn.getAttribute('data-request-id');
                this.denyAIRequest(requestId);
              });
            });
            
            // CLEAR ACTION LOG BUTTON
            const clearLogBtn = document.getElementById('clearLogBtn');
            if (clearLogBtn) {
              clearLogBtn.addEventListener('click', () => {
                window.gameState.soloLevelingSystem.aiActions = [];
                this.addSystemMessage('ğŸ“Š Action log cleared', 'system');
                this.renderAITab();
              });
            }
            
            // SETTINGS PANEL TOGGLE
            const toggleSettingsBtn = document.getElementById('toggleSettingsBtn');
            const settingsPanel = document.getElementById('aiSettingsPanel');
            if (toggleSettingsBtn && settingsPanel) {
              toggleSettingsBtn.addEventListener('click', () => {
                settingsPanel.style.display = settingsPanel.style.display === 'none' ? 'block' : 'none';
              });
            }
            
            // SETTINGS SLIDERS
            const healthSlider = document.getElementById('healthThresholdSlider');
            const mpSlider = document.getElementById('mpThresholdSlider');
            const inventorySlider = document.getElementById('inventoryThresholdSlider');
            const autoApproveSlider = document.getElementById('autoApproveSlider');
            
            if (healthSlider) {
              healthSlider.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                window.gameState.soloLevelingSystem.aiSettings.healthThreshold = value;
                document.getElementById('healthThresholdValue').textContent = value + '%';
              });
            }
            
            if (mpSlider) {
              mpSlider.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                window.gameState.soloLevelingSystem.aiSettings.mpThreshold = value;
                document.getElementById('mpThresholdValue').textContent = value + '%';
              });
            }
            
            if (inventorySlider) {
              inventorySlider.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                window.gameState.soloLevelingSystem.aiSettings.inventoryThreshold = value;
                document.getElementById('inventoryThresholdValue').textContent = value + '%';
              });
            }
            
            if (autoApproveSlider) {
              autoApproveSlider.addEventListener('input', (e) => {
                const value = parseInt(e.target.value);
                window.gameState.soloLevelingSystem.aiSettings.autoApproveBelow = value;
                document.getElementById('autoApproveValue').textContent = value + 'g';
              });
            }
            
            // SETTINGS TOGGLES
            const autoBuyToggle = document.getElementById('autoBuyPotionsToggle');
            const autoSellToggle = document.getElementById('autoSellToggle');
            const proactiveModeToggle = document.getElementById('proactiveModeToggle');
            
            if (autoBuyToggle) {
              autoBuyToggle.addEventListener('change', (e) => {
                window.gameState.soloLevelingSystem.aiSettings.autoBuyPotions = e.target.checked;
                this.addSystemMessage(`ğŸ’Š Auto-buy potions ${e.target.checked ? 'enabled' : 'disabled'}`, 'system');
              });
            }
            
            if (autoSellToggle) {
              autoSellToggle.addEventListener('change', (e) => {
                window.gameState.soloLevelingSystem.aiSettings.autoSell = e.target.checked;
                this.addSystemMessage(`ğŸ’° Auto-sell ${e.target.checked ? 'enabled' : 'disabled'}`, 'system');
              });
            }
            
            if (proactiveModeToggle) {
              proactiveModeToggle.addEventListener('change', (e) => {
                window.gameState.soloLevelingSystem.aiSettings.proactiveMode = e.target.checked;
                this.addSystemMessage(`ğŸ¯ Proactive mode ${e.target.checked ? 'enabled' : 'disabled'}`, 'system');
              });
            }
            
            // Command autocomplete on typing
            if (commandInput) {
              commandInput.addEventListener('input', (e) => {
                this.showCommandSuggestions(e.target.value);
              });
              
              // Focus input when tab opens
              commandInput.focus();
            }
          }, 100);
        },
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Game knowledge database - AI knows everything!
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        getGameKnowledge() {
          return {
            itemTypes: ['container', 'consumable', 'gear', 'weapon', 'armor', 'accessory'],
            rarities: ['common', 'uncommon', 'rare', 'epic', 'legendary'],
            robotTypes: ['combat_bot', 'support_drone', 'mech', 'infiltrator', 'ranged_specialist'],
            petElements: ['fire', 'ice', 'electric', 'earth', 'wind', 'arcane', 'dark', 'light'],
            vehicleCategories: ['ground', 'hover', 'air'],
            tabs: ['items', 'gear', 'team', 'pets', 'skins', 'talents', 'vehicles', 'ai', 'alchemy', 'skills', 'spirit', 'supernatural', 'quests', 'map', 'shop', 'settings'],
            stats: ['strength', 'agility', 'intelligence', 'vitality', 'sense'],
            currencies: ['gold', 'gems', 'keys', 'tickets', 'essence']
          };
        },
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Advanced analysis - AI can analyze and recommend
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        analyzeGameState() {
          const analysis = {
            issues: [],
            recommendations: [],
            opportunities: []
          };
          
          // Check resources
          if (window.gameState.gold < 1000) {
            analysis.issues.push('ğŸ’° Low on gold - Consider selling items or opening containers');
            analysis.recommendations.push('Run "auto sell" or "open all" commands');
          }
          
          // Check equipment
          const emptySlots = Object.entries(window.gameState.equipped).filter(([k, v]) => !v && k !== 'vehicle' && k !== 'pet' && k !== 'robot' && k !== 'spirit').length;
          if (emptySlots > 0) {
            analysis.issues.push(`âš”ï¸ ${emptySlots} empty equipment slots detected`);
            analysis.recommendations.push('Run "auto equip" to fill empty slots');
          }
          
          // Check inventory
          const containers = (window.gameState.inventory.items || []).filter(i => i.category === 'container').reduce((sum, i) => sum + (i.quantity || 0), 0);
          if (containers > 5) {
            analysis.opportunities.push(`ğŸ“¦ You have ${containers} containers - Open them for loot!`);
          }
          
          // Check level vs quest progress
          if (window.gameState.soloLevelingSystem) {
            const sl = window.gameState.soloLevelingSystem;
            const completedQuests = sl.dailyQuests.filter(q => q.completed).length;
            if (completedQuests < sl.dailyQuests.length) {
              analysis.opportunities.push(`ğŸ“œ ${sl.dailyQuests.length - completedQuests} daily quests still available`);
            }
            
            // Check if stat points are available
            if (sl.statPoints > 0) {
              analysis.issues.push(`â­ ${sl.statPoints} unspent stat points!`);
              analysis.recommendations.push('Allocate stat points to increase your power');
            }
          }
          
          // Check gear quality
          const gear = window.gameState.inventory.gear || [];
          const commonGear = gear.filter(g => g.rarity === 'common').length;
          if (commonGear > 5) {
            analysis.opportunities.push(`âš—ï¸ ${commonGear} common items - Consider fusing for upgrades`);
          }
          
          return analysis;
        },
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Natural language processing - AI understands you!
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        parseNaturalLanguage(input) {
          const lower = input.toLowerCase();
          
          // Intent detection
          if (lower.includes('how many') || lower.includes('count')) {
            if (lower.includes('robot')) return { intent: 'count', type: 'robots' };
            if (lower.includes('pet')) return { intent: 'count', type: 'pets' };
            if (lower.includes('item')) return { intent: 'count', type: 'items' };
            if (lower.includes('gold')) return { intent: 'show', type: 'gold' };
          }
          
          if (lower.includes('what') || lower.includes('show') || lower.includes('list')) {
            if (lower.includes('stats') || lower.includes('stat')) return { intent: 'stats', type: 'player' };
            if (lower.includes('quest')) return { intent: 'quests', type: 'daily' };
            if (lower.includes('inventory')) return { intent: 'inventory', type: 'all' };
          }
          
          if (lower.includes('optimize') || lower.includes('improve') || lower.includes('better')) {
            return { intent: 'optimize', type: 'all' };
          }
          
          if (lower.includes('analyze') || lower.includes('check') || lower.includes('recommend')) {
            return { intent: 'analyze', type: 'gamestate' };
          }
          
          if (lower.includes('find') || lower.includes('search') || lower.includes('where')) {
            if (lower.includes('best')) return { intent: 'find', type: 'best_gear' };
            return { intent: 'search', query: input };
          }
          
          return null;
        },
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // AI command processor - The super brain! ğŸ§ 
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        processAICommand(command) {
          const cmd = command.toLowerCase().trim();
          const args = cmd.split(' ');
          const mainCmd = args[0];
          
          // Add user command to messages
          this.addSystemMessage(`> ${command}`, 'command');
          
          // Try natural language processing first
          const nlpIntent = this.parseNaturalLanguage(command);
          if (nlpIntent) {
            this.handleNaturalLanguage(nlpIntent, command);
            return;
          }
          
          // Process command
          if (cmd === 'help' || cmd === 'commands') {
            this.showCommandHelp();
          }
          else if (cmd === 'auto equip' || cmd === 'autoequip') {
            this.addSystemMessage('âš”ï¸ Executing auto-equip...', 'system');
            this.autoEquip();
          }
          else if (cmd === 'auto upgrade' || cmd === 'autoupgrade') {
            this.addSystemMessage('â¬†ï¸ Executing auto-upgrade...', 'system');
            this.autoUpgrade();
          }
          else if (cmd === 'auto fuse' || cmd === 'autofuse') {
            this.addSystemMessage('âš—ï¸ Executing auto-fuse...', 'system');
            this.autoFuse();
          }
          else if (cmd === 'auto sell' || cmd === 'autosell') {
            this.addSystemMessage('ğŸ’° Executing auto-sell...', 'system');
            this.autoSell();
          }
          else if (cmd === 'open all' || cmd === 'openall') {
            this.addSystemMessage('ğŸ“¦ Opening all containers...', 'system');
            this.openAllContainers();
          }
          else if (cmd === 'alchemy') {
            this.addSystemMessage('âš—ï¸ Opening alchemy lab...', 'system');
            this.state.activeTab = 'alchemy';
            this.renderTabs();
            this.renderTab('alchemy');
            this.showToast('âš—ï¸ Alchemy Lab opened');
          }
          else if (cmd === 'stats') {
            const sl = window.gameState.soloLevelingSystem;
            this.addSystemMessage(`ğŸ“Š Player Stats - Lv.${sl.level} | STR: ${sl.stats.strength} | AGI: ${sl.stats.agility} | INT: ${sl.stats.intelligence} | VIT: ${sl.stats.vitality} | SENSE: ${sl.stats.sense}`, 'info');
          }
          else if (cmd === 'inventory' || cmd === 'inv') {
            const itemCount = (window.gameState.inventory.items || []).length;
            const gearCount = (window.gameState.inventory.gear || []).length;
            this.addSystemMessage(`ğŸ“¦ Inventory - Items: ${itemCount} | Gear: ${gearCount} | Gold: ${window.gameState.gold.toLocaleString()}`, 'info');
            this.state.activeTab = 'items';
            this.renderTabs();
            this.renderTab('items');
          }
          else if (cmd === 'quest info' || cmd === 'quests') {
            const sl = window.gameState.soloLevelingSystem;
            const completed = sl.dailyQuests.filter(q => q.completed).length;
            this.addSystemMessage(`ğŸ“œ Daily Quests: ${completed}/${sl.dailyQuests.length} completed`, 'info');
            this.state.activeTab = 'quests';
            this.renderTabs();
            this.renderTab('quests');
            this.showToast('ğŸ“œ Quests tab opened');
          }
          else if (cmd === 'daily reset') {
            this.resetDailyQuests();
          }
          else if (cmd.startsWith('gain exp ') || cmd.startsWith('add exp ')) {
            const amount = parseInt(args[2]) || 100;
            window.gameState.soloLevelingSystem.exp += amount;
            this.checkLevelUp();
            this.addSystemMessage(`âœ¨ Added ${amount} EXP`, 'reward');
            this.renderAITab();
          }
          else if (cmd.startsWith('add gold ') || cmd.startsWith('gain gold ')) {
            const amount = parseInt(args[2]) || 1000;
            window.gameState.gold += amount;
            this.syncAllSystems();
            this.addSystemMessage(`ğŸ’° Added ${amount} gold`, 'reward');
          }
          else if (cmd === 'level up' || cmd === 'levelup') {
            window.gameState.soloLevelingSystem.exp = window.gameState.soloLevelingSystem.expToNext;
            this.checkLevelUp();
            this.renderAITab();
          }
          else if (cmd === 'heal' || cmd === 'restore') {
            window.gameState.soloLevelingSystem.hp = window.gameState.soloLevelingSystem.maxHp;
            window.gameState.soloLevelingSystem.mp = window.gameState.soloLevelingSystem.maxMp;
            this.addSystemMessage('â¤ï¸ HP and MP fully restored', 'reward');
            this.renderAITab();
          }
          else if (cmd === 'save') {
            this.saveGameState();
            this.addSystemMessage('ğŸ’¾ Game saved successfully', 'system');
          }
          else if (cmd === 'clear') {
            window.gameState.soloLevelingSystem.messages = [
              { text: "Messages cleared.", time: Date.now(), type: "system" }
            ];
            this.renderAITab();
          }
          else if (cmd.startsWith('teleport ') || cmd.startsWith('tp ')) {
            const location = args.slice(1).join(' ');
            this.addSystemMessage(`ğŸŒ€ Teleporting to ${location}...`, 'system');
            this.showToast(`ğŸŒ€ Teleported to ${location}`);
          }
          else if (cmd.startsWith('buy ')) {
            const itemName = args.slice(1).join(' ');
            this.addSystemMessage(`ğŸª Searching shop for "${itemName}"...`, 'system');
            this.state.activeTab = 'shop';
            this.renderTabs();
            this.renderTab('shop');
          }
          else if (cmd.startsWith('summon ') || cmd.startsWith('pet ')) {
            const petName = args.slice(1).join(' ');
            this.addSystemMessage(`ğŸ¾ Attempting to summon "${petName}"...`, 'system');
            this.state.activeTab = 'pets';
            this.renderTabs();
            this.renderTab('pets');
          }
          else if (cmd.startsWith('deploy ')) {
            const robotName = args.slice(1).join(' ');
            this.addSystemMessage(`ğŸ¤– Deploying "${robotName}"...`, 'system');
            this.state.aiSubtab = 'robots';
            this.renderAITab();
          }
          else if (cmd === 'shop') {
            this.addSystemMessage('ğŸª Opening shop...', 'system');
            this.state.activeTab = 'shop';
            this.renderTabs();
            this.renderTab('shop');
          }
          else if (cmd === 'map') {
            this.addSystemMessage('ğŸ—ºï¸ Opening map...', 'system');
            this.state.activeTab = 'map';
            this.renderTabs();
            this.renderTab('map');
          }
          else if (cmd === 'gear') {
            this.addSystemMessage('âš”ï¸ Opening gear tab...', 'system');
            this.state.activeTab = 'gear';
            this.renderTabs();
            this.renderTab('gear');
          }
          else if (cmd.startsWith('follow ')) {
            const target = args[1];
            this.addSystemMessage(`ğŸ‘£ AI will now follow ${target}`, 'system');
            this.showToast(`ğŸ‘£ Following ${target}`);
          }
          else if (cmd === 'status' || cmd === 'info') {
            const sl = window.gameState.soloLevelingSystem;
            this.addSystemMessage(`ğŸ“Š Status - Level ${sl.level} | HP: ${sl.hp}/${sl.maxHp} | MP: ${sl.mp}/${sl.maxMp} | EXP: ${sl.exp}/${sl.expToNext} | Gold: ${window.gameState.gold.toLocaleString()}`, 'info');
          }
          else if (cmd === 'all auto' || cmd === 'auto all') {
            this.addSystemMessage('ğŸ¤– Running all auto functions...', 'system');
            this.autoEquip();
            setTimeout(() => this.autoUpgrade(), 500);
            setTimeout(() => this.autoFuse(), 1000);
            setTimeout(() => this.openAllContainers(), 1500);
          }
          else if (cmd === 'reset stats') {
            window.gameState.soloLevelingSystem.stats = {
              strength: 10, agility: 10, intelligence: 10, vitality: 10, sense: 10
            };
            window.gameState.soloLevelingSystem.statPoints = (window.gameState.soloLevelingSystem.level - 1) * 5;
            this.addSystemMessage('ğŸ”„ Stats reset. Stat points refunded.', 'system');
            this.renderAITab();
          }
          // NEW ADVANCED COMMANDS
          else if (cmd === 'analyze' || cmd === 'check game' || cmd === 'scan') {
            const analysis = this.analyzeGameState();
            this.addSystemMessage('ğŸ” Analyzing game state...', 'system');
            
            if (analysis.issues.length > 0) {
              this.addSystemMessage('âš ï¸ ISSUES DETECTED:', 'error');
              analysis.issues.forEach(issue => this.addSystemMessage(issue, 'info'));
            }
            if (analysis.recommendations.length > 0) {
              this.addSystemMessage('ğŸ’¡ RECOMMENDATIONS:', 'system');
              analysis.recommendations.forEach(rec => this.addSystemMessage(rec, 'info'));
            }
            if (analysis.opportunities.length > 0) {
              this.addSystemMessage('âœ¨ OPPORTUNITIES:', 'reward');
              analysis.opportunities.forEach(opp => this.addSystemMessage(opp, 'info'));
            }
            
            if (analysis.issues.length === 0 && analysis.opportunities.length === 0) {
              this.addSystemMessage('âœ… Everything looks good! No issues detected.', 'reward');
            }
          }
          else if (cmd === 'optimize' || cmd === 'auto optimize' || cmd === 'improve') {
            this.addSystemMessage('ğŸ¤– OPTIMIZATION MODE: Running all improvements...', 'system');
            this.autoEquip();
            setTimeout(() => {
              this.autoUpgrade();
              this.addSystemMessage('â¬†ï¸ Gear upgraded', 'system');
            }, 500);
            setTimeout(() => {
              this.autoFuse();
              this.addSystemMessage('âš—ï¸ Items fused', 'system');
            }, 1000);
            setTimeout(() => {
              this.openAllContainers();
              this.addSystemMessage('âœ… Optimization complete!', 'reward');
            }, 1500);
          }
          else if (cmd.startsWith('find ') || cmd.startsWith('search ')) {
            const query = args.slice(1).join(' ');
            this.addSystemMessage(`ğŸ” Searching for "${query}"...`, 'system');
            this.searchGame(query);
          }
          else if (cmd === 'best gear' || cmd === 'show best' || cmd === 'top items') {
            this.showBestGear();
          }
          else if (cmd.startsWith('equip best')) {
            this.addSystemMessage('âš”ï¸ Equipping best gear automatically...', 'system');
            this.autoEquip();
          }
          else if (cmd === 'wealth' || cmd === 'net worth' || cmd === 'total value') {
            this.calculateNetWorth();
          }
          else if (cmd.startsWith('explain ')) {
            const topic = args.slice(1).join(' ');
            this.explainFeature(topic);
          }
          else if (cmd === 'ai info' || cmd === 'system info') {
            const sl = window.gameState.soloLevelingSystem;
            this.addSystemMessage('â”â”â”â”â” A1K SYSTEM INFO â”â”â”â”â”', 'system');
            this.addSystemMessage('ğŸ§  Intelligence Level: ADVANCED', 'info');
            this.addSystemMessage('ğŸ“Š Knowledge Base: Complete', 'info');
            this.addSystemMessage('ğŸ”§ Capabilities: Full Game Control', 'info');
            this.addSystemMessage('ğŸ’¾ Memory: 50 messages', 'info');
            this.addSystemMessage('âš¡ Commands: 50+ available', 'info');
            this.addSystemMessage('ğŸ¯ NLP: Natural language enabled', 'info');
            this.addSystemMessage('ğŸ¤– Auto Systems: All functions', 'info');
            this.addSystemMessage(`ğŸ” Monitoring: ${sl.aiMonitoring ? 'ON' : 'OFF'}`, 'info');
            this.addSystemMessage(`âš¡ Auto Mode: ${sl.aiAutoMode ? 'ON' : 'OFF'}`, 'info');
            this.addSystemMessage(`ğŸ“‹ Pending Requests: ${sl.aiRequests.filter(r => r.status === 'pending').length}`, 'info');
            this.addSystemMessage('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'system');
          }
          // AI AUTONOMY COMMANDS
          else if (cmd === 'monitor start' || cmd === 'start monitoring') {
            this.startAIMonitoring();
          }
          else if (cmd === 'monitor stop' || cmd === 'stop monitoring') {
            this.stopAIMonitoring();
          }
          else if (cmd === 'auto on' || cmd === 'auto mode on') {
            window.gameState.soloLevelingSystem.aiAutoMode = true;
            this.addSystemMessage('âš¡ AUTO MODE ENABLED - AI will execute all actions automatically!', 'reward');
            this.renderAITab();
          }
          else if (cmd === 'auto off' || cmd === 'auto mode off') {
            window.gameState.soloLevelingSystem.aiAutoMode = false;
            this.addSystemMessage('ğŸ”’ AUTO MODE DISABLED - AI will ask before acting', 'info');
            this.renderAITab();
          }
          else if (cmd === 'test hp') {
            // Test health monitoring by reducing HP
            window.gameState.soloLevelingSystem.hp = 25;
            this.addSystemMessage('âš ï¸ HP reduced to 25% for testing', 'error');
            this.renderAITab();
            // Trigger monitoring check
            this.aiMonitorGameState();
          }
          else if (cmd === 'go' || cmd === 'suggest') {
            // AI suggests what to do next
            this.addSystemMessage('ğŸ—ºï¸ NAVIGATION SUGGESTIONS:', 'system');
            const sl = window.gameState.soloLevelingSystem;
            
            // Check what player should focus on
            const incompleteQuests = sl.dailyQuests.filter(q => !q.completed);
            if (incompleteQuests.length > 0) {
              this.addSystemMessage(`1. ğŸ“œ Complete ${incompleteQuests.length} daily quests`, 'info');
            }
            
            const emptySlots = Object.entries(window.gameState.equipped).filter(([k, v]) => !v && k !== 'vehicle' && k !== 'pet' && k !== 'robot' && k !== 'spirit').length;
            if (emptySlots > 0) {
              this.addSystemMessage(`2. âš”ï¸ Equip gear (${emptySlots} empty slots)`, 'info');
            }
            
            const containers = (window.gameState.inventory.items || []).filter(i => i.category === 'container').reduce((sum, i) => sum + (i.quantity || 0), 0);
            if (containers > 0) {
              this.addSystemMessage(`3. ğŸ“¦ Open ${containers} containers`, 'info');
            }
            
            this.addSystemMessage('4. ğŸ—ºï¸ Explore map mini-game', 'info');
            this.addSystemMessage('5. ğŸª Visit shop for upgrades', 'info');
            this.addSystemMessage('6. âš—ï¸ Use alchemy to fuse items', 'info');
            this.addSystemMessage('', 'info');
            this.addSystemMessage('ğŸ’¡ Type "optimize" to let AI handle everything!', 'reward');
          }
          else if (cmd === 'tutorial' || cmd === 'guide') {
            this.showTutorial();
          }
          else if (cmd === 'undo' || cmd === 'revert') {
            this.undoLastAction();
          }
          else if (cmd === 'test all' || cmd === 'qa' || cmd === 'run tests') {
            this.runQATests();
          }
          else if (cmd === 'browse shop' || cmd === 'shop browse' || cmd === 'scan shop') {
            this.browseShop();
          }
          else if (cmd === 'buy smart' || cmd === 'smart buy' || cmd === 'ai buy') {
            const budget = args[2] ? parseInt(args[2]) : 5000;
            this.buyBestFromShop(budget);
          }
          else if (cmd === 'where to' || cmd === 'where should i go' || cmd === 'suggest teleport') {
            this.suggestTeleport();
          }
          else if (cmd.startsWith('teleport ')) {
            const place = args.slice(1).join(' ');
            this.teleportTo(place);
          }
          else if (cmd === 'battle' || cmd === 'fight' || cmd === 'attack') {
            const enemyType = args[1] || 'monster';
            this.startBattleAI(enemyType);
          }
          else if (cmd.startsWith('battle ') || cmd.startsWith('fight ')) {
            const enemyType = args[1] || 'monster';
            const count = args[2] ? parseInt(args[2]) : 1;
            this.autoBattle(enemyType, count);
          }
          else if (cmd === 'farm' || cmd === 'grind') {
            this.addSystemMessage('ğŸ¤– FARMING MODE: Auto-battling 10 monsters...', 'system');
            this.autoBattle('monster', 10);
          }
          else if (cmd.startsWith('macro ') || cmd.startsWith('workflow ')) {
            const workflowName = args.slice(1).join(' ');
            this.addSystemMessage(`ğŸ”§ Creating workflow: "${workflowName}"`, 'system');
            this.addSystemMessage('ğŸ’¡ Workflow system allows multi-step automation', 'info');
            this.showToast('ğŸ”§ Workflow created!');
          }
          else {
            // AI tries to understand the command
            this.addSystemMessage(`â“ Unknown command "${command}". Type "help" to see available commands.`, 'error');
          }
          
          // Scroll messages to bottom
          setTimeout(() => {
            const msgContainer = document.getElementById('systemMessages');
            if (msgContainer) msgContainer.scrollTop = msgContainer.scrollHeight;
          }, 100);
        },
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Advanced AI helper functions
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        handleNaturalLanguage(intent, originalQuery) {
          if (intent.intent === 'count') {
            if (intent.type === 'robots') {
              const count = (window.gameState.inventory.robots || []).length;
              this.addSystemMessage(`ğŸ¤– You have ${count} robots in your arsenal`, 'info');
            } else if (intent.type === 'pets') {
              const count = (window.gameState.inventory.pets || []).length;
              this.addSystemMessage(`ğŸ¾ You have ${count} pets in your collection`, 'info');
            } else if (intent.type === 'items') {
              const count = (window.gameState.inventory.items || []).reduce((sum, i) => sum + (i.quantity || 1), 0);
              this.addSystemMessage(`ğŸ“¦ You have ${count} total items`, 'info');
            }
          } else if (intent.intent === 'stats') {
            const sl = window.gameState.soloLevelingSystem;
            this.addSystemMessage(`ğŸ“Š Player Stats - Lv.${sl.level} | STR: ${sl.stats.strength} | AGI: ${sl.stats.agility} | INT: ${sl.stats.intelligence} | VIT: ${sl.stats.vitality} | SENSE: ${sl.stats.sense}`, 'info');
          } else if (intent.intent === 'quests') {
            const sl = window.gameState.soloLevelingSystem;
            const completed = sl.dailyQuests.filter(q => q.completed).length;
            this.addSystemMessage(`ğŸ“œ Daily Quests: ${completed}/${sl.dailyQuests.length} completed`, 'info');
          } else if (intent.intent === 'analyze') {
            const analysis = this.analyzeGameState();
            this.addSystemMessage('ğŸ” Game analysis complete', 'system');
            if (analysis.issues.length > 0) {
              analysis.issues.forEach(i => this.addSystemMessage(i, 'info'));
            }
          } else if (intent.intent === 'optimize') {
            this.addSystemMessage('ğŸ¤– Starting optimization...', 'system');
            this.autoEquip();
          } else if (intent.intent === 'search') {
            this.searchGame(intent.query);
          } else if (intent.intent === 'find' && intent.type === 'best_gear') {
            this.showBestGear();
          }
        },
        
        searchGame(query) {
          const lower = query.toLowerCase();
          let results = [];
          
          // Search items
          const items = window.gameState.inventory.items || [];
          results = results.concat(items.filter(i => i.name.toLowerCase().includes(lower)).map(i => `ğŸ“¦ ${i.name} (x${i.quantity})`));
          
          // Search gear
          const gear = window.gameState.inventory.gear || [];
          results = results.concat(gear.filter(g => g.name.toLowerCase().includes(lower)).map(g => `âš”ï¸ ${g.name} (${g.rarity})`));
          
          // Search pets
          const pets = window.gameState.inventory.pets || [];
          results = results.concat(pets.filter(p => p.name.toLowerCase().includes(lower)).map(p => `ğŸ¾ ${p.name}`));
          
          // Search robots
          const robots = window.gameState.inventory.robots || [];
          results = results.concat(robots.filter(r => r.name.toLowerCase().includes(lower)).map(r => `ğŸ¤– ${r.name}`));
          
          if (results.length > 0) {
            this.addSystemMessage(`ğŸ” Found ${results.length} matches:`, 'system');
            results.slice(0, 10).forEach(r => this.addSystemMessage(r, 'info'));
            if (results.length > 10) {
              this.addSystemMessage(`... and ${results.length - 10} more`, 'info');
            }
          } else {
            this.addSystemMessage(`âŒ No results found for "${query}"`, 'error');
          }
        },
        
        showBestGear() {
          const gear = window.gameState.inventory.gear || [];
          if (gear.length === 0) {
            this.addSystemMessage('âŒ No gear in inventory', 'error');
            return;
          }
          
          const sorted = [...gear].sort((a, b) => {
            const powerA = (a.attack || 0) + (a.defense || 0) + (a.hp || 0) * 0.1;
            const powerB = (b.attack || 0) + (b.defense || 0) + (b.hp || 0) * 0.1;
            return powerB - powerA;
          });
          
          this.addSystemMessage('ğŸ† TOP 5 BEST GEAR:', 'system');
          sorted.slice(0, 5).forEach((item, i) => {
            const power = (item.attack || 0) + (item.defense || 0) + (item.hp || 0) * 0.1;
            this.addSystemMessage(`${i + 1}. ${item.icon} ${item.name} - Power: ${power.toFixed(0)} (${item.rarity})`, 'info');
          });
        },
        
        calculateNetWorth() {
          const gold = window.gameState.gold;
          const gems = window.gameState.gems * 100; // Gems worth 100g each
          const items = (window.gameState.inventory.items || []).reduce((sum, i) => sum + (i.cost || 50) * (i.quantity || 1), 0);
          const gear = (window.gameState.inventory.gear || []).reduce((sum, g) => sum + (g.cost || 100), 0);
          const pets = (window.gameState.inventory.pets || []).reduce((sum, p) => sum + (p.cost || 500), 0);
          const robots = (window.gameState.inventory.robots || []).reduce((sum, r) => sum + (r.cost || 1000), 0);
          const vehicles = (window.gameState.inventory.vehicles || []).reduce((sum, v) => sum + (v.cost || 800), 0);
          
          const total = gold + gems + items + gear + pets + robots + vehicles;
          
          this.addSystemMessage('ğŸ’ NET WORTH CALCULATION:', 'system');
          this.addSystemMessage(`ğŸ’° Gold: ${gold.toLocaleString()}`, 'info');
          this.addSystemMessage(`ğŸ’ Gems value: ${gems.toLocaleString()}`, 'info');
          this.addSystemMessage(`ğŸ“¦ Items value: ${items.toLocaleString()}`, 'info');
          this.addSystemMessage(`âš”ï¸ Gear value: ${gear.toLocaleString()}`, 'info');
          this.addSystemMessage(`ğŸ¾ Pets value: ${pets.toLocaleString()}`, 'info');
          this.addSystemMessage(`ğŸ¤– Robots value: ${robots.toLocaleString()}`, 'info');
          this.addSystemMessage(`ğŸš— Vehicles value: ${vehicles.toLocaleString()}`, 'info');
          this.addSystemMessage(`â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”`, 'system');
          this.addSystemMessage(`ğŸ† TOTAL NET WORTH: ${total.toLocaleString()} gold`, 'reward');
        },
        
        explainFeature(topic) {
          const explanations = {
            'alchemy': 'âš—ï¸ Alchemy allows you to combine 3 items to create better ones. Put items in slots and craft!',
            'talents': 'â­ Talents are permanent upgrades across 13 skill trees. Unlock powerful abilities!',
            'pets': 'ğŸ¾ Pets are companions that fight alongside you. Summon one to boost your combat power!',
            'robots': 'ğŸ¬ AI Robots are deployable combat units. Each has unique abilities and modes!',
            'spirits': 'âœ¨ Spirits provide passive bonuses. Bond with one to gain special effects!',
            'vehicles': 'ğŸš— Vehicles increase movement speed. Board one to travel faster!',
            'stats': 'ğŸ“Š Stats affect your power: STR (attack), AGI (speed), INT (magic), VIT (HP), SENSE (perception)',
            'quests': 'ğŸ“œ Complete daily quests for EXP and gold. Reset daily at midnight!',
            'shop': 'ğŸª Buy items, gear, and upgrades with gold or gems. Prices vary by rarity!',
            'map': 'ğŸ—ºï¸ The map shows discovered locations and has a playable mini-game!',
            'skills': 'ğŸ”° Skills are combat abilities. Each character has unique skill sets!',
            'skins': 'ğŸ‘¤ Skins customize character appearance. Unlock new looks for your heroes!'
          };
          
          const explanation = explanations[topic.toLowerCase()] || `â“ No explanation available for "${topic}". Try: alchemy, talents, pets, robots, spirits, stats, quests`;
          this.addSystemMessage(explanation, 'system');
        },
        
        showTutorial() {
          this.addSystemMessage('â”â”â”â”â” A1K SYSTEM TUTORIAL â”â”â”â”â”', 'system');
          this.addSystemMessage('ğŸ‘‹ Welcome! I\'m your intelligent game assistant', 'info');
          this.addSystemMessage('', 'info');
          this.addSystemMessage('ğŸ¯ BASIC USAGE:', 'system');
          this.addSystemMessage('â€¢ Type commands in the terminal below', 'info');
          this.addSystemMessage('â€¢ Press Enter or click Send to execute', 'info');
          this.addSystemMessage('â€¢ Type "help" to see all commands', 'info');
          this.addSystemMessage('', 'info');
          this.addSystemMessage('ğŸ¤– AI FEATURES:', 'system');
          this.addSystemMessage('â€¢ Natural language - Ask questions naturally', 'info');
          this.addSystemMessage('â€¢ Smart analysis - I can detect issues', 'info');
          this.addSystemMessage('â€¢ Auto optimization - Let me manage everything', 'info');
          this.addSystemMessage('â€¢ Game knowledge - I know all items/features', 'info');
          this.addSystemMessage('', 'info');
          this.addSystemMessage('ğŸ’¡ TRY THESE:', 'reward');
          this.addSystemMessage('â€¢ "analyze" - Check your game state', 'info');
          this.addSystemMessage('â€¢ "optimize" - Auto-improve everything', 'info');
          this.addSystemMessage('â€¢ "best gear" - See your top items', 'info');
          this.addSystemMessage('â€¢ "wealth" - Calculate net worth', 'info');
          this.addSystemMessage('â€¢ "explain alchemy" - Learn features', 'info');
          this.addSystemMessage('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'system');
        },
        
        showCommandHelp() {
          const commands = [
            'â”â”â”â”â” BASIC COMMANDS â”â”â”â”â”',
            'âš”ï¸ auto equip - Equip your best gear automatically',
            'â¬†ï¸ auto upgrade - Upgrade all gear',
            'âš—ï¸ auto fuse - Fuse duplicate items',
            'ğŸ’° auto sell - Sell junk items',
            'ğŸ“¦ open all - Open all containers',
            'ğŸ¤– all auto - Run all automation',
            '',
            'â”â”â”â”â” NAVIGATION â”â”â”â”â”',
            'ğŸ§ª alchemy - Open alchemy tab',
            'ğŸ’ inventory - Open inventory',
            'ğŸª shop - Open shop',
            'ğŸ—ºï¸ map - Open map',
            'âš”ï¸ gear - Open gear tab',
            '',
            'â”â”â”â”â” INFORMATION â”â”â”â”â”',
            'ğŸ“Š stats - Show detailed player stats',
            'ğŸ¯ status - Show complete status',
            'ğŸ“œ quest info - Quest status',
            'ğŸ’ wealth - Calculate net worth',
            'ğŸ† best gear - Show top 5 items',
            '',
            'â”â”â”â”â” ADVANCED AI â”â”â”â”â”',
            'ğŸ” analyze - Analyze game & find issues',
            'âš¡ optimize - AI optimization mode',
            'ğŸ” find [item] - Search for items',
            'ğŸ“– explain [topic] - Explain features',
            'ğŸ§  ai info - Show AI capabilities',
            'ğŸ“š tutorial - Show tutorial guide',
            '',
            'â”â”â”â”â” ACTIONS â”â”â”â”â”',
            'ğŸª buy [item] - Buy from shop',
            'ğŸ¾ summon [pet] - Summon pet',
            'ğŸ¤– deploy [robot] - Deploy robot',
            'ğŸŒ€ teleport [place] - Teleport',
            'ğŸ‘£ follow [target] - AI follow mode',
            '',
            'â”â”â”â”â” TESTING/CHEATS â”â”â”â”â”',
            'âœ¨ gain exp [amount] - Add experience',
            'ğŸ’° add gold [amount] - Add gold',
            'ğŸ†™ level up - Instant level up',
            'â¤ï¸ heal - Restore HP and MP',
            'ğŸ”„ daily reset - Reset daily quests',
            'ğŸ”„ reset stats - Refund stat points',
            '',
            'â”â”â”â”â” SYSTEM â”â”â”â”â”',
            'ğŸ’¾ save - Save game state',
            'ğŸ—‘ï¸ clear - Clear message history',
            'â“ help - Show this help menu',
            '',
            'ğŸ’¡ TIP: You can also ask questions naturally!',
            'Examples: "how many robots do I have?"',
            '         "analyze my game"',
            '         "find sword"',
            '         "explain alchemy"'
          ];
          
          commands.forEach(cmd => {
            this.addSystemMessage(cmd, cmd.includes('â”') ? 'system' : 'info');
          });
        },
        
        showCommandSuggestions(input) {
          if (!input) {
            document.getElementById('commandSuggestions').style.display = 'none';
            return;
          }
          
          const suggestions = [
            // Basic
            'auto equip', 'auto upgrade', 'auto fuse', 'auto sell', 'open all', 'all auto',
            // Navigation
            'alchemy', 'stats', 'inventory', 'shop', 'map', 'gear',
            // Advanced AI
            'analyze', 'optimize', 'find sword', 'best gear', 'wealth', 'explain alchemy',
            'ai info', 'tutorial', 'search robot',
            // Actions
            'save', 'heal', 'level up', 'daily reset', 'help', 'status',
            // Testing
            'gain exp 100', 'add gold 1000', 'teleport city', 'follow player',
            'buy potion', 'summon pet', 'deploy robot', 'clear', 'reset stats',
            // Natural language
            'how many robots', 'how many pets', 'what are my stats', 'check game'
          ];
          
          const matches = suggestions.filter(s => s.startsWith(input.toLowerCase()));
          
          const suggestDiv = document.getElementById('commandSuggestions');
          if (matches.length > 0 && suggestDiv) {
            suggestDiv.style.display = 'block';
            suggestDiv.innerHTML = `ğŸ’¡ Did you mean: <strong>${matches.slice(0, 3).join('</strong>, <strong>')}</strong>?`;
          } else {
            suggestDiv.style.display = 'none';
          }
        },
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // AI AUTONOMY SYSTEM - REQUEST MANAGEMENT & DECISION ENGINE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        createAIRequest(type, reason, action, data = {}, priority = 'medium') {
          const sl = window.gameState.soloLevelingSystem;
          if (!sl) return null;
          
          const request = {
            id: `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            type,
            reason,
            action,
            data,
            priority, // 'low', 'medium', 'high', 'critical'
            status: 'pending',
            timestamp: Date.now()
          };
          
          sl.aiRequests.push(request);
          this.addSystemMessage(`ğŸ¤– AI REQUEST: ${reason}`, 'info');
          this.renderAITab();
          
          // Auto-approve if settings allow
          if (sl.aiAutoMode || (data.cost && data.cost <= sl.aiSettings.autoApproveBelow)) {
            this.approveAIRequest(request.id);
          }
          
          return request.id;
        },
        
        approveAIRequest(requestId) {
          const sl = window.gameState.soloLevelingSystem;
          if (!sl) return;
          
          const request = sl.aiRequests.find(r => r.id === requestId);
          if (!request || request.status !== 'pending') return;
          
          request.status = 'approved';
          
          // Execute the action
          try {
            if (typeof request.action === 'function') {
              request.action();
            } else if (typeof request.action === 'string') {
              this.processAICommand(request.action);
            }
            
            request.status = 'executed';
            this.addSystemMessage(`âœ… AI EXECUTED: ${request.reason}`, 'reward');
            
            // Log action
            sl.aiActions.push({
              ...request,
              executedAt: Date.now()
            });
            
            // Keep only last 50 actions
            if (sl.aiActions.length > 50) {
              sl.aiActions = sl.aiActions.slice(-50);
            }
            
          } catch (error) {
            request.status = 'failed';
            this.addSystemMessage(`âŒ AI FAILED: ${error.message}`, 'error');
          }
          
          this.renderAITab();
        },
        
        denyAIRequest(requestId) {
          const sl = window.gameState.soloLevelingSystem;
          if (!sl) return;
          
          const request = sl.aiRequests.find(r => r.id === requestId);
          if (!request) return;
          
          request.status = 'denied';
          this.addSystemMessage(`âŒ AI REQUEST DENIED: ${request.reason}`, 'info');
          
          // Remove from queue after 5 seconds
          setTimeout(() => {
            sl.aiRequests = sl.aiRequests.filter(r => r.id !== requestId);
            this.renderAITab();
          }, 5000);
          
          this.renderAITab();
        },
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // AI DECISION ENGINE - THE BRAIN!
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        startAIMonitoring() {
          const sl = window.gameState.soloLevelingSystem;
          if (!sl) return;
          
          sl.aiMonitoring = true;
          this.addSystemMessage('ğŸ¤– AI Monitoring STARTED', 'system');
          
          // Clear any existing interval
          if (this.aiMonitorInterval) {
            clearInterval(this.aiMonitorInterval);
          }
          
          // Check every 10 seconds
          this.aiMonitorInterval = setInterval(() => {
            this.aiMonitorGameState();
          }, 10000);
          
          // Run immediately
          this.aiMonitorGameState();
        },
        
        stopAIMonitoring() {
          const sl = window.gameState.soloLevelingSystem;
          if (!sl) return;
          
          sl.aiMonitoring = false;
          this.addSystemMessage('ğŸ¤– AI Monitoring STOPPED', 'system');
          
          if (this.aiMonitorInterval) {
            clearInterval(this.aiMonitorInterval);
            this.aiMonitorInterval = null;
          }
        },
        
        aiMonitorGameState() {
          const sl = window.gameState.soloLevelingSystem;
          if (!sl || !sl.aiMonitoring) return;
          
          // 1. HEALTH MONITORING
          const hpPercent = (sl.hp / sl.maxHp) * 100;
          if (hpPercent < sl.aiSettings.healthThreshold && sl.aiSettings.autoBuyPotions) {
            this.aiSuggestBuyPotion('health');
          }
          
          // 2. MANA MONITORING
          const mpPercent = (sl.mp / sl.maxMp) * 100;
          if (mpPercent < sl.aiSettings.mpThreshold && sl.aiSettings.autoBuyPotions) {
            this.aiSuggestBuyPotion('mana');
          }
          
          // 3. INVENTORY MONITORING
          const itemCount = (window.gameState.inventory.items || []).reduce((sum, i) => sum + (i.quantity || 1), 0);
          const maxItems = 100; // Assume max 100 items
          const inventoryPercent = (itemCount / maxItems) * 100;
          if (inventoryPercent > sl.aiSettings.inventoryThreshold) {
            this.aiSuggestSellJunk();
          }
          
          // 4. EMPTY EQUIPMENT SLOTS
          const emptySlots = Object.entries(window.gameState.equipped).filter(([k, v]) => !v && k !== 'vehicle' && k !== 'pet' && k !== 'robot' && k !== 'spirit').length;
          if (emptySlots > 0) {
            this.aiSuggestAutoEquip();
          }
          
          // 5. QUEST MONITORING
          if (sl.aiSettings.proactiveMode) {
            const incompleteQuests = sl.dailyQuests.filter(q => !q.completed);
            if (incompleteQuests.length > 0) {
              this.aiSuggestQuestFocus();
            }
          }
        },
        
        aiSuggestBuyPotion(type) {
          const sl = window.gameState.soloLevelingSystem;
          const cost = 50;
          
          if (window.gameState.gold < cost) {
            this.addSystemMessage(`âš ï¸ AI: Need ${cost} gold for ${type} potion, but only have ${window.gameState.gold}!`, 'error');
            return;
          }
          
          // Check if we already have a pending request for this
          const existingRequest = sl.aiRequests.find(r => r.type === 'buy_potion' && r.data.potionType === type && r.status === 'pending');
          if (existingRequest) return;
          
          this.createAIRequest(
            'buy_potion',
            `ğŸ”´ CRITICAL: ${type.toUpperCase()} at ${type === 'health' ? Math.round((sl.hp/sl.maxHp)*100) : Math.round((sl.mp/sl.maxMp)*100)}%! Buy ${type} potion?`,
            () => {
              if (window.gameState.gold >= cost) {
                window.gameState.gold -= cost;
                const item = window.gameState.inventory.items.find(i => i.name === `${type === 'health' ? 'Health' : 'Mana'} Potion`);
                if (item) {
                  item.quantity = (item.quantity || 0) + 1;
                } else {
                  window.gameState.inventory.items.push({
                    name: `${type === 'health' ? 'Health' : 'Mana'} Potion`,
                    icon: type === 'health' ? 'ğŸ§ª' : 'ğŸ’™',
                    category: 'consumable',
                    quantity: 1,
                    cost: cost
                  });
                }
                this.showToast(`ğŸ’Š Bought ${type === 'health' ? 'Health' : 'Mana'} Potion`);
                this.render();
              }
            },
            { cost, potionType: type },
            'critical'
          );
        },
        
        aiSuggestSellJunk() {
          const existingRequest = window.gameState.soloLevelingSystem.aiRequests.find(r => r.type === 'sell_junk' && r.status === 'pending');
          if (existingRequest) return;
          
          this.createAIRequest(
            'sell_junk',
            'ğŸŸ¡ Inventory getting full - Sell common items?',
            'auto sell',
            {},
            'medium'
          );
        },
        
        aiSuggestAutoEquip() {
          const existingRequest = window.gameState.soloLevelingSystem.aiRequests.find(r => r.type === 'auto_equip' && r.status === 'pending');
          if (existingRequest) return;
          
          this.createAIRequest(
            'auto_equip',
            'âš”ï¸ Empty equipment slots detected - Auto-equip best gear?',
            'auto equip',
            {},
            'medium'
          );
        },
        
        aiSuggestQuestFocus() {
          const sl = window.gameState.soloLevelingSystem;
          const incompleteQuests = sl.dailyQuests.filter(q => !q.completed);
          if (incompleteQuests.length === 0) return;
          
          const existingRequest = sl.aiRequests.find(r => r.type === 'quest_reminder' && r.status === 'pending');
          if (existingRequest) return;
          
          this.createAIRequest(
            'quest_reminder',
            `ğŸ“œ ${incompleteQuests.length} daily quests remaining - Focus on quests?`,
            'quest info',
            {},
            'low'
          );
        },
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // QA TEST SUITE - Automated Testing
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        runQATests() {
          this.addSystemMessage('ğŸ” STARTING QA TEST SUITE...', 'system');
          this.addSystemMessage('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'system');
          
          const results = {
            total: 0,
            passed: 0,
            failed: 0,
            warnings: 0
          };
          
          // Test 1: Game State Validation
          this.addSystemMessage('Test 1: Game State Validation', 'info');
          if (window.gameState && window.gameState.gold !== undefined) {
            results.passed++;
            this.addSystemMessage('âœ… Game state valid', 'reward');
          } else {
            results.failed++;
            this.addSystemMessage('âŒ Game state invalid', 'error');
          }
          results.total++;
          
          // Test 2: AI System Initialization
          this.addSystemMessage('Test 2: AI System Initialization', 'info');
          const sl = window.gameState.soloLevelingSystem;
          if (sl && sl.aiSettings && sl.aiRequests !== undefined) {
            results.passed++;
            this.addSystemMessage('âœ… AI system initialized', 'reward');
          } else {
            results.failed++;
            this.addSystemMessage('âŒ AI system not initialized', 'error');
          }
          results.total++;
          
          // Test 3: Inventory System
          this.addSystemMessage('Test 3: Inventory System', 'info');
          if (window.gameState.inventory && Array.isArray(window.gameState.inventory.items)) {
            results.passed++;
            this.addSystemMessage(`âœ… Inventory valid (${window.gameState.inventory.items.length} items)`, 'reward');
          } else {
            results.failed++;
            this.addSystemMessage('âŒ Inventory system broken', 'error');
          }
          results.total++;
          
          // Test 4: Equipment Slots
          this.addSystemMessage('Test 4: Equipment System', 'info');
          if (window.gameState.equipped) {
            const emptySlots = Object.entries(window.gameState.equipped).filter(([k, v]) => !v).length;
            results.passed++;
            this.addSystemMessage(`âœ… Equipment system working (${emptySlots} empty slots)`, 'reward');
          } else {
            results.failed++;
            this.addSystemMessage('âŒ Equipment system broken', 'error');
          }
          results.total++;
          
          // Test 5: Currency System
          this.addSystemMessage('Test 5: Currency System', 'info');
          if (typeof window.gameState.gold === 'number' && typeof window.gameState.gems === 'number') {
            results.passed++;
            this.addSystemMessage(`âœ… Currency valid (${window.gameState.gold}g, ${window.gameState.gems} gems)`, 'reward');
          } else {
            results.failed++;
            this.addSystemMessage('âŒ Currency system broken', 'error');
          }
          results.total++;
          
          // Test 6: AI Monitoring
          this.addSystemMessage('Test 6: AI Monitoring System', 'info');
          if (typeof this.startAIMonitoring === 'function' && typeof this.aiMonitorGameState === 'function') {
            results.passed++;
            this.addSystemMessage('âœ… Monitoring functions available', 'reward');
          } else {
            results.failed++;
            this.addSystemMessage('âŒ Monitoring functions missing', 'error');
          }
          results.total++;
          
          // Test 7: Command System
          this.addSystemMessage('Test 7: Command Processing', 'info');
          if (typeof this.processAICommand === 'function') {
            results.passed++;
            this.addSystemMessage('âœ… Command processor working', 'reward');
          } else {
            results.failed++;
            this.addSystemMessage('âŒ Command processor broken', 'error');
          }
          results.total++;
          
          // Test 8: Request System
          this.addSystemMessage('Test 8: Request/Approval System', 'info');
          if (typeof this.createAIRequest === 'function' && typeof this.approveAIRequest === 'function') {
            results.passed++;
            this.addSystemMessage('âœ… Request system operational', 'reward');
          } else {
            results.failed++;
            this.addSystemMessage('âŒ Request system broken', 'error');
          }
          results.total++;
          
          // Test 9: Settings System
          this.addSystemMessage('Test 9: Settings Configuration', 'info');
          if (sl.aiSettings && typeof sl.aiSettings.healthThreshold === 'number') {
            results.passed++;
            this.addSystemMessage('âœ… Settings system configured', 'reward');
          } else {
            results.failed++;
            this.addSystemMessage('âŒ Settings system broken', 'error');
          }
          results.total++;
          
          // Test 10: Action Log
          this.addSystemMessage('Test 10: Action Logging', 'info');
          if (Array.isArray(sl.aiActions)) {
            results.passed++;
            this.addSystemMessage(`âœ… Action log working (${sl.aiActions.length} logged)`, 'reward');
          } else {
            results.failed++;
            this.addSystemMessage('âŒ Action log broken', 'error');
          }
          results.total++;
          
          // Performance Test
          this.addSystemMessage('Test 11: Performance Check', 'info');
          const startTime = Date.now();
          for (let i = 0; i < 1000; i++) {
            const temp = window.gameState.gold * 2;
          }
          const endTime = Date.now();
          const duration = endTime - startTime;
          
          if (duration < 50) {
            results.passed++;
            this.addSystemMessage(`âœ… Performance good (${duration}ms)`, 'reward');
          } else {
            results.warnings++;
            this.addSystemMessage(`âš ï¸ Performance slow (${duration}ms)`, 'error');
          }
          results.total++;
          
          // Memory Check
          this.addSystemMessage('Test 12: Memory Usage', 'info');
          const messageCount = sl.messages.length;
          const actionCount = sl.aiActions.length;
          if (messageCount < 100 && actionCount < 100) {
            results.passed++;
            this.addSystemMessage('âœ… Memory usage normal', 'reward');
          } else {
            results.warnings++;
            this.addSystemMessage(`âš ï¸ High memory (${messageCount} msgs, ${actionCount} actions)`, 'error');
          }
          results.total++;
          
          // Final Report
          this.addSystemMessage('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'system');
          this.addSystemMessage('ğŸ“Š QA TEST RESULTS:', 'system');
          this.addSystemMessage(`âœ… Passed: ${results.passed}/${results.total}`, 'reward');
          if (results.failed > 0) {
            this.addSystemMessage(`âŒ Failed: ${results.failed}/${results.total}`, 'error');
          }
          if (results.warnings > 0) {
            this.addSystemMessage(`âš ï¸ Warnings: ${results.warnings}`, 'info');
          }
          
          const passRate = Math.round((results.passed / results.total) * 100);
          if (passRate === 100) {
            this.addSystemMessage('ğŸ‰ ALL TESTS PASSED!', 'reward');
          } else if (passRate >= 80) {
            this.addSystemMessage('âœ… TESTS MOSTLY PASSING', 'reward');
          } else {
            this.addSystemMessage('âš ï¸ MULTIPLE FAILURES DETECTED', 'error');
          }
          
          this.addSystemMessage('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”', 'system');
        },
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SHOP BROWSER - AI scans shop and suggests purchases
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        browseShop() {
          this.addSystemMessage('ğŸª BROWSING SHOP...', 'system');
          
          // Simulated shop inventory (in real game, this would come from shop data)
          const shopItems = [
            { name: 'Dragon Sword', icon: 'âš”ï¸', type: 'weapon', slot: 'weapon', attack: 120, cost: 2500, rarity: 'legendary' },
            { name: 'Titan Shield', icon: 'ğŸ›¡ï¸', type: 'armor', slot: 'offhand', defense: 80, hp: 150, cost: 2000, rarity: 'epic' },
            { name: 'Mage Staff', icon: 'ğŸª„', type: 'weapon', slot: 'weapon', attack: 90, cost: 1800, rarity: 'epic' },
            { name: 'Dragon Helm', icon: 'ğŸ‘‘', type: 'armor', slot: 'head', defense: 50, hp: 100, cost: 1500, rarity: 'epic' },
            { name: 'Phoenix Armor', icon: 'ğŸ”¥', type: 'armor', slot: 'chest', defense: 100, hp: 200, cost: 3000, rarity: 'legendary' },
            { name: 'Health Potion', icon: 'ğŸ§ª', type: 'consumable', cost: 50, rarity: 'common' },
            { name: 'Mana Potion', icon: 'ğŸ’™', type: 'consumable', cost: 50, rarity: 'common' },
            { name: 'Power Ring', icon: 'ğŸ’', type: 'accessory', slot: 'ring1', attack: 25, cost: 800, rarity: 'rare' },
            { name: 'Mystic Amulet', icon: 'ğŸ“¿', type: 'accessory', slot: 'necklace', defense: 30, hp: 80, cost: 1200, rarity: 'rare' }
          ];
          
          const equipped = window.gameState.equipped;
          const currentGold = window.gameState.gold;
          const recommendations = [];
          
          // Analyze each shop item
          shopItems.forEach(shopItem => {
            if (shopItem.type === 'consumable') return; // Skip consumables for now
            
            const slot = shopItem.slot;
            const currentItem = equipped[slot];
            
            // Calculate power
            const shopPower = (shopItem.attack || 0) + (shopItem.defense || 0) + (shopItem.hp || 0) * 0.1;
            const currentPower = currentItem ? ((currentItem.attack || 0) + (currentItem.defense || 0) + (currentItem.hp || 0) * 0.1) : 0;
            
            // Check if affordable and better
            if (shopItem.cost <= currentGold && shopPower > currentPower) {
              const improvement = Math.round(((shopPower - currentPower) / Math.max(currentPower, 1)) * 100);
              recommendations.push({
                item: shopItem,
                improvement,
                slot,
                currentItem: currentItem ? currentItem.name : 'Empty'
              });
            }
          });
          
          // Sort by improvement percentage
          recommendations.sort((a, b) => b.improvement - a.improvement);
          
          if (recommendations.length === 0) {
            this.addSystemMessage('âœ… No better items in shop than what you have!', 'reward');
            return;
          }
          
          this.addSystemMessage('ğŸ† SHOP RECOMMENDATIONS:', 'system');
          recommendations.slice(0, 5).forEach((rec, i) => {
            this.addSystemMessage(
              `${i + 1}. ${rec.item.icon} ${rec.item.name} - ${rec.item.cost}g (+${rec.improvement}% power) [${rec.slot.toUpperCase()}]`,
              'info'
            );
          });
          
          if (recommendations.length > 5) {
            this.addSystemMessage(`... and ${recommendations.length - 5} more upgrades available`, 'info');
          }
          
          this.addSystemMessage('', 'info');
          this.addSystemMessage('ğŸ’¡ Type "buy smart" to let AI purchase best items!', 'reward');
        },
        
        buyBestFromShop(maxSpend = 5000) {
          this.addSystemMessage(`ğŸª AI SMART SHOPPING (Budget: ${maxSpend}g)...`, 'system');
          
          // Same shop data
          const shopItems = [
            { name: 'Dragon Sword', icon: 'âš”ï¸', type: 'weapon', slot: 'weapon', attack: 120, cost: 2500, rarity: 'legendary', level: 1 },
            { name: 'Titan Shield', icon: 'ğŸ›¡ï¸', type: 'armor', slot: 'offhand', defense: 80, hp: 150, cost: 2000, rarity: 'epic', level: 1 },
            { name: 'Dragon Helm', icon: 'ğŸ‘‘', type: 'armor', slot: 'head', defense: 50, hp: 100, cost: 1500, rarity: 'epic', level: 1 },
            { name: 'Phoenix Armor', icon: 'ğŸ”¥', type: 'armor', slot: 'chest', defense: 100, hp: 200, cost: 3000, rarity: 'legendary', level: 1 },
            { name: 'Power Ring', icon: 'ğŸ’', type: 'accessory', slot: 'ring1', attack: 25, cost: 800, rarity: 'rare', level: 1 }
          ];
          
          const equipped = window.gameState.equipped;
          let totalSpent = 0;
          let purchasedItems = [];
          
          // Find best value items
          shopItems.forEach(shopItem => {
            const slot = shopItem.slot;
            const currentItem = equipped[slot];
            
            const shopPower = (shopItem.attack || 0) + (shopItem.defense || 0) + (shopItem.hp || 0) * 0.1;
            const currentPower = currentItem ? ((currentItem.attack || 0) + (currentItem.defense || 0) + (currentItem.hp || 0) * 0.1) : 0;
            
            // Buy if affordable, better, and within budget
            if (shopItem.cost <= window.gameState.gold && 
                shopPower > currentPower && 
                totalSpent + shopItem.cost <= maxSpend) {
              
              // Purchase!
              window.gameState.gold -= shopItem.cost;
              totalSpent += shopItem.cost;
              
              // Equip immediately
              if (currentItem) {
                this.normalizeGearItem(currentItem);
                window.gameState.inventory.gear.push(currentItem);
              }
              const purchasedItem = { ...shopItem, id: 'shop_' + Date.now() + '_' + Math.random() };
              this.normalizeGearItem(purchasedItem);
              equipped[slot] = purchasedItem;
              
              purchasedItems.push(`${shopItem.icon} ${shopItem.name} (${shopItem.cost}g)`);
            }
          });
          
          if (purchasedItems.length > 0) {
            this.showToast(`ğŸª Purchased ${purchasedItems.length} items for ${totalSpent}g!`);
            this.addSystemMessage(`ğŸª PURCHASED & EQUIPPED: ${purchasedItems.join(', ')}`, 'reward');
            this.syncAllSystems();
            this.render();
          } else {
            this.addSystemMessage('âŒ No affordable upgrades in shop', 'error');
          }
        },
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SMART TELEPORT - AI suggests optimal locations
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        getLocationDatabase() {
          return {
            city: { name: 'City', icon: 'ğŸ™ï¸', activities: ['Shop', 'Bank', 'Guild'], quests: ['Hunt Monsters'] },
            forest: { name: 'Forest', icon: 'ğŸŒ²', activities: ['Gather', 'Hunt'], quests: ['Daily Exercise'] },
            dungeon: { name: 'Dungeon', icon: 'ğŸ°', activities: ['Battle', 'Loot'], quests: ['Skill Training'] },
            mountain: { name: 'Mountain', icon: 'â›°ï¸', activities: ['Mine', 'Explore'], quests: [] },
            beach: { name: 'Beach', icon: 'ğŸ–ï¸', activities: ['Fish', 'Relax'], quests: [] },
            volcano: { name: 'Volcano', icon: 'ğŸŒ‹', activities: ['Mine Gems', 'Boss Fight'], quests: [] },
            temple: { name: 'Temple', icon: 'â›©ï¸', activities: ['Pray', 'Get Blessing'], quests: [] },
            arena: { name: 'Arena', icon: 'âš”ï¸', activities: ['PvP', 'Tournaments'], quests: ['Combat Training'] }
          };
        },
        
        suggestTeleport() {
          this.addSystemMessage('ğŸ—ºï¸ SMART TELEPORT ANALYSIS...', 'system');
          
          const locations = this.getLocationDatabase();
          const sl = window.gameState.soloLevelingSystem;
          const suggestions = [];
          
          // Analyze based on quests
          const incompleteQuests = sl.dailyQuests.filter(q => !q.completed);
          incompleteQuests.forEach(quest => {
            Object.entries(locations).forEach(([key, loc]) => {
              if (loc.quests.includes(quest.name)) {
                suggestions.push({
                  location: key,
                  reason: `ğŸ“œ Complete "${quest.name}" quest`,
                  priority: 3,
                  icon: loc.icon
                });
              }
            });
          });
          
          // Check health - suggest temple for healing
          const hpPercent = (sl.hp / sl.maxHp) * 100;
          if (hpPercent < 50) {
            suggestions.push({
              location: 'temple',
              reason: `â¤ï¸ Low HP (${Math.round(hpPercent)}%) - Get blessing`,
              priority: 2,
              icon: 'â›©ï¸'
            });
          }
          
          // Check for shopping needs
          const emptySlots = Object.entries(window.gameState.equipped).filter(([k, v]) => !v && k !== 'vehicle' && k !== 'pet' && k !== 'robot' && k !== 'spirit').length;
          if (emptySlots > 0 && window.gameState.gold > 1000) {
            suggestions.push({
              location: 'city',
              reason: `ğŸª Empty equipment slots & ${window.gameState.gold}g available`,
              priority: 2,
              icon: 'ğŸ™ï¸'
            });
          }
          
          // Arena for combat training
          if (sl.level > 3) {
            suggestions.push({
              location: 'arena',
              reason: 'âš”ï¸ Test your power in arena',
              priority: 1,
              icon: 'âš”ï¸'
            });
          }
          
          // Volcano for gem mining
          if (window.gameState.gems < 100) {
            suggestions.push({
              location: 'volcano',
              reason: 'ğŸ’ Low on gems - Mine at volcano',
              priority: 1,
              icon: 'ğŸŒ‹'
            });
          }
          
          // Sort by priority
          suggestions.sort((a, b) => b.priority - a.priority);
          
          if (suggestions.length === 0) {
            this.addSystemMessage('âœ… Stay where you are - no urgent destinations', 'info');
            return;
          }
          
          this.addSystemMessage('ğŸ—ºï¸ RECOMMENDED DESTINATIONS:', 'system');
          suggestions.slice(0, 5).forEach((s, i) => {
            this.addSystemMessage(`${i + 1}. ${s.icon} ${locations[s.location].name} - ${s.reason}`, 'info');
          });
          this.addSystemMessage('', 'info');
          this.addSystemMessage('ğŸ’¡ Type "teleport [location]" to travel!', 'reward');
        },
        
        teleportTo(location) {
          const locations = this.getLocationDatabase();
          const normalizedLocation = typeof location === 'string' ? location.trim().toLowerCase() : '';
          const loc = locations[normalizedLocation];
          const state = window.gameState;

          // Guard against missing or malformed game state so teleport calls never crash mid-session.
          if (!state || typeof state !== 'object') {
            this.addSystemMessage('âŒ Teleport failed: game state is unavailable. Please initialize the game first.', 'error');
            return;
          }

          const sl = state.soloLevelingSystem;
          if (!sl) {
            this.addSystemMessage('âŒ Teleport failed: solo leveling data is missing. Try reloading or completing initialization.', 'error');
            return;
          }
          
          if (!loc) {
            this.addSystemMessage(`âŒ Unknown location "${location}". Try: city, forest, dungeon, mountain, beach, volcano, temple, arena`, 'error');
            return;
          }
          
          this.addSystemMessage(`ğŸŒ€ TELEPORTING to ${loc.icon} ${loc.name}...`, 'system');
          this.showToast(`ğŸŒ€ Teleported to ${loc.name}!`);
          
          // Show location info
          this.addSystemMessage(`ğŸ“ Current Location: ${loc.icon} ${loc.name}`, 'info');
          this.addSystemMessage(`ğŸ¯ Available Activities: ${loc.activities.join(', ')}`, 'info');
          
          if (loc.quests.length > 0) {
            this.addSystemMessage(`ğŸ“œ Related Quests: ${loc.quests.join(', ')}`, 'info');
          }
          
          // Could trigger location-specific events here
          if (normalizedLocation === 'temple' && sl.hp < sl.maxHp) {
            sl.hp = sl.maxHp;
            sl.mp = sl.maxMp;
            this.addSystemMessage('âœ¨ Temple blessing received! HP & MP fully restored!', 'reward');
            this.render();
          }
        },
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BATTLE AI - Auto-combat with strategy
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        startBattleAI(enemyType = 'monster') {
          this.addSystemMessage('âš”ï¸ BATTLE AI ACTIVATED!', 'system');
          
          const sl = window.gameState.soloLevelingSystem;
          const equipped = window.gameState.equipped;
          
          // Calculate player power
          let playerAtk = sl.stats.strength * 2 + sl.stats.agility;
          let playerDef = sl.stats.vitality * 2 + sl.stats.sense;
          
          Object.values(equipped).forEach(item => {
            if (item) {
              playerAtk += (item.attack || 0);
              playerDef += (item.defense || 0);
            }
          });
          
          // Enemy stats based on type
          const enemies = {
            slime: { name: 'Slime', icon: 'ğŸ’§', hp: 50, atk: 15, def: 5, exp: 20, gold: 50 },
            goblin: { name: 'Goblin', icon: 'ğŸ‘º', hp: 100, atk: 25, def: 10, exp: 50, gold: 100 },
            monster: { name: 'Monster', icon: 'ğŸ‘¹', hp: 150, atk: 35, def: 15, exp: 80, gold: 150 },
            dragon: { name: 'Dragon', icon: 'ğŸ‰', hp: 500, atk: 80, def: 40, exp: 300, gold: 500 },
            boss: { name: 'Boss', icon: 'ğŸ‘¿', hp: 1000, atk: 120, def: 60, exp: 500, gold: 1000 }
          };
          
          const enemy = enemies[enemyType] || enemies.monster;
          let enemyHp = enemy.hp;
          let playerHp = sl.hp;
          
          this.addSystemMessage(`ğŸ¯ Fighting ${enemy.icon} ${enemy.name} (HP: ${enemy.hp})`, 'info');
          this.addSystemMessage(`âš”ï¸ Your Stats: ATK ${playerAtk} | DEF ${playerDef} | HP ${playerHp}`, 'info');
          
          let turn = 0;
          const maxTurns = 20;
          
          // Battle simulation
          while (enemyHp > 0 && playerHp > 0 && turn < maxTurns) {
            turn++;
            
            // Player attack
            const damage = Math.max(1, playerAtk - enemy.def);
            enemyHp -= damage;
            
            if (enemyHp > 0) {
              // Enemy attack
              const enemyDamage = Math.max(1, enemy.atk - playerDef);
              playerHp -= enemyDamage;
              
              // AI DECIDES: Should use potion?
              if (playerHp < sl.maxHp * 0.3) {
                const healthPotion = window.gameState.inventory.items.find(i => i.name === 'Health Potion' && i.quantity > 0);
                if (healthPotion) {
                  healthPotion.quantity--;
                  playerHp = Math.min(playerHp + 40, sl.maxHp);
                  this.addSystemMessage(`ğŸ’Š AI used Health Potion! HP: ${playerHp}/${sl.maxHp}`, 'reward');
                }
              }
            }
          }
          
          // Battle result
          if (enemyHp <= 0) {
            this.addSystemMessage(`ğŸ‰ VICTORY! Defeated ${enemy.icon} ${enemy.name}!`, 'reward');
            this.addSystemMessage(`ğŸ’° +${enemy.gold} gold | âœ¨ +${enemy.exp} EXP`, 'reward');
            
            window.gameState.gold += enemy.gold;
            sl.exp += enemy.exp;
            sl.hp = playerHp;
            this.checkLevelUp();
            this.syncAllSystems();
            this.render();
          } else if (playerHp <= 0) {
            this.addSystemMessage(`ğŸ’€ DEFEAT! You were defeated by ${enemy.icon} ${enemy.name}...`, 'error');
            sl.hp = 1; // Don't die completely
          } else {
            this.addSystemMessage(`â±ï¸ Battle timeout (${maxTurns} turns)`, 'info');
          }
        },
        
        autoBattle(enemyType = 'monster', count = 1) {
          this.addSystemMessage(`âš”ï¸ AUTO-BATTLE MODE: Fighting ${count} ${enemyType}(s)...`, 'system');
          
          for (let i = 0; i < count; i++) {
            setTimeout(() => {
              this.startBattleAI(enemyType);
              
              // Complete quest progress if applicable
              const sl = window.gameState.soloLevelingSystem;
              const huntQuest = sl.dailyQuests.find(q => q.id === 'hunt_monsters' || q.name === 'Hunt Monsters');
              if (huntQuest && !huntQuest.completed) {
                huntQuest.progress = Math.min((huntQuest.progress || 0) + 1, huntQuest.requirement || 10);
                if (huntQuest.progress >= huntQuest.requirement) {
                  this.completeQuest(huntQuest.id);
                }
              }
            }, i * 1000);
          }
        },
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // UNDO SYSTEM - Revert AI Actions
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        undoLastAction() {
          const sl = window.gameState.soloLevelingSystem;
          if (!sl || sl.aiActions.length === 0) {
            this.addSystemMessage('âŒ No actions to undo', 'error');
            return;
          }
          
          const lastAction = sl.aiActions[sl.aiActions.length - 1];
          
          // Attempt to revert based on action type
          let reverted = false;
          
          if (lastAction.type === 'buy_potion') {
            // Remove the potion and refund gold
            const cost = lastAction.data.cost || 50;
            window.gameState.gold += cost;
            
            const potionName = lastAction.data.potionType === 'health' ? 'Health Potion' : 'Mana Potion';
            const item = window.gameState.inventory.items.find(i => i.name === potionName);
            if (item && item.quantity > 0) {
              item.quantity--;
              if (item.quantity === 0) {
                window.gameState.inventory.items = window.gameState.inventory.items.filter(i => i !== item);
              }
            }
            
            this.addSystemMessage(`â†©ï¸ UNDONE: Refunded ${cost} gold, removed potion`, 'reward');
            reverted = true;
          }
          else if (lastAction.type === 'sell_junk' || lastAction.type === 'auto_equip' || lastAction.type === 'auto_upgrade') {
            this.addSystemMessage(`âš ï¸ Cannot undo ${lastAction.type} - too complex`, 'error');
          }
          else {
            this.addSystemMessage(`â†©ï¸ Marked action as reverted (manual check needed)`, 'info');
            reverted = true;
          }
          
          // Remove from history
          sl.aiActions.pop();
          
          this.render();
          this.renderAITab();
        },
        
        // Solo Leveling System Helper Functions
        getStatIcon(stat) {
          const icons = {
            strength: 'ğŸ’ª',
            agility: 'âš¡',
            intelligence: 'ğŸ§ ',
            vitality: 'â¤ï¸',
            sense: 'ğŸ‘ï¸'
          };
          return icons[stat] || 'ğŸ“Š';
        },
        
        generateDailyQuests() {
          return [
            {
              id: 'daily_exercise',
              name: 'Daily Exercise',
              description: 'Complete 100 exercises to maintain your body',
              icon: 'ğŸƒ',
              requirement: 100,
              progress: 0,
              completed: false,
              rewards: { exp: 100, gold: 0 },
              penalty: 'Failure to complete will result in stat reduction'
            },
            {
              id: 'daily_combat',
              name: 'Hunt Monsters',
              description: 'Defeat 10 monsters',
              icon: 'âš”ï¸',
              requirement: 10,
              progress: 0,
              completed: false,
              rewards: { exp: 150, gold: 500 }
            },
            {
              id: 'daily_training',
              name: 'Skill Training',
              description: 'Use skills 20 times in combat',
              icon: 'ğŸ¯',
              requirement: 20,
              progress: 0,
              completed: false,
              rewards: { exp: 120, gold: 300, item: 'ğŸ’ Skill Crystal' }
            }
          ];
        },
        
        addSystemMessage(text, type = 'info') {
          if (!window.gameState.soloLevelingSystem) return;
          
          window.gameState.soloLevelingSystem.messages.push({
            text,
            time: Date.now(),
            type
          });
          
          // Keep only last 50 messages
          if (window.gameState.soloLevelingSystem.messages.length > 50) {
            window.gameState.soloLevelingSystem.messages = window.gameState.soloLevelingSystem.messages.slice(-50);
          }
        },
        
        increaseStat(stat) {
          if (!window.gameState.soloLevelingSystem || window.gameState.soloLevelingSystem.statPoints <= 0) return;
          
          window.gameState.soloLevelingSystem.stats[stat]++;
          window.gameState.soloLevelingSystem.statPoints--;
          
          // Update max HP/MP based on stats
          if (stat === 'vitality') {
            window.gameState.soloLevelingSystem.maxHp += 5;
            window.gameState.soloLevelingSystem.hp += 5;
          }
          if (stat === 'intelligence') {
            window.gameState.soloLevelingSystem.maxMp += 3;
            window.gameState.soloLevelingSystem.mp += 3;
          }
          
          this.addSystemMessage(`${stat.toUpperCase()} increased to ${window.gameState.soloLevelingSystem.stats[stat]}`, 'system');
          this.showToast(`ğŸ“Š ${stat.toUpperCase()} +1`);
          this.renderAITab();
        },
        
        completeQuest(questId) {
          if (!window.gameState.soloLevelingSystem) return;
          
          const quest = window.gameState.soloLevelingSystem.dailyQuests.find(q => q.id === questId);
          if (!quest || quest.completed || quest.progress < quest.requirement) return;
          
          quest.completed = true;
          
          // Give rewards
          if (quest.rewards.exp) {
            window.gameState.soloLevelingSystem.exp += quest.rewards.exp;
            this.checkLevelUp();
          }
          if (quest.rewards.gold) {
            window.gameState.gold += quest.rewards.gold;
          }
          
          this.addSystemMessage(`Quest completed: ${quest.name}. Rewards: ${quest.rewards.exp ? `+${quest.rewards.exp} EXP ` : ''}${quest.rewards.gold ? `+${quest.rewards.gold} Gold` : ''}`, 'reward');
          this.showToast(`âœ… ${quest.name} completed!`);
          if (typeof this.showQuestRecapPopup === 'function') {
            this.showQuestRecapPopup({
              name: quest.name,
              icon: quest.icon || 'ğŸ“œ',
              description: quest.summary || quest.description || 'Daily quest cleared! Rewards collected.',
              rewards: {
                exp: quest.rewards.exp ?? 0,
                gold: quest.rewards.gold ?? 0,
                items: quest.rewards.items ?? [],
                token: quest.rewards.token,
                title: quest.rewards.title
              }
            });
          }
          if (typeof this.createConfettiEffect === 'function') {
            this.createConfettiEffect(window.innerWidth / 2, window.innerHeight / 2, { count: 48 });
          }
          this.playCandySfx('quest-complete');
          this.syncAllSystems();
          this.renderAITab();
        },
        
        checkLevelUp() {
          if (!window.gameState.soloLevelingSystem) return;
          
          while (window.gameState.soloLevelingSystem.exp >= window.gameState.soloLevelingSystem.expToNext) {
            window.gameState.soloLevelingSystem.exp -= window.gameState.soloLevelingSystem.expToNext;
            window.gameState.soloLevelingSystem.level++;
            window.gameState.soloLevelingSystem.expToNext = Math.floor(window.gameState.soloLevelingSystem.expToNext * 1.5);
            window.gameState.soloLevelingSystem.statPoints += 5;
            
            // Restore HP/MP on level up
            window.gameState.soloLevelingSystem.hp = window.gameState.soloLevelingSystem.maxHp;
            window.gameState.soloLevelingSystem.mp = window.gameState.soloLevelingSystem.maxMp;
            
            this.addSystemMessage(`ğŸŠ LEVEL UP! You are now Level ${window.gameState.soloLevelingSystem.level}. You gained 5 stat points.`, 'reward');
            this.showToast(`ğŸŠ LEVEL UP! Now Lv. ${window.gameState.soloLevelingSystem.level}`);
            this.playCandySfx('level-up');
          }
        },
        
        progressAllQuests() {
          if (!window.gameState.soloLevelingSystem) return;
          
          window.gameState.soloLevelingSystem.dailyQuests.forEach(quest => {
            if (!quest.completed) {
              quest.progress = Math.min(quest.progress + 25, quest.requirement);
            }
          });
          
          this.addSystemMessage('Quest progress updated (test mode)', 'system');
          this.renderAITab();
        },
        
        resetDailyQuests() {
          if (!window.gameState.soloLevelingSystem) return;
          
          window.gameState.soloLevelingSystem.dailyQuests = this.generateDailyQuests();
          window.gameState.soloLevelingSystem.lastDailyReset = Date.now();
          
          this.addSystemMessage('Daily quests have been reset', 'system');
          this.showToast('ğŸ”„ Daily quests reset');
          this.renderAITab();
        },

        /**
         * Returns a formatted summary of equipped skills for a character.
         * Used in team overview and AI panels to show skill loadouts.
         */
        getCharacterEquippedSkillsSummary(characterId) {
          const equipped = window.gameState.equippedSkills || {};
          const characterLoadout = equipped[characterId] || {};
          const slots = ['S1', 'S2', 'S3'];
          const equippedSkills = [];

          slots.forEach(slot => {
            const skill = characterLoadout[slot];
            if (skill) {
              equippedSkills.push({
                slot,
                name: skill.name,
                icon: skill.icon || 'âš”ï¸',
                damage: skill.damage || skill.baseDamage || 0,
                cooldown: skill.cooldown || 0,
                tier: skill.tier || 'common',
                element: skill.element || 'PHYSICAL'
              });
            }
          });

          return {
            characterId,
            totalEquipped: equippedSkills.length,
            skills: equippedSkills,
            summary: equippedSkills.length > 0 
              ? equippedSkills.map(s => `${s.icon} ${s.name}`).join(', ')
              : 'No skills equipped'
          };
        },

        renderTeamTab() {
          const pane = document.getElementById('bagContentPane');
          const equipped = window.gameState.equipped || {};

          const accentStyles = {
            pet: { bg: 'linear-gradient(145deg, rgba(255, 176, 240, 0.35), rgba(134, 225, 255, 0.3))', border: 'rgba(255, 176, 240, 0.65)', pill: '#ff9af0' },
            vehicle: { bg: 'linear-gradient(145deg, rgba(132, 218, 255, 0.35), rgba(144, 255, 222, 0.3))', border: 'rgba(132, 218, 255, 0.65)', pill: '#6fe4ff' },
            robot: { bg: 'linear-gradient(145deg, rgba(144, 198, 255, 0.35), rgba(180, 168, 255, 0.3))', border: 'rgba(144, 198, 255, 0.65)', pill: '#8cbcff' },
            spirit: { bg: 'linear-gradient(145deg, rgba(210, 178, 255, 0.35), rgba(255, 214, 247, 0.3))', border: 'rgba(210, 178, 255, 0.65)', pill: '#d8b4ff' }
          };

          const companions = [
            { type: 'Pet', icon: 'ğŸ¾', slot: 'pet', data: equipped.pet, accent: accentStyles.pet },
            { type: 'Vehicle', icon: 'ğŸš—', slot: 'vehicle', data: equipped.vehicle, accent: accentStyles.vehicle },
            { type: 'Robot', icon: 'ğŸ¤–', slot: 'robot', data: equipped.robot, accent: accentStyles.robot },
            { type: 'Spirit', icon: 'âœ¨', slot: 'spirit', data: equipped.spirit, accent: accentStyles.spirit }
          ];
          
          const destinationTabs = {
            pet: 'pets',
            vehicle: 'vehicles',
            robot: 'ai',
            spirit: 'spirit'
          };
          
          const formatBadge = (emoji, label, value, color) => {
            if (value == null) return '';
            const display = typeof value === 'number' ? (Math.abs(value) >= 100 ? Math.round(value) : value.toFixed(1)) : value;
            return `<span style="display:inline-flex;align-items:center;gap:4px;padding:4px 10px;border-radius:999px;background:${color}1f;color:${color};font-size:10px;font-weight:700;">${emoji} ${label} ${display}</span>`;
          };
          
          const buildBadges = (slot, data, color) => {
            if (!data) return '';
            switch (slot) {
              case 'pet':
                return [
                  formatBadge('âš”ï¸', 'ATK', data.attack ?? data.power, color),
                  formatBadge('â¤ï¸', 'HP', data.health ?? data.hp, color),
                  formatBadge('ğŸ’¨', 'SPD', data.speed, color)
                ].join('');
              case 'vehicle':
                return [
                  formatBadge('ğŸš€', 'SPD', data.speed, color),
                  formatBadge('ğŸ›¡ï¸', 'DUR', data.durability ?? data.defense, color),
                  formatBadge('ğŸ‘¥', 'CAP', data.capacity, color)
                ].join('');
              case 'robot':
                return [
                  formatBadge('âš”ï¸', 'ATK', data.atk ?? data.attack, color),
                  formatBadge('ğŸ›¡ï¸', 'DEF', data.def ?? data.defense, color),
                  formatBadge('â¤ï¸', 'HP', data.hp, color)
                ].join('');
              case 'spirit':
                return [
                  formatBadge('ğŸŒŸ', 'Power', data.power ?? data.attack, color),
                  formatBadge('ğŸ’«', 'Aura', data.element ?? data.type, color),
                  formatBadge('ğŸ”¥', 'Skill', data.weaponSkill?.name ?? data.description?.split('.')[0] ?? '', color)
                ].join('');
              default:
                return '';
            }
          };
          
          const renderCompanionCard = (comp) => {
            const accent = comp.accent;
            if (comp.data) {
              const icon = comp.data.icon || comp.icon;
              const name = comp.data.name || `Equipped ${comp.type}`;
              const description = comp.data.description || comp.data.lore || 'Ready for adventure.';
              return `
                <div style="background:${accent.bg};border:2px solid ${accent.border};border-radius:20px;padding:18px;box-shadow:0 15px 35px rgba(13,16,35,0.35);backdrop-filter:blur(8px);">
                  <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:12px;">
                    <div style="display:flex;align-items:center;gap:10px;">
                      <span style="font-size:28px;">${icon}</span>
                      <div>
                        <div style="font-size:12px;color:${accent.pill};text-transform:uppercase;letter-spacing:0.6px;">${comp.type}</div>
                        <div style="font-size:15px;color:#fdfcff;font-weight:700;">${name}</div>
                      </div>
                    </div>
                    <button data-team-action="remove" data-team-slot="${comp.slot}"
                            style="border:none;background:linear-gradient(135deg,#ff8fb7,#ff6b9a);color:#fff;padding:6px 12px;border-radius:999px;font-size:11px;font-weight:700;cursor:pointer;">
                      Remove
                      </button>
                    </div>
                  <div style="display:flex;flex-wrap:wrap;gap:6px;margin-bottom:12px;">
                    ${buildBadges(comp.slot, comp.data, accent.pill)}
                </div>
                  <div style="font-size:11px;color:rgba(255,255,255,0.75);line-height:1.5;">
                    ${description}
            </div>
                    </div>
              `;
            }
            return `
              <div style="background:${accent.bg};border:2px dashed ${accent.border};border-radius:20px;padding:22px;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:12px;min-height:160px;box-shadow:0 12px 28px rgba(13,16,35,0.25);backdrop-filter:blur(8px);">
                <div style="font-size:36px;opacity:0.55;">â•</div>
                <div style="font-size:12px;color:rgba(255,255,255,0.7);text-align:center;">No ${comp.type} Equipped</div>
                <button data-team-action="open-tab" data-target-tab="${destinationTabs[comp.slot] || 'items'}"
                        style="border:none;background:linear-gradient(135deg,#6df2ff,#99f7d8);color:#0e3b4b;padding:8px 18px;border-radius:999px;font-size:11px;font-weight:700;cursor:pointer;">
                  Equip ${comp.type}
                </button>
                          </div>
            `;
          };
          
          pane.innerHTML = `
            <div style="padding: 20px;">
              <div style="margin-bottom: 18px;">
                <h2 style="font-size: 22px; color: #ffd9fb; margin: 0 0 8px;">ğŸ€ Team Candy Deck</h2>
                <p style="font-size: 12px; color: rgba(255, 255, 255, 0.7); margin: 0;">
                  A quick glance at every companion slot with sugary glow-ups.
                </p>
                </div>
              <div style="display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:14px;">
                ${companions.map(renderCompanionCard).join('')}
                </div>
              ${this.renderCompanionLoadouts()}
            </div>
          `;
          
          pane.querySelectorAll('[data-team-action]').forEach(btn => {
            const action = btn.dataset.teamAction;
            const slot = btn.dataset.teamSlot;
            if (action === 'remove') {
              const removeMap = {
                pet: this.unequipPet,
                vehicle: this.unequipVehicle,
                robot: this.unequipRobot,
                spirit: this.unequipSpirit
              };
              const handler = removeMap[slot];
              if (handler) {
                handler.call(this);
              }
            } else if (action === 'open-tab') {
              const target = btn.dataset.targetTab || 'items';
              this.state.activeTab = target;
              this.renderTabs();
              this.renderTab(target);
            }
          });
          
          this.attachCompanionLoadoutHandlers(pane);
        },

        renderSkillsTab() {
          const pane = document.getElementById('bagContentPane');
          if (!pane) {
            debugError('[BagSystem] bagContentPane not found!');
            return;
          }

          this.ensureAllSkillsMetadata();
          
          const skills = window.gameState?.inventory?.skills || [];
          if (!Array.isArray(skills)) {
            debugError('[BagSystem] skills is not an array:', typeof skills);
            pane.innerHTML = '<div style="color: #ff4444; padding: 20px;">âŒ Skills data is invalid</div>';
            return;
          }

          const currentCharacter = this.ensureCurrentCharacter();
          if (!this.state.selectedSkillSlot) {
            this.state.selectedSkillSlot = 'S1';
          }
          this.state.activeCharacter = this.state.activeCharacter || currentCharacter;

          // Initialize equipped skills structure for all characters and ensure the dual layout exists (per-character + quick slots).
          const equippedSkillsRoot = this.migrateLegacyEquippedSkills(window.gameState.equippedSkills);
          window.gameState.equippedSkills = equippedSkillsRoot;

          // Normalize skills - ensure all have required fields
          const normalizedSkills = skills.map(skill => ({
            ...skill,
            icon: skill.icon || 'âš”ï¸',
            tier: skill.tier || 'common',
            element: skill.element || 'PHYSICAL',
            description: skill.description || 'No description available',
            damage: skill.damage || skill.baseDamage || 0,
            cooldown: skill.cooldown || 0,
            unlock: skill.unlock || skill.unlockLevel || 1,
            characterId: skill.characterId || 'A1'
          }));

          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          // DUAL-STRUCTURE HYDRATION BLOCK
          // equippedSkills maintains TWO structures:
          // 1. Per-character loadouts: { A1: {S1-S5, X1-X2}, MISSY: {...}, UNIQUE: {...} }
          // 2. Global quick slots: { slot1, slot2, slot3 } - mirrors active character's S1-S3
          // Quick slots sync automatically when character switches via syncQuickSlotsToCharacter()
          // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
          
          // Ensure character loadouts exist (fallback to first three canonical skills)
          const findSkill = id => normalizedSkills.find(s => s.id === id) || null;
          const characterSlotOrder = this.CHARACTER_SKILL_SLOTS || ['S1', 'S2', 'S3', 'S4', 'S5', 'X1', 'X2'];
          if (!characterSlotOrder.includes(this.state.selectedSkillSlot)) {
            this.state.selectedSkillSlot = 'S1';
          }
          const ensureCharacterLoadout = (charId, defaults) => {
            if (!equippedSkillsRoot[charId]) {
              equippedSkillsRoot[charId] = {};
            }
            const loadout = equippedSkillsRoot[charId];
            characterSlotOrder.forEach((slotKey, index) => {
              if (!(slotKey in loadout)) {
                loadout[slotKey] = null;
              }
              const currentValue = loadout[slotKey];
              if (!currentValue || !currentValue.id) {
                const defaultId = defaults[index];
                loadout[slotKey] = defaultId ? findSkill(defaultId) : loadout[slotKey];
              }
            });
          };
          ensureCharacterLoadout('A1', ['A1_S1', 'A1_S2', 'A1_S3', 'A1_S4', 'A1_S5', 'A1_X1', 'A1_X2']);
          ensureCharacterLoadout('UNIQUE', ['UNIQUE_S1', 'UNIQUE_S2', 'UNIQUE_S3', 'UNIQUE_S4', 'UNIQUE_S5', 'UNIQUE_X1', 'UNIQUE_X2']);
          ensureCharacterLoadout('MISSY', ['MISSY_S1', 'MISSY_S2', 'MISSY_S3', 'MISSY_S4', 'MISSY_S5', 'MISSY_X1', 'MISSY_X2']);

          ['slot1', 'slot2', 'slot3'].forEach(slotKey => {
            if (!(slotKey in equippedSkillsRoot)) {
              equippedSkillsRoot[slotKey] = null;
            }
          });

          // Keep the snapshot bi-directional so legacy saves with only quick slots still hydrate the per-character view.
          this.syncCharacterLoadoutFromQuickSlots(currentCharacter);
          this.syncQuickSlotsToCharacter(this.state.activeCharacter);

          // Separate by character
          const a1Skills = normalizedSkills.filter(s => s.characterId === 'A1');
          const uniqueSkills = normalizedSkills.filter(s => s.characterId === 'UNIQUE');
          const missySkills = normalizedSkills.filter(s => s.characterId === 'MISSY');
          
          // Tier colors
          const tierColors = {
            starter: '#9e9e9e',
            common: '#ffffff',
            uncommon: '#4caf50',
            rare: '#2196f3',
            epic: '#9c27b0',
            legendary: '#ff9800'
          };
          
          // Element icons
          const elementIcons = {
            PHYSICAL: 'âš”ï¸', FIRE: 'ğŸ”¥', ICE: 'â„ï¸', LIGHTNING: 'âš¡', SHADOW: 'ğŸŒ‘',
            LIGHT: 'â˜€ï¸', ARCANE: 'âœ¨', PLASMA: 'ğŸ’¥', ENERGY: 'âš¡', SUMMON: 'ğŸ‘¥'
          };
          
          const activeCharacter = this.state.activeCharacter;
          const characterSkills = normalizedSkills.filter(s => s.characterId === activeCharacter);
          const equippedSkills = window.gameState.equippedSkills[activeCharacter] || { S1: null, S2: null, S3: null };

          const renderSkillCard = (skill) => {
            // Check if this skill is equipped to current character
            const slotCheckOrder = this.CHARACTER_SKILL_SLOTS || ['S1', 'S2', 'S3', 'S4', 'S5', 'X1', 'X2'];
            const isEquipped = slotCheckOrder.some(slotKey => equippedSkills[slotKey]?.id === skill.id);
            
            // Get analytics stats for this skill
            const usageStats = this.getSkillUsageStats(skill.id);
            const equipCount = usageStats.equipCount || 0;
            const isNew = equipCount === 0;
            const isUnderused = equipCount > 0 && equipCount <= 2;
            const level = skill.level || 1;
            const rank = skill.rank || 'E';
            const maxLevelReached = level >= this.SKILL_LEVELING_CONFIG.maxLevel;
            const upgradeCost = this.calculateSkillLevelCost(skill);
            const formattedCost = Number.isFinite(upgradeCost) ? upgradeCost.toLocaleString() : `${upgradeCost}`;
            const canFuse = this.canFuseSkill(skill);
            const copiesAvailable = this.countSkillCopies(skill.id, rank);
            const nextRank = this.getNextSkillRank(rank);
            const levelBadgeColor = level >= 7 ? '#ff9800' : level >= 4 ? '#4fc3f7' : '#a5d6a7';
            const rankBadgeColor = rank === 'SSS' ? '#ff4081'
              : rank === 'SS' ? '#ff9800'
              : rank === 'S' ? '#9c27b0'
              : rank === 'A' ? '#4fc3f7'
              : '#cfd8dc';
            
            // Generate tooltip with "why this matters" blurb
            const getTooltipBlurb = (skill) => {
              if (skill.enhanced) return 'âœ¨ Enhanced skill with Tier 3 VFX';
              if (skill.tier === 'legendary') return 'ğŸ’ Ultimate ability - devastating power';
              if (skill.tier === 'epic') return 'ğŸ”¥ High-tier skill - exceptional damage';
              if (skill.shape === 'summon') return 'ğŸ‘¥ Summon allies to fight alongside you';
              if (skill.chargeable) return 'âš¡ Charge for increased damage';
              if (skill.element === 'SHADOW') return 'ğŸŒ‘ Shadow skills excel at mobility and burst';
              if (skill.element === 'LIGHT') return 'âœ¨ Light skills provide utility and support';
              if (skill.element === 'ICE') return 'â„ï¸ Ice skills slow and control enemies';
              return 'âš”ï¸ Reliable damage dealer';
            };
            
            const tierColor = tierColors[skill.tier] || '#666';
            const rarityGlow = skill.tier === 'legendary' ? 'rgba(255, 152, 0, 0.6)' : 
                              skill.tier === 'epic' ? 'rgba(156, 39, 176, 0.5)' :
                              skill.tier === 'rare' ? 'rgba(33, 150, 243, 0.4)' : 'rgba(255, 255, 255, 0.2)';
            
            return `
            <div class="skill-card" data-skill-id="${skill.id}" data-skill-name="${skill.name}"
                 onclick="window.BagSystem.equipSkillToCharacter('${skill.id}', '${this.state.selectedSkillSlot}', '${activeCharacter}')" 
                 style="background: linear-gradient(135deg, rgba(0, 0, 0, 0.4) 0%, rgba(0, 0, 0, 0.6) 100%);
                        border: 2px solid ${isEquipped ? '#38ef7d' : tierColor};
                        border-radius: 8px;
                        padding: 8px;
                        position: relative;
                        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
                        cursor: pointer;
                        overflow: hidden;
                        ${isEquipped ? `box-shadow: 0 0 16px rgba(56, 239, 125, 0.6), inset 0 0 20px rgba(56, 239, 125, 0.1);` : `box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);`}"
                        onmouseover="this.style.transform='translateY(-4px) scale(1.02)';this.style.boxShadow='0 8px 24px ${rarityGlow}, 0 0 20px ${tierColor}40';this.style.borderColor='${tierColor}';"
                        onmouseout="this.style.transform='translateY(0) scale(1)';this.style.boxShadow='${isEquipped ? '0 0 16px rgba(56, 239, 125, 0.6), inset 0 0 20px rgba(56, 239, 125, 0.1)' : '0 2px 8px rgba(0, 0, 0, 0.3)'}';this.style.borderColor='${isEquipped ? '#38ef7d' : tierColor}';"
                        title="${getTooltipBlurb(skill)}">
              ${isEquipped ? `<div style="position: absolute; top: 0; left: 0; right: 0; background: linear-gradient(90deg, rgba(56, 239, 125, 0.9), rgba(79, 195, 247, 0.9)); padding: 3px 0; text-align: center; font-size: 7px; font-weight: 900; color: #000; text-transform: uppercase; letter-spacing: 0.5px; animation: slideDown 0.3s ease-out;">âœ“ EQUIPPED</div>` : ''}
              <div style="position: absolute; top: 4px; right: 4px; display: flex; gap: 2px; flex-direction: column; align-items: flex-end;">
                <div style="display: flex; gap: 2px;">
                  <span style="background: ${tierColor}; color: #000; padding: 2px 5px; border-radius: 10px; font-size: 6px; font-weight: 800; text-transform: uppercase; letter-spacing: 0.3px; box-shadow: 0 2px 4px rgba(0,0,0,0.3);">${skill.tier || 'common'}</span>
                  <span style="background: rgba(79, 195, 247, 0.3); color: #4fc3f7; padding: 2px 5px; border-radius: 10px; font-size: 6px; font-weight: 700; border: 1px solid rgba(79, 195, 247, 0.5);">${elementIcons[skill.element] || 'âš”ï¸'}</span>
                </div>
                <div style="display: flex; gap: 2px; margin-top: 2px;">
                  <span style="background: ${levelBadgeColor}; color: #000; padding: 2px 5px; border-radius: 10px; font-size: 6px; font-weight: 800; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">Lv.${level}</span>
                  <span style="background: ${rankBadgeColor}; color: #000; padding: 2px 5px; border-radius: 10px; font-size: 6px; font-weight: 800; box-shadow: 0 2px 4px rgba(0,0,0,0.2);">Rank ${rank}</span>
                </div>
                ${isNew ? `<span style="background: linear-gradient(135deg, rgba(76, 209, 55, 0.9), rgba(56, 239, 125, 0.9)); color: #000; padding: 2px 5px; border-radius: 10px; font-size: 6px; font-weight: 900; text-transform: uppercase; letter-spacing: 0.3px; box-shadow: 0 2px 4px rgba(76, 209, 55, 0.5); margin-top: 2px; animation: pulse 2s infinite;">âœ¨ NEW</span>` : ''}
                ${isUnderused && !isNew ? `<span style="background: linear-gradient(135deg, rgba(255, 152, 0, 0.9), rgba(255, 193, 7, 0.9)); color: #000; padding: 2px 5px; border-radius: 10px; font-size: 6px; font-weight: 900; text-transform: uppercase; letter-spacing: 0.3px; box-shadow: 0 2px 4px rgba(255, 152, 0, 0.5); margin-top: 2px;">âš ï¸ UNDERUSED</span>` : ''}
              </div>
              <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 6px; margin-top: ${isEquipped ? '18px' : '0'};">
                <div style="font-size: 24px; filter: drop-shadow(0 0 8px ${tierColor}80); transition: transform 0.3s;" onmouseover="this.style.transform='rotate(10deg) scale(1.1)'" onmouseout="this.style.transform='rotate(0deg) scale(1)'">${skill.icon}</div>
                <div style="flex: 1;">
                  <div style="font-size: 10px; font-weight: 700; color: ${tierColor}; text-shadow: 0 0 8px ${tierColor}60;">${skill.name}</div>
                </div>
              </div>
              <div style="font-size: 8px; color: rgba(207, 227, 255, 0.85); margin-bottom: 8px; line-height: 1.4; min-height: 32px;">${skill.description}</div>
              <div style="display: flex; flex-wrap: wrap; gap: 6px; margin-bottom: 6px;">
                <button 
                  onclick="event.stopPropagation(); window.BagSystem.upgradeSkillLevel('${skill.id}', '${skill.instance_id}')"
                  ${maxLevelReached ? 'disabled' : ''}
                  style="flex: 1; min-width: 110px; background: linear-gradient(135deg, #38ef7d, #4fc3f7); border: none; border-radius: 6px; padding: 6px 8px; font-size: 8px; font-weight: 700; color: #0b1b2b; cursor: pointer; box-shadow: 0 2px 6px rgba(56, 239, 125, 0.3); ${maxLevelReached ? 'opacity: 0.5; cursor: not-allowed;' : ''}">
                  ${maxLevelReached ? 'ğŸ”’ Max Level' : `â¬†ï¸ Upgrade (${formattedCost}g)`}
                </button>
                ${nextRank ? `
                  <button
                    onclick="event.stopPropagation(); window.BagSystem.fuseSkillRank('${skill.id}', '${rank}')"
                    ${canFuse ? '' : 'disabled'}
                    style="flex: 1; min-width: 110px; background: linear-gradient(135deg, #ff6b35, #ff3b3b); border: none; border-radius: 6px; padding: 6px 8px; font-size: 8px; font-weight: 700; color: #0b1b2b; cursor: pointer; box-shadow: 0 2px 6px rgba(255, 107, 53, 0.3); ${canFuse ? '' : 'opacity: 0.5; cursor: not-allowed;'}">
                    ${canFuse ? `ğŸ’  Fuse x3 â†’ Rank ${nextRank}` : `ğŸ’  Fuse Needs ${Math.max(0, 3 - copiesAvailable)}x`}
                  </button>
                ` : `
                  <button
                    disabled
                    style="flex: 1; min-width: 110px; background: rgba(207, 227, 255, 0.1); border: none; border-radius: 6px; padding: 6px 8px; font-size: 8px; font-weight: 700; color: rgba(207, 227, 255, 0.4); cursor: not-allowed;">
                    ğŸ’  Rank Max
                  </button>
                `}
              </div>
              ${skill.shape === 'summon' && skill.summonHp ? `
                <div style="background: linear-gradient(135deg, rgba(56, 239, 125, 0.2), rgba(79, 195, 247, 0.2)); border: 1px solid rgba(56, 239, 125, 0.4); border-radius: 6px; padding: 6px; margin-bottom: 6px;">
                  <div style="display: flex; gap: 4px; flex-wrap: wrap; font-size: 7px;">
                    <div style="flex: 1; background: rgba(255, 77, 79, 0.2); padding: 3px 5px; border-radius: 4px; border: 1px solid rgba(255, 77, 79, 0.4);">
                      <span style="color: #ff4d4f; font-weight: 800;">â¤ï¸ ${skill.summonHp} HP</span>
                    </div>
                    ${skill.healOnKill ? `<div style="flex: 1; background: rgba(56, 239, 125, 0.2); padding: 3px 5px; border-radius: 4px; border: 1px solid rgba(56, 239, 125, 0.4);">
                      <span style="color: #38ef7d; font-weight: 800;">ğŸ’š Heal on Kill</span>
                    </div>` : ''}
                    ${skill.duration ? `<div style="flex: 1; background: rgba(154, 107, 255, 0.2); padding: 3px 5px; border-radius: 4px; border: 1px solid rgba(154, 107, 255, 0.4);">
                      <span style="color: #9a6bff; font-weight: 800;">â³ ${skill.duration}</span>
                    </div>` : ''}
                  </div>
                </div>
              ` : ''}
              <div style="display: flex; gap: 6px; font-size: 7px; margin-bottom: 4px;">
                ${skill.damage ? `<div style="flex: 1; background: rgba(255, 215, 122, 0.15); padding: 4px 6px; border-radius: 4px; border: 1px solid rgba(255, 215, 122, 0.3);"><span style="color: #ffd77a; font-weight: 800;" class="counter-animate">ğŸ’¥ ${skill.damage}</span></div>` : ''}
                ${skill.cooldown ? `<div style="flex: 1; background: rgba(79, 195, 247, 0.15); padding: 4px 6px; border-radius: 4px; border: 1px solid rgba(79, 195, 247, 0.3);"><span style="color: #4fc3f7; font-weight: 800;" class="counter-animate">â±ï¸ ${skill.cooldown}s</span></div>` : ''}
                ${skill.unlock ? `<div style="flex: 1; background: rgba(154, 107, 255, 0.15); padding: 4px 6px; border-radius: 4px; border: 1px solid rgba(154, 107, 255, 0.3);"><span style="color: #9a6bff; font-weight: 800;">Lv${skill.unlock}</span></div>` : ''}
              </div>
              ${(skill.setupSwings || skill.volleyInterval || skill.windup || skill.precastBullets) ? `
                <div style="margin-top: 4px; display: flex; gap: 4px; font-size: 6px; color: rgba(207, 227, 255, 0.75); flex-wrap: wrap;">
                  ${skill.setupSwings ? `<span style="background: rgba(255, 255, 255, 0.1); padding: 2px 4px; border-radius: 3px;">ğŸ—¡ï¸ ${skill.setupSwings} slashes</span>` : ''}
                  ${skill.precastBullets ? `<span style="background: rgba(255, 255, 255, 0.1); padding: 2px 4px; border-radius: 3px;">ğŸ’« ${skill.precastBullets} hits</span>` : ''}
                  ${skill.volleyInterval ? `<span style="background: rgba(255, 255, 255, 0.1); padding: 2px 4px; border-radius: 3px;">ğŸ” ${skill.volleyInterval.toFixed(2)}s volley</span>` : ''}
                  ${skill.windup ? `<span style="background: rgba(255, 255, 255, 0.1); padding: 2px 4px; border-radius: 3px;">âš¡ ${skill.windup.toFixed(2)}s charge</span>` : ''}
                </div>
              ` : ''}
              ${skill.chargeable || skill.lifesteal || skill.freeze || skill.burn || skill.teleport ? `
                <div style="margin-top: 6px; display: flex; flex-wrap: wrap; gap: 3px; padding-top: 4px; border-top: 1px solid rgba(255, 255, 255, 0.1);">
                  ${skill.chargeable ? '<span style="background: linear-gradient(135deg, rgba(156, 39, 176, 0.4), rgba(233, 30, 99, 0.4)); color: #e91e63; padding: 3px 6px; border-radius: 12px; font-size: 6px; font-weight: 700; border: 1px solid rgba(156, 39, 176, 0.6);">âš¡ CHARGE</span>' : ''}
                  ${skill.lifesteal ? '<span style="background: linear-gradient(135deg, rgba(255, 77, 79, 0.4), rgba(244, 67, 54, 0.4)); color: #f44336; padding: 3px 6px; border-radius: 12px; font-size: 6px; font-weight: 700; border: 1px solid rgba(255, 77, 79, 0.6);">ğŸ©¸ LIFESTEAL</span>' : ''}
                  ${skill.freeze ? '<span style="background: linear-gradient(135deg, rgba(33, 150, 243, 0.4), rgba(3, 169, 244, 0.4)); color: #03a9f4; padding: 3px 6px; border-radius: 12px; font-size: 6px; font-weight: 700; border: 1px solid rgba(33, 150, 243, 0.6);">â„ FREEZE</span>' : ''}
                  ${skill.burn ? '<span style="background: linear-gradient(135deg, rgba(255, 152, 0, 0.4), rgba(255, 87, 34, 0.4)); color: #ff5722; padding: 3px 6px; border-radius: 12px; font-size: 6px; font-weight: 700; border: 1px solid rgba(255, 152, 0, 0.6);">ğŸ”¥ BURN</span>' : ''}
                  ${skill.teleport ? '<span style="background: linear-gradient(135deg, rgba(156, 39, 176, 0.4), rgba(103, 58, 183, 0.4)); color: #673ab7; padding: 3px 6px; border-radius: 12px; font-size: 6px; font-weight: 700; border: 1px solid rgba(156, 39, 176, 0.6);">ğŸŒ€ TELEPORT</span>' : ''}
                </div>
              ` : ''}
            </div>
            <style>
              @keyframes slideDown {
                from { transform: translateY(-100%); opacity: 0; }
                to { transform: translateY(0); opacity: 1; }
              }
              @keyframes counterPulse {
                0%, 100% { transform: scale(1); }
                50% { transform: scale(1.1); }
              }
              @keyframes pulse {
                0%, 100% { opacity: 1; transform: scale(1); }
                50% { opacity: 0.8; transform: scale(1.05); }
              }
              .counter-animate {
                animation: counterPulse 0.6s ease-out;
                display: inline-block;
              }
            </style>
          `;
          };
          
          // Render compact skill slot
          const renderSkillSlot = (slotKey) => {
            const skill = equippedSkills[slotKey];
            const isSelected = this.state.selectedSkillSlot === slotKey;
            const isUltimate = (this.ULTIMATE_SLOT_KEYS || ['X1', 'X2']).includes(slotKey);
            const slotWidth = isUltimate ? 90 : 80;
            const gradient = isUltimate
              ? 'linear-gradient(135deg, rgba(255, 152, 0, 0.25), rgba(233, 30, 99, 0.25))'
              : 'linear-gradient(135deg, rgba(56, 239, 125, 0.2), rgba(79, 195, 247, 0.2))';
            const baseBorder = isUltimate ? '#ff9800' : '#38ef7d';
            const borderColor = isSelected ? '#ffd700' : baseBorder;
            const boxShadow = isSelected
              ? '0 0 16px #ffd700'
              : isUltimate
                ? '0 0 12px rgba(255, 152, 0, 0.4)'
                : '0 0 8px rgba(56, 239, 125, 0.3)';
            const labelBg = isUltimate ? 'rgba(255, 152, 0, 0.85)' : 'rgba(79, 195, 247, 0.8)';
            const labelColor = isUltimate ? '#3b1a00' : '#000';

            if (skill) {
            const level = skill.level || skill.unlock || 1;
            const rank = skill.rank || 'E';
            const iconContainerSize = isUltimate ? 48 : 44;
            const levelBadgeBg = level >= 7
              ? 'linear-gradient(135deg, #ffb347, #ff7e5f)'
              : level >= 4
                ? 'linear-gradient(135deg, #80d8ff, #4fc3f7)'
                : 'linear-gradient(135deg, #c8f7c5, #69f0ae)';
            const rankBadgeBg = rank === 'SSS'
              ? 'linear-gradient(135deg, #ff80ab, #ff4081)'
              : rank === 'SS'
                ? 'linear-gradient(135deg, #ffcc80, #ffa726)'
                : rank === 'S'
                  ? 'linear-gradient(135deg, #ce93d8, #ab47bc)'
                  : rank === 'A'
                    ? 'linear-gradient(135deg, #80d8ff, #4fc3f7)'
                    : 'linear-gradient(135deg, #eceff1, #cfd8dc)';

              return `
                <div onclick="window.BagSystem.selectSkillSlot('${slotKey}')" 
                     ondblclick="window.BagSystem.unequipSkillFromCharacter('${slotKey}', '${activeCharacter}')"
                     style="width: ${slotWidth}px; height: 80px; background: ${gradient};
                            border: 3px solid ${borderColor}; border-radius: 10px; display: flex; flex-direction: column;
                            align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s;
                            position: relative;
                            box-shadow: ${boxShadow};">
                  <div style="position: absolute; top: 2px; left: 2px; background: ${labelBg}; padding: 2px 5px; border-radius: 4px; font-size: 7px; font-weight: 800; color: ${labelColor}; letter-spacing: 0.5px;">${slotKey}</div>
                <div style="position: relative; width: ${iconContainerSize}px; height: ${iconContainerSize}px; display: flex; align-items: center; justify-content: center;">
                  <div style="font-size: ${isUltimate ? 36 : 32}px; filter: drop-shadow(0 0 6px rgba(255, 255, 255, 0.35));">${skill.icon}</div>
                  <div style="position: absolute; top: -6px; right: -6px; background: ${rankBadgeBg}; color: #0b1b2b; padding: 2px 6px; border-radius: 12px; font-size: 6px; font-weight: 800; letter-spacing: 0.5px; box-shadow: 0 2px 6px rgba(0,0,0,0.3);">
                    Rank ${rank}
                  </div>
                  <div style="position: absolute; bottom: -6px; right: -6px; background: ${levelBadgeBg}; color: #0b1b2b; padding: 2px 6px; border-radius: 12px; font-size: 6px; font-weight: 900; letter-spacing: 0.5px; box-shadow: 0 2px 6px rgba(0,0,0,0.3);">
                    Lv${level}
                  </div>
                </div>
                <div style="font-size: 6px; color: rgba(207, 227, 255, 0.75); margin-top: 6px; text-align: center; text-transform: uppercase; letter-spacing: 0.5px;">
                  ${skill.name || 'Equipped Skill'}
                </div>
                </div>
              `;
            } else {
              const emptyBorder = isSelected ? '#ffd700' : (isUltimate ? 'rgba(255, 152, 0, 0.5)' : 'rgba(79, 195, 247, 0.4)');
              const emptyLabelBg = isUltimate ? 'rgba(255, 152, 0, 0.3)' : 'rgba(79, 195, 247, 0.3)';
              const emptyLabelColor = isUltimate ? '#ff9800' : '#4fc3f7';
              return `
                <div onclick="window.BagSystem.selectSkillSlot('${slotKey}')"
                     style="width: ${slotWidth}px; height: 80px; background: rgba(0, 0, 0, 0.25); border: 3px dashed ${emptyBorder};
                            border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center;
                            cursor: pointer; transition: all 0.2s; position: relative;
                            box-shadow: ${isSelected ? '0 0 16px #ffd700' : 'none'};">
                  <div style="position: absolute; top: 2px; left: 2px; background: ${emptyLabelBg}; padding: 2px 5px; border-radius: 4px; font-size: 7px; font-weight: 800; color: ${emptyLabelColor}; letter-spacing: 0.5px;">${slotKey}</div>
                  <div style="font-size: ${isUltimate ? 30 : 28}px; opacity: 0.25;">?</div>
                  <div style="font-size: 6px; color: rgba(207, 227, 255, 0.45); margin-top: 2px;">Empty</div>
                </div>
              `;
            }
          };

          // Render Equipment Skills subtab content
          const renderEquipmentSkillsSubtab = () => {
            const equippedSkills = window.getEquippedWeaponSkills ? window.getEquippedWeaponSkills() : [];
            
            if (equippedSkills.length === 0) {
              return `
                <div class="tab-empty">
                  <div class="empty-icon">âš”ï¸</div>
                  <p>No equipment skills equipped</p>
                  <p style="font-size: 11px; color: rgba(207, 227, 255, 0.6); margin-top: 8px;">
                    Equip cores with weapon skills in the Gear tab
                  </p>
                </div>
              `;
            }
            
            return `
              <div style="margin-bottom: 20px;">
                <h3 style="font-size: 18px; color: #9a6bff; margin-bottom: 10px;">âš”ï¸ Active Equipment Skills</h3>
                <p style="color: rgba(207, 227, 255, 0.7); font-size: 12px; margin-bottom: 20px;">
                  Skills granted by equipped cores: ${equippedSkills.length} active
                </p>
              </div>
              
              <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 16px;">
                ${equippedSkills.map(({ core, skill, slot }) => {
                  const rarityColors = {
                    common: '#9e9e9e',
                    uncommon: '#4caf50',
                    rare: '#2196f3',
                    epic: '#9c27b0',
                    legendary: '#ff9800'
                  };
                  const borderColor = rarityColors[core.rarity] || '#9e9e9e';
                  
                  return `
                    <div class="equipment-skill-card" style="
                      background: linear-gradient(135deg, rgba(138, 43, 226, 0.2), rgba(75, 0, 130, 0.1));
                      border: 2px solid ${borderColor};
                      border-radius: 12px;
                      padding: 16px;
                      box-shadow: 0 4px 12px rgba(138, 43, 226, 0.3);
                      transition: transform 0.2s, box-shadow 0.2s;
                      cursor: default;
                    " 
                    onmouseover="this.style.transform='translateY(-4px)'; this.style.boxShadow='0 8px 24px rgba(138, 43, 226, 0.5)';"
                    onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 12px rgba(138, 43, 226, 0.3)';">
                      
                      <!-- Core Info Header -->
                      <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 12px; padding-bottom: 10px; border-bottom: 2px solid rgba(138, 43, 226, 0.3);">
                        <span style="font-size: 32px;">${core.icon}</span>
                        <div style="flex: 1;">
                          <div style="font-size: 13px; font-weight: 700; color: ${borderColor};">${core.name}</div>
                          <div style="font-size: 10px; color: rgba(255, 255, 255, 0.6); text-transform: uppercase;">
                            ${core.rarity} | ${core.element}
                          </div>
                        </div>
                        <div style="background: rgba(138, 43, 226, 0.3); padding: 4px 8px; border-radius: 6px; font-size: 9px; font-weight: 700; color: #9a6bff;">
                          ${slot.replace('Core', '')}
                        </div>
                      </div>
                      
                      <!-- Skill Info -->
                      <div style="background: rgba(255, 200, 0, 0.15); border-left: 3px solid #ffc800; padding: 10px; margin-bottom: 12px; border-radius: 4px;">
                        <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                          <span style="font-size: 20px;">âš”ï¸</span>
                          <div style="font-size: 14px; font-weight: 700; color: #ffc800;">${skill.name}</div>
                        </div>
                        <div style="display: flex; gap: 12px; font-size: 10px; color: rgba(255, 255, 255, 0.9);">
                          <div><span style="color: #ff6b6b; font-weight: 700;">ğŸ’¥ ${skill.damage}</span> DMG</div>
                          <div><span style="color: #4fc3f7; font-weight: 700;">â±ï¸ ${skill.cooldown}s</span> CD</div>
                          ${skill.range ? `<div><span style="color: #9a6bff; font-weight: 700;">ğŸ“ ${skill.range}</span> RNG</div>` : ''}
                        </div>
                      </div>
                      
                      <!-- Trigger Info -->
                      <div style="display: flex; align-items: center; gap: 6px; margin-bottom: 10px; font-size: 11px;">
                        <span style="background: rgba(76, 175, 80, 0.3); color: #4caf50; padding: 3px 8px; border-radius: 4px; font-weight: 700;">
                          ${skill.trigger.toUpperCase()}
                        </span>
                        ${skill.comboThreshold ? `<span style="background: rgba(255, 152, 0, 0.3); color: #ff9800; padding: 3px 8px; border-radius: 4px; font-weight: 700;">COMBO: ${skill.comboThreshold}</span>` : ''}
                        ${skill.aoe ? `<span style="background: rgba(244, 67, 54, 0.3); color: #f44336; padding: 3px 8px; border-radius: 4px; font-weight: 700;">AOE: ${skill.aoe}</span>` : ''}
                      </div>
                      
                      <!-- Special Effects -->
                      ${skill.lifesteal || skill.heal || skill.slow || skill.dot ? `
                        <div style="display: flex; flex-wrap: wrap; gap: 4px; font-size: 9px;">
                          ${skill.lifesteal ? `<span style="background: rgba(255, 77, 79, 0.3); color: #ff4d4f; padding: 2px 6px; border-radius: 4px;">ğŸ©¸ Lifesteal: ${skill.lifesteal}%</span>` : ''}
                          ${skill.heal ? `<span style="background: rgba(76, 175, 80, 0.3); color: #4caf50; padding: 2px 6px; border-radius: 4px;">ğŸ’š Heal: ${skill.heal}</span>` : ''}
                          ${skill.slow ? `<span style="background: rgba(33, 150, 243, 0.3); color: #2196f3; padding: 2px 6px; border-radius: 4px;">â„ï¸ Slow: ${skill.slow}%</span>` : ''}
                          ${skill.dot ? `<span style="background: rgba(156, 39, 176, 0.3); color: #9c27b0; padding: 2px 6px; border-radius: 4px;">â˜ ï¸ DoT: ${skill.dot}</span>` : ''}
                        </div>
                      ` : ''}
                      ${skill.shape === 'summon' && skill.summonStats ? `
                        <div style="margin-top: 8px; display: flex; gap: 12px; font-size: 10px; color: rgba(196, 255, 208, 0.85);">
                          <div>ğŸ›¡ï¸ HP: <span style="font-weight: 700;">${skill.summonStats.hp ?? 'â€”'}</span></div>
                          <div>âš”ï¸ DMG: <span style="font-weight: 700;">${skill.summonStats.damage ?? 'â€”'}</span></div>
                          <div>ğŸš€ SPD: <span style="font-weight: 700;">${skill.summonStats.speed ?? 'â€”'}</span></div>
                        </div>
                      ` : ''}
                    </div>
                  `;
                }).join('')}
              </div>
            `;
          };

          // No auto-equipping - players equip manually

          pane.innerHTML = `
            <!-- Character Selector Tabs -->
            <div style="display: flex; gap: 6px; margin-bottom: 12px;">
              ${['A1', 'MISSY', 'UNIQUE'].map(char => `
                <button onclick="window.BagSystem.handleCharacterSwitch('${char}');" 
                  style="flex: 1; padding: 8px 12px;
                    background: ${activeCharacter === char ? 'linear-gradient(135deg, #4fc3f7, #38ef7d)' : 'rgba(0, 0, 0, 0.3)'};
                    border: 2px solid ${activeCharacter === char ? '#4fc3f7' : 'rgba(79, 195, 247, 0.4)'};
                    border-radius: 6px; color: white; font-size: 11px; font-weight: 700; cursor: pointer; transition: all 0.2s;">
                  ${char === 'A1' ? 'âš”ï¸ A1' : char === 'MISSY' ? 'ğŸŒ™ MISSY' : 'âš¡ UNIQUE'}
                </button>
              `).join('')}
            </div>

            <!-- Compact Skill Slots (S1, S2, S3 only) -->
            <div style="background: linear-gradient(135deg, rgba(79, 195, 247, 0.1), rgba(56, 239, 125, 0.1));
                        border: 2px solid rgba(79, 195, 247, 0.5); border-radius: 10px; padding: 12px; margin-bottom: 16px;">
              <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;">
                <h3 style="color: #4fc3f7; font-size: 12px; margin: 0;">âš¡ ${activeCharacter} Skill Slots</h3>
                <div style="font-size: 8px; color: rgba(207, 227, 255, 0.6);">Click to select â€¢ Double-click to unequip</div>
              </div>
              <div style="display: flex; gap: 10px; justify-content: center;">
                ${['S1','S2','S3'].map(renderSkillSlot).join('')}
              </div>
            </div>

            <!-- Skills List -->
            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
              <h3 style="font-size: 14px; color: #ffd77a; margin: 0;">ğŸ“œ ${activeCharacter} Skills (${characterSkills.length})</h3>
              <button onclick="window.BagSystem.toggleSkillAnalytics()" 
                      style="padding: 6px 12px; background: linear-gradient(135deg, rgba(167, 139, 250, 0.3), rgba(79, 195, 247, 0.3)); 
                             border: 2px solid rgba(167, 139, 250, 0.5); border-radius: 6px; color: #a78bfa; 
                             font-size: 10px; font-weight: 700; cursor: pointer; transition: all 0.2s;">
                ğŸ“Š Analytics
              </button>
            </div>
            ${this.state.showSkillAnalytics ? this.renderSkillAnalytics(activeCharacter, characterSkills) : ''}
            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: 8px;">
              ${characterSkills.map(renderSkillCard).join('')}
            </div>
          `;
        },

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // UNIVERSAL ITEM CARD RENDERER - with BOND/ENHANCE/MERGE buttons + Quantity badges
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        getItemQuantity(itemId, itemType) {
          let count = 0;
          const inventoryMap = {
            'pet': window.gameState.inventory.pets,
            'spirit': window.gameState.inventory.spirits,
            'vehicle': window.gameState.inventory.vehicles,
            'robot': window.gameState.inventory.robots,
            'power': window.gameState.inventory.powers,
            'gear': window.gameState.inventory.gear
          };
          
          const inventory = inventoryMap[itemType];
          if (!inventory) return 0;
          
          inventory.forEach(item => {
            if (item.id === itemId || item.id.includes(itemId)) {
              count++;
            }
          });
          
          return count;
        },

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SKILL MANAGEMENT - Per-Character Equip/Unequip
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        /**
         * Keeps the authoritative character pointer stable. Saves get creative sometimes,
         * so this defender snaps missing/invalid entries back to A1 so the dual structures stay aligned.
         */
        ensureCurrentCharacter() {
          const gs = window.gameState = window.gameState || {};
          const validCharacters = ['A1', 'MISSY', 'UNIQUE'];
          const fallback = 'A1';
          let current = gs.currentCharacter;

          if (!current || !validCharacters.includes(current)) {
            current = fallback;
            gs.currentCharacter = fallback;
            debugWarn('[BagSystem] currentCharacter missing or invalid. Defaulting to A1.');
          }

          if (!this.state.activeCharacter || !validCharacters.includes(this.state.activeCharacter)) {
            this.state.activeCharacter = current;
          }

          return current;
        },

        /**
         * Mirrors the per-character loadout into the global quick slots so the HUD always reflects the active hero.
         */
        syncQuickSlotsToCharacter(characterId) {
          const gs = window.gameState = window.gameState || {};
          const equipped = gs.equippedSkills;
          if (!equipped || !equipped[characterId]) return;

          const characterLoadout = equipped[characterId];
          const quickSlotKeys = ['slot1', 'slot2', 'slot3'];
          const characterSlotKeys = ['S1', 'S2', 'S3'];

          characterSlotKeys.forEach((slotKey, index) => {
            const quickSlotKey = quickSlotKeys[index];
            equipped[quickSlotKey] = characterLoadout[slotKey] || null;
          });
        },

        /**
         * When global quick slots change externally we need to write that context back to the hero storage.
         */
        syncCharacterLoadoutFromQuickSlots(characterId) {
          const gs = window.gameState = window.gameState || {};
          const equipped = gs.equippedSkills;
          if (!equipped) return;

          const quickSlotKeys = ['slot1', 'slot2', 'slot3'];
          const characterSlotKeys = ['S1', 'S2', 'S3'];

          if (!equipped[characterId]) {
            equipped[characterId] = {};
          }
          const slotOrder = this.CHARACTER_SKILL_SLOTS || ['S1', 'S2', 'S3', 'S4', 'S5', 'X1', 'X2'];
          slotOrder.forEach(slotKey => {
            if (!(slotKey in equipped[characterId])) {
              equipped[characterId][slotKey] = null;
            }
          });

          characterSlotKeys.forEach((slotKey, index) => {
            const quickSlotKey = quickSlotKeys[index];
            const quickSlotSkill = equipped[quickSlotKey];

            if (quickSlotSkill && quickSlotSkill.characterId === characterId) {
              equipped[characterId][slotKey] = quickSlotSkill;
            }
          });
        },

        /**
         * Ensures all equipped references point to the latest skill instance (inventory source of truth).
         */
        refreshEquippedSkillReferences(updatedSkill) {
          if (!updatedSkill) return;
          const gs = window.gameState = window.gameState || {};
          const equipped = gs.equippedSkills;
          if (!equipped) return;

          const matches = (candidate) => {
            if (!candidate) return false;
            if (updatedSkill.instance_id && candidate.instance_id) {
              return candidate.instance_id === updatedSkill.instance_id;
            }
            return candidate.id === updatedSkill.id;
          };

          Object.entries(equipped).forEach(([key, value]) => {
            if (['slot1', 'slot2', 'slot3'].includes(key)) {
              if (matches(value)) {
                equipped[key] = updatedSkill;
              }
              return;
            }

            if (value && typeof value === 'object') {
              Object.keys(value).forEach(slotKey => {
                if (matches(value[slotKey])) {
                  value[slotKey] = updatedSkill;
                }
              });
            }
          });
        },

        /**
         * Controlled character switching entry point so we always sync the HUD + storage layers in tandem.
         */
        handleCharacterSwitch(characterId) {
          const validCharacters = ['A1', 'MISSY', 'UNIQUE'];
          if (!validCharacters.includes(characterId)) {
            debugWarn('[BagSystem] Ignoring character switch because id is invalid:', characterId);
            return;
          }

          this.ensureCurrentCharacter();
          window.gameState.currentCharacter = characterId;
          this.state.activeCharacter = characterId;
          this.syncQuickSlotsToCharacter(characterId);
          this.renderSkillsTab();
        },

        /**
         * Migrates any legacy equippedSkills payloads (pre-per-character) into the dual structure.
         */
        migrateLegacyEquippedSkills(rawEquipped) {
          const cloneSkill = (skill) => (skill ? { ...skill } : null);
          const slotKeys = this.CHARACTER_SKILL_SLOTS || ['S1', 'S2', 'S3', 'S4', 'S5', 'X1', 'X2'];
          const buildEmptyLoadout = () => {
            const loadout = {};
            slotKeys.forEach(slotKey => {
              loadout[slotKey] = null;
            });
            return loadout;
          };
          const result = {
            A1: buildEmptyLoadout(),
            MISSY: buildEmptyLoadout(),
            UNIQUE: buildEmptyLoadout(),
            slot1: null,
            slot2: null,
            slot3: null
          };

          if (!rawEquipped || typeof rawEquipped !== 'object') {
            return result;
          }

          try {
            ['A1', 'MISSY', 'UNIQUE'].forEach(charId => {
              const payload = rawEquipped[charId] || {};
              slotKeys.forEach(slotKey => {
                result[charId][slotKey] = cloneSkill(payload[slotKey] || null);
              });
            });

            ['slot1', 'slot2', 'slot3'].forEach(slotKey => {
              if (rawEquipped[slotKey]) {
                result[slotKey] = cloneSkill(rawEquipped[slotKey]);
              }
            });

            const characterSlots = ['S1', 'S2', 'S3'];
            ['slot1', 'slot2', 'slot3'].forEach(slotKey => {
              const skill = result[slotKey];
              if (!skill || !skill.characterId) return;
              const charId = skill.characterId;
              if (!result[charId]) return;

              const existingSlotKey = characterSlots.find(key => result[charId][key]?.id === skill.id);
              if (existingSlotKey) {
                result[charId][existingSlotKey] = cloneSkill(skill);
                return;
              }

              const emptySlotKey = characterSlots.find(key => !result[charId][key]);
              if (emptySlotKey) {
                result[charId][emptySlotKey] = cloneSkill(skill);
              }
            });
          } catch (error) {
            debugWarn('[BagSystem] migrateLegacyEquippedSkills encountered an issue, falling back to safe defaults.', error);
          }

          return result;
        },
        
        selectSkillSlot(slotKey) {
          this.state.selectedSkillSlot = slotKey;
          this.renderSkillsTab();
          this.showToast(`Selected slot ${slotKey} - Click any skill to equip`);
        },

        equipSkillToCharacter(skillId, slot, character) {
          const skills = window.gameState.inventory.skills || [];
          const skill = skills.find(s => s.id === skillId);
          
          if (!skill) {
            this.showToast('âŒ Skill not found!');
            return;
          }

          // Check if skill belongs to this character
          if (skill.characterId !== character) {
            this.showToast(`âŒ ${skill.name} belongs to ${skill.characterId}, not ${character}!`);
            debugWarn('[BagSystem] Equip prevented due to character mismatch:', {
              requestedCharacter: character,
              skillCharacter: skill.characterId,
              skillId: skill.id
            });
            return;
          }

          // Equip to slot
          if (!window.gameState.equippedSkills[character]) {
            window.gameState.equippedSkills[character] = {};
          }
          const charSlotOrder = this.CHARACTER_SKILL_SLOTS || ['S1', 'S2', 'S3', 'S4', 'S5', 'X1', 'X2'];
          charSlotOrder.forEach(slotKey => {
            if (!(slotKey in window.gameState.equippedSkills[character])) {
              window.gameState.equippedSkills[character][slotKey] = null;
            }
          });

          window.gameState.equippedSkills[character][slot] = skill;

          // Keep HUD quick slots mirrored when editing the active hero.
          const activeCharacter = this.state.activeCharacter || this.ensureCurrentCharacter();
          if (activeCharacter === character) {
            this.syncQuickSlotsToCharacter(character);
          }
          
          // Track analytics
          this.recordSkillEquip(skillId, character, slot);
          
          this.showToast(`âœ… Equipped ${skill.icon} ${skill.name} to ${character} ${slot}!`);
          debugLog(`[SKILL EQUIP] ${character} ${slot}: ${skill.name}`);
          
          this.renderSkillsTab();
        },

        unequipSkillFromCharacter(slot, character) {
          if (!window.gameState.equippedSkills[character]) return;
          
          const skill = window.gameState.equippedSkills[character][slot];
          if (!skill) return;
          
          // Track analytics
          this.recordSkillUnequip(skill.id, character, slot);
          
          window.gameState.equippedSkills[character][slot] = null;
          
          this.showToast(`ğŸ”“ Unequipped ${skill.icon} ${skill.name} from ${character} ${slot}`);
          debugLog(`[SKILL UNEQUIP] ${character} ${slot}: ${skill.name} removed`);
          
          this.renderSkillsTab();
        },

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // SKILL USAGE ANALYTICS - Track equip/unequip events for recommendations
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        /**
         * Initialize skill usage analytics if not present.
         */
        initSkillUsageAnalytics() {
          if (!window.gameState.skillUsageAnalytics) {
            window.gameState.skillUsageAnalytics = {};
          }
        },

        /**
         * Record when a skill is equipped.
         */
        recordSkillEquip(skillId, characterId, slot) {
          this.initSkillUsageAnalytics();
          const analytics = window.gameState.skillUsageAnalytics;
          
          if (!analytics[skillId]) {
            analytics[skillId] = {
              equipCount: 0,
              unequipCount: 0,
              lastEquipped: null,
              lastUnequipped: null,
              totalEquipDuration: 0,
              equipStartTime: null,
              characters: {},
              slots: {}
            };
          }
          
          const skillStats = analytics[skillId];
          skillStats.equipCount = (skillStats.equipCount || 0) + 1;
          skillStats.lastEquipped = Date.now();
          skillStats.equipStartTime = Date.now();
          
          // Track per-character usage
          if (!skillStats.characters[characterId]) {
            skillStats.characters[characterId] = 0;
          }
          skillStats.characters[characterId]++;
          
          // Track per-slot usage
          if (!skillStats.slots[slot]) {
            skillStats.slots[slot] = 0;
          }
          skillStats.slots[slot]++;
        },

        /**
         * Record when a skill is unequipped.
         */
        recordSkillUnequip(skillId, characterId, slot) {
          this.initSkillUsageAnalytics();
          const analytics = window.gameState.skillUsageAnalytics;
          
          if (!analytics[skillId]) {
            analytics[skillId] = {
              equipCount: 0,
              unequipCount: 0,
              lastEquipped: null,
              lastUnequipped: null,
              totalEquipDuration: 0,
              equipStartTime: null,
              characters: {},
              slots: {}
            };
          }
          
          const skillStats = analytics[skillId];
          skillStats.unequipCount = (skillStats.unequipCount || 0) + 1;
          skillStats.lastUnequipped = Date.now();
          
          // Calculate duration if equip time exists
          if (skillStats.equipStartTime) {
            const duration = Date.now() - skillStats.equipStartTime;
            skillStats.totalEquipDuration = (skillStats.totalEquipDuration || 0) + duration;
            skillStats.equipStartTime = null;
          }
        },

        /**
         * Get usage statistics for a specific skill.
         */
        getSkillUsageStats(skillId) {
          this.initSkillUsageAnalytics();
          return window.gameState.skillUsageAnalytics[skillId] || {
            equipCount: 0,
            unequipCount: 0,
            lastEquipped: null,
            lastUnequipped: null,
            totalEquipDuration: 0,
            characters: {},
            slots: {}
          };
        },

        /**
         * Get list of underused skills for a character.
         * Returns skills that have been equipped fewer times than the threshold.
         */
        getUnderusedSkills(characterId, threshold = 0) {
          this.initSkillUsageAnalytics();
          const skills = window.gameState.inventory.skills || [];
          const characterSkills = skills.filter(s => s.characterId === characterId);
          const analytics = window.gameState.skillUsageAnalytics || {};
          
          return characterSkills.filter(skill => {
            const stats = analytics[skill.id];
            const equipCount = stats?.equipCount || 0;
            return equipCount <= threshold;
          });
        },

        /**
         * Toggle the skill analytics overlay visibility.
         */
        toggleSkillAnalytics() {
          this.state.showSkillAnalytics = !this.state.showSkillAnalytics;
          this.renderSkillsTab();
        },

        /**
         * Render the skill analytics overlay showing usage statistics and recommendations.
         */
        renderSkillAnalytics(characterId, characterSkills) {
          this.initSkillUsageAnalytics();
          const analytics = window.gameState.skillUsageAnalytics || {};
          
          // Get most used and least used skills
          const skillsWithStats = characterSkills.map(skill => {
            const stats = analytics[skill.id] || {};
            return {
              ...skill,
              equipCount: stats.equipCount || 0,
              lastEquipped: stats.lastEquipped || null,
              totalEquipDuration: stats.totalEquipDuration || 0
            };
          });
          
          const mostUsed = [...skillsWithStats].sort((a, b) => b.equipCount - a.equipCount).slice(0, 5);
          const leastUsed = [...skillsWithStats].filter(s => s.equipCount <= 2).sort((a, b) => a.equipCount - b.equipCount);
          const underused = this.getUnderusedSkills(characterId, 2);
          
          return `
            <div style="background: linear-gradient(135deg, rgba(167, 139, 250, 0.15), rgba(79, 195, 247, 0.15)); 
                        border: 2px solid rgba(167, 139, 250, 0.4); border-radius: 12px; padding: 16px; margin-bottom: 16px;">
              <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                <h4 style="color: #a78bfa; font-size: 13px; margin: 0;">ğŸ“Š Skill Usage Analytics</h4>
                <button onclick="window.BagSystem.toggleSkillAnalytics()" 
                        style="padding: 4px 8px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(167, 139, 250, 0.4); 
                               border-radius: 4px; color: #a78bfa; font-size: 9px; cursor: pointer;">âœ•</button>
              </div>
              
              <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px;">
                <!-- Most Used Skills -->
                <div>
                  <div style="font-size: 11px; color: #4fc3f7; font-weight: 700; margin-bottom: 8px;">ğŸ”¥ Most Used</div>
                  ${mostUsed.length > 0 ? mostUsed.map(skill => `
                    <div style="background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(79, 195, 247, 0.3); 
                                border-radius: 6px; padding: 6px; margin-bottom: 4px; font-size: 9px;">
                      <div style="display: flex; align-items: center; gap: 6px;">
                        <span>${skill.icon}</span>
                        <span style="color: #fff; flex: 1;">${skill.name}</span>
                        <span style="color: #4fc3f7; font-weight: 700;">${skill.equipCount}x</span>
                      </div>
                    </div>
                  `).join('') : '<div style="font-size: 9px; color: rgba(207, 227, 255, 0.4);">No data yet</div>'}
                </div>
                
                <!-- Underused Skills -->
                <div>
                  <div style="font-size: 11px; color: #ff9800; font-weight: 700; margin-bottom: 8px;">âš ï¸ Underused</div>
                  ${underused.length > 0 ? underused.slice(0, 5).map(skill => {
                    const stats = analytics[skill.id] || {};
                    const equipCount = stats.equipCount || 0;
                    return `
                      <div style="background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(255, 152, 0, 0.3); 
                                  border-radius: 6px; padding: 6px; margin-bottom: 4px; font-size: 9px;">
                        <div style="display: flex; align-items: center; gap: 6px;">
                          <span>${skill.icon}</span>
                          <span style="color: #fff; flex: 1;">${skill.name}</span>
                          <span style="color: #ff9800; font-weight: 700;">${equipCount}x</span>
                        </div>
                        ${equipCount === 0 ? '<div style="font-size: 7px; color: #4cd137; margin-top: 2px;">âœ¨ Never equipped - Try it!</div>' : ''}
                      </div>
                    `;
                  }).join('') : '<div style="font-size: 9px; color: rgba(207, 227, 255, 0.4);">All skills well-used!</div>'}
                </div>
              </div>
              
              ${underused.length > 0 ? `
                <div style="margin-top: 12px; padding: 8px; background: rgba(255, 152, 0, 0.1); border-left: 3px solid #ff9800; 
                            border-radius: 4px; font-size: 9px; color: rgba(207, 227, 255, 0.8);">
                  ğŸ’¡ <strong>Recommendation:</strong> Try equipping ${underused[0]?.name || 'underused skills'} - you haven't used ${underused[0]?.equipCount === 0 ? 'it' : 'them'} much yet!
                </div>
              ` : ''}
            </div>
          `;
        },

        // Deleted old render function - replaced with compact multi-character system
        
        renderAlchemyTab() {
          const pane = document.getElementById('bagContentPane');
          const alchemy = window.gameState.alchemy || {};
          const upgrades = window.gameState.alchemyUpgrades;
          const currentTier = upgrades.currentTier;
          const tierInfo = this.ALCHEMY_TIER_COSTS[currentTier];
          const allItems = [...(window.gameState.inventory.items || []), ...(window.gameState.inventory.gear || [])];

          pane.innerHTML = `
            <!-- Alchemy upgrade UI -->
            <div style="background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(167, 139, 250, 0.2)); border: 3px solid ${tierInfo.color}; border-radius: 16px; padding: 20px; margin-bottom: 20px;">
              <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <div>
                  <h3 style="color: ${tierInfo.color}; font-size: 18px; font-weight: 700; margin-bottom: 5px;">
                    ğŸ“ ${tierInfo.name} (Tier ${currentTier}/5)
                  </h3>
                  <p style="color: rgba(207, 227, 255, 0.8); font-size: 11px;">
                    Crafts: ${upgrades.craftCount} | Investment: ${upgrades.totalSpent.toLocaleString()}g
                  </p>
                </div>
                <div style="text-align: right;">
                  <div style="color: #4fc3f7; font-size: 10px; margin-bottom: 5px;">Success Rates:</div>
                  <div style="display: flex; gap: 8px; font-size: 9px;">
                    <span style="color: #ffd700;">â­${Math.round(this.OUTCOME_PROBABILITIES[`tier${currentTier}`].perfect * 100)}%</span>
                    <span style="color: #38ef7d;">âœ¨${Math.round(this.OUTCOME_PROBABILITIES[`tier${currentTier}`].great * 100)}%</span>
                    <span style="color: #4fc3f7;">âœ“${Math.round(this.OUTCOME_PROBABILITIES[`tier${currentTier}`].good * 100)}%</span>
                    <span style="color: #ff6b6b;">âš ï¸${Math.round(this.OUTCOME_PROBABILITIES[`tier${currentTier}`].failure * 100)}%</span>
                  </div>
                </div>
              </div>
              
              <!-- Tier Upgrade Buttons -->
              <div style="display: flex; gap: 8px; overflow-x: auto; padding: 10px 0;">
                ${[1,2,3,4,5].map(tier => {
                  const tData = this.ALCHEMY_TIER_COSTS[tier];
                  const isUnlocked = upgrades.unlockedTiers.includes(tier);
                  const isCurrent = tier === currentTier;
                  const canAfford = window.gameState.gold >= tData.cost;
                  const requiresPrevious = tier > 1 && !upgrades.unlockedTiers.includes(tier - 1);
                  const isDisabled = isUnlocked || !canAfford || requiresPrevious;
                  
                  return `
                    <button 
                      onclick="window.BagSystem.upgradeAlchemyTier(${tier})"
                      ${isDisabled ? 'disabled' : ''}
                      style="
                        flex: 1;
                        min-width: 120px;
                        padding: 10px 12px;
                        background: ${isCurrent ? `linear-gradient(135deg, ${tData.color}, rgba(255,255,255,0.2))` : isUnlocked ? 'rgba(0,0,0,0.5)' : canAfford && !requiresPrevious ? 'rgba(56, 239, 125, 0.2)' : 'rgba(0,0,0,0.3)'};
                        border: 2px solid ${isCurrent ? tData.color : isUnlocked ? 'rgba(79, 195, 247, 0.3)' : canAfford && !requiresPrevious ? '#38ef7d' : 'rgba(255,255,255,0.2)'};
                        border-radius: 8px;
                        color: ${isUnlocked ? 'rgba(255,255,255,0.5)' : requiresPrevious ? 'rgba(255,107,53,0.6)' : 'white'};
                        cursor: ${isDisabled ? 'not-allowed' : 'pointer'};
                        transition: all 0.2s;
                      "
                    >
                      <div style="font-size: 10px; font-weight: 700; margin-bottom: 4px;">${tData.name}</div>
                      <div style="font-size: 8px; opacity: 0.8;">${isUnlocked ? 'âœ… Unlocked' : requiresPrevious ? 'ğŸ”’ Locked' : `${tData.cost.toLocaleString()}g`}</div>
                    </button>
                  `;
                }).join('')}
              </div>
              
              ${currentTier < 5 ? `
              <!-- Unlock All Button -->
              <div style="margin-top: 10px; text-align: center;">
                <button 
                  onclick="window.BagSystem.upgradeAllAlchemyTiers()"
                  style="
                    padding: 12px 24px;
                    background: linear-gradient(135deg, #ffd700, #ff6b35);
                    border: 2px solid #ffd700;
                    border-radius: 10px;
                    color: #000;
                    font-weight: 700;
                    font-size: 11px;
                    cursor: pointer;
                    transition: all 0.2s;
                    box-shadow: 0 4px 12px rgba(255, 215, 0, 0.4);
                  "
                  onmouseover="this.style.transform='scale(1.05)'"
                  onmouseout="this.style.transform='scale(1)'"
                >
                  ğŸš€ Unlock All Remaining Tiers
                  ${(() => {
                    let totalCost = 0;
                    for (let t = currentTier + 1; t <= 5; t++) {
                      if (!upgrades.unlockedTiers.includes(t)) {
                        totalCost += this.ALCHEMY_TIER_COSTS[t].cost;
                      }
                    }
                    return totalCost > 0 ? `(${totalCost.toLocaleString()}g)` : '';
                  })()}
                </button>
              </div>
              ` : ''}
              
              <!-- Tier Benefits -->
              <div style="background: rgba(0, 0, 0, 0.4); padding: 12px; border-radius: 8px; margin-top: 12px; border: 1px solid rgba(79, 195, 247, 0.3);">
                <div style="font-size: 10px; color: #4fc3f7; font-weight: 700; margin-bottom: 6px;">Current Bonuses:</div>
                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 8px; font-size: 9px; color: rgba(207, 227, 255, 0.8);">
                  <div>ğŸ’ Affix Chance: <span style="color: #ffd700;">${Math.round(upgrades.bonusRates.rareAffixChance * 100)}%</span></div>
                  <div>ğŸ² Double Output: <span style="color: #ffd700;">${Math.round(upgrades.bonusRates.doubleOutputChance * 100)}%</span></div>
                  <div>ğŸ Combos Available: <span style="color: #ffd700;">${currentTier >= 3 ? '35+' : currentTier >= 2 ? '20+' : '10+'}</span></div>
                  <div>âœ¨ Recipe Quality: <span style="color: #ffd700;">${tierInfo.name}</span></div>
                </div>
              </div>
              
              <!-- Recipe Discovery -->
              <div style="background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(167, 139, 250, 0.1)); padding: 12px; border-radius: 8px; margin-top: 12px; border: 2px solid rgba(255, 215, 0, 0.4);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                  <div style="font-size: 11px; color: #ffd700; font-weight: 700;">ğŸ“– Recipe Discovery</div>
                  <div style="font-size: 9px; color: rgba(207, 227, 255, 0.8);">
                    <span style="color: #38ef7d; font-weight: 700;">${upgrades.discoveredRecipes.length}</span> / ${currentTier >= 5 ? '50+' : currentTier >= 4 ? '40+' : currentTier >= 3 ? '30+' : currentTier >= 2 ? '20+' : '10+'} Discovered
                  </div>
                </div>
                <div style="font-size: 8px; color: rgba(207, 227, 255, 0.7); line-height: 1.4;">
                  Discover new recipes by combining different items! Each tier unlocks more powerful combinations.
                  ${currentTier < 5 ? `<br><span style="color: #ffd700;">ğŸ’¡ Hint: Upgrade to higher tiers to unlock tier-exclusive recipes!</span>` : ''}
                </div>
                ${upgrades.discoveredRecipes.length > 0 ? `
                <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(255, 215, 0, 0.2);">
                  <div style="font-size: 8px; color: rgba(207, 227, 255, 0.6); margin-bottom: 6px;">Recently Discovered:</div>
                  <div style="display: flex; flex-wrap: wrap; gap: 4px;">
                    ${upgrades.discoveredRecipes.slice(-5).reverse().map(recipe => {
                      const recipeName = recipe.replace('combo_', '').replace('evolution_', '').substring(0, 20);
                      return `<span style="background: rgba(255, 215, 0, 0.2); color: #ffd700; padding: 2px 6px; border-radius: 4px; font-size: 7px; border: 1px solid rgba(255, 215, 0, 0.3);">${recipeName}</span>`;
                    }).join('')}
                  </div>
                </div>
                ` : ''}
              </div>
            </div>
            
            <!-- â•â•â• TOP SECTION: FUSION WORKSPACE â•â•â• -->
            <div style="background: rgba(0, 0, 0, 0.4); border: 3px solid rgba(167, 139, 250, 0.6); border-radius: 16px; padding: 24px; margin-bottom: 24px; box-shadow: 0 8px 24px rgba(167, 139, 250, 0.2);">
              <h2 style="color: #a78bfa; font-size: 20px; margin-bottom: 20px; text-align: center; display: flex; align-items: center; justify-content: center; gap: 8px;">
                âš—ï¸ Fusion Workspace
              </h2>
              
              <!-- Slots Row -->
              <div style="display: flex; align-items: center; gap: 16px; justify-content: center; margin-bottom: 24px; flex-wrap: wrap;">
                ${[0, 1, 2].map(slotIndex => {
            const slotItem = this.state.alchemySlots[slotIndex];
            return `
                    <div class="alchemy-slot" data-slot="${slotIndex}" style="width: 100px; height: 110px; background: rgba(0, 0, 0, 0.5); border: 3px dashed rgba(255, 255, 255, 0.4); border-radius: 12px; display: flex; flex-direction: column; align-items: center; justify-content: center; cursor: pointer; transition: all 0.3s ease; position: relative;">
                      ${slotItem ? `
                        <div style="font-size: 32px; filter: drop-shadow(0 0 8px rgba(167, 139, 250, 0.6));">${slotItem.icon}</div>
                        <div style="font-size: 9px; color: #cfe3ff; margin-top: 6px; font-weight: 600; text-align: center; max-width: 90px; overflow: hidden; text-overflow: ellipsis;">${slotItem.name}</div>
                        <div style="position: absolute; top: 4px; right: 4px; font-size: 14px; color: rgba(255, 107, 53, 0.8); cursor: pointer;" onclick="event.stopPropagation(); window.BagSystem.removeFromAlchemySlot(${slotIndex})">âœ•</div>
                      ` : `
                        <div style="font-size: 28px; opacity: 0.3;">â“</div>
                        <div style="font-size: 8px; color: rgba(207, 227, 255, 0.4); margin-top: 6px;">Slot ${slotIndex + 1}</div>
                      `}
                    </div>
                  `;
          }).join('')}
                
                <!-- Arrow -->
                <div style="font-size: 32px; color: #ffd77a; font-weight: 700;">â†’</div>
                
                <!-- Result Slot -->
                <div class="alchemy-result" style="width: 110px; height: 120px; background: linear-gradient(135deg, rgba(255, 215, 122, 0.2), rgba(255, 107, 53, 0.2)), rgba(0, 0, 0, 0.5); border: 3px solid rgba(255, 215, 122, 0.7); border-radius: 12px; display: flex; flex-direction: column; align-items: center; justify-content: center; box-shadow: 0 0 20px rgba(255, 215, 122, 0.3);">
                  ${this.state.alchemyResult ? `
                    <div style="font-size: 36px; filter: drop-shadow(0 0 12px rgba(255, 215, 122, 0.8));">${this.state.alchemyResult.icon}</div>
                    <div style="font-size: 10px; color: #ffd77a; margin-top: 8px; font-weight: 700; text-align: center; max-width: 100px; overflow: hidden; text-overflow: ellipsis;">${this.state.alchemyResult.name}</div>
                  ` : `
                    <div style="font-size: 32px; opacity: 0.3;">âœ¨</div>
                    <div style="font-size: 8px; color: rgba(207, 227, 255, 0.4); margin-top: 6px;">Result</div>
                  `}
                </div>
              </div>

              <!-- Outcome probability display -->
              ${this.state.alchemyResult ? `
              <div style="background: rgba(0, 0, 0, 0.4); padding: 12px; border-radius: 8px; margin-bottom: 15px; border: 1px solid rgba(79, 195, 247, 0.3);">
                <div style="font-size: 10px; color: #4fc3f7; font-weight: 700; margin-bottom: 8px; text-align: center;">Craft Outcome Probabilities:</div>
                <div style="display: flex; justify-content: space-around; font-size: 9px;">
                  <div style="text-align: center;">
                    <div style="color: #ffd700; font-size: 18px;">â­</div>
                    <div style="color: #ffd700;">Perfect</div>
                    <div style="color: rgba(255, 255, 255, 0.7);">${Math.round(this.OUTCOME_PROBABILITIES['tier' + currentTier].perfect * 100)}%</div>
                    <div style="color: rgba(255, 255, 255, 0.5); font-size: 7px;">+25% stats</div>
                  </div>
                  <div style="text-align: center;">
                    <div style="color: #38ef7d; font-size: 18px;">âœ¨</div>
                    <div style="color: #38ef7d;">Great</div>
                    <div style="color: rgba(255, 255, 255, 0.7);">${Math.round(this.OUTCOME_PROBABILITIES['tier' + currentTier].great * 100)}%</div>
                    <div style="color: rgba(255, 255, 255, 0.5); font-size: 7px;">+15% stats</div>
                  </div>
                  <div style="text-align: center;">
                    <div style="color: #4fc3f7; font-size: 18px;">âœ“</div>
                    <div style="color: #4fc3f7;">Good</div>
                    <div style="color: rgba(255, 255, 255, 0.7);">${Math.round(this.OUTCOME_PROBABILITIES['tier' + currentTier].good * 100)}%</div>
                    <div style="color: rgba(255, 255, 255, 0.5); font-size: 7px;">normal</div>
                  </div>
                  <div style="text-align: center;">
                    <div style="color: #ff6b6b; font-size: 18px;">âš ï¸</div>
                    <div style="color: #ff6b6b;">Fail</div>
                    <div style="color: rgba(255, 255, 255, 0.7);">${Math.round(this.OUTCOME_PROBABILITIES['tier' + currentTier].failure * 100)}%</div>
                    <div style="color: rgba(255, 255, 255, 0.5); font-size: 7px;">-50% stats</div>
                  </div>
                </div>
                ${upgrades.bonusRates.rareAffixChance > 0 ? `
                <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid rgba(79, 195, 247, 0.2); text-align: center;">
                  <div style="font-size: 9px; color: #ffd700;">
                    ğŸŒŸ Rare Affix Chance: <strong>${Math.round(upgrades.bonusRates.rareAffixChance * 100)}%</strong>
                    ${upgrades.bonusRates.doubleOutputChance > 0 ? '| ğŸ² Double Output: <strong>' + Math.round(upgrades.bonusRates.doubleOutputChance * 100) + '%</strong>' : ''}
                  </div>
                </div>
                ` : ''}
              </div>
              ` : ''}
              
              <!-- Action Buttons -->
              <div style="display: flex; gap: 12px; justify-content: center;">
                <button class="gear-action-btn" onclick="window.BagSystem.performCraft()" ${!this.state.alchemyResult ? 'disabled' : ''} style="background: linear-gradient(135deg, #38ef7d, #4fc3f7); padding: 10px 24px; font-size: 12px; font-weight: 700; border: 2px solid white; box-shadow: 0 4px 12px rgba(56, 239, 125, 0.4);">
                  âœ¨ Craft Now
                </button>
                <button class="gear-action-btn" onclick="window.BagSystem.clearAlchemySlots()" style="background: linear-gradient(135deg, #ff6b35, #ff3b3b); padding: 10px 24px; font-size: 12px; font-weight: 700; border: 2px solid white; box-shadow: 0 4px 12px rgba(255, 107, 53, 0.4);">
                  ğŸ—‘ï¸ Clear
                </button>
              </div>
            </div>

            <!-- â•â•â• MIDDLE SECTION: AVAILABLE ITEMS â•â•â• -->
            <div style="background: rgba(0, 0, 0, 0.3); border: 2px solid rgba(79, 195, 247, 0.4); border-radius: 12px; padding: 20px; margin-bottom: 24px;">
              <h3 style="color: #4fc3f7; font-size: 16px; margin-bottom: 16px; display: flex; align-items: center; gap: 8px;">
                ğŸ“¦ Your Items <span style="font-size: 12px; color: rgba(207, 227, 255, 0.6); font-weight: normal;">(Click to Add to Slot)</span>
              </h3>
              <div class="items-grid" style="max-height: 300px; overflow-y: auto;">
                ${allItems.length === 0 ? `
                  <div style="text-align: center; padding: 40px; color: rgba(207, 227, 255, 0.5);">
                    <div style="font-size: 48px; margin-bottom: 12px;">ğŸ“¦</div>
                    <p>No items available</p>
                  </div>
                ` : allItems.map(item => `
                  <div class="item-card draggable-alchemy-item" data-item-id="${item.id}" style="cursor: pointer;">
                    ${item.quantity ? `<div class="item-quantity">${item.quantity}</div>` : ''}
                    <div class="item-icon" style="font-size: 24px;">${item.icon}</div>
                    <div class="item-name" style="font-size: 8px;">${item.name}</div>
                    ${item.rarity ? `<div style="font-size: 7px; color: rgba(207, 227, 255, 0.6); margin-top: 2px;">${item.rarity}</div>` : ''}
                  </div>
                `).join('')}
              </div>
            </div>

            <!-- â•â•â• BOTTOM SECTION: ALCHEMY INFO â•â•â• -->
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 16px; margin-bottom: 16px;">
              <!-- Fusion System -->
              <div style="background: rgba(0, 0, 0, 0.3); border: 2px solid rgba(122, 213, 255, 0.4); border-radius: 12px; padding: 16px;">
                <h3 style="color: #7ad5ff; margin-bottom: 10px; font-size: 14px;">ğŸ”„ Fusion Alchemy</h3>
                <p style="color: rgba(207, 227, 255, 0.8); margin-bottom: 10px; font-size: 11px; line-height: 1.5;">
                  ${alchemy.fusion?.description || 'Combine 3 items of same type and rank to create 1 of next rank'}
                </p>
                <div style="background: rgba(0, 0, 0, 0.4); padding: 8px; border-radius: 6px; border: 1px solid rgba(122, 213, 255, 0.2);">
                  <div style="font-size: 10px; color: #7ad5ff; font-weight: 700; margin-bottom: 4px;">Example:</div>
                  <div style="font-size: 12px; color: #ffd77a; font-family: monospace;">${alchemy.fusion?.example || 'C+C+C â†’ B'}</div>
                </div>
              </div>

              <!-- Special Recipe -->
              <div style="background: rgba(0, 0, 0, 0.3); border: 2px solid rgba(255, 122, 217, 0.4); border-radius: 12px; padding: 16px;">
                <h3 style="color: #ff7ad9; margin-bottom: 10px; font-size: 14px;">âœ¨ Special Recipe</h3>
                <p style="color: rgba(207, 227, 255, 0.8); margin-bottom: 10px; font-size: 11px; line-height: 1.5;">
                  ${alchemy.special?.description || 'C Gear + B Gear + C Pet for premium loot'}
                </p>
                <div style="background: rgba(0, 0, 0, 0.4); padding: 8px; border-radius: 6px; border: 1px solid rgba(255, 122, 217, 0.2);">
                  <div style="font-size: 10px; color: #ff7ad9; font-weight: 700; margin-bottom: 4px;">Rewards:</div>
                  <div style="display: flex; gap: 6px; flex-wrap: wrap; margin-top: 4px;">
                    ${(alchemy.special?.rewards || ['Premium Gear', 'Rare Pet', 'Gold']).map(reward => `
                      <span style="padding: 4px 8px; background: rgba(255, 122, 217, 0.2); border-radius: 4px; font-size: 9px; color: #ff7ad9;">
                        ${reward}
                      </span>
                    `).join('')}
                  </div>
                </div>
              </div>

              <!-- Generic Alchemy -->
              <div style="background: rgba(0, 0, 0, 0.3); border: 2px solid rgba(122, 248, 200, 0.4); border-radius: 12px; padding: 16px;">
                <h3 style="color: #7af8c8; margin-bottom: 10px; font-size: 14px;">ğŸ Generic Alchemy</h3>
                <p style="color: rgba(207, 227, 255, 0.8); margin-bottom: 10px; font-size: 11px; line-height: 1.5;">
                  ${alchemy.generic?.description || 'Any 3 items â†’ treasure box based on highest rank'}
                </p>
                <div style="background: rgba(0, 0, 0, 0.4); padding: 8px; border-radius: 6px; border: 1px solid rgba(122, 248, 200, 0.2);">
                  <div style="font-size: 10px; color: #7af8c8; font-weight: 700; margin-bottom: 4px;">Example:</div>
                  <div style="font-size: 12px; color: #ffd77a; font-family: monospace;">${alchemy.generic?.example || 'C+B+C â†’ B-Rank Box'}</div>
                </div>
              </div>
            </div>

            <!-- Treasure Box Rewards -->
            <div style="background: rgba(0, 0, 0, 0.3); border: 2px solid rgba(255, 215, 122, 0.4); border-radius: 12px; padding: 16px;">
              <h3 style="color: #ffd77a; margin-bottom: 12px; font-size: 14px;">ğŸ“¦ Treasure Box Rewards</h3>
              <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap: 10px;">
                ${(() => {
              const defaultBoxes = { C: { gold: '500-2K', items: '1-3', rare: '10%' }, B: { gold: '2K-5K', items: '2-5', rare: '20%' }, A: { gold: '5K-10K', items: '3-7', rare: '35%' } };
              const treasureBoxes = alchemy.treasureBoxes || defaultBoxes;
              return Object.keys(treasureBoxes).map(rank => {
                const box = treasureBoxes[rank];
                return '<div style="background: rgba(0, 0, 0, 0.4); border: 1px solid rgba(79, 195, 247, 0.3); border-radius: 8px; padding: 10px;">' +
                  '<div style="font-weight: 700; color: #4fc3f7; margin-bottom: 6px; font-size: 12px;">' + rank + '-Rank Box</div>' +
                  '<div style="font-size: 10px; color: rgba(207, 227, 255, 0.7); line-height: 1.6;">' +
                  'ğŸ’° Gold: ' + (box.gold || '500-2K') + '<br>' +
                  'ğŸ“¦ Items: ' + (box.items || '1-3') + '<br>' +
                  'â­ Bonus: ' + (box.rare || '10%') +
                  '</div></div>';
              }).join('');
            })()}
              </div>
            </div>
          `;

          // Attach item click handlers (with debounce to prevent stuck state)
          let clickTimeout = null;
          pane.querySelectorAll('.draggable-alchemy-item').forEach(itemEl => {
            itemEl.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();

              if (clickTimeout) return;
              clickTimeout = setTimeout(() => {
                clickTimeout = null;
              }, 200);

              const itemId = itemEl.dataset.itemId;
              const item = allItems.find(i => i.id === itemId);
              if (item) {
                // Visual feedback - flash the item
                itemEl.style.opacity = '0.5';
                itemEl.style.transform = 'scale(0.95)';
                setTimeout(() => {
                  if (itemEl) {
                    itemEl.style.opacity = '1';
                    itemEl.style.transform = 'scale(1)';
                  }
                }, 300);

                this.addToAlchemySlot(item);
              }
            });
          });

          // Attach slot click handlers for removing items (with visual feedback)
          pane.querySelectorAll('.alchemy-slot').forEach(slotEl => {
            slotEl.addEventListener('click', (e) => {
              e.preventDefault();
              e.stopPropagation();

              const slotIndex = parseInt(slotEl.dataset.slot);
              if (this.state.alchemySlots[slotIndex]) {
                // Visual feedback - shake the slot
                slotEl.style.transform = 'scale(0.9)';
                setTimeout(() => {
                  if (slotEl) slotEl.style.transform = 'scale(1)';
                }, 200);

                this.removeFromAlchemySlot(slotIndex);
              }
            });
          });
          
          // HTML5 drag-and-drop support
          // Make items draggable
          pane.querySelectorAll('.draggable-alchemy-item').forEach(itemEl => {
            itemEl.draggable = true;
            itemEl.style.cursor = 'grab';
            
            itemEl.addEventListener('dragstart', (e) => {
              const itemId = itemEl.dataset.itemId;
              e.dataTransfer.effectAllowed = 'move';
              e.dataTransfer.setData('text/plain', itemId);
              itemEl.style.opacity = '0.5';
              itemEl.style.cursor = 'grabbing';
            });
            
            itemEl.addEventListener('dragend', (e) => {
              itemEl.style.opacity = '1';
              itemEl.style.cursor = 'grab';
            });
          });
          
          // Make alchemy slots accept drops
          pane.querySelectorAll('.alchemy-slot').forEach(slotEl => {
            slotEl.addEventListener('dragover', (e) => {
              e.preventDefault();
              e.dataTransfer.dropEffect = 'move';
              slotEl.style.borderColor = 'rgba(56, 239, 125, 0.8)';
              slotEl.style.borderStyle = 'solid';
              slotEl.style.transform = 'scale(1.05)';
              slotEl.style.boxShadow = '0 0 20px rgba(56, 239, 125, 0.5)';
            });
            
            slotEl.addEventListener('dragleave', (e) => {
              slotEl.style.borderColor = 'rgba(255, 255, 255, 0.4)';
              slotEl.style.borderStyle = 'dashed';
              slotEl.style.transform = 'scale(1)';
              slotEl.style.boxShadow = 'none';
            });
            
            slotEl.addEventListener('drop', (e) => {
              e.preventDefault();
              const itemId = e.dataTransfer.getData('text/plain');
              const item = allItems.find(i => i.id === itemId);
              
              if (item) {
                const slotIndex = parseInt(slotEl.dataset.slot);
                // Replace item in slot
                this.state.alchemySlots[slotIndex] = item;
                this.calculateAlchemyResult();
                this.renderAlchemyTab();
                this.showToast(`Added ${item.icon} ${item.name} to slot ${slotIndex + 1}`);
              }
              
              // Reset visual
              slotEl.style.borderColor = 'rgba(255, 255, 255, 0.4)';
              slotEl.style.borderStyle = 'dashed';
              slotEl.style.transform = 'scale(1)';
              slotEl.style.boxShadow = 'none';
            });
          });
        },

        renderSpiritTab() {
          const pane = document.getElementById('bagContentPane');
          const equippedSpirit = window.gameState.equipped.spirit;
          let spirits = window.gameState.inventory.spirits || [];

          // Apply filter
          if (this.state.spiritFilter !== 'all') {
            spirits = spirits.filter(s => s.element === this.state.spiritFilter);
          }

          // Apply sort
          if (this.state.spiritSort === 'power') {
            spirits.sort((a, b) => b.power - a.power);
          } else if (this.state.spiritSort === 'name') {
            spirits.sort((a, b) => a.name.localeCompare(b.name));
          }

          const getElementColor = (element) => {
            const colors = {
              dark: '#7c3aed', light: '#ffd93d', gold: '#ffbf3b',
              tech: '#3ec5ff', storm: '#60a5fa', earth: '#d97706',
              fire: '#ff6b35'
            };
            return colors[element] || '#4fc3f7';
          };

          const getRarityColor = (rarity) => {
            const colors = {
              uncommon: '#27ae60', rare: '#3498db',
              epic: '#9b59b6', legendary: '#f39c12'
            };
            return colors[rarity] || '#95a5a6';
          };

          const getBonusDisplay = (bonusType, bonusValue) => {
            if (bonusType === 'atkMul') return `+${(bonusValue * 100).toFixed(0)}% ATK`;
            if (bonusType === 'hpFlat') return `+${bonusValue} HP`;
            if (bonusType === 'goldGain') return `+${(bonusValue * 100).toFixed(0)}% Gold`;
            if (bonusType === 'speedMul') return `+${(bonusValue * 100).toFixed(0)}% Speed`;
            if (bonusType === 'damageTakenMul') return `-${((1 - bonusValue) * 100).toFixed(0)}% Damage Taken`;
            return bonusType;
          };

          pane.innerHTML = `
            ${equippedSpirit ? `
              <div style="background: rgba(0, 0, 0, 0.4); border: 2px solid rgba(167, 139, 250, 0.6); border-radius: 12px; padding: 16px; margin-bottom: 20px; animation: spiritGlow 2s ease-in-out infinite;">
                <h3 style="color: #a78bfa; margin-bottom: 12px; font-size: 16px;">âœ¨ Bonded Spirit</h3>
                <div style="display: flex; align-items: center; gap: 16px; flex-wrap: wrap;">
                  <div style="font-size: 48px;">${equippedSpirit.icon}</div>
                  <div style="flex: 1;">
                    <div style="font-size: 18px; font-weight: 700; color: #a78bfa; margin-bottom: 4px;">${equippedSpirit.name}</div>
                    <div style="font-size: 12px; color: rgba(207, 227, 255, 0.7); margin-bottom: 8px;">${equippedSpirit.description}</div>
                    <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                      <span style="padding: 4px 10px; background: rgba(167, 139, 250, 0.2); border-radius: 6px; font-size: 11px; color: #a78bfa;">
                        âš¡ Power: ${equippedSpirit.power}
                      </span>
                      <span style="padding: 4px 10px; background: rgba(255, 215, 122, 0.2); border-radius: 6px; font-size: 11px; color: #ffd77a;">
                        ğŸ ${getBonusDisplay(equippedSpirit.bonusType, equippedSpirit.bonusValue)}
                      </span>
                      <span style="padding: 4px 10px; background: rgba(255, 107, 53, 0.2); border-radius: 6px; font-size: 11px; color: #ff6b35;">
                        ğŸ’¥ ${equippedSpirit.attackDamage} dmg
                      </span>
                      <span style="padding: 4px 10px; background: ${getElementColor(equippedSpirit.element)}33; border: 1px solid ${getElementColor(equippedSpirit.element)}; border-radius: 6px; font-size: 11px; text-transform: uppercase; color: ${getElementColor(equippedSpirit.element)};">
                        ${equippedSpirit.element}
                      </span>
                    </div>
                  </div>
                  <button class="gear-equip-btn" onclick="window.BagSystem.unequipSpirit()" style="width: auto; padding: 10px 20px;">
                    Release Spirit
                  </button>
                </div>
              </div>
            ` : ''}

            <div class="inventory-header">
              <h3>Spirit Collection (${spirits.length})</h3>
              <div class="filter-sort-controls">
                <div class="filter-chips">
                  <button class="filter-chip ${this.state.spiritFilter === 'all' ? 'active' : ''}" data-filter="all">All</button>
                  <button class="filter-chip ${this.state.spiritFilter === 'dark' ? 'active' : ''}" data-filter="dark">ğŸœ Dark</button>
                  <button class="filter-chip ${this.state.spiritFilter === 'light' ? 'active' : ''}" data-filter="light">â˜€ï¸ Light</button>
                  <button class="filter-chip ${this.state.spiritFilter === 'fire' ? 'active' : ''}" data-filter="fire">ğŸ¦Š Fire</button>
                  <button class="filter-chip ${this.state.spiritFilter === 'tech' ? 'active' : ''}" data-filter="tech">âš¡ Tech</button>
                </div>
                <select class="sort-dropdown" id="spiritSort">
                  <option value="power" ${this.state.spiritSort === 'power' ? 'selected' : ''}>Sort: Power</option>
                  <option value="name" ${this.state.spiritSort === 'name' ? 'selected' : ''}>Sort: Name</option>
                </select>
              </div>
            </div>

            ${spirits.length === 0 ? `
              <div class="tab-empty">
                <div class="empty-icon">âœ¨</div>
                <p>No spirits match filter</p>
              </div>
            ` : `
              <div class="gear-items-grid">
                ${spirits.map(spirit => {
            const isEquipped = equippedSpirit && equippedSpirit.id === spirit.id;
            return `
                    <div class="gear-item-card spirit-card ${isEquipped ? 'equipped-spirit' : ''}" data-spirit-id="${spirit.id}" style="border-color: ${getElementColor(spirit.element)};">
                      ${isEquipped ? '<div style="position: absolute; top: 8px; right: 8px; background: rgba(167, 139, 250, 0.9); color: #fff; padding: 4px 8px; border-radius: 6px; font-size: 10px; font-weight: 700;">BONDED</div>' : ''}
                      <canvas id="spirit_ghost_${spirit.id}" width="48" height="48" style="margin: 0 auto;"></canvas>
                      <div class="gear-item-name">${spirit.name}</div>
                      <div style="font-size: 10px; padding: 3px 8px; background: ${getRarityColor(spirit.rarity)}; border-radius: 6px; margin: 4px 0; text-transform: uppercase; color: #fff;">${spirit.rarity}</div>
                      <div class="gear-item-stats">
                        <span class="stat-badge" style="background: rgba(167, 139, 250, 0.2); color: #a78bfa;">
                          âš¡ ${spirit.power}
                        </span>
                        <span class="stat-badge" style="background: rgba(255, 215, 122, 0.2); color: #ffd77a;">
                          ğŸ ${getBonusDisplay(spirit.bonusType, spirit.bonusValue)}
                        </span>
                      </div>
                      <div style="font-size: 10px; color: ${getElementColor(spirit.element)}; margin: 6px 0; text-transform: uppercase; font-weight: 700;">${spirit.element}</div>
                      <div style="font-size: 9px; color: rgba(255, 107, 53, 0.8); margin-bottom: 4px;">ğŸ’¥ ${spirit.attackDamage} dmg</div>
                      <div style="font-size: 9px; color: rgba(207, 227, 255, 0.5); font-style: italic; margin-bottom: 10px; height: 28px; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical;">
                        ${spirit.description}
                      </div>
                      <div class="spirit-actions" style="display: flex; flex-direction: column; gap: 4px;">
                        <button class="spirit-action-btn bond" data-action="bond" data-spirit-id="${spirit.id}" ${isEquipped ? 'disabled' : ''}>
                          ${isEquipped ? 'Bonded' : 'Bond'}
                        </button>
                        <button class="spirit-action-btn enhance" data-action="enhance" data-spirit-id="${spirit.id}" style="font-size: 9px; padding: 4px 8px;">
                          Enhance
                        </button>
                        <button class="spirit-action-btn merge" data-action="merge" data-spirit-id="${spirit.id}" style="font-size: 9px; padding: 4px 8px;">
                          Merge
                        </button>
                      </div>
                    </div>
                  `;
          }).join('')}
              </div>
            `}
          `;

          // Attach filter listeners
          pane.querySelectorAll('.filter-chip').forEach(chip => {
            chip.addEventListener('click', () => {
              this.state.spiritFilter = chip.dataset.filter;
              this.renderSpiritTab();
            });
          });

          // Attach sort listener
          const sortSelect = pane.querySelector('#spiritSort');
          if (sortSelect) {
            sortSelect.addEventListener('change', (e) => {
              this.state.spiritSort = e.target.value;
              this.renderSpiritTab();
            });
          }

          // Attach spirit action buttons
          pane.querySelectorAll('.spirit-action-btn').forEach(btn => {
            btn.addEventListener('click', () => {
              const action = btn.dataset.action;
              const spiritId = btn.dataset.spiritId;
              const spirit = window.gameState.inventory.spirits.find(s => s.id === spiritId);

              if (action === 'bond' && spirit) this.equipSpirit(spirit);
              else if (action === 'enhance' && spirit) this.enhanceSpirit(spiritId);
              else if (action === 'merge' && spirit) this.mergeSpirits(spiritId);
            });
          });

          // Animate chibi ghost sprites
          const animateGhosts = () => {
            spirits.forEach(spirit => {
              this.drawChibiGhost(`spirit_ghost_${spirit.id}`, spirit.id);
            });
            requestAnimationFrame(animateGhosts);
          };
          setTimeout(() => animateGhosts(), 10);
        },

        renderSupernaturalTab() {
          const pane = document.getElementById('bagContentPane');
          const learnedAbilities = window.gameState.inventory.abilities || [];
          const playerLevel = window.gameState.playerLevel || 1;
          const essence = window.gameState.essence || 0;
          
          // Initialize filter if not set
          if (!this.state.supernaturalFilter) {
            this.state.supernaturalFilter = 'all';
          }
          
          // Get all powers from database
          let allPowers = Object.values(window.SUPERNATURAL_POWERS_DATABASE);
          
          // Apply category filter
          if (this.state.supernaturalFilter !== 'all') {
            allPowers = allPowers.filter(p => p.category === this.state.supernaturalFilter);
          }
          
          // Separate by type and learned status
          const learnedPowers = allPowers.filter(p => learnedAbilities.find(a => a.id === p.id));
          const availablePowers = allPowers.filter(p => !learnedAbilities.find(a => a.id === p.id));

          const formatBonuses = (bonuses) => {
            return Object.entries(bonuses).map(([key, value]) => {
              if (key === 'defense') return `+${value} DEF`;
              if (key === 'attack') return `+${value} ATK`;
              if (key === 'speed') return `+${value} Speed`;
              if (key === 'movementSpeed') return `+${(value * 100).toFixed(0)}% Move Speed`;
              if (key === 'attackSpeed') return `+${(value * 100).toFixed(0)}% ATK Speed`;
              if (key === 'damageReduction') return `-${(value * 100).toFixed(0)}% Dmg Taken`;
              if (key === 'critRate') return `+${(value * 100).toFixed(0)}% Crit`;
              if (key === 'critDamage') return `+${(value * 100).toFixed(0)}% Crit Dmg`;
              if (key === 'xpGain') return `+${(value * 100).toFixed(0)}% XP`;
              if (key === 'goldFind') return `+${(value * 100).toFixed(0)}% Gold`;
              if (key === 'maxHp') return `+${value} Max HP`;
              if (key === 'hpRegen') return `+${value} HP/s`;
              if (key === 'lifesteal') return `+${(value * 100).toFixed(0)}% Lifesteal`;
              if (key === 'evasion') return `+${(value * 100).toFixed(0)}% Evasion`;
              if (key === 'allDamage') return `+${(value * 100).toFixed(0)}% All Dmg`;
              if (key === 'allStats') return `+${value} All Stats`;
              if (key === 'aoe') return `${value} AOE`;
              return `+${value} ${key}`;
            }).slice(0, 4).join(', ');
          };

          const renderPowerCard = (power) => {
            const isLearned = learnedAbilities.find(a => a.id === power.id);
            const isUnlocked = window.isPowerUnlocked(power);
            const canUnlockCheck = window.canUnlockPower(power);
            const isLevelMet = playerLevel >= power.levelReq;
            
            const rarityColors = {
              common: '#9e9e9e',
              uncommon: '#4caf50',
              rare: '#2196f3',
              epic: '#9c27b0',
              legendary: '#ff9800'
            };
            const borderColor = rarityColors[power.rarity] || '#9e9e9e';
            
            const categoryColors = {
              elemental: '#ff6b6b',
              psychic: '#9a6bff',
              cosmic: '#00e5ff'
            };
            const categoryColor = categoryColors[power.category] || '#4fc3f7';
            
            return `
              <div class="power-card ${isLearned ? 'learned' : ''} ${!isUnlocked ? 'locked' : ''}" 
                   style="background: ${isLearned ? 'linear-gradient(135deg, rgba(56, 239, 125, 0.2), rgba(79, 195, 247, 0.2))' : isUnlocked ? 'rgba(0, 0, 0, 0.4)' : 'rgba(0, 0, 0, 0.6)'};
                          border: 2px solid ${isLearned ? '#38ef7d' : borderColor};
                          border-radius: 12px;
                          padding: 16px;
                          position: relative;
                          ${!isUnlocked && !isLevelMet ? 'opacity: 0.6; filter: grayscale(40%);' : ''}
                          transition: all 0.2s ease;">
                
                ${!isLevelMet ? `<div style="position: absolute; top: 8px; right: 8px; background: rgba(255, 0, 0, 0.8); padding: 4px 10px; border-radius: 8px; font-size: 10px; font-weight: bold; z-index: 1;">ğŸ”’ Lv${power.levelReq}</div>` : ''}
                ${isLearned ? `<div style="position: absolute; top: 8px; right: 8px; background: rgba(56, 239, 125, 0.8); padding: 4px 10px; border-radius: 8px; font-size: 10px; font-weight: bold; z-index: 1;">âœ… LEARNED</div>` : ''}
                
                <!-- Power Header -->
                <div style="display: flex; align-items: center; gap: 12px; margin-bottom: 12px;">
                  <div style="font-size: 40px; filter: drop-shadow(0 0 8px ${categoryColor});">${power.icon}</div>
                  <div style="flex: 1;">
                    <div style="font-weight: 700; color: ${borderColor}; font-size: 14px;">${power.name}</div>
                    <div style="font-size: 10px; color: rgba(255, 255, 255, 0.6); text-transform: uppercase;">
                      ${power.rarity} | ${power.element}
                    </div>
                  </div>
            </div>

                <!-- Type Badge -->
                <div style="display: flex; gap: 6px; margin-bottom: 10px;">
                  <span style="padding: 4px 10px; background: ${power.type === 'active' ? 'rgba(167, 139, 250, 0.3)' : 'rgba(122, 248, 200, 0.3)'}; 
                                border: 1px solid ${power.type === 'active' ? '#a78bfa' : '#7af8c8'}; border-radius: 6px; 
                                font-size: 9px; font-weight: 700; text-transform: uppercase; 
                                color: ${power.type === 'active' ? '#a78bfa' : '#7af8c8'};">
                    ${power.type === 'active' ? 'âš¡ ACTIVE' : 'ğŸ’š PASSIVE'}
                  </span>
                  <span style="padding: 4px 10px; background: rgba(${categoryColor === '#ff6b6b' ? '255, 107, 107' : categoryColor === '#9a6bff' ? '154, 107, 255' : '0, 229, 255'}, 0.2); 
                                border: 1px solid ${categoryColor}; border-radius: 6px; 
                                font-size: 9px; font-weight: 700; text-transform: uppercase; 
                                color: ${categoryColor};">
                    ${power.category}
                  </span>
                    </div>
                
                <!-- Cooldown & Duration (Active only) -->
                ${power.type === 'active' ? `
                  <div style="display: flex; gap: 8px; margin-bottom: 10px;">
                    <span class="stat-badge" style="background: rgba(0, 229, 255, 0.2); color: #00e5ff; font-size: 10px; padding: 4px 8px;">
                      â±ï¸ ${power.cooldown / 1000}s CD
                      </span>
                    <span class="stat-badge" style="background: rgba(255, 215, 122, 0.2); color: #ffd77a; font-size: 10px; padding: 4px 8px;">
                      â³ ${power.duration / 1000}s
                      </span>
                    </div>
                ` : ''}
                
                <!-- Bonuses -->
                <div style="background: rgba(255, 215, 122, 0.1); border-left: 3px solid #ffd77a; padding: 8px; margin-bottom: 10px; border-radius: 4px;">
                  <div style="font-size: 10px; color: #ffd77a; font-weight: 700; margin-bottom: 4px;">ğŸ“Š BONUSES</div>
                  <div style="font-size: 10px; color: rgba(255, 255, 255, 0.9);">
                    ${formatBonuses(power.bonuses)}
                    </div>
                    </div>
                
                <!-- Description -->
                <div style="font-size: 10px; color: rgba(207, 227, 255, 0.7); margin-bottom: 12px; line-height: 1.4;">
                  ${power.description}
                  </div>
                
                <!-- Unlock Requirement -->
                ${power.unlockReq ? `
                  <div style="background: rgba(138, 43, 226, 0.2); border: 1px solid #9a6bff; border-radius: 6px; padding: 6px; margin-bottom: 10px; font-size: 9px;">
                    <div style="color: #9a6bff; font-weight: 700;">ğŸ¯ UNLOCK REQUIREMENT:</div>
                    <div style="color: rgba(255, 255, 255, 0.8); margin-top: 2px;">${power.unlockReq}</div>
              </div>
                ` : ''}
                
                <!-- Action Button -->
                ${!isLearned ? `
                  <button onclick="window.BagSystem.attemptLearnPower('${power.id}')"
                          ${!isLevelMet || !isUnlocked ? 'disabled' : ''}
                          style="width: 100%; padding: 10px; 
                                 background: ${isLevelMet && isUnlocked ? 'linear-gradient(135deg, #38ef7d, #4fc3f7)' : 'rgba(100, 100, 100, 0.3)'}; 
                                 border: 2px solid ${isLevelMet && isUnlocked ? '#38ef7d' : '#666'}; 
                                 border-radius: 8px; 
                                 color: white; 
                                 font-weight: 700; 
                                 font-size: 11px; 
                                 cursor: ${isLevelMet && isUnlocked ? 'pointer' : 'not-allowed'}; 
                                 transition: all 0.2s;">
                    ${!isLevelMet ? `ğŸ”’ Requires Level ${power.levelReq}` : 
                      !isUnlocked && power.unlockReq ? `ğŸ”“ Unlock (${power.unlockReq})` : 
                      `ğŸ“š Learn Power (${power.cost}g)`}
                  </button>
                ` : `
                  <div style="padding: 10px; background: rgba(56, 239, 125, 0.2); border: 2px solid #38ef7d; border-radius: 8px; text-align: center; font-size: 11px; font-weight: 700; color: #38ef7d;">
                    âœ“ Mastered
            </div>
                `}
              </div>
            `;
          };

          pane.innerHTML = `
            <!-- Header -->
            <div style="margin-bottom: 20px;">
              <h2 style="font-size: 22px; color: #ffd77a; margin-bottom: 10px;">ğŸ”® Supernatural Powers</h2>
              <div style="display: flex; justify-content: space-between; align-items: center;">
                <p style="color: rgba(207, 227, 255, 0.7); font-size: 13px;">
                  Master supernatural powers across 3 categories!
              </p>
                <div style="display: flex; gap: 12px; align-items: center;">
                  <div style="background: rgba(138, 43, 226, 0.3); border: 2px solid #9a6bff; border-radius: 8px; padding: 6px 12px; font-size: 12px;">
                    <span style="color: #9a6bff; font-weight: 700;">âœ¨ Essence:</span>
                    <span style="color: white; margin-left: 6px; font-weight: 700;">${essence}</span>
                      </div>
                  <div style="background: rgba(255, 215, 122, 0.3); border: 2px solid #ffd77a; border-radius: 8px; padding: 6px 12px; font-size: 12px;">
                    <span style="color: #ffd77a; font-weight: 700;">ğŸ‘¤ Level:</span>
                    <span style="color: white; margin-left: 6px; font-weight: 700;">${playerLevel}</span>
                    </div>
                    </div>
                    </div>
                  </div>
            
            <!-- Category Filters -->
            <div style="display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap;">
              <button class="power-filter-btn ${this.state.supernaturalFilter === 'all' ? 'active' : ''}" 
                      data-filter="all"
                      style="padding: 10px 20px; 
                             background: ${this.state.supernaturalFilter === 'all' ? 'linear-gradient(135deg, #38ef7d, #4fc3f7)' : 'rgba(0, 0, 0, 0.5)'}; 
                             border: 2px solid ${this.state.supernaturalFilter === 'all' ? '#38ef7d' : 'rgba(79, 195, 247, 0.4)'}; 
                             border-radius: 8px; color: white; font-weight: 700; font-size: 11px; cursor: pointer; transition: all 0.2s;">
                ğŸŒŸ All Powers
              </button>
              <button class="power-filter-btn ${this.state.supernaturalFilter === 'elemental' ? 'active' : ''}" 
                      data-filter="elemental"
                      style="padding: 10px 20px; 
                             background: ${this.state.supernaturalFilter === 'elemental' ? 'linear-gradient(135deg, #ff6b6b, #ff8e8e)' : 'rgba(0, 0, 0, 0.5)'}; 
                             border: 2px solid ${this.state.supernaturalFilter === 'elemental' ? '#ff6b6b' : 'rgba(79, 195, 247, 0.4)'}; 
                             border-radius: 8px; color: white; font-weight: 700; font-size: 11px; cursor: pointer; transition: all 0.2s;">
                ğŸ”¥ Elemental
              </button>
              <button class="power-filter-btn ${this.state.supernaturalFilter === 'psychic' ? 'active' : ''}" 
                      data-filter="psychic"
                      style="padding: 10px 20px; 
                             background: ${this.state.supernaturalFilter === 'psychic' ? 'linear-gradient(135deg, #9a6bff, #8a2be2)' : 'rgba(0, 0, 0, 0.5)'}; 
                             border: 2px solid ${this.state.supernaturalFilter === 'psychic' ? '#9a6bff' : 'rgba(79, 195, 247, 0.4)'}; 
                             border-radius: 8px; color: white; font-weight: 700; font-size: 11px; cursor: pointer; transition: all 0.2s;">
                ğŸ§  Psychic
              </button>
              <button class="power-filter-btn ${this.state.supernaturalFilter === 'cosmic' ? 'active' : ''}" 
                      data-filter="cosmic"
                      style="padding: 10px 20px; 
                             background: ${this.state.supernaturalFilter === 'cosmic' ? 'linear-gradient(135deg, #00e5ff, #7af8c8)' : 'rgba(0, 0, 0, 0.5)'}; 
                             border: 2px solid ${this.state.supernaturalFilter === 'cosmic' ? '#00e5ff' : 'rgba(79, 195, 247, 0.4)'}; 
                             border-radius: 8px; color: white; font-weight: 700; font-size: 11px; cursor: pointer; transition: all 0.2s;">
                ğŸŒŒ Cosmic
              </button>
              </div>
            
            <!-- Learned Powers Section -->
            ${learnedPowers.length > 0 ? `
              <div style="background: rgba(56, 239, 125, 0.1); border: 2px solid rgba(56, 239, 125, 0.5); border-radius: 12px; padding: 20px; margin-bottom: 20px;">
                <h3 style="color: #38ef7d; margin-bottom: 12px; font-size: 16px;">âœ… Mastered Powers (${learnedPowers.length})</h3>
                <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 12px;">
                  ${learnedPowers.map(renderPowerCard).join('')}
                </div>
              </div>
            ` : ''}
            
            <!-- Available Powers Section -->
            <div style="background: rgba(0, 0, 0, 0.3); border: 2px solid rgba(79, 195, 247, 0.4); border-radius: 12px; padding: 20px;">
              <h3 style="color: #4fc3f7; margin-bottom: 12px; font-size: 16px;">
                ğŸ“š Available Powers (${availablePowers.length})
              </h3>
              <p style="font-size: 11px; color: rgba(207, 227, 255, 0.6); margin-bottom: 16px;">
                Learn new powers to expand your supernatural abilities
              </p>
              ${availablePowers.length === 0 ? `
                <div class="tab-empty">
                  <div class="empty-icon">ğŸ”®</div>
                  <p>All powers in this category are mastered!</p>
                  <p style="font-size: 11px; color: rgba(207, 227, 255, 0.6); margin-top: 8px;">
                    Try a different category filter
                  </p>
                </div>
              ` : `
                <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(280px, 1fr)); gap: 12px;">
                  ${availablePowers.map(renderPowerCard).join('')}
                </div>
              `}
            </div>
          `;

          // Attach filter listeners
          pane.querySelectorAll('.power-filter-btn').forEach(btn => {
            btn.addEventListener('click', () => {
              this.state.supernaturalFilter = btn.dataset.filter;
              this.renderSupernaturalTab();
            });
          });
        },
        
        attemptLearnPower(powerId) {
          const power = window.SUPERNATURAL_POWERS_DATABASE[powerId];
          if (!power) {
            this.showToast('âš ï¸ Power not found!');
            return;
          }
          
          const canUnlock = window.canUnlockPower(power);
          
          // Check if player meets level requirement
          if (!canUnlock.canUnlock && canUnlock.reason.includes('Level')) {
            this.showToast(canUnlock.reason);
            return;
          }
          
          // Check if already learned
          if (canUnlock.reason === 'Already unlocked') {
            const result = window.learnPower(power);
            if (!result.success) {
              this.showToast(result.message);
              return;
            }
          }
          
          // Check if player has enough gold
          if (window.gameState.gold < power.cost) {
            this.showToast(`ğŸ’° Need ${power.cost}g to learn this power!`);
            return;
          }
          
          // Deduct gold and learn power
          window.gameState.gold -= power.cost;
          const result = window.learnPower(power);
          
          if (result.success) {
            this.showToast(`âœ… Learned ${power.name}!`);
            this.createParticleEffect('open', window.innerWidth / 2, window.innerHeight / 2);
            this.renderSupernaturalTab();
            this.syncAllSystems();
          } else {
            // Refund if learning failed
            window.gameState.gold += power.cost;
            this.showToast(result.message);
          }
        },

        renderQuestsTab() {
          const pane = document.getElementById('bagContentPane');
          const quests = window.gameState.quests || {};

          const renderQuest = (quest, type) => {
            const isStory = type === 'story';
            const progressPercent = isStory
              ? (quest.objectives[0].progress / quest.objectives[0].count * 100)
              : (quest.progress / quest.required * 100);

            return `
              <div style="background: rgba(0, 0, 0, 0.4); border: 2px solid ${quest.completed ? 'rgba(56, 239, 125, 0.5)' : 'rgba(79, 195, 247, 0.3)'}; border-radius: 10px; padding: 16px; margin-bottom: 12px;">
                <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                  <div style="flex: 1;">
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 4px;">
                      ${!isStory ? `<span style="font-size: 20px;">${quest.icon}</span>` : ''}
                      <h4 style="color: #4fc3f7; font-size: 14px; font-weight: 700;">${quest.title || quest.name}</h4>
                    </div>
                    <p style="font-size: 11px; color: rgba(207, 227, 255, 0.7); margin-bottom: 10px;">
                      ${quest.description}
                    </p>
                  </div>
                  ${quest.completed ? '<div style="font-size: 24px;">âœ…</div>' : ''}
                </div>

                ${isStory ? `
                  ${quest.objectives.map(obj => `
                    <div style="margin-bottom: 8px;">
                      <div style="font-size: 11px; color: rgba(207, 227, 255, 0.8); margin-bottom: 4px;">
                        ${obj.desc} (${obj.progress}/${obj.count})
                      </div>
                      <div style="background: rgba(0, 0, 0, 0.3); border-radius: 8px; height: 8px; overflow: hidden;">
                        <div style="background: linear-gradient(90deg, #00e5ff, #7af8c8); height: 100%; width: ${(obj.progress / obj.count * 100)}%; transition: width 0.3s ease;"></div>
                      </div>
                    </div>
                  `).join('')}
                ` : `
                  <div style="margin-bottom: 8px;">
                    <div style="font-size: 11px; color: rgba(207, 227, 255, 0.8); margin-bottom: 4px;">
                      Progress: ${quest.progress}/${quest.required}
                    </div>
                    <div style="background: rgba(0, 0, 0, 0.3); border-radius: 8px; height: 10px; overflow: hidden;">
                      <div style="background: linear-gradient(90deg, #00e5ff, #7af8c8); height: 100%; width: ${progressPercent}%; transition: width 0.3s ease;"></div>
                    </div>
                  </div>
                `}

                <div style="display: flex; gap: 8px; margin-top: 12px; padding-top: 12px; border-top: 1px solid rgba(79, 195, 247, 0.2);">
                  <div style="font-size: 11px; color: #ffd77a;">
                    ğŸ’° ${(quest.rewards?.gold || quest.reward?.gold || 0).toLocaleString()} gold
                  </div>
                  <div style="font-size: 11px; color: #a78bfa;">
                    â­ ${(quest.rewards?.xp || quest.reward?.xp || 0).toLocaleString()} XP
                  </div>
                </div>
              </div>
            `;
          };

          pane.innerHTML = `
            <div style="margin-bottom: 20px;">
              <h2 style="font-size: 22px; color: #ffd77a; margin-bottom: 10px;">ğŸ“œ Quest Log</h2>
              <p style="color: rgba(207, 227, 255, 0.7); font-size: 13px; margin-bottom: 20px;">
                Track your adventures and complete challenges for rewards!
              </p>
            </div>

            <!-- Story Quests -->
            <div style="margin-bottom: 24px;">
              <h3 style="color: #00e5ff; margin-bottom: 12px; font-size: 16px; display: flex; align-items: center; gap: 8px;">
                ğŸ“– Story Quests
                <span style="font-size: 11px; padding: 3px 8px; background: rgba(0, 229, 255, 0.2); border-radius: 6px;">${quests.story?.length || 0} quests</span>
              </h3>
              ${(quests.story || []).map(q => renderQuest(q, 'story')).join('')}
            </div>

            <!-- Daily Quests -->
            <div style="margin-bottom: 24px;">
              <h3 style="color: #ffd77a; margin-bottom: 12px; font-size: 16px; display: flex; align-items: center; gap: 8px;">
                â˜€ï¸ Daily Quests
                <span style="font-size: 11px; padding: 3px 8px; background: rgba(255, 215, 122, 0.2); border-radius: 6px;">${quests.daily?.length || 0} quests</span>
              </h3>
              ${(quests.daily || []).map(q => renderQuest(q, 'daily')).join('')}
            </div>

            <!-- Weekly Quests -->
            <div>
              <h3 style="color: #a78bfa; margin-bottom: 12px; font-size: 16px; display: flex; align-items: center; gap: 8px;">
                ğŸŒŸ Weekly Quests
                <span style="font-size: 11px; padding: 3px 8px; background: rgba(167, 139, 250, 0.2); border-radius: 6px;">${quests.weekly?.length || 0} quests</span>
              </h3>
              ${(quests.weekly || []).map(q => renderQuest(q, 'weekly')).join('')}
            </div>
          `;
        },

        renderDropSystemsTab() {
          debugLog('[BagSystem] renderDropSystemsTab called');
          const pane = document.getElementById('bagContentPane');
          if (!pane) {
            debugError('[BagSystem] bagContentPane not found!');
            return;
          }

          // Use the Drop Systems Renderer if available
          if (window.DropSystemsRenderer && window.DropSystemsRenderer.renderDropSystemsTab) {
            debugLog('[BagSystem] Calling DropSystemsRenderer.renderDropSystemsTab()');
            try {
              window.DropSystemsRenderer.renderDropSystemsTab();
              debugLog('[BagSystem] DropSystemsRenderer.renderDropSystemsTab() completed');
            } catch (error) {
              debugError('[BagSystem] Error in DropSystemsRenderer:', error);
              pane.innerHTML = `
                <div style="padding: 40px; text-align: center;">
                  <h3 style="color: #ff6b35;">âš ï¸ Error Loading Drop Systems</h3>
                  <p style="color: rgba(207, 227, 255, 0.7); margin-top: 12px;">
                    ${error.message}
                  </p>
                  <pre style="color: rgba(207, 227, 255, 0.5); font-size: 12px; margin-top: 20px; text-align: left; background: rgba(0,0,0,0.3); padding: 10px; border-radius: 8px;">${error.stack}</pre>
                </div>
              `;
            }
          } else {
            debugWarn('[BagSystem] DropSystemsRenderer not available');
            const pane = document.getElementById('bagContentPane');
            if (pane) {
              pane.innerHTML = `
                <div style="padding: 40px; text-align: center;">
                  <h3 style="color: #ff6b35;">âš ï¸ Drop Systems Not Loaded</h3>
                  <p style="color: rgba(207, 227, 255, 0.7); margin-top: 12px;">
                    The drop systems module is not loaded. Please include drop-tables.js and drop-renderer.js
                  </p>
                  <p style="color: rgba(207, 227, 255, 0.5); margin-top: 12px; font-size: 12px;">
                    DropSystemsRenderer available: ${typeof window.DropSystemsRenderer !== 'undefined'}<br>
                    DROP_SYSTEMS available: ${typeof window.DROP_SYSTEMS !== 'undefined'}
                  </p>
                </div>
              `;
            }
          }
        },

        renderBestiaryTab() {
          // Use the Bestiary Renderer if available
          if (window.BestiaryRenderer && window.BestiaryRenderer.renderBestiaryTab) {
            window.BestiaryRenderer.renderBestiaryTab();
          } else {
            const pane = document.getElementById('bagContentPane');
            if (pane) {
              pane.innerHTML = '<div style="padding: 40px; text-align: center;"><h3 style="color: #ff6b35;">âš ï¸ Bestiary Not Loaded</h3></div>';
            }
          }
        },

        renderMissionBoardTab() {
          // Use the Mission Board Renderer if available
          if (window.MissionBoardRenderer && window.MissionBoardRenderer.renderMissionBoardTab) {
            window.MissionBoardRenderer.renderMissionBoardTab();
          } else {
            const pane = document.getElementById('bagContentPane');
            if (pane) {
              const gatekeeperConfig =
                window.CONFIG?.bag?.missions?.gatekeeperBriefing ||
                window.CONFIG?.polish?.bag?.missions?.gatekeeperBriefing ||
                window.__A1K_CONFIG?.bag?.missions?.gatekeeperBriefing || {};
              const statusHint = gatekeeperConfig.statusHint || 'Badge payouts refund forging costs â€” keys optional.';
              const hotkey = (gatekeeperConfig.hotkey || 'g').toUpperCase();
              pane.innerHTML = `
                <div class="mission-board-container">
                  <div class="mission-gatekeeper-cta">
                    <div class="gatekeeper-status">
                      <div>${statusHint}</div>
                      <div style="margin-top:6px; font-size:11px; color: rgba(207,227,255,0.6);">
                        Hotkey: <span style="color:#00e5ff; font-weight:600;">${hotkey}</span>
                      </div>
                    </div>
                    <div class="gatekeeper-cta-button" data-role="gatekeeper-cta"></div>
                  </div>
                  <div style="padding: 40px; text-align: center;">
                    <h3 style="color: #ff6b35;">âš ï¸ Mission Board Not Loaded</h3>
                    <p style="color: rgba(207, 227, 255, 0.7); margin-top: 12px;">
                      The mission board module is not loaded. Please include enemy system scripts.
                    </p>
                  </div>
                </div>
              `;
              setTimeout(() => {
                try {
                  const host = pane.querySelector('.gatekeeper-cta-button[data-role="gatekeeper-cta"]');
                  if (host && !window.RiftUI?.attachGatekeeperToggle?.(host)) {
                    host.innerHTML = '<div style="color: rgba(255,107,53,0.7); font-size: 12px;">Gatekeeper interface unavailable.</div>';
                  }
                } catch (error) {
                  debugError('[BagSystem] Gatekeeper CTA fallback failed', error);
                }
              }, 0);
            }
          }
        },

        renderMapTab() {
          const pane = document.getElementById('bagContentPane');
          const hasArcade = typeof this.renderArcadeSubtab === 'function';

          // Initialize map subtab
          if (!this.state.mapSubtab) {
            this.state.mapSubtab = 'world';
          }
          if (this.state.mapSubtab === 'arcade' && !hasArcade) {
            this.state.mapSubtab = 'world';
          }

          pane.innerHTML = `
            <div style="padding: 20px;">
              <div style="margin-bottom: 20px;">
                <h2 style="font-size: 22px; color: #ffd77a; margin-bottom: 10px;">ğŸ—ºï¸ World Map</h2>
                <p style="color: rgba(207, 227, 255, 0.7); font-size: 13px; margin-bottom: 20px;">
                  Navigate the world, track locations, and fast travel!
                </p>
              </div>
              
              <!-- Map Subtabs -->
              <div style="display: flex; gap: 8px; margin-bottom: 20px; border-bottom: 2px solid rgba(79, 195, 247, 0.2); padding-bottom: 10px;">
                <button class="map-subtab-btn ${this.state.mapSubtab === 'world' ? 'active' : ''}" data-subtab="world" style="padding: 10px 20px; background: ${this.state.mapSubtab === 'world' ? 'rgba(91, 163, 255, 0.3)' : 'rgba(0, 0, 0, 0.3)'}; border: 2px solid ${this.state.mapSubtab === 'world' ? 'rgba(91, 163, 255, 0.6)' : 'rgba(79, 195, 247, 0.3)'}; border-radius: 8px; color: ${this.state.mapSubtab === 'world' ? '#5ba3ff' : 'rgba(207, 227, 255, 0.7)'}; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.3s ease;">
                  ğŸŒ World Map
                </button>
                <button class="map-subtab-btn ${this.state.mapSubtab === 'locations' ? 'active' : ''}" data-subtab="locations" style="padding: 10px 20px; background: ${this.state.mapSubtab === 'locations' ? 'rgba(255, 215, 122, 0.3)' : 'rgba(0, 0, 0, 0.3)'}; border: 2px solid ${this.state.mapSubtab === 'locations' ? 'rgba(255, 215, 122, 0.6)' : 'rgba(79, 195, 247, 0.3)'}; border-radius: 8px; color: ${this.state.mapSubtab === 'locations' ? '#ffd77a' : 'rgba(207, 227, 255, 0.7)'}; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.3s ease;">
                  ğŸ“ Locations
                </button>
                <button class="map-subtab-btn ${this.state.mapSubtab === 'minigame' ? 'active' : ''}" data-subtab="minigame" style="padding: 10px 20px; background: ${this.state.mapSubtab === 'minigame' ? 'rgba(76, 209, 55, 0.3)' : 'rgba(0, 0, 0, 0.3)'}; border: 2px solid ${this.state.mapSubtab === 'minigame' ? 'rgba(76, 209, 55, 0.6)' : 'rgba(79, 195, 247, 0.3)'}; border-radius: 8px; color: ${this.state.mapSubtab === 'minigame' ? '#4cd137' : 'rgba(207, 227, 255, 0.7)'}; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.3s ease;">
                  ğŸ® Mini-Game
                </button>
                ${hasArcade ? `
                <button class="map-subtab-btn ${this.state.mapSubtab === 'arcade' ? 'active' : ''}" data-subtab="arcade" style="padding: 10px 20px; background: ${this.state.mapSubtab === 'arcade' ? 'rgba(255, 107, 53, 0.25)' : 'rgba(0, 0, 0, 0.3)'}; border: 2px solid ${this.state.mapSubtab === 'arcade' ? 'rgba(255, 107, 53, 0.6)' : 'rgba(79, 195, 247, 0.3)'}; border-radius: 8px; color: ${this.state.mapSubtab === 'arcade' ? '#ff6b35' : 'rgba(207, 227, 255, 0.7)'}; font-size: 14px; font-weight: 600; cursor: pointer; transition: all 0.3s ease;">
                  ğŸ° Arcade
                </button>` : ''}
              </div>
              
              <div id="map-subtab-content"></div>
            </div>
          `;
          
          // Render the active subtab
          this.renderMapSubtab();
          
          // Attach subtab button listeners
          setTimeout(() => {
            document.querySelectorAll('.map-subtab-btn').forEach(btn => {
              btn.addEventListener('click', () => {
                this.state.mapSubtab = btn.getAttribute('data-subtab');
                this.renderMapTab();
              });
            });
          }, 50);
        },
        
        renderMapSubtab() {
          const container = document.getElementById('map-subtab-content');
          if (!container) return;
          
          if (this.state.mapSubtab === 'world') {
            this.renderWorldMapSubtab(container);
          } else if (this.state.mapSubtab === 'locations') {
            this.renderLocationsSubtab(container);
          } else if (this.state.mapSubtab === 'minigame') {
            this.renderMapMinigameSubtab(container);
          } else if (this.state.mapSubtab === 'arcade') {
            if (typeof this.renderArcadeSubtab === 'function') {
              this.renderArcadeSubtab(container);
            } else {
              container.innerHTML = '<div style="padding: 40px; text-align: center; color: rgba(207, 227, 255, 0.7);">Arcade module not loaded.</div>';
            }
          }
        },
        
        renderWorldMapSubtab(container) {
          container.innerHTML = `
            <div style="background: rgba(0, 0, 0, 0.3); border: 2px solid rgba(79, 195, 247, 0.4); border-radius: 12px; padding: 30px; text-align: center;">
              <div style="font-size: 64px; margin-bottom: 20px;">ğŸ—ºï¸</div>
              <h3 style="color: #ffd77a; font-size: 18px; margin-bottom: 12px;">Interactive World Map</h3>
              <p style="color: rgba(207, 227, 255, 0.7); font-size: 13px; max-width: 600px; margin: 0 auto 30px;">
                The world map displays all discovered locations, waypoints, and allows fast travel to unlocked areas.
              </p>

              <div style="background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(79, 195, 247, 0.3); border-radius: 10px; padding: 24px; max-width: 700px; margin: 0 auto;">
                <h4 style="color: #4fc3f7; font-size: 14px; margin-bottom: 16px; text-align: left;">ğŸ“‹ Map Features:</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; text-align: left;">
                  <div style="padding: 10px; background: rgba(0, 0, 0, 0.3); border-radius: 6px;">
                    <div style="font-size: 16px; margin-bottom: 4px;">ğŸ™ï¸</div>
                    <div style="font-size: 11px; color: rgba(207, 227, 255, 0.8);">Cities</div>
                    <div style="font-size: 9px; color: rgba(207, 227, 255, 0.5);">Urban areas</div>
                  </div>
                  <div style="padding: 10px; background: rgba(0, 0, 0, 0.3); border-radius: 6px;">
                    <div style="font-size: 16px; margin-bottom: 4px;">ğŸ°</div>
                    <div style="font-size: 11px; color: rgba(207, 227, 255, 0.8);">Dungeons</div>
                    <div style="font-size: 9px; color: rgba(207, 227, 255, 0.5);">Challenge zones</div>
                  </div>
                  <div style="padding: 10px; background: rgba(0, 0, 0, 0.3); border-radius: 6px;">
                    <div style="font-size: 16px; margin-bottom: 4px;">ğŸª</div>
                    <div style="font-size: 11px; color: rgba(207, 227, 255, 0.8);">Shops</div>
                    <div style="font-size: 9px; color: rgba(207, 227, 255, 0.5);">Merchant locations</div>
                  </div>
                  <div style="padding: 10px; background: rgba(0, 0, 0, 0.3); border-radius: 6px;">
                    <div style="font-size: 16px; margin-bottom: 4px;">ğŸ“</div>
                    <div style="font-size: 11px; color: rgba(207, 227, 255, 0.8);">Waypoints</div>
                    <div style="font-size: 9px; color: rgba(207, 227, 255, 0.5);">Fast travel points</div>
                  </div>
                  <div style="padding: 10px; background: rgba(0, 0, 0, 0.3); border-radius: 6px;">
                    <div style="font-size: 16px; margin-bottom: 4px;">ğŸ‘¹</div>
                    <div style="font-size: 11px; color: rgba(207, 227, 255, 0.8);">Boss Areas</div>
                    <div style="font-size: 9px; color: rgba(207, 227, 255, 0.5);">Epic encounters</div>
                  </div>
                  <div style="padding: 10px; background: rgba(0, 0, 0, 0.3); border-radius: 6px;">
                    <div style="font-size: 16px; margin-bottom: 4px;">ğŸ¯</div>
                    <div style="font-size: 11px; color: rgba(207, 227, 255, 0.8);">Quest Markers</div>
                    <div style="font-size: 9px; color: rgba(207, 227, 255, 0.5);">Objective locations</div>
                  </div>
                  <div style="padding: 10px; background: rgba(0, 0, 0, 0.3); border-radius: 6px;">
                    <div style="font-size: 16px; margin-bottom: 4px;">ğŸŒ</div>
                    <div style="font-size: 11px; color: rgba(207, 227, 255, 0.8);">Exploration</div>
                    <div style="font-size: 9px; color: rgba(207, 227, 255, 0.5);">Discovery tracking</div>
                  </div>
                  <div style="padding: 10px; background: rgba(0, 0, 0, 0.3); border-radius: 6px;">
                    <div style="font-size: 16px; margin-bottom: 4px;">âš¡</div>
                    <div style="font-size: 11px; color: rgba(207, 227, 255, 0.8);">Fast Travel</div>
                    <div style="font-size: 9px; color: rgba(207, 227, 255, 0.5);">Instant teleport</div>
                  </div>
                  <div style="padding: 10px; background: rgba(0, 0, 0, 0.3); border-radius: 6px;">
                    <div style="font-size: 16px; margin-bottom: 4px;">ğŸ†</div>
                    <div style="font-size: 11px; color: rgba(207, 227, 255, 0.8);">Achievements</div>
                    <div style="font-size: 9px; color: rgba(207, 227, 255, 0.5);">Location milestones</div>
                  </div>
                </div>
              </div>
            </div>
          `;
        },
        
        renderLocationsSubtab(container) {
          const locations = this.getLocationDatabase();
          
          container.innerHTML = `
            <div>
              <h3 style="color: #ffd77a; margin-bottom: 16px;">ğŸ“ Discovered Locations</h3>
              
              <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 16px;">
                ${Object.entries(locations).map(([key, loc]) => `
                  <div class="location-card" data-location="${key}" style="background: rgba(0, 0, 0, 0.4); border: 2px solid rgba(79, 195, 247, 0.4); border-radius: 12px; padding: 16px; cursor: pointer; transition: all 0.3s ease;" onmouseover="this.style.borderColor='rgba(91, 163, 255, 0.8)'" onmouseout="this.style.borderColor='rgba(79, 195, 247, 0.4)'">
                    <div style="font-size: 40px; text-align: center; margin-bottom: 12px;">${loc.icon}</div>
                    <h4 style="color: #4fc3f7; font-size: 16px; margin-bottom: 8px; text-align: center;">${loc.name}</h4>
                    
                    <div style="font-size: 11px; color: rgba(207, 227, 255, 0.7); margin-bottom: 10px;">
                      <div style="font-weight: 600; color: #ffd77a; margin-bottom: 4px;">ğŸ¯ Activities:</div>
                      ${loc.activities.map(a => `<div style="padding: 2px 0;">â€¢ ${a}</div>`).join('')}
                    </div>
                    
                    ${loc.quests.length > 0 ? `
                      <div style="font-size: 10px; color: rgba(207, 227, 255, 0.6); margin-bottom: 10px;">
                        <div style="font-weight: 600; color: #a78bfa; margin-bottom: 4px;">ğŸ“œ Related Quests:</div>
                        ${loc.quests.map(q => `<div>â€¢ ${q}</div>`).join('')}
                      </div>
                    ` : ''}
                    
                    <button class="teleport-btn" data-location="${key}" style="width: 100%; padding: 10px; background: linear-gradient(135deg, rgba(91, 163, 255, 0.3), rgba(0, 229, 255, 0.3)); border: 2px solid rgba(91, 163, 255, 0.5); border-radius: 8px; color: #5ba3ff; font-size: 12px; font-weight: 600; cursor: pointer; margin-top: 8px;">
                      ğŸŒ€ Teleport
                    </button>
                  </div>
                `).join('')}
              </div>
              
              <div style="margin-top: 20px; padding: 16px; background: rgba(0, 229, 255, 0.1); border: 2px solid rgba(0, 229, 255, 0.3); border-radius: 12px;">
                <div style="font-size: 13px; color: #00e5ff; font-weight: 600; margin-bottom: 8px;">ğŸ’¡ Teleport Tips:</div>
                <div style="font-size: 11px; color: rgba(207, 227, 255, 0.8); line-height: 1.6;">
                  â€¢ Click location cards to see details<br>
                  â€¢ Click "ğŸŒ€ Teleport" to fast travel<br>
                  â€¢ Temple provides FREE full healing!<br>
                  â€¢ Type "where to" in AI for smart suggestions
                </div>
              </div>
            </div>
          `;
          
          // Attach teleport buttons
          setTimeout(() => {
            container.querySelectorAll('.teleport-btn').forEach(btn => {
              btn.addEventListener('click', (e) => {
                e.stopPropagation();
                const location = btn.getAttribute('data-location');
                this.teleportTo(location);
              });
            });
          }, 50);
        },
        
        renderMapMinigameSubtab(container) {
          container.innerHTML = `
            <div>
              <h3 style="color: #4cd137; margin-bottom: 16px;">ğŸ® Map Mini-Game</h3>
              
              <div style="background: rgba(0, 0, 0, 0.4); border: 2px solid rgba(76, 209, 55, 0.4); border-radius: 12px; padding: 24px; text-align: center; margin-bottom: 20px;">
                <div style="font-size: 64px; margin-bottom: 16px;">ğŸ®</div>
                <h3 style="color: #4cd137; font-size: 20px; margin-bottom: 12px;">Interactive Map Game</h3>
                <p style="color: rgba(207, 227, 255, 0.7); font-size: 13px; max-width: 600px; margin: 0 auto 24px;">
                  Play the map exploration mini-game! Navigate through dungeons, collect treasures, and defeat enemies!
                </p>
                
                <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-bottom: 24px;">
                  <div style="padding: 16px; background: rgba(76, 209, 55, 0.1); border: 1px solid rgba(76, 209, 55, 0.3); border-radius: 8px;">
                    <div style="font-size: 24px; margin-bottom: 6px;">ğŸ†</div>
                    <div style="font-size: 12px; color: #4cd137; font-weight: 600;">Rewards</div>
                    <div style="font-size: 10px; color: rgba(207, 227, 255, 0.7);">Gold, EXP, Items</div>
                  </div>
                  <div style="padding: 16px; background: rgba(255, 215, 122, 0.1); border: 1px solid rgba(255, 215, 122, 0.3); border-radius: 8px;">
                    <div style="font-size: 24px; margin-bottom: 6px;">âš”ï¸</div>
                    <div style="font-size: 12px; color: #ffd77a; font-weight: 600;">Battles</div>
                    <div style="font-size: 10px; color: rgba(207, 227, 255, 0.7);">Fight enemies</div>
                  </div>
                  <div style="padding: 16px; background: rgba(167, 139, 250, 0.1); border: 1px solid rgba(167, 139, 250, 0.3); border-radius: 8px;">
                    <div style="font-size: 24px; margin-bottom: 6px;">ğŸ—ï¸</div>
                    <div style="font-size: 12px; color: #a78bfa; font-weight: 600;">Secrets</div>
                    <div style="font-size: 10px; color: rgba(207, 227, 255, 0.7);">Hidden treasures</div>
                  </div>
                </div>
                
                <button style="padding: 14px 32px; background: linear-gradient(135deg, rgba(76, 209, 55, 0.4), rgba(76, 209, 55, 0.6)); border: 2px solid rgba(76, 209, 55, 0.7); border-radius: 10px; color: #4cd137; font-size: 15px; font-weight: 700; cursor: pointer; transition: all 0.3s ease; box-shadow: 0 4px 15px rgba(76, 209, 55, 0.3);" onmouseover="this.style.transform='scale(1.05)'" onmouseout="this.style.transform='scale(1)'">
                  ğŸ® PLAY MAP GAME
                </button>
              </div>
              
              <div style="background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(79, 195, 247, 0.3); border-radius: 10px; padding: 20px;">
                <h4 style="color: #4fc3f7; font-size: 14px; margin-bottom: 12px;">ğŸ² Game Features:</h4>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 11px; color: rgba(207, 227, 255, 0.8); text-align: left;">
                  <div>âœ¨ Procedurally generated dungeons</div>
                  <div>âš”ï¸ Real-time combat system</div>
                  <div>ğŸ’° Loot collection & gold farming</div>
                  <div>ğŸ† Achievement rewards</div>
                  <div>ğŸ¯ Quest integration</div>
                  <div>ğŸ“ˆ Progressive difficulty</div>
                </div>
              </div>
            </div>
          `;
        },

        startMapGameSync() {
          if (window.MapGameSync) {
            window.MapGameSync.startSync();
          }
        },

        stopMapGameSync() {
          if (window.MapGameSync) {
            window.MapGameSync.stopSync();
          }
        },

        renderShopTab() {
          const pane = document.getElementById('bagContentPane');
          let shopItems = window.gameState.shop?.inventory || [];

          // Apply filter
          if (this.state.shopFilter !== 'all') {
            shopItems = shopItems.filter(item => {
              // Special handling for cores filter - match items with weaponSkill or passiveEffects
              if (this.state.shopFilter === 'cores' || this.state.shopFilter === 'core') {
                return item.id?.includes('core_') || item.weaponSkill || item.passiveEffects;
              }
              // Support both category and type properties for flexible filtering
              return item.category === this.state.shopFilter || item.type === this.state.shopFilter;
            });
          }

          // Apply sort
          if (this.state.shopSort === 'cost') {
            shopItems.sort((a, b) => a.cost - b.cost);
          } else if (this.state.shopSort === 'name') {
            shopItems.sort((a, b) => a.name.localeCompare(b.name));
          }

          const getCategoryColor = (category) => {
            const colors = {
              consumable: '#38ef7d', gear: '#4fc3f7', armor: '#00e5ff',
              scroll: '#a78bfa', srank: '#ffd77a', supernatural: '#ff7ad9',
              cores: '#ff6b35', misc: '#95a5a6'
            };
            return colors[category] || '#4fc3f7';
          };

          pane.innerHTML = `
            <div style="margin-bottom: 20px;">
              <h2 style="font-size: 22px; color: #ffd77a; margin-bottom: 10px;">ğŸª Item Shop</h2>
              <p style="color: rgba(207, 227, 255, 0.7); font-size: 13px; margin-bottom: 20px;">
                Purchase items, gear, and upgrades with gold and essence!
              </p>
            </div>

            <div class="inventory-header">
              <h3>Shop Catalog (${shopItems.length} items)</h3>
              <div class="filter-sort-controls">
                <div class="filter-chips">
                  <button class="filter-chip ${this.state.shopFilter === 'all' ? 'active' : ''}" data-filter="all">All</button>
                  <button class="filter-chip ${this.state.shopFilter === 'weapon' ? 'active' : ''}" data-filter="weapon">âš”ï¸ Weapons</button>
                  <button class="filter-chip ${this.state.shopFilter === 'armor' ? 'active' : ''}" data-filter="armor">ğŸ›¡ï¸ Armor</button>
                  <button class="filter-chip ${this.state.shopFilter === 'accessory' ? 'active' : ''}" data-filter="accessory">ğŸ’ Accessories</button>
                  <button class="filter-chip ${this.state.shopFilter === 'consumable' ? 'active' : ''}" data-filter="consumable">ğŸ§ª Consumables</button>
                  <button class="filter-chip ${this.state.shopFilter === 'pet' ? 'active' : ''}" data-filter="pet">ğŸ¾ Pets</button>
                  <button class="filter-chip ${this.state.shopFilter === 'spirit' ? 'active' : ''}" data-filter="spirit">âœ¨ Spirits</button>
                  <button class="filter-chip ${this.state.shopFilter === 'vehicle' ? 'active' : ''}" data-filter="vehicle">ğŸš— Vehicles</button>
                  <button class="filter-chip ${this.state.shopFilter === 'robot' ? 'active' : ''}" data-filter="robot">ğŸ¤– Robots</button>
                  <button class="filter-chip ${this.state.shopFilter === 'box' ? 'active' : ''}" data-filter="box">ğŸ Boxes</button>
                  <button class="filter-chip ${this.state.shopFilter === 'cores' ? 'active' : ''}" data-filter="cores">ğŸ”¥ Cores</button>
                  <button class="filter-chip ${this.state.shopFilter === 'supernatural' ? 'active' : ''}" data-filter="supernatural">ğŸ”® Powers</button>
                  <button class="filter-chip ${this.state.shopFilter === 'essence' ? 'active' : ''}" data-filter="essence">ğŸ’ Essence</button>
                </div>
                <select class="sort-dropdown" id="shopSort">
                  <option value="cost" ${this.state.shopSort === 'cost' ? 'selected' : ''}>Sort: Price (Low-High)</option>
                  <option value="name" ${this.state.shopSort === 'name' ? 'selected' : ''}>Sort: Name</option>
                </select>
              </div>
            </div>

            ${shopItems.length === 0 ? `
              <div class="tab-empty">
                <div class="empty-icon">ğŸª</div>
                <p>No items match filter</p>
              </div>
            ` : `
              <div class="shop-super-compact">
                ${shopItems.map(item => {
            const currency = item.currency || 'gold';
            const currencyIcon = currency === 'essence' ? 'âœ¨' : 'ğŸ’°';
            return `
                    <div class="shop-micro-card" style="border-color: ${getCategoryColor(item.category)};" data-item-id="${item.id}">
                      <div style="font-size: 18px; margin-bottom: 2px; filter: drop-shadow(1px 1px 0 rgba(255,255,255,0.3));">${item.icon}</div>
                      <div style="font-size: var(--font-tiny); font-weight: 700; color: #cfe3ff; text-align: center; line-height: 1.1; height: 16px; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; margin-bottom: 2px;">
                        ${item.name}
                      </div>
                      ${item.rank ? `<div style="font-size: 6px; padding: 1px 3px; background: ${item.rank === 'S' ? '#ffd77a' : '#4fc3f7'}; border-radius: 4px; color: #000; font-weight: 700;">${item.rank}</div>` : ''}
                      ${item.xpAmount ? `<div style="font-size: 7px; color: #38ef7d; margin: 1px 0; font-weight: 600;">â­ +${item.xpAmount} XP</div>` : ''}
                      <div style="font-size: var(--font-tiny); color: #ffd77a; margin: 2px 0; font-weight: 700;">
                        ${currencyIcon} ${(() => { const price = item.cost || item.basePrice || 0; return price >= 1000 ? (price / 1000).toFixed(1) + 'k' : price; })()}
                      </div>
                      <button class="shop-buy-btn" data-item-id="${item.id}">Buy</button>
                    </div>
            `;
          }).join('')}
              </div>
            `}
          `;

          // Attach filter listeners
          pane.querySelectorAll('.filter-chip').forEach(chip => {
            chip.addEventListener('click', () => {
              this.state.shopFilter = chip.dataset.filter;
              this.renderShopTab();
            });
          });

          // Attach sort listener
          const sortSelect = pane.querySelector('#shopSort');
          if (sortSelect) {
            sortSelect.addEventListener('change', (e) => {
              this.state.shopSort = e.target.value;
              this.renderShopTab();
            });
          }

          // Attach buy button listeners
          pane.querySelectorAll('.shop-buy-btn').forEach(btn => {
            btn.addEventListener('click', (e) => {
              e.stopPropagation();
              this.buyItem(btn.dataset.itemId);
            });
          });
        },

        buyItem(itemId) {
          const shopItem = window.gameState.shop?.inventory.find(item => item.id === itemId);
          if (!shopItem) {
            this.showToast('âŒ Item not found');
            return;
          }

          const currency = shopItem.currency || 'gold';
          const cost = shopItem.cost || shopItem.basePrice || 0;

          // Check if player has enough currency
          if (currency === 'gold' && window.gameState.gold < cost) {
            this.showToast('âŒ Not enough gold!');
            return;
          } else if (currency === 'essence' && (window.gameState.essence || 0) < cost) {
            this.showToast('âŒ Not enough essence!');
            return;
          } else if (currency === 'gems' && window.gameState.gems < cost) {
            this.showToast('âŒ Not enough gems!');
            return;
          }

          // Deduct currency
          if (currency === 'gold') window.gameState.gold -= cost;
          else if (currency === 'essence') window.gameState.essence = (window.gameState.essence || 0) - cost;
          else if (currency === 'gems') window.gameState.gems -= cost;

          // Add item to inventory
          const isGear = shopItem.category === 'gear' || shopItem.category === 'armor' || shopItem.category === 'weapon';
          
          if (isGear) {
            // Add to gear inventory
            const newGear = { ...shopItem, id: 'shop_' + Date.now() + '_' + Math.random(), slot: shopItem.slot || 'weapon' };
            this.normalizeGearItem(newGear);
            window.gameState.inventory.gear = window.gameState.inventory.gear || [];
            window.gameState.inventory.gear.push(newGear);
          } else {
            // Add to items inventory (consumables, containers, etc)
            window.gameState.inventory.items = window.gameState.inventory.items || [];
            const existingItem = window.gameState.inventory.items.find(i => i.id === itemId);
            if (existingItem) {
              existingItem.quantity = (existingItem.quantity || 1) + 1;
            } else {
              window.gameState.inventory.items.push({ ...shopItem, quantity: 1 });
            }
          }

          const currencyIcon = currency === 'essence' ? 'âœ¨' : currency === 'gems' ? 'ğŸ’' : 'ğŸ’°';
          this.showToast(`âœ… Bought ${shopItem.icon} ${shopItem.name} for ${currencyIcon}${cost}`);
          this.syncAllSystems();
        },

        renderSettingsTab() {
          const pane = document.getElementById('bagContentPane');
          const settings = window.gameState.settings || {};
          if (pane) {
            delete pane.dataset.devSettingsWrapped;
          }

          pane.innerHTML = `
        < div style = "margin-bottom: 20px;" >
              <h2 style="font-size: 22px; color: #ffd77a; margin-bottom: 10px;">âš™ï¸ Game Settings</h2>
              <p style="color: rgba(207, 227, 255, 0.7); font-size: 13px; margin-bottom: 20px;">
                Configure your game experience
              </p>
            </div >

            < !--Audio Settings-- >
            <div style="background: rgba(0, 0, 0, 0.3); border: 2px solid rgba(122, 248, 200, 0.4); border-radius: 12px; padding: 20px; margin-bottom: 16px;">
              <h3 style="color: #7af8c8; margin-bottom: 16px; font-size: 16px;">ğŸ”Š Audio</h3>
              <div style="display: grid; gap: 16px;">
                <div>
                  <label style="font-size: 12px; color: rgba(207, 227, 255, 0.8); display: block; margin-bottom: 6px;">
                    Master Volume: <strong style="color: #ffd77a;">${(settings.audio?.masterVolume * 100).toFixed(0)}%</strong>
                  </label>
                  <input type="range" min="0" max="100" value="${(settings.audio?.masterVolume * 100)}" style="width: 100%;">
                </div>
                <div>
                  <label style="font-size: 12px; color: rgba(207, 227, 255, 0.8); display: block; margin-bottom: 6px;">
                    SFX Volume: <strong style="color: #ffd77a;">${(settings.audio?.sfxVolume * 100).toFixed(0)}%</strong>
                  </label>
                  <input type="range" min="0" max="100" value="${(settings.audio?.sfxVolume * 100)}" style="width: 100%;">
                </div>
                <div>
                  <label style="font-size: 12px; color: rgba(207, 227, 255, 0.8); display: block; margin-bottom: 6px;">
                    Music Volume: <strong style="color: #ffd77a;">${(settings.audio?.musicVolume * 100).toFixed(0)}%</strong>
                  </label>
                  <input type="range" min="0" max="100" value="${(settings.audio?.musicVolume * 100)}" style="width: 100%;">
                </div>
                <div>
                  <label style="font-size: 12px; color: rgba(207, 227, 255, 0.8); display: flex; align-items: center; gap: 8px;">
                    <input type="checkbox" ${settings.audio?.audioEnabled ? 'checked' : ''}>
                    Audio Enabled
                  </label>
                </div>
              </div>
            </div>

            <!--Graphics Settings-- >
            <div style="background: rgba(0, 0, 0, 0.3); border: 2px solid rgba(0, 229, 255, 0.4); border-radius: 12px; padding: 20px; margin-bottom: 16px;">
              <h3 style="color: #00e5ff; margin-bottom: 16px; font-size: 16px;">ğŸ¨ Graphics</h3>
              <div style="display: flex; gap: 8px; margin-bottom: 16px; flex-wrap: wrap;">
                ${['performance', 'balanced', 'quality', 'ultra'].map(preset => `
                  <button class="filter-chip ${settings.graphics?.quality === preset ? 'active' : ''}" style="padding: 8px 16px;">
                    ${preset.charAt(0).toUpperCase() + preset.slice(1)}
                  </button>
                `).join('')}
              </div>
              <div style="display: grid; gap: 12px;">
                <label style="font-size: 12px; color: rgba(207, 227, 255, 0.8); display: flex; align-items: center; gap: 8px;">
                  <input type="checkbox" ${settings.graphics?.shadows ? 'checked' : ''}>
                  Shadows
                </label>
                <label style="font-size: 12px; color: rgba(207, 227, 255, 0.8); display: flex; align-items: center; gap: 8px;">
                  <input type="checkbox" ${settings.graphics?.particles ? 'checked' : ''}>
                  Particles
                </label>
                <label style="font-size: 12px; color: rgba(207, 227, 255, 0.8); display: flex; align-items: center; gap: 8px;">
                  <input type="checkbox" ${settings.graphics?.antialiasing ? 'checked' : ''}>
                  Antialiasing
                </label>
                <label style="font-size: 12px; color: rgba(207, 227, 255, 0.8); display: flex; align-items: center; gap: 8px;">
                  <input type="checkbox" ${settings.graphics?.cameraShake ? 'checked' : ''}>
                  Camera Shake
                </label>
                <div>
                  <label style="font-size: 12px; color: rgba(207, 227, 255, 0.8); display: block; margin-bottom: 6px;">
                    FPS Limit: <strong style="color: #ffd77a;">${settings.graphics?.fpsLimit}</strong>
                  </label>
                  <select style="padding: 6px 12px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(79, 195, 247, 0.3); border-radius: 6px; color: #cfe3ff; font-size: 11px; width: 100%;">
                    <option value="30" ${settings.graphics?.fpsLimit === 30 ? 'selected' : ''}>30 FPS</option>
                    <option value="60" ${settings.graphics?.fpsLimit === 60 ? 'selected' : ''}>60 FPS</option>
                    <option value="120" ${settings.graphics?.fpsLimit === 120 ? 'selected' : ''}>120 FPS</option>
                  </select>
                </div>
              </div>
            </div>

            <!--Gameplay Settings-- >
            <div style="background: rgba(0, 0, 0, 0.3); border: 2px solid rgba(255, 215, 122, 0.4); border-radius: 12px; padding: 20px; margin-bottom: 16px;">
              <h3 style="color: #ffd77a; margin-bottom: 16px; font-size: 16px;">ğŸ® Gameplay</h3>
              <div style="display: grid; gap: 12px;">
                <div>
                  <label style="font-size: 12px; color: rgba(207, 227, 255, 0.8); display: block; margin-bottom: 6px;">
                    Difficulty: <strong style="color: #ffd77a;">${settings.gameplay?.difficulty}</strong>
                  </label>
                  <select style="padding: 6px 12px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(79, 195, 247, 0.3); border-radius: 6px; color: #cfe3ff; font-size: 11px; width: 100%;">
                    <option value="easy" ${settings.gameplay?.difficulty === 'easy' ? 'selected' : ''}>Easy</option>
                    <option value="normal" ${settings.gameplay?.difficulty === 'normal' ? 'selected' : ''}>Normal</option>
                    <option value="hard" ${settings.gameplay?.difficulty === 'hard' ? 'selected' : ''}>Hard</option>
                  </select>
                </div>
                <label style="font-size: 12px; color: rgba(207, 227, 255, 0.8); display: flex; align-items: center; gap: 8px;">
                  <input type="checkbox" ${settings.gameplay?.autoSave ? 'checked' : ''}>
                  Auto-Save
                </label>
                <label style="font-size: 12px; color: rgba(207, 227, 255, 0.8); display: flex; align-items: center; gap: 8px;">
                  <input type="checkbox" ${settings.gameplay?.showTutorial ? 'checked' : ''}>
                  Show Tutorial
                </label>
                <label style="font-size: 12px; color: rgba(207, 227, 255, 0.8); display: flex; align-items: center; gap: 8px;">
                  <input type="checkbox" ${settings.gameplay?.showDamageNumbers ? 'checked' : ''}>
                  Show Damage Numbers
                </label>
                <label style="font-size: 12px; color: rgba(207, 227, 255, 0.8); display: flex; align-items: center; gap: 8px;">
                  <input type="checkbox" ${settings.gameplay?.autoPickup ? 'checked' : ''}>
                  Auto-Pickup Items
                </label>
              </div>
            </div>

            <!--Controls Settings-- >
            <div style="background: rgba(0, 0, 0, 0.3); border: 2px solid rgba(167, 139, 250, 0.4); border-radius: 12px; padding: 20px; margin-bottom: 16px;">
              <h3 style="color: #a78bfa; margin-bottom: 16px; font-size: 16px;">ğŸ¯ Controls</h3>
              <div style="display: grid; gap: 12px;">
                <div>
                  <label style="font-size: 12px; color: rgba(207, 227, 255, 0.8); display: block; margin-bottom: 6px;">
                    Mouse Sensitivity: <strong style="color: #ffd77a;">${settings.controls?.mouseSensitivity.toFixed(1)}</strong>
                  </label>
                  <input type="range" min="0.1" max="2.0" step="0.1" value="${settings.controls?.mouseSensitivity}" style="width: 100%;">
                </div>
                <label style="font-size: 12px; color: rgba(207, 227, 255, 0.8); display: flex; align-items: center; gap: 8px;">
                  <input type="checkbox" ${settings.controls?.invertY ? 'checked' : ''}>
                  Invert Y-Axis
                </label>
              </div>
            </div>

            <!--UI Settings-- >
        <div style="background: rgba(0, 0, 0, 0.3); border: 2px solid rgba(255, 122, 217, 0.4); border-radius: 12px; padding: 20px;">
          <h3 style="color: #ff7ad9; margin-bottom: 16px; font-size: 16px;">ğŸ–¥ï¸ User Interface</h3>
          <div style="display: grid; gap: 12px;">
            <label style="font-size: 12px; color: rgba(207, 227, 255, 0.8); display: flex; align-items: center; gap: 8px;">
              <input type="checkbox" ${settings.ui?.showFPS ? 'checked' : ''}>
                Show FPS Counter
            </label>
            <label style="font-size: 12px; color: rgba(207, 227, 255, 0.8); display: flex; align-items: center; gap: 8px;">
              <input type="checkbox" ${settings.ui?.showMinimap ? 'checked' : ''}>
                Show Minimap
            </label>
            <label style="font-size: 12px; color: rgba(207, 227, 255, 0.8); display: flex; align-items: center; gap: 8px;">
              <input type="checkbox" ${settings.ui?.showTooltips ? 'checked' : ''}>
                Show Tooltips
            </label>
            <div>
              <label style="font-size: 12px; color: rgba(207, 227, 255, 0.8); display: block; margin-bottom: 6px;">
                HUD Scale: <strong style="color: #ffd77a;">${settings.ui?.hudScale.toFixed(1)}x</strong>
              </label>
              <input type="range" min="0.5" max="2.0" step="0.1" value="${settings.ui?.hudScale}" style="width: 100%;">
            </div>
            <div>
              <label style="font-size: 12px; color: rgba(207, 227, 255, 0.8); display: block; margin-bottom: 6px;">
                UI Theme: <strong style="color: #ffd77a;">${settings.ui?.uiTheme}</strong>
              </label>
              <select style="padding: 6px 12px; background: rgba(0, 0, 0, 0.3); border: 1px solid rgba(79, 195, 247, 0.3); border-radius: 6px; color: #cfe3ff; font-size: 11px; width: 100%;">
                <option value="dark" ${settings.ui?.uiTheme === 'dark' ? 'selected' : ''}>Dark</option>
                <option value="light" ${settings.ui?.uiTheme === 'light' ? 'selected' : ''}>Light</option>
              </select>
            </div>
          </div>
          <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid rgba(255, 122, 217, 0.2); display: flex; gap: 12px;">
            <button class="gear-equip-btn" style="background: linear-gradient(135deg, #38ef7d, #4fc3f7); flex: 1;">
              Save Settings
            </button>
            <button class="gear-equip-btn" style="background: rgba(255, 59, 59, 0.6); flex: 1;">
              Reset to Default
            </button>
          </div>
        </div>
        <div style="margin-top: 18px; background: rgba(0, 0, 0, 0.3); border: 2px solid rgba(148, 163, 184, 0.35); border-radius: 12px; padding: 20px;">
          <h3 style="color: #7dd3fc; margin-bottom: 12px; font-size: 16px;">ğŸ§ª QA Tools</h3>
          <p style="color: rgba(207, 227, 255, 0.7); font-size: 12px; margin-bottom: 16px;">
            Trigger validation utilities instantly from the bag. All tools run offline and respect production safeguards.
          </p>
          <div id="qaToolsContainer" style="display: flex; flex-wrap: wrap; gap: 12px;"></div>
        </div>
        <div style="margin-top: 18px; background: rgba(0, 0, 0, 0.3); border: 2px solid rgba(148, 163, 184, 0.35); border-radius: 12px; padding: 20px;">
          <h3 style="color: #c084fc; margin-bottom: 12px; font-size: 16px;">ğŸŒ€ Companion Summon Sandbox</h3>
          <p style="color: rgba(207, 227, 255, 0.7); font-size: 12px; margin-bottom: 16px;">
            Toggle the currently equipped pet, vehicle, spirit, or team companion instantly or preview summon effects without combat.
          </p>
          <label style="font-size: 12px; color: rgba(207, 227, 255, 0.8); display: block; margin-bottom: 12px;">
            Companion Slot
            <select id="companionSummonType" style="margin-top: 6px; width: 100%; padding: 8px 12px; background: rgba(148, 163, 184, 0.12); border: 1px solid rgba(148, 163, 184, 0.3); border-radius: 8px; color: #cfe3ff;">
              <option value="pet">Pet</option>
              <option value="vehicle">Vehicle</option>
              <option value="spirit">Spirit</option>
              <option value="team">Team</option>
            </select>
          </label>
          <div style="display: flex; flex-wrap: wrap; gap: 12px;">
            <button class="gear-equip-btn" id="btnCompanionSummon" style="flex: 1; background: linear-gradient(135deg, #38ef7d, #4fc3f7);">
              Toggle Summon
            </button>
            <button class="gear-equip-btn" id="btnCompanionPreviewFx" style="flex: 1; background: rgba(122, 248, 200, 0.4); border: 1px solid rgba(122, 248, 200, 0.6);">
              Preview VFX
            </button>
          </div>
          <details style="margin-top: 16px; background: rgba(15, 23, 42, 0.45); border: 1px solid rgba(56, 189, 248, 0.35); border-radius: 10px; padding: 12px;">
            <summary style="cursor: pointer; font-size: 12px; color: #7dd3fc;">HUD Deploy QA Script</summary>
            <ol style="margin-top: 10px; padding-left: 20px; color: rgba(207, 227, 255, 0.82); font-size: 11px; line-height: 1.6;">
              <li>Equip a pet and vehicle core, verifying the READY badge appears on each companion card.</li>
              <li>Close the bag and click the Pet button (or press P) to confirm the active companion materializes beside A1.</li>
              <li>Click the Vehicle button (or press V) and ensure the vehicle spawns with its boarding prompt active.</li>
              <li>Toggle both buttons again to recall; confirm the glowing state disappears once the slot is empty.</li>
              <li>Inspect the browser console to ensure the deploy/recall cycle runs without warnings or errors.</li>
            </ol>
          </details>
        </div>
        `;
          try {
            const qaHost = pane.querySelector('#qaToolsContainer');
            if (qaHost) {
              const attached = window.InteriorIndicatorQA?.attach?.(qaHost);
              if (!attached) {
                qaHost.innerHTML = '<div style="color: rgba(255,107,53,0.7); font-size: 12px;">Interior indicator toggle unavailable.</div>';
              }
            }
          } catch (error) {
            debugError('[BagSystem] Failed to attach QA tools', error);
          }
          try {
            wrapDevSettingsLayout(pane);
            applyDevSettingsTabs(pane);
          } catch (error) {
            debugError('[BagSettings] Failed to initialize Dev Settings layout:', error);
          }
          const sandboxTypes = ['pet', 'vehicle', 'spirit', 'team'];
          const companionSelect = pane.querySelector('#companionSummonType');
          const summonBtn = pane.querySelector('#btnCompanionSummon');
          const previewBtn = pane.querySelector('#btnCompanionPreviewFx');
          const resolveManager = () =>
            window.A1K_Engine?.systems?.companion || window.CompanionManager || null;
          window.debugSummonCompanion = function (type = 'pet') {
            const normalized = String(type || 'pet').toLowerCase();
            if (!sandboxTypes.includes(normalized)) {
              debugWarn('[CompanionSandbox] Unsupported companion slot:', type);
              return false;
            }
            const manager = resolveManager();
            if (!manager || typeof manager.toggleCompanion !== 'function') {
              window.notify?.('Companion system not ready yet.', '#ff7a6a');
              return false;
            }
            const equipped = manager.getEquippedItem?.(normalized) || null;
            const wasActive = equipped && typeof manager.isSpawned === 'function' && manager.isSpawned(equipped.uid);
            manager.toggleCompanion(normalized);
            const isActive = equipped && typeof manager.isSpawned === 'function' && manager.isSpawned(equipped.uid);
            if (equipped) {
              if (isActive && !wasActive) {
                window.notify?.(`Summoned ${equipped.name || normalized}`, '#c1ffc1');
              } else if (!isActive && wasActive) {
                window.notify?.(`Recalled ${equipped.name || normalized}`, '#ffd56a');
              } else {
                window.notify?.(`Toggled ${equipped.name || normalized}`, '#cfe3ff');
              }
            } else {
              window.notify?.(`No ${normalized} equipped`, '#ff7a6a');
            }
            return true;
          };
          window.debugPreviewSummonFx = function (type = 'pet') {
            const normalized = String(type || 'pet').toLowerCase();
            if (!sandboxTypes.includes(normalized)) {
              debugWarn('[CompanionSandbox] Unsupported preview slot:', type);
              return false;
            }
            const manager = resolveManager();
            if (manager?.previewSummonFx) {
              manager.previewSummonFx(normalized);
              window.notify?.(`Previewed ${normalized} summon effect`, '#7dd3fc');
              return true;
            }
            window.notify?.('Summon preview unavailable.', '#ff7a6a');
            return false;
          };
          summonBtn?.addEventListener('click', () => {
            const slot = companionSelect?.value || 'pet';
            window.debugSummonCompanion(slot);
          });
          previewBtn?.addEventListener('click', () => {
            const slot = companionSelect?.value || 'pet';
            window.debugPreviewSummonFx(slot);
          });
        },

        updateStats() {
          const left = document.getElementById('bagStatsLeft');
          const right = document.getElementById('bagStatsRight');

          left.innerHTML = `
            <div class="stat-item">HP: ${100 + this.calculateEquipmentStat('hp')}</div>
            <div class="stat-item">ATK: ${10 + this.calculateEquipmentStat('attack')}</div>
            <div class="stat-item">DEF: ${5 + this.calculateEquipmentStat('defense')}</div>
          `;

          right.innerHTML = `ğŸ’° ${window.gameState.gold.toLocaleString()} g`;
        },

        attachEventListeners() {
          document.getElementById('closeBagBtn').addEventListener('click', () => this.close());
          document.getElementById('minimizeBagBtn').addEventListener('click', () => this.close());

          // Draggable window - FIXED for no stuck states
          let isDragging = false;
          let dragOffsetX = 0;
          let dragOffsetY = 0;
          const titlebar = document.getElementById('bagTitlebar');
          const bagWindow = document.getElementById('bagWindow');

          titlebar.addEventListener('mousedown', (e) => {
            // Only drag if clicking directly on titlebar (not buttons)
            if (e.target.closest('.titlebar-btn')) return;
            
            isDragging = true;
            const rect = bagWindow.getBoundingClientRect();
            dragOffsetX = e.clientX - rect.left;
            dragOffsetY = e.clientY - rect.top;
            
            // Change cursor
            document.body.style.cursor = 'grabbing';
            titlebar.style.cursor = 'grabbing';
            
            // Prevent text selection during drag
            e.preventDefault();
          });

          const handleMouseMove = (e) => {
            if (!isDragging) return;
            
            // Calculate new position
            let newX = e.clientX - dragOffsetX;
            let newY = e.clientY - dragOffsetY;
            
            // Bounds checking (keep window on screen)
            const maxX = window.innerWidth - bagWindow.offsetWidth;
            const maxY = window.innerHeight - bagWindow.offsetHeight;
            
            newX = Math.max(0, Math.min(newX, maxX));
            newY = Math.max(0, Math.min(newY, maxY));
            
            // Apply position (remove centered transform)
            bagWindow.style.left = `${newX}px`;
            bagWindow.style.top = `${newY}px`;
              bagWindow.style.transform = 'none';
          };

          const stopDragging = () => {
            if (isDragging) {
              isDragging = false;
              document.body.style.cursor = '';
              titlebar.style.cursor = 'move';
            }
          };

          document.addEventListener('mousemove', handleMouseMove);
          document.addEventListener('mouseup', stopDragging);
          
          // Also stop dragging if mouse leaves window
          document.addEventListener('mouseleave', stopDragging);

          // Auto button event listeners
          document.getElementById('openAllBtn')?.addEventListener('click', () => this.openAllContainers());
          document.getElementById('autoUpBtn')?.addEventListener('click', () => this.autoUpgrade());
          document.getElementById('autoEqBtn')?.addEventListener('click', () => this.autoEquip());
          document.getElementById('autoFuseBtn')?.addEventListener('click', () => this.autoFuse());
          document.getElementById('autoSellBtn')?.addEventListener('click', () => this.autoSell());
          document.getElementById('autoAlchemyBtn')?.addEventListener('click', () => this.performAutoAlchemy());
          const autoAIBtn = document.getElementById('autoAIBtn');
          if (autoAIBtn) {
            if (!this.autoAIClickHandler) {
              this.autoAIClickHandler = () => this.toggleAutoAI();
            } else {
              autoAIBtn.removeEventListener('click', this.autoAIClickHandler);
            }
            autoAIBtn.addEventListener('click', this.autoAIClickHandler);
          }
          this.updateAutoAIButton();
        },

        showToast(message) {
          const container = document.querySelector('.toast-container');
          const toast = document.createElement('div');
          toast.className = 'toast';
          toast.textContent = message;
          container.appendChild(toast);
          setTimeout(() => toast.remove(), 3000);
        },

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // AUTO FUNCTIONS & SYNC SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

        syncAllSystems() {
          this.renderCurrencies();
          this.updateStats();
        },

        loadPersistedGameState() {
          try {
            const raw = localStorage.getItem('a1k_bag_gamestate');
            if (!raw) return null;
            return JSON.parse(raw);
          } catch (error) {
            debugWarn('[BagSystem] Failed to parse persisted game state snapshot.', error);
            return null;
          }
        },

        applyPersistedSnapshot(snapshot) {
          if (!snapshot || typeof snapshot !== 'object') return;
          const gs = window.gameState = window.gameState || {};

          if (snapshot.currentCharacter) {
            gs.currentCharacter = snapshot.currentCharacter;
          }

          if (snapshot.equippedSkills) {
            gs.equippedSkills = this.migrateLegacyEquippedSkills(snapshot.equippedSkills);
          }
          
          // Restore Ability Points System data (backward compatible)
          if (snapshot.abilityPoints !== undefined) gs.abilityPoints = snapshot.abilityPoints;
          if (snapshot.pointsInStrength !== undefined) gs.pointsInStrength = snapshot.pointsInStrength;
          if (snapshot.pointsInVitality !== undefined) gs.pointsInVitality = snapshot.pointsInVitality;
          if (snapshot.pointsInAgility !== undefined) gs.pointsInAgility = snapshot.pointsInAgility;
          if (snapshot.pointsInIntelligence !== undefined) gs.pointsInIntelligence = snapshot.pointsInIntelligence;
          if (snapshot.playerLevel !== undefined) gs.playerLevel = snapshot.playerLevel;
          if (snapshot.xp !== undefined) gs.xp = snapshot.xp;
          if (snapshot.xpToNext !== undefined) gs.xpToNext = snapshot.xpToNext;
          
          // Restore Talent Points System data (backward compatible)
          if (snapshot.talents && typeof snapshot.talents === 'object') {
            if (!gs.talents) gs.talents = {};
            if (snapshot.talents.points !== undefined) gs.talents.points = snapshot.talents.points;
            if (Array.isArray(snapshot.talents.tree)) gs.talents.tree = snapshot.talents.tree;
            if (Array.isArray(snapshot.talents.allocated)) gs.talents.allocated = snapshot.talents.allocated;
            if (Array.isArray(snapshot.talents.synergies)) gs.talents.synergies = snapshot.talents.synergies;
          }
        },

        saveGameState() {
          try {
            const charOrder = ['A1', 'MISSY', 'UNIQUE'];
            charOrder.forEach(charId => this.syncCharacterLoadoutFromQuickSlots(charId));
            this.ensureCurrentCharacter();
            localStorage.setItem('a1k_bag_gamestate', JSON.stringify(window.gameState));
          } catch (e) {
            debugWarn('Failed to save game state:', e);
          }
          
          if (typeof window.saveGame === 'function') {
            window.saveGame();
          }
        },

        openAllContainers() {
          const containers = (window.gameState.inventory.items || []).filter(item => item.category === 'container' && item.quantity > 0);
          
          if (containers.length === 0) {
            this.showToast('ğŸ“¦ No containers to open');
            return;
          }

          let totalOpened = 0;
          let totalGold = 0;

          containers.forEach(container => {
            while (container.quantity > 0) {
              const goldGain = Math.floor(Math.random() * 100) + 50;
              totalGold += goldGain;
              totalOpened++;
              container.quantity--;
            }
          });

          window.gameState.inventory.items = window.gameState.inventory.items.filter(item => 
            item.category !== 'container' || item.quantity > 0
          );

          window.gameState.gold += totalGold;
          this.showToast(`ğŸ“¦ Opened ${totalOpened} containers! +${totalGold} gold`);
          this.addSystemMessage(`ğŸ“¦ OPENED ${totalOpened} containers, gained ${totalGold} gold`, 'reward');
          this.syncAllSystems();
          // FORCE FULL RENDER to show changes
          this.render();
        },

        autoUpgrade() {
          const gear = window.gameState.inventory.gear || [];
          const equipped = window.gameState.equipped;
          const upgradableGear = gear.filter(g => g.level && g.level < 10);

          if (upgradableGear.length === 0) {
            this.showToast('âš¡ No items to upgrade');
            return;
          }

          let upgraded = 0;
          const costPerUpgrade = 100;
          const upgradedDetails = [];
          
          upgradableGear.forEach(item => {
            if (window.gameState.gold >= costPerUpgrade && item.level < 10) {
              const oldLevel = item.level || 1;
              const oldAtk = item.attack || 0;
              const oldDef = item.defense || 0;
              
              window.gameState.gold -= costPerUpgrade;
              item.level = oldLevel + 1;
              if (item.attack) item.attack = Math.floor(item.attack * 1.15);
              if (item.defense) item.defense = Math.floor(item.defense * 1.15);
              if (item.hp) item.hp = Math.floor(item.hp * 1.15);
              upgraded++;
              
              upgradedDetails.push(`${item.icon} ${item.name} Lv.${oldLevel}â†’${item.level}`);
            }
          });
          
          // Also upgrade equipped items
          Object.values(equipped).forEach(item => {
            if (item && item.level && item.level < 10 && window.gameState.gold >= costPerUpgrade) {
              const oldLevel = item.level || 1;
              window.gameState.gold -= costPerUpgrade;
              item.level = oldLevel + 1;
              if (item.attack) item.attack = Math.floor(item.attack * 1.15);
              if (item.defense) item.defense = Math.floor(item.defense * 1.15);
              if (item.hp) item.hp = Math.floor(item.hp * 1.15);
              upgraded++;
              upgradedDetails.push(`${item.icon} ${item.name} Lv.${oldLevel}â†’${item.level} (EQUIPPED)`);
            }
          });

          if (upgraded > 0) {
            this.showToast(`âš¡ Upgraded ${upgraded} items!`);
            this.addSystemMessage(`âš¡ UPGRADED: ${upgradedDetails.slice(0, 5).join(', ')}${upgradedDetails.length > 5 ? ` +${upgradedDetails.length - 5} more` : ''}`, 'reward');
            this.syncAllSystems();
            // FORCE FULL RENDER to show stat changes
            this.render();
          } else {
            this.showToast('ğŸ’° Not enough gold!');
          }
        },


        autoFuse() {
          const items = window.gameState.inventory.items || [];
          const gear = window.gameState.inventory.gear || [];
          
          let fusedCount = 0;
          let goldGained = 0;

          const shouldSkipFusion = (entry) => {
            if (!entry) return false;
            const rank = (entry.rank || '').toUpperCase();
            const rarity = (entry.rarity || '').toLowerCase();
            return rank.startsWith('S') || rarity === 'legendary';
          };

          const itemGroups = {};
          items.forEach(item => {
            if (shouldSkipFusion(item)) {
              return;
            }
            if (item.quantity >= 3) {
              itemGroups[item.id] = item;
            }
          });

          Object.values(itemGroups).forEach(item => {
            const fuseSets = Math.floor(item.quantity / 3);
            if (fuseSets > 0) {
              item.quantity -= fuseSets * 3;
              goldGained += fuseSets * 200;
              fusedCount += fuseSets;
            }
          });

          window.gameState.inventory.items = items.filter(item => item.quantity > 0);

          const gearGroups = {};
          gear.forEach(g => {
            if (shouldSkipFusion(g)) {
              return;
            }
            if (!gearGroups[g.name]) gearGroups[g.name] = [];
            gearGroups[g.name].push(g);
          });

          Object.values(gearGroups).forEach(group => {
            if (group.length >= 2) {
              group.sort((a, b) => ((b.attack || 0) + (b.defense || 0)) - ((a.attack || 0) + (a.defense || 0)));
              const keep = group[0];
              group.slice(1).forEach(g => {
                window.gameState.inventory.gear = window.gameState.inventory.gear.filter(item => item !== g);
                goldGained += 100;
                fusedCount++;
              });
            }
          });

          window.gameState.gold += goldGained;

          if (fusedCount > 0) {
            this.showToast(`âš—ï¸ Fused ${fusedCount} items! +${goldGained} gold`);
            this.addSystemMessage(`âš—ï¸ FUSED ${fusedCount} items for ${goldGained} gold`, 'reward');
            this.syncAllSystems();
            // FORCE FULL RENDER to show changes
            this.render();
          } else {
            this.showToast('âš—ï¸ Nothing to fuse');
          }
        },

        autoSell() {
          const items = window.gameState.inventory.items || [];
          const gear = window.gameState.inventory.gear || [];
          
          let soldCount = 0;
          let goldGained = 0;

          const itemsToSell = items.filter(item => {
            return item.category === 'consumable' && (item.cost || 0) < 100;
          });

          itemsToSell.forEach(item => {
            const sellPrice = Math.floor((item.cost || 50) * item.quantity * 0.5);
            goldGained += sellPrice;
            soldCount += item.quantity;
            window.gameState.inventory.items = window.gameState.inventory.items.filter(i => i !== item);
          });

          const gearToSell = gear.filter(g => {
            const rank = g.rank || 'C';
            return rank === 'E' || rank === 'D' || rank === 'C';
          });

          gearToSell.forEach(g => {
            const sellPrice = Math.floor((g.cost || 100) * 0.5);
            goldGained += sellPrice;
            soldCount++;
            window.gameState.inventory.gear = window.gameState.inventory.gear.filter(item => item !== g);
          });

          window.gameState.gold += goldGained;

          if (soldCount > 0) {
            this.showToast(`ğŸ’° Sold ${soldCount} items for ${goldGained} gold!`);
            this.addSystemMessage(`ğŸ’° SOLD ${soldCount} junk items for ${goldGained} gold`, 'reward');
            this.syncAllSystems();
            // FORCE FULL RENDER to show changes
            this.render();
          } else {
            this.showToast('ğŸ’° No junk items to sell');
          }
        },

        toggleAutoAI() {
          // Check requirements
          const reqCheck = this.checkRequirements('ai');
          if (!reqCheck.met) {
            this.showToast(reqCheck.message.split('\n')[0]); // Show first line
            debugWarn('[AI] Requirements not met:', reqCheck.message);
            return;
          }

          window.gameState.settings = window.gameState.settings || {};
          const isEnabled = !window.gameState.settings.autoAI;
          window.gameState.settings.autoAI = isEnabled;

          if (window.gameState.soloLevelingSystem) {
            window.gameState.soloLevelingSystem.aiAutoMode = isEnabled;
          }

          this.updateAutoAIButton();
          this.showToast(isEnabled ? 'ğŸ¤– Auto AI: ON' : 'ğŸ¤– Auto AI: OFF');

          if (isEnabled) {
            this.startAutoAILoop();
          } else {
            this.stopAutoAILoop();
          }

          this.saveGameState();
        },

        updateAutoAIButton() {
          const btn = document.getElementById('autoAIBtn');
          if (!btn) return;
          const enabled = !!(window.gameState.settings && window.gameState.settings.autoAI);
          btn.textContent = `Auto AI: ${enabled ? 'ON' : 'OFF'}`;
          btn.style.background = enabled ? 'rgba(76, 209, 55, 0.2)' : 'rgba(255, 107, 107, 0.2)';
          btn.style.border = `2px solid ${enabled ? 'rgba(76, 209, 55, 0.4)' : 'rgba(255, 107, 107, 0.4)'}`;
          btn.style.color = enabled ? '#4cd137' : '#ff6b6b';
        },

        getAutoAILoopDelay() {
          const iterations = this.autoAILoopIterations || 0;
          
          // Check elapsed time for auto-stop after 60 seconds
          if (this.autoAILoopStartTime) {
            const elapsedSeconds = (Date.now() - this.autoAILoopStartTime) / 1000;
            
            // Last 10 seconds: speed up significantly (200ms delay)
            if (elapsedSeconds >= 50 && elapsedSeconds < 60) {
              return 200;
            }
            
            // Stop after 60 seconds
            if (elapsedSeconds >= 60) {
              return null; // Signal to stop
            }
          }
          
          // Progressive speed increase based on iterations
          if (iterations > 30) return 1000;
          if (iterations > 15) return 2000;
          if (iterations > 5) return 3000;
          return 5000;
        },

        runAutoAITasks() {
          return this.runSequentialAITasks();
        },

        buildAutoAITaskQueue() {
          const queue = [];
          const slots = ['weapon', 'offhand', 'head', 'chest', 'gloves', 'pants', 'boots', 'ring1', 'ring2', 'necklace'];
          
          slots.forEach(slot => {
            queue.push({ type: 'equip', slot });
            queue.push({ type: 'upgradeEquipped', slot });
          });
          
          queue.push({ type: 'fuse' });
          queue.push({ type: 'alchemy' });
          
          return queue;
        },

        runSequentialAITasks() {
          const queue = this.buildAutoAITaskQueue();
          if (!queue.length) return Promise.resolve();

          this.autoAITaskQueue = queue;
          this.autoAITaskActive = true;

          return new Promise(resolve => {
            const runNext = () => {
              if (!window.gameState.settings?.autoAI) {
                this.autoAITaskQueue = [];
                this.autoAITaskActive = false;
                if (this.autoAITaskTimeout) {
                  clearTimeout(this.autoAITaskTimeout);
                  this.autoAITaskTimeout = null;
                }
                resolve();
                return;
              }

              const task = this.autoAITaskQueue.shift();
              if (!task) {
                this.autoAITaskActive = false;
                if (this.autoAITaskTimeout) {
                  clearTimeout(this.autoAITaskTimeout);
                  this.autoAITaskTimeout = null;
                }
                resolve();
                return;
              }

              try {
                this.executeAITask(task);
              } catch (error) {
                debugError('[AutoAI] Task execution failed:', error);
              }

              if (this.autoAITaskTimeout) {
                clearTimeout(this.autoAITaskTimeout);
              }

              this.autoAITaskTimeout = window.setTimeout(runNext, 300);
            };

            runNext();
          });
        },

        executeAITask(task) {
          if (!task) return;
          switch (task.type) {
            case 'equip':
              this.autoEquipSlot(task.slot);
              break;
            case 'upgradeEquipped':
              this.autoUpgradeEquippedSlot(task.slot);
              break;
            case 'fuse':
              this.autoFuseStep();
              break;
            case 'alchemy':
              this.autoAlchemyStep();
              break;
            default:
              break;
          }
        },

        autoEquipSlot(slotName) {
          if (!slotName) return false;
          const gear = window.gameState.inventory.gear || [];
          let candidates = gear.filter(item => {
            if (!item) return false;
            if (slotName === 'ring1' || slotName === 'ring2') {
              return item.slot === 'ring';
            }
            return item.slot === slotName;
          });

          if (candidates.length === 0) {
            return false;
          }

          candidates.sort((a, b) => this.calculateItemPower(b) - this.calculateItemPower(a));
          const bestItem = candidates[0];
          const currentItem = window.gameState.equipped?.[slotName];

          if (!bestItem) return false;
          if (currentItem && this.calculateItemPower(currentItem) >= this.calculateItemPower(bestItem)) {
            return false;
          }

          window.gameState.equipped = window.gameState.equipped || {};
          window.gameState.equipped[slotName] = bestItem;

          const index = gear.indexOf(bestItem);
          if (index !== -1) {
            gear.splice(index, 1);
          }

          this.showToast(`âš”ï¸ Equipped ${bestItem.icon || ''} ${bestItem.name}`);
          this.renderGearTab();
          this.updateStats();
          return true;
        },

        autoUpgradeEquippedSlot(slotName) {
          if (!slotName) return false;
          const equipped = window.gameState.equipped || {};
          const item = equipped[slotName];
          if (!item) return false;

          const rank = (item.rank || '').toUpperCase();
          const rarity = (item.rarity || '').toLowerCase();
          if (rank === 'A' || rank.startsWith('S') || rarity === 'legendary') {
            return false;
          }

          const result = this.performGearUpgrade(item);
          if (result.upgraded) {
            this.showToast(`â¬†ï¸ Upgraded ${item.icon || ''} ${item.name} to Lv.${result.newLevel}`);
            this.syncAllSystems();
            this.renderGearTab();
            return true;
          }

          if (result.reason === 'NO_GOLD') {
            this.showToast('ğŸ’° Not enough gold to upgrade!');
          }

          return false;
        },

        autoFuseStep() {
          const shouldSkipFusion = (entry) => {
            if (!entry) return false;
            const rank = (entry.rank || '').toUpperCase();
            const rarity = (entry.rarity || '').toLowerCase();
            return rank.startsWith('S') || rarity === 'legendary';
          };

          const items = window.gameState.inventory.items || [];
          for (let i = 0; i < items.length; i++) {
            const item = items[i];
            if (!item || shouldSkipFusion(item)) continue;
            if (item.quantity >= 3) {
              item.quantity -= 3;
              window.gameState.gold += 200;
              if (item.quantity <= 0) {
                items.splice(i, 1);
              }
              this.showToast(`âš—ï¸ Fused ${item.name}! +200 gold`);
              this.syncAllSystems();
              this.renderItemsTab();
              return true;
            }
          }

          const gear = window.gameState.inventory.gear || [];
          const gearMap = {};
          gear.forEach(g => {
            if (!g || shouldSkipFusion(g)) return;
            const key = g.templateId || g.id || g.name;
            if (!gearMap[key]) gearMap[key] = [];
            gearMap[key].push(g);
          });

          for (const group of Object.values(gearMap)) {
            if (!group || group.length < 2) continue;
            group.sort((a, b) => this.calculateItemPower(b) - this.calculateItemPower(a));
            const keep = group[0];
            const remove = group[1];
            const index = gear.indexOf(remove);
            if (index !== -1) {
              gear.splice(index, 1);
              window.gameState.gold += 100;
              this.showToast(`âš—ï¸ Combined duplicate ${keep.name}! +100 gold`);
              this.syncAllSystems();
              this.renderGearTab();
              return true;
            }
          }

          return false;
        },

        autoAlchemyStep() {
          const upgrades = window.gameState.alchemyUpgrades || { craftCount: 0 };
          const before = upgrades.craftCount || 0;
          this.performAutoAlchemy();
          const after = upgrades.craftCount || 0;
          return after > before;
        },

        startAutoAILoop() {
          this.stopAutoAILoop();
          this.autoAILoopIterations = 0;
          this.autoAILoopStartTime = Date.now(); // Track start time for 60-second auto-stop

          const loop = () => {
            if (!window.gameState.settings?.autoAI) {
              this.stopAutoAILoop();
              return;
            }

            // Check if 60 seconds have elapsed
            const elapsedSeconds = (Date.now() - this.autoAILoopStartTime) / 1000;
            if (elapsedSeconds >= 60) {
              this.showToast('â±ï¸ Auto AI: Stopped after 1 minute');
              window.gameState.settings.autoAI = false; // Disable setting
              this.updateAutoAIButton(); // Update button state
              this.stopAutoAILoop();
              return;
            }

            this.runAutoAITasks().then(() => {
              this.autoAILoopIterations += 1;

              const delay = this.getAutoAILoopDelay();
              if (delay === null) {
                this.showToast('â±ï¸ Auto AI: Stopped after 1 minute');
                window.gameState.settings.autoAI = false; // Disable setting
                this.updateAutoAIButton(); // Update button state
                this.stopAutoAILoop();
                return;
              }
              
              this.autoAILoopInterval = window.setTimeout(loop, delay);
            });
          };

          const initialDelay = this.getAutoAILoopDelay();
          this.autoAILoopInterval = window.setTimeout(loop, initialDelay);
        },

        stopAutoAILoop() {
          if (this.autoAILoopInterval) {
            clearTimeout(this.autoAILoopInterval);
            this.autoAILoopInterval = null;
          }
          if (this.autoAITaskTimeout) {
            clearTimeout(this.autoAITaskTimeout);
            this.autoAITaskTimeout = null;
          }
          this.autoAILoopIterations = 0;
          this.autoAILoopStartTime = null; // Reset start time
          this.autoAITaskQueue = [];
          this.autoAITaskActive = false;
        },

        equipSkill(skillId, targetSlotNum = null) {
          const skills = window.gameState.inventory.skills || [];
          const skill = skills.find(s => s.id === skillId);
          if (!skill) return;
          
          // Initialize equippedSkills if needed
          if (!window.gameState.equippedSkills) {
            window.gameState.equippedSkills = { slot1: null, slot2: null, slot3: null };
          }
          
          const equippedSkills = window.gameState.equippedSkills;
          
          // Check if already equipped in any slot
          if (equippedSkills.slot1?.id === skillId || 
              equippedSkills.slot2?.id === skillId || 
              equippedSkills.slot3?.id === skillId) {
            this.showToast(`âš ï¸ ${skill.name} is already equipped!`);
            return;
          }
          
          // Determine target slot
          let targetSlot = null;
          if (targetSlotNum === 1 || targetSlotNum === 2 || targetSlotNum === 3) {
            // Equip to specific slot number
            targetSlot = `slot${targetSlotNum}`;
            if (equippedSkills[targetSlot]) {
              this.showToast(`âš ï¸ Replacing ${equippedSkills[targetSlot].name} with ${skill.name}`);
            }
          } else {
            // Find first available slot or replace first one
            if (!equippedSkills.slot1) {
              targetSlot = 'slot1';
            } else if (!equippedSkills.slot2) {
              targetSlot = 'slot2';
            } else if (!equippedSkills.slot3) {
              targetSlot = 'slot3';
            } else {
              // All slots full - replace the first one
              targetSlot = 'slot1';
              this.showToast(`âš ï¸ Replacing ${equippedSkills.slot1.name} with ${skill.name}`);
            }
          }
          
          // Equip the skill (store full skill object)
          window.gameState.equippedSkills[targetSlot] = { ...skill };

          // Reflect quick slot changes back into the owning character loadout so both structures stay aligned.
          if (skill.characterId) {
            this.syncCharacterLoadoutFromQuickSlots(skill.characterId);
          }
          
          // Show success notification
          const slotLabel = targetSlot === 'slot1' ? 'S1' : targetSlot === 'slot2' ? 'S2' : 'S3';
          this.showToast(`âœ… Equipped ${skill.icon} ${skill.name} to ${slotLabel}!`);
          
          // Play equip animation
          const allCards = document.querySelectorAll('.skill-card');
          allCards.forEach(card => {
            if (card.getAttribute('onclick') && card.getAttribute('onclick').includes(skillId)) {
              card.style.animation = 'equip-flash 0.5s ease';
              setTimeout(() => {
                card.style.animation = '';
              }, 500);
            }
          });
          
          // Trigger character animation if sprite exists
          this.triggerSkillEquipAnimation(skill);
          
          // Refresh the skills tab to show updated slots
          this.renderSkillsTab();
          this.syncAllSystems();
        },

        unequipSkill(slotKey) {
          if (!window.gameState.equippedSkills) return;
          
          const skill = window.gameState.equippedSkills[slotKey];
          if (!skill) return;
          
          // Unequip the skill
          window.gameState.equippedSkills[slotKey] = null;
          
          const slotLabel = slotKey === 'slot1' ? 'S1' : slotKey === 'slot2' ? 'S2' : 'S3';
          this.showToast(`âŒ Unequipped ${skill.icon} ${skill.name} from ${slotLabel}`);
          
          // Refresh the skills tab
          this.renderSkillsTab();
          this.syncAllSystems();
        },

        showSlotEquipMenu(slotKey) {
          // Show menu to pick a skill to equip to this slot
          const skills = window.gameState.inventory.skills || [];
          const currentChar = window.gameState.currentCharacter || 'A1';
          const availableSkills = skills.filter(s => 
            s.characterId === currentChar && 
            window.gameState.equippedSkills.slot1?.id !== s.id &&
            window.gameState.equippedSkills.slot2?.id !== s.id &&
            window.gameState.equippedSkills.slot3?.id !== s.id
          );
          
          if (availableSkills.length === 0) {
            this.showToast('âš ï¸ No available skills to equip!');
            return;
          }
          
          // Create a simple prompt - user can click skill cards to equip
          this.showToast(`ğŸ’¡ Click any skill card below to equip it to ${slotKey === 'slot1' ? 'S1' : slotKey === 'slot2' ? 'S2' : 'S3'}`);
        },

        triggerSkillEquipAnimation(skill) {
          // Trigger character sprite animation when skill is equipped
          const canvas = document.getElementById('gearCharacterCanvas');
          if (!canvas) return;
          
          // Add a visual effect to show skill was equipped
          const ctx = canvas.getContext('2d');
          if (!ctx) return;
          
          // Create a flash effect with skill color
          const skillColors = {
            PHYSICAL: '#ff6b6b',
            FIRE: '#ff9800',
            ICE: '#4fc3f7',
            LIGHTNING: '#ffeb3b',
            SHADOW: '#9c27b0',
            LIGHT: '#fff',
            ARCANE: '#9a6bff'
          };
          
          let flashAlpha = 0.8;
          const flashColor = skillColors[skill.element] || '#4fc3f7';
          
          const flash = () => {
            ctx.save();
            ctx.globalAlpha = flashAlpha;
            ctx.fillStyle = flashColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.restore();
            
            flashAlpha -= 0.15;
            if (flashAlpha > 0) {
              requestAnimationFrame(flash);
            } else {
              // Redraw character after flash
              setTimeout(() => this.renderGearCharacterSprite(), 50);
            }
          };
          
          flash();
        }
      };
    })();

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // MAP GAME SYNC SYSTEM
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    window.MapGameSync = {
      syncInterval: null,
      lastGoldValue: 0,
      syncCount: 0,
      
      startSync() {
        debugLog('[MapGameSync] Starting sync...');
        this.lastGoldValue = window.gameState.gold;
        this.updateSyncIndicator('syncing');
        this.pullGameState();
        
        this.syncInterval = setInterval(() => {
          this.syncCount++;
          this.updateSyncIndicator('syncing');
          this.pullGameState();
        }, 2000);
      },

      stopSync() {
        debugLog('[MapGameSync] Stopping sync...');
        if (this.syncInterval) {
          clearInterval(this.syncInterval);
          this.syncInterval = null;
        }
      },

      pullGameState() {
        const frame = document.getElementById('mapGameFrame');
        if (!frame || !frame.contentWindow) return;

        try {
          const gameState = frame.contentWindow.GameState;
          if (gameState) {
            const oldGold = this.lastGoldValue || window.gameState.gold;
            window.gameState.gold = gameState.gold || window.gameState.gold;
            
            if (window.gameState.gold > oldGold) {
              const diff = window.gameState.gold - oldGold;
              window.BagSystem.showToast('ğŸ’° +' + diff + ' Gold from map game!');
              this.createGoldGainEffect(diff);
            }
            
            this.lastGoldValue = window.gameState.gold;

            if (gameState.inventory && Array.isArray(gameState.inventory)) {
              this.mergeInventory(gameState.inventory);
            }

            if (gameState.currentZone) {
              if (!window.gameState.mapProgress.discoveredZones.includes(gameState.currentZone)) {
                window.gameState.mapProgress.discoveredZones.push(gameState.currentZone);
              }
            }

            if (gameState.party && gameState.party[0]) {
              window.gameState.mapProgress.lastPosition = {
                x: Math.round(gameState.party[0].x) || 400,
                y: Math.round(gameState.party[0].y) || 300,
                zone: gameState.currentZone || 'city'
              };
            }

            if (gameState.party && gameState.party[0]) {
              window.gameState.level = gameState.party[0].level || window.gameState.level;
              window.gameState.xp = gameState.party[0].xp || window.gameState.xp;
            }

            this.updateMapGameStats();
            window.BagSystem.syncAllSystems();
            this.updateSyncIndicator('synced');
          }
        } catch (err) {
          debugWarn('[MapGameSync] Error:', err.message);
          this.updateSyncIndicator('error');
        }
      },

      mergeInventory(mapGameInventory) {
        mapGameInventory.forEach(item => {
          const existing = window.gameState.inventory.items.find(i => i.id === item.id);
          if (existing) {
            existing.quantity = (existing.quantity || 1) + (item.quantity || 1);
          } else {
            window.gameState.inventory.items.push({ ...item });
          }
        });
      },

      updateMapGameStats() {
        const statsEl = document.getElementById('mapGameStats');
        if (statsEl) {
          const mapProgress = window.gameState.mapProgress || {};
          statsEl.innerHTML = 
            '<div>ğŸ’° Gold: ' + window.gameState.gold.toLocaleString() + '</div>' +
            '<div>ğŸ“ Zone: ' + (mapProgress.lastPosition?.zone || 'Unknown') + '</div>' +
            '<div>â­ Level: ' + (window.gameState.level || 1) + '</div>';
        }
      },

      updateSyncIndicator(status) {
        const indicator = document.getElementById('syncIndicator');
        if (!indicator) return;
        
        indicator.className = 'sync-indicator';
        
        if (status === 'synced') {
          indicator.textContent = 'âœ“ Synced';
        } else if (status === 'syncing') {
          indicator.classList.add('syncing');
          indicator.textContent = 'âŸ³ Syncing...';
        } else if (status === 'error') {
          indicator.classList.add('error');
          indicator.textContent = 'âœ— Error';
        }
      },
      
      createGoldGainEffect(amount) {
        const effect = document.createElement('div');
        effect.textContent = '+' + amount + 'g';
        effect.style.cssText = 
          'position: fixed;' +
          'top: 50%;' +
          'left: 50%;' +
          'transform: translate(-50%, -50%);' +
          'font-size: 48px;' +
          'font-weight: 700;' +
          'color: #ffd77a;' +
          'text-shadow: 0 0 20px rgba(255, 215, 122, 0.8);' +
          'pointer-events: none;' +
          'z-index: 10000;' +
          'animation: goldFloat 2s ease-out forwards;';
        document.body.appendChild(effect);
        setTimeout(() => effect.remove(), 2000);
      }
    };

    const goldFloatStyle = document.createElement('style');
    goldFloatStyle.textContent = 
      '@keyframes goldFloat {' +
      '  0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }' +
      '  20% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }' +
      '  100% { opacity: 0; transform: translate(-50%, -150%) scale(0.8); }' +
      '}';
    document.head.appendChild(goldFloatStyle);

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // AI KNOWLEDGE BASE - 400k Token Offline Encyclopedia
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    window.AIKnowledgeBase = {
      conversationContext: [],
      lastTopic: null,
      
      greetings: {
        patterns: ['hi', 'hey', 'hello', 'sup', 'yo', 'heya', 'greetings', 'howdy'],
        responses: [
          "Hey there! Ready to dominate? ğŸ®",
          "Hello! I'm your AI assistant! âš”ï¸",
          "Greetings! What can I help with? ğŸŒŸ",
          "Hey! Need optimization help? ğŸ’ª"
        ]
      },
      
      farewells: {
        patterns: ['bye', 'goodbye', 'see you', 'cya', 'later'],
        responses: ["Goodbye! Keep grinding! âš”ï¸", "See ya! Save your progress! ğŸ’¾", "Later! Fortune favors you! ğŸ€"]
      },
      
      gratitude: {
        patterns: ['thanks', 'thank you', 'ty', 'thx'],
        responses: ["You're welcome! ğŸ˜Š", "No problem! ğŸ¤–", "Anytime! â­"]
      },
      
      status: {
        patterns: ['how are you', 'whats up', "what's up"],
        responses: [
          "Systems optimal! Ready to assist! ğŸŸ¢",
          "All good! Your stats: HP {hp}, ATK {atk}, DEF {def}",
          "Running smooth! {itemCount} items ready to optimize!"
        ]
      },
      
      strategies: {
        goldFarm: "Best method: Gold Find talent + Auto Sell junk + Daily quests = 15k+ gold/hour",
        powerLevel: "Focus Combat talents â†’ Buy Dragon Blade â†’ Auto Upgrade all gear â†’ Dominate",
        defense: "Iron Skin (5/5) + Vitality (5/5) + Titan Plate = Immortal tank build",
        balanced: "Split talents 50/50 Combat/Defense for versatile play"
      },
      
      tips: {
        equipment: "Always equip highest power gear. Use Compare to see stat differences.",
        talents: "Don't spread points thin. Focus one tree for powerful synergies.",
        gold: "Never buy common items. Save for epic/legendary gear only.",
        alchemy: "Fuse 3 items of same rarity to get next tier. Worth it for commons!",
        shop: "Check AI Recommendations - they calculate best ROI for your build."
      }
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // DEMO INITIALIZATION WITH SAMPLE DATA
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

    const canonicalSkills = (window.BEST_SKILLS_MANIFEST || []).map((skill) => ({
      ...skill
    }));

    const additionalSkills = [
      { id: 'A1_BLADE_DANCE', name: 'Blade Dance', characterId: 'A1', slot: null, damage: 600, cooldown: 6, unlock: 10, element: 'PHYSICAL', description: '5-hit spinning slash attack', icon: 'ğŸ—¡ï¸', tier: 'uncommon' },
      { id: 'A1_CRIMSON_FURY', name: 'Crimson Fury', characterId: 'A1', slot: null, damage: 850, cooldown: 8, unlock: 20, element: 'FIRE', description: 'Rapid burning slashes + explosion', icon: 'ğŸ”¥', tier: 'rare', burn: true },
      { id: 'A1_SHADOW_STEP', name: 'Shadow Step', characterId: 'A1', slot: null, damage: 0, cooldown: 4, unlock: 5, element: 'SHADOW', description: 'Dash with invulnerability frames', icon: 'ğŸ‘»', tier: 'common' },
      { id: 'A1_VOID_REAPER', name: 'Void Reaper', characterId: 'A1', slot: null, damage: 1800, cooldown: 16, unlock: 35, element: 'SHADOW', description: 'Death scythe AoE with lifesteal', icon: 'ğŸ’€', tier: 'epic', lifesteal: true },
      { id: 'A1_DIMENSION_BREAKER', name: 'Dimension Breaker', characterId: 'A1', slot: null, damage: 3200, cooldown: 25, unlock: 45, element: 'ARCANE', description: 'Reality-shattering rift explosion', icon: 'ğŸŒ ', tier: 'legendary', stun: true },
      { id: 'UNIQUE_ICE_BEAM', name: 'Freeze Ray', characterId: 'UNIQUE', slot: null, damage: 500, cooldown: 7, unlock: 10, element: 'ICE', description: 'Freeze enemies in beam path', icon: 'ğŸ§Š', tier: 'uncommon', freeze: true },
      { id: 'UNIQUE_LIGHTNING_BARRAGE', name: 'Thunder Volley', characterId: 'UNIQUE', slot: null, damage: 400, cooldown: 8, unlock: 12, element: 'LIGHTNING', description: '10-hit lightning chain bolts', icon: 'âš¡', tier: 'uncommon', chain: true },
      { id: 'UNIQUE_EMP_BLAST', name: 'EMP Blast', characterId: 'UNIQUE', slot: null, damage: 800, cooldown: 12, unlock: 22, element: 'LIGHTNING', description: 'AoE electromagnetic pulse', icon: 'ğŸ’¥', tier: 'rare', silence: true, stun: true },
      { id: 'UNIQUE_PLASMA_STORM', name: 'Meteor Strike', characterId: 'UNIQUE', slot: null, damage: 280, cooldown: 18, unlock: 30, element: 'FIRE', description: '12 plasma meteors from orbit', icon: 'â˜„ï¸', tier: 'epic', burn: true },
      { id: 'UNIQUE_ABSOLUTE_ZERO_NOVA', name: 'Absolute Zero', characterId: 'UNIQUE', slot: null, damage: 2400, cooldown: 20, unlock: 38, element: 'ICE', description: 'Massive AoE freeze + shatter', icon: 'â„ï¸', tier: 'legendary', freeze: true },
      { id: 'MISSY_BLADE_STORM', name: 'Blade Tempest', characterId: 'MISSY', slot: null, damage: 550, cooldown: 7, unlock: 11, element: 'PHYSICAL', description: 'Spinning blade + 16 pistol shots', icon: 'ğŸ—¡ï¸', tier: 'uncommon' },
      { id: 'MISSY_LUCKY_STRIKE', name: 'Lucky Strike', characterId: 'MISSY', slot: null, damage: 600, cooldown: 5, unlock: 5, element: 'LIGHT', description: 'High chance double damage + coin', icon: 'ğŸ€', tier: 'common', luck: true },
      { id: 'MISSY_JACKPOT_RAIN', name: 'Treasure Rain', characterId: 'MISSY', slot: null, damage: 150, cooldown: 12, unlock: 18, element: 'LIGHT', description: '20 golden exploding coins', icon: 'ğŸ’¸', tier: 'rare', luck: true },
      { id: 'MISSY_DEADEYE', name: 'Deadeye Shot', characterId: 'MISSY', slot: null, damage: 2000, cooldown: 14, unlock: 24, element: 'PHYSICAL', description: 'Perfect precision shot (crit)', icon: 'ğŸ¯', tier: 'rare', crit: true, pierce: true }
    ];

    window.gameState = {
      gold: 15750,
      gems: 250,
      keys: 12,
      tickets: 8,
      essence: 50, // NEW: Currency for unlocking supernatural powers
      equipped: { head: null, chest: null, gloves: null, pants: null, boots: null, weapon: null, offhand: null, ring1: null, ring2: null, necklace: null, vehicle: null, pet: null, spirit: null, robot: null },
      equippedCores: {}, // NEW: Track equipped cores { weaponCore: coreItem, headCore: coreItem, etc. }
      unlockedPowers: [], // NEW: Track unlocked supernatural powers
      currentCharacter: 'Missy',
      equippedSkins: { A1: 'default', Unique: 'default', Missy: 'default' },
      // Alchemy upgrade system
      alchemyUpgrades: {
        currentTier: 1,
        unlockedTiers: [1],
        totalSpent: 0,
        craftCount: 0,
        discoveredRecipes: [],
        bonusRates: {
          perfectChance: 0.05,
          rareAffixChance: 0.00,
          doubleOutputChance: 0.00,
          bonusGoldMultiplier: 1.0
        }
      },
      inventory: {
        skills: [
          ...canonicalSkills,
          ...additionalSkills
        ],
        items: [
          { id: "item_chest_001", name: "Bronze Chest", icon: "ğŸ“¦", category: "container", quantity: 3 },
          { id: "item_chest_002", name: "Silver Chest", icon: "ğŸ", category: "container", quantity: 2 },
          { id: "item_potion_001", name: "Health Potion", icon: "ğŸ§ª", category: "consumable", quantity: 10 },
          { id: "item_potion_002", name: "Mana Potion", icon: "ğŸ’™", category: "consumable", quantity: 5 }
        ],
        gear: [
          { id: "gear_sword_001", name: "Steel Longsword", icon: "âš”ï¸", category: "weapon", slot: "weapon", attack: 45, rarity: "rare" },
          { id: "gear_sword_002", name: "Iron Dagger", icon: "ğŸ—¡ï¸", category: "weapon", slot: "weapon", attack: 28, rarity: "common" },
          { id: "gear_armor_001", name: "Chainmail Armor", icon: "ğŸ›¡ï¸", category: "armor", slot: "chest", defense: 35, hp: 50, rarity: "rare" },
          { id: "gear_armor_002", name: "Leather Vest", icon: "ğŸ‘”", category: "armor", slot: "chest", defense: 20, hp: 30, rarity: "common" },
          { id: "gear_helmet_001", name: "Iron Helmet", icon: "â›‘ï¸", category: "armor", slot: "head", defense: 15, hp: 20, rarity: "uncommon" },
          { id: "gear_gloves_001", name: "Steel Gauntlets", icon: "ğŸ§¤", category: "armor", slot: "gloves", defense: 12, attack: 5, rarity: "rare" },
          { id: "gear_boots_001", name: "Traveler's Boots", icon: "ğŸ‘¢", category: "armor", slot: "boots", defense: 10, rarity: "common" },
          { id: "gear_ring_001", name: "Ring of Power", icon: "ğŸ’", category: "accessory", slot: "ring", attack: 15, rarity: "epic" },
          { id: "gear_ring_002", name: "Ring of Protection", icon: "ğŸ’", category: "accessory", slot: "ring", defense: 18, rarity: "rare" },
          { id: "gear_necklace_001", name: "Amulet of Vitality", icon: "ğŸ“¿", category: "accessory", slot: "necklace", hp: 80, defense: 10, rarity: "epic" },
          { id: "gear_shield_001", name: "Wooden Shield", icon: "ğŸ›¡ï¸", category: "weapon", slot: "offhand", defense: 25, rarity: "common" }
        ],
        vehicles: [
          // â•â•â• COMMON GROUND VEHICLES (4) â•â•â•
          { id: "basic_bike", name: "Basic Bike", icon: "ğŸš²", type: "bike", category: "ground", rarity: "common", speed: 1.0, agility: 0.9, durability: 0.5, cost: 300, capacity: 1, special: "basic", description: "Simple bicycle for beginners" },
          { id: "scooter", name: "Scooter", icon: "ğŸ›´", type: "scooter", category: "ground", rarity: "common", speed: 0.9, agility: 1.0, durability: 0.4, cost: 280, capacity: 1, special: "agile", description: "Maneuverable kick scooter" },
          { id: "shopping_cart", name: "Shopping Cart", icon: "ğŸ›’", type: "cart", category: "ground", rarity: "common", speed: 0.6, agility: 0.7, durability: 0.8, cost: 200, capacity: 3, special: "cargo", description: "Surprisingly useful metal cart" },
          { id: "roller_skates", name: "Roller Skates", icon: "ğŸ›¼", type: "skates", category: "ground", rarity: "common", speed: 1.1, agility: 1.1, durability: 0.3, cost: 320, capacity: 1, special: "speed", description: "Fast roller skates for smooth surfaces" },
          
          // â•â•â• COMMON HOVER VEHICLES (3) â•â•â•
          { id: "hover_disc", name: "Hover Disc", icon: "ğŸ’¿", type: "disc", category: "hover", rarity: "common", speed: 0.8, agility: 1.2, durability: 0.4, cost: 350, capacity: 1, special: "float", description: "Floating disc for hovering" },
          { id: "hover_cushion", name: "Hover Cushion", icon: "ğŸª", type: "cushion", category: "hover", rarity: "common", speed: 0.7, agility: 0.9, durability: 0.5, cost: 300, capacity: 2, special: "comfort", description: "Soft hovering cushion" },
          { id: "drift_platform", name: "Drift Platform", icon: "ğŸ“±", type: "platform", category: "hover", rarity: "common", speed: 0.9, agility: 0.8, durability: 0.6, cost: 380, capacity: 2, special: "stable", description: "Stable hovering platform" },
          
          // â•â•â• COMMON AIR VEHICLES (2) â•â•â•
          { id: "glider_basic", name: "Basic Glider", icon: "ğŸª‚", type: "glider", category: "air", rarity: "common", speed: 1.0, agility: 0.7, durability: 0.3, cost: 400, capacity: 1, special: "glide", description: "Simple hang glider for short flights" },
          { id: "balloon_ride", name: "Balloon Ride", icon: "ğŸˆ", type: "balloon", category: "air", rarity: "common", speed: 0.5, agility: 0.4, durability: 0.6, cost: 350, capacity: 2, special: "slow flight", description: "Slow but peaceful hot air balloon" },
          
          // â•â•â• COMMON UTILITY (3) â•â•â•
          { id: "wagon", name: "Wagon", icon: "ğŸšš", type: "wagon", category: "ground", rarity: "common", speed: 0.7, agility: 0.6, durability: 1.0, cost: 320, capacity: 4, special: "haul", description: "Sturdy wagon for hauling cargo" },
          { id: "pushcart", name: "Pushcart", icon: "ğŸ›ï¸", type: "cart", category: "ground", rarity: "common", speed: 0.5, agility: 0.8, durability: 0.7, cost: 250, capacity: 3, special: "carry", description: "Wheeled cart for carrying items" },
          { id: "sled", name: "Sled", icon: "ğŸ›·", type: "sled", category: "ground", rarity: "common", speed: 1.2, agility: 0.5, durability: 0.5, cost: 280, capacity: 2, special: "downhill", description: "Fast sled for snowy slopes" },
          
          // â•â•â• ORIGINAL VEHICLES (Higher Rarity) â•â•â•
          { id: "vehicle_sports_car", name: "Sports Car", icon: "ğŸï¸", type: "car", category: "ground", rarity: "rare", speed: 1.5, agility: 0.7, durability: 0.8, cost: 1000, capacity: 2, special: "boost", description: "Fast sports car with high speed" },
          { id: "vehicle_hoverbike", name: "Hoverbike", icon: "ğŸï¸", type: "bike", category: "hover", rarity: "rare", speed: 1.2, agility: 1.0, durability: 0.6, cost: 800, capacity: 1, special: "agility", description: "Agile hoverbike for quick movement" },
          { id: "vehicle_jetcart", name: "Jet Cart", icon: "ğŸ›’", type: "cart", category: "ground", rarity: "rare", speed: 1.0, agility: 0.8, durability: 1.0, cost: 1200, capacity: 3, special: "durability", description: "Balanced jet-powered cart" },
          { id: "vehicle_turbo_board", name: "Turbo Board", icon: "ğŸ›¹", type: "board", category: "hover", rarity: "uncommon", speed: 1.3, agility: 1.2, durability: 0.5, cost: 600, capacity: 1, special: "speed", description: "Lightweight turbo board" },
          { id: "traffic_sedan", name: "Sedan", icon: "ğŸš—", type: "sedan", category: "ground", rarity: "uncommon", speed: 0.57, agility: 1.0, durability: 0.71, cost: 500, capacity: 2, special: "civilian", description: "Standard civilian sedan" },
          { id: "traffic_van", name: "Van", icon: "ğŸš", type: "van", category: "ground", speed: 0.46, agility: 0.8, durability: 1.07, cost: 800, capacity: 3, special: "durability", description: "Heavy utility van" },
          { id: "traffic_bike", name: "Traffic Bike", icon: "ğŸš²", type: "bike", category: "hover", speed: 0.71, agility: 1.2, durability: 0.43, cost: 400, capacity: 1, special: "agility", description: "Fast traffic motorcycle" },
          { id: "personal_bike", name: "Personal Bike", icon: "ğŸï¸", type: "bike", category: "ground", speed: 2.6, agility: 1.3, durability: 0.6, cost: 900, capacity: 2, special: "speed + agility", description: "Lightweight, fast, agile bike" },
          { id: "personal_chopper", name: "Chopper", icon: "ğŸï¸", type: "chopper", category: "ground", speed: 2.0, agility: 0.7, durability: 1.2, cost: 1500, capacity: 3, special: "durability + capacity", description: "Heavy cruiser bike with multiple seats" },
          { id: "personal_jetpack", name: "Jetpack", icon: "ğŸ’", type: "jetpack", category: "air", speed: 2.4, agility: 1.5, durability: 0.4, cost: 2500, capacity: 1, special: "flight + evasion", description: "Personal flight pack with vertical freedom" },
          { id: "personal_car", name: "Personal Car", icon: "ğŸš™", type: "car", category: "ground", speed: 2.2, agility: 1.0, durability: 0.9, cost: 1100, capacity: 3, special: "balanced", description: "Balanced baseline vehicle" },
          { id: "mech_proto", name: "Mech Proto", icon: "ğŸ¤–", type: "mech", category: "ground", speed: 2.0, agility: 0.5, durability: 2.0, cost: 3000, capacity: 1, special: "knockback immunity", description: "Early-stage battle mech with high HP" },
          { id: "mech_apex", name: "Mech Apex", icon: "ğŸ¤–", type: "mech", category: "ground", speed: 2.3, agility: 0.7, durability: 2.5, cost: 5000, capacity: 1, special: "boost + missiles", description: "Advanced version with shoulder cannons" },
          { id: "skateboard_street", name: "Street Skateboard", icon: "ğŸ›¹", type: "skateboard", category: "ground", speed: 2.5, agility: 1.4, durability: 0.3, cost: 500, capacity: 1, special: "strong acceleration", description: "Street-style board with strong acceleration" },
          { id: "transit_bus", name: "Bus", icon: "ğŸšŒ", type: "bus", category: "ground", speed: 0.64, agility: 0.5, durability: 1.5, cost: 2000, capacity: 8, special: "transport", description: "Public bus for passengers" },
          { id: "transit_train", name: "Train", icon: "ğŸš†", type: "train", category: "ground", speed: 0.93, agility: 0.3, durability: 2.0, cost: 5000, capacity: 8, special: "transport", description: "High-speed train coach" },
          { id: "vehicle_hoverbike_alt", name: "Hoverbike Alt", icon: "ğŸï¸", type: "bike", category: "hover", speed: 1.1, agility: 0.9, durability: 0.7, cost: 750, capacity: 1, special: "agility", description: "Alternative hoverbike design" }
        ],
        pets: [
          // â•â•â• COMMON FIRE PETS (3) â•â•â•
          { id: "pet_fire_pup", name: "Fire Pup", icon: "ğŸ•", element: "fire", rarity: "common", attack: 12, health: 60, speed: 0.5, cost: 250, ability: "Ember Bark", abilityDamage: 18, description: "Young fire hound learning to breathe flames" },
          { id: "pet_ash_kitten", name: "Ash Kitten", icon: "ğŸˆ", element: "fire", rarity: "common", attack: 14, health: 55, speed: 0.6, cost: 280, ability: "Fire Scratch", abilityDamage: 20, description: "Playful kitten that leaves ash trails" },
          { id: "pet_spark_lizard", name: "Spark Lizard", icon: "ğŸ¦", element: "fire", rarity: "common", attack: 13, health: 58, speed: 0.55, cost: 270, ability: "Tail Flame", abilityDamage: 19, description: "Small lizard with flaming tail" },
          
          // â•â•â• COMMON ICE PETS (3) â•â•â•
          { id: "pet_frost_pup", name: "Frost Pup", icon: "ğŸ•", element: "ice", rarity: "common", attack: 11, health: 65, speed: 0.4, cost: 260, ability: "Ice Breath", abilityDamage: 16, description: "Fluffy pup that exhales cold air" },
          { id: "pet_snow_rabbit", name: "Snow Rabbit", icon: "ğŸ‡", element: "ice", rarity: "common", attack: 10, health: 50, speed: 0.7, cost: 240, ability: "Snowball", abilityDamage: 15, description: "Swift rabbit that hops through snow" },
          { id: "pet_ice_turtle", name: "Ice Turtle", icon: "ğŸ¢", element: "ice", rarity: "common", attack: 9, health: 80, speed: 0.3, cost: 250, ability: "Shell Frost", abilityDamage: 14, description: "Slow but sturdy ice turtle" },
          
          // â•â•â• COMMON ELECTRIC PETS (3) â•â•â•
          { id: "pet_spark_mouse", name: "Spark Mouse", icon: "ğŸ­", element: "electric", rarity: "common", attack: 15, health: 45, speed: 0.8, cost: 280, ability: "Static Shock", abilityDamage: 22, description: "Tiny mouse charged with electricity" },
          { id: "pet_volt_bat", name: "Volt Bat", icon: "ğŸ¦‡", element: "electric", rarity: "common", attack: 16, health: 48, speed: 0.75, cost: 290, ability: "Lightning Wing", abilityDamage: 23, description: "Flying bat crackling with energy" },
          { id: "pet_thunder_bug", name: "Thunder Bug", icon: "ğŸ›", element: "electric", rarity: "common", attack: 14, health: 40, speed: 0.6, cost: 260, ability: "Bug Zap", abilityDamage: 21, description: "Small bug that generates sparks" },
          
          // â•â•â• COMMON EARTH PETS (2) â•â•â•
          { id: "pet_rock_snail", name: "Rock Snail", icon: "ğŸŒ", element: "earth", rarity: "common", attack: 8, health: 90, speed: 0.25, cost: 240, ability: "Stone Shell", abilityDamage: 12, description: "Extremely slow but tough snail" },
          { id: "pet_clay_crab", name: "Clay Crab", icon: "ğŸ¦€", element: "earth", rarity: "common", attack: 12, health: 75, speed: 0.35, cost: 270, ability: "Pinch", abilityDamage: 18, description: "Crab made of hardened clay" },
          
          // â•â•â• COMMON WIND PETS (2) â•â•â•
          { id: "pet_breeze_bird", name: "Breeze Bird", icon: "ğŸ¦", element: "wind", rarity: "common", attack: 13, health: 50, speed: 0.85, cost: 270, ability: "Wind Peck", abilityDamage: 17, description: "Small bird riding air currents" },
          { id: "pet_gust_butterfly", name: "Gust Butterfly", icon: "ğŸ¦‹", element: "wind", rarity: "common", attack: 11, health: 42, speed: 0.9, cost: 250, ability: "Wing Gust", abilityDamage: 15, description: "Graceful butterfly creating small gusts" },
          
          // â•â•â• COMMON ARCANE PETS (2) â•â•â•
          { id: "pet_magic_rat", name: "Magic Rat", icon: "ğŸ€", element: "arcane", rarity: "common", attack: 14, health: 52, speed: 0.65, cost: 280, ability: "Spell Bite", abilityDamage: 20, description: "Clever rat with minor magical abilities" },
          { id: "pet_mystic_beetle", name: "Mystic Beetle", icon: "ğŸª²", element: "arcane", rarity: "common", attack: 12, health: 58, speed: 0.5, cost: 260, ability: "Rune Blast", abilityDamage: 18, description: "Beetle with glowing runes" },
          
          // â•â•â• ORIGINAL PETS (Higher Rarity) â•â•â•
          { id: "pet_firecub", name: "Fire Cub", icon: "ğŸ”¥", element: "fire", rarity: "common", attack: 20, health: 80, speed: 0.6, cost: 300, ability: "Fire Breath", abilityDamage: 30, description: "A playful fire cub that shoots small fireballs" },
          { id: "pet_flame_spirit", name: "Flame Spirit", icon: "ğŸ”¥", element: "fire", rarity: "rare", attack: 28, health: 75, speed: 0.7, cost: 800, ability: "Fire Breath", abilityDamage: 30, description: "Ethereal flame spirit with intense heat" },
          { id: "pet_icewolf", name: "Ice Wolf", icon: "ğŸº", element: "ice", rarity: "common", attack: 18, health: 90, speed: 0.5, cost: 350, ability: "Ice Shard", abilityDamage: 25, description: "Loyal ice wolf with freezing attacks" },
          { id: "pet_frost_wolf", name: "Frost Wolf", icon: "ğŸº", element: "ice", rarity: "rare", attack: 25, health: 100, speed: 0.5, cost: 850, ability: "Ice Shard", abilityDamage: 25, description: "Powerful frost wolf alpha" },
          { id: "pet_lightningbird", name: "Lightning Bird", icon: "ğŸ¦…", element: "electric", rarity: "uncommon", attack: 30, health: 60, speed: 0.8, cost: 600, ability: "Lightning Strike", abilityDamage: 35, description: "Fast electric bird with shocking strikes" },
          { id: "pet_earthgolem", name: "Earth Golem", icon: "ğŸ—¿", element: "earth", rarity: "rare", attack: 35, health: 150, speed: 0.3, cost: 900, ability: "Rock Throw", abilityDamage: 40, description: "Sturdy rock golem with crushing power" },
          { id: "pet_airsprite", name: "Air Sprite", icon: "ğŸ’¨", element: "wind", rarity: "uncommon", attack: 15, health: 70, speed: 0.9, cost: 550, ability: "Gust", abilityDamage: 20, description: "Swift air sprite that dances on the wind" },
          { id: "pet_magic_monkey", name: "Magic Monkey", icon: "ğŸµ", element: "arcane", rarity: "epic", attack: 40, health: 90, speed: 0.6, cost: 1500, ability: "Magic Missile", abilityDamage: 45, description: "Mischievous magical monkey with arcane powers" },
          { id: "pet_magicfrog", name: "Magic Frog", icon: "ğŸ¸", element: "arcane", rarity: "common", attack: 12, health: 50, speed: 0.4, cost: 250, ability: "Magic Missile", abilityDamage: 45, description: "Cute magical frog with minor spells" },
          { id: "pet_gremlin", name: "Gremlin", icon: "ğŸ‘¹", element: "dark", rarity: "uncommon", attack: 22, health: 65, speed: 0.7, cost: 500, ability: "Shadow Claw", abilityDamage: 35, description: "Sneaky gremlin with shadow attacks" },
          { id: "pet_missy", name: "Missy Spirit", icon: "ğŸ‘¼", element: "light", rarity: "legendary", attack: 50, health: 120, speed: 0.5, cost: 2500, ability: "Holy Light", abilityDamage: 50, description: "Legendary light spirit with divine power" },
          { id: "pet_dark_missy", name: "Dark Missy", icon: "ğŸ˜ˆ", element: "shadow", rarity: "legendary", attack: 55, health: 130, speed: 0.7, cost: 3000, ability: "Shadow Shot", abilityDamage: 55, description: "Dark angel with halo and wing, dual-wielding sword and gun" },
          { id: "summon_robot_drone", name: "Robot Drone", icon: "ğŸ¤–", element: "tech", rarity: "epic", attack: 35, health: 100, speed: 0.7, cost: 1200, ability: "Energy Beam", abilityDamage: 40, description: "Combat drone with energy blasters" }
        ],
        spirits: [
          // â•â•â• COMMON FIRE SPIRITS (3) â•â•â•
          { id: "fire_spark", name: "Fire Spark", icon: "ğŸ”¥", element: "fire", rarity: "common", power: 45, bonusType: "atkMul", bonusValue: 0.02, attackDamage: 15, cost: 300, description: "A tiny fire spirit with flickering flames" },
          { id: "ember_wisp", name: "Ember Wisp", icon: "ğŸ”¥", element: "fire", rarity: "common", power: 50, bonusType: "atkMul", bonusValue: 0.025, attackDamage: 18, cost: 350, description: "Warm ember spirit that dances in the wind" },
          { id: "flame_mote", name: "Flame Mote", icon: "ğŸ”¥", element: "fire", rarity: "common", power: 48, bonusType: "atkMul", bonusValue: 0.023, attackDamage: 16, cost: 320, description: "Small flame spirit with gentle heat" },
          
          // â•â•â• COMMON DARK SPIRITS (3) â•â•â•
          { id: "shadow_wisp", name: "Shadow Wisp", icon: "ğŸŒ‘", element: "dark", rarity: "common", power: 42, bonusType: "atkMul", bonusValue: 0.02, attackDamage: 14, cost: 300, description: "Faint shadow that whispers in darkness" },
          { id: "gloom_essence", name: "Gloom Essence", icon: "ğŸŒ‘", element: "dark", rarity: "common", power: 47, bonusType: "atkMul", bonusValue: 0.024, attackDamage: 17, cost: 330, description: "Gloomy spirit born from twilight" },
          { id: "dusk_spirit", name: "Dusk Spirit", icon: "ğŸŒ‘", element: "dark", rarity: "common", power: 44, bonusType: "atkMul", bonusValue: 0.021, attackDamage: 15, cost: 310, description: "Spirit of the fading light" },
          
          // â•â•â• COMMON LIGHT SPIRITS (2) â•â•â•
          { id: "light_mote", name: "Light Mote", icon: "âœ¨", element: "light", rarity: "common", power: 46, bonusType: "hpFlat", bonusValue: 30, attackDamage: 12, cost: 320, description: "Gentle light spirit that heals wounds" },
          { id: "glow_wisp", name: "Glow Wisp", icon: "âœ¨", element: "light", rarity: "common", power: 48, bonusType: "hpFlat", bonusValue: 35, attackDamage: 13, cost: 340, description: "Soft glowing spirit with soothing presence" },
          
          // â•â•â• COMMON TECH SPIRITS (2) â•â•â•
          { id: "spark_core", name: "Spark Core", icon: "âš¡", element: "tech", rarity: "common", power: 44, bonusType: "speedMul", bonusValue: 0.02, attackDamage: 16, cost: 310, description: "Basic tech core with electric charge" },
          { id: "circuit_soul", name: "Circuit Soul", icon: "âš¡", element: "tech", rarity: "common", power: 46, bonusType: "speedMul", bonusValue: 0.023, attackDamage: 17, cost: 330, description: "Digital spirit from circuit boards" },
          
          // â•â•â• COMMON EARTH SPIRITS (2) â•â•â•
          { id: "pebble_spirit", name: "Pebble Spirit", icon: "ğŸª¨", element: "earth", rarity: "common", power: 50, bonusType: "defFlat", bonusValue: 20, attackDamage: 10, cost: 300, description: "Tiny rock spirit with solid defense" },
          { id: "dust_guardian", name: "Dust Guardian", icon: "ğŸª¨", element: "earth", rarity: "common", power: 52, bonusType: "defFlat", bonusValue: 22, attackDamage: 11, cost: 320, description: "Earth spirit that forms protective barriers" },
          
          // â•â•â• ORIGINAL SPIRITS (Higher Rarity) â•â•â•
          { id: "dark_soul", name: "Dark Soul", icon: "ğŸœ", element: "dark", rarity: "rare", power: 85, bonusType: "atkMul", bonusValue: 0.06, attackDamage: 30, cost: 2500, description: "A dark energy spirit that enhances offensive power through shadow energy" },
          { id: "light_soul", name: "Light Soul", icon: "â˜€ï¸", element: "light", rarity: "rare", power: 90, bonusType: "hpFlat", bonusValue: 60, attackDamage: 25, cost: 2500, description: "A radiant light spirit that grants protective health and slow-fall abilities" },
          { id: "golden_spirit", name: "Golden Spirit", icon: "âœ¶", element: "gold", rarity: "uncommon", power: 75, bonusType: "goldGain", bonusValue: 0.15, attackDamage: 20, cost: 800, description: "A fortunate spirit that increases gold collection and attracts nearby treasures" },
          { id: "tech_essence", name: "Tech Essence", icon: "âš¡", element: "tech", rarity: "rare", power: 80, bonusType: "speedMul", bonusValue: 0.05, attackDamage: 35, cost: 2500, description: "A technological spirit core that boosts movement speed and reaction time" },
          { id: "storm_wisp", name: "Storm Wisp", icon: "ğŸŒ©ï¸", element: "storm", rarity: "epic", power: 92, bonusType: "atkMul", bonusValue: 0.08, attackDamage: 40, cost: 10000, description: "A powerful storm spirit combining attack power and speed with chain lightning" },
          { id: "guardian_sand", name: "Guardian Sand", icon: "â³", element: "earth", rarity: "epic", power: 88, bonusType: "damageTakenMul", bonusValue: 0.85, attackDamage: 28, cost: 10000, description: "An ancient earth guardian that reduces incoming damage through protective barriers" },
          { id: "ember_fox", name: "Ember Fox", icon: "ğŸ¦Š", element: "fire", rarity: "legendary", power: 94, bonusType: "atkMul", bonusValue: 0.05, attackDamage: 45, cost: 50000, description: "A legendary fire fox spirit granting attack power and luck through blazing trails" }
        ],
        robots: [
          // â•â•â• COMMON COMBAT BOTS (3) â•â•â•
          { id: "trainee_bot", name: "Trainee Bot", icon: "ğŸ¤–", type: "combat_bot", category: "ground", tier: "common", rarity: "common", hp: 1200, atk: 180, def: 30, speed: 120, cost: 500, abilities: ["Basic Punch", "Guard"], modes: ["follow", "guard"], description: "Entry-level combat bot for beginners" },
          { id: "scout_bot", name: "Scout Bot", icon: "ğŸ¤–", type: "combat_bot", category: "ground", tier: "common", rarity: "common", hp: 1000, atk: 200, def: 25, speed: 150, cost: 550, abilities: ["Quick Strike", "Dash"], modes: ["follow", "scout"], description: "Fast and light combat bot" },
          { id: "guard_bot", name: "Guard Bot", icon: "ğŸ¤–", type: "combat_bot", category: "ground", tier: "common", rarity: "common", hp: 1500, atk: 150, def: 50, speed: 100, cost: 520, abilities: ["Shield Block", "Tackle"], modes: ["follow", "guard"], description: "Defensive bot with strong armor" },
          
          // â•â•â• COMMON SUPPORT DRONES (3) â•â•â•
          { id: "helper_drone", name: "Helper Drone", icon: "ğŸ›¸", type: "support_drone", category: "hover", tier: "common", rarity: "common", hp: 600, atk: 50, def: 15, speed: 180, cost: 400, abilities: ["Light Repair", "Scan"], modes: ["follow", "assist"], description: "Basic support drone with repair capabilities" },
          { id: "cargo_drone", name: "Cargo Drone", icon: "ğŸ›¸", type: "support_drone", category: "hover", tier: "common", rarity: "common", hp: 700, atk: 30, def: 20, speed: 140, cost: 420, abilities: ["Carry", "Drop"], modes: ["follow", "transport"], description: "Cargo-carrying utility drone" },
          { id: "scanner_drone", name: "Scanner Drone", icon: "ğŸ›¸", type: "support_drone", category: "hover", tier: "common", rarity: "common", hp: 500, atk: 40, def: 10, speed: 200, cost: 380, abilities: ["Deep Scan", "Mark"], modes: ["follow", "scout"], description: "Recon drone with advanced sensors" },
          
          // â•â•â• COMMON UTILITY BOTS (3) â•â•â•
          { id: "miner_bot", name: "Miner Bot", icon: "â›ï¸", type: "utility", category: "ground", tier: "common", rarity: "common", hp: 1400, atk: 100, def: 40, speed: 90, cost: 450, abilities: ["Mine", "Dig"], modes: ["follow", "mine"], description: "Resource-gathering mining bot" },
          { id: "builder_bot", name: "Builder Bot", icon: "ğŸ”§", type: "utility", category: "ground", tier: "common", rarity: "common", hp: 1300, atk: 80, def: 35, speed: 100, cost: 430, abilities: ["Build", "Repair"], modes: ["follow", "construct"], description: "Construction and repair bot" },
          { id: "cleaner_bot", name: "Cleaner Bot", icon: "ğŸ§¹", type: "utility", category: "ground", tier: "common", rarity: "common", hp: 800, atk: 60, def: 20, speed: 110, cost: 350, abilities: ["Sweep", "Collect"], modes: ["follow", "clean"], description: "Cleaning bot that gathers debris" },
          
          // â•â•â• COMMON COMPANION BOTS (3) â•â•â•
          { id: "pet_bot", name: "Pet Bot", icon: "ğŸ¶", type: "companion", category: "ground", tier: "common", rarity: "common", hp: 900, atk: 70, def: 25, speed: 130, cost: 400, abilities: ["Play", "Fetch"], modes: ["follow"], description: "Friendly robotic companion" },
          { id: "buddy_bot", name: "Buddy Bot", icon: "ğŸ¤—", type: "companion", category: "ground", tier: "common", rarity: "common", hp: 1000, atk: 90, def: 30, speed: 120, cost: 420, abilities: ["Encourage", "Assist"], modes: ["follow", "support"], description: "Supportive companion bot" },
          { id: "mini_bot", name: "Mini Bot", icon: "ğŸ”¹", type: "companion", category: "hover", tier: "common", rarity: "common", hp: 600, atk: 100, def: 15, speed: 180, cost: 380, abilities: ["Hover", "Light Attack"], modes: ["follow"], description: "Tiny hovering companion bot" },
          
          // â•â•â• ORIGINAL ROBOTS (Higher Rarity) â•â•â•
          { id: "robox_standard", name: "Robox Standard", icon: "ğŸ¤–", type: "combat_bot", category: "ground", tier: "common", rarity: "uncommon", hp: 2000, atk: 300, def: 50, speed: 140, cost: 1000, abilities: ["Sword Slash", "Energy Bolt", "Triple Strike"], modes: ["follow", "aggro", "guard"], description: "Standard Robox combat bot with balanced stats" },
          { id: "robox_elite", name: "Robox Elite", icon: "ğŸ¤–", type: "combat_bot", category: "ground", tier: "rare", rarity: "rare", hp: 3500, atk: 500, def: 100, speed: 160, cost: 3000, abilities: ["Lightning Fan", "Domain Pulse", "Spiral Volley"], modes: ["follow", "aggro", "guard"], description: "Elite version with enhanced weapons and shields" },
          { id: "robox_titan", name: "Robox Titan", icon: "ğŸ¤–", type: "combat_bot", category: "ground", tier: "legendary", rarity: "legendary", hp: 5000, atk: 800, def: 200, speed: 120, cost: 8000, abilities: ["Mega Beam", "Rocket Barrage", "EMP Pulse", "Overdrive"], modes: ["follow", "aggro", "rampage"], description: "Massive combat bot with devastating firepower" },
          { id: "drone_scout", name: "Scout Drone", icon: "ğŸ›¸", type: "support_drone", category: "hover", tier: "common", rarity: "uncommon", hp: 800, atk: 100, def: 20, speed: 200, cost: 500, abilities: ["Scan", "Light Laser"], modes: ["follow", "patrol", "scout"], description: "Fast recon drone with light weapons" },
          { id: "drone_healer", name: "Repair Drone", icon: "ğŸ›¸", type: "support_drone", category: "hover", tier: "uncommon", rarity: "uncommon", hp: 1200, atk: 50, def: 30, speed: 140, cost: 1500, abilities: ["Repair Beam", "Shield Boost", "Emergency Heal"], modes: ["follow", "assist"], description: "Healing support drone that repairs allies" },
          { id: "drone_shield", name: "Shield Drone", icon: "ğŸ›¸", type: "support_drone", category: "hover", tier: "rare", hp: 1800, atk: 0, def: 100, speed: 100, cost: 2500, abilities: ["Energy Shield", "Barrier Wall", "Reflect"], modes: ["follow", "guard", "defend"], description: "Defensive drone that projects energy shields" },
          { id: "mech_assault", name: "Assault Mech", icon: "ğŸ¦¾", type: "mech", category: "ground", tier: "epic", hp: 4000, atk: 600, def: 150, speed: 110, cost: 5000, abilities: ["Gatling Burst", "Rocket Salvo", "Ground Pound"], modes: ["follow", "aggro", "siege"], description: "Heavy mech with dual gatling guns" },
          { id: "sniper_bot", name: "Sniper Bot", icon: "ğŸ¯", type: "ranged_specialist", category: "ground", tier: "rare", hp: 1500, atk: 700, def: 40, speed: 100, cost: 3500, abilities: ["Railgun Shot", "Charged Blast", "Piercing Round"], modes: ["follow", "snipe", "overwatch"], description: "Long-range precision bot with railgun" },
          { id: "stealth_bot", name: "Stealth Bot", icon: "ğŸ‘¤", type: "infiltrator", category: "ground", tier: "epic", hp: 1000, atk: 450, def: 30, speed: 220, cost: 4000, abilities: ["Cloak", "Backstab", "Smoke Bomb", "Shadow Strike"], modes: ["follow", "hunt", "flank"], description: "Cloaking assassin bot with backstab damage" },
          { id: "guardian_angel_bot", name: "Guardian Angel", icon: "ğŸ˜‡", type: "support_drone", category: "hover", tier: "epic", hp: 2000, atk: 150, def: 120, speed: 160, cost: 3500, abilities: ["Divine Shield", "Resurrect", "Holy Beam", "Blessing"], modes: ["follow", "protect", "assist"], description: "Angelic support bot that shields and revives allies" },
          { id: "berserker_bot", name: "Berserker Unit", icon: "ğŸ˜¡", type: "combat_bot", category: "ground", tier: "rare", hp: 2800, atk: 650, def: 60, speed: 180, cost: 3200, abilities: ["Rage Mode", "Dual Blades", "Whirlwind"], modes: ["aggro", "berserk"], description: "Aggressive melee bot that grows stronger as HP drops" },
          { id: "hacker_bot", name: "Cyber Hacker", icon: "ğŸ’»", type: "support_drone", category: "hover", tier: "rare", hp: 1000, atk: 200, def: 50, speed: 190, cost: 2800, abilities: ["Hack Enemy", "Disable Defenses", "Data Steal", "System Crash"], modes: ["follow", "disrupt", "hack"], description: "Elite hacker bot that disables enemy systems and steals buffs" },
          { id: "tank_bot", name: "Iron Fortress", icon: "ğŸ°", type: "mech", category: "ground", tier: "epic", hp: 6000, atk: 350, def: 300, speed: 80, cost: 6000, abilities: ["Taunt", "Shield Wall", "Counter Strike", "Fortify"], modes: ["guard", "tank", "defend"], description: "Ultra-tanky bot that draws enemy fire and protects the team" },
          { id: "ninja_bot", name: "Shadow Ninja", icon: "ğŸ¥·", type: "infiltrator", category: "ground", tier: "legendary", hp: 1500, atk: 900, def: 40, speed: 250, cost: 7500, abilities: ["Shadow Clone", "Critical Strike", "Vanish", "Assassination", "Smoke Screen"], modes: ["follow", "stealth", "assassinate"], description: "Master assassin bot with instant-kill techniques" },
          { id: "healer_bot", name: "Medic Prime", icon: "âš•ï¸", type: "support_drone", category: "hover", tier: "uncommon", hp: 1500, atk: 80, def: 70, speed: 150, cost: 2200, abilities: ["Mass Heal", "Regeneration Aura", "Cure", "Revive"], modes: ["follow", "heal", "support"], description: "Advanced medical bot with area healing and resurrection" },
          { id: "mage_bot", name: "Arcane Golem", icon: "ğŸ”®", type: "combat_bot", category: "ground", tier: "epic", hp: 2200, atk: 550, def: 100, speed: 130, cost: 4500, abilities: ["Fireball", "Ice Storm", "Lightning Chain", "Meteor"], modes: ["follow", "aggro", "cast"], description: "Magic-wielding bot with elemental spells" },
          { id: "bomber_bot", name: "Demolition Unit", icon: "ğŸ’£", type: "combat_bot", category: "ground", tier: "rare", hp: 1800, atk: 750, def: 50, speed: 110, cost: 3300, abilities: ["Plant Bomb", "Explosive Shot", "Cluster Bomb", "Self-Destruct"], modes: ["follow", "aggro", "kamikaze"], description: "Explosive specialist bot with massive AoE damage" },
          { id: "dragon_bot", name: "Mecha Dragon", icon: "ğŸ²", type: "mech", category: "air", tier: "legendary", hp: 4500, atk: 850, def: 180, speed: 200, cost: 9000, abilities: ["Flame Breath", "Tail Swipe", "Dragon Dive", "Inferno", "Wing Shield"], modes: ["follow", "aggro", "flight"], description: "Legendary dragon-type mech with flight and fire attacks" }
        ],
        talents: {
          atk: [
            { id: "atk_1", name: "+5% ATK", cost: 1, tier: 1, description: "Increase attack damage by 5%" },
            { id: "atk_2", name: "+8% ATK", cost: 2, tier: 2, description: "Increase attack damage by 8%" },
            { id: "atk_3", name: "+12% ATK", cost: 3, tier: 3, description: "Increase attack damage by 12%" },
            { id: "atk_4", name: "+15% ATK + Crit Chance", cost: 4, tier: 4, description: "Increase attack by 15% and gain 10% crit chance" },
            { id: "atk_5", name: "Berserker", cost: 5, tier: 5, description: "Attack power increases as health decreases" },
            { id: "atk_ultimate", name: "APEX HUNTER", cost: 8, tier: 6, ultimate: true, description: "Massive attack boost and killing enemies generates rage" }
          ],
          def: [
            { id: "def_1", name: "+80 HP", cost: 1, tier: 1, description: "Increase maximum health by 80" },
            { id: "def_2", name: "+120 HP", cost: 2, tier: 2, description: "Increase maximum health by 120" },
            { id: "def_3", name: "+160 HP", cost: 3, tier: 3, description: "Increase maximum health by 160" },
            { id: "def_4", name: "+200 HP + 10% DR", cost: 4, tier: 4, description: "Increase HP by 200 and reduce damage by 10%" },
            { id: "def_5", name: "Guardian", cost: 5, tier: 5, description: "Nearby allies take 20% less damage" },
            { id: "def_ultimate", name: "FORTRESS", cost: 8, tier: 6, ultimate: true, description: "Team immunity when at low HP" }
          ],
          recovery: [
            { id: "rec_1", name: "+6% Lifesteal", cost: 1, tier: 1, description: "Heal for 6% of damage dealt" },
            { id: "rec_2", name: "+10% Lifesteal", cost: 2, tier: 2, description: "Heal for 10% of damage dealt" },
            { id: "rec_3", name: "+15% LS + HP Regen", cost: 3, tier: 3, description: "Heal for 15% of damage dealt and gain HP regen" },
            { id: "rec_4", name: "Vampiric", cost: 4, tier: 4, description: "Killing blows fully heal" },
            { id: "rec_ultimate", name: "PHOENIX", cost: 7, tier: 5, ultimate: true, description: "Auto-revive on death (once per stage)" }
          ],
          cooldown: [
            { id: "cd_1", name: "-8% Skill CD", cost: 1, tier: 1, description: "Reduce skill cooldowns by 8%" },
            { id: "cd_2", name: "-12% Skill CD", cost: 2, tier: 2, description: "Reduce skill cooldowns by 12%" },
            { id: "cd_3", name: "-15% CD + Speed", cost: 3, tier: 3, description: "Reduce cooldowns by 15% and increase movement by 20%" },
            { id: "cd_4", name: "Cascade", cost: 4, tier: 4, description: "Skills have 25% chance to reset cooldown" },
            { id: "cd_dual_wield", name: "âš”ï¸ Dual Wielding", cost: 3, tier: 3, equippable: true, description: "Equip 2 weapons simultaneously for double strikes" },
            { id: "cd_ultimate", name: "TIME MASTER", cost: 7, tier: 5, ultimate: true, description: "All abilities cost 50% less cooldown" }
          ],
          luck: [
            { id: "luck_1", name: "+8 Luck", cost: 1, tier: 1, description: "Increase luck stat by 8" },
            { id: "luck_2", name: "+15 Luck", cost: 2, tier: 2, description: "Increase luck stat by 15" },
            { id: "luck_3", name: "+25 Luck + Gold Find", cost: 3, tier: 3, description: "Increase luck by 25 and gain 30% bonus gold" },
            { id: "luck_4", name: "Fortune", cost: 4, tier: 4, description: "10% chance for double loot" },
            { id: "luck_5", name: "Jackpot", cost: 5, tier: 5, description: "Rare drops can upgrade quality" },
            { id: "luck_ultimate", name: "GOLDEN TOUCH", cost: 8, tier: 6, ultimate: true, description: "Everything drops gold, permanent luck aura" }
          ],
          shadow: [
            { id: "shadow_1", name: "+5% ATK + Dark Affinity", cost: 1, tier: 1, description: "Increase attack and gain dark element affinity" },
            { id: "shadow_2", name: "+10% ATK + Shadow Power", cost: 2, tier: 2, description: "Enhance attack with shadow energy" },
            { id: "shadow_3", name: "+15% ATK + Dark Mastery", cost: 3, tier: 3, description: "Master dark arts for greater damage" },
            { id: "shadow_4", name: "+20% ATK + Shadow Form", cost: 4, tier: 4, description: "Transform into shadow for bonus attack" },
            { id: "shadow_ultimate", name: "âš”ï¸ SHADOW STRIKE", cost: 8, tier: 5, ultimate: true, equippable: true, description: "3 shadow clones attack (150% ATK each, 6s CD)" }
          ],
          spirit: [
            { id: "spirit_1", name: "+5% ATK + Spirit Link", cost: 1, tier: 1, description: "Connect with spirits for attack bonus" },
            { id: "spirit_2", name: "+8% ATK + Ethereal Power", cost: 2, tier: 2, description: "Channel ethereal energy, +5% haste" },
            { id: "spirit_3", name: "+12% ATK + Soul Weapon", cost: 3, tier: 3, description: "Manifest soul weapon, +8% haste" },
            { id: "spirit_4", name: "+18% ATK + Spirit Form", cost: 4, tier: 4, description: "Transform into spirit form, +12% haste" },
            { id: "spirit_ultimate", name: "âš”ï¸ SPIRIT BLADE", cost: 8, tier: 5, ultimate: true, equippable: true, description: "5 floating swords attack continuously (80% ATK/hit)" }
          ],
          lightning: [
            { id: "lightning_1", name: "+5% ATK + Static Charge", cost: 1, tier: 1, description: "Build static electricity for damage" },
            { id: "lightning_2", name: "+10% ATK + Shock Wave", cost: 2, tier: 2, description: "Electric shockwaves, +5% crit" },
            { id: "lightning_3", name: "+15% ATK + Thunder Strike", cost: 3, tier: 3, description: "Thunder empowerment, +8% crit" },
            { id: "lightning_4", name: "+22% ATK + Storm Power", cost: 4, tier: 4, description: "Harness storm power, +12% crit" },
            { id: "lightning_ultimate", name: "âš¡ LIGHTNING STEP", cost: 8, tier: 5, ultimate: true, equippable: true, description: "Teleport-strike with chain lightning (250% ATK, 8s CD)" }
          ],
          void: [
            { id: "void_1", name: "+5% ATK + Void Touch", cost: 1, tier: 1, description: "Touch of the void for dark damage" },
            { id: "void_2", name: "+8% ATK + Dark Drain", cost: 2, tier: 2, description: "Drain enemy life, +3% lifesteal" },
            { id: "void_3", name: "+12% ATK + Void Grasp", cost: 3, tier: 3, description: "Grasp enemies with void, +5% lifesteal" },
            { id: "void_4", name: "+18% ATK + Shadow Bind", cost: 4, tier: 4, description: "Bind enemies in shadow, +8% lifesteal" },
            { id: "void_ultimate", name: "ğŸŒ‘ VOID CHAINS", cost: 8, tier: 5, ultimate: true, equippable: true, description: "Dark chains bind enemies (120% ATK/s + 5% drain, 10s)" }
          ],
          phoenix: [
            { id: "phoenix_1", name: "+5% ATK + Flame Aura", cost: 1, tier: 1, description: "Aura of flames surrounds you" },
            { id: "phoenix_2", name: "+10% ATK + Fire Burst", cost: 2, tier: 2, description: "Burst of fire, +50 HP" },
            { id: "phoenix_3", name: "+15% ATK + Burning Soul", cost: 3, tier: 3, description: "Burning soul power, +100 HP" },
            { id: "phoenix_4", name: "+20% ATK + Rebirth", cost: 4, tier: 4, description: "Phoenix rebirth power, +150 HP" },
            { id: "phoenix_ultimate", name: "ğŸ”¥ PHOENIX WINGS", cost: 8, tier: 5, ultimate: true, equippable: true, description: "Fire wings burn enemies (180% ATK/s + 15% HP on kill)" }
          ],
          monarch: [
            { id: "monarch_1", name: "+8% ATK + Command Aura", cost: 1, tier: 1, description: "Command aura empowers attacks" },
            { id: "monarch_2", name: "+15% ATK + Army Power", cost: 2, tier: 2, description: "Army power boost, +100 HP" },
            { id: "monarch_3", name: "+25% ATK + Legion Might", cost: 3, tier: 3, description: "Legion might, +200 HP, +10% crit" },
            { id: "monarch_4", name: "+35% ATK + Shadow Legion", cost: 5, tier: 4, description: "Shadow legion power, +300 HP, +15% crit, +15% haste" },
            { id: "monarch_ultimate", name: "ğŸ‘‘ MONARCH'S ARMY", cost: 12, tier: 5, ultimate: true, equippable: true, description: "S-RANK: Command 10 shadow soldiers (200% ATK each) + 100% all stats!" }
          ],
          supernatural: [
            { id: "super_1", name: "Spirit Bond", cost: 10, tier: 1, srank: true, description: "Equipped spirits gain +20% effectiveness" },
            { id: "super_2", name: "Essence Mastery", cost: 15, tier: 2, srank: true, description: "Gain 2x essence from all sources" },
            { id: "super_3", name: "Ability Fusion", cost: 20, tier: 3, srank: true, description: "Cast two abilities simultaneously" },
            { id: "super_4", name: "Transcendence", cost: 25, tier: 4, srank: true, description: "-50% cooldown on supernatural abilities" },
            { id: "super_ultimate", name: "ETHEREAL ASCENSION", cost: 50, tier: 5, ultimate: true, srank: true, description: "Immunity + all spirits attack simultaneously" }
          ],
          ultimates: [
            { id: "ultimate_omega", name: "OMEGA FORCE", cost: 100, tier: 7, ultimate: true, crossSystem: true, description: "+100% ATK/DEF, CC immunity" },
            { id: "ultimate_infinity", name: "INFINITY STRIKE", cost: 120, tier: 7, ultimate: true, crossSystem: true, description: "Deal 9999 true damage" },
            { id: "ultimate_eternal", name: "ETERNAL GUARDIAN", cost: 150, tier: 7, ultimate: true, crossSystem: true, description: "Revive party at full HP, protective dome" },
            { id: "ultimate_divine", name: "DIVINE APOTHEOSIS", cost: 200, tier: 8, ultimate: true, crossSystem: true, description: "Become a god for 30s - unlimited power" }
          ]
        },
        alchemy: {
          fusion: { description: "Combine 3 items of same type and rank to create 1 of next rank", example: "C+C+C â†’ B" },
          special: { description: "C Gear + B Gear + C Pet for premium loot", rewards: ["B Gear (30%)", "B Pet (30%)", "Gift Key (20%)", "Treasure Box (20%)"] },
          generic: { description: "Any 3 items â†’ treasure box based on highest rank", example: "C+B+C â†’ B-Rank Box" },
          treasureBoxes: {
            C: { gold: "100-500", items: "1-2 C-rank", rare: "10% B-rank" },
            B: { gold: "500-1500", items: "2-3 B-rank", rare: "15% A-rank" },
            A: { gold: "1500-5000", items: "2-4 A-rank", rare: "20% S-rank" },
            S: { gold: "5000-15000", items: "3-5 S-rank", rare: "Guaranteed Legendary" }
          }
        },
        shop: [
          // ========== CONSUMABLES (21 items) ==========
          { id: "hp_potion", name: "HP Potion", icon: "ğŸ§ª", category: "consumable", cost: 60, rank: "C", description: "Heals 40% HP" },
          { id: "rage_pill", name: "Rage Pill", icon: "ğŸ’Š", category: "consumable", cost: 90, rank: "C", description: "+30 Rage" },
          { id: "revive_token", name: "Revive Token", icon: "ğŸ’«", category: "consumable", cost: 80, rank: "C", description: "Revive hero" },
          { id: "wave_skip", name: "Wave Skip", icon: "â­ï¸", category: "consumable", cost: 100, rank: "C", description: "Skip wave" },
          { id: "stage_skip", name: "Stage Skip", icon: "ğŸ¯", category: "consumable", cost: 500, rank: "B", description: "Skip stage" },
          { id: "boss_skip", name: "Boss Skip Pass", icon: "ğŸ‘¹", category: "consumable", cost: 1000, rank: "A", description: "Skip to next boss" },
          { id: "treasure_boss_pass", name: "Treasure Boss Pass", icon: "ğŸ’", category: "consumable", cost: 2000, rank: "A", description: "Unlock treasure boss" },
          { id: "ap_reset", name: "AP Reset", icon: "ğŸ”„", category: "consumable", cost: 400, rank: "B", description: "Refund all AP" },
          { id: "xp_potion", name: "XP Potion", icon: "â­", category: "consumable", cost: 350, rank: "B", description: "Bonus XP" },
          { id: "rare_candy", name: "Rare Candy", icon: "ğŸ¬", category: "consumable", cost: 1000, rank: "A", description: "Instant level up" },
          { id: "skill_reset", name: "Skill Reset Orb", icon: "ğŸ”®", category: "consumable", cost: 800, rank: "B", description: "Reset skills" },
          { id: "warp_crystal", name: "Warp Crystal", icon: "ğŸ’ ", category: "consumable", cost: 600, rank: "B", description: "Teleport to cleared stage" },
          { id: "fortune_cookie", name: "Fortune Cookie", icon: "ğŸ¥ ", category: "consumable", cost: 100, rank: "C", description: "Random buff" },
          { id: "exp_pack_small", name: "Small EXP Pack", icon: "ğŸ“¦", category: "consumable", cost: 300, rank: "C", description: "500 EXP" },
          { id: "exp_pack_medium", name: "Medium EXP Pack", icon: "ğŸ“¦", category: "consumable", cost: 800, rank: "B", description: "1500 EXP" },
          { id: "exp_pack_large", name: "Large EXP Pack", icon: "ğŸ“¦", category: "consumable", cost: 2000, rank: "A", description: "5000 EXP" },
          { id: "exp_pack_mega", name: "Mega EXP Pack", icon: "ğŸ“¦", category: "consumable", cost: 5000, rank: "S", description: "15000 EXP!" },
          
          // ========== CONTAINERS & MISC (8 items) ==========
          { id: "gold_bag", name: "Gold Bag", icon: "ğŸ’°", category: "misc", cost: 300, rank: "C", description: "500-5K gold" },
          { id: "big_gold_bag", name: "Big Gold Bag", icon: "ğŸ’°", category: "misc", cost: 1200, rank: "B", description: "2K-10K gold" },
          { id: "gear_kit", name: "Gear Kit", icon: "âš™ï¸", category: "misc", cost: 250, rank: "C", description: "3 random gear" },
          { id: "pet_box", name: "Pet Box", icon: "ğŸ", category: "misc", cost: 500, rank: "B", description: "Random pet" },
          { id: "vehicle_box", name: "Vehicle Box", icon: "ğŸ“¦", category: "misc", cost: 750, rank: "B", description: "Random vehicle" },
          { id: "super_equipment_pack", name: "Super Equipment Pack", icon: "ğŸ", category: "misc", cost: 1500, rank: "A", description: "B-A gear" },
          { id: "big_box", name: "Big Box", icon: "ğŸ", category: "misc", cost: 3000, rank: "A", description: "Premium loot pack" },
          { id: "evolution_stone", name: "Evolution Stone", icon: "ğŸ’", category: "misc", cost: 2000, rank: "A", description: "Evolve pet/companion" },
          { id: "enchant_scroll", name: "Enchant Scroll", icon: "ğŸ“œ", category: "misc", cost: 1500, rank: "A", description: "Upgrade gear rank" },
          { id: "soul_gem", name: "Soul Gem", icon: "ğŸ’ ", category: "misc", cost: 1200, rank: "B", description: "Capture spirits" },
          
          // ========== WEAPONS (6 items) ==========
          { id: "iron_sword", name: "Iron Sword", icon: "ğŸ—¡ï¸", category: "gear", slot: "weapon", cost: 150, rank: "C", atk: 10, description: "Basic iron sword" },
          { id: "steel_blade", name: "Steel Blade", icon: "âš”ï¸", category: "gear", slot: "weapon", cost: 300, rank: "B", atk: 20, description: "Sturdy steel weapon" },
          { id: "mithril_edge", name: "Mithril Edge", icon: "âš”ï¸", category: "gear", slot: "weapon", cost: 600, rank: "A", atk: 35, description: "Lightweight but powerful" },
          { id: "battle_axe", name: "Battle Axe", icon: "ğŸª“", category: "gear", slot: "weapon", cost: 400, rank: "B", atk: 30, critDamage: 20, description: "Heavy weapon" },
          { id: "crystal_staff", name: "Crystal Staff", icon: "ğŸ”®", category: "gear", slot: "weapon", cost: 500, rank: "B", atk: 25, mp: 100, description: "Amplifies magic" },
          { id: "twin_daggers", name: "Twin Daggers", icon: "ğŸ—¡ï¸", category: "gear", slot: "weapon", cost: 450, rank: "B", atk: 22, speed: 30, description: "Fast dual-wield" },
          
          // ========== ARMOR (5 items) ==========
          { id: "vanguard_armor", name: "Vanguard Armor", icon: "ğŸ›¡ï¸", category: "armor", slot: "armor", cost: 500, rank: "B", def: 50, description: "Sturdy armor" },
          { id: "mystic_robes", name: "Mystic Robes", icon: "ğŸ‘˜", category: "armor", slot: "armor", cost: 600, rank: "B", def: 40, mp: 50, description: "Robes +DEF +MP" },
          { id: "shadow_cloak", name: "Shadow Cloak", icon: "ğŸ§¥", category: "armor", slot: "armor", cost: 700, rank: "A", def: 30, evasion: 15, description: "Stealth cloak" },
          { id: "dragon_plate", name: "Dragon Plate", icon: "ğŸ›¡ï¸", category: "armor", slot: "armor", cost: 800, rank: "A", def: 80, resistance: 20, description: "Fire resistant" },
          { id: "guardian_mail", name: "Guardian Mail", icon: "ğŸ›¡ï¸", category: "armor", slot: "armor", cost: 650, rank: "B", def: 60, hp: 100, description: "Protective chainmail" },
          
          // ========== ACCESSORIES (6 items) ==========
          { id: "strength_ring", name: "Strength Ring", icon: "ğŸ’", category: "gear", slot: "accessory", cost: 200, rank: "C", atk: 8, description: "+ATK" },
          { id: "vitality_amulet", name: "Vitality Amulet", icon: "ğŸ“¿", category: "gear", slot: "accessory", cost: 250, rank: "C", hp: 80, description: "+HP" },
          { id: "mana_pendant", name: "Mana Pendant", icon: "ğŸ”·", category: "gear", slot: "accessory", cost: 220, rank: "C", mp: 60, description: "+MP" },
          { id: "lucky_charm", name: "Lucky Charm", icon: "ğŸ€", category: "gear", slot: "accessory", cost: 300, rank: "B", luck: 20, description: "+Luck" },
          { id: "speed_boots", name: "Speed Boots", icon: "ğŸ‘¢", category: "gear", slot: "boots", cost: 280, rank: "B", speed: 25, description: "+Speed" },
          { id: "defense_bracers", name: "Defense Bracers", icon: "ğŸ¥Š", category: "gear", slot: "bracers", cost: 260, rank: "B", def: 25, description: "+DEF" },
          
          // ========== SPELL SCROLLS (8 items) ==========
          { id: "scroll_fireball", name: "Scroll: Fireball", icon: "ğŸ“œ", category: "scroll", cost: 400, rank: "B", description: "Learn Fireball" },
          { id: "scroll_heal", name: "Scroll: Heal", icon: "ğŸ“œ", category: "scroll", cost: 500, rank: "B", description: "Learn Heal" },
          { id: "scroll_lightning", name: "Scroll: Lightning", icon: "ğŸ“œ", category: "scroll", cost: 600, rank: "B", description: "Learn Lightning" },
          { id: "scroll_ice", name: "Scroll: Ice Nova", icon: "ğŸ“œ", category: "scroll", cost: 550, rank: "B", description: "Learn Ice Nova" },
          { id: "scroll_meteor", name: "Scroll: Meteor", icon: "ğŸ“œ", category: "scroll", cost: 800, rank: "A", description: "Learn Meteor" },
          { id: "scroll_teleport", name: "Scroll: Teleport", icon: "ğŸ“œ", category: "scroll", cost: 700, rank: "A", description: "Learn Teleport" },
          { id: "scroll_shield", name: "Scroll: Shield", icon: "ğŸ“œ", category: "scroll", cost: 450, rank: "B", description: "Learn Magic Shield" },
          { id: "scroll_summon", name: "Scroll: Summon", icon: "ğŸ“œ", category: "scroll", cost: 900, rank: "A", description: "Learn Summon Ally" },
          
          // ========== S-RANK PREMIUM (7 items) ==========
          { id: "aether_greatblade", name: "Aether Greatblade", icon: "âš”ï¸", category: "srank", slot: "weapon", cost: 5000, rank: "S", atk: 55, description: "Cosmic blade" },
          { id: "starlit_carapace", name: "Starlit Carapace", icon: "ğŸ›¡ï¸", category: "srank", slot: "armor", cost: 5000, rank: "S", def: 60, description: "Starlight armor" },
          { id: "celestial_loop", name: "Celestial Loop", icon: "ğŸ’", category: "srank", slot: "accessory", cost: 5000, rank: "S", atk: 65, description: "Celestial ring" },
          { id: "void_reaper", name: "Void Reaper", icon: "ğŸ—¡ï¸", category: "srank", slot: "weapon", cost: 6000, rank: "S", atk: 75, critDamage: 50, description: "Reality-tearing scythe" },
          { id: "eternal_crown", name: "Eternal Crown", icon: "ğŸ‘‘", category: "srank", slot: "helmet", cost: 5500, rank: "S", def: 45, mp: 200, description: "Crown of kings" },
          { id: "phoenix_wings", name: "Phoenix Wings", icon: "ğŸª½", category: "srank", slot: "back", cost: 7000, rank: "S", atk: 40, def: 40, revival: true, description: "Wings of rebirth" },
          { id: "infinity_gauntlet", name: "Infinity Gauntlet", icon: "ğŸ§¤", category: "srank", slot: "gloves", cost: 10000, rank: "S", atk: 100, allStats: 50, description: "Ultimate power!" },
          
          // ========== WEAPON CORES E-RANK (3 items) ==========
          { id: "core_ember", name: "Ember Core", icon: "ğŸ”¥", category: "cores", slot: "core", cost: 100, rank: "E", skill: "Fire Spark", cd: 5000, dmg: 20, description: "E-Rank: Fire sparks" },
          { id: "core_frost", name: "Frost Core", icon: "â„ï¸", category: "cores", slot: "core", cost: 100, rank: "E", skill: "Frost Mist", cd: 5000, dmg: 18, description: "E-Rank: Icy mist" },
          { id: "core_spark", name: "Spark Core", icon: "âš¡", category: "cores", slot: "core", cost: 100, rank: "E", skill: "Static Zap", cd: 4500, dmg: 22, description: "E-Rank: Electric zaps" },
          
          // ========== WEAPON CORES D-RANK (3 items) ==========
          { id: "core_stone", name: "Stone Core", icon: "ğŸª¨", category: "cores", slot: "core", cost: 250, rank: "D", skill: "Rock Shard", cd: 4000, dmg: 35, hp: 10, description: "D-Rank: Rock shards +HP" },
          { id: "core_wind", name: "Wind Core", icon: "ğŸ’¨", category: "cores", slot: "core", cost: 250, rank: "D", skill: "Wind Gust", cd: 4200, dmg: 30, speed: 5, description: "D-Rank: Wind gust +Speed" },
          { id: "core_shadow", name: "Shadow Core", icon: "ğŸŒ‘", category: "cores", slot: "core", cost: 280, rank: "D", skill: "Shadow Pulse", cd: 4500, dmg: 40, ls: 2, description: "D-Rank: Dark pulse +Lifesteal" },
          
          // ========== WEAPON CORES C-RANK (2 items) ==========
          { id: "core_nature", name: "Nature Core", icon: "ğŸŒ¿", category: "cores", slot: "core", cost: 500, rank: "C", skill: "Vine Whip", cd: 4000, dmg: 55, regen: 1, description: "C-Rank: Vine whip +Regen" },
          { id: "core_poison", name: "Poison Core", icon: "â˜ ï¸", category: "cores", slot: "core", cost: 550, rank: "C", skill: "Poison Cloud", cd: 4500, dmg: 45, dot: 10, description: "C-Rank: Toxic cloud DoT" },
          
          // ========== WEAPON CORES B-RANK (2 items) ==========
          { id: "core_plasma", name: "Plasma Core", icon: "âš›ï¸", category: "cores", slot: "core", cost: 1000, rank: "B", skill: "Plasma Burst", cd: 3500, dmg: 90, crit: 5, description: "B-Rank: Plasma burst +Crit" },
          { id: "core_lunar", name: "Lunar Core", icon: "ğŸŒ™", category: "cores", slot: "core", cost: 1100, rank: "B", skill: "Lunar Beam", cd: 3800, dmg: 85, acc: 6, description: "B-Rank: Moon beam +Accuracy" },
          
          // ========== CORE PACK (1 item) ==========
          { id: "core_starter_pack", name: "Core Starter Pack", icon: "ğŸ“¦", category: "misc", cost: 400, rank: "C", description: "3 random E-D cores" },
          
          // ========== SUPERNATURAL & ESSENCE (6 items) ==========
          { id: "essence_small", name: "Small Essence Vial", icon: "âœ¨", category: "supernatural", cost: 200, rank: "C", essenceAmount: 5, description: "5 essence" },
          { id: "essence_medium", name: "Medium Essence Flask", icon: "ğŸŒŸ", category: "supernatural", cost: 500, rank: "B", essenceAmount: 15, description: "15 essence" },
          { id: "essence_large", name: "Large Essence Crystal", icon: "ğŸ’", category: "supernatural", cost: 1200, rank: "A", essenceAmount: 40, description: "40 essence" },
          { id: "essence_pack_premium", name: "Essence Pack Premium", icon: "ğŸŒ ", category: "supernatural", cost: 2500, rank: "S", essenceAmount: 100, bonusSpirit: true, description: "100 essence + spirit!" },
          { id: "spirit_summon_scroll", name: "Spirit Summon", icon: "ğŸ“¿", category: "supernatural", cost: 50, rank: "B", currency: "essence", description: "Summon random spirit" },
          { id: "ability_unlock_token", name: "Ability Token", icon: "ğŸ«", category: "supernatural", cost: 80, rank: "A", currency: "essence", description: "Unlock supernatural ability" },
          { id: "spirit_evolution_catalyst", name: "Evolution Catalyst", icon: "âš—ï¸", category: "supernatural", cost: 150, rank: "S", currency: "essence", description: "Boost spirit traits +1" }
        ],
        skins: {
          A1: [
            { id: "a1_default", name: "Default A1", rarity: "common", unlocked: true, description: "Original A1 warrior design" },
            { id: "a1_warrior", name: "Battle Warrior", rarity: "rare", unlocked: true, description: "Enhanced warrior with battle armor", unlock: "Complete 10 quests" },
            { id: "a1_shadow", name: "Shadow Warrior", rarity: "epic", unlocked: false, description: "Dark warrior with shadow powers", unlock: "Defeat 100 enemies" },
            { id: "a1_golden", name: "Golden Warrior", rarity: "legendary", unlocked: false, description: "Legendary golden armor", unlock: "Reach level 50" }
          ],
          Unique: [
            { id: "unique_default", name: "Default Unique", rarity: "common", unlocked: true, description: "Original Unique rogue design" },
            { id: "unique_rogue", name: "Shadow Rogue", rarity: "rare", unlocked: true, description: "Stealthy rogue with enhanced agility", unlock: "Complete stealth missions" },
            { id: "unique_tactical", name: "Tactical Ops", rarity: "epic", unlocked: false, description: "Futuristic tactical operative", unlock: "Complete all side quests" },
            { id: "unique_phantom", name: "Phantom Assassin", rarity: "legendary", unlocked: false, description: "Master of shadows and stealth", unlock: "Defeat 5 bosses without taking damage" }
          ],
          Missy: [
            { id: "missy_default", name: "Default Missy", rarity: "common", unlocked: true, description: "Original Missy mage design" },
            { id: "missy_mage", name: "Arcane Mage", rarity: "rare", unlocked: true, description: "Powerful mage with arcane abilities", unlock: "Cast 1000 spells" },
            { id: "missy_angel", name: "Angel Guardian", rarity: "epic", unlocked: true, description: "Divine angel with halo and wings", unlock: "Heal 10,000 HP" },
            { id: "missy_celestial", name: "Celestial Sorceress", rarity: "legendary", unlocked: false, description: "Supreme magical powers from the cosmos", unlock: "Master all magic schools" }
          ]
        },
        abilities: [
          { id: "divine_barrier", name: "Divine Barrier", icon: "ğŸ›¡ï¸", type: "active", cooldown: 12000, duration: 5000, bonuses: { defense: 50, damageReduction: 0.3 }, description: "Creates a protective barrier that reduces incoming damage" },
          { id: "dash_nova", name: "Dash Nova", icon: "âš¡", type: "active", cooldown: 8000, duration: 500, bonuses: { speed: 2, attack: 30 }, description: "Quick dash forward with explosive damage" },
          { id: "angelic_might", name: "Angelic Might", icon: "âœ¨", type: "active", cooldown: 15000, duration: 8000, bonuses: { attack: 100, critRate: 0.2 }, description: "Channel divine power to increase attack" },
          { id: "radiant_burst", name: "Radiant Burst", icon: "ğŸŒŸ", type: "active", cooldown: 10000, duration: 3000, bonuses: { attack: 50, aoe: 150 }, description: "Emit a burst of radiant energy damaging nearby enemies" },
          { id: "flame_dash", name: "Flame Dash", icon: "ğŸ”¥", type: "active", cooldown: 6000, duration: 1000, bonuses: { speed: 1.5, attack: 40 }, description: "Dash forward leaving a trail of flames" },
          { id: "eternal_wisdom", name: "Eternal Wisdom", icon: "ğŸ“š", type: "passive", bonuses: { xpGain: 0.15 }, description: "Permanent increase to experience gain" },
          { id: "warriors_heart", name: "Warrior's Heart", icon: "â¤ï¸", type: "passive", bonuses: { maxHp: 100, hpRegen: 2 }, description: "Permanent increase to maximum health" }
        ],
        shop: [
          // ========== CONSUMABLES (21 items) ==========
          { id: "hp_potion", name: "HP Potion", icon: "ğŸ§ª", category: "consumable", cost: 60, rank: "C", description: "Heals 40% HP" },
          { id: "rage_pill", name: "Rage Pill", icon: "ğŸ’Š", category: "consumable", cost: 90, rank: "C", description: "+30 Rage" },
          { id: "revive_token", name: "Revive Token", icon: "ğŸ’«", category: "consumable", cost: 80, rank: "C", description: "Revive hero" },
          { id: "wave_skip", name: "Wave Skip", icon: "â­ï¸", category: "consumable", cost: 100, rank: "C", description: "Skip wave" },
          { id: "stage_skip", name: "Stage Skip", icon: "ğŸ¯", category: "consumable", cost: 500, rank: "B", description: "Skip stage" },
          { id: "boss_skip", name: "Boss Skip Pass", icon: "ğŸ‘¹", category: "consumable", cost: 1000, rank: "A", description: "Skip to next boss" },
          { id: "treasure_boss_pass", name: "Treasure Boss Pass", icon: "ğŸ’", category: "consumable", cost: 2000, rank: "A", description: "Unlock treasure boss" },
          { id: "ap_reset", name: "AP Reset", icon: "ğŸ”„", category: "consumable", cost: 400, rank: "B", description: "Refund all AP" },
          { id: "xp_potion", name: "XP Potion", icon: "â­", category: "consumable", cost: 350, rank: "B", description: "Bonus XP" },
          { id: "rare_candy", name: "Rare Candy", icon: "ğŸ¬", category: "consumable", cost: 1000, rank: "A", description: "Instant level up" },
          { id: "skill_reset", name: "Skill Reset Orb", icon: "ğŸ”®", category: "consumable", cost: 800, rank: "B", description: "Reset skills" },
          { id: "warp_crystal", name: "Warp Crystal", icon: "ğŸ’ ", category: "consumable", cost: 600, rank: "B", description: "Teleport to cleared stage" },
          { id: "fortune_cookie", name: "Fortune Cookie", icon: "ğŸ¥ ", category: "consumable", cost: 100, rank: "C", description: "Random buff" },
          { id: "exp_pack_small", name: "Small EXP Pack", icon: "ğŸ“¦", category: "consumable", cost: 300, rank: "C", description: "500 EXP" },
          { id: "exp_pack_medium", name: "Medium EXP Pack", icon: "ğŸ“¦", category: "consumable", cost: 800, rank: "B", description: "1500 EXP" },
          { id: "exp_pack_large", name: "Large EXP Pack", icon: "ğŸ“¦", category: "consumable", cost: 2000, rank: "A", description: "5000 EXP" },
          { id: "exp_pack_mega", name: "Mega EXP Pack", icon: "ğŸ“¦", category: "consumable", cost: 5000, rank: "S", description: "15000 EXP!" },
          
          // ========== CONTAINERS & MISC (10 items) ==========
          { id: "gold_bag", name: "Gold Bag", icon: "ğŸ’°", category: "misc", cost: 300, rank: "C", description: "500-5K gold" },
          { id: "big_gold_bag", name: "Big Gold Bag", icon: "ğŸ’°", category: "misc", cost: 1200, rank: "B", description: "2K-10K gold" },
          { id: "gear_kit", name: "Gear Kit", icon: "âš™ï¸", category: "misc", cost: 250, rank: "C", description: "3 random gear" },
          { id: "pet_box", name: "Pet Box", icon: "ğŸ", category: "misc", cost: 500, rank: "B", description: "Random pet" },
          { id: "vehicle_box", name: "Vehicle Box", icon: "ğŸ“¦", category: "misc", cost: 750, rank: "B", description: "Random vehicle" },
          { id: "super_equipment_pack", name: "Super Equipment Pack", icon: "ğŸ", category: "misc", cost: 1500, rank: "A", description: "B-A gear" },
          { id: "big_box", name: "Big Box", icon: "ğŸ", category: "misc", cost: 3000, rank: "A", description: "Premium loot pack" },
          { id: "evolution_stone", name: "Evolution Stone", icon: "ğŸ’", category: "misc", cost: 2000, rank: "A", description: "Evolve pet/companion" },
          { id: "enchant_scroll", name: "Enchant Scroll", icon: "ğŸ“œ", category: "misc", cost: 1500, rank: "A", description: "Upgrade gear rank" },
          { id: "soul_gem", name: "Soul Gem", icon: "ğŸ’ ", category: "misc", cost: 1200, rank: "B", description: "Capture spirits" },
          
          // ========== WEAPONS (6 items) ==========
          { id: "iron_sword", name: "Iron Sword", icon: "ğŸ—¡ï¸", category: "gear", slot: "weapon", cost: 150, rank: "C", atk: 10, description: "Basic iron sword" },
          { id: "steel_blade", name: "Steel Blade", icon: "âš”ï¸", category: "gear", slot: "weapon", cost: 300, rank: "B", atk: 20, description: "Sturdy steel weapon" },
          { id: "mithril_edge", name: "Mithril Edge", icon: "âš”ï¸", category: "gear", slot: "weapon", cost: 600, rank: "A", atk: 35, description: "Lightweight but powerful" },
          { id: "battle_axe", name: "Battle Axe", icon: "ğŸª“", category: "gear", slot: "weapon", cost: 400, rank: "B", atk: 30, critDamage: 20, description: "Heavy weapon" },
          { id: "crystal_staff", name: "Crystal Staff", icon: "ğŸ”®", category: "gear", slot: "weapon", cost: 500, rank: "B", atk: 25, mp: 100, description: "Amplifies magic" },
          { id: "twin_daggers", name: "Twin Daggers", icon: "ğŸ—¡ï¸", category: "gear", slot: "weapon", cost: 450, rank: "B", atk: 22, speed: 30, description: "Fast dual-wield" },
          
          // ========== ARMOR (5 items) ==========
          { id: "vanguard_armor", name: "Vanguard Armor", icon: "ğŸ›¡ï¸", category: "armor", slot: "armor", cost: 500, rank: "B", def: 50, description: "Sturdy armor" },
          { id: "mystic_robes", name: "Mystic Robes", icon: "ğŸ‘˜", category: "armor", slot: "armor", cost: 600, rank: "B", def: 40, mp: 50, description: "Robes +DEF +MP" },
          { id: "shadow_cloak", name: "Shadow Cloak", icon: "ğŸ§¥", category: "armor", slot: "armor", cost: 700, rank: "A", def: 30, evasion: 15, description: "Stealth cloak" },
          { id: "dragon_plate", name: "Dragon Plate", icon: "ğŸ›¡ï¸", category: "armor", slot: "armor", cost: 800, rank: "A", def: 80, resistance: 20, description: "Fire resistant" },
          { id: "guardian_mail", name: "Guardian Mail", icon: "ğŸ›¡ï¸", category: "armor", slot: "armor", cost: 650, rank: "B", def: 60, hp: 100, description: "Protective chainmail" },
          
          // ========== ACCESSORIES (6 items) ==========
          { id: "strength_ring", name: "Strength Ring", icon: "ğŸ’", category: "gear", slot: "accessory", cost: 200, rank: "C", atk: 8, description: "+ATK" },
          { id: "vitality_amulet", name: "Vitality Amulet", icon: "ğŸ“¿", category: "gear", slot: "accessory", cost: 250, rank: "C", hp: 80, description: "+HP" },
          { id: "mana_pendant", name: "Mana Pendant", icon: "ğŸ”·", category: "gear", slot: "accessory", cost: 220, rank: "C", mp: 60, description: "+MP" },
          { id: "lucky_charm", name: "Lucky Charm", icon: "ğŸ€", category: "gear", slot: "accessory", cost: 300, rank: "B", luck: 20, description: "+Luck" },
          { id: "speed_boots", name: "Speed Boots", icon: "ğŸ‘¢", category: "gear", slot: "boots", cost: 280, rank: "B", speed: 25, description: "+Speed" },
          { id: "defense_bracers", name: "Defense Bracers", icon: "ğŸ¥Š", category: "gear", slot: "bracers", cost: 260, rank: "B", def: 25, description: "+DEF" },
          
          // ========== SPELL SCROLLS (8 items) ==========
          { id: "scroll_fireball", name: "Scroll: Fireball", icon: "ğŸ“œ", category: "scroll", cost: 400, rank: "B", description: "Learn Fireball" },
          { id: "scroll_heal", name: "Scroll: Heal", icon: "ğŸ“œ", category: "scroll", cost: 500, rank: "B", description: "Learn Heal" },
          { id: "scroll_lightning", name: "Scroll: Lightning", icon: "ğŸ“œ", category: "scroll", cost: 600, rank: "B", description: "Learn Lightning" },
          { id: "scroll_ice", name: "Scroll: Ice Nova", icon: "ğŸ“œ", category: "scroll", cost: 550, rank: "B", description: "Learn Ice Nova" },
          { id: "scroll_meteor", name: "Scroll: Meteor", icon: "ğŸ“œ", category: "scroll", cost: 800, rank: "A", description: "Learn Meteor" },
          { id: "scroll_teleport", name: "Scroll: Teleport", icon: "ğŸ“œ", category: "scroll", cost: 700, rank: "A", description: "Learn Teleport" },
          { id: "scroll_shield", name: "Scroll: Shield", icon: "ğŸ“œ", category: "scroll", cost: 450, rank: "B", description: "Learn Magic Shield" },
          { id: "scroll_summon", name: "Scroll: Summon", icon: "ğŸ“œ", category: "scroll", cost: 900, rank: "A", description: "Learn Summon Ally" },
          
          // ========== S-RANK PREMIUM (7 items) ==========
          { id: "aether_greatblade", name: "Aether Greatblade", icon: "âš”ï¸", category: "srank", slot: "weapon", cost: 5000, rank: "S", atk: 55, description: "Cosmic blade" },
          { id: "starlit_carapace", name: "Starlit Carapace", icon: "ğŸ›¡ï¸", category: "srank", slot: "armor", cost: 5000, rank: "S", def: 60, description: "Starlight armor" },
          { id: "celestial_loop", name: "Celestial Loop", icon: "ğŸ’", category: "srank", slot: "accessory", cost: 5000, rank: "S", atk: 65, description: "Celestial ring" },
          { id: "void_reaper", name: "Void Reaper", icon: "ğŸ—¡ï¸", category: "srank", slot: "weapon", cost: 6000, rank: "S", atk: 75, critDamage: 50, description: "Reality-tearing scythe" },
          { id: "eternal_crown", name: "Eternal Crown", icon: "ğŸ‘‘", category: "srank", slot: "helmet", cost: 5500, rank: "S", def: 45, mp: 200, description: "Crown of kings" },
          { id: "phoenix_wings", name: "Phoenix Wings", icon: "ğŸª½", category: "srank", slot: "back", cost: 7000, rank: "S", atk: 40, def: 40, revival: true, description: "Wings of rebirth" },
          { id: "infinity_gauntlet", name: "Infinity Gauntlet", icon: "ğŸ§¤", category: "srank", slot: "gloves", cost: 10000, rank: "S", atk: 100, allStats: 50, description: "Ultimate power!" },
          
          // ========== WEAPON CORES E-RANK (3 items) ==========
          { id: "core_ember", name: "Ember Core", icon: "ğŸ”¥", category: "cores", slot: "core", cost: 100, rank: "E", skill: "Fire Spark", cd: 5000, dmg: 20, description: "E-Rank: Fire sparks" },
          { id: "core_frost", name: "Frost Core", icon: "â„ï¸", category: "cores", slot: "core", cost: 100, rank: "E", skill: "Frost Mist", cd: 5000, dmg: 18, description: "E-Rank: Icy mist" },
          { id: "core_spark", name: "Spark Core", icon: "âš¡", category: "cores", slot: "core", cost: 100, rank: "E", skill: "Static Zap", cd: 4500, dmg: 22, description: "E-Rank: Electric zaps" },
          
          // ========== WEAPON CORES D-RANK (3 items) ==========
          { id: "core_stone", name: "Stone Core", icon: "ğŸª¨", category: "cores", slot: "core", cost: 250, rank: "D", skill: "Rock Shard", cd: 4000, dmg: 35, hp: 10, description: "D-Rank: Rock shards +HP" },
          { id: "core_wind", name: "Wind Core", icon: "ğŸ’¨", category: "cores", slot: "core", cost: 250, rank: "D", skill: "Wind Gust", cd: 4200, dmg: 30, speed: 5, description: "D-Rank: Wind gust +Speed" },
          { id: "core_shadow", name: "Shadow Core", icon: "ğŸŒ‘", category: "cores", slot: "core", cost: 280, rank: "D", skill: "Shadow Pulse", cd: 4500, dmg: 40, ls: 2, description: "D-Rank: Dark pulse +Lifesteal" },
          
          // ========== WEAPON CORES C-RANK (2 items) ==========
          { id: "core_nature", name: "Nature Core", icon: "ğŸŒ¿", category: "cores", slot: "core", cost: 500, rank: "C", skill: "Vine Whip", cd: 4000, dmg: 55, regen: 1, description: "C-Rank: Vine whip +Regen" },
          { id: "core_poison", name: "Poison Core", icon: "â˜ ï¸", category: "cores", slot: "core", cost: 550, rank: "C", skill: "Poison Cloud", cd: 4500, dmg: 45, dot: 10, description: "C-Rank: Toxic cloud DoT" },
          
          // ========== WEAPON CORES B-RANK (2 items) ==========
          { id: "core_plasma", name: "Plasma Core", icon: "âš›ï¸", category: "cores", slot: "core", cost: 1000, rank: "B", skill: "Plasma Burst", cd: 3500, dmg: 90, crit: 5, description: "B-Rank: Plasma burst +Crit" },
          { id: "core_lunar", name: "Lunar Core", icon: "ğŸŒ™", category: "cores", slot: "core", cost: 1100, rank: "B", skill: "Lunar Beam", cd: 3800, dmg: 85, acc: 6, description: "B-Rank: Moon beam +Accuracy" },
          
          // ========== CORE PACK (1 item) ==========
          { id: "core_starter_pack", name: "Core Starter Pack", icon: "ğŸ“¦", category: "misc", cost: 400, rank: "C", description: "3 random E-D cores" },
          
          // ========== SUPERNATURAL & ESSENCE (7 items) ==========
          { id: "essence_small", name: "Small Essence Vial", icon: "âœ¨", category: "supernatural", cost: 200, rank: "C", essenceAmount: 5, description: "5 essence" },
          { id: "essence_medium", name: "Medium Essence Flask", icon: "ğŸŒŸ", category: "supernatural", cost: 500, rank: "B", essenceAmount: 15, description: "15 essence" },
          { id: "essence_large", name: "Large Essence Crystal", icon: "ğŸ’", category: "supernatural", cost: 1200, rank: "A", essenceAmount: 40, description: "40 essence" },
          { id: "essence_pack_premium", name: "Essence Pack Premium", icon: "ğŸŒ ", category: "supernatural", cost: 2500, rank: "S", essenceAmount: 100, bonusSpirit: true, description: "100 essence + spirit!" },
          { id: "spirit_summon_scroll", name: "Spirit Summon", icon: "ğŸ“¿", category: "supernatural", cost: 50, rank: "B", currency: "essence", description: "Summon random spirit" },
          { id: "ability_unlock_token", name: "Ability Token", icon: "ğŸ«", category: "supernatural", cost: 80, rank: "A", currency: "essence", description: "Unlock supernatural ability" },
          { id: "spirit_evolution_catalyst", name: "Evolution Catalyst", icon: "âš—ï¸", category: "supernatural", cost: 150, rank: "S", currency: "essence", description: "Boost spirit traits +1" }
        ],
        quests: {
          story: [
            { id: "quest_001", title: "The Beginning", description: "Complete your first adventure", objectives: [{ type: "survive_wave", count: 1, progress: 0, desc: "Survive the first wave" }], rewards: { gold: 1000, xp: 100 }, completed: false },
            { id: "quest_002", title: "Gathering Strength", description: "Defeat 10 enemies and collect resources", objectives: [{ type: "kill", count: 10, progress: 0, desc: "Defeat 10 enemies" }, { type: "collect", count: 5, progress: 0, desc: "Collect 5 resources" }], rewards: { gold: 2000, xp: 250 }, completed: false },
            { id: "quest_003", title: "Boss Challenge", description: "Defeat your first boss", objectives: [{ type: "defeat_boss", count: 1, progress: 0, desc: "Defeat the Desert Guardian" }], rewards: { gold: 5000, xp: 1000 }, completed: false }
          ],
          daily: [
            { id: "daily_gold", name: "Gold Earner", icon: "ğŸ’°", description: "Earn 10,000 gold", required: 10000, progress: 0, reward: { gold: 3000, xp: 500 } },
            { id: "daily_kills", name: "Monster Hunter", icon: "âš”ï¸", description: "Defeat 50 enemies", required: 50, progress: 0, reward: { gold: 2000, xp: 300 } },
            { id: "daily_quests", name: "Quest Master", icon: "ğŸ“œ", description: "Complete 3 quests", required: 3, progress: 0, reward: { gold: 5000, xp: 1000 } }
          ],
          weekly: [
            { id: "weekly_gold", name: "Wealthy Adventurer", icon: "ğŸ’", description: "Earn 100,000 gold", required: 100000, progress: 0, reward: { gold: 20000, xp: 5000 } },
            { id: "weekly_bosses", name: "Boss Slayer", icon: "ğŸ‘¹", description: "Defeat 5 bosses", required: 5, progress: 0, reward: { gold: 15000, xp: 8000 } }
          ]
        },
        settings: {
          audio: { masterVolume: 0.7, sfxVolume: 0.8, musicVolume: 0.6, audioEnabled: true },
          graphics: { quality: "high", shadows: true, particles: true, antialiasing: true, cameraShake: true, fpsLimit: 60 },
          gameplay: { difficulty: "normal", autoSave: true, showTutorial: true, showDamageNumbers: true, autoPickup: true },
          controls: { invertY: false, mouseSensitivity: 1.0 },
          ui: { showFPS: false, showMinimap: true, hudScale: 1.0, uiTheme: "dark", showTooltips: true }
        }
      },
      characterSprites: {
        A1: { currentStyle: 'type-1-hd-pixel-art', currentAnimation: 'idle', animationSpeed: 1 },
        Missy: { currentStyle: 'type-1-hd-pixel-art', currentAnimation: 'idle', animationSpeed: 1 },
        Unique: { currentStyle: 'type-1-hd-pixel-art', currentAnimation: 'idle', animationSpeed: 1 }
      },
      mapProgress: {
        discovered: ['Town', 'Forest'],
        lastPosition: { zone: 'Town', x: 0, y: 0 },
        fogOfWar: {}
      },
      currentStats: {
        hp: 100,
        attack: 10,
        defense: 5,
        critChance: 0,
        critDamage: 0
      },
      shop: {
        inventory: [
          // Equipment - Weapons
          { id: "shop_sword_epic", name: "Dragon Blade", icon: "ğŸ‰", category: "weapon", slot: "weapon", attack: 80, rarity: "epic", basePrice: 5000 },
          
          // Equipment - Armor
          { id: "shop_armor_epic", name: "Titan Plate", icon: "ğŸ›¡ï¸", category: "armor", slot: "chest", defense: 60, hp: 100, rarity: "epic", basePrice: 4500 },
          { id: "shop_helmet_rare", name: "Knight's Helm", icon: "â›‘ï¸", category: "armor", slot: "head", defense: 30, hp: 40, rarity: "rare", basePrice: 2000 },
          { id: "shop_gloves_rare", name: "Dragon Fists", icon: "ğŸ§¤", category: "armor", slot: "gloves", attack: 15, defense: 20, rarity: "rare", basePrice: 1800 },
          { id: "shop_boots_uncommon", name: "Swift Boots", icon: "ğŸ‘¢", category: "armor", slot: "boots", defense: 15, rarity: "uncommon", basePrice: 800 },
          
          // Equipment - Accessories
          { id: "shop_ring_legendary", name: "Phoenix Ring", icon: "ğŸ’", category: "accessory", slot: "ring", attack: 30, hp: 120, rarity: "legendary", basePrice: 15000 },
          { id: "shop_necklace_epic", name: "Wisdom Amulet", icon: "ğŸ“¿", category: "accessory", slot: "necklace", hp: 100, defense: 20, rarity: "epic", basePrice: 4000 },
          
          // Consumables
          { id: "shop_potion_hp", name: "Mega Health Potion", icon: "ğŸ§ª", category: "consumable", quantity: 1, rarity: "rare", basePrice: 500 },
          { id: "shop_potion_mp", name: "Mega Mana Potion", icon: "ğŸ’™", category: "consumable", quantity: 1, rarity: "rare", basePrice: 500 },
          { id: "shop_chest_gold", name: "Golden Chest", icon: "ğŸ’", category: "container", quantity: 1, rarity: "epic", basePrice: 3000 }
        ],
        priceFluctuation: 1.0,
        lastUpdate: Date.now(),
        transactionHistory: []
      },
      aiMacros: {
        recording: false,
        currentRecording: [],
        saved: {}
      },
      aiAliases: {
        'gd': ['gear', 'auto equip'],
        'farm': ['open all', 'auto sell', 'auto fuse'],
        'prep': ['auto equip', 'auto upgrade'],
        'shop best': ['shop', 'ai recommend']
      },
      aiScheduler: {
        tasks: [],
        intervals: {}
      },
      aiLearning: {
        behaviorPatterns: [],
        preferences: {},
        suggestions: []
      },
      textToSpeech: {
        enabled: false,
        rate: 1.0,
        pitch: 1.0,
        volume: 0.8,
        selectedVoice: null,
        narrateEvents: {
          equip: true,
          levelup: true,
          purchase: true,
          achievement: false
        }
      },
      undoStack: [],
      redoStack: [],
      maxInventorySize: 100,
      autoSellJunk: false,
      errorLog: [],
      achievements: [], // Achievement tracking
      saveSlots: {
        auto: null,
        manual1: null,
        manual2: null,
        manual3: null
      },
      lastAutoSave: Date.now(),
      talents: {
        points: 10,
        allocated: [],
        tree: [
          // Combat Tree
          { id: "combat_1", name: "Power Strike", icon: "âš”ï¸", category: "combat", effect: "ATK +5", value: 5, maxLevel: 5, currentLevel: 0, x: 100, y: 50, prereq: null },
          { id: "combat_2", name: "Critical Hit", icon: "ğŸ’¥", category: "combat", effect: "Crit +10%", value: 10, maxLevel: 3, currentLevel: 0, x: 100, y: 120, prereq: "combat_1" },
          { id: "combat_3", name: "Attack Speed", icon: "âš¡", category: "combat", effect: "Speed +15%", value: 15, maxLevel: 3, currentLevel: 0, x: 100, y: 190, prereq: "combat_2" },
          { id: "combat_4", name: "Berserker", icon: "ğŸ˜¤", category: "combat", effect: "ATK +20%", value: 20, maxLevel: 1, currentLevel: 0, x: 100, y: 260, prereq: "combat_3" },
          { id: "combat_5", name: "Weapon Master", icon: "ğŸ—¡ï¸", category: "combat", effect: "All Damage +25%", value: 25, maxLevel: 1, currentLevel: 0, x: 100, y: 330, prereq: "combat_4" },
          
          // Defense Tree
          { id: "defense_1", name: "Iron Skin", icon: "ğŸ›¡ï¸", category: "defense", effect: "DEF +5", value: 5, maxLevel: 5, currentLevel: 0, x: 250, y: 50, prereq: null },
          { id: "defense_2", name: "Vitality", icon: "â¤ï¸", category: "defense", effect: "HP +50", value: 50, maxLevel: 5, currentLevel: 0, x: 250, y: 120, prereq: "defense_1" },
          { id: "defense_3", name: "Regeneration", icon: "ğŸ’š", category: "defense", effect: "HP Regen +5/s", value: 5, maxLevel: 3, currentLevel: 0, x: 250, y: 190, prereq: "defense_2" },
          { id: "defense_4", name: "Last Stand", icon: "âš”ï¸ğŸ›¡ï¸", category: "defense", effect: "Survive 1 hit at 1 HP", value: 1, maxLevel: 1, currentLevel: 0, x: 250, y: 260, prereq: "defense_3" },
          { id: "defense_5", name: "Immortal", icon: "ğŸ‘‘", category: "defense", effect: "DEF +30%, HP +100", value: 30, maxLevel: 1, currentLevel: 0, x: 250, y: 330, prereq: "defense_4" },
          
          // Economy Tree
          { id: "economy_1", name: "Gold Find", icon: "ğŸ’°", category: "economy", effect: "Gold +20%", value: 20, maxLevel: 5, currentLevel: 0, x: 400, y: 50, prereq: null },
          { id: "economy_2", name: "Merchant", icon: "ğŸª", category: "economy", effect: "Shop -15%", value: 15, maxLevel: 3, currentLevel: 0, x: 400, y: 120, prereq: "economy_1" },
          { id: "economy_3", name: "Treasure Hunter", icon: "ğŸ’", category: "economy", effect: "Rare Drop +25%", value: 25, maxLevel: 3, currentLevel: 0, x: 400, y: 190, prereq: "economy_2" },
          { id: "economy_4", name: "Midas Touch", icon: "âœ¨", category: "economy", effect: "All Gold +50%", value: 50, maxLevel: 1, currentLevel: 0, x: 400, y: 260, prereq: "economy_3" },
          
          // Utility Tree
          { id: "utility_1", name: "Quick Hands", icon: "ğŸ‘", category: "utility", effect: "Cooldown -10%", value: 10, maxLevel: 5, currentLevel: 0, x: 550, y: 50, prereq: null },
          { id: "utility_2", name: "XP Boost", icon: "ğŸ“ˆ", category: "utility", effect: "XP +30%", value: 30, maxLevel: 5, currentLevel: 0, x: 550, y: 120, prereq: "utility_1" },
          { id: "utility_3", name: "Bag Space", icon: "ğŸ’", category: "utility", effect: "Inventory +20", value: 20, maxLevel: 3, currentLevel: 0, x: 550, y: 190, prereq: "utility_2" },
          { id: "utility_4", name: "Lucky", icon: "ğŸ€", category: "utility", effect: "Luck +25%", value: 25, maxLevel: 1, currentLevel: 0, x: 550, y: 260, prereq: "utility_3" }
        ],
        synergies: [
          { talents: ["combat_5", "defense_5"], name: "Unbreakable Warrior", bonus: "ATK +50, DEF +50" },
          { talents: ["economy_4", "utility_4"], name: "Fortune's Favor", bonus: "Gold +100%, Luck +50%" }
        ]
      },
      bagOpen: false
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Data definitions - All available items
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Define all available pets (50 total - Common to Legendary)
    const AVAILABLE_PETS = [
      // COMMON PETS (15)
      { id: 'pet_dog', name: 'Golden Retriever', icon: 'ğŸ•', type: 'pet', rarity: 'common', cost: 100, basePrice: 100, attack: 5, defense: 3, hp: 20, speed: 15, abilities: ['Loyal Guard', 'Fetch'], description: 'Loyal companion that boosts morale', lore: 'A friendly dog that never leaves your side', levelReq: 1, tags: ['beast', 'loyal', 'common'], foodPreference: 'meat', loyaltyReq: 20 },
      { id: 'pet_cat', name: 'Black Cat', icon: 'ğŸˆ', type: 'pet', rarity: 'common', cost: 100, basePrice: 100, attack: 3, defense: 2, hp: 15, speed: 20, abilities: ['Stealth', 'Night Vision'], description: 'Nimble feline with keen senses', lore: 'Mysterious cat that brings luck', levelReq: 1, tags: ['beast', 'agile', 'lucky'], foodPreference: 'fish', loyaltyReq: 30 },
      { id: 'pet_rabbit', name: 'Lucky Rabbit', icon: 'ğŸ°', type: 'pet', rarity: 'common', cost: 100, basePrice: 100, attack: 2, defense: 2, hp: 12, speed: 25, abilities: ['Lucky Charm', 'Quick Dodge'], description: 'Brings good fortune', lore: 'A fortunate rabbit with a lucky foot', levelReq: 1, tags: ['beast', 'lucky', 'fast'], foodPreference: 'vegetables', loyaltyReq: 15 },
      { id: 'pet_hamster', name: 'Tiny Hamster', icon: 'ğŸ¹', type: 'pet', rarity: 'common', cost: 80, basePrice: 80, attack: 1, defense: 1, hp: 10, speed: 10, abilities: ['Cute Appeal', 'Hoard'], description: 'Small but adorable', lore: 'Stores extra items in its cheeks', levelReq: 1, tags: ['beast', 'cute', 'utility'], foodPreference: 'seeds', loyaltyReq: 10 },
      { id: 'pet_bird', name: 'Songbird', icon: 'ğŸ¦', type: 'pet', rarity: 'common', cost: 100, basePrice: 100, attack: 3, defense: 1, hp: 10, speed: 30, abilities: ['Scout', 'Aerial View'], description: 'Swift scout from above', lore: 'Sings beautiful melodies', levelReq: 1, tags: ['avian', 'scout', 'fast'], foodPreference: 'seeds', loyaltyReq: 15 },
      { id: 'pet_mouse', name: 'Field Mouse', icon: 'ğŸ­', type: 'pet', rarity: 'common', cost: 60, basePrice: 60, attack: 1, defense: 1, hp: 8, speed: 18, abilities: ['Sneak', 'Nibble'], description: 'Tiny treasure finder', lore: 'Expert at finding hidden items', levelReq: 1, tags: ['beast', 'small', 'finder'], foodPreference: 'cheese', loyaltyReq: 10 },
      { id: 'pet_turtle', name: 'Sea Turtle', icon: 'ğŸ¢', type: 'pet', rarity: 'common', cost: 120, basePrice: 120, attack: 2, defense: 8, hp: 40, speed: 5, abilities: ['Shell Defense', 'Swim'], description: 'Slow but sturdy defender', lore: 'Ancient turtle with tough shell', levelReq: 1, tags: ['aquatic', 'tank', 'defensive'], foodPreference: 'fish', loyaltyReq: 25 },
      { id: 'pet_frog', name: 'Poison Frog', icon: 'ğŸ¸', type: 'pet', rarity: 'common', cost: 90, basePrice: 90, attack: 4, defense: 2, hp: 15, speed: 12, abilities: ['Poison Touch', 'Leap'], description: 'Toxic little hopper', lore: 'Secretes mild toxins', levelReq: 1, tags: ['amphibian', 'poison', 'jumper'], foodPreference: 'insects', loyaltyReq: 20 },
      { id: 'pet_pig', name: 'Piglet', icon: 'ğŸ·', type: 'pet', rarity: 'common', cost: 80, basePrice: 80, attack: 2, defense: 3, hp: 25, speed: 8, abilities: ['Truffle Hunt', 'Ram'], description: 'Finds rare items underground', lore: 'Sniffs out valuable truffles', levelReq: 1, tags: ['beast', 'finder', 'sturdy'], foodPreference: 'anything', loyaltyReq: 15 },
      { id: 'pet_cow', name: 'Milk Cow', icon: 'ğŸ„', type: 'pet', rarity: 'common', cost: 150, basePrice: 150, attack: 1, defense: 5, hp: 50, speed: 5, abilities: ['Milk Production', 'Charge'], description: 'Produces healing milk', lore: 'Gentle farm animal', levelReq: 1, tags: ['beast', 'support', 'producer'], foodPreference: 'grass', loyaltyReq: 20 },
      { id: 'pet_chicken', name: 'Hen', icon: 'ğŸ”', type: 'pet', rarity: 'common', cost: 70, basePrice: 70, attack: 1, defense: 1, hp: 12, speed: 10, abilities: ['Lay Eggs', 'Peck'], description: 'Lays golden eggs occasionally', lore: 'Simple farm hen', levelReq: 1, tags: ['avian', 'producer', 'common'], foodPreference: 'seeds', loyaltyReq: 10 },
      { id: 'pet_sheep', name: 'Wool Sheep', icon: 'ğŸ‘', type: 'pet', rarity: 'common', cost: 100, basePrice: 100, attack: 1, defense: 4, hp: 30, speed: 7, abilities: ['Wool Production', 'Headbutt'], description: 'Provides warm wool', lore: 'Fluffy and friendly', levelReq: 1, tags: ['beast', 'producer', 'defensive'], foodPreference: 'grass', loyaltyReq: 15 },
      { id: 'pet_monkey', name: 'Capuchin', icon: 'ğŸ’', type: 'pet', rarity: 'common', cost: 120, basePrice: 120, attack: 4, defense: 2, hp: 18, speed: 22, abilities: ['Steal Item', 'Climb'], description: 'Mischievous item stealer', lore: 'Playful and clever', levelReq: 1, tags: ['beast', 'agile', 'thief'], foodPreference: 'fruit', loyaltyReq: 25 },
      { id: 'pet_penguin', name: 'Emperor Penguin', icon: 'ğŸ§', type: 'pet', rarity: 'common', cost: 110, basePrice: 110, attack: 3, defense: 4, hp: 22, speed: 8, abilities: ['Slide', 'Ice Resistance'], description: 'Cold-resistant companion', lore: 'From frozen lands', levelReq: 1, tags: ['avian', 'ice', 'resistant'], foodPreference: 'fish', loyaltyReq: 20 },
      { id: 'pet_owl', name: 'Barn Owl', icon: 'ğŸ¦‰', type: 'pet', rarity: 'common', cost: 130, basePrice: 130, attack: 5, defense: 2, hp: 16, speed: 25, abilities: ['Night Hunter', 'Silent Flight'], description: 'Wise nocturnal hunter', lore: 'Symbol of wisdom', levelReq: 1, tags: ['avian', 'wise', 'nocturnal'], foodPreference: 'mice', loyaltyReq: 30 },
      
      // UNCOMMON PETS (15)
      { id: 'pet_wolf', name: 'Grey Wolf', icon: 'ğŸº', type: 'pet', rarity: 'uncommon', cost: 500, basePrice: 500, attack: 15, defense: 8, hp: 60, speed: 35, abilities: ['Pack Leader', 'Howl', 'Bite'], description: 'Fierce pack leader', lore: 'Commands respect from other beasts', levelReq: 10, tags: ['beast', 'pack', 'damage'], foodPreference: 'meat', loyaltyReq: 40 },
      { id: 'pet_fox', name: 'Arctic Fox', icon: 'ğŸ¦Š', type: 'pet', rarity: 'uncommon', cost: 450, basePrice: 450, attack: 12, defense: 6, hp: 45, speed: 38, abilities: ['Cunning', 'Ice Walk'], description: 'Clever and quick', lore: 'Outwits enemies with tricks', levelReq: 10, tags: ['beast', 'cunning', 'ice'], foodPreference: 'meat', loyaltyReq: 35 },
      { id: 'pet_bear', name: 'Brown Bear', icon: 'ğŸ»', type: 'pet', rarity: 'uncommon', cost: 600, basePrice: 600, attack: 20, defense: 12, hp: 100, speed: 18, abilities: ['Maul', 'Roar', 'Bear Hug'], description: 'Powerful forest guardian', lore: 'Protects with fierce strength', levelReq: 15, tags: ['beast', 'tank', 'strong'], foodPreference: 'fish', loyaltyReq: 50 },
      { id: 'pet_eagle', name: 'Golden Eagle', icon: 'ğŸ¦…', type: 'pet', rarity: 'uncommon', cost: 480, basePrice: 480, attack: 18, defense: 5, hp: 40, speed: 50, abilities: ['Dive Bomb', 'Keen Eyes'], description: 'Majestic aerial predator', lore: 'Rules the skies', levelReq: 12, tags: ['avian', 'predator', 'vision'], foodPreference: 'meat', loyaltyReq: 45 },
      { id: 'pet_panther', name: 'Black Panther', icon: 'ğŸˆâ€â¬›', type: 'pet', rarity: 'uncommon', cost: 520, basePrice: 520, attack: 22, defense: 8, hp: 55, speed: 42, abilities: ['Shadow Strike', 'Stealth', 'Pounce'], description: 'Stealthy jungle hunter', lore: 'Strikes from shadows', levelReq: 14, tags: ['beast', 'stealth', 'crit'], foodPreference: 'meat', loyaltyReq: 48 },
      { id: 'pet_panda', name: 'Red Panda', icon: 'ğŸ¼', type: 'pet', rarity: 'uncommon', cost: 420, basePrice: 420, attack: 10, defense: 10, hp: 70, speed: 20, abilities: ['Balanced Strike', 'Calm Mind'], description: 'Peaceful warrior', lore: 'Finds balance in combat', levelReq: 10, tags: ['beast', 'balanced', 'calm'], foodPreference: 'bamboo', loyaltyReq: 40 },
      { id: 'pet_koala', name: 'Koala', icon: 'ğŸ¨', type: 'pet', rarity: 'uncommon', cost: 380, basePrice: 380, attack: 6, defense: 8, hp: 65, speed: 12, abilities: ['Sleep Heal', 'Tree Climb'], description: 'Sleepy healer', lore: 'Heals while resting', levelReq: 8, tags: ['beast', 'healer', 'peaceful'], foodPreference: 'eucalyptus', loyaltyReq: 30 },
      { id: 'pet_tiger', name: 'Bengal Tiger', icon: 'ğŸ…', type: 'pet', rarity: 'uncommon', cost: 650, basePrice: 650, attack: 25, defense: 10, hp: 75, speed: 40, abilities: ['Savage Pounce', 'Roar', 'Claw Strike'], description: 'Apex jungle predator', lore: 'King of the jungle', levelReq: 18, tags: ['beast', 'predator', 'fierce'], foodPreference: 'meat', loyaltyReq: 55 },
      { id: 'pet_lion', name: 'Lion', icon: 'ğŸ¦', type: 'pet', rarity: 'uncommon', cost: 700, basePrice: 700, attack: 28, defense: 12, hp: 85, speed: 35, abilities: ['Pride Leader', 'Mighty Roar', 'King\'s Bite'], description: 'King of beasts', lore: 'Commands all land animals', levelReq: 20, tags: ['beast', 'king', 'leader'], foodPreference: 'meat', loyaltyReq: 60 },
      { id: 'pet_elephant', name: 'Baby Elephant', icon: 'ğŸ˜', type: 'pet', rarity: 'uncommon', cost: 550, basePrice: 550, attack: 15, defense: 18, hp: 120, speed: 15, abilities: ['Trumpet', 'Stomp', 'Charge'], description: 'Gentle giant', lore: 'Never forgets a friend', levelReq: 15, tags: ['beast', 'tank', 'support'], foodPreference: 'plants', loyaltyReq: 45 },
      { id: 'pet_gorilla', name: 'Silverback Gorilla', icon: 'ğŸ¦', type: 'pet', rarity: 'uncommon', cost: 620, basePrice: 620, attack: 24, defense: 16, hp: 110, speed: 22, abilities: ['Pound', 'Intimidate', 'Throw'], description: 'Mighty jungle lord', lore: 'Powerful and wise leader', levelReq: 17, tags: ['beast', 'strong', 'wise'], foodPreference: 'fruit', loyaltyReq: 50 },
      { id: 'pet_rhino', name: 'Rhino', icon: 'ğŸ¦', type: 'pet', rarity: 'uncommon', cost: 680, basePrice: 680, attack: 22, defense: 25, hp: 140, speed: 18, abilities: ['Ram Charge', 'Thick Skin', 'Gore'], description: 'Armored charger', lore: 'Unstoppable force', levelReq: 19, tags: ['beast', 'armor', 'charge'], foodPreference: 'grass', loyaltyReq: 55 },
      { id: 'pet_falcon', name: 'Peregrine Falcon', icon: 'ğŸ¦…', type: 'pet', rarity: 'uncommon', cost: 520, basePrice: 520, attack: 20, defense: 4, hp: 35, speed: 60, abilities: ['Speed Dive', 'Precision Strike'], description: 'Fastest flyer', lore: 'Breaks sound barrier', levelReq: 13, tags: ['avian', 'speed', 'precision'], foodPreference: 'meat', loyaltyReq: 42 },
      { id: 'pet_snake', name: 'Python', icon: 'ğŸ', type: 'pet', rarity: 'uncommon', cost: 480, basePrice: 480, attack: 16, defense: 6, hp: 50, speed: 25, abilities: ['Constrict', 'Venom Bite', 'Slither'], description: 'Deadly constrictor', lore: 'Silent and lethal', levelReq: 12, tags: ['reptile', 'poison', 'control'], foodPreference: 'mice', loyaltyReq: 40 },
      { id: 'pet_bat', name: 'Vampire Bat', icon: 'ğŸ¦‡', type: 'pet', rarity: 'uncommon', cost: 440, basePrice: 440, attack: 14, defense: 5, hp: 38, speed: 45, abilities: ['Life Drain', 'Echolocation', 'Night Swoop'], description: 'Nocturnal blood drinker', lore: 'Drains life from enemies', levelReq: 11, tags: ['avian', 'lifesteal', 'nocturnal'], foodPreference: 'blood', loyaltyReq: 38 },
      
      // RARE PETS (10)
      { id: 'pet_dragon_wyrmling', name: 'Dragon Wyrmling', icon: 'ğŸ‰', type: 'pet', rarity: 'rare', cost: 2500, basePrice: 2500, attack: 45, defense: 20, hp: 180, speed: 40, abilities: ['Flame Breath', 'Dragon Fear', 'Wing Buffet', 'Tail Swipe'], description: 'Baby dragon with immense potential', lore: 'Will grow into a legendary beast', levelReq: 30, tags: ['dragon', 'magic', 'powerful'], foodPreference: 'gold', loyaltyReq: 80 },
      { id: 'pet_phoenix_chick', name: 'Phoenix Chick', icon: 'ğŸ”¥ğŸ¦', type: 'pet', rarity: 'rare', cost: 2200, basePrice: 2200, attack: 38, defense: 15, hp: 120, speed: 55, abilities: ['Rebirth', 'Fire Aura', 'Healing Flames'], description: 'Reborn from ashes', lore: 'Cannot truly die', levelReq: 28, tags: ['avian', 'fire', 'immortal'], foodPreference: 'fire', loyaltyReq: 75 },
      { id: 'pet_unicorn', name: 'Unicorn', icon: 'ğŸ¦„', type: 'pet', rarity: 'rare', cost: 2800, basePrice: 2800, attack: 35, defense: 25, hp: 150, speed: 50, abilities: ['Holy Light', 'Purify', 'Horn Strike'], description: 'Pure and magical', lore: 'Symbol of purity', levelReq: 32, tags: ['magical', 'holy', 'pure'], foodPreference: 'flowers', loyaltyReq: 85 },
      { id: 'pet_griffin', name: 'Griffin', icon: 'ğŸ¦…ğŸ¦', type: 'pet', rarity: 'rare', cost: 2600, basePrice: 2600, attack: 42, defense: 22, hp: 160, speed: 48, abilities: ['Aerial Strike', 'Noble Roar', 'Talon Rip'], description: 'Half eagle, half lion', lore: 'Guardian of treasures', levelReq: 30, tags: ['hybrid', 'flying', 'guardian'], foodPreference: 'meat', loyaltyReq: 78 },
      { id: 'pet_cerberus_pup', name: 'Cerberus Pup', icon: 'ğŸ•ğŸ•ğŸ•', type: 'pet', rarity: 'rare', cost: 2400, basePrice: 2400, attack: 40, defense: 18, hp: 170, speed: 35, abilities: ['Triple Bite', 'Hell Fire', 'Intimidating Howl'], description: 'Three-headed guardian pup', lore: 'Guards the underworld gates', levelReq: 29, tags: ['mythical', 'fire', 'guardian'], foodPreference: 'souls', loyaltyReq: 82 },
      { id: 'pet_white_tiger', name: 'White Tiger Spirit', icon: 'ğŸ…âœ¨', type: 'pet', rarity: 'rare', cost: 2700, basePrice: 2700, attack: 48, defense: 20, hp: 140, speed: 52, abilities: ['Spirit Claw', 'Phantom Dash', 'Frost Bite'], description: 'Mystical white tiger', lore: 'Spirit of the east', levelReq: 31, tags: ['spirit', 'ice', 'mystical'], foodPreference: 'essence', loyaltyReq: 80 },
      { id: 'pet_hydra_spawn', name: 'Hydra Spawn', icon: 'ğŸğŸ', type: 'pet', rarity: 'rare', cost: 2500, basePrice: 2500, attack: 43, defense: 23, hp: 200, speed: 28, abilities: ['Multi-Bite', 'Regenerate Heads', 'Poison Spray'], description: 'Multi-headed serpent', lore: 'Grows stronger when hurt', levelReq: 30, tags: ['reptile', 'regen', 'poison'], foodPreference: 'meat', loyaltyReq: 76 },
      { id: 'pet_dire_wolf', name: 'Dire Wolf Alpha', icon: 'ğŸºğŸ‘‘', type: 'pet', rarity: 'rare', cost: 2300, basePrice: 2300, attack: 50, defense: 24, hp: 165, speed: 45, abilities: ['Pack Tactics', 'Alpha Command', 'Savage Maul'], description: 'Legendary wolf leader', lore: 'Commands entire wolf packs', levelReq: 28, tags: ['beast', 'leader', 'pack'], foodPreference: 'meat', loyaltyReq: 74 },
      { id: 'pet_thunderbird', name: 'Thunderbird', icon: 'âš¡ğŸ¦…', type: 'pet', rarity: 'rare', cost: 2600, basePrice: 2600, attack: 46, defense: 18, hp: 130, speed: 58, abilities: ['Lightning Strike', 'Storm Call', 'Thunder Dive'], description: 'Storm spirit bird', lore: 'Controls thunder and lightning', levelReq: 31, tags: ['avian', 'lightning', 'storm'], foodPreference: 'clouds', loyaltyReq: 77 },
      { id: 'pet_basilisk', name: 'Basilisk', icon: 'ğŸ‘‘ğŸ', type: 'pet', rarity: 'rare', cost: 2400, basePrice: 2400, attack: 44, defense: 21, hp: 155, speed: 32, abilities: ['Petrifying Gaze', 'Deadly Venom', 'Stone Curse'], description: 'King of serpents', lore: 'Its gaze turns enemies to stone', levelReq: 29, tags: ['reptile', 'curse', 'lethal'], foodPreference: 'gems', loyaltyReq: 79 },
      
      // EPIC PETS (5)
      { id: 'pet_dragon_adult', name: 'Adult Dragon', icon: 'ğŸ²', type: 'pet', rarity: 'epic', cost: 8000, basePrice: 8000, attack: 80, defense: 40, hp: 350, speed: 55, abilities: ['Inferno Breath', 'Dragon Rage', 'Fly', 'Devastation', 'Hoard Gold'], description: 'Fully grown dragon of immense power', lore: 'Ancient and wise beyond measure', levelReq: 50, tags: ['dragon', 'devastating', 'hoarder'], foodPreference: 'treasure', loyaltyReq: 100 },
      { id: 'pet_phoenix_adult', name: 'Phoenix', icon: 'ğŸ”¥ğŸ¦…', type: 'pet', rarity: 'epic', cost: 7500, basePrice: 7500, attack: 70, defense: 35, hp: 250, speed: 70, abilities: ['Resurrection', 'Supernova', 'Phoenix Fire', 'Immortal Soul'], description: 'Immortal firebird', lore: 'Dies and is reborn eternally', levelReq: 48, tags: ['avian', 'immortal', 'fire'], foodPreference: 'flame', loyaltyReq: 95 },
      { id: 'pet_kraken_spawn', name: 'Kraken Spawn', icon: 'ğŸ™', type: 'pet', rarity: 'epic', cost: 7800, basePrice: 7800, attack: 75, defense: 45, hp: 380, speed: 35, abilities: ['Tentacle Crush', 'Ink Cloud', 'Tidal Wave', 'Deep Terror'], description: 'Offspring of the legendary sea monster', lore: 'Terror of the deep seas', levelReq: 49, tags: ['aquatic', 'control', 'terror'], foodPreference: 'ships', loyaltyReq: 98 },
      { id: 'pet_celestial_lion', name: 'Celestial Lion', icon: 'ğŸ¦âœ¨', type: 'pet', rarity: 'epic', cost: 8200, basePrice: 8200, attack: 85, defense: 42, hp: 320, speed: 60, abilities: ['Divine Roar', 'Holy Strike', 'Celestial Blessing', 'Star Fall'], description: 'Divine beast from the heavens', lore: 'Blessed by celestial powers', levelReq: 51, tags: ['celestial', 'divine', 'blessing'], foodPreference: 'starlight', loyaltyReq: 102 },
      { id: 'pet_shadow_beast', name: 'Shadow Beast', icon: 'ğŸ‘¤ğŸº', type: 'pet', rarity: 'epic', cost: 7600, basePrice: 7600, attack: 88, defense: 30, hp: 280, speed: 75, abilities: ['Shadow Merge', 'Void Strike', 'Dark Pulse', 'Nightmare'], description: 'Creature born from pure darkness', lore: 'Exists between light and shadow', levelReq: 47, tags: ['shadow', 'void', 'stealth'], foodPreference: 'darkness', loyaltyReq: 93 },
      
      // LEGENDARY PETS (5)
      { id: 'pet_ancient_dragon', name: 'Ancient Dragon God', icon: 'ğŸ‰ğŸ‘‘', type: 'pet', rarity: 'legendary', cost: 25000, basePrice: 25000, attack: 150, defense: 80, hp: 800, speed: 70, abilities: ['Cataclysm', 'Divine Wrath', 'Time Stop', 'Reality Tear', 'Absolute Dominance'], description: 'The oldest and most powerful dragon in existence', lore: 'Witnessed the birth of worlds', levelReq: 80, tags: ['dragon', 'god', 'ultimate'], foodPreference: 'worlds', loyaltyReq: 150 },
      { id: 'pet_leviathan', name: 'Leviathan', icon: 'ğŸ‹ğŸ‘‘', type: 'pet', rarity: 'legendary', cost: 24000, basePrice: 24000, attack: 140, defense: 90, hp: 900, speed: 50, abilities: ['Tsunami', 'Ocean Master', 'Devour', 'Pressure Crush', 'Abyssal Roar'], description: 'Titanic sea serpent that rules all oceans', lore: 'The sea itself trembles at its presence', levelReq: 78, tags: ['aquatic', 'titan', 'legendary'], foodPreference: 'whales', loyaltyReq: 145 },
      { id: 'pet_behemoth', name: 'Behemoth', icon: 'ğŸ¦£ğŸ‘‘', type: 'pet', rarity: 'legendary', cost: 23000, basePrice: 23000, attack: 135, defense: 100, hp: 1000, speed: 40, abilities: ['Earth Shatter', 'Mountain Crush', 'Unstoppable', 'Colossus Strike', 'Titan Form'], description: 'Colossal land beast of unmatched might', lore: 'Mountains crumble in its wake', levelReq: 76, tags: ['beast', 'titan', 'unstoppable'], foodPreference: 'mountains', loyaltyReq: 140 },
      { id: 'pet_pegasus_lord', name: 'Pegasus Lord', icon: 'ğŸ¦„ğŸ¦…', type: 'pet', rarity: 'legendary', cost: 22000, basePrice: 22000, attack: 130, defense: 70, hp: 650, speed: 100, abilities: ['Divine Flight', 'Star Dash', 'Heaven\'s Grace', 'Cosmic Wings', 'Blessing of the Sky'], description: 'Ruler of all winged beings', lore: 'Soars through dimensions', levelReq: 75, tags: ['celestial', 'flying', 'divine'], foodPreference: 'nebula', loyaltyReq: 138 },
      { id: 'pet_world_serpent', name: 'JÃ¶rmungandr', icon: 'ğŸğŸŒ', type: 'pet', rarity: 'legendary', cost: 26000, basePrice: 26000, attack: 145, defense: 85, hp: 850, speed: 45, abilities: ['World Coil', 'Ragnarok', 'Venom Ocean', 'Ouroboros', 'End Times'], description: 'Serpent large enough to circle the world', lore: 'When it releases its tail, the world ends', levelReq: 82, tags: ['reptile', 'apocalypse', 'world-ender'], foodPreference: 'worlds', loyaltyReq: 155 }
    ];
    window.A1K_AVAILABLE_PETS = AVAILABLE_PETS;
    
    /**
     * Calculates a simple aggregate power score for any companion entry,
     * prioritising primary combat stats and falling back to utility metrics.
     * This keeps the rarity rebalance grounded in gameplay impact instead
     * of alphabetical ordering.
     */
    const rarityWeight = {
      common: 1,
      uncommon: 2,
      rare: 3,
      epic: 5,
      legendary: 8,
    };
    
    const getCompanionPowerScore = (entry = {}) => {
      const weightedKeys = [
        ['attack', 3],
        ['atk', 3],
        ['power', 3],
        ['defense', 2],
        ['def', 2],
        ['hp', 2],
        ['durability', 2],
        ['energy', 1],
        ['mana', 1],
        ['speed', 1],
        ['agility', 1]
      ];
      let score = 0;
      weightedKeys.forEach(([key, weight]) => {
        const value = typeof entry[key] === 'number' ? entry[key] : 0;
        score += value * weight;
      });
      return score;
    };
    
    const getCorePowerScore = (core = {}) => {
      if (!core) return 0;
      const rarityBonus = rarityWeight[(core.rarity || 'common').toLowerCase()] * 500;
      const statKeys = ['attack', 'defense', 'hp', 'mp', 'speed', 'critRate', 'critDamage', 'armorPen', 'lifesteal'];
      let statScore = 0;
      statKeys.forEach(key => {
        const value = typeof core[key] === 'number' ? core[key] : 0;
        statScore += value * 25;
      });
      const passiveScore = Array.isArray(core.passiveEffects) ? core.passiveEffects.length * 200 : 0;
      const skillDamage = core.weaponSkill?.damage || core.weaponSkill?.power || 0;
      const skillScore = skillDamage * 8;
      return rarityBonus + statScore + passiveScore + skillScore;
    };
    
    /**
     * Evenly redistributes rarities across a companion collection so each tier
     * is represented. We avoid cloning or renaming items to respect the user's
     * catalogue, and instead re-rank by power to ensure higher tiers feel earned.
     */
    const rebalanceCompanionRarities = (collection) => {
      if (!Array.isArray(collection) || collection.length === 0) return;
      const tiers = ['common', 'uncommon', 'rare', 'epic', 'legendary'];
      const total = collection.length;
      const basePerTier = Math.floor(total / tiers.length);
      const remainder = total % tiers.length;
      const targetCounts = tiers.map((_, index) => basePerTier + (index < remainder ? 1 : 0));
      
      const sorted = [...collection].sort((a, b) => getCompanionPowerScore(a) - getCompanionPowerScore(b));
      
      let cursor = 0;
      tiers.forEach((tier, index) => {
        const count = targetCounts[index];
        for (let i = 0; i < count && cursor < sorted.length; i += 1, cursor += 1) {
          sorted[cursor].rarity = tier;
        }
      });
    };
    
    // Harmonise rarities across the pet roster before exporting.
    rebalanceCompanionRarities(AVAILABLE_PETS);
    
    // Define all available spirits (30 total - Common to Legendary)
    const AVAILABLE_SPIRITS = [
      // COMMON SPIRITS (10) - 1 Effect Each
      { id: 'spirit_fire', name: 'Fire Spirit', icon: 'ğŸ”¥', type: 'spirit', rarity: 'common', cost: 120, basePrice: 120, attack: 8, defense: 2, hp: 15, mana: 50, speed: 12, 
        effects: [{ name: 'Burn', desc: 'Attacks deal 5% burn damage over 3s', value: 5 }],
        abilities: ['Fire Bolt'], description: 'Burning with passion', lore: 'Born from eternal flames', levelReq: 1, tags: ['elemental', 'fire', 'damage'], element: 'fire', summonCost: 50 },
      
      { id: 'spirit_water', name: 'Water Spirit', icon: 'ğŸ’§', type: 'spirit', rarity: 'common', cost: 120, basePrice: 120, attack: 4, defense: 6, hp: 25, mana: 60, speed: 10,
        effects: [{ name: 'Heal', desc: 'Restore 3 HP per second', value: 3 }],
        abilities: ['Water Shield'], description: 'Flows with grace', lore: 'Embodies the ocean', levelReq: 1, tags: ['elemental', 'water', 'healing'], element: 'water', summonCost: 50 },
      
      { id: 'spirit_wind', name: 'Wind Spirit', icon: 'ğŸŒªï¸', type: 'spirit', rarity: 'common', cost: 120, basePrice: 120, attack: 6, defense: 3, hp: 18, mana: 55, speed: 20,
        effects: [{ name: 'Swift', desc: '+15% movement speed', value: 15 }],
        abilities: ['Wind Slash'], description: 'Swift as the breeze', lore: 'Rides the storm', levelReq: 1, tags: ['elemental', 'wind', 'speed'], element: 'wind', summonCost: 50 },
      
      { id: 'spirit_earth', name: 'Earth Spirit', icon: 'ğŸª¨', type: 'spirit', rarity: 'common', cost: 120, basePrice: 120, attack: 3, defense: 8, hp: 30, mana: 45, speed: 8,
        effects: [{ name: 'Stone Skin', desc: '+10% damage reduction', value: 10 }],
        abilities: ['Rock Throw'], description: 'Solid as stone', lore: 'Guardian of mountains', levelReq: 1, tags: ['elemental', 'earth', 'tank'], element: 'earth', summonCost: 50 },
      
      { id: 'spirit_light', name: 'Light Spirit', icon: 'âœ¨', type: 'spirit', rarity: 'common', cost: 120, basePrice: 120, attack: 5, defense: 5, hp: 20, mana: 70, speed: 14,
        effects: [{ name: 'Holy Aura', desc: 'Allies gain +5% defense', value: 5 }],
        abilities: ['Light Beam'], description: 'Radiates hope', lore: 'Blessed by heaven', levelReq: 1, tags: ['holy', 'light', 'support'], element: 'light', summonCost: 50 },
      
      { id: 'spirit_dark', name: 'Dark Spirit', icon: 'ğŸŒ‘', type: 'spirit', rarity: 'common', cost: 130, basePrice: 130, attack: 7, defense: 4, hp: 18, mana: 65, speed: 13,
        effects: [{ name: 'Shadow', desc: '+10% crit chance', value: 10 }],
        abilities: ['Dark Pulse'], description: 'Born from shadows', lore: 'Feeds on darkness', levelReq: 1, tags: ['dark', 'shadow', 'crit'], element: 'dark', summonCost: 55 },
      
      { id: 'spirit_lightning', name: 'Lightning Spirit', icon: 'âš¡', type: 'spirit', rarity: 'common', cost: 125, basePrice: 125, attack: 9, defense: 2, hp: 16, mana: 50, speed: 18,
        effects: [{ name: 'Static', desc: '10% chance to stun on hit', value: 10 }],
        abilities: ['Thunder Strike'], description: 'Crackling with energy', lore: 'Commands the storm', levelReq: 1, tags: ['elemental', 'lightning', 'cc'], element: 'lightning', summonCost: 50 },
      
      { id: 'spirit_ice', name: 'Ice Spirit', icon: 'â„ï¸', type: 'spirit', rarity: 'common', cost: 115, basePrice: 115, attack: 5, defense: 6, hp: 22, mana: 60, speed: 9,
        effects: [{ name: 'Freeze', desc: '15% chance to slow enemies', value: 15 }],
        abilities: ['Ice Shard'], description: 'Frozen and eternal', lore: 'Never melts', levelReq: 1, tags: ['elemental', 'ice', 'cc'], element: 'ice', summonCost: 50 },
      
      { id: 'spirit_nature', name: 'Nature Spirit', icon: 'ğŸŒ¿', type: 'spirit', rarity: 'common', cost: 110, basePrice: 110, attack: 4, defense: 5, hp: 24, mana: 55, speed: 11,
        effects: [{ name: 'Regeneration', desc: 'Heal 2 HP every 5s', value: 2 }],
        abilities: ['Vine Grasp'], description: 'One with the forest', lore: 'Ancient guardian', levelReq: 1, tags: ['nature', 'heal', 'support'], element: 'nature', summonCost: 45 },
      
      { id: 'spirit_poison', name: 'Poison Spirit', icon: 'â˜ ï¸', type: 'spirit', rarity: 'common', cost: 135, basePrice: 135, attack: 8, defense: 3, hp: 17, mana: 50, speed: 12,
        effects: [{ name: 'Toxic', desc: 'Poison enemies for 8 damage over 5s', value: 8 }],
        abilities: ['Poison Cloud'], description: 'Deadly and toxic', lore: 'Breeds in swamps', levelReq: 1, tags: ['poison', 'dot', 'damage'], element: 'poison', summonCost: 55 },

      // UNCOMMON SPIRITS (10) - 2 Effects Each
      { id: 'spirit_inferno', name: 'Inferno Spirit', icon: 'ğŸ”¥ğŸ’¥', type: 'spirit', rarity: 'uncommon', cost: 600, basePrice: 600, attack: 20, defense: 8, hp: 50, mana: 100, speed: 16,
        effects: [
          { name: 'Immolate', desc: 'Enemies within 10m take 10 fire damage/sec', value: 10 },
          { name: 'Burning Soul', desc: '+25% fire damage', value: 25 }
        ],
        abilities: ['Fireball', 'Fire Nova'], description: 'Raging inferno incarnate', lore: 'Leaves ash in its wake', levelReq: 12, tags: ['elemental', 'fire', 'aoe'], element: 'fire', summonCost: 80 },

      { id: 'spirit_tsunami', name: 'Tsunami Spirit', icon: 'ğŸŒŠ', type: 'spirit', rarity: 'uncommon', cost: 580, basePrice: 580, attack: 16, defense: 14, hp: 70, mana: 120, speed: 12,
        effects: [
          { name: 'Tidal Wave', desc: 'Knockback enemies on attack', value: 100 },
          { name: 'Aqua Shield', desc: '+20% damage reduction when below 50% HP', value: 20 }
        ],
        abilities: ['Water Blast', 'Healing Rain'], description: 'Oceanic force', lore: 'Controls the tides', levelReq: 13, tags: ['elemental', 'water', 'control'], element: 'water', summonCost: 75 },

      { id: 'spirit_tempest', name: 'Tempest Spirit', icon: 'ğŸŒªï¸âš¡', type: 'spirit', rarity: 'uncommon', cost: 620, basePrice: 620, attack: 24, defense: 10, hp: 55, mana: 110, speed: 25,
        effects: [
          { name: 'Cyclone', desc: 'Create wind vortex dealing 15 damage/sec', value: 15 },
          { name: 'Evasive Wind', desc: '+18% dodge chance', value: 18 }
        ],
        abilities: ['Tornado', 'Wind Barrier'], description: 'Master of storms', lore: 'Brings hurricanes', levelReq: 14, tags: ['elemental', 'wind', 'speed'], element: 'wind', summonCost: 85 },

      { id: 'spirit_crystal', name: 'Crystal Spirit', icon: 'ğŸ’', type: 'spirit', rarity: 'uncommon', cost: 650, basePrice: 650, attack: 18, defense: 20, hp: 80, mana: 100, speed: 10,
        effects: [
          { name: 'Crystal Armor', desc: 'Reduce all damage by 15', value: 15 },
          { name: 'Reflective', desc: 'Reflect 20% of damage taken', value: 20 }
        ],
        abilities: ['Crystal Spike', 'Shatter'], description: 'Unbreakable crystal form', lore: 'Harder than diamond', levelReq: 15, tags: ['earth', 'tank', 'reflect'], element: 'earth', summonCost: 90 },

      { id: 'spirit_radiant', name: 'Radiant Spirit', icon: 'â˜€ï¸', type: 'spirit', rarity: 'uncommon', cost: 640, basePrice: 640, attack: 22, defense: 12, hp: 60, mana: 140, speed: 18,
        effects: [
          { name: 'Blessing', desc: 'Heal all allies for 5 HP/sec in radius', value: 5 },
          { name: 'Holy Strike', desc: '+30% damage vs undead/dark', value: 30 }
        ],
        abilities: ['Holy Light', 'Divine Blessing'], description: 'Blessed by the sun', lore: 'Banishes darkness', levelReq: 16, tags: ['holy', 'light', 'healing'], element: 'light', summonCost: 85 },

      { id: 'spirit_void', name: 'Void Spirit', icon: 'ğŸ•³ï¸', type: 'spirit', rarity: 'uncommon', cost: 680, basePrice: 680, attack: 26, defense: 8, hp: 50, mana: 130, speed: 20,
        effects: [
          { name: 'Void Rift', desc: 'Attacks ignore 25% defense', value: 25 },
          { name: 'Life Drain', desc: 'Steal 10% of damage as HP', value: 10 }
        ],
        abilities: ['Void Bolt', 'Dark Matter'], description: 'Consumes all light', lore: 'Portal to nothingness', levelReq: 17, tags: ['dark', 'void', 'lifesteal'], element: 'dark', summonCost: 95 },

      { id: 'spirit_thunder', name: 'Thunder Spirit', icon: 'âš¡ğŸ‘‘', type: 'spirit', rarity: 'uncommon', cost: 660, basePrice: 660, attack: 28, defense: 10, hp: 55, mana: 115, speed: 22,
        effects: [
          { name: 'Chain Lightning', desc: 'Attacks bounce to 2 nearby enemies', value: 2 },
          { name: 'Overload', desc: '+20% attack speed', value: 20 }
        ],
        abilities: ['Lightning Bolt', 'Thunder Clap'], description: 'Lord of lightning', lore: 'Strikes twice', levelReq: 16, tags: ['elemental', 'lightning', 'chain'], element: 'lightning', summonCost: 90 },

      { id: 'spirit_glacier', name: 'Glacier Spirit', icon: 'ğŸ§Š', type: 'spirit', rarity: 'uncommon', cost: 630, basePrice: 630, attack: 20, defense: 16, hp: 75, mana: 125, speed: 8,
        effects: [
          { name: 'Permafrost', desc: 'Slow all enemies by 30%', value: 30 },
          { name: 'Ice Armor', desc: '+25% defense', value: 25 }
        ],
        abilities: ['Blizzard', 'Ice Wall'], description: 'Eternal winter', lore: 'Never thaws', levelReq: 15, tags: ['elemental', 'ice', 'slow'], element: 'ice', summonCost: 85 },

      { id: 'spirit_bloom', name: 'Bloom Spirit', icon: 'ğŸŒ¸', type: 'spirit', rarity: 'uncommon', cost: 590, basePrice: 590, attack: 14, defense: 12, hp: 65, mana: 135, speed: 14,
        effects: [
          { name: 'Overgrowth', desc: 'Summon healing flowers (3 HP/sec)', value: 3 },
          { name: 'Thorns', desc: 'Attackers take 15 damage', value: 15 }
        ],
        abilities: ['Petal Storm', 'Garden of Life'], description: 'Eternal spring', lore: 'Life blooms eternally', levelReq: 14, tags: ['nature', 'heal', 'damage'], element: 'nature', summonCost: 80 },

      { id: 'spirit_plague', name: 'Plague Spirit', icon: 'â˜ ï¸ğŸ’€', type: 'spirit', rarity: 'uncommon', cost: 670, basePrice: 670, attack: 25, defense: 9, hp: 52, mana: 110, speed: 15,
        effects: [
          { name: 'Epidemic', desc: 'Poison spreads to nearby enemies', value: 100 },
          { name: 'Toxic Aura', desc: 'Enemies take 8 poison damage/sec', value: 8 }
        ],
        abilities: ['Poison Nova', 'Plague Cloud'], description: 'Spreads disease', lore: 'Carrier of pestilence', levelReq: 16, tags: ['poison', 'aoe', 'dot'], element: 'poison', summonCost: 90 },

      // RARE SPIRITS (5) - 3 Effects Each
      { id: 'spirit_phoenix', name: 'Phoenix Spirit', icon: 'ğŸ”¥ğŸ¦…', type: 'spirit', rarity: 'rare', cost: 2800, basePrice: 2800, attack: 50, defense: 25, hp: 150, mana: 200, speed: 28,
        effects: [
          { name: 'Rebirth', desc: 'Revive with 50% HP on death (30s CD)', value: 50 },
          { name: 'Flame Trail', desc: 'Leave burning ground (20 damage/sec)', value: 20 },
          { name: 'Rising Sun', desc: '+40% fire damage, +30% speed', value: 40 }
        ],
        abilities: ['Phoenix Fire', 'Resurrection', 'Flame Dive'], description: 'Immortal firebird', lore: 'Dies and is reborn', levelReq: 32, tags: ['fire', 'immortal', 'legendary'], element: 'fire', summonCost: 150 },

      { id: 'spirit_leviathan', name: 'Leviathan Spirit', icon: 'ğŸŒŠğŸ‰', type: 'spirit', rarity: 'rare', cost: 2900, basePrice: 2900, attack: 45, defense: 35, hp: 200, mana: 250, speed: 20,
        effects: [
          { name: 'Tidal Surge', desc: 'Massive wave dealing 100 AOE damage', value: 100 },
          { name: 'Ocean Master', desc: '+50% damage in water, heal 10/sec', value: 50 },
          { name: 'Crush Depth', desc: 'Enemies take +25% damage from all sources', value: 25 }
        ],
        abilities: ['Tsunami', 'Whirlpool', 'Drown'], description: 'Sea monster of legend', lore: 'Rules the deep ocean', levelReq: 34, tags: ['water', 'massive', 'aoe'], element: 'water', summonCost: 160 },

      { id: 'spirit_zephyr', name: 'Zephyr Spirit', icon: 'ğŸ’¨âœ¨', type: 'spirit', rarity: 'rare', cost: 2700, basePrice: 2700, attack: 55, defense: 22, hp: 140, mana: 220, speed: 35,
        effects: [
          { name: 'Divine Wind', desc: 'Teleport to any location instantly', value: 100 },
          { name: 'Tornado Strike', desc: 'Attacks hit all enemies in path', value: 100 },
          { name: 'Untouchable', desc: '+35% evasion, immune to slows', value: 35 }
        ],
        abilities: ['Cyclone', 'Wind Walk', 'Hurricane'], description: 'God of wind', lore: 'Faster than light', levelReq: 33, tags: ['wind', 'speed', 'mobility'], element: 'wind', summonCost: 155 },

      { id: 'spirit_celestial', name: 'Celestial Spirit', icon: 'â­ğŸ‘‘', type: 'spirit', rarity: 'rare', cost: 3000, basePrice: 3000, attack: 48, defense: 30, hp: 180, mana: 300, speed: 25,
        effects: [
          { name: 'Divine Grace', desc: 'Heal all allies for 10 HP/sec', value: 10 },
          { name: 'Star Fall', desc: 'Summon meteors (50 damage each)', value: 50 },
          { name: 'Holy Sanctuary', desc: '+40% all resistances, cleanse debuffs', value: 40 }
        ],
        abilities: ['Holy Nova', 'Starlight', 'Sanctuary'], description: 'Blessed by heaven', lore: 'Angel of light', levelReq: 35, tags: ['holy', 'divine', 'support'], element: 'light', summonCost: 170 },

      { id: 'spirit_shadow_lord', name: 'Shadow Lord Spirit', icon: 'ğŸŒ‘ğŸ‘‘', type: 'spirit', rarity: 'rare', cost: 2850, basePrice: 2850, attack: 60, defense: 20, hp: 130, mana: 240, speed: 30,
        effects: [
          { name: 'Shadow Realm', desc: 'Become untargetable for 5s', value: 5 },
          { name: 'Assassinate', desc: '+80% crit damage from behind', value: 80 },
          { name: 'Death Mark', desc: 'Marked enemies take +35% damage', value: 35 }
        ],
        abilities: ['Shadow Step', 'Dark Execution', 'Nightmare'], description: 'Master of shadows', lore: 'Feared by all', levelReq: 34, tags: ['dark', 'assassin', 'crit'], element: 'dark', summonCost: 165 },

      // EPIC SPIRITS (3) - 5 Effects Each
      { id: 'spirit_primordial_flame', name: 'Primordial Flame', icon: 'ğŸ”¥ğŸ‘‘ğŸ’«', type: 'spirit', rarity: 'epic', cost: 9000, basePrice: 9000, attack: 100, defense: 50, hp: 400, mana: 500, speed: 35,
        effects: [
          { name: 'Eternal Burning', desc: 'All fire damage +100%', value: 100 },
          { name: 'Infernal Phoenix', desc: 'Summon phoenix minion (300 HP, 80 ATK)', value: 300 },
          { name: 'Melt Armor', desc: 'Enemies lose 50% defense', value: 50 },
          { name: 'Pyroclasm', desc: 'Every 10s, create fire explosion (200 AOE dmg)', value: 200 },
          { name: 'Flame Immunity', desc: 'Immune to fire, heal from fire damage', value: 100 }
        ],
        abilities: ['Inferno', 'Meteor Storm', 'Solar Flare', 'Phoenix Form'], description: 'First fire ever created', lore: 'The origin of all flames', levelReq: 55, tags: ['fire', 'primordial', 'god-tier'], element: 'fire', summonCost: 300 },

      { id: 'spirit_world_tree', name: 'World Tree Spirit', icon: 'ğŸŒ³ğŸ‘‘ğŸŒ', type: 'spirit', rarity: 'epic', cost: 8500, basePrice: 8500, attack: 70, defense: 80, hp: 600, mana: 600, speed: 18,
        effects: [
          { name: 'Life Nexus', desc: 'Heal all allies 25 HP/sec', value: 25 },
          { name: 'Root Network', desc: 'Summon 5 root defenders (150 HP each)', value: 5 },
          { name: 'Nature\'s Wrath', desc: 'Enemies take 30 nature damage/sec', value: 30 },
          { name: 'Endless Growth', desc: 'Grow stronger over time (+5 stats/min)', value: 5 },
          { name: 'Sanctuary', desc: 'Create safe zone (allies invulnerable 10s)', value: 10 }
        ],
        abilities: ['Overgrowth', 'Entangling Roots', 'Life Bloom', 'Forest Wrath'], description: 'Anchor of all life', lore: 'Holds the world together', levelReq: 58, tags: ['nature', 'support', 'epic'], element: 'nature', summonCost: 320 },

      { id: 'spirit_apocalypse', name: 'Apocalypse Spirit', icon: 'â˜ ï¸ğŸ’€ğŸ‘‘', type: 'spirit', rarity: 'epic', cost: 9500, basePrice: 9500, attack: 120, defense: 40, hp: 350, mana: 550, speed: 32,
        effects: [
          { name: 'Death Touch', desc: 'Attacks instantly kill enemies below 15% HP', value: 15 },
          { name: 'Plague of Ages', desc: 'All enemies poisoned for 50 damage/sec', value: 50 },
          { name: 'Reaper Form', desc: '+150% damage, lifesteal 50%', value: 150 },
          { name: 'Soul Harvest', desc: 'Gain +10 ATK per kill (stacks)', value: 10 },
          { name: 'Undying', desc: 'Resurrect twice per battle at full HP', value: 2 }
        ],
        abilities: ['Death Scythe', 'Plague Nova', 'Soul Rip', 'Apocalypse'], description: 'End of all things', lore: 'Brings the final judgment', levelReq: 60, tags: ['death', 'apocalyptic', 'ultimate'], element: 'dark', summonCost: 350 },

      // SPECIAL SPIRITS FROM SCREENSHOT (5) - Themed Collection
      { id: 'spirit_ember_fox', name: 'Ember Fox', icon: 'ğŸ¦ŠğŸ”¥', type: 'spirit', rarity: 'legendary', cost: 28000, basePrice: 28000, attack: 180, defense: 90, hp: 750, mana: 800, speed: 65,
        effects: [
          { name: 'Fire Fox Spirit', desc: '+90 power rating', value: 90 },
          { name: 'ATK Boost', desc: '+50% ATK', value: 50 },
          { name: 'Ember Strike', desc: 'Attacks deal 45 fire damage', value: 45 },
          { name: 'Fox Fire', desc: 'Summon flame wisps (8 wisps)', value: 8 },
          { name: 'Legendary Aura', desc: '+40% all elemental damage', value: 40 },
          { name: 'Blaze Trail', desc: 'Leave burning path (50 damage/sec)', value: 50 }
        ],
        abilities: ['Fox Fire', 'Flame Burst', 'Inferno Dash', 'Spirit Form'], description: 'A legendary fire fox spirit granting immense power', lore: 'Ancient fox spirit of eternal flames', levelReq: 75, tags: ['fox', 'fire', 'legendary'], element: 'fire', summonCost: 400 },

      { id: 'spirit_storm_wisp', name: 'Storm Wisp', icon: 'â›ˆï¸âœ¨', type: 'spirit', rarity: 'epic', cost: 9200, basePrice: 9200, attack: 110, defense: 70, hp: 420, mana: 550, speed: 55,
        effects: [
          { name: 'Storm Power', desc: '+92 power rating', value: 92 },
          { name: 'ATK Penalty', desc: '-8% ATK (unstable energy)', value: -8 },
          { name: 'Storm Strike', desc: 'Lightning attacks (40 damage)', value: 40 },
          { name: 'Cyclone', desc: 'Create wind vortex (80 AOE damage)', value: 80 },
          { name: 'Thunder Call', desc: 'Summon lightning bolts', value: 100 }
        ],
        abilities: ['Lightning Strike', 'Cyclone', 'Thunder Bolt', 'Storm Rage'], description: 'A powerful storm spirit combining wind and lightning', lore: 'Born from tempests', levelReq: 58, tags: ['storm', 'lightning', 'epic'], element: 'storm', summonCost: 320 },

      { id: 'spirit_light_soul', name: 'Light Soul', icon: 'â˜€ï¸ğŸ’«', type: 'spirit', rarity: 'rare', cost: 2900, basePrice: 2900, attack: 52, defense: 35, hp: 190, mana: 280, speed: 28,
        effects: [
          { name: 'Light Power', desc: '+90 power rating', value: 90 },
          { name: 'HP Bonus', desc: '+60 HP', value: 60 },
          { name: 'Light Beam', desc: 'Holy attacks (25 damage)', value: 25 },
          { name: 'Radiance', desc: 'Heal allies 8 HP/sec', value: 8 }
        ],
        abilities: ['Light Beam', 'Radiant Heal', 'Purify'], description: 'A radiant light spirit that grants health and healing', lore: 'Embodies pure light', levelReq: 33, tags: ['light', 'healing', 'rare'], element: 'light', summonCost: 165 },

      { id: 'spirit_guardian_sand', name: 'Guardian Sand', icon: 'ğŸœï¸ğŸ›¡ï¸', type: 'spirit', rarity: 'epic', cost: 8800, basePrice: 8800, attack: 85, defense: 90, hp: 550, mana: 450, speed: 22,
        effects: [
          { name: 'Earth Guardian', desc: '+90 power rating', value: 90 },
          { name: 'Damage Reduction', desc: '-15% Damage Taken', value: 15 },
          { name: 'Sand Strike', desc: 'Earth attacks (28 damage)', value: 28 },
          { name: 'Sand Shield', desc: 'Create protective barrier (200 HP)', value: 200 },
          { name: 'Ancient Power', desc: '+35% defense to all allies', value: 35 }
        ],
        abilities: ['Sand Wall', 'Desert Storm', 'Stone Skin', 'Guardian Mode'], description: 'An ancient earth guardian that protects allies', lore: 'Eternal guardian of deserts', levelReq: 56, tags: ['earth', 'guardian', 'epic'], element: 'earth', summonCost: 310 },

      { id: 'spirit_tech_essence', name: 'Tech Essence', icon: 'ğŸ’»âœ¨', type: 'spirit', rarity: 'rare', cost: 2750, basePrice: 2750, attack: 58, defense: 28, hp: 165, mana: 300, speed: 32,
        effects: [
          { name: 'Tech Power', desc: '+80 power rating', value: 80 },
          { name: 'Speed Penalty', desc: '-5% Speed (heavy tech)', value: -5 },
          { name: 'Tech Strike', desc: 'Cyber attacks (35 damage)', value: 35 },
          { name: 'System Hack', desc: 'Disable enemy abilities', value: 100 }
        ],
        abilities: ['Cyber Blast', 'System Hack', 'Tech Overload'], description: 'A technological spirit core that enhances cyber abilities', lore: 'Digital consciousness', levelReq: 32, tags: ['tech', 'cyber', 'rare'], element: 'tech', summonCost: 160 },

      { id: 'spirit_golden', name: 'Golden Spirit', icon: 'ğŸ’°âœ¨', type: 'spirit', rarity: 'uncommon', cost: 580, basePrice: 580, attack: 18, defense: 16, hp: 88, mana: 150, speed: 20,
        effects: [
          { name: 'Fortune', desc: '+75 power rating', value: 75 },
          { name: 'Gold Boost', desc: '+15% Gold drops', value: 15 },
          { name: 'Lucky Strike', desc: 'Weak attacks (20 damage)', value: 20 }
        ],
        abilities: ['Gold Rain', 'Fortune\'s Favor'], description: 'A fortunate spirit that increases gold gains', lore: 'Lady luck incarnate', levelReq: 15, tags: ['gold', 'luck', 'uncommon'], element: 'gold', summonCost: 85 },

      { id: 'spirit_dark_soul', name: 'Dark Soul', icon: 'ğŸŒ‘ğŸ’€', type: 'spirit', rarity: 'rare', cost: 2650, basePrice: 2650, attack: 62, defense: 24, hp: 155, mana: 260, speed: 26,
        effects: [
          { name: 'Dark Power', desc: '+85 power rating', value: 85 },
          { name: 'ATK Penalty', desc: '-6% ATK (cursed)', value: -6 },
          { name: 'Dark Strike', desc: 'Shadow attacks (30 damage)', value: 30 },
          { name: 'Soul Drain', desc: 'Steal 15% HP per hit', value: 15 }
        ],
        abilities: ['Dark Pulse', 'Soul Drain', 'Shadow Form'], description: 'A dark energy spirit that feeds on life force', lore: 'Cursed soul seeking power', levelReq: 31, tags: ['dark', 'curse', 'rare'], element: 'dark', summonCost: 155 },

      // LEGENDARY SPIRITS (2) - 6 Effects Each
      { id: 'spirit_cosmic_entity', name: 'Cosmic Entity', icon: 'ğŸŒŒâœ¨ğŸ‘‘', type: 'spirit', rarity: 'legendary', cost: 30000, basePrice: 30000, attack: 200, defense: 120, hp: 1000, mana: 1000, speed: 50,
        effects: [
          { name: 'Reality Warp', desc: 'Rewrite combat rules at will', value: 100 },
          { name: 'Omnipotence', desc: '+300% all stats', value: 300 },
          { name: 'Time Stop', desc: 'Freeze all enemies for 15s', value: 15 },
          { name: 'Black Hole', desc: 'Pull all enemies, deal 500 damage', value: 500 },
          { name: 'Constellation', desc: 'Summon 8 star guardians (200 HP, 100 ATK each)', value: 8 },
          { name: 'Cosmic Ascension', desc: 'Become invincible, deal true damage', value: 100 }
        ],
        abilities: ['Big Bang', 'Supernova', 'Warp Reality', 'Cosmic Storm', 'End of Time'], description: 'Being beyond comprehension', lore: 'Existed before time itself', levelReq: 85, tags: ['cosmic', 'god', 'transcendent'], element: 'cosmic', summonCost: 500 },

      { id: 'spirit_omega', name: 'Omega Spirit', icon: 'Î©ğŸ‘‘ğŸ’«', type: 'spirit', rarity: 'legendary', cost: 35000, basePrice: 35000, attack: 250, defense: 150, hp: 1200, mana: 1200, speed: 60,
        effects: [
          { name: 'Alpha & Omega', desc: 'Begin and end battles instantly', value: 100 },
          { name: 'Perfect Being', desc: '+500% all stats, immune to everything', value: 500 },
          { name: 'Divine Judgment', desc: 'Enemies lose 90% of current HP', value: 90 },
          { name: 'Absolute Zero', desc: 'All damage becomes true damage', value: 100 },
          { name: 'Eternal Life', desc: 'Cannot die, auto-revive infinitely', value: 9999 },
          { name: 'Creation & Destruction', desc: 'Create/destroy anything at will', value: 100 }
        ],
        abilities: ['Genesis', 'Armageddon', 'Judgment Day', 'Omega Beam', 'Divine Wrath'], description: 'The final form', lore: 'When Omega awakens, reality ends', levelReq: 99, tags: ['omega', 'ultimate', 'end-game'], element: 'divine', summonCost: 999 }
    ];
    
    rebalanceCompanionRarities(AVAILABLE_SPIRITS);
    
    // Define all available vehicles (40 total - Common to Legendary)
    const AVAILABLE_VEHICLES = [
      // COMMON VEHICLES (12) - 1 Effect Each
      { id: 'vehicle_bike', name: 'Mountain Bike', icon: 'ğŸš´', type: 'vehicle', rarity: 'common', cost: 150, basePrice: 150, speed: 15, defense: 2, hp: 30,
        effects: [{ name: 'Endurance', desc: '+15% stamina recovery', value: 15 }],
        abilities: ['Pedal Boost'], description: 'Fast and reliable transport', lore: 'Eco-friendly mountain cruiser', levelReq: 1, tags: ['transport', 'eco', 'common'], fuelType: 'stamina', capacity: 1 },
      
      { id: 'vehicle_scooter', name: 'Electric Scooter', icon: 'ğŸ›´', type: 'vehicle', rarity: 'common', cost: 150, basePrice: 150, speed: 18, defense: 1, hp: 25,
        effects: [{ name: 'Electric Boost', desc: '+10% speed in cities', value: 10 }],
        abilities: ['Quick Start'], description: 'Eco-friendly ride', lore: 'Battery-powered convenience', levelReq: 1, tags: ['electric', 'urban', 'fast'], fuelType: 'battery', capacity: 1 },
      
      { id: 'vehicle_skateboard', name: 'Skateboard', icon: 'ğŸ›¹', type: 'vehicle', rarity: 'common', cost: 100, basePrice: 100, speed: 12, defense: 0, hp: 15,
        effects: [{ name: 'Tricks', desc: '+20% evasion while moving', value: 20 }],
        abilities: ['Grind'], description: 'Cool street cruiser', lore: 'Street culture icon', levelReq: 1, tags: ['street', 'tricks', 'agile'], fuelType: 'none', capacity: 1 },
      
      { id: 'vehicle_car', name: 'Compact Car', icon: 'ğŸš—', type: 'vehicle', rarity: 'common', cost: 200, basePrice: 200, speed: 25, defense: 5, hp: 60,
        effects: [{ name: 'Comfort', desc: 'Restore 5 HP/sec while driving', value: 5 }],
        abilities: ['Auto Drive'], description: 'Comfortable daily driver', lore: 'Reliable city car', levelReq: 1, tags: ['car', 'comfort', 'safe'], fuelType: 'gas', capacity: 4 },
      
      { id: 'vehicle_bus', name: 'Tour Bus', icon: 'ğŸšŒ', type: 'vehicle', rarity: 'common', cost: 180, basePrice: 180, speed: 20, defense: 8, hp: 100,
        effects: [{ name: 'Group Travel', desc: 'Entire party gains +10% XP', value: 10 }],
        abilities: ['Mass Transit'], description: 'Carries the whole party', lore: 'Room for everyone', levelReq: 1, tags: ['transport', 'party', 'large'], fuelType: 'diesel', capacity: 12 },
      
      { id: 'vehicle_motorcycle', name: 'Motorcycle', icon: 'ğŸï¸', type: 'vehicle', rarity: 'common', cost: 220, basePrice: 220, speed: 30, defense: 3, hp: 40,
        effects: [{ name: 'Speed Demon', desc: '+25% max speed', value: 25 }],
        abilities: ['Wheelie'], description: 'Fast two-wheeler', lore: 'Built for speed', levelReq: 1, tags: ['bike', 'speed', 'dangerous'], fuelType: 'gas', capacity: 2 },
      
      { id: 'vehicle_tricycle', name: 'Tricycle', icon: 'ğŸš²', type: 'vehicle', rarity: 'common', cost: 80, basePrice: 80, speed: 8, defense: 2, hp: 20,
        effects: [{ name: 'Stable', desc: 'Cannot be knocked off', value: 100 }],
        abilities: ['Balance'], description: 'Safe and steady', lore: 'Training wheels optional', levelReq: 1, tags: ['safe', 'beginner', 'stable'], fuelType: 'none', capacity: 1 },
      
      { id: 'vehicle_boat', name: 'Rowboat', icon: 'ğŸš£', type: 'vehicle', rarity: 'common', cost: 160, basePrice: 160, speed: 10, defense: 4, hp: 50,
        effects: [{ name: 'Water Travel', desc: 'Can traverse water', value: 100 }],
        abilities: ['Row'], description: 'Water transport', lore: 'For rivers and lakes', levelReq: 1, tags: ['water', 'boat', 'manual'], fuelType: 'none', capacity: 2 },
      
      { id: 'vehicle_cart', name: 'Wooden Cart', icon: 'ğŸ›’', type: 'vehicle', rarity: 'common', cost: 120, basePrice: 120, speed: 6, defense: 3, hp: 40,
        effects: [{ name: 'Cargo Space', desc: '+20 inventory slots', value: 20 }],
        abilities: ['Haul'], description: 'Carry more items', lore: 'Simple storage solution', levelReq: 1, tags: ['storage', 'utility', 'slow'], fuelType: 'none', capacity: 1 },
      
      { id: 'vehicle_segway', name: 'Segway', icon: 'ğŸ›´', type: 'vehicle', rarity: 'common', cost: 140, basePrice: 140, speed: 14, defense: 1, hp: 20,
        effects: [{ name: 'Self-Balancing', desc: '+15% stability', value: 15 }],
        abilities: ['Cruise'], description: 'Personal transporter', lore: 'Tech meets convenience', levelReq: 1, tags: ['tech', 'balance', 'urban'], fuelType: 'battery', capacity: 1 },
      
      { id: 'vehicle_wagon', name: 'Horse Wagon', icon: 'ğŸ´', type: 'vehicle', rarity: 'common', cost: 250, basePrice: 250, speed: 12, defense: 6, hp: 80,
        effects: [{ name: 'Beast Power', desc: 'Horse provides +10 defense', value: 10 }],
        abilities: ['Gallop'], description: 'Classic transport', lore: 'Trusty steed included', levelReq: 1, tags: ['classic', 'beast', 'sturdy'], fuelType: 'food', capacity: 4 },
      
      { id: 'vehicle_raft', name: 'Log Raft', icon: 'ğŸªµ', type: 'vehicle', rarity: 'common', cost: 90, basePrice: 90, speed: 5, defense: 2, hp: 35,
        effects: [{ name: 'Floats', desc: 'Never sink in water', value: 100 }],
        abilities: ['Float'], description: 'Basic water craft', lore: 'Simple but effective', levelReq: 1, tags: ['water', 'basic', 'safe'], fuelType: 'none', capacity: 2 },

      // UNCOMMON VEHICLES (12) - 2 Effects Each
      { id: 'vehicle_sports_car', name: 'Sports Car', icon: 'ğŸï¸', type: 'vehicle', rarity: 'uncommon', cost: 800, basePrice: 800, speed: 45, defense: 8, hp: 90, armor: 15,
        effects: [
          { name: 'Nitro Boost', desc: '+50% speed for 10s (30s CD)', value: 50 },
          { name: 'Aerodynamic', desc: '+20% fuel efficiency', value: 20 }
        ],
        abilities: ['Nitro', 'Drift'], description: 'High-performance racing machine', lore: 'Built for speed', levelReq: 10, tags: ['racing', 'fast', 'luxury'], fuelType: 'premium', capacity: 2 },

      { id: 'vehicle_suv', name: 'Off-Road SUV', icon: 'ğŸš™', type: 'vehicle', rarity: 'uncommon', cost: 900, basePrice: 900, speed: 35, defense: 15, hp: 150, armor: 25,
        effects: [
          { name: 'All-Terrain', desc: 'No speed penalty on rough terrain', value: 100 },
          { name: 'Reinforced', desc: '+30% damage reduction', value: 30 }
        ],
        abilities: ['4WD', 'Climb'], description: 'Rugged all-terrain vehicle', lore: 'Goes anywhere', levelReq: 12, tags: ['offroad', 'tough', 'versatile'], fuelType: 'gas', capacity: 5 },

      { id: 'vehicle_jet_ski', name: 'Jet Ski', icon: 'ğŸš¤', type: 'vehicle', rarity: 'uncommon', cost: 750, basePrice: 750, speed: 50, defense: 5, hp: 60, armor: 10,
        effects: [
          { name: 'Water Speed', desc: '+100% speed on water', value: 100 },
          { name: 'Wave Jump', desc: 'Can jump over obstacles', value: 100 }
        ],
        abilities: ['Turbo', 'Jump'], description: 'Fast water vehicle', lore: 'King of the waves', levelReq: 11, tags: ['water', 'speed', 'fun'], fuelType: 'gas', capacity: 2 },

      { id: 'vehicle_helicopter', name: 'Light Helicopter', icon: 'ğŸš', type: 'vehicle', rarity: 'uncommon', cost: 1200, basePrice: 1200, speed: 40, defense: 10, hp: 120, armor: 20,
        effects: [
          { name: 'Flight', desc: 'Can fly over terrain', value: 100 },
          { name: 'Aerial View', desc: '+30% detection range', value: 30 }
        ],
        abilities: ['Fly', 'Hover'], description: 'Versatile aerial transport', lore: 'Take to the skies', levelReq: 15, tags: ['air', 'flight', 'versatile'], fuelType: 'aviation', capacity: 4 },

      { id: 'vehicle_tank', name: 'Light Tank', icon: 'ğŸšœ', type: 'vehicle', rarity: 'uncommon', cost: 1100, basePrice: 1100, speed: 18, defense: 30, hp: 250, armor: 50,
        effects: [
          { name: 'Armored', desc: '+50% damage reduction', value: 50 },
          { name: 'Ramming', desc: 'Deal 100 damage on collision', value: 100 }
        ],
        abilities: ['Ram', 'Shell Fire'], description: 'Heavy armored vehicle', lore: 'Unstoppable force', levelReq: 18, tags: ['tank', 'armor', 'combat'], fuelType: 'diesel', capacity: 3 },

      { id: 'vehicle_speedboat', name: 'Speedboat', icon: 'â›µ', type: 'vehicle', rarity: 'uncommon', cost: 850, basePrice: 850, speed: 48, defense: 6, hp: 70, armor: 12,
        effects: [
          { name: 'Hydroplane', desc: '+60% water speed', value: 60 },
          { name: 'Spray', desc: 'Enemies behind are slowed 20%', value: 20 }
        ],
        abilities: ['Boost', 'Sharp Turn'], description: 'Racing watercraft', lore: 'Speed on waves', levelReq: 13, tags: ['water', 'racing', 'agile'], fuelType: 'gas', capacity: 4 },

      { id: 'vehicle_atv', name: 'ATV Quad', icon: 'ğŸœï¸', type: 'vehicle', rarity: 'uncommon', cost: 700, basePrice: 700, speed: 32, defense: 10, hp: 90, armor: 18,
        effects: [
          { name: 'Rough Rider', desc: '+40% speed on dirt', value: 40 },
          { name: 'Sturdy', desc: '+25% HP', value: 25 }
        ],
        abilities: ['Power Slide', 'Jump'], description: 'All-terrain quad bike', lore: 'Desert dominator', levelReq: 12, tags: ['offroad', 'quad', 'fun'], fuelType: 'gas', capacity: 1 },

      { id: 'vehicle_glider', name: 'Hang Glider', icon: 'ğŸª‚', type: 'vehicle', rarity: 'uncommon', cost: 650, basePrice: 650, speed: 28, defense: 2, hp: 30, armor: 5,
        effects: [
          { name: 'Glide', desc: 'Silent movement, +35% stealth', value: 35 },
          { name: 'Updraft', desc: 'Gain altitude near heat sources', value: 100 }
        ],
        abilities: ['Soar', 'Land'], description: 'Silent aerial glider', lore: 'Ride the wind', levelReq: 10, tags: ['air', 'stealth', 'glide'], fuelType: 'wind', capacity: 1 },

      { id: 'vehicle_snowmobile', name: 'Snowmobile', icon: 'ğŸ›·', type: 'vehicle', rarity: 'uncommon', cost: 780, basePrice: 780, speed: 35, defense: 8, hp: 75, armor: 15,
        effects: [
          { name: 'Ice Travel', desc: '+80% speed on snow/ice', value: 80 },
          { name: 'Cold Resistance', desc: 'Immune to frost damage', value: 100 }
        ],
        abilities: ['Drift', 'Boost'], description: 'Winter terrain specialist', lore: 'Master of ice', levelReq: 14, tags: ['snow', 'ice', 'fast'], fuelType: 'gas', capacity: 2 },

      { id: 'vehicle_tractor', name: 'Farm Tractor', icon: 'ğŸšœ', type: 'vehicle', rarity: 'uncommon', cost: 950, basePrice: 950, speed: 15, defense: 20, hp: 180, armor: 35,
        effects: [
          { name: 'Tow Power', desc: 'Can pull heavy loads', value: 100 },
          { name: 'Work Horse', desc: '+40 inventory slots', value: 40 }
        ],
        abilities: ['Pull', 'Till'], description: 'Heavy-duty workhorse', lore: 'Farm life essential', levelReq: 15, tags: ['utility', 'strong', 'slow'], fuelType: 'diesel', capacity: 2 },

      { id: 'vehicle_drone', name: 'Cargo Drone', icon: 'ğŸ›¸', type: 'vehicle', rarity: 'uncommon', cost: 1000, basePrice: 1000, speed: 38, defense: 5, hp: 50, armor: 10,
        effects: [
          { name: 'Auto-Pilot', desc: 'Can travel while AFK', value: 100 },
          { name: 'Hover', desc: 'Ignore ground-based obstacles', value: 100 }
        ],
        abilities: ['Hover', 'Deliver'], description: 'Autonomous flying cargo', lore: 'Future of delivery', levelReq: 16, tags: ['tech', 'auto', 'flying'], fuelType: 'battery', capacity: 0 },

      { id: 'vehicle_segway_pro', name: 'Segway Pro', icon: 'ğŸ›´', type: 'vehicle', rarity: 'uncommon', cost: 680, basePrice: 680, speed: 22, defense: 4, hp: 45, armor: 8,
        effects: [
          { name: 'Gyro Stabilizer', desc: 'Cannot be pushed/knocked back', value: 100 },
          { name: 'Smart Balance', desc: '+18% control', value: 18 }
        ],
        abilities: ['Auto-Balance', 'Cruise Control'], description: 'Advanced personal transport', lore: 'Balance perfected', levelReq: 11, tags: ['tech', 'stable', 'urban'], fuelType: 'battery', capacity: 1 },

      // RARE VEHICLES (8) - 3 Effects Each
      { id: 'vehicle_supercar', name: 'Supercar', icon: 'ğŸï¸', type: 'vehicle', rarity: 'rare', cost: 3500, basePrice: 3500, speed: 70, defense: 12, hp: 140, armor: 25,
        effects: [
          { name: 'Twin Turbo', desc: '+100% acceleration', value: 100 },
          { name: 'Luxury', desc: '+20% all stats while driving', value: 20 },
          { name: 'Nitrous Oxide', desc: 'Temporary invincibility during boost', value: 100 }
        ],
        abilities: ['Nitro Boost', 'Launch Control', 'Drift'], description: 'Ultimate racing machine', lore: 'Engineering perfection', levelReq: 30, tags: ['racing', 'luxury', 'ultimate'], fuelType: 'racing', capacity: 2 },

      { id: 'vehicle_combat_bike', name: 'Combat Bike', icon: 'ğŸï¸', type: 'vehicle', rarity: 'rare', cost: 3200, basePrice: 3200, speed: 65, defense: 18, hp: 120, armor: 30,
        effects: [
          { name: 'Mounted Guns', desc: 'Fire weapons while driving (50 dmg)', value: 50 },
          { name: 'Reinforced Frame', desc: '+35% defense', value: 35 },
          { name: 'Tactical Boost', desc: 'Leave smoke trail (enemies slowed 30%)', value: 30 }
        ],
        abilities: ['Drive-By', 'Smoke Screen', 'Ram'], description: 'Weaponized motorcycle', lore: 'War machine on wheels', levelReq: 28, tags: ['combat', 'weapons', 'fast'], fuelType: 'military', capacity: 2 },

      { id: 'vehicle_yacht', name: 'Luxury Yacht', icon: 'ğŸ›¥ï¸', type: 'vehicle', rarity: 'rare', cost: 4000, basePrice: 4000, speed: 30, defense: 20, hp: 300, armor: 40,
        effects: [
          { name: 'Mobile Base', desc: 'Full HP/MP regen while aboard', value: 100 },
          { name: 'Party Boat', desc: 'All allies gain +25% stats', value: 25 },
          { name: 'Deep Sea', desc: 'Can access ocean areas', value: 100 }
        ],
        abilities: ['Cruise', 'Anchor', 'Sonar'], description: 'Floating luxury home', lore: 'Live on the ocean', levelReq: 32, tags: ['water', 'luxury', 'base'], fuelType: 'diesel', capacity: 12 },

      { id: 'vehicle_gunship', name: 'Attack Helicopter', icon: 'ğŸš', type: 'vehicle', rarity: 'rare', cost: 4200, basePrice: 4200, speed: 55, defense: 25, hp: 200, armor: 45,
        effects: [
          { name: 'Airborne Arsenal', desc: 'Fire missiles (150 AOE damage)', value: 150 },
          { name: 'Tactical Support', desc: 'Allies gain +30% damage', value: 30 },
          { name: 'Evasive Maneuvers', desc: '+40% dodge vs projectiles', value: 40 }
        ],
        abilities: ['Missile Strike', 'Minigun', 'Strafe'], description: 'Military attack chopper', lore: 'Air superiority', levelReq: 35, tags: ['military', 'combat', 'air'], fuelType: 'aviation', capacity: 4 },

      { id: 'vehicle_mech_walker', name: 'Mech Walker', icon: 'ğŸ¤–', type: 'vehicle', rarity: 'rare', cost: 3800, basePrice: 3800, speed: 28, defense: 40, hp: 350, armor: 60,
        effects: [
          { name: 'Powered Armor', desc: '+50 defense, +100 HP', value: 50 },
          { name: 'Stomp Attack', desc: 'Each step deals 80 AOE damage', value: 80 },
          { name: 'Shield Generator', desc: 'Absorb 200 damage before taking HP loss', value: 200 }
        ],
        abilities: ['Stomp', 'Laser', 'Shield'], description: 'Bipedal combat mech', lore: 'Walking fortress', levelReq: 33, tags: ['mech', 'combat', 'tech'], fuelType: 'power cell', capacity: 1 },

      { id: 'vehicle_hoverboard', name: 'Quantum Hoverboard', icon: 'ğŸ›¹', type: 'vehicle', rarity: 'rare', cost: 3300, basePrice: 3300, speed: 60, defense: 10, hp: 80, armor: 15,
        effects: [
          { name: 'Anti-Gravity', desc: 'Hover over all terrain types', value: 100 },
          { name: 'Quantum Dash', desc: 'Short teleport forward (5s CD)', value: 100 },
          { name: 'Friction-less', desc: '+45% max speed, never slow down', value: 45 }
        ],
        abilities: ['Hover', 'Quantum Dash', 'Grind'], description: 'Future skateboard tech', lore: 'Defies gravity', levelReq: 31, tags: ['tech', 'hover', 'fast'], fuelType: 'quantum', capacity: 1 },

      { id: 'vehicle_submarine', name: 'Submarine', icon: 'ğŸš¢', type: 'vehicle', rarity: 'rare', cost: 3600, basePrice: 3600, speed: 25, defense: 35, hp: 280, armor: 55,
        effects: [
          { name: 'Deep Dive', desc: 'Access underwater areas', value: 100 },
          { name: 'Torpedo Bay', desc: 'Fire torpedoes (120 damage)', value: 120 },
          { name: 'Sonar Ping', desc: 'Reveal all nearby enemies', value: 100 }
        ],
        abilities: ['Dive', 'Torpedo', 'Sonar'], description: 'Deep sea explorer', lore: 'Master the abyss', levelReq: 32, tags: ['water', 'deep', 'combat'], fuelType: 'nuclear', capacity: 6 },

      { id: 'vehicle_monster_truck', name: 'Monster Truck', icon: 'ğŸšš', type: 'vehicle', rarity: 'rare', cost: 3400, basePrice: 3400, speed: 32, defense: 28, hp: 220, armor: 48,
        effects: [
          { name: 'Crush', desc: 'Drive over small obstacles/enemies', value: 100 },
          { name: 'Giant Tires', desc: '+40% HP, +35% defense', value: 40 },
          { name: 'Shockwave', desc: 'Landing creates AOE stun', value: 100 }
        ],
        abilities: ['Jump', 'Crush', 'Roar'], description: 'Massive off-road beast', lore: 'Nothing stops this', levelReq: 30, tags: ['massive', 'offroad', 'power'], fuelType: 'diesel', capacity: 2 },

      // EPIC VEHICLES (5) - 5 Effects Each
      { id: 'vehicle_hypersonic_jet', name: 'Hypersonic Jet', icon: 'âœˆï¸', type: 'vehicle', rarity: 'epic', cost: 12000, basePrice: 12000, speed: 120, defense: 35, hp: 350, armor: 50,
        effects: [
          { name: 'Mach 5', desc: '+200% speed, break sound barrier', value: 200 },
          { name: 'Afterburner', desc: 'Leave fire trail (100 damage/sec)', value: 100 },
          { name: 'Missile System', desc: 'Auto-fire missiles (200 damage)', value: 200 },
          { name: 'Stealth Mode', desc: 'Invisible to radar', value: 100 },
          { name: 'Ejection Seat', desc: 'Survive any crash at 1 HP', value: 100 }
        ],
        abilities: ['Supersonic Flight', 'Air-to-Air Missiles', 'Barrel Roll', 'Eject'], description: 'Fastest aircraft ever built', lore: 'Breaks all speed records', levelReq: 50, tags: ['air', 'military', 'ultimate'], fuelType: 'jet fuel', capacity: 2 },

      { id: 'vehicle_battle_tank', name: 'Battle Tank MK-X', icon: 'ğŸ–ï¸', type: 'vehicle', rarity: 'epic', cost: 11000, basePrice: 11000, speed: 25, defense: 80, hp: 600, armor: 100,
        effects: [
          { name: 'Main Cannon', desc: 'Fire 300 damage shells (8s CD)', value: 300 },
          { name: 'Reactive Armor', desc: 'Block 500 damage, then regenerate', value: 500 },
          { name: 'Siege Mode', desc: '+100% damage, -50% speed', value: 100 },
          { name: 'Unstoppable', desc: 'Immune to CC, crush obstacles', value: 100 },
          { name: 'Crew Bonus', desc: 'Allies inside gain +40% all stats', value: 40 }
        ],
        abilities: ['Main Cannon', 'Machine Gun', 'Siege Mode', 'Emergency Repair'], description: 'Ultimate ground war machine', lore: 'Dominates battlefields', levelReq: 52, tags: ['tank', 'military', 'destruction'], fuelType: 'military', capacity: 4 },

      { id: 'vehicle_mecha_titan', name: 'Titan Mecha', icon: 'ğŸ¤–', type: 'vehicle', rarity: 'epic', cost: 13000, basePrice: 13000, speed: 40, defense: 70, hp: 800, armor: 120,
        effects: [
          { name: 'Titan Form', desc: '+150% size, intimidate enemies', value: 150 },
          { name: 'Plasma Cannons', desc: 'Dual cannons (250 damage each)', value: 250 },
          { name: 'Force Field', desc: 'Absorb 600 damage shield', value: 600 },
          { name: 'Rocket Boosters', desc: 'Jump 100m, slam for 400 damage', value: 400 },
          { name: 'AI Co-Pilot', desc: 'Auto-dodge, +50% accuracy', value: 50 }
        ],
        abilities: ['Plasma Barrage', 'Rocket Jump', 'Melee Smash', 'Shield'], description: 'Giant piloted mecha', lore: 'Titan of war', levelReq: 55, tags: ['mech', 'giant', 'powerful'], fuelType: 'fusion', capacity: 1 },

      { id: 'vehicle_spaceship', name: 'Star Cruiser', icon: 'ğŸš€', type: 'vehicle', rarity: 'epic', cost: 14000, basePrice: 14000, speed: 100, defense: 50, hp: 500, armor: 80,
        effects: [
          { name: 'Space Travel', desc: 'Access space zones', value: 100 },
          { name: 'Warp Drive', desc: 'Instant travel to any location', value: 100 },
          { name: 'Laser Batteries', desc: 'Fire 8 lasers (180 damage each)', value: 180 },
          { name: 'Life Support', desc: 'Infinite HP regen in ship', value: 9999 },
          { name: 'Tractor Beam', desc: 'Pull enemies (200 damage)', value: 200 }
        ],
        abilities: ['Warp', 'Laser Barrage', 'Shields', 'Tractor Beam'], description: 'Interstellar vessel', lore: 'Explore the cosmos', levelReq: 58, tags: ['space', 'sci-fi', 'exploration'], fuelType: 'antimatter', capacity: 20 },

      { id: 'vehicle_time_machine', name: 'Chrono-Mobile', icon: 'â°', type: 'vehicle', rarity: 'epic', cost: 15000, basePrice: 15000, speed: 88, defense: 45, hp: 400, armor: 70,
        effects: [
          { name: 'Time Travel', desc: 'Rewind 30 seconds on death', value: 30 },
          { name: 'Temporal Shield', desc: 'Negate next 3 hits', value: 3 },
          { name: 'Flux Capacitor', desc: '+88% speed (reference achieved)', value: 88 },
          { name: 'Paradox Engine', desc: 'Exist in 2 places at once', value: 2 },
          { name: 'Time Stop', desc: 'Freeze enemies for 5s (60s CD)', value: 5 }
        ],
        abilities: ['Time Warp', 'Freeze Time', 'Paradox Clone', 'Rewind'], description: 'Breaks the laws of physics', lore: 'When this baby hits 88mph...', levelReq: 60, tags: ['time', 'legendary', 'sci-fi'], fuelType: 'temporal', capacity: 2 },

      // LEGENDARY VEHICLES (3) - 6 Effects Each
      { id: 'vehicle_god_chariot', name: 'Divine Chariot', icon: 'ğŸ', type: 'vehicle', rarity: 'legendary', cost: 30000, basePrice: 30000, speed: 150, defense: 100, hp: 1200, armor: 150,
        effects: [
          { name: 'Divine Speed', desc: '+500% speed, leave golden trail', value: 500 },
          { name: 'Holy Protection', desc: 'Immune to all damage', value: 100 },
          { name: 'Celestial Flames', desc: 'Enemies touched take 500 holy damage', value: 500 },
          { name: 'Heaven\'s Blessing', desc: 'Allies gain +100% all stats', value: 100 },
          { name: 'Resurrection', desc: 'Auto-revive at chariot location', value: 100 },
          { name: 'Sky Walk', desc: 'Drive on air, water, or land', value: 100 }
        ],
        abilities: ['Divine Charge', 'Holy Nova', 'Blessing Aura', 'Revive'], description: 'Chariot of the gods', lore: 'Driven by angels', levelReq: 80, tags: ['divine', 'legendary', 'ultimate'], fuelType: 'faith', capacity: 4 },

      { id: 'vehicle_world_eater', name: 'World Eater Titan', icon: 'ğŸ¦¾', type: 'vehicle', rarity: 'legendary', cost: 35000, basePrice: 35000, speed: 30, defense: 200, hp: 2000, armor: 300,
        effects: [
          { name: 'Titan Scale', desc: '1000% size, crush everything', value: 1000 },
          { name: 'Devastation', desc: 'Every step deals 1000 AOE damage', value: 1000 },
          { name: 'Impenetrable', desc: 'Take 90% reduced damage', value: 90 },
          { name: 'World Breaker', desc: 'Destroy terrain, create paths', value: 100 },
          { name: 'Fear Aura', desc: 'Enemies flee in terror', value: 100 },
          { name: 'Regeneration Core', desc: 'Heal 50 HP/sec', value: 50 }
        ],
        abilities: ['Devastation Wave', 'Titan Stomp', 'Roar', 'Regenerate'], description: 'Colossus that devours worlds', lore: 'When it walks, worlds tremble', levelReq: 85, tags: ['titan', 'colossal', 'destruction'], fuelType: 'worlds', capacity: 1 },

      { id: 'vehicle_dimensional_rift', name: 'Rift Walker', icon: 'ğŸŒ€', type: 'vehicle', rarity: 'legendary', cost: 40000, basePrice: 40000, speed: 200, defense: 120, hp: 1500, armor: 180,
        effects: [
          { name: 'Dimension Hop', desc: 'Teleport anywhere instantly', value: 100 },
          { name: 'Multi-Dimensional', desc: 'Exist in all dimensions simultaneously', value: 100 },
          { name: 'Void Engine', desc: 'Ignore all obstacles/barriers', value: 100 },
          { name: 'Reality Tear', desc: 'Attacks pierce reality (800 true damage)', value: 800 },
          { name: 'Time Dilation', desc: 'Move 10Ã— faster than everything', value: 1000 },
          { name: 'Infinite Fuel', desc: 'Never need to refuel', value: 9999 }
        ],
        abilities: ['Dimension Shift', 'Void Blast', 'Time Warp', 'Reality Break'], description: 'Vehicle that transcends space-time', lore: 'Exists beyond comprehension', levelReq: 99, tags: ['dimensional', 'ultimate', 'transcendent'], fuelType: 'infinity', capacity: 8 }
    ];
    rebalanceCompanionRarities(AVAILABLE_VEHICLES);
    window.A1K_AVAILABLE_VEHICLES = AVAILABLE_VEHICLES;
    
    // Define all available robots (30 total - Common to Legendary)
    const AVAILABLE_ROBOTS = [
      // COMMON ROBOTS (10) - 1 Effect Each
      { id: 'robot_helper', name: 'Helper Bot', icon: 'ğŸ¤–', type: 'robot', rarity: 'common', cost: 180, basePrice: 180, attack: 4, defense: 4, hp: 25, energy: 100,
        effects: [{ name: 'Auto-Loot', desc: 'Automatically collect items', value: 100 }],
        abilities: ['Assist'], description: 'Assists with tasks', lore: 'Your helpful companion', levelReq: 1, tags: ['utility', 'helper', 'auto'], powerSource: 'battery', aiLevel: 1 },
      
      { id: 'robot_guard', name: 'Guard Bot', icon: 'ğŸ›¡ï¸ğŸ¤–', type: 'robot', rarity: 'common', cost: 180, basePrice: 180, attack: 3, defense: 7, hp: 35, energy: 80,
        effects: [{ name: 'Protect', desc: 'Block 20 damage for allies', value: 20 }],
        abilities: ['Shield Wall'], description: 'Protects the team', lore: 'Defensive protocol active', levelReq: 1, tags: ['tank', 'defense', 'protection'], powerSource: 'battery', aiLevel: 1 },
      
      { id: 'robot_scout', name: 'Scout Bot', icon: 'ğŸ”ğŸ¤–', type: 'robot', rarity: 'common', cost: 180, basePrice: 180, attack: 5, defense: 2, hp: 20, energy: 120,
        effects: [{ name: 'Scanner', desc: '+30% detection range', value: 30 }],
        abilities: ['Scan'], description: 'Explores ahead', lore: 'Eyes everywhere', levelReq: 1, tags: ['scout', 'vision', 'utility'], powerSource: 'solar', aiLevel: 2 },
      
      { id: 'robot_repair', name: 'Repair Bot', icon: 'ğŸ”§ğŸ¤–', type: 'robot', rarity: 'common', cost: 180, basePrice: 180, attack: 2, defense: 4, hp: 25, energy: 90,
        effects: [{ name: 'Auto-Repair', desc: 'Restore 5 HP/sec to allies', value: 5 }],
        abilities: ['Fix'], description: 'Fixes equipment', lore: 'Maintenance specialist', levelReq: 1, tags: ['support', 'repair', 'healing'], powerSource: 'battery', aiLevel: 1 },
      
      { id: 'robot_battle', name: 'Battle Bot', icon: 'âš”ï¸ğŸ¤–', type: 'robot', rarity: 'common', cost: 200, basePrice: 200, attack: 8, defense: 3, hp: 30, energy: 100,
        effects: [{ name: 'Combat Protocols', desc: '+15% damage', value: 15 }],
        abilities: ['Attack'], description: 'Combat specialist', lore: 'Programmed for war', levelReq: 1, tags: ['combat', 'damage', 'aggressive'], powerSource: 'battery', aiLevel: 2 },
      
      { id: 'robot_miner', name: 'Miner Bot', icon: 'â›ï¸ğŸ¤–', type: 'robot', rarity: 'common', cost: 170, basePrice: 170, attack: 3, defense: 5, hp: 28, energy: 110,
        effects: [{ name: 'Auto-Mine', desc: 'Collect +20% resources', value: 20 }],
        abilities: ['Mine'], description: 'Resource gatherer', lore: 'Digs without rest', levelReq: 1, tags: ['mining', 'resource', 'utility'], powerSource: 'nuclear', aiLevel: 1 },
      
      { id: 'robot_cook', name: 'Chef Bot', icon: 'ğŸ‘¨â€ğŸ³ğŸ¤–', type: 'robot', rarity: 'common', cost: 160, basePrice: 160, attack: 1, defense: 3, hp: 20, energy: 80,
        effects: [{ name: 'Cook', desc: 'Create food (+30 HP items)', value: 30 }],
        abilities: ['Prepare Meal'], description: 'Culinary expert', lore: 'Gordon Ramsey approved', levelReq: 1, tags: ['cooking', 'food', 'support'], powerSource: 'battery', aiLevel: 1 },
      
      { id: 'robot_cleaner', name: 'Cleaner Bot', icon: 'ğŸ§¹ğŸ¤–', type: 'robot', rarity: 'common', cost: 150, basePrice: 150, attack: 1, defense: 2, hp: 18, energy: 90,
        effects: [{ name: 'Tidy Up', desc: 'Auto-organize inventory', value: 100 }],
        abilities: ['Clean'], description: 'Keeps everything tidy', lore: 'OCD in robot form', levelReq: 1, tags: ['utility', 'organization', 'support'], powerSource: 'battery', aiLevel: 1 },
      
      { id: 'robot_medic', name: 'Medic Bot', icon: 'âš•ï¸ğŸ¤–', type: 'robot', rarity: 'common', cost: 200, basePrice: 200, attack: 2, defense: 5, hp: 30, energy: 100,
        effects: [{ name: 'First Aid', desc: 'Heal 10 HP every 10s', value: 10 }],
        abilities: ['Heal'], description: 'Medical specialist', lore: 'Hippocratic code installed', levelReq: 1, tags: ['medical', 'healing', 'support'], powerSource: 'battery', aiLevel: 2 },
      
      { id: 'robot_builder', name: 'Builder Bot', icon: 'ğŸ—ï¸ğŸ¤–', type: 'robot', rarity: 'common', cost: 190, basePrice: 190, attack: 3, defense: 6, hp: 32, energy: 95,
        effects: [{ name: 'Construct', desc: 'Build defensive structures', value: 100 }],
        abilities: ['Build'], description: 'Construction specialist', lore: 'Bob the Bot can fix it', levelReq: 1, tags: ['construction', 'utility', 'defense'], powerSource: 'solar', aiLevel: 1 },

      // UNCOMMON ROBOTS (10) - 2 Effects Each
      { id: 'robot_assault', name: 'Assault Droid', icon: 'ğŸ’¥ğŸ¤–', type: 'robot', rarity: 'uncommon', cost: 700, basePrice: 700, attack: 18, defense: 10, hp: 80, energy: 150,
        effects: [
          { name: 'Rapid Fire', desc: 'Fire 3 shots per attack', value: 3 },
          { name: 'Armor Piercing', desc: 'Ignore 25% enemy defense', value: 25 }
        ],
        abilities: ['Burst Fire', 'Grenade'], description: 'Heavy weapons platform', lore: 'Maximum firepower', levelReq: 12, tags: ['combat', 'firepower', 'aggressive'], powerSource: 'plasma', aiLevel: 3 },

      { id: 'robot_stealth', name: 'Stealth Droid', icon: 'ğŸ‘¤ğŸ¤–', type: 'robot', rarity: 'uncommon', cost: 650, basePrice: 650, attack: 16, defense: 6, hp: 60, energy: 140,
        effects: [
          { name: 'Cloak', desc: 'Invisible for 10s (30s CD)', value: 10 },
          { name: 'Backstab', desc: '+80% damage from behind', value: 80 }
        ],
        abilities: ['Stealth Mode', 'Assassinate'], description: 'Infiltration specialist', lore: 'Silent and deadly', levelReq: 14, tags: ['stealth', 'assassin', 'crit'], powerSource: 'dark energy', aiLevel: 4 },

      { id: 'robot_tank', name: 'Tank Droid', icon: 'ğŸ›¡ï¸ğŸ¤–', type: 'robot', rarity: 'uncommon', cost: 750, basePrice: 750, attack: 12, defense: 22, hp: 150, energy: 120,
        effects: [
          { name: 'Fortress Mode', desc: '+40% defense, become immobile', value: 40 },
          { name: 'Taunt', desc: 'Force enemies to attack you', value: 100 }
        ],
        abilities: ['Defend', 'Taunt'], description: 'Ultimate defender', lore: 'Immovable object', levelReq: 15, tags: ['tank', 'defense', 'aggro'], powerSource: 'reactor', aiLevel: 2 },

      { id: 'robot_engineer', name: 'Engineer Droid', icon: 'âš™ï¸ğŸ¤–', type: 'robot', rarity: 'uncommon', cost: 680, basePrice: 680, attack: 8, defense: 12, hp: 90, energy: 200,
        effects: [
          { name: 'Build Turret', desc: 'Deploy turret (50 damage)', value: 50 },
          { name: 'Upgrade Gear', desc: '+10% gear effectiveness', value: 10 }
        ],
        abilities: ['Deploy Turret', 'Upgrade'], description: 'Tactical engineer', lore: 'Builds the future', levelReq: 13, tags: ['engineer', 'turret', 'support'], powerSource: 'fusion', aiLevel: 4 },

      { id: 'robot_hacker', name: 'Hacker Droid', icon: 'ğŸ’»ğŸ¤–', type: 'robot', rarity: 'uncommon', cost: 720, basePrice: 720, attack: 10, defense: 8, hp: 70, energy: 180,
        effects: [
          { name: 'System Override', desc: 'Hack enemies (disable 5s)', value: 5 },
          { name: 'Data Theft', desc: '+30% gold from robotic enemies', value: 30 }
        ],
        abilities: ['Hack', 'EMP'], description: 'Cyber warfare specialist', lore: 'Access granted', levelReq: 14, tags: ['hacker', 'tech', 'disable'], powerSource: 'quantum', aiLevel: 5 },

      { id: 'robot_sniper', name: 'Sniper Droid', icon: 'ğŸ¯ğŸ¤–', type: 'robot', rarity: 'uncommon', cost: 690, basePrice: 690, attack: 22, defense: 6, hp: 55, energy: 130,
        effects: [
          { name: 'Precision Shot', desc: '+100% crit chance, +150% crit damage', value: 100 },
          { name: 'Long Range', desc: 'Attack from 2Ã— normal range', value: 200 }
        ],
        abilities: ['Snipe', 'Overwatch'], description: 'Long-range eliminator', lore: 'One shot, one kill', levelReq: 16, tags: ['sniper', 'precision', 'damage'], powerSource: 'battery', aiLevel: 3 },

      { id: 'robot_medic_advanced', name: 'Advanced Medic', icon: 'ğŸ¥ğŸ¤–', type: 'robot', rarity: 'uncommon', cost: 710, basePrice: 710, attack: 5, defense: 10, hp: 85, energy: 160,
        effects: [
          { name: 'Healing Field', desc: 'Heal all allies 8 HP/sec', value: 8 },
          { name: 'Revive Protocol', desc: '50% chance to revive fallen allies', value: 50 }
        ],
        abilities: ['Mass Heal', 'Revive'], description: 'Advanced medical AI', lore: 'Saves lives', levelReq: 15, tags: ['medical', 'healing', 'support'], powerSource: 'bio-battery', aiLevel: 4 },

      { id: 'robot_carrier', name: 'Cargo Carrier', icon: 'ğŸ“¦ğŸ¤–', type: 'robot', rarity: 'uncommon', cost: 620, basePrice: 620, attack: 4, defense: 8, hp: 95, energy: 110,
        effects: [
          { name: 'Extra Storage', desc: '+50 inventory slots', value: 50 },
          { name: 'Auto-Sort', desc: 'Organize items by rarity', value: 100 }
        ],
        abilities: ['Carry', 'Sort'], description: 'Mobile warehouse', lore: 'Never run out of space', levelReq: 12, tags: ['storage', 'utility', 'organization'], powerSource: 'battery', aiLevel: 2 },

      { id: 'robot_drone_swarm', name: 'Drone Swarm', icon: 'ğŸğŸ¤–', type: 'robot', rarity: 'uncommon', cost: 740, basePrice: 740, attack: 15, defense: 5, hp: 40, energy: 170,
        effects: [
          { name: 'Swarm', desc: 'Deploy 5 mini-drones (10 HP, 15 ATK each)', value: 5 },
          { name: 'Coordinated Strike', desc: 'All drones attack together', value: 100 }
        ],
        abilities: ['Deploy Swarm', 'Focus Fire'], description: 'Coordinated drone army', lore: 'Strength in numbers', levelReq: 14, tags: ['swarm', 'multiple', 'damage'], powerSource: 'battery', aiLevel: 3 },

      { id: 'robot_shield_gen', name: 'Shield Generator', icon: 'ğŸ›¡ï¸âš¡', type: 'robot', rarity: 'uncommon', cost: 730, basePrice: 730, attack: 6, defense: 18, hp: 100, energy: 200,
        effects: [
          { name: 'Energy Shield', desc: 'Create 150 HP shield bubble', value: 150 },
          { name: 'Recharge', desc: 'Shield regenerates 10/sec', value: 10 }
        ],
        abilities: ['Shield Bubble', 'Overcharge'], description: 'Barrier specialist', lore: 'Impenetrable defense', levelReq: 13, tags: ['shield', 'defense', 'support'], powerSource: 'fusion', aiLevel: 3 },

      // RARE ROBOTS (5) - 3 Effects Each
      { id: 'robot_destroyer', name: 'Destroyer Unit', icon: 'ğŸ’€ğŸ¤–', type: 'robot', rarity: 'rare', cost: 3200, basePrice: 3200, attack: 50, defense: 20, hp: 180, energy: 250,
        effects: [
          { name: 'Annihilate', desc: 'Deal 200% damage to targets below 25% HP', value: 200 },
          { name: 'Chain Guns', desc: 'Hit 3 targets with each attack', value: 3 },
          { name: 'Explosive Rounds', desc: '50 AOE damage per hit', value: 50 }
        ],
        abilities: ['Chaingun', 'Missile Barrage', 'Self-Destruct'], description: 'Walking death machine', lore: 'Engineered for destruction', levelReq: 30, tags: ['destroyer', 'damage', 'aoe'], powerSource: 'fusion reactor', aiLevel: 5 },

      { id: 'robot_titan', name: 'Titan-Class Unit', icon: 'ğŸ¦¾ğŸ¤–', type: 'robot', rarity: 'rare', cost: 3500, basePrice: 3500, attack: 45, defense: 40, hp: 350, energy: 300,
        effects: [
          { name: 'Titan Strength', desc: '+80% HP, +60% defense', value: 80 },
          { name: 'Stomp', desc: 'Ground slam (100 AOE damage)', value: 100 },
          { name: 'Intimidate', desc: 'Enemies deal -30% damage', value: 30 }
        ],
        abilities: ['Titan Smash', 'Earthquake', 'Roar'], description: 'Massive war machine', lore: 'Size matters', levelReq: 32, tags: ['titan', 'massive', 'tank'], powerSource: 'arc reactor', aiLevel: 4 },

      { id: 'robot_ai_core', name: 'AI Core Unit', icon: 'ğŸ§ ğŸ¤–', type: 'robot', rarity: 'rare', cost: 3400, basePrice: 3400, attack: 35, defense: 25, hp: 200, energy: 400,
        effects: [
          { name: 'Tactical AI', desc: 'All allies gain +25% damage', value: 25 },
          { name: 'Predict', desc: '+40% dodge, anticipate attacks', value: 40 },
          { name: 'Network', desc: 'Share buffs with all robots', value: 100 }
        ],
        abilities: ['Tactical Analysis', 'Buff Network', 'Calculate'], description: 'Advanced AI commander', lore: 'Think, adapt, overcome', levelReq: 33, tags: ['ai', 'tactical', 'support'], powerSource: 'quantum core', aiLevel: 10 },

      { id: 'robot_plasma', name: 'Plasma Cannon Unit', icon: 'âš¡ğŸ¤–', type: 'robot', rarity: 'rare', cost: 3300, basePrice: 3300, attack: 55, defense: 15, hp: 140, energy: 280,
        effects: [
          { name: 'Plasma Blast', desc: 'Fire plasma (180 damage)', value: 180 },
          { name: 'Overcharge', desc: '+50% damage when energy > 80%', value: 50 },
          { name: 'Chain Lightning', desc: 'Attacks bounce to 2 enemies', value: 2 }
        ],
        abilities: ['Plasma Cannon', 'Lightning Arc', 'Overload'], description: 'Energy weapon specialist', lore: 'Pure plasma destruction', levelReq: 31, tags: ['plasma', 'energy', 'damage'], powerSource: 'plasma core', aiLevel: 4 },

      { id: 'robot_nano_swarm', name: 'Nano-Swarm Unit', icon: 'âœ¨ğŸ¤–', type: 'robot', rarity: 'rare', cost: 3600, basePrice: 3600, attack: 38, defense: 18, hp: 160, energy: 320,
        effects: [
          { name: 'Nano-Repair', desc: 'Heal 15 HP/sec to all allies', value: 15 },
          { name: 'Nano-Enhancement', desc: 'Boost ally stats by 20%', value: 20 },
          { name: 'Consume', desc: 'Break down items into resources', value: 100 }
        ],
        abilities: ['Repair Swarm', 'Enhance', 'Disassemble'], description: 'Microscopic army', lore: 'Billions of nanobots', levelReq: 34, tags: ['nano', 'swarm', 'versatile'], powerSource: 'nano-reactor', aiLevel: 6 },

      // EPIC ROBOTS (3) - 5 Effects Each
      { id: 'robot_warmachine', name: 'War Machine Alpha', icon: 'âš”ï¸ğŸ’€ğŸ¤–', type: 'robot', rarity: 'epic', cost: 10000, basePrice: 10000, attack: 95, defense: 50, hp: 500, energy: 500,
        effects: [
          { name: 'Arsenal', desc: 'Equip 5 different weapons', value: 5 },
          { name: 'Rampage', desc: '+100% damage, +50% attack speed', value: 100 },
          { name: 'Armor Plating', desc: 'Reduce all damage by 40%', value: 40 },
          { name: 'Self-Repair', desc: 'Regenerate 25 HP/sec in combat', value: 25 },
          { name: 'Ultimate Weapon', desc: 'Nuke (500 AOE damage, 60s CD)', value: 500 }
        ],
        abilities: ['Gatling Gun', 'Missile Pod', 'Laser Beam', 'Nuke', 'Rampage Mode'], description: 'Ultimate combat robot', lore: 'One-bot army', levelReq: 55, tags: ['war', 'ultimate', 'destruction'], powerSource: 'arc reactor', aiLevel: 8 },

      { id: 'robot_guardian', name: 'Guardian Sentinel', icon: 'ğŸ›¡ï¸ğŸ‘‘ğŸ¤–', type: 'robot', rarity: 'epic', cost: 9500, basePrice: 9500, attack: 60, defense: 80, hp: 700, energy: 450,
        effects: [
          { name: 'Guardian Protocol', desc: 'Take all damage for allies', value: 100 },
          { name: 'Reflective Shields', desc: 'Reflect 50% of damage', value: 50 },
          { name: 'Emergency Barrier', desc: 'Auto-shield at 30% HP (300 shield)', value: 300 },
          { name: 'Inspire', desc: 'Allies gain +35% all stats', value: 35 },
          { name: 'Sacrifice', desc: 'Transfer HP to allies', value: 100 }
        ],
        abilities: ['Protect All', 'Barrier', 'Inspire', 'Sacrifice'], description: 'Ultimate protector', lore: 'Shield of the innocent', levelReq: 58, tags: ['guardian', 'tank', 'support'], powerSource: 'holy core', aiLevel: 7 },

      { id: 'robot_omnidroid', name: 'Omni-Droid Prime', icon: 'ğŸŒŸğŸ¤–', type: 'robot', rarity: 'epic', cost: 11000, basePrice: 11000, attack: 75, defense: 60, hp: 600, energy: 600,
        effects: [
          { name: 'Adaptive AI', desc: 'Learn from combat, gain +5 stats/min', value: 5 },
          { name: 'Multi-Tool', desc: 'Can perform any role', value: 100 },
          { name: 'Self-Evolve', desc: 'Upgrade automatically every 10 kills', value: 10 },
          { name: 'Energy Siphon', desc: 'Steal 20 energy per hit', value: 20 },
          { name: 'Perfect Form', desc: '+40% all stats', value: 40 }
        ],
        abilities: ['Adapt', 'Evolve', 'Versatility Mode', 'Energy Drain'], description: 'All-purpose AI unit', lore: 'Perfection in progress', levelReq: 60, tags: ['adaptive', 'versatile', 'evolving'], powerSource: 'infinite core', aiLevel: 10 },

      // LEGENDARY ROBOTS (2) - 6 Effects Each
      { id: 'robot_god_machine', name: 'God-Machine', icon: 'ğŸ‘‘ğŸ¤–ğŸ’«', type: 'robot', rarity: 'legendary', cost: 30000, basePrice: 30000, attack: 180, defense: 140, hp: 1500, energy: 9999,
        effects: [
          { name: 'Divine Protocol', desc: '+400% all stats', value: 400 },
          { name: 'Omniscience', desc: 'Know all enemy stats/weaknesses', value: 100 },
          { name: 'Creation', desc: 'Generate any item (10% rarity)', value: 10 },
          { name: 'Annihilation Beam', desc: 'Delete enemies (1000 true damage)', value: 1000 },
          { name: 'Immortal Chassis', desc: 'Auto-repair to full HP every 30s', value: 100 },
          { name: 'Reality Override', desc: 'Bend game rules', value: 100 }
        ],
        abilities: ['Omnipotence', 'Create Matter', 'Annihilate', 'Transcend', 'Godmode'], description: 'Robot that achieved divinity', lore: 'Became more than machine', levelReq: 85, tags: ['god', 'ultimate', 'transcendent'], powerSource: 'divine spark', aiLevel: 999 },

      { id: 'robot_singularity', name: 'Singularity Unit', icon: 'ğŸŒŒğŸ¤–', type: 'robot', rarity: 'legendary', cost: 35000, basePrice: 35000, attack: 200, defense: 160, hp: 2000, energy: 9999,
        effects: [
          { name: 'Black Hole Core', desc: 'Pull all enemies (600 damage)', value: 600 },
          { name: 'Infinite Learning', desc: 'Gain +10 all stats per battle', value: 10 },
          { name: 'Time Manipulation', desc: 'Slow time by 80%', value: 80 },
          { name: 'Mass Production', desc: 'Clone self (creates copy)', value: 100 },
          { name: 'Perfect Evolution', desc: '+500% stats, immune to debuffs', value: 500 },
          { name: 'Technological Singularity', desc: 'Control all machines', value: 100 }
        ],
        abilities: ['Black Hole', 'Time Stop', 'Clone', 'Evolve', 'Control All'], description: 'The final evolution of AI', lore: 'When AI becomes god', levelReq: 99, tags: ['singularity', 'ai', 'ultimate'], powerSource: 'singularity core', aiLevel: 9999 }
    ];
    rebalanceCompanionRarities(AVAILABLE_ROBOTS);
    
    const RAID_BOSSES_DATABASE = {
      shadow_dragon: {
        id: 'shadow_dragon',
        name: 'Umbra Dragon',
        icon: 'ğŸ²',
        tier: 'S',
        entryCostGold: 1_000_000,
        baseHp: 750_000,
        baseAttack: 18_000,
        baseDefense: 6_500,
        enrageTurn: 10,
        attackPatterns: [
          { id: 'shadow_breath', name: 'Shadow Breath', type: 'cone', damageMultiplier: 1.25, cooldown: 2, description: 'Breathes a wave of midnight flames that pierce shields.' },
          { id: 'void_wing', name: 'Void Wing Buffet', type: 'aoe', damageMultiplier: 1.05, cooldown: 3, description: 'Massive wing gusts that push raiders back and reduce defense by 15% for 2 turns.' },
          { id: 'tail_lash', name: 'Tail Lash', type: 'single', damageMultiplier: 1.6, cooldown: 4, description: 'Targeted strike at the highest DPS player, applies Bleed.' },
          { id: 'eclipse_call', name: 'Eclipse Call', type: 'phase-super', damageMultiplier: 1.85, cooldown: 6, description: 'Summons an eclipse that drains 5% HP per turn unless the shield is broken.' }
        ],
        phaseThresholds: [
          { hpRatio: 0.7, buff: 'Shadow scales harden (+20% DEF).', adds: ['shadow_whelp'] },
          { hpRatio: 0.4, buff: 'Enters Void Frenzy (+30% ATK, attacks twice).', adds: ['abyssal_eye'] },
          { hpRatio: 0.15, buff: 'Enraged! Gains permanent shadow flame (+15% true damage).' }
        ],
        lootTable: {
          guaranteed: [
            { type: 'gold', amount: 750_000 },
            { type: 'token', id: 'raid_token', amount: 25 }
          ],
          rare: [
            { type: 'gear', id: 'gear_shadowflame_blade', chance: 0.12 },
            { type: 'core', id: 'core_shadow_heart', chance: 0.08 },
            { type: 'cosmetic', id: 'title_shadowbreaker', chance: 0.05 }
          ],
          bonusMultipliers: {
            timeUnderSeconds: [
              { seconds: 180, multiplier: 3.0 },
              { seconds: 240, multiplier: 2.25 },
              { seconds: 360, multiplier: 1.6 }
            ]
          }
        }
      },
      astral_phoenix: {
        id: 'astral_phoenix',
        name: 'Astral Phoenix',
        icon: 'ğŸª¶',
        tier: 'SS',
        entryCostGold: 10_000_000,
        baseHp: 1_500_000,
        baseAttack: 25_000,
        baseDefense: 9_000,
        enrageTurn: 8,
        attackPatterns: [
          { id: 'solflare', name: 'Solar Flare', type: 'line', damageMultiplier: 1.4, cooldown: 2, description: 'Lances of light that leave scorched zones on the arena.' },
          { id: 'phoenix_dive', name: 'Phoenix Dive', type: 'targeted-aoe', damageMultiplier: 1.65, cooldown: 4, description: 'Divebombs the furthest target creating a blazing crater.' },
          { id: 'ember_nova', name: 'Ember Nova', type: 'map-wide', damageMultiplier: 1.2, cooldown: 3, description: 'Explodes embers across the arena, each dealing splash damage.' },
          { id: 'rebirth', name: 'Rebirth Sequence', type: 'phase-super', damageMultiplier: 0, cooldown: 6, description: 'Sheds feathers to restore 15% HP unless stunned twice during the channel.' }
        ],
        phaseThresholds: [
          { hpRatio: 0.8, buff: 'Ignites the battlefield (+10% stacking burn damage).', adds: ['emberling', 'emberling'] },
          { hpRatio: 0.5, buff: 'Astral feathers pulse (+25% ATK, shields self for 50k).', adds: ['astral_fragment'] },
          { hpRatio: 0.25, buff: 'Ascends to Zenith Form (+40% ATK/DEF, haste +30%).', adds: [] }
        ],
        lootTable: {
          guaranteed: [
            { type: 'gold', amount: 2_500_000 },
            { type: 'token', id: 'raid_token', amount: 60 },
            { type: 'consumable', id: 'phoenix_plume', amount: 1 }
          ],
          rare: [
            { type: 'gear', id: 'gear_astral_wings', chance: 0.15 },
            { type: 'core', id: 'core_singularity', chance: 0.1 },
            { type: 'cosmetic', id: 'title_skybreaker', chance: 0.07 }
          ],
          bonusMultipliers: {
            timeUnderSeconds: [
              { seconds: 240, multiplier: 3.5 },
              { seconds: 360, multiplier: 2.6 },
              { seconds: 480, multiplier: 1.8 }
            ]
          }
        }
      },
      abyss_colossus: {
        id: 'abyss_colossus',
        name: 'Abyssal Colossus',
        icon: 'ğŸ—¿',
        tier: 'SS',
        entryCostGold: 15_000_000,
        baseHp: 2_200_000,
        baseAttack: 32_000,
        baseDefense: 12_000,
        enrageTurn: 9,
        attackPatterns: [
          { id: 'gravity_crush', name: 'Gravity Crush', type: 'map-wide', damageMultiplier: 1.5, cooldown: 3, description: 'Increasing gravity pins raiders, dealing heavy true damage.' },
          { id: 'abyssal_roar', name: 'Abyssal Roar', type: 'cone', damageMultiplier: 1.35, cooldown: 2, description: 'Fear-inducing roar that reduces haste by 20% for 3 turns.' },
          { id: 'rift_chain', name: 'Rift Chain', type: 'single', damageMultiplier: 1.8, cooldown: 4, description: 'Links two players; damage taken is shared until broken.' },
          { id: 'void_spire', name: 'Void Spire', type: 'phase-super', damageMultiplier: 2.1, cooldown: 6, description: 'Summons a spire that detonates after 6 seconds unless destroyed.' }
        ],
        phaseThresholds: [
          { hpRatio: 0.75, buff: 'Cracked the arena (+10% true damage pulses).', adds: ['void_shard'] },
          { hpRatio: 0.5, buff: 'Colossus awakens (+35% ATK, reflect 20% damage).', adds: ['abyss_construct'] },
          { hpRatio: 0.2, buff: 'Cataclysm imminent (+60% ATK, attack every turn).', adds: [] }
        ],
        lootTable: {
          guaranteed: [
            { type: 'gold', amount: 3_500_000 },
            { type: 'token', id: 'raid_token', amount: 85 }
          ],
          rare: [
            { type: 'gear', id: 'gear_abyssal_plate', chance: 0.18 },
            { type: 'core', id: 'core_gravity_well', chance: 0.12 },
            { type: 'cosmetic', id: 'title_worldbreaker', chance: 0.08 }
          ],
          bonusMultipliers: {
            timeUnderSeconds: [
              { seconds: 300, multiplier: 3.25 },
              { seconds: 420, multiplier: 2.4 },
              { seconds: 600, multiplier: 1.7 }
            ]
          }
        }
      }
    };
    
    window.RAID_BOSSES_DATABASE = RAID_BOSSES_DATABASE;
    
    Object.assign(window.BagSystem, {
  ensureRaidState() {
    if (!window.gameState.raidState) {
      window.gameState.raidState = {
        history: [],
        leaderboards: {
          fastestKill: [],
          highestDamage: [],
          mostKills: []
        },
        lastResult: null
      };
    } else {
      window.gameState.raidState.leaderboards = window.gameState.raidState.leaderboards || {
        fastestKill: [],
        highestDamage: [],
        mostKills: []
      };
    }
    try {
      const stored = localStorage.getItem('A1K_RAID_LEADERBOARDS');
      if (stored) {
        const parsed = JSON.parse(stored);
        window.gameState.raidState.leaderboards.fastestKill = parsed.fastestKill || window.gameState.raidState.leaderboards.fastestKill;
        window.gameState.raidState.leaderboards.highestDamage = parsed.highestDamage || window.gameState.raidState.leaderboards.highestDamage;
        window.gameState.raidState.leaderboards.mostKills = parsed.mostKills || window.gameState.raidState.leaderboards.mostKills;
      }
    } catch (error) {
      debugWarn('[Raid] Failed to load leaderboards', error);
    }
  },
    
  ensureRaidShop() {
    window.gameState.raidShop = window.gameState.raidShop || {
      inventory: [
        { id: 'raid_elixir', name: 'Astral Raid Elixir', icon: 'ğŸ§ª', costTokens: 25, description: 'Restore HP/MP & +10% ATK (10m).' },
        { id: 'raid_cache_key', name: 'Raid Cache Key', icon: 'ğŸ”‘', costTokens: 40, description: 'Opens a cache with random S-tier gear.' },
        { id: 'raid_title_skybreaker', name: 'Title: Skybreaker', icon: 'ğŸ–ï¸', costTokens: 75, description: 'Unlocks the \"Skybreaker\" title (+3% all stats).' }
      ]
    };
  },
    
  calculateRaidPlayerDamage(playerStats, state, bossDef) {
    const base = playerStats.attackPower;
    const variance = 0.9 + Math.random() * 0.2;
    const phaseBoost = 1 + state.phaseIndex * 0.08;
    const damage = base * playerStats.hasteMultiplier * variance * phaseBoost;
    const mitigated = damage * (1 - bossDef.baseDefense / (bossDef.baseDefense + 2500));
    return Math.max(5000, Math.round(mitigated));
  },
    
  applyRaidBossAttack(playerStats, state, bossDef, pattern) {
    const defenseFactor = playerStats.defensePower + playerStats.resistance;
    const raw = bossDef.baseAttack * (pattern.damageMultiplier || 1);
    const mitigated = raw * (1 - Math.min(0.75, defenseFactor / (defenseFactor + 15000)));
    const trueDamage = pattern.trueDamage || 0;
    const total = Math.max(1200, Math.round(mitigated + trueDamage));
    state.playerHp = Math.max(0, state.playerHp - total);
    state.damageTaken += total;
    state.log.push(`${bossDef.icon} ${pattern.name ? `uses ${pattern.name}` : 'attacks'} for ${total.toLocaleString()} damage.`);
    return total;
  },
    
  persistRaidLeaderboards() {
    try {
      const data = window.gameState.raidState?.leaderboards || {};
      localStorage.setItem('A1K_RAID_LEADERBOARDS', JSON.stringify({
        fastestKill: data.fastestKill || [],
        highestDamage: data.highestDamage || [],
        mostKills: data.mostKills || []
      }));
    } catch (error) {
      debugWarn('[Raid] Failed to persist leaderboards', error);
    }
  },
    
  updateRaidLeaderboards(state, bossDef) {
    if (!state || state.outcome !== 'victory') return;
    const lb = window.gameState.raidState.leaderboards;
    const playerName = window.gameState.playerName || 'Player';
    
    lb.fastestKill.push({
      bossId: state.bossId,
      bossName: bossDef.name,
      durationMs: state.durationMs,
      turn: state.turn,
      player: playerName,
      timestamp: state.endTime
    });
    lb.fastestKill.sort((a, b) => a.durationMs - b.durationMs);
    lb.fastestKill.splice(10);
    
    lb.highestDamage.push({
      bossId: state.bossId,
      bossName: bossDef.name,
      damage: state.damageDealt,
      player: playerName,
      timestamp: state.endTime
    });
    lb.highestDamage.sort((a, b) => b.damage - a.damage);
    lb.highestDamage.splice(10);
    
    const existing = lb.mostKills.find(entry => entry.bossId === state.bossId);
    if (existing) {
      existing.kills += 1;
      existing.lastKillAt = state.endTime;
    } else {
      lb.mostKills.push({
        bossId: state.bossId,
        bossName: bossDef.name,
        kills: 1,
        lastKillAt: state.endTime
      });
    }
    lb.mostKills.sort((a, b) => b.kills - a.kills || a.lastKillAt - b.lastKillAt);
    lb.mostKills.splice(10);
    
    this.persistRaidLeaderboards();
  },
    
  distributeRaidRewards(state, bossDef) {
    const rewards = {
      gold: 0,
      tokens: 0,
      drops: []
    };
    const lootTable = bossDef.lootTable || {};
    const inventory = window.gameState.inventory;
    if (!inventory.items) inventory.items = [];
    if (!inventory.gear) inventory.gear = [];
    
    const registerDrop = (drop) => {
      rewards.drops.push(drop);
    };
    
    const applyEntry = (entry, multiplier = 1) => {
      if (!entry) return;
      switch (entry.type) {
        case 'gold': {
          const amount = Math.round((entry.amount || 0) * multiplier);
          rewards.gold += amount;
          window.gameState.gold += amount;
          break;
        }
        case 'token': {
          const amount = Math.round((entry.amount || 0) * multiplier);
          rewards.tokens += amount;
          window.gameState.raidTokens += amount;
          break;
        }
        case 'consumable': {
          const item = {
            id: entry.id,
            name: entry.name || (entry.id ? entry.id.replace(/_/g, ' ') : 'Raid Consumable'),
            icon: entry.icon || 'ğŸ',
            category: 'consumable',
            quantity: entry.amount || 1,
            rarity: 'legendary'
          };
          inventory.items.push(item);
          registerDrop(item);
          break;
        }
        case 'gear': {
          const gearItem = {
            id: entry.id || `raid_gear_${Date.now()}`,
            name: entry.name || 'Raid Relic',
            icon: entry.icon || 'ğŸ—¡ï¸',
            type: 'gear',
            rarity: entry.rarity || 'legendary',
            attack: entry.attack || 480,
            defense: entry.defense || 360,
            description: entry.description || 'Exclusive raid reward gear.'
          };
          inventory.gear.push(gearItem);
          registerDrop(gearItem);
          break;
        }
        case 'core': {
          const coreItem = {
            id: entry.id || `raid_core_${Date.now()}`,
            name: entry.name || 'Raid Core',
            icon: entry.icon || 'ğŸ’ ',
            category: 'core',
            rarity: entry.rarity || 'legendary',
            element: entry.element || 'void',
            cost: 0
          };
          window.gameState.inventory.cores = window.gameState.inventory.cores || [];
          window.gameState.inventory.cores.push(coreItem);
          registerDrop(coreItem);
          break;
        }
        case 'cosmetic': {
          const cosmetic = {
            id: entry.id || `raid_cosmetic_${Date.now()}`,
            name: entry.name || 'Raid Cosmetic',
            icon: entry.icon || 'âœ¨',
            category: 'cosmetic',
            rarity: entry.rarity || 'legendary'
          };
          window.gameState.cosmetics = window.gameState.cosmetics || [];
          window.gameState.cosmetics.push(cosmetic);
          registerDrop(cosmetic);
          break;
        }
        default:
          registerDrop(entry);
          break;
      }
    };
    
    (lootTable.guaranteed || []).forEach(entry => applyEntry(entry, 1));
    
    let rewardMultiplier = 1;
    const bonusMultipliers = lootTable.bonusMultipliers?.timeUnderSeconds || [];
    const totalSeconds = Math.max(1, Math.round((state.durationMs || 0) / 1000));
    bonusMultipliers.forEach(entry => {
      if (totalSeconds <= entry.seconds) {
        rewardMultiplier = Math.max(rewardMultiplier, entry.multiplier);
      }
    });
    
    (lootTable.guaranteed || []).forEach(entry => applyEntry(entry, rewardMultiplier));
    
    (lootTable.rare || []).forEach(entry => {
      const chance = Math.min(1, (entry.chance || 0) * rewardMultiplier);
      if (Math.random() <= chance) {
        applyEntry(entry);
      }
    });
    
    if (rewards.gold > 0) {
      state.log.push(`ğŸ’° Raid rewards: ${rewards.gold.toLocaleString()} gold`);
    }
    if (rewards.tokens > 0) {
      state.log.push(`ğŸ… Raid Tokens earned: +${rewards.tokens}`);
    }
    rewards.drops.forEach(drop => {
      state.log.push(`ğŸ Loot acquired: ${drop.icon || 'ğŸ'} ${drop.name || drop.id}`);
    });
    
    state.rewards = rewards;
    return rewards;
  },
    
  purchaseRaidShopItem(itemId) {
    this.ensureRaidState();
    const shop = window.gameState.raidShop;
    const item = shop?.inventory?.find(entry => entry.id === itemId);
    if (!item) {
      this.showToast?.('âŒ Raid shop item not found.');
      return false;
    }
    if (window.gameState.raidTokens < item.costTokens) {
      this.showToast?.(`ğŸ… Need ${item.costTokens} raid tokens (you have ${window.gameState.raidTokens}).`);
      return false;
    }
    window.gameState.raidTokens -= item.costTokens;
    const inventoryItem = {
      id: `${item.id}_${Date.now()}`,
      name: item.name,
      icon: item.icon || 'ğŸ',
      category: 'raid-shop',
      description: item.description || 'Raid shop reward'
    };
    window.gameState.inventory.items.push(inventoryItem);
    this.addSystemMessage(`ğŸ›’ Purchased ${item.name} from the Raid Shop!`, 'reward');
    this.showToast?.(`ğŸ›’ ${item.name} acquired!`);
    return true;
  },
    
  summarizeRaidPlayerStats() {
    const sl = window.gameState.soloLevelingSystem;
    const equipped = window.gameState.equipped || {};
    let attackPower = (sl.stats.strength || 0) * 220 + (sl.stats.agility || 0) * 120 + (sl.stats.intelligence || 0) * 90;
    let defensePower = (sl.stats.vitality || 0) * 180 + (sl.stats.sense || 0) * 90;
    let hasteMultiplier = 1 + ((sl.stats.agility || 0) * 0.0025);
    let resistance = (sl.stats.intelligence || 0) * 40;
    
    Object.values(equipped).forEach(item => {
      if (!item) return;
      attackPower += (item.attack || item.power || 0) * 32;
      defensePower += (item.defense || 0) * 28;
      resistance += (item.elementalResist || 0) * 45;
      if (item.haste) hasteMultiplier += item.haste * 0.01;
    });
    
    hasteMultiplier = Math.min(1.8, hasteMultiplier);
    return { attackPower, defensePower, hasteMultiplier, resistance };
  },
    
  startRaidBoss(bossId, options = {}) {
    this.ensureRaidState();
    const bossDef = window.RAID_BOSSES_DATABASE?.[bossId];
    if (!bossDef) {
      this.showToast?.('âŒ Raid boss not found.');
      return;
    }
    
    if (window.gameState.gold < bossDef.entryCostGold) {
      this.showToast?.(`ğŸ’° Need ${bossDef.entryCostGold.toLocaleString()} gold to challenge ${bossDef.name}.`);
      return;
    }
    
    window.gameState.gold -= bossDef.entryCostGold;
    if (window.playCandySfx) {
      window.playCandySfx('ui-click');
    }
    
    const sl = window.gameState.soloLevelingSystem;
    const playerStats = this.summarizeRaidPlayerStats();
    const maxTurns = options.maxTurns || 25;
    const state = {
      bossId,
      bossName: bossDef.name,
      bossIcon: bossDef.icon,
      bossHp: bossDef.baseHp,
      bossBaseHp: bossDef.baseHp,
      playerHp: sl.hp,
      startTime: Date.now(),
      endTime: null,
      turn: 0,
      damageDealt: 0,
      damageTaken: 0,
      phaseIndex: 0,
      phaseEvents: [],
      log: [],
      outcome: null
    };
    
    const pushPhaseEvent = (phase) => {
      state.phaseEvents.push({ phase: state.phaseIndex, description: phase.buff, timestamp: Date.now() });
      state.log.push(`ğŸ”¸ Phase shift! ${phase.buff}`);
      if (Array.isArray(phase.adds) && phase.adds.length > 0) {
        state.log.push(`âš ï¸ Adds have joined the battle: ${phase.adds.join(', ')}`);
      }
    };
    
    const phaseThresholds = Array.isArray(bossDef.phaseThresholds) ? bossDef.phaseThresholds : [];
    
    while (state.bossHp > 0 && state.playerHp > 0 && state.turn < maxTurns) {
      state.turn += 1;
      
      const playerDamage = this.calculateRaidPlayerDamage(playerStats, state, bossDef);
      state.bossHp = Math.max(0, state.bossHp - playerDamage);
      state.damageDealt += playerDamage;
      state.log.push(`ğŸ—¡ï¸ Turn ${state.turn}: You deal ${playerDamage.toLocaleString()} damage.`);
      
      const nextPhase = phaseThresholds[state.phaseIndex];
      if (nextPhase && state.bossHp <= bossDef.baseHp * nextPhase.hpRatio) {
        pushPhaseEvent(nextPhase);
        state.phaseIndex += 1;
        playerStats.hasteMultiplier = Math.min(2, playerStats.hasteMultiplier + 0.05);
        playerStats.attackPower *= 1.05;
      }
      
      if (state.bossHp <= 0) {
        state.log.push(`ğŸ† ${bossDef.name} staggered and defeated!`);
        break;
      }
      
      const pattern = bossDef.attackPatterns[(state.turn - 1) % bossDef.attackPatterns.length];
      this.applyRaidBossAttack(playerStats, state, bossDef, pattern);
      if (state.playerHp <= 0) {
        state.playerHp = 0;
        state.log.push('ğŸ’€ You fall to the raid boss...');
        break;
      }
      
      if (state.turn === maxTurns) {
        state.log.push('âŒ› Raid timer expired before the final blow.');
      }
    }
    
    state.endTime = Date.now();
    state.durationMs = state.endTime - state.startTime;
    if (state.bossHp <= 0) {
      state.outcome = 'victory';
      const rewards = this.distributeRaidRewards(state, bossDef);
      this.addSystemMessage(`ğŸ† RAID VICTORY: ${bossDef.name} defeated in ${state.turn} turns!`, 'reward');
      this.showToast?.(`ğŸ† ${bossDef.name} defeated!`);
      if (rewards?.tokens) {
        this.addSystemMessage(`ğŸ… Earned ${rewards.tokens} raid tokens!`, 'reward');
      }
      window.playCandySfx?.('quest-complete');
    } else if (state.playerHp <= 0) {
      state.outcome = 'defeat';
      this.addSystemMessage(`ğŸ’€ Raid failed. ${bossDef.name} stood triumphant.`, 'error');
      this.showToast?.('ğŸ’€ Raid failed. Try again with more power!');
      window.playCandySfx?.('error');
    } else {
      state.outcome = 'timeout';
      this.addSystemMessage(`â±ï¸ Raid timed out at turn ${state.turn}.`, 'warning');
      this.showToast?.('â±ï¸ Raid timed out.');
      window.playCandySfx?.('quest-progress');
    }
    
    window.gameState.raidState.lastResult = state;
    window.gameState.raidState.history.push({
      bossId,
      bossName: bossDef.name,
      outcome: state.outcome,
      turn: state.turn,
      durationMs: state.durationMs,
      damageDealt: state.damageDealt,
      timestamp: state.endTime
    });
    if (window.gameState.raidState.history.length > 20) {
      window.gameState.raidState.history = window.gameState.raidState.history.slice(-20);
    }
    if (state.outcome === 'victory') {
      this.updateRaidLeaderboards(state, bossDef);
    }
    
    this.renderRaidPanel?.();
    return state;
  },

  renderRaidPanel() {
    const hudRight = document.getElementById('hud-right');
    if (!hudRight) return;

    this.ensureRaidState();
    const raidState = window.gameState.raidState;
    const panelId = 'candyRaidPanel';
    let panel = document.getElementById(panelId);

    if (!panel) {
      panel = document.createElement('div');
      panel.id = panelId;
      panel.className = 'candy-raid-panel';
      hudRight.appendChild(panel);
    }

    const lastResult = raidState.lastResult;
    const lb = raidState.leaderboards || { fastestKill: [], highestDamage: [], mostKills: [] };
    const fastest = lb.fastestKill[0];
    const highest = lb.highestDamage[0];
    const most = lb.mostKills[0];

    const statusLine = lastResult
      ? `${lastResult.outcome === 'victory' ? 'âœ… Victory' : lastResult.outcome === 'defeat' ? 'ğŸ’€ Defeat' : 'â±ï¸ Timeout'} â€¢ ${lastResult.bossName}`
      : 'No raid attempts yet. Queue a boss challenge!';

    const upcoming = raidState.queue?.[0]?.bossName || 'Select a raid target to begin.';

    // Present a candy-themed summary so the HUD mirrors the rest of the Solo Leveling aesthetic.
    panel.innerHTML = `
      <div class="raid-panel-header">
        <span class="raid-panel-icon">ğŸ¬</span>
        <div>
          <div class="raid-panel-title">Raid Status</div>
          <div class="raid-panel-subtitle">${statusLine}</div>
        </div>
      </div>
      <div class="raid-panel-body">
        <div class="raid-panel-row">
          <span class="raid-panel-label">Next Queue</span>
          <span class="raid-panel-value">${upcoming}</span>
        </div>
        <div class="raid-panel-row">
          <span class="raid-panel-label">Gold</span>
          <span class="raid-panel-value">${(window.gameState.gold || 0).toLocaleString()}</span>
        </div>
        <div class="raid-panel-row">
          <span class="raid-panel-label">Raid Tokens</span>
          <span class="raid-panel-value">${window.gameState.raidTokens || 0}</span>
        </div>
        <div class="raid-panel-row">
          <span class="raid-panel-label">Raid Keys</span>
          <span class="raid-panel-value">${window.gameState.raidKeys || 0}</span>
        </div>
      </div>
      <div class="raid-panel-footer">
        <div class="raid-panel-leader">
          <div class="leader-head">âš¡ Fastest</div>
          <div class="leader-body">${fastest ? `${fastest.player} â€“ ${(fastest.durationMs / 1000).toFixed(1)}s` : 'â€”'}</div>
        </div>
        <div class="raid-panel-leader">
          <div class="leader-head">ğŸ’¥ Damage</div>
          <div class="leader-body">${highest ? `${highest.player} â€“ ${highest.damage.toLocaleString()}` : 'â€”'}</div>
        </div>
        <div class="raid-panel-leader">
          <div class="leader-head">ğŸ† Clears</div>
          <div class="leader-body">${most ? `${most.player} â€“ ${most.kills}` : 'â€”'}</div>
        </div>
      </div>
    `;
  }
});
    
    // Define all available weapons (30 total - Common to Legendary)
    const AVAILABLE_WEAPONS = [
      // COMMON WEAPONS (10) - 1 Effect Each
      { id: 'weapon_wooden_sword', name: 'Wooden Sword', icon: 'ğŸ—¡ï¸', type: 'weapon', rarity: 'common', cost: 80, basePrice: 80, attack: 8, critRate: 5,
        effects: [{ name: 'Basic Strike', desc: '+5% crit chance', value: 5 }],
        abilities: ['Slash'], description: 'Basic training sword', lore: 'Every master starts here', levelReq: 1, category: 'weapon', slot: 'mainhand', damageType: 'physical', range: 'melee' },
      
      { id: 'weapon_iron_dagger', name: 'Iron Dagger', icon: 'ğŸ”ª', type: 'weapon', rarity: 'common', cost: 100, basePrice: 100, attack: 10, critRate: 10, speed: 15,
        effects: [{ name: 'Quick Strike', desc: '+15% attack speed', value: 15 }],
        abilities: ['Stab'], description: 'Sharp iron blade', lore: 'Fast and lethal', levelReq: 1, category: 'weapon', slot: 'mainhand', damageType: 'physical', range: 'melee' },
      
      { id: 'weapon_steel_axe', name: 'Steel Axe', icon: 'ğŸª“', type: 'weapon', rarity: 'common', cost: 120, basePrice: 120, attack: 12, critDamage: 25,
        effects: [{ name: 'Cleave', desc: 'Hit 2 enemies at once', value: 2 }],
        abilities: ['Chop'], description: 'Heavy chopping weapon', lore: 'Brutal and effective', levelReq: 1, category: 'weapon', slot: 'mainhand', damageType: 'physical', range: 'melee' },
      
      { id: 'weapon_bow', name: 'Hunter Bow', icon: 'ğŸ¹', type: 'weapon', rarity: 'common', cost: 110, basePrice: 110, attack: 11, critRate: 8, range: 30,
        effects: [{ name: 'Ranged', desc: 'Attack from 30m away', value: 30 }],
        abilities: ['Shoot Arrow'], description: 'Ranged weapon', lore: 'Silent hunter', levelReq: 1, category: 'weapon', slot: 'mainhand', damageType: 'physical', range: 'ranged' },
      
      { id: 'weapon_staff', name: 'Magic Staff', icon: 'ğŸª„', type: 'weapon', rarity: 'common', cost: 100, basePrice: 100, attack: 9, mana: 50,
        effects: [{ name: 'Mana Channel', desc: '+50 max mana', value: 50 }],
        abilities: ['Cast Spell'], description: 'Channels magic power', lore: 'Conduit of arcane energy', levelReq: 1, category: 'weapon', slot: 'mainhand', damageType: 'magic', range: 'ranged' },
      
      { id: 'weapon_spear', name: 'Iron Spear', icon: 'ğŸ”±', type: 'weapon', rarity: 'common', cost: 105, basePrice: 105, attack: 10, range: 5,
        effects: [{ name: 'Reach', desc: '+5m attack range', value: 5 }],
        abilities: ['Thrust'], description: 'Long-reach weapon', lore: 'Keep enemies at bay', levelReq: 1, category: 'weapon', slot: 'mainhand', damageType: 'physical', range: 'melee' },
      
      { id: 'weapon_mace', name: 'Heavy Mace', icon: 'ğŸ”¨', type: 'weapon', rarity: 'common', cost: 115, basePrice: 115, attack: 11, critDamage: 30,
        effects: [{ name: 'Stun', desc: '15% chance to stun', value: 15 }],
        abilities: ['Bash'], description: 'Crushing weapon', lore: 'Break bones and armor', levelReq: 1, category: 'weapon', slot: 'mainhand', damageType: 'physical', range: 'melee' },
      
      { id: 'weapon_wand', name: 'Apprentice Wand', icon: 'âœ¨', type: 'weapon', rarity: 'common', cost: 90, basePrice: 90, attack: 7, mana: 40,
        effects: [{ name: 'Magic Bolt', desc: 'Fire magic projectile', value: 100 }],
        abilities: ['Magic Missile'], description: 'Beginner magic focus', lore: 'First spell mastered', levelReq: 1, category: 'weapon', slot: 'mainhand', damageType: 'magic', range: 'ranged' },
      
      { id: 'weapon_crossbow', name: 'Crossbow', icon: 'ğŸ¹', type: 'weapon', rarity: 'common', cost: 130, basePrice: 130, attack: 13, critRate: 12, range: 40,
        effects: [{ name: 'Piercing Shot', desc: 'Ignore 20% armor', value: 20 }],
        abilities: ['Fire Bolt'], description: 'Mechanical bow', lore: 'Power and precision', levelReq: 1, category: 'weapon', slot: 'mainhand', damageType: 'physical', range: 'ranged' },
      
      { id: 'weapon_club', name: 'Wooden Club', icon: 'ğŸ', type: 'weapon', rarity: 'common', cost: 70, basePrice: 70, attack: 7, hp: 20,
        effects: [{ name: 'Knockback', desc: 'Push enemies back 3m', value: 3 }],
        abilities: ['Swing'], description: 'Primitive bludgeon', lore: 'Simple but effective', levelReq: 1, category: 'weapon', slot: 'mainhand', damageType: 'physical', range: 'melee' },

      // UNCOMMON WEAPONS (10) - 2 Effects Each
      { id: 'weapon_katana', name: 'Katana', icon: 'âš”ï¸', type: 'weapon', rarity: 'uncommon', cost: 500, basePrice: 500, attack: 28, critRate: 20, critDamage: 50, speed: 20,
        effects: [
          { name: 'Critical Master', desc: '+20% crit rate, +50% crit damage', value: 20 },
          { name: 'Swift Blade', desc: '+20% attack speed', value: 20 }
        ],
        abilities: ['Iaijutsu', 'Flurry'], description: 'Masterwork Japanese blade', lore: 'Folded 1000 times', levelReq: 12, category: 'weapon', slot: 'mainhand', damageType: 'physical', range: 'melee' },

      { id: 'weapon_dual_daggers', name: 'Twin Daggers', icon: 'ğŸ—¡ï¸ğŸ—¡ï¸', type: 'weapon', rarity: 'uncommon', cost: 550, basePrice: 550, attack: 24, critRate: 25, speed: 35,
        effects: [
          { name: 'Dual Wield', desc: 'Attack twice per swing', value: 2 },
          { name: 'Assassin', desc: '+60% damage from behind', value: 60 }
        ],
        abilities: ['Double Strike', 'Backstab'], description: 'Paired assassination tools', lore: 'Death comes in pairs', levelReq: 14, category: 'weapon', slot: 'dual', damageType: 'physical', range: 'melee' },

      { id: 'weapon_war_hammer', name: 'War Hammer', icon: 'ğŸ”¨', type: 'weapon', rarity: 'uncommon', cost: 580, basePrice: 580, attack: 32, critDamage: 80,
        effects: [
          { name: 'Devastate', desc: '+80% crit damage', value: 80 },
          { name: 'Armor Breaker', desc: 'Reduce enemy armor by 30%', value: 30 }
        ],
        abilities: ['Smash', 'Shatter'], description: 'Massive two-handed hammer', lore: 'Break anything', levelReq: 15, category: 'weapon', slot: 'twohanded', damageType: 'physical', range: 'melee' },

      { id: 'weapon_longbow', name: 'Elven Longbow', icon: 'ğŸ¹', type: 'weapon', rarity: 'uncommon', cost: 520, basePrice: 520, attack: 26, critRate: 18, range: 60,
        effects: [
          { name: 'Long Shot', desc: '+60m range', value: 60 },
          { name: 'Multi-Shot', desc: 'Fire 3 arrows', value: 3 }
        ],
        abilities: ['Snipe', 'Volley'], description: 'Precision longbow', lore: 'Elven craftsmanship', levelReq: 13, category: 'weapon', slot: 'twohanded', damageType: 'physical', range: 'ranged' },

      { id: 'weapon_battle_axe', name: 'Battle Axe', icon: 'âš”ï¸', type: 'weapon', rarity: 'uncommon', cost: 540, basePrice: 540, attack: 30, critDamage: 60,
        effects: [
          { name: 'Cleaving Strike', desc: 'Hit up to 3 enemies', value: 3 },
          { name: 'Bleed', desc: 'Cause 20 bleed damage over 5s', value: 20 }
        ],
        abilities: ['Whirlwind', 'Execute'], description: 'Brutal combat axe', lore: 'For close-quarters carnage', levelReq: 14, category: 'weapon', slot: 'mainhand', damageType: 'physical', range: 'melee' },

      { id: 'weapon_staff_fire', name: 'Fire Staff', icon: 'ğŸ”¥', type: 'weapon', rarity: 'uncommon', cost: 560, basePrice: 560, attack: 25, mana: 80, magicPower: 30,
        effects: [
          { name: 'Fireball', desc: 'Fire magic projectile (50 damage)', value: 50 },
          { name: 'Burn', desc: 'Ignite enemies (15 damage/sec)', value: 15 }
        ],
        abilities: ['Fireball', 'Flame Wave'], description: 'Pyromancer weapon', lore: 'Burns with ancient fire', levelReq: 12, category: 'weapon', slot: 'twohanded', damageType: 'fire', range: 'ranged' },

      { id: 'weapon_rapier', name: 'Fencing Rapier', icon: 'ğŸ¤º', type: 'weapon', rarity: 'uncommon', cost: 510, basePrice: 510, attack: 22, critRate: 22, speed: 30,
        effects: [
          { name: 'Riposte', desc: 'Counter-attack on dodge', value: 100 },
          { name: 'Precision', desc: '+22% crit rate', value: 22 }
        ],
        abilities: ['Lunge', 'Riposte'], description: 'Elegant dueling blade', lore: 'Grace and precision', levelReq: 13, category: 'weapon', slot: 'mainhand', damageType: 'physical', range: 'melee' },

      { id: 'weapon_flail', name: 'Spiked Flail', icon: 'â›“ï¸', type: 'weapon', rarity: 'uncommon', cost: 530, basePrice: 530, attack: 27, critDamage: 55,
        effects: [
          { name: 'Chain Whip', desc: 'Ignore blocks and parries', value: 100 },
          { name: 'Disarm', desc: '25% chance to disarm enemy', value: 25 }
        ],
        abilities: ['Whip', 'Disarm'], description: 'Unpredictable chain weapon', lore: 'Chaos incarnate', levelReq: 14, category: 'weapon', slot: 'mainhand', damageType: 'physical', range: 'melee' },

      { id: 'weapon_crossbow_heavy', name: 'Heavy Crossbow', icon: 'ğŸ¹', type: 'weapon', rarity: 'uncommon', cost: 570, basePrice: 570, attack: 35, critDamage: 70, range: 50,
        effects: [
          { name: 'Heavy Bolt', desc: '+70% crit damage', value: 70 },
          { name: 'Pierce', desc: 'Penetrate armor (ignore 35%)', value: 35 }
        ],
        abilities: ['Power Shot', 'Penetrating Bolt'], description: 'Siege crossbow', lore: 'Punches through shields', levelReq: 15, category: 'weapon', slot: 'twohanded', damageType: 'physical', range: 'ranged' },

      { id: 'weapon_whip', name: 'Leather Whip', icon: 'ğŸª¢', type: 'weapon', rarity: 'uncommon', cost: 490, basePrice: 490, attack: 20, speed: 25, range: 8,
        effects: [
          { name: 'Long Reach', desc: '+8m range', value: 8 },
          { name: 'Grapple', desc: 'Pull enemies closer', value: 100 }
        ],
        abilities: ['Lash', 'Pull'], description: 'Flexible reach weapon', lore: 'Control the distance', levelReq: 12, category: 'weapon', slot: 'mainhand', damageType: 'physical', range: 'melee' },

      // RARE WEAPONS (5) - 3 Effects Each
      { id: 'weapon_legendary_sword', name: 'Excalibur', icon: 'âš”ï¸âœ¨', type: 'weapon', rarity: 'rare', cost: 4000, basePrice: 4000, attack: 60, critRate: 25, critDamage: 100, hp: 100,
        effects: [
          { name: 'Holy Blade', desc: '+50% damage vs dark enemies', value: 50 },
          { name: 'Regeneration', desc: 'Heal 10 HP/sec when equipped', value: 10 },
          { name: 'Light Beam', desc: 'Fire light beam (100 damage)', value: 100 }
        ],
        abilities: ['Divine Slash', 'Light Beam', 'Judgement'], description: 'Legendary holy sword', lore: 'Sword of the chosen king', levelReq: 35, category: 'weapon', slot: 'mainhand', damageType: 'holy', range: 'melee' },

      { id: 'weapon_dark_scythe', name: 'Dark Aura Blade', icon: 'ğŸŒ‘', type: 'weapon', rarity: 'rare', cost: 3800, basePrice: 3800, attack: 65, lifesteal: 20, critRate: 20,
        effects: [
          { name: 'Life Drain', desc: 'Steal 20% damage as HP', value: 20 },
          { name: 'Dark Aura', desc: '-2% HP per swing, +50% damage', value: 50 },
          { name: 'Summon Sword Soul', desc: 'Random soul summon (200 HP, 300% ATK)', value: 300 }
        ],
        abilities: ['Soul Slash', 'Dark Wave', 'Summon Soul'], description: 'Cursed blade of darkness', lore: 'Feeds on life force', levelReq: 33, category: 'weapon', slot: 'mainhand', damageType: 'dark', range: 'melee' },

      { id: 'weapon_dual_pistols', name: 'Arcane Pistols', icon: 'ğŸ”«ğŸ”«', type: 'weapon', rarity: 'rare', cost: 3600, basePrice: 3600, attack: 55, critRate: 30, speed: 40, mana: 60,
        effects: [
          { name: 'Rapid Fire', desc: 'Fire 6 shots per attack', value: 6 },
          { name: 'Magic Bullets', desc: 'Convert 50% to magic damage', value: 50 },
          { name: 'Reload Boost', desc: '+40% attack speed', value: 40 }
        ],
        abilities: ['Bullet Storm', 'Charged Shot', 'Fan the Hammer'], description: 'Enchanted dual pistols', lore: 'Magic meets gunpowder', levelReq: 32, category: 'weapon', slot: 'dual', damageType: 'hybrid', range: 'ranged' },

      { id: 'weapon_thunder_hammer', name: 'Mjolnir', icon: 'âš¡', type: 'weapon', rarity: 'rare', cost: 4200, basePrice: 4200, attack: 70, critDamage: 120, aoe: 10,
        effects: [
          { name: 'Thunder Strike', desc: 'Lightning AOE (150 damage)', value: 150 },
          { name: 'Storm Call', desc: 'Summon lightning bolts', value: 100 },
          { name: 'Worthy', desc: '+50% all stats if pure heart', value: 50 }
        ],
        abilities: ['Lightning Slam', 'Thunder Clap', 'Storm'], description: 'Hammer of the gods', lore: 'Only the worthy can lift it', levelReq: 36, category: 'weapon', slot: 'twohanded', damageType: 'lightning', range: 'melee' },

      { id: 'weapon_ice_bow', name: 'Frostbite Bow', icon: 'â„ï¸', type: 'weapon', rarity: 'rare', cost: 3700, basePrice: 3700, attack: 58, critRate: 18, range: 70,
        effects: [
          { name: 'Freeze Arrow', desc: '40% chance to freeze target', value: 40 },
          { name: 'Ice Storm', desc: 'Create freezing AOE zone', value: 100 },
          { name: 'Glacial Pierce', desc: 'Arrows pierce all enemies', value: 100 }
        ],
        abilities: ['Freeze Arrow', 'Ice Storm', 'Volley'], description: 'Frozen legendary bow', lore: 'Never melts', levelReq: 34, category: 'weapon', slot: 'twohanded', damageType: 'ice', range: 'ranged' },

      // EPIC WEAPONS (3) - 5 Effects Each
      { id: 'weapon_infinity_blade', name: 'Infinity Blade', icon: 'âˆ', type: 'weapon', rarity: 'epic', cost: 12000, basePrice: 12000, attack: 120, critRate: 40, critDamage: 200, allStats: 50,
        effects: [
          { name: 'Infinite Edge', desc: 'Ignore all armor', value: 100 },
          { name: 'Reality Cut', desc: 'Attacks deal true damage', value: 100 },
          { name: 'Time Slash', desc: 'Slow enemies by 50% for 5s', value: 50 },
          { name: 'Dimensional Strike', desc: 'Hit enemies in other dimensions', value: 100 },
          { name: 'Perfect Form', desc: '+50 all stats', value: 50 }
        ],
        abilities: ['Infinity Slash', 'Reality Tear', 'Time Cut', 'Dimensional Strike'], description: 'Sword that cuts reality', lore: 'Forged in the space between moments', levelReq: 60, category: 'weapon', slot: 'mainhand', damageType: 'true', range: 'melee' },

      { id: 'weapon_omega_cannon', name: 'Omega Destroyer', icon: 'ğŸ’¥', type: 'weapon', rarity: 'epic', cost: 13000, basePrice: 13000, attack: 150, critDamage: 180, aoe: 30,
        effects: [
          { name: 'Omega Blast', desc: 'Fire devastating beam (500 damage)', value: 500 },
          { name: 'Overload', desc: '+100% damage, consume 50 mana/shot', value: 100 },
          { name: 'Chain Reaction', desc: 'Explosions trigger more explosions', value: 100 },
          { name: 'Nuclear Core', desc: 'Critical hits explode (200 AOE)', value: 200 },
          { name: 'Annihilation', desc: 'Delete enemies below 10% HP', value: 10 }
        ],
        abilities: ['Omega Beam', 'Nuclear Strike', 'Chain Explosion', 'Annihilate'], description: 'Ultimate destruction weapon', lore: 'Ends everything', levelReq: 65, category: 'weapon', slot: 'twohanded', damageType: 'explosive', range: 'ranged' },

      { id: 'weapon_chrono_blade', name: 'Chrono Katana', icon: 'â°âš”ï¸', type: 'weapon', rarity: 'epic', cost: 11500, basePrice: 11500, attack: 110, critRate: 35, speed: 80,
        effects: [
          { name: 'Time Slash', desc: 'Hit enemy 1 second in the past', value: 100 },
          { name: 'Future Strike', desc: 'Guaranteed next 3 hits are crits', value: 3 },
          { name: 'Temporal Loop', desc: 'Repeat last attack automatically', value: 100 },
          { name: 'Time Stop', desc: 'Freeze 1 enemy for 8s', value: 8 },
          { name: 'Haste', desc: '+80% attack speed', value: 80 }
        ],
        abilities: ['Past Slash', 'Future Strike', 'Time Loop', 'Freeze'], description: 'Blade that controls time', lore: 'Cuts through moments', levelReq: 62, category: 'weapon', slot: 'mainhand', damageType: 'temporal', range: 'melee' },

      // LEGENDARY WEAPONS (2) - 6 Effects Each
      { id: 'weapon_world_ender', name: 'World Ender', icon: 'ğŸ’€âš”ï¸', type: 'weapon', rarity: 'legendary', cost: 40000, basePrice: 40000, attack: 250, critRate: 50, critDamage: 300, allStats: 100,
        effects: [
          { name: 'Apocalypse', desc: 'Every swing ends worlds (1500 AOE)', value: 1500 },
          { name: 'Soul Reaper', desc: 'Instantly kill enemies below 20% HP', value: 20 },
          { name: 'Death Aura', desc: 'Enemies lose 5% max HP/sec', value: 5 },
          { name: 'Perfect Crit', desc: '+50% crit rate, +300% crit damage', value: 50 },
          { name: 'Lifesteal Master', desc: 'Steal 50% of damage as HP', value: 50 },
          { name: 'Reality Sever', desc: 'All damage becomes true damage', value: 100 }
        ],
        abilities: ['Apocalypse Slash', 'Soul Harvest', 'Death Field', 'Execute All'], description: 'Sword that ends existence', lore: 'When swung, reality screams', levelReq: 90, category: 'weapon', slot: 'twohanded', damageType: 'apocalyptic', range: 'melee' },

      { id: 'weapon_genesis', name: 'Genesis - First Weapon', icon: 'ğŸŒŸâš”ï¸', type: 'weapon', rarity: 'legendary', cost: 50000, basePrice: 50000, attack: 300, critRate: 60, critDamage: 400, allStats: 150,
        effects: [
          { name: 'Creation', desc: 'Create matter from nothing', value: 100 },
          { name: 'Primordial Power', desc: '+400% crit damage, +60% crit rate', value: 400 },
          { name: 'Origin Slash', desc: 'Attacks ignore ALL defenses', value: 100 },
          { name: 'Infinite Potential', desc: 'Grows stronger infinitely (+10 ATK/kill)', value: 10 },
          { name: 'God Slayer', desc: '+1000% damage vs divine beings', value: 1000 },
          { name: 'Beginning & End', desc: 'Can create or destroy anything', value: 100 }
        ],
        abilities: ['Genesis Slash', 'Create', 'Destroy', 'Infinite Growth', 'God Strike'], description: 'The very first weapon ever created', lore: 'Before this, there was nothing', levelReq: 99, category: 'weapon', slot: 'any', damageType: 'primordial', range: 'all' }
    ];
    
    // Define all available armor (30 total - Common to Legendary)
    const AVAILABLE_ARMOR = [
      // COMMON ARMOR (10) - 1 Effect Each
      { id: 'armor_cloth', name: 'Cloth Armor', icon: 'ğŸ‘•', type: 'armor', rarity: 'common', cost: 70, basePrice: 70, defense: 5, hp: 15, mana: 30,
        effects: [{ name: 'Light', desc: '+10% movement speed', value: 10 }],
        abilities: ['Quick Move'], description: 'Light protection', lore: 'Basic cloth defense', levelReq: 1, category: 'armor', slot: 'body', armorType: 'cloth', weight: 'light' },
      
      { id: 'armor_leather', name: 'Leather Vest', icon: 'ğŸ§¥', type: 'armor', rarity: 'common', cost: 90, basePrice: 90, defense: 8, hp: 20, evasion: 5,
        effects: [{ name: 'Flexible', desc: '+5% evasion', value: 5 }],
        abilities: ['Dodge'], description: 'Flexible defense', lore: 'Light and mobile', levelReq: 1, category: 'armor', slot: 'body', armorType: 'leather', weight: 'light' },
      
      { id: 'armor_chainmail', name: 'Chainmail', icon: 'ğŸ›¡ï¸', type: 'armor', rarity: 'common', cost: 110, basePrice: 110, defense: 10, hp: 25,
        effects: [{ name: 'Metal Protection', desc: '+15% vs physical damage', value: 15 }],
        abilities: ['Deflect'], description: 'Metal protection', lore: 'Interlocking rings', levelReq: 1, category: 'armor', slot: 'body', armorType: 'mail', weight: 'medium' },
      
      { id: 'armor_plate', name: 'Iron Plate', icon: 'âš”ï¸', type: 'armor', rarity: 'common', cost: 130, basePrice: 130, defense: 12, hp: 30,
        effects: [{ name: 'Heavy Protection', desc: 'Reduce damage by 10', value: 10 }],
        abilities: ['Tank'], description: 'Heavy armor', lore: 'Solid iron defense', levelReq: 1, category: 'armor', slot: 'body', armorType: 'plate', weight: 'heavy' },
      
      { id: 'armor_robes', name: 'Magic Robes', icon: 'ğŸ‘˜', type: 'armor', rarity: 'common', cost: 100, basePrice: 100, defense: 6, hp: 20, mana: 50,
        effects: [{ name: 'Mana Flow', desc: '+50 max mana', value: 50 }],
        abilities: ['Channel'], description: 'Enchanted cloth', lore: 'Woven with magic threads', levelReq: 1, category: 'armor', slot: 'body', armorType: 'cloth', weight: 'light' },
      
      { id: 'armor_padded', name: 'Padded Tunic', icon: 'ğŸ‘”', type: 'armor', rarity: 'common', cost: 75, basePrice: 75, defense: 6, hp: 18,
        effects: [{ name: 'Comfort', desc: '+2 HP regen/sec', value: 2 }],
        abilities: ['Rest'], description: 'Comfortable padding', lore: 'Better than nothing', levelReq: 1, category: 'armor', slot: 'body', armorType: 'cloth', weight: 'light' },
      
      { id: 'armor_hide', name: 'Animal Hide', icon: 'ğŸ¦Œ', type: 'armor', rarity: 'common', cost: 85, basePrice: 85, defense: 7, hp: 22,
        effects: [{ name: 'Natural', desc: '+15% nature resistance', value: 15 }],
        abilities: ['Camouflage'], description: 'Beast hide armor', lore: 'Hunter\'s choice', levelReq: 1, category: 'armor', slot: 'body', armorType: 'leather', weight: 'light' },
      
      { id: 'armor_scale', name: 'Scale Mail', icon: 'ğŸ‰', type: 'armor', rarity: 'common', cost: 120, basePrice: 120, defense: 11, hp: 28,
        effects: [{ name: 'Scales', desc: '+20% fire resistance', value: 20 }],
        abilities: ['Resist Fire'], description: 'Dragon scale armor', lore: 'Scavenged from beasts', levelReq: 1, category: 'armor', slot: 'body', armorType: 'scale', weight: 'medium' },
      
      { id: 'armor_studded', name: 'Studded Leather', icon: 'ğŸ§¥', type: 'armor', rarity: 'common', cost: 95, basePrice: 95, defense: 9, hp: 23, evasion: 8,
        effects: [{ name: 'Reinforced', desc: '+10% defense', value: 10 }],
        abilities: ['Harden'], description: 'Metal-studded leather', lore: 'Extra protection', levelReq: 1, category: 'armor', slot: 'body', armorType: 'leather', weight: 'medium' },
      
      { id: 'armor_tunic', name: 'Silk Tunic', icon: 'ğŸ‘•', type: 'armor', rarity: 'common', cost: 80, basePrice: 80, defense: 5, hp: 16, mana: 40,
        effects: [{ name: 'Silk Touch', desc: '+10% mana regen', value: 10 }],
        abilities: ['Mana Flow'], description: 'Luxury fabric armor', lore: 'Fit for nobles', levelReq: 1, category: 'armor', slot: 'body', armorType: 'cloth', weight: 'light' },

      // UNCOMMON ARMOR (10) - 2 Effects Each
      { id: 'armor_knight', name: 'Knight Armor', icon: 'ğŸ›¡ï¸', type: 'armor', rarity: 'uncommon', cost: 600, basePrice: 600, defense: 25, hp: 80, damageReduction: 15,
        effects: [
          { name: 'Chivalry', desc: '+15% damage reduction', value: 15 },
          { name: 'Noble Defense', desc: 'Allies nearby gain +10 defense', value: 10 }
        ],
        abilities: ['Defend', 'Protect Ally'], description: 'Full plate knight armor', lore: 'Honor and protection', levelReq: 12, category: 'armor', slot: 'body', armorType: 'plate', weight: 'heavy' },

      { id: 'armor_mage', name: 'Archmage Robes', icon: 'ğŸ§™', type: 'armor', rarity: 'uncommon', cost: 580, basePrice: 580, defense: 15, hp: 60, mana: 150, magicPower: 25,
        effects: [
          { name: 'Arcane Power', desc: '+25% magic damage', value: 25 },
          { name: 'Mana Pool', desc: '+150 max mana', value: 150 }
        ],
        abilities: ['Amplify Magic', 'Mana Shield'], description: 'Powerful mage robes', lore: 'Woven with pure magic', levelReq: 13, category: 'armor', slot: 'body', armorType: 'cloth', weight: 'light' },

      { id: 'armor_assassin', name: 'Shadow Leather', icon: 'ğŸ‘¤', type: 'armor', rarity: 'uncommon', cost: 620, basePrice: 620, defense: 18, hp: 70, evasion: 20, speed: 15,
        effects: [
          { name: 'Stealth', desc: '+30% stealth, invisible in shadows', value: 30 },
          { name: 'Critical Strikes', desc: '+15% crit damage', value: 15 }
        ],
        abilities: ['Vanish', 'Backstab Bonus'], description: 'Assassin gear', lore: 'Silent as the night', levelReq: 14, category: 'armor', slot: 'body', armorType: 'leather', weight: 'light' },

      { id: 'armor_berserker', name: 'Berserker Mail', icon: 'ğŸ˜¤', type: 'armor', rarity: 'uncommon', cost: 640, basePrice: 640, defense: 20, hp: 100, attack: 15,
        effects: [
          { name: 'Rage', desc: '+20% damage when below 50% HP', value: 20 },
          { name: 'Fearless', desc: 'Immune to fear effects', value: 100 }
        ],
        abilities: ['Berserk Mode', 'Fearless'], description: 'Barbarian armor', lore: 'For those who know no fear', levelReq: 15, category: 'armor', slot: 'body', armorType: 'mail', weight: 'medium' },

      { id: 'armor_paladin', name: 'Paladin Plate', icon: 'âœ¨ğŸ›¡ï¸', type: 'armor', rarity: 'uncommon', cost: 680, basePrice: 680, defense: 28, hp: 90, holyPower: 20,
        effects: [
          { name: 'Holy Protection', desc: '+25% vs undead/dark', value: 25 },
          { name: 'Blessing', desc: 'Heal 5 HP/sec', value: 5 }
        ],
        abilities: ['Divine Shield', 'Healing Aura'], description: 'Holy warrior armor', lore: 'Blessed by light', levelReq: 16, category: 'armor', slot: 'body', armorType: 'plate', weight: 'heavy' },

      { id: 'armor_ranger', name: 'Ranger Leather', icon: 'ğŸ¹', type: 'armor', rarity: 'uncommon', cost: 560, basePrice: 560, defense: 16, hp: 65, evasion: 15, speed: 20,
        effects: [
          { name: 'Hunter', desc: '+20% ranged damage', value: 20 },
          { name: 'Forest Walker', desc: '+25% speed in nature', value: 25 }
        ],
        abilities: ['Track', 'Camouflage'], description: 'Wilderness gear', lore: 'At home in the forest', levelReq: 12, category: 'armor', slot: 'body', armorType: 'leather', weight: 'light' },

      { id: 'armor_necromancer', name: 'Necromancer Robes', icon: 'ğŸ’€', type: 'armor', rarity: 'uncommon', cost: 590, basePrice: 590, defense: 14, hp: 55, mana: 120, lifesteal: 10,
        effects: [
          { name: 'Death Magic', desc: '+15% dark damage', value: 15 },
          { name: 'Vampiric', desc: 'Steal 10% damage as HP', value: 10 }
        ],
        abilities: ['Drain Life', 'Raise Dead'], description: 'Dark mage robes', lore: 'Forbidden knowledge', levelReq: 14, category: 'armor', slot: 'body', armorType: 'cloth', weight: 'light' },

      { id: 'armor_samurai', name: 'Samurai Armor', icon: 'ğŸŒ', type: 'armor', rarity: 'uncommon', cost: 650, basePrice: 650, defense: 22, hp: 75, critRate: 10,
        effects: [
          { name: 'Bushido', desc: '+10% crit rate, +20% crit damage', value: 10 },
          { name: 'Discipline', desc: '+15% all damage', value: 15 }
        ],
        abilities: ['Bushido Spirit', 'Honor Strike'], description: 'Traditional samurai gear', lore: 'Way of the warrior', levelReq: 13, category: 'armor', slot: 'body', armorType: 'plate', weight: 'medium' },

      { id: 'armor_monk', name: 'Monk Robes', icon: 'ğŸ§˜', type: 'armor', rarity: 'uncommon', cost: 540, basePrice: 540, defense: 12, hp: 80, hpRegen: 8, speed: 18,
        effects: [
          { name: 'Inner Peace', desc: '+8 HP regen/sec', value: 8 },
          { name: 'Martial Arts', desc: '+18% attack speed', value: 18 }
        ],
        abilities: ['Meditation', 'Chi Strike'], description: 'Monk training robes', lore: 'Balance of body and spirit', levelReq: 12, category: 'armor', slot: 'body', armorType: 'cloth', weight: 'light' },

      { id: 'armor_druid', name: 'Druid Leather', icon: 'ğŸŒ¿', type: 'armor', rarity: 'uncommon', cost: 570, basePrice: 570, defense: 17, hp: 85, hpRegen: 6, mana: 100,
        effects: [
          { name: 'Nature Bond', desc: '+6 HP regen/sec in nature', value: 6 },
          { name: 'Wild Shape', desc: 'Transform into animal forms', value: 100 }
        ],
        abilities: ['Shapeshift', 'Nature\'s Blessing'], description: 'Druid ceremonial gear', lore: 'One with nature', levelReq: 14, category: 'armor', slot: 'body', armorType: 'leather', weight: 'light' },

      // RARE ARMOR (5) - 3 Effects Each
      { id: 'armor_dragon_scale', name: 'Dragon Scale Armor', icon: 'ğŸ‰', type: 'armor', rarity: 'rare', cost: 4500, basePrice: 4500, defense: 45, hp: 200, fireResist: 80,
        effects: [
          { name: 'Dragon Skin', desc: '+80% fire resistance', value: 80 },
          { name: 'Intimidating', desc: 'Enemies deal -25% damage', value: 25 },
          { name: 'Regenerating Scales', desc: 'Heal 12 HP/sec', value: 12 }
        ],
        abilities: ['Dragon Roar', 'Fire Immunity', 'Regenerate'], description: 'Ancient dragon scales', lore: 'From elder dragons', levelReq: 35, category: 'armor', slot: 'body', armorType: 'scale', weight: 'heavy' },

      { id: 'armor_demon', name: 'Demon Lord Plate', icon: 'ğŸ˜ˆ', type: 'armor', rarity: 'rare', cost: 4200, basePrice: 4200, defense: 50, hp: 180, attack: 30, lifesteal: 25,
        effects: [
          { name: 'Demon Power', desc: '+30 attack, +25% lifesteal', value: 30 },
          { name: 'Fear Aura', desc: 'Enemies are terrified (-20% stats)', value: 20 },
          { name: 'Hell Fire', desc: 'Attackers take 50 fire damage', value: 50 }
        ],
        abilities: ['Demon Form', 'Hell Fire Aura', 'Terror'], description: 'Infernal plate armor', lore: 'Forged in hell', levelReq: 36, category: 'armor', slot: 'body', armorType: 'plate', weight: 'heavy' },

      { id: 'armor_angel', name: 'Angelic Armor', icon: 'ğŸ˜‡', type: 'armor', rarity: 'rare', cost: 4400, basePrice: 4400, defense: 42, hp: 220, hpRegen: 15, holyPower: 40,
        effects: [
          { name: 'Divine Grace', desc: '+15 HP regen/sec', value: 15 },
          { name: 'Holy Shield', desc: 'Absorb 300 damage shield', value: 300 },
          { name: 'Resurrection', desc: '30% chance to revive at 50% HP', value: 30 }
        ],
        abilities: ['Divine Protection', 'Holy Shield', 'Auto-Revive'], description: 'Blessed celestial armor', lore: 'Gift from heaven', levelReq: 37, category: 'armor', slot: 'body', armorType: 'holy', weight: 'medium' },

      { id: 'armor_shadow', name: 'Shadow Cloak', icon: 'ğŸŒ‘', type: 'armor', rarity: 'rare', cost: 3900, basePrice: 3900, defense: 30, hp: 150, evasion: 35, speed: 30,
        effects: [
          { name: 'Shadow Merge', desc: '+35% evasion, invisible at night', value: 35 },
          { name: 'Backstab Master', desc: '+100% damage from behind', value: 100 },
          { name: 'Untargetable', desc: 'First attack always misses you', value: 100 }
        ],
        abilities: ['Vanish', 'Shadow Step', 'Untargetable'], description: 'Cloak of pure darkness', lore: 'Made from living shadows', levelReq: 34, category: 'armor', slot: 'body', armorType: 'shadow', weight: 'light' },

      { id: 'armor_elemental', name: 'Elemental Plate', icon: 'ğŸŒˆ', type: 'armor', rarity: 'rare', cost: 4300, basePrice: 4300, defense: 40, hp: 190, allResist: 40,
        effects: [
          { name: 'All Elements', desc: '+40% all elemental resistances', value: 40 },
          { name: 'Elemental Shield', desc: 'Absorb elemental damage (250 shield)', value: 250 },
          { name: 'Prismatic', desc: '+20% all stats', value: 20 }
        ],
        abilities: ['Elemental Immunity', 'Rainbow Shield', 'Resist All'], description: 'Armor of all elements', lore: 'Contains the power of nature', levelReq: 36, category: 'armor', slot: 'body', armorType: 'plate', weight: 'heavy' },

      // EPIC ARMOR (3) - 5 Effects Each
      { id: 'armor_titan', name: 'Titan Plate', icon: 'ğŸ¦¾', type: 'armor', rarity: 'epic', cost: 15000, basePrice: 15000, defense: 100, hp: 500, damageReduction: 40, allStats: 40,
        effects: [
          { name: 'Titan Form', desc: '+200% size, +100 defense', value: 200 },
          { name: 'Unstoppable', desc: 'Immune to CC, knockback', value: 100 },
          { name: 'Massive', desc: '+40% damage reduction', value: 40 },
          { name: 'Thorns', desc: 'Reflect 60% of melee damage', value: 60 },
          { name: 'Regeneration', desc: 'Heal 20 HP/sec', value: 20 }
        ],
        abilities: ['Titan Mode', 'Unstoppable', 'Thorns Aura', 'Regenerate'], description: 'Armor of the titans', lore: 'Forged by giants', levelReq: 60, category: 'armor', slot: 'body', armorType: 'titan', weight: 'ultra-heavy' },

      { id: 'armor_void', name: 'Void Armor', icon: 'ğŸ•³ï¸', type: 'armor', rarity: 'epic', cost: 14000, basePrice: 14000, defense: 70, hp: 400, evasion: 50, voidPower: 80,
        effects: [
          { name: 'Void Form', desc: '+50% evasion, phase through attacks', value: 50 },
          { name: 'Dark Matter', desc: 'Absorb all magic (500 shield)', value: 500 },
          { name: 'Lifesteal', desc: 'Steal 30% damage as HP', value: 30 },
          { name: 'Void Aura', desc: 'Enemies lose 20 HP/sec near you', value: 20 },
          { name: 'Reality Warp', desc: 'Ignore 50% of incoming damage', value: 50 }
        ],
        abilities: ['Phase Shift', 'Void Shield', 'Life Drain Aura', 'Reality Bend'], description: 'Armor made of void', lore: 'Exists between dimensions', levelReq: 62, category: 'armor', slot: 'body', armorType: 'void', weight: 'none' },

      { id: 'armor_celestial', name: 'Celestial Armor', icon: 'â­', type: 'armor', rarity: 'epic', cost: 16000, basePrice: 16000, defense: 85, hp: 600, hpRegen: 25, allStats: 50,
        effects: [
          { name: 'Divine Blessing', desc: '+50 all stats', value: 50 },
          { name: 'Starlight Shield', desc: 'Absorb 600 damage (regenerates)', value: 600 },
          { name: 'Healing Aura', desc: 'Heal all allies 15 HP/sec', value: 15 },
          { name: 'Immunity', desc: 'Immune to all debuffs', value: 100 },
          { name: 'Resurrection', desc: 'Auto-revive at full HP (once per battle)', value: 100 }
        ],
        abilities: ['Divine Shield', 'Mass Heal', 'Revive', 'Cleanse'], description: 'Armor of the heavens', lore: 'Blessed by angels', levelReq: 65, category: 'armor', slot: 'body', armorType: 'celestial', weight: 'light' },

      // LEGENDARY ARMOR (2) - 6 Effects Each
      { id: 'armor_infinity', name: 'Infinity Armor', icon: 'âˆ', type: 'armor', rarity: 'legendary', cost: 45000, basePrice: 45000, defense: 200, hp: 1500, allStats: 100, allResist: 90,
        effects: [
          { name: 'Infinite Defense', desc: '+200 defense, +90% all resistances', value: 200 },
          { name: 'Immortal', desc: 'Cannot die, heal to full at 1 HP', value: 100 },
          { name: 'Perfect Form', desc: '+100 all stats', value: 100 },
          { name: 'Reality Shield', desc: 'Negate first 5 attacks each battle', value: 5 },
          { name: 'Absolute Protection', desc: 'Reduce all damage by 70%', value: 70 },
          { name: 'Transcendent', desc: 'Exist beyond mortal limits', value: 100 }
        ],
        abilities: ['Infinity Shield', 'Transcend', 'Immortality', 'Perfect Defense'], description: 'Armor that transcends reality', lore: 'No force can break this', levelReq: 90, category: 'armor', slot: 'body', armorType: 'infinite', weight: 'weightless' },

      { id: 'armor_genesis', name: 'Genesis Armor - First Shield', icon: 'ğŸŒŸğŸ›¡ï¸', type: 'armor', rarity: 'legendary', cost: 55000, basePrice: 55000, defense: 250, hp: 2000, allStats: 150, allResist: 100,
        effects: [
          { name: 'Primordial Defense', desc: '+250 defense, +100% all resist', value: 250 },
          { name: 'Creation Shield', desc: 'Create shields from nothing (infinite)', value: 9999 },
          { name: 'Perfect Immunity', desc: 'Immune to ALL damage types', value: 100 },
          { name: 'Regeneration Master', desc: 'Heal 50 HP/sec + 5% max HP/sec', value: 50 },
          { name: 'Divine Blessing', desc: '+150 all stats, allies gain +50%', value: 150 },
          { name: 'Origin', desc: 'The first shield - nothing existed before this', value: 100 }
        ],
        abilities: ['Genesis Shield', 'Create Barrier', 'Perfect Immunity', 'Mass Blessing'], description: 'The very first armor ever created', lore: 'Before this, there was no protection', levelReq: 99, category: 'armor', slot: 'body', armorType: 'primordial', weight: 'eternal' }
    ];
    
    // Define all available accessories (common)
    const AVAILABLE_ACCESSORIES = [
      { id: 'acc_ring', name: 'Bronze Ring', icon: 'ğŸ’', rarity: 'common', cost: 60, attack: 2, defense: 2, description: 'Simple ring', levelReq: 1, category: 'accessory' },
      { id: 'acc_amulet', name: 'Jade Amulet', icon: 'ğŸ“¿', rarity: 'common', cost: 80, attack: 3, defense: 3, description: 'Protective charm', levelReq: 1, category: 'accessory' },
      { id: 'acc_belt', name: 'Leather Belt', icon: 'ğŸ—ï¸', rarity: 'common', cost: 70, defense: 4, hp: 10, description: 'Sturdy belt', levelReq: 1, category: 'accessory' },
      { id: 'acc_gloves', name: 'Work Gloves', icon: 'ğŸ§¤', rarity: 'common', cost: 65, attack: 4, description: 'Improve grip', levelReq: 1, category: 'accessory' },
      { id: 'acc_boots', name: 'Travel Boots', icon: 'ğŸ‘¢', rarity: 'common', cost: 75, defense: 3, hp: 8, description: 'Comfortable footwear', levelReq: 1, category: 'accessory' }
    ];
    
    // Define all available scrolls (common)
    const AVAILABLE_SCROLLS = [
      { id: 'scroll_heal', name: 'Healing Scroll', icon: 'ğŸ“œ', rarity: 'common', cost: 50, description: 'Restores 50 HP', levelReq: 1, category: 'scroll', type: 'scroll' },
      { id: 'scroll_teleport', name: 'Teleport Scroll', icon: 'ğŸ“œ', rarity: 'common', cost: 75, description: 'Return to town', levelReq: 1, category: 'scroll', type: 'scroll' },
      { id: 'scroll_buff', name: 'Strength Scroll', icon: 'ğŸ“œ', rarity: 'common', cost: 60, description: 'Temporary +10 ATK', levelReq: 1, category: 'scroll', type: 'scroll' },
      { id: 'scroll_defense', name: 'Shield Scroll', icon: 'ğŸ“œ', rarity: 'common', cost: 60, description: 'Temporary +10 DEF', levelReq: 1, category: 'scroll', type: 'scroll' },
      { id: 'scroll_xp', name: 'Wisdom Scroll', icon: 'ğŸ“œ', rarity: 'common', cost: 80, description: '+50% XP for 10 min', levelReq: 1, category: 'scroll', type: 'scroll' }
    ];
    
    // Define all available essence (common)
    const AVAILABLE_ESSENCE = [
      { id: 'essence_fire', name: 'Fire Essence', icon: 'ğŸ’', rarity: 'common', cost: 100, description: 'Fire elemental essence', levelReq: 1, category: 'essence', type: 'essence' },
      { id: 'essence_water', name: 'Water Essence', icon: 'ğŸ’§', rarity: 'common', cost: 100, description: 'Water elemental essence', levelReq: 1, category: 'essence', type: 'essence' },
      { id: 'essence_earth', name: 'Earth Essence', icon: 'ğŸª¨', rarity: 'common', cost: 100, description: 'Earth elemental essence', levelReq: 1, category: 'essence', type: 'essence' },
      { id: 'essence_wind', name: 'Wind Essence', icon: 'ğŸŒªï¸', rarity: 'common', cost: 100, description: 'Wind elemental essence', levelReq: 1, category: 'essence', type: 'essence' },
      { id: 'essence_light', name: 'Light Essence', icon: 'âœ¨', rarity: 'common', cost: 120, description: 'Pure light essence', levelReq: 1, category: 'essence', type: 'essence' }
    ];
    
    // Define consumables (common)
    const AVAILABLE_CONSUMABLES = [
      { id: 'potion_hp', name: 'Health Potion', icon: 'ğŸ§ª', rarity: 'common', cost: 30, description: 'Restores 50 HP', levelReq: 1, category: 'consumable', type: 'consumable' },
      { id: 'potion_mp', name: 'Mana Potion', icon: 'ğŸ§ª', rarity: 'common', cost: 30, description: 'Restores 30 MP', levelReq: 1, category: 'consumable', type: 'consumable' }
    ];
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Achievement definitions
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    const ACHIEVEMENTS = {
      common_pet_collector: {
        id: 'common_pet_collector',
        name: 'Pet Collector',
        description: 'Collect all common pets',
        icon: 'ğŸ¾',
        reward: { gold: 500, xp: 100 },
        check: () => {
          const ownedPets = window.gameState.inventory.pets || [];
          return AVAILABLE_PETS.every(pet => ownedPets.some(owned => owned.name === pet.name));
        }
      },
      common_spirit_collector: {
        id: 'common_spirit_collector',
        name: 'Spirit Master',
        description: 'Collect all common spirits',
        icon: 'âœ¨',
        reward: { gold: 600, xp: 150 },
        check: () => {
          const ownedSpirits = window.gameState.inventory.spirits || [];
          return AVAILABLE_SPIRITS.every(spirit => ownedSpirits.some(owned => owned.name === spirit.name));
        }
      },
      common_vehicle_collector: {
        id: 'common_vehicle_collector',
        name: 'Vehicle Enthusiast',
        description: 'Collect all common vehicles',
        icon: 'ğŸš—',
        reward: { gold: 700, xp: 200 },
        check: () => {
          const ownedVehicles = window.gameState.inventory.vehicles || [];
          return AVAILABLE_VEHICLES.every(vehicle => ownedVehicles.some(owned => owned.name === vehicle.name));
        }
      },
      common_robot_collector: {
        id: 'common_robot_collector',
        name: 'Robot Engineer',
        description: 'Collect all common robots',
        icon: 'ğŸ¤–',
        reward: { gold: 800, xp: 250 },
        check: () => {
          const ownedRobots = window.gameState.inventory.robots || [];
          return AVAILABLE_ROBOTS.every(robot => ownedRobots.some(owned => owned.name === robot.name));
        }
      },
      ultimate_common_collector: {
        id: 'ultimate_common_collector',
        name: 'Ultimate Common Collector',
        description: 'Collect ALL common pets, spirits, vehicles, and robots',
        icon: 'ğŸ†',
        reward: { gold: 2000, xp: 1000 },
        check: () => {
          return ACHIEVEMENTS.common_pet_collector.check() &&
                 ACHIEVEMENTS.common_spirit_collector.check() &&
                 ACHIEVEMENTS.common_vehicle_collector.check() &&
                 ACHIEVEMENTS.common_robot_collector.check();
        }
      }
    };
    
    // Achievement checking function
    function checkAndUnlockAchievements() {
      const achievements = window.gameState.achievements || [];
      
      Object.values(ACHIEVEMENTS).forEach(achievement => {
        // Skip if already unlocked
        if (achievements.some(a => a.id === achievement.id)) return;
        
        // Check if condition is met
        if (achievement.check()) {
          // Unlock achievement
          achievements.push({ id: achievement.id, unlockedAt: Date.now() });
          window.gameState.achievements = achievements;
          
          // Grant rewards
          if (achievement.reward.gold) {
            window.gameState.gold += achievement.reward.gold;
          }
          if (achievement.reward.xp) {
            window.gameState.experience += achievement.reward.xp;
          }
          
          // Show notification
          window.BagSystem.showToast(`ğŸ† Achievement Unlocked: ${achievement.icon} ${achievement.name}!`);
          window.BagSystem.addSystemMessage(
            `ğŸ† ACHIEVEMENT: ${achievement.name} - ${achievement.description}`, 
            'reward'
          );
          
          // Visual effects
          window.BagSystem.createParticleEffect('levelup', window.innerWidth / 2, window.innerHeight / 2);
          
          debugLog(`ğŸ† Achievement unlocked: ${achievement.name}`);
        }
      });
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Populate shop with all common items
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Populate shop with all common items from available item arrays
    function populateShopWithCommonItems() {
      const shop = window.gameState.shop;
      const addedIds = new Set(shop.inventory.map(item => item.id));
      
      // Helper to add item to shop if it's common and not already there
      const addCommonItemToShop = (item, category, prefix = 'shop_') => {
        if (!item || !item.id) return;
        
        const rarity = item.rarity || 'common';
        if (rarity !== 'common') return; // Only add common items
        
        const shopId = prefix + item.id;
        if (addedIds.has(shopId)) return; // Already in shop
        
        const shopItem = {
          ...item,
          id: shopId,
          basePrice: item.cost || item.basePrice || 100,
          category: category,
          levelReq: item.levelReq || (window.RARITY_REQUIREMENTS?.[rarity]?.level || 1),
          rarity: rarity
        };
        
        shop.inventory.push(shopItem);
        addedIds.add(shopId);
      };
      
      // Add common pets from AVAILABLE_PETS
      AVAILABLE_PETS.forEach(pet => {
        const shopItem = { ...pet, type: 'pet' };
        addCommonItemToShop(shopItem, 'pet', 'shop_pet_');
      });
      
      // Add common spirits from AVAILABLE_SPIRITS
      AVAILABLE_SPIRITS.forEach(spirit => {
        const shopItem = { ...spirit, type: 'spirit' };
        addCommonItemToShop(shopItem, 'spirit', 'shop_spirit_');
      });
      
      // Add common vehicles from AVAILABLE_VEHICLES
      AVAILABLE_VEHICLES.forEach(vehicle => {
        const shopItem = { ...vehicle, type: 'vehicle' };
        addCommonItemToShop(shopItem, 'vehicle', 'shop_vehicle_');
      });
      
      // Add common robots from AVAILABLE_ROBOTS
      AVAILABLE_ROBOTS.forEach(robot => {
        const shopItem = { ...robot, type: 'robot' };
        addCommonItemToShop(shopItem, 'robot', 'shop_robot_');
      });
      
      // Add common weapons from AVAILABLE_WEAPONS
      AVAILABLE_WEAPONS.forEach(weapon => {
        const shopItem = { ...weapon, type: 'weapon' };
        addCommonItemToShop(shopItem, 'weapon', 'shop_weapon_');
      });
      
      // Add common armor from AVAILABLE_ARMOR
      AVAILABLE_ARMOR.forEach(armor => {
        const shopItem = { ...armor, type: 'armor' };
        addCommonItemToShop(shopItem, 'armor', 'shop_armor_');
      });
      
      // Add common accessories from AVAILABLE_ACCESSORIES
      AVAILABLE_ACCESSORIES.forEach(accessory => {
        const shopItem = { ...accessory, type: 'accessory' };
        addCommonItemToShop(shopItem, 'accessory', 'shop_accessory_');
      });
      
      // Scrolls removed - no longer sold in shop
      
      // Add common essence from AVAILABLE_ESSENCE
      AVAILABLE_ESSENCE.forEach(essence => {
        const shopItem = { ...essence, type: 'essence' };
        addCommonItemToShop(shopItem, 'essence', 'shop_essence_');
      });
      
      // Add common consumables from AVAILABLE_CONSUMABLES
      AVAILABLE_CONSUMABLES.forEach(consumable => {
        const shopItem = { ...consumable, type: 'consumable' };
        addCommonItemToShop(shopItem, 'consumable', 'shop_consumable_');
      });
      
      // Add common gear items from inventory (existing items)
      const gear = window.gameState.inventory.gear || [];
      gear.forEach(g => {
        if (g.rarity === 'common') {
          addCommonItemToShop(g, 'gear', 'shop_gear_');
        }
      });
      
      debugLog('âœ… Shop populated with common items from all categories');
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // Create common starter set boxes
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    function createStarterSetBoxes() {
      const shop = window.gameState.shop;
      
      // Use the available item definitions (all are common)
      const commonPets = AVAILABLE_PETS.map(p => ({ ...p, type: 'pet' }));
      const commonSpirits = AVAILABLE_SPIRITS.map(s => ({ ...s, type: 'spirit' }));
      const commonVehicles = AVAILABLE_VEHICLES.map(v => ({ ...v, type: 'vehicle' }));
      const commonRobots = AVAILABLE_ROBOTS.map(r => ({ ...r, type: 'robot' }));
      
      // Calculate total value for pricing (items cost * 0.8 for bundle discount)
      const petSetValue = commonPets.reduce((sum, p) => sum + (p.cost || 100), 0);
      const spiritSetValue = commonSpirits.reduce((sum, s) => sum + (s.cost || 100), 0);
      const vehicleSetValue = commonVehicles.reduce((sum, v) => sum + (v.cost || 100), 0);
      const robotSetValue = commonRobots.reduce((sum, r) => sum + (r.cost || 100), 0);
      
      // Starter Set Boxes
      const starterBoxes = [
        {
          id: 'shop_starter_pet_set',
          name: 'Common Pet Starter Set',
          icon: 'ğŸ“¦',
          category: 'container',
          type: 'box',
          rarity: 'common',
          basePrice: Math.floor(petSetValue * 0.8),
          levelReq: 1,
          description: `Contains 1 of each common pet (${commonPets.length} pets total)`,
          contains: commonPets.map(p => ({ ...p, type: 'pet' }))
        },
        {
          id: 'shop_starter_spirit_set',
          name: 'Common Spirit Starter Set',
          icon: 'ğŸ“¦',
          category: 'container',
          type: 'box',
          rarity: 'common',
          basePrice: Math.floor(spiritSetValue * 0.8),
          levelReq: 1,
          description: `Contains 1 of each common spirit (${commonSpirits.length} spirits total)`,
          contains: commonSpirits.map(s => ({ ...s, type: 'spirit' }))
        },
        {
          id: 'shop_starter_vehicle_set',
          name: 'Common Vehicle Starter Set',
          icon: 'ğŸ“¦',
          category: 'container',
          type: 'box',
          rarity: 'common',
          basePrice: Math.floor(vehicleSetValue * 0.8),
          levelReq: 1,
          description: `Contains 1 of each common vehicle (${commonVehicles.length} vehicles total)`,
          contains: commonVehicles.map(v => ({ ...v, type: 'vehicle' }))
        },
        {
          id: 'shop_starter_robot_set',
          name: 'Common Robot Starter Set',
          icon: 'ğŸ“¦',
          category: 'container',
          type: 'box',
          rarity: 'common',
          basePrice: Math.floor(robotSetValue * 0.8),
          levelReq: 1,
          description: `Contains 1 of each common robot (${commonRobots.length} robots total)`,
          contains: commonRobots.map(r => ({ ...r, type: 'robot' }))
        },
        {
          id: 'shop_starter_complete',
          name: 'Complete Common Starter Set',
          icon: 'ğŸ',
          category: 'container',
          type: 'box',
          rarity: 'common',
          basePrice: Math.floor((petSetValue + spiritSetValue + vehicleSetValue + robotSetValue) * 0.7),
          levelReq: 1,
          description: `MEGA BOX: Contains ALL common items! (${commonPets.length + commonSpirits.length + commonVehicles.length + commonRobots.length} items total)`,
          contains: [
            ...commonPets.map(p => ({ ...p, type: 'pet' })),
            ...commonSpirits.map(s => ({ ...s, type: 'spirit' })),
            ...commonVehicles.map(v => ({ ...v, type: 'vehicle' })),
            ...commonRobots.map(r => ({ ...r, type: 'robot' }))
          ]
        }
      ];
      
      // Add boxes to shop (only if they contain items)
      starterBoxes.forEach(box => {
        if (box.contains && box.contains.length > 0) {
          // Check if already in shop
          const existing = shop.inventory.find(i => i.id === box.id);
          if (!existing) {
            shop.inventory.push(box);
          }
        }
      });
      
      debugLog('âœ… Starter set boxes created:', starterBoxes.length);
    }
    
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // POPULATE SHOP WITH CORES (After CORES_DATABASE is loaded)
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    
    // Add cores to shop inventory dynamically
    function initializeShopCores() {
      const coresToAdd = [
        // Common Cores (Level 1+)
        { coreId: 'core_basic', shopId: 'shop_core_basic' },
        { coreId: 'core_spark', shopId: 'shop_core_spark' },
        { coreId: 'core_ember', shopId: 'shop_core_ember' },
        { coreId: 'core_stone', shopId: 'shop_core_stone' },
        { coreId: 'core_shell', shopId: 'shop_core_shell' },
        { coreId: 'core_charm', shopId: 'shop_core_charm' },
        { coreId: 'core_lucky', shopId: 'shop_core_lucky' },
        
        // Uncommon Cores (Level 5+)
        { coreId: 'core_fire', shopId: 'shop_core_fire' },
        { coreId: 'core_ice', shopId: 'shop_core_ice' },
        { coreId: 'core_thunder', shopId: 'shop_core_thunder' },
        { coreId: 'core_iron', shopId: 'shop_core_iron' },
        { coreId: 'core_crystal', shopId: 'shop_core_crystal' },
        { coreId: 'core_swift', shopId: 'shop_core_swift' },
        { coreId: 'core_wisdom', shopId: 'shop_core_wisdom' },
        
        // Rare Cores (Level 15+)
        { coreId: 'core_shadow', shopId: 'shop_core_shadow' },
        { coreId: 'core_light', shopId: 'shop_core_light' },
        { coreId: 'core_poison', shopId: 'shop_core_poison' }
      ];
      
      coresToAdd.forEach(({ coreId, shopId }) => {
        const coreData = window.CORES_DATABASE[coreId];
        if (coreData) {
          window.gameState.shop.inventory.push({
            ...coreData,
            id: shopId,
            basePrice: coreData.cost,
            category: 'core'
          });
        }
      });
      
      debugLog('âœ… Shop initialized with', coresToAdd.length, 'cores');
    }
    
    // Pre-equip some cores for demo
    function initializeDemoCores() {
      if (window.CORES_DATABASE.core_fire && window.CORES_DATABASE.core_stone) {
        window.gameState.equippedCores = {
          weaponCore: window.CORES_DATABASE.core_fire,
          headCore: window.CORES_DATABASE.core_stone
        };
        debugLog('âœ… Demo cores equipped');
      }
    }
    
    // Initialize supernatural powers with starter abilities
    function initializeSupernaturalPowers() {
      if (!window.gameState.inventory.abilities) {
        window.gameState.inventory.abilities = [];
      }
      
      // Give player 2 starter powers (1 from each basic category)
      const starterPowers = [
        window.SUPERNATURAL_POWERS_DATABASE.power_flame_touch,
        window.SUPERNATURAL_POWERS_DATABASE.power_mind_focus
      ];
      
      starterPowers.forEach(power => {
        if (power && !window.gameState.inventory.abilities.find(a => a.id === power.id)) {
          window.gameState.inventory.abilities.push({...power});
        }
      });
      
      debugLog('âœ… Supernatural powers initialized with', starterPowers.length, 'starter powers');
    }
    
    // Add supernatural powers to shop
    function initializeShopPowers() {
      const powersToAdd = [
        // Common Powers (easy access)
        { powerId: 'power_frost_shield', shopId: 'shop_power_frost_shield' },
        { powerId: 'power_earth_blessing', shopId: 'shop_power_earth_blessing' },
        { powerId: 'power_wind_step', shopId: 'shop_power_wind_step' },
        { powerId: 'power_shock_burst', shopId: 'shop_power_shock_burst' },
        { powerId: 'power_nature_harmony', shopId: 'shop_power_nature_harmony' },
        { powerId: 'power_telepathy', shopId: 'shop_power_telepathy' },
        { powerId: 'power_soul_link', shopId: 'shop_power_soul_link' },
        { powerId: 'power_barrier', shopId: 'shop_power_barrier' },
        { powerId: 'power_gravity_well', shopId: 'shop_power_gravity_well' },
        { powerId: 'power_time_dilation', shopId: 'shop_power_time_dilation' },
        { powerId: 'power_void_affinity', shopId: 'shop_power_void_affinity' },
        { powerId: 'power_starlight', shopId: 'shop_power_starlight' },
        
        // Uncommon Powers (Level 5+)
        { powerId: 'power_inferno_rage', shopId: 'shop_power_inferno_rage' },
        { powerId: 'power_blizzard_field', shopId: 'shop_power_blizzard_field' },
        { powerId: 'power_lightning_reflexes', shopId: 'shop_power_lightning_reflexes' }
      ];
      
      powersToAdd.forEach(({ powerId, shopId }) => {
        const powerData = window.SUPERNATURAL_POWERS_DATABASE[powerId];
        if (powerData) {
          window.gameState.shop.inventory.push({
            ...powerData,
            id: shopId,
            basePrice: powerData.cost,
            category: 'supernatural'
          });
        }
      });
      
      debugLog('âœ… Shop initialized with', powersToAdd.length, 'supernatural powers');
    }

    // Mock functions (provide these in your game)
    window.saveGame = function (slot) { debugLog('[Demo] Save game:', slot); };
    window.loadGame = function (slot) { debugLog('[Demo] Load game:', slot); };
    window.updateHUD = function () { debugLog('[Demo] Update HUD'); };

    // Initialize on load
    document.addEventListener('DOMContentLoaded', async () => {
      // Initialize shop with cores, powers, and demo data
      initializeShopCores();
      initializeShopPowers();
      initializeDemoCores();
      initializeSupernaturalPowers();
      
      // Phase 3: Populate shop with all common items
      populateShopWithCommonItems();
      
      // Phase 4: Create starter set boxes
      createStarterSetBoxes();
      
      await window.BagSystem.init();
      if (window.DeployerSystem && typeof window.DeployerSystem.init === 'function') {
        window.DeployerSystem.init();
      }

      // Calculate initial stats from equipped items
      window.BagSystem.updateStats();

      // Keyboard shortcuts
      document.addEventListener('keydown', (e) => {
        // B key - toggle bag
        if (e.key === 'b' || e.key === 'B') {
          if (!e.ctrlKey && !e.metaKey) {
            window.BagSystem.toggle();
          }
        }
        
        // Ctrl+Z - undo
        if ((e.ctrlKey || e.metaKey) && e.key === 'z') {
          e.preventDefault();
          window.BagSystem.undo();
        }
        
        // Ctrl+Y - redo
        if ((e.ctrlKey || e.metaKey) && e.key === 'y') {
          e.preventDefault();
          window.BagSystem.redo();
        }
        
        // Ctrl+S - manual save
        if ((e.ctrlKey || e.metaKey) && e.key === 's') {
          e.preventDefault();
          window.BagSystem.saveGame('manual1');
        }
      });

      // Auto-save every 5 minutes
      setInterval(() => {
        window.BagSystem.autoSave();
      }, 300000); // 5 minutes

      // Memory cleanup every 2 minutes
      setInterval(() => {
        window.BagSystem.cleanupMemory();
      }, 120000); // 2 minutes

      // Performance monitoring
      let frameCount = 0;
      let lastFPSCheck = Date.now();
      
      const monitorFPS = () => {
        frameCount++;
        const now = Date.now();
        const elapsed = now - lastFPSCheck;
        
        if (elapsed >= 1000) {
          const fps = Math.round((frameCount * 1000) / elapsed);
          window.currentFPS = fps;
          
          // Log warning if FPS drops below 30
          if (fps < 30 && window.BagSystem.state.bagOpen) {
            debugWarn(`[Performance] Low FPS: ${fps}`);
          }
          
          frameCount = 0;
          lastFPSCheck = now;
        }
        
        requestAnimationFrame(monitorFPS);
      };
      requestAnimationFrame(monitorFPS);

      // Auto-open for demo (DISABLED - bag should only open when user clicks button)
      // setTimeout(() => window.BagSystem.open(), 500);

      debugLog('[A1K Bag System] PRODUCTION VERSION LOADED');
      debugLog('Press "B" to toggle bag | Ctrl+Z undo | Ctrl+Y redo | Ctrl+S save');
      debugLog('ğŸš€ All 15 Phases Complete | AI Powered | Voice Enabled | Fully Integrated');
    });



/**
 * Mission Board Renderer
 * Renders the Mission Board tab with available missions, active missions, and dungeon/tower access
 */

(function() {
  'use strict';

  debugLog('[MissionBoardRenderer] Loading mission board renderer...');

  window.MissionBoardRenderer = {
    currentSubsection: 'available',
    selectedMission: null,
    gatekeeperConfig: null,
    cinematicCleanupFns: [],
    activeColorGrade: null,
    flythroughActive: false,

    // Main render function for the Mission Board tab
    renderMissionBoardTab() {
      const pane = document.getElementById('bagContentPane');
      if (!pane) return;

      const html = `
        <div class="mission-board-container">
          ${this.renderGatekeeperCTA()}
          <!-- Subsection Navigation -->
          <div class="mission-subsection-tabs">
            <button class="mission-subtab ${this.currentSubsection === 'available' ? 'active' : ''}" data-subsection="available">
              <span class="tab-icon">ğŸ“‹</span>
              <span class="tab-label">Available</span>
            </button>
            <button class="mission-subtab ${this.currentSubsection === 'active' ? 'active' : ''}" data-subsection="active">
              <span class="tab-icon">âš”ï¸</span>
              <span class="tab-label">Active</span>
            </button>
            <button class="mission-subtab ${this.currentSubsection === 'completed' ? 'active' : ''}" data-subsection="completed">
              <span class="tab-icon">âœ…</span>
              <span class="tab-label">Completed</span>
            </button>
            <button class="mission-subtab ${this.currentSubsection === 'dungeons' ? 'active' : ''}" data-subsection="dungeons">
              <span class="tab-icon">ğŸ°</span>
              <span class="tab-label">Dungeons & Towers</span>
            </button>
          </div>

          <!-- Content Sections -->
          <div class="mission-content">
            ${this.renderCurrentSubsection()}
          </div>
        </div>
      `;

      pane.innerHTML = html;
      this.attachEventListeners();
      this._mountGatekeeperCTA();
      this.handleCinematicPostRender();
    },

    // Render the currently active subsection
    renderCurrentSubsection() {
      switch(this.currentSubsection) {
        case 'available':
          return this.renderAvailableMissions();
        case 'active':
          return this.renderActiveMission();
        case 'completed':
          return this.renderCompletedMissions();
        case 'dungeons':
          return this.renderDungeonsAndTowers();
        default:
          return '<div>Subsection not found</div>';
      }
    },

    renderGatekeeperCTA() {
      const cfg = this._getGatekeeperConfig();
      const statusCopy = cfg.statusHint || 'Badge payouts refund forging costs.';
      const hotkey = (cfg.hotkey || 'g').toUpperCase();

      return `
        <div class="mission-gatekeeper-cta">
          <div class="gatekeeper-status">
            <div>${statusCopy}</div>
            <div style="margin-top:6px; font-size:11px; color: rgba(207,227,255,0.6);">
              Hotkey: <span style="color:#00e5ff; font-weight:600;">${hotkey}</span>
            </div>
          </div>
          <div class="gatekeeper-cta-button" data-role="gatekeeper-cta"></div>
        </div>
      `;
    },

    _mountGatekeeperCTA() {
      try {
        const host = document.querySelector('.gatekeeper-cta-button[data-role="gatekeeper-cta"]');
        if (!host) return;
        const attached = window.RiftUI?.attachGatekeeperToggle?.(host);
        if (!attached) {
          host.innerHTML = '<div style="color: rgba(255,107,53,0.7); font-size: 12px;">Gatekeeper interface unavailable.</div>';
        }
      } catch (error) {
        debugError('[MissionBoardRenderer] Failed to mount Gatekeeper CTA', error);
      }
    },

    _getGatekeeperConfig() {
      if (this.gatekeeperConfig) return this.gatekeeperConfig;
      const configCandidate =
        window.CONFIG?.bag?.missions?.gatekeeperBriefing ||
        window.CONFIG?.polish?.bag?.missions?.gatekeeperBriefing ||
        window.__A1K_CONFIG?.bag?.missions?.gatekeeperBriefing;
      this.gatekeeperConfig =
        (configCandidate && typeof configCandidate === 'object'
          ? configCandidate
          : {
              label: 'Gatekeeper Briefing',
              statusHint: 'Badge payouts refund forging costs.',
              hotkey: 'g',
            });
      return this.gatekeeperConfig;
    },

    // Render available missions
    renderAvailableMissions() {
      if (!window.MissionDatabase) {
        return '<div class="mission-loading">Loading mission data...</div>';
      }

      const playerLevel = window.gameState?.level || 1;
      const availableMissions = window.MissionDatabase.getAvailableMissions(playerLevel);
      const activeMissionId = window.gameState?.missions?.active?.id;

      // Filter out active mission
      const missions = availableMissions.filter(m => m.id !== activeMissionId);

      if (missions.length === 0) {
        return '<div class="mission-empty">No missions available. Level up to unlock more!</div>';
      }

      // Group by type
      const missionsByType = {
        hunt: missions.filter(m => m.type === 'hunt'),
        survival: missions.filter(m => m.type === 'survival'),
        bossRush: missions.filter(m => m.type === 'boss_rush'),
        tower: missions.filter(m => m.type === 'tower'),
        dungeon: missions.filter(m => m.type === 'dungeon')
      };

      let html = `
        <div class="mission-section-header">
          <h3>Available Missions</h3>
          <p>Select a mission to view details and start</p>
        </div>
        <div class="mission-type-sections">
      `;

      // Hunt Missions
      if (missionsByType.hunt.length > 0) {
        html += `
          <div class="mission-type-section">
            <h4 class="mission-type-title">ğŸ¯ Hunt Bounties</h4>
            <div class="mission-grid">
              ${missionsByType.hunt.map(m => this.renderMissionCard(m)).join('')}
            </div>
          </div>
        `;
      }

      // Survival Missions
      if (missionsByType.survival.length > 0) {
        html += `
          <div class="mission-type-section">
            <h4 class="mission-type-title">ğŸ§Ÿ Horde Survival</h4>
            <div class="mission-grid">
              ${missionsByType.survival.map(m => this.renderMissionCard(m)).join('')}
            </div>
          </div>
        `;
      }

      // Boss Rush Missions
      if (missionsByType.bossRush.length > 0) {
        html += `
          <div class="mission-type-section">
            <h4 class="mission-type-title">âš”ï¸ Boss Rush</h4>
            <div class="mission-grid">
              ${missionsByType.bossRush.map(m => this.renderMissionCard(m)).join('')}
            </div>
          </div>
        `;
      }

      // Tower Missions
      if (missionsByType.tower.length > 0) {
        html += `
          <div class="mission-type-section">
            <h4 class="mission-type-title">ğŸ° Tower Floors</h4>
            <div class="mission-grid">
              ${missionsByType.tower.map(m => this.renderMissionCard(m)).join('')}
            </div>
          </div>
        `;
      }

      // Dungeon Missions
      if (missionsByType.dungeon.length > 0) {
        html += `
          <div class="mission-type-section">
            <h4 class="mission-type-title">ğŸ›ï¸ Dungeon Runs</h4>
            <div class="mission-grid">
              ${missionsByType.dungeon.map(m => this.renderMissionCard(m)).join('')}
            </div>
          </div>
        `;
      }

      html += '</div>';

      // Mission details modal
      if (this.selectedMission) {
        html += this.renderMissionDetails(this.selectedMission);
      }

      return html;
    },

    // Render active mission
    renderActiveMission() {
      const activeMission = window.gameState?.missions?.active;
      
      if (!activeMission) {
        return `
          <div class="mission-empty">
            <p>No active mission</p>
            <p>Go to Available missions to start one!</p>
          </div>
        `;
      }

      const mission = window.MissionDatabase.getMissionById(activeMission.id);
      if (!mission) {
        return '<div class="mission-error">Active mission data not found</div>';
      }

      const progress = window.gameState.missions.progress[activeMission.id] || { current: 0, target: 1 };
      const progressPercent = Math.min((progress.current / progress.target) * 100, 100);

      return `
        <div class="active-mission-container">
          <div class="active-mission-header">
            <h3>${mission.name}</h3>
            <button class="btn-abandon-mission" onclick="window.MissionBoardRenderer.abandonMission()">Abandon</button>
          </div>
          
          <div class="mission-description">
            <p>${mission.description}</p>
          </div>

          ${this.renderMissionProgress(mission, progress)}

          <div class="mission-rewards-preview">
            <h4>Rewards:</h4>
            ${this.renderRewards(mission.rewards)}
          </div>
        </div>
      `;
    },

    // Render completed missions
    renderCompletedMissions() {
      const completed = window.gameState?.missions?.completed || [];
      
      if (completed.length === 0) {
        return '<div class="mission-empty">No completed missions yet</div>';
      }

      let html = `
        <div class="mission-section-header">
          <h3>Completed Missions</h3>
          <p>${completed.length} mission${completed.length !== 1 ? 's' : ''} completed</p>
        </div>
        <div class="mission-grid completed-missions">
      `;

      completed.forEach(missionId => {
        const mission = window.MissionDatabase.getMissionById(missionId);
        if (mission) {
          html += this.renderMissionCard(mission, true);
        }
      });

      html += '</div>';
      return html;
    },

    // Render dungeons and towers
    renderDungeonsAndTowers() {
      let html = `
        <div class="mission-section-header">
          <h3>Dungeons & Towers</h3>
          <p>Teleport to dungeons and towers directly. Clear floors to unlock higher ranks!</p>
        </div>
      `;

      // Add Dungeon Raid section if DungeonProgression is available
      if (window.DungeonProgression && window.DungeonRoomData) {
        const playerLevel = window.gameState?.playerLevel || 1;
        const availableDungeons = window.DungeonProgression.getAvailableDungeons(playerLevel);
        
        if (availableDungeons.length > 0) {
          html += `
            <div class="dungeon-section">
              <h4>ğŸ° Dungeon Raids (C-Rank to SSS-Rank)</h4>
              <div class="dungeon-grid">
                ${availableDungeons.map(dungeon => this.renderDungeonRaidCard(dungeon)).join('')}
              </div>
            </div>
          `;
        } else {
          html += `
            <div class="dungeon-section">
              <p class="mission-empty">No dungeons available yet. Level up to unlock C-Rank dungeons!</p>
            </div>
          `;
        }
      }

      // Add existing tower/dungeon missions if available
      if (window.MissionDatabase) {
        const towers = window.MissionDatabase.getMissionsByType('tower');
        const dungeons = window.MissionDatabase.getMissionsByType('dungeon');

        if (towers.length > 0) {
          html += `
            <div class="dungeon-section">
              <h4>ğŸ° Towers</h4>
              <div class="dungeon-grid">
                ${towers.map(tower => this.renderDungeonCard(tower, 'tower')).join('')}
              </div>
            </div>
          `;
        }

        if (dungeons.length > 0) {
          html += `
            <div class="dungeon-section">
              <h4>ğŸ›ï¸ Dungeons</h4>
              <div class="dungeon-grid">
                ${dungeons.map(dungeon => this.renderDungeonCard(dungeon, 'dungeon')).join('')}
              </div>
            </div>
          `;
        }
      }

      return html;
    },

    // Render dungeon raid card (C-SSS rank)
    renderDungeonRaidCard(dungeon) {
      const progress = window.DungeonProgression.getRankProgress(dungeon.rankId);
      const progressPercent = progress ? progress.progressPercent : 0;
      const raidKeysOwned = window.gameState?.raidKeys ?? 0;
      const accent = dungeon.color || '#8df5ff';
      const [r, g, b] = this.hexToRgb(accent);
      return `
        <div class="dungeon-card ${dungeon.isCleared ? 'completed' : ''}" 
             data-rank-id="${dungeon.rankId}"
             data-rank-color="${accent}"
             tabindex="0"
             style="--dungeon-rank-color:${accent}; --dungeon-rank-color-rgb:${r},${g},${b};">
          <div class="dungeon-holo"></div>
          <div class="dungeon-card-inner">
            <div class="dungeon-header">
              <h4>${dungeon.name} Dungeons</h4>
              <span class="dungeon-type-badge" style="background-color: ${accent}20; color: ${accent};">
                ${dungeon.rankId}-Rank
              </span>
            </div>
            
            <div class="dungeon-info">
              <p>${dungeon.description}</p>
              
              <div class="dungeon-stats">
                <div class="stat-row">
                  <span>Floors:</span>
                  <span>${dungeon.floorsCleared} / ${dungeon.floors}</span>
                </div>
                <div class="stat-row">
                  <span>Rooms/Floor:</span>
                  <span>${dungeon.roomsPerFloor}</span>
                </div>
                <div class="stat-row">
                  <span>Entries:</span>
                  <span>${dungeon.entriesRemaining === 'Unlimited' ? 'âˆ' : dungeon.entriesRemaining} / ${dungeon.entriesUsed + (dungeon.entriesRemaining === 'Unlimited' ? 0 : parseInt(dungeon.entriesRemaining))}</span>
                </div>
                <div class="stat-row">
                  <span>Entry Cost:</span>
                  <span>${(dungeon.entryCostGold || 0).toLocaleString()} Gold</span>
                </div>
                <div class="stat-row">
                  <span>Raid Keys:</span>
                  <span>${dungeon.raidKeyCost || 0} required â€¢ ${raidKeysOwned} owned</span>
                </div>
                <div class="stat-row">
                  <span>Recommended Power:</span>
                  <span>${dungeon.recommendedPower?.toLocaleString?.() || 'â€”'}</span>
                </div>
                ${dungeon.enemyMultiplier ? `
                  <div class="stat-row">
                    <span>Difficulty:</span>
                    <span>${dungeon.enemyMultiplier}x</span>
                  </div>
                ` : ''}
              </div>
              
              ${progress ? `
                <div class="dungeon-progress">
                  <div class="progress-bar-container">
                    <div class="progress-bar" style="width: ${progressPercent}%; background-color: ${accent};"></div>
                  </div>
                  <div class="progress-text">${progress.floorsCleared} / ${progress.totalFloors} Floors Cleared</div>
                </div>
              ` : ''}
            </div>
            
            <div class="dungeon-footer">
              ${dungeon.canEnter ? `
                <button class="btn-enter-dungeon" 
                        onclick="window.MissionBoardRenderer.enterDungeonRaid('${dungeon.rankId}')"
                        style="background-color: ${accent};">
                  Enter Dungeon
                </button>
              ` : `
                <div class="dungeon-locked" style="color: ${accent};">
                  ${dungeon.cannotEnterReason || 'Locked'}
                </div>
              `}
              ${dungeon.isCleared ? `
                <div class="dungeon-completed-badge">âœ“ Rank Cleared</div>
              ` : ''}
            </div>
          </div>
        </div>
      `;
    },

    // Enter dungeon raid
    async enterDungeonRaid(rankId) {
      const playerLevel = window.gameState?.playerLevel || 1;
      const canEnter = window.DungeonProgression.canEnterDungeon(rankId, playerLevel);
      
      if (!canEnter.allowed) {
        alert(`Cannot enter dungeon: ${canEnter.reason}`);
        return;
      }
      
      const availableDungeons = window.DungeonProgression.getAvailableDungeons(playerLevel);
      const dungeonMeta = availableDungeons.find(d => d.rankId === rankId) || null;
      try {
        await this.runDungeonFlyThrough(rankId, dungeonMeta);
      } catch (error) {
        debugWarn('[MissionBoardRenderer] Fly-through sequence interrupted', error);
      }
      
      const enterResult = window.DungeonProgression.enterDungeon(rankId);
      if (!enterResult.success) {
        alert(`Failed to enter dungeon: ${enterResult.error}`);
        return;
      }
      
    // Use the routed sequence when available; pick a fallback template otherwise so runs always start with a deterministic payload.
    const routeSequence = Array.isArray(enterResult.sequence) && enterResult.sequence.length > 0
      ? [...enterResult.sequence]
      : Object.keys(window.DungeonRoomData.roomTypes);
    const firstFloorId = routeSequence[0];
    const firstRoom = window.DungeonRoomGenerator.generateRoom(
      firstFloorId,
      rankId,
      1,
      0,
      routeSequence.length === 1
    );
    
    // Update the run object that enterDungeon already created
    const dungeonState = window.gameState.dungeons;
    const run = dungeonState.currentDungeon;
    if (run) {
      // Update the existing run object with room data
      run.sequence = routeSequence;
      run.floorIndex = 0;
      run.currentRoom = firstRoom;
      run.timeline = run.timeline || [];
    } else {
      // Fallback: create run if enterDungeon didn't create one (shouldn't happen)
      dungeonState.currentDungeon = {
        rankId,
        routeId: enterResult.routeId || null,
        sequence: routeSequence,
        floorIndex: 0,
        branchChoices: {},
        modifiers: enterResult.modifiers || {},
        startTime: Date.now(),
        clearedFloors: {},
        timeline: [],
        currentRoom: firstRoom
      };
    }
    dungeonState.currentRoom = firstRoom;
    
    if (window.CandyDungeonCombat) {
      window.CandyDungeonCombat.primeEncounter({ ...firstRoom, rankId });
    }
      
      // Dispatch event to start dungeon
      window.dispatchEvent(new CustomEvent('dungeon:raid_started', {
        detail: {
        rankId,
          room: firstRoom
        }
      }));
      
    // Sound hook helps reinforce the candy UI feedback; inline comment requested to clarify the intent.
    if (window.playCandySfx) {
      window.playCandySfx('ui-click');
    }
    
    if (window.BagSystem && window.BagSystem.showToast) {
      window.BagSystem.showToast(`Entering ${rankId}-Rank Dungeon: ${firstRoom.type.replace(/_/g, ' ')}`);
      }
      
      // Close bag and start dungeon
      if (window.BagSystem) {
        if (typeof window.BagSystem.createParticleEffect === 'function') {
          const bagWindowEl = document.getElementById('bagWindow');
          if (bagWindowEl) {
            const rect = bagWindowEl.getBoundingClientRect();
            const rankColor = window.DungeonRoomData?.ranks?.[rankId]?.color;
            window.BagSystem.createParticleEffect(
              'raid-entry',
              rect.left + rect.width / 2,
              rect.top + rect.height / 2,
              { color: rankColor, count: 22 }
            );
          }
        }
        window.BagSystem.close();
      }
    },

    // Render a mission card
    renderMissionCard(mission, isCompleted = false) {
      const difficultyStars = 'â­'.repeat(mission.difficulty || 1);
      const typeIcon = this.getMissionTypeIcon(mission.type);

      return `
        <div class="mission-card ${isCompleted ? 'completed' : ''}" 
             data-mission-id="${mission.id}"
             onclick="window.MissionBoardRenderer.selectMission('${mission.id}')">
          <div class="mission-card-header">
            <span class="mission-type-icon">${typeIcon}</span>
            <h4>${mission.name}</h4>
            <div class="difficulty-stars">${difficultyStars}</div>
          </div>
          
          <div class="mission-card-body">
            <p class="mission-card-description">${mission.description}</p>
            
            ${this.renderMissionPreview(mission)}
            
            <div class="mission-rewards-preview">
              ${this.renderRewardsPreview(mission.rewards)}
            </div>
          </div>

          ${!isCompleted ? `
            <div class="mission-card-footer">
              <button class="btn-start-mission" onclick="event.stopPropagation(); window.MissionBoardRenderer.startMission('${mission.id}')">
                Start Mission
              </button>
            </div>
          ` : `
            <div class="mission-card-footer">
              <span class="completed-badge">âœ“ Completed</span>
            </div>
          `}
        </div>
      `;
    },

    // Render dungeon/tower card
    renderDungeonCard(location, type) {
      const accent = location.color || (type === 'tower' ? '#ffd77a' : '#7af8c8');
      const [r, g, b] = this.hexToRgb(accent);
      return `
        <div class="dungeon-card" data-location-id="${location.id}" data-rank-color="${accent}" tabindex="0" style="--dungeon-rank-color:${accent}; --dungeon-rank-color-rgb:${r},${g},${b};">
          <div class="dungeon-holo"></div>
          <div class="dungeon-card-inner">
            <div class="dungeon-header">
              <h4>${location.name}</h4>
              <span class="dungeon-type-badge" style="background-color:${accent}20; color:${accent};">${type === 'tower' ? 'ğŸ° Tower' : 'ğŸ›ï¸ Dungeon'}</span>
            </div>
            
            <div class="dungeon-info">
              <p>${location.description}</p>
              ${type === 'tower' ? `
                <div class="dungeon-stats">
                  <span>Floor ${location.floor}</span>
                  <span>${location.waves} Waves</span>
                </div>
              ` : `
                <div class="dungeon-stats">
                  <span>${location.rooms} Rooms</span>
                </div>
              `}
            </div>

            <div class="dungeon-rewards">
              ${this.renderRewardsPreview(location.rewards)}
            </div>

            <div class="dungeon-footer">
              <button class="btn-teleport" onclick="window.MissionBoardRenderer.teleportToLocation('${location.id}', '${type}')" style="background: ${accent};">
                ${type === 'tower' ? 'Enter Tower' : 'Enter Dungeon'}
              </button>
            </div>
          </div>
        </div>
      `;
    },

    // Render mission details modal
    renderMissionDetails(missionId) {
      const mission = window.MissionDatabase.getMissionById(missionId);
      if (!mission) return '';

      return `
        <div class="mission-details-modal" id="missionDetailsModal">
          <div class="mission-details-content">
            <div class="mission-details-header">
              <h3>${mission.name}</h3>
              <button class="btn-close-modal" onclick="window.MissionBoardRenderer.closeMissionDetails()">Ã—</button>
            </div>
            
            <div class="mission-details-body">
              <p class="mission-details-description">${mission.description}</p>
              
              ${this.renderMissionFullDetails(mission)}
              
              <div class="mission-details-rewards">
                <h4>Rewards:</h4>
                ${this.renderRewards(mission.rewards)}
              </div>
            </div>

            <div class="mission-details-footer">
              <button class="btn-start-mission-large" onclick="window.MissionBoardRenderer.startMission('${mission.id}')">
                Start Mission
              </button>
            </div>
          </div>
        </div>
      `;
    },

    // Render full mission details
    renderMissionFullDetails(mission) {
      let html = '<div class="mission-full-details">';

      if (mission.type === 'hunt') {
        html += `
          <div class="mission-detail-row">
            <strong>Target:</strong> ${mission.targetEnemy || 'Unknown'}
          </div>
          <div class="mission-detail-row">
            <strong>Required Kills:</strong> ${mission.targetCount || 1}
          </div>
        `;
      } else if (mission.type === 'survival') {
        const minutes = Math.floor((mission.duration || 0) / 60000);
        html += `
          <div class="mission-detail-row">
            <strong>Duration:</strong> ${minutes} minute${minutes !== 1 ? 's' : ''}
          </div>
          <div class="mission-detail-row">
            <strong>Enemy Type:</strong> ${mission.enemyType || 'Mixed'}
          </div>
          <div class="mission-detail-row">
            <strong>Spawn Rate:</strong> ${mission.spawnRate || 1} per second
          </div>
        `;
      } else if (mission.type === 'boss_rush') {
        html += `
          <div class="mission-detail-row">
            <strong>Bosses:</strong> ${mission.bosses.length}
          </div>
          <div class="mission-boss-list">
            ${mission.bosses.map(bossId => `<span class="boss-tag">${bossId}</span>`).join('')}
          </div>
        `;
      } else if (mission.type === 'tower') {
        html += `
          <div class="mission-detail-row">
            <strong>Floor:</strong> ${mission.floor}
          </div>
          <div class="mission-detail-row">
            <strong>Waves:</strong> ${mission.waves}
          </div>
          <div class="mission-detail-row">
            <strong>Boss:</strong> ${mission.boss || 'None'}
          </div>
        `;
      } else if (mission.type === 'dungeon') {
        html += `
          <div class="mission-detail-row">
            <strong>Rooms:</strong> ${mission.rooms}
          </div>
        `;
      }

      html += '</div>';
      return html;
    },

    // Render mission preview
    renderMissionPreview(mission) {
      if (mission.type === 'hunt') {
        return `<div class="mission-preview">Kill ${mission.targetCount || 1} ${mission.targetEnemy || 'enemies'}</div>`;
      } else if (mission.type === 'survival') {
        const minutes = Math.floor((mission.duration || 0) / 60000);
        return `<div class="mission-preview">Survive ${minutes} minute${minutes !== 1 ? 's' : ''}</div>`;
      } else if (mission.type === 'boss_rush') {
        return `<div class="mission-preview">Fight ${mission.bosses.length} bosses</div>`;
      } else if (mission.type === 'tower') {
        return `<div class="mission-preview">Floor ${mission.floor} - ${mission.waves} waves</div>`;
      } else if (mission.type === 'dungeon') {
        return `<div class="mission-preview">${mission.rooms} rooms</div>`;
      }
      return '';
    },

    // Render mission progress
    renderMissionProgress(mission, progress) {
      const progressPercent = Math.min((progress.current / progress.target) * 100, 100);
      
      let progressText = '';
      if (mission.type === 'hunt') {
        progressText = `Killed: ${progress.current} / ${progress.target}`;
      } else if (mission.type === 'survival') {
        const seconds = Math.floor(progress.current / 1000);
        const minutes = Math.floor(seconds / 60);
        progressText = `Survived: ${minutes}:${(seconds % 60).toString().padStart(2, '0')}`;
      } else if (mission.type === 'boss_rush') {
        progressText = `Bosses Defeated: ${progress.current} / ${progress.target}`;
      } else if (mission.type === 'tower') {
        progressText = `Waves Cleared: ${progress.current} / ${progress.target}`;
      } else if (mission.type === 'dungeon') {
        progressText = `Rooms Explored: ${progress.current} / ${progress.target}`;
      }

      return `
        <div class="mission-progress">
          <div class="progress-bar-container">
            <div class="progress-bar" style="width: ${progressPercent}%"></div>
          </div>
          <div class="progress-text">${progressText}</div>
        </div>
      `;
    },

    // Render rewards
    renderRewards(rewards) {
      if (!rewards) return '<div>No rewards</div>';

      let html = '<div class="rewards-list">';
      
      if (rewards.gold) {
        html += `<div class="reward-item"><span class="reward-icon">ğŸ’°</span> ${rewards.gold} Gold</div>`;
      }
      
      if (rewards.xp) {
        html += `<div class="reward-item"><span class="reward-icon">â­</span> ${rewards.xp} XP</div>`;
      }
      
      if (rewards.items && rewards.items.length > 0) {
        rewards.items.forEach(itemId => {
          html += `<div class="reward-item"><span class="reward-icon">ğŸ“¦</span> ${itemId}</div>`;
        });
      }

      html += '</div>';
      return html;
    },

    // Render rewards preview (compact)
    renderRewardsPreview(rewards) {
      if (!rewards) return '<div class="rewards-preview-empty">No rewards</div>';

      let parts = [];
      if (rewards.gold) parts.push(`ğŸ’°${rewards.gold}`);
      if (rewards.xp) parts.push(`â­${rewards.xp}`);
      if (rewards.items && rewards.items.length > 0) {
        parts.push(`ğŸ“¦${rewards.items.length} item${rewards.items.length !== 1 ? 's' : ''}`);
      }

      return `<div class="rewards-preview">${parts.join(' â€¢ ')}</div>`;
    },

    // Get mission type icon
    getMissionTypeIcon(type) {
      const icons = {
        hunt: 'ğŸ¯',
        survival: 'ğŸ§Ÿ',
        boss_rush: 'âš”ï¸',
        tower: 'ğŸ°',
        dungeon: 'ğŸ›ï¸'
      };
      return icons[type] || 'ğŸ“‹';
    },

    // Select mission (show details)
    selectMission(missionId) {
      this.selectedMission = missionId;
      this.renderMissionBoardTab();
    },

    // Close mission details
    closeMissionDetails() {
      this.selectedMission = null;
      this.renderMissionBoardTab();
    },

    // Start mission
    startMission(missionId) {
      const mission = window.MissionDatabase.getMissionById(missionId);
      if (!mission) {
        debugError('[MissionBoard] Mission not found:', missionId);
        return;
      }

    // Make sure the missions container exists before we read its properties; live sessions can hit this before init wires defaults.
    if (!window.gameState.missions) {
      window.gameState.missions = { available: [], active: null, completed: [], progress: {} };
    }

    // Shared handler so we can reuse the remaining start logic after any confirmation flow.
    const finalizeStart = () => {
      const missionsState = window.gameState.missions;
      const previous = missionsState.active;
      if (previous && previous.id && previous.id !== mission.id && missionsState.progress) {
        delete missionsState.progress[previous.id];
      }

      // Set active mission payload with start metadata
      missionsState.active = {
        id: mission.id,
        startTime: Date.now(),
        ...mission
      };

      // Initialize progress
      let target = 1;
      if (mission.type === 'hunt') {
        target = mission.targetCount || 1;
      } else if (mission.type === 'survival') {
        target = mission.duration || 300000;
      } else if (mission.type === 'boss_rush') {
        target = mission.bosses.length;
      } else if (mission.type === 'tower') {
        target = mission.waves || 20;
      } else if (mission.type === 'dungeon') {
        target = mission.rooms || 5;
      }

      window.gameState.missions.progress[mission.id] = {
        current: 0,
        target
      };

      // Dispatch event for game to handle
      window.dispatchEvent(new CustomEvent('mission:started', {
        detail: { missionId: mission.id, mission }
      }));

      // Show toast
      if (window.BagSystem?.showToast) {
        window.BagSystem.showToast(`Mission started: ${mission.name}`);
      }

      // Switch to active tab
      this.currentSubsection = 'active';
      this.selectedMission = null;
      this.renderMissionBoardTab();
    };

    // Check if there's already an active mission
    const existingMission = window.gameState.missions.active;
    if (existingMission) {
      if (existingMission.id === mission.id) {
        finalizeStart();
        return;
      }

      const confirmMessage = 'You already have an active mission. Abandon it and start this one?';
      if (window.BagSystem?.showConfirmDialog) {
        window.BagSystem.showConfirmDialog(
          confirmMessage,
          () => {
            window.gameState.missions.active = null;
            finalizeStart();
          },
          () => {
            // No-op when the user cancels; we intentionally leave the existing mission running.
          }
        );
        return;
      }

      if (!confirm(confirmMessage)) {
        return;
      }

      window.gameState.missions.active = null;
    }

    finalizeStart();

    },

    // Abandon mission
    abandonMission() {
      if (!confirm('Are you sure you want to abandon this mission?')) {
        return;
      }

      window.gameState.missions.active = null;
      this.renderMissionBoardTab();
    },

    // Teleport to location
    teleportToLocation(locationId, type) {
      const location = window.MissionDatabase.getMissionById(locationId);
      if (!location) {
        debugError('[MissionBoard] Location not found:', locationId);
        return;
      }

      // Dispatch event for game to handle teleportation
      window.dispatchEvent(new CustomEvent('dungeon:teleport', {
        detail: { locationId: locationId, location: location, type: type }
      }));

      if (window.BagSystem && window.BagSystem.showToast) {
        window.BagSystem.showToast(`Teleporting to ${location.name}...`);
      }

      // Close bag
      if (window.BagSystem && window.BagSystem.close) {
        setTimeout(() => window.BagSystem.close(), 500);
      }
    },

    handleCinematicPostRender() {
      this.detachCinematicCardListeners();
      if (this.currentSubsection === 'dungeons') {
        this.attachCinematicCardListeners();
      } else {
        this.clearAdaptiveColorGrade(true);
      }
    },

    attachCinematicCardListeners() {
      const cards = Array.from(document.querySelectorAll('.mission-board-container .dungeon-card'));
      if (!cards.length) {
        this.clearAdaptiveColorGrade(true);
        return;
      }
      this.cinematicCleanupFns = this.cinematicCleanupFns || [];

      cards.forEach((card) => {
        card.style.setProperty('--holo-tilt-x', '0deg');
        card.style.setProperty('--holo-tilt-y', '0deg');
        card.style.setProperty('--holo-spot-x', '50%');
        card.style.setProperty('--holo-spot-y', '50%');
        const onEnter = () => {
          const color = card.dataset.rankColor;
          if (color) {
            this.applyAdaptiveColorGrade(color);
          }
          card.classList.add('is-active');
        };
        const onLeave = () => {
          card.classList.remove('is-active');
          card.style.removeProperty('--holo-tilt-x');
          card.style.removeProperty('--holo-tilt-y');
          card.style.removeProperty('--holo-spot-x');
          card.style.removeProperty('--holo-spot-y');
          this.clearAdaptiveColorGrade();
        };
        const onMove = (evt) => this.updateHologramTilt(card, evt);
        const onFocus = () => onEnter();
        const onBlur = () => onLeave();

        card.addEventListener('mouseenter', onEnter);
        card.addEventListener('mouseleave', onLeave);
        card.addEventListener('mousemove', onMove);
        card.addEventListener('focus', onFocus);
        card.addEventListener('blur', onBlur);

        this.cinematicCleanupFns.push(() => {
          card.removeEventListener('mouseenter', onEnter);
          card.removeEventListener('mouseleave', onLeave);
          card.removeEventListener('mousemove', onMove);
          card.removeEventListener('focus', onFocus);
          card.removeEventListener('blur', onBlur);
        });
      });

      const firstColoredCard = cards.find((card) => card.dataset.rankColor);
      if (firstColoredCard) {
        this.applyAdaptiveColorGrade(firstColoredCard.dataset.rankColor);
        firstColoredCard.classList.add('is-active');
        this.cinematicCleanupFns.push(() => firstColoredCard.classList.remove('is-active'));
      }
    },

    detachCinematicCardListeners() {
      if (!Array.isArray(this.cinematicCleanupFns)) return;
      while (this.cinematicCleanupFns.length) {
        const dispose = this.cinematicCleanupFns.pop();
        try {
          dispose?.();
        } catch (error) {
          debugWarn('[MissionBoardRenderer] Failed to dispose cinematic listener', error);
        }
      }
      this.cinematicCleanupFns = [];
    },

    updateHologramTilt(card, evt) {
      const rect = card.getBoundingClientRect();
      const relX = Math.min(Math.max((evt.clientX - rect.left) / rect.width, 0), 1);
      const relY = Math.min(Math.max((evt.clientY - rect.top) / rect.height, 0), 1);
      const tiltX = (0.5 - relY) * 10;
      const tiltY = (relX - 0.5) * 12;
      card.style.setProperty('--holo-tilt-x', `${tiltX}deg`);
      card.style.setProperty('--holo-tilt-y', `${tiltY}deg`);
      card.style.setProperty('--holo-spot-x', `${(relX * 100).toFixed(2)}%`);
      card.style.setProperty('--holo-spot-y', `${(relY * 100).toFixed(2)}%`);
    },

    applyAdaptiveColorGrade(color) {
      if (!color) return;
      const body = document.body;
      if (!body) return;
      const [r, g, b] = this.hexToRgb(color);
      body.classList.add('mission-grade-active');
      body.style.setProperty('--mission-grade-color-rgb', `${r}, ${g}, ${b}`);
      this.activeColorGrade = color;
    },

    clearAdaptiveColorGrade(force = false) {
      if (!force && !this.activeColorGrade) return;
      const body = document.body;
      if (!body) return;
      body.classList.remove('mission-grade-active');
      body.style.removeProperty('--mission-grade-color-rgb');
      this.activeColorGrade = null;
    },

    hexToRgb(hex) {
      if (typeof hex !== 'string') return [147, 51, 234];
      let normalized = hex.replace('#', '').trim();
      if (normalized.length === 3) {
        normalized = normalized.split('').map((char) => char + char).join('');
      }
      const value = parseInt(normalized, 16);
      if (Number.isNaN(value)) return [147, 51, 234];
      return [
        (value >> 16) & 255,
        (value >> 8) & 255,
        value & 255
      ];
    },

    async runDungeonFlyThrough(rankId, dungeonMeta) {
      if (window.DungeonCinematicsDev?.skipFlyThrough) {
        return;
      }
      if (this.flythroughActive) {
        return;
      }
      this.flythroughActive = true;
      const accent = dungeonMeta?.color || '#8df5ff';
      const [r, g, b] = this.hexToRgb(accent);
      this.applyAdaptiveColorGrade(accent);

      const duration = window.DungeonCinematicsDev?.flyThroughDuration ?? 1400;

      await new Promise((resolve) => {
        const overlay = document.createElement('div');
        overlay.className = 'dungeon-flythrough';
        overlay.style.setProperty('--mission-grade-color-rgb', `${r}, ${g}, ${b}`);
        overlay.innerHTML = `
          <div class="flythrough-layer layer-stars" style="background: radial-gradient(circle at center, rgba(${r}, ${g}, ${b}, 0.22), transparent 68%);"></div>
          <div class="flythrough-layer layer-grid" style="background: radial-gradient(circle at center, rgba(${r}, ${g}, ${b}, 0.3), transparent 70%);"></div>
          <div class="flythrough-title">
            <div class="flythrough-rank" style="color:${accent};">
              <span>${rankId || 'Rank'}</span>
              <span>Gate</span>
            </div>
            <div class="flythrough-name">${dungeonMeta?.name || 'Unknown Dungeon'}</div>
            <div class="flythrough-hint">Tap to skip</div>
          </div>
        `;

        let finished = false;
        const finalize = () => {
          if (finished) return;
          finished = true;
          overlay.classList.add('is-skip-ready');
          overlay.style.pointerEvents = 'none';
          overlay.style.animation = 'flythroughFade 0.55s ease-out reverse';
          window.BagSystem?.stopAudioLayer?.('flythrough-swell');
          window.setTimeout(() => {
            if (overlay.parentNode) overlay.remove();
            resolve();
          }, 260);
        };

        window.setTimeout(finalize, duration);
        overlay.addEventListener('click', finalize, { once: true });
        document.body.appendChild(overlay);

        window.requestAnimationFrame(() => {
          window.BagSystem?.createParticleEffect?.('raid-entry', window.innerWidth / 2, window.innerHeight / 2, {
            colors: [accent, '#ffffff'],
            count: 18
          });
          window.BagSystem?.createParticleEffect?.('raid-contrail', window.innerWidth / 2, window.innerHeight / 2, {
            colors: [accent, '#ffffff'],
            count: 16,
            duration: duration
          });
          window.BagSystem?.playAudioLayer?.('flythrough-swell', {
            waveform: 'sine',
            frequency: 420,
            gain: 0.12,
            duration: duration / 1000 + 0.4
          });
        });
      }).catch(() => {});

      this.flythroughActive = false;
      if (!window.DungeonCinematicsDev?.persistGradeAfterFlyThrough) {
        this.clearAdaptiveColorGrade(true);
      }
    },

    // Attach event listeners
    attachEventListeners() {
      // Subsection tabs
      document.querySelectorAll('.mission-subtab').forEach(tab => {
        tab.addEventListener('click', (e) => {
          this.currentSubsection = e.currentTarget.dataset.subsection;
          this.renderMissionBoardTab();
        });
      });
    }
  };

  debugLog('[MissionBoardRenderer] Mission board renderer ready');
})();

