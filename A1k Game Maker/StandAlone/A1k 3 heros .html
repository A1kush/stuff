<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>A1K Ultimate Mega Engine</title>

    <!-- 1. ERROR SAFETY & LOGGING -->
    <script>
        window.onerror = function(msg, url, line) {
            const log = document.getElementById('debug-console');
            if(log) {
                log.style.display = 'block';
                log.innerHTML += `âŒ ${msg} (Line ${line})<br>`;
            }
        };
    </script>

    <!-- 2. THREE.JS IMPORT (Offline Compatible if downloaded) -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <!-- 3. BAG SYSTEM - Manifest Path Configuration -->
    <script>
        // Configure manifest paths before bag system scripts load
        window.A1K_ALL_MANIFESTS_PATH = 'bag last updte/all-manifests.json';
        window.A1K_ASSET_MANIFEST_PATH = 'bag last updte/all-manifests.json';
        window.A1K_ARCADE_MANIFEST_PATH = 'bag last updte/all-manifests.json';
    </script>

    <!-- 3.5. BAG SYSTEM - Inline Manifests & Fetch Shim (CORS Fix for file://) -->
    <script>
        // Inline Manifests (asset + arcade) for offline usage - prevents CORS errors
        window.__ASSET_MANIFEST = {
            "assets": [
                {"id":"pet_firecub","type":"pet","icon":"ğŸ•","rarity":"common"},
                {"id":"veh_hoverbike","type":"vehicle","icon":"ğŸï¸","rarity":"uncommon"},
                {"id":"veh_cybercar","type":"vehicle","icon":"ğŸš—","rarity":"rare"}
            ]
        };
        window.__ARCADE_MANIFEST = {
            name:"A1K Arcade System",version:"1.0.0",games:[
                {id:"slots",name:"Slot Machine",icon:"ğŸ°"},
                {id:"rps",name:"Rock Paper Scissors",icon:"âœŠâœ‹âœŒï¸"},
                {id:"dice",name:"Dice Duel",icon:"ğŸ²"},
                {id:"wheel",name:"Color Wheel",icon:"ğŸ¡"},
                {id:"highlow",name:"High-Low Card",icon:"ğŸƒ"}
            ]
        };

        // Fetch shim to intercept manifest requests (handles file:// CORS issues)
        const ORIG_FETCH = window.fetch;
        window.fetch = async function(resource, init){
            if(typeof resource === 'string'){
                // Handle all-manifests.json requests
                if(resource.includes('all-manifests.json')){
                    // Try to load the actual file first, fall back to inline data
                    try {
                        const response = await ORIG_FETCH(resource, { cache: 'no-store' });
                        if(response.ok){
                            const data = await response.json();
                            window.__ALL_MANIFESTS = data;
                            return new Response(JSON.stringify(data), {status:200, headers:{'Content-Type':'application/json'}});
                        }
                    } catch(e) {
                        // CORS error or file not found - use inline data
                        console.warn('[Fetch Shim] Could not load manifest file, using inline data:', resource);
                    }
                    // Fallback: Return the merged manifest with all data nested under keys
                    const allManifests = {
                        assetManifest: window.__ASSET_MANIFEST || { version: 1, assets: [] },
                        bagManifest: window.__BAG_MANIFEST || {},
                        unifiedManifests: window.__UNIFIED_MANIFESTS || {},
                        arcadeManifest: window.__ARCADE_MANIFEST || { name: "A1K Arcade System", version: "1.0.0", games: [] }
                    };
                    window.__ALL_MANIFESTS = allManifests;
                    return new Response(JSON.stringify(allManifests), {status:200, headers:{'Content-Type':'application/json'}});
                }
                // Handle asset_manifest.json requests
                if(resource.includes('asset_manifest.json')){
                    // Try to load from all-manifests.json first
                    if(!window.__ALL_MANIFESTS){
                        try {
                            const allManPath = resource.replace('asset_manifest.json', 'all-manifests.json');
                            const response = await ORIG_FETCH(allManPath, { cache: 'no-store' });
                            if(response.ok){
                                window.__ALL_MANIFESTS = await response.json();
                            }
                        } catch(e) {}
                    }
                    // Extract assetManifest from all-manifests if available
                    if(window.__ALL_MANIFESTS && window.__ALL_MANIFESTS.assetManifest){
                        return new Response(JSON.stringify(window.__ALL_MANIFESTS.assetManifest), {status:200, headers:{'Content-Type':'application/json'}});
                    }
                    // Fallback to inline data
                    return new Response(JSON.stringify(window.__ASSET_MANIFEST), {status:200, headers:{'Content-Type':'application/json'}});
                }
                // Handle arcade-manifest.json requests
                if(resource.includes('arcade-manifest.json')){
                    // Try to load from all-manifests.json first
                    if(!window.__ALL_MANIFESTS){
                        try {
                            const allManPath = resource.replace('arcade-manifest.json', 'all-manifests.json');
                            const response = await ORIG_FETCH(allManPath, { cache: 'no-store' });
                            if(response.ok){
                                window.__ALL_MANIFESTS = await response.json();
                            }
                        } catch(e) {}
                    }
                    // Extract arcadeManifest from all-manifests if available
                    if(window.__ALL_MANIFESTS && window.__ALL_MANIFESTS.arcadeManifest){
                        return new Response(JSON.stringify(window.__ALL_MANIFESTS.arcadeManifest), {status:200, headers:{'Content-Type':'application/json'}});
                    }
                    // Fallback to inline data
                    return new Response(JSON.stringify(window.__ARCADE_MANIFEST), {status:200, headers:{'Content-Type':'application/json'}});
                }
            }
            // For all other requests, use original fetch
            return ORIG_FETCH(resource, init);
        };
    </script>

    <!-- 4. BAG SYSTEM - CSS Stylesheet -->
    <link rel="stylesheet" href="bag last updte/main-styles.css" id="a1k-bag-system-styles">

    <!-- 5. BAG SYSTEM - Core Scripts -->
    <script src="bag last updte/game-data.js"></script>
    <script src="bag last updte/A1KBagSystem.js"></script>

    <style>
        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           CORE & LAYOUT STYLES
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        body { 
            margin: 0; overflow: hidden; background: #050505; 
            font-family: 'Segoe UI', sans-serif; 
            -webkit-user-select: none; user-select: none; touch-action: none; 
        }
        canvas { display: block; outline: none; }
        
        #debug-console {
            position: fixed; top: 0; left: 0; width: 100%; background: rgba(50,0,0,0.9); 
            color: #ff9999; padding: 10px; z-index: 99999; display: none; font-family: monospace; font-size: 12px;
        }
        
        #loading-screen {
            position: fixed; inset: 0; background: #000; z-index: 9000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: #00E5FF; font-size: 24px; font-weight: bold; text-shadow: 0 0 15px #00E5FF;
            transition: opacity 0.8s;
        }
        #loading-bar-wrap { width: 300px; height: 4px; background: #333; margin-top: 20px; border-radius: 2px; }
        #loading-bar { width: 0%; height: 100%; background: #00E5FF; transition: width 0.2s; box-shadow: 0 0 10px #00E5FF; }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           CANDY HUD STYLES (From A1K Files)
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #hud-wrap { 
            position: fixed; inset: auto 0 0 0; padding: 20px; 
            display: grid; grid-template-columns: 1fr 1fr; 
            pointer-events: none; z-index: 100; bottom: 10px; 
        }
        
        /* Left Control Cluster */
        #hud-left { 
            pointer-events: auto; justify-self: start; 
            display: flex; flex-direction: column; align-items: center; 
            gap: 20px; margin-left: 20px; margin-bottom: 20px; 
        }
        
        /* Right Control Cluster */
        #hud-right { 
            pointer-events: auto; justify-self: end; 
            display: grid; grid-template-rows: auto auto; gap: 20px; 
            align-content: end; margin-right: 20px; margin-bottom: 30px; 
        }

        /* Joystick - Candy Style */
        #vj-root { 
            width: 130px; height: 130px; position: relative; 
            filter: drop-shadow(0 8px 20px rgba(0, 0, 0, 0.4)); margin-top: 10px; 
        }
        #vj-base { 
            position: absolute; inset: 0; border-radius: 50%; 
            background: radial-gradient(circle at 35% 25%, rgba(255, 255, 255, 0.1), rgba(0, 229, 255, 0.1), rgba(0, 0, 0, 0.5)); 
            border: 2px solid rgba(122, 213, 255, 0.4); 
            box-shadow: inset 0 0 20px rgba(0, 229, 255, 0.1);
        }
        #vj-knob { 
            position: absolute; left: 50%; top: 50%; width: 54px; height: 54px; 
            margin-left: -27px; margin-top: -27px; border-radius: 50%; 
            background: radial-gradient(circle at 30% 30%, #fff, #00E5FF); 
            box-shadow: 0 4px 15px rgba(0, 229, 255, 0.4); 
            transform: translate(0, 0); transition: transform 0.05s;
        }

        /* Utility Buttons Container */
        .utility-stack { display: flex; flex-direction: column; gap: 10px; align-items: center; }
        .utility-row { display: flex; gap: 10px; }
        
        /* General Pill Button */
        .utility-btn { 
            min-width: 55px; height: 34px; padding: 0 12px;
            border-radius: 17px; border: 1px solid rgba(255, 255, 255, 0.3); 
            background: rgba(20, 25, 40, 0.85); color: #fff; 
            font-weight: bold; font-size: 11px; letter-spacing: 0.5px;
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            -webkit-backdrop-filter: blur(8px); backdrop-filter: blur(8px); box-shadow: 0 4px 8px rgba(0,0,0,0.4);
            text-transform: uppercase; transition: all 0.1s;
        }
        .utility-btn:active { transform: scale(0.95); filter: brightness(1.2); }
        
        /* Specific Button Styles */
        .utility-btn[data-btn="switch"] { 
            background: linear-gradient(135deg, #FFD700, #FFA500); 
            color: #000; border: 1px solid #fff; min-width: 70px; 
            text-shadow: 0 1px 0 rgba(255,255,255,0.4);
        }
        .utility-btn[data-btn="bag"] { 
            background: linear-gradient(135deg, #4facfe, #00f2fe); 
            border-color: #aeeaff; text-shadow: 0 1px 2px rgba(0,0,0,0.3);
        }
        .utility-btn[data-btn="ai"] { 
            border: 1px dashed #d946ef; color: #d946ef; background: rgba(20, 0, 20, 0.8); 
        }
        .utility-btn[data-btn="ai"].active { 
            background: #d946ef; color: #fff; border: 1px solid #fff; 
            box-shadow: 0 0 15px #d946ef; 
        }
        .utility-btn[data-btn="veh"] { border-color: #ffd700; color: #ffd700; }
        .utility-btn[data-btn="veh"].active { background: #ffd700; color: #000; }
        
        .utility-btn[data-btn="pet"] { border-color: #39FF14; color: #39FF14; }
        .utility-btn[data-btn="pet"].active { background: #39FF14; color: #000; }

        /* Skills Row */
        .skill-row { display: flex; gap: 12px; justify-content: flex-end; }
        .skill-pill { 
            width: 50px; height: 50px; border-radius: 50%; 
            border: 2px solid rgba(255, 255, 255, 0.3); 
            background: rgba(0,0,0,0.6); color: #fff; font-weight: 900; 
            display: flex; align-items: center; justify-content: center; 
            font-size: 13px; cursor: pointer; -webkit-backdrop-filter: blur(4px); backdrop-filter: blur(4px);
        }
        .skill-pill.s1 { border-color: #ff7ad9; color: #ff7ad9; box-shadow: 0 0 10px rgba(255, 122, 217, 0.2); }
        .skill-pill.s2 { border-color: #7af8c8; color: #7af8c8; box-shadow: 0 0 10px rgba(122, 248, 200, 0.2); }
        .skill-pill.s3 { border-color: #7ad5ff; color: #7ad5ff; box-shadow: 0 0 10px rgba(122, 213, 255, 0.2); }
        .skill-pill:active { transform: scale(0.9); }
        .skill-pill.charging { 
            animation: chargePulse 0.5s ease-in-out infinite;
            box-shadow: 0 0 20px rgba(255, 170, 0, 0.8);
        }
        @keyframes chargePulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }
        
        /* Rage Button */
        .rage-btn {
            width: 60px; height: 35px; border-radius: 8px;
            border: 2px solid #ff0000;
            background: linear-gradient(135deg, #ff0000, #aa0000);
            color: #fff; font-weight: 900; font-size: 11px;
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; margin-bottom: 8px;
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.5);
            text-transform: uppercase; letter-spacing: 1px;
            transition: all 0.2s;
        }
        .rage-btn:hover { 
            transform: scale(1.05);
            box-shadow: 0 0 25px rgba(255, 0, 0, 0.8);
        }
        .rage-btn:active { transform: scale(0.95); }
        .rage-btn.active {
            background: linear-gradient(135deg, #ffaa00, #ff6600);
            border-color: #ffaa00;
            animation: ragePulse 0.8s ease-in-out infinite;
            box-shadow: 0 0 30px rgba(255, 170, 0, 1);
        }
        @keyframes ragePulse {
            0%, 100% { box-shadow: 0 0 30px rgba(255, 170, 0, 1); }
            50% { box-shadow: 0 0 50px rgba(255, 0, 0, 1); }
        }
        .skill-column { display: flex; flex-direction: column; align-items: flex-end; gap: 8px; }

        /* Main Action Buttons */
        .btn-container { display: flex; gap: 18px; align-items: center; }
        .big-btn { 
            width: 85px; height: 85px; border-radius: 50%; 
            border: 4px solid rgba(255, 255, 255, 0.4); 
            background: rgba(0,0,0,0.3); color: #FFF; 
            font-weight: 900; font-size: 16px; 
            cursor: pointer; display: flex; align-items: center; justify-content: center; 
            -webkit-tap-highlight-color: transparent; 
            box-shadow: 0 8px 20px rgba(0,0,0,0.5);
        }
        .big-btn.attack { 
            background: radial-gradient(circle at 30% 30%, #ff7ad9, #aa3a80); 
            box-shadow: 0 0 25px rgba(255, 122, 217, 0.5); 
            text-shadow: 0 2px 2px rgba(0,0,0,0.5); 
            border-color: #ffb3e6;
        }
        .big-btn.jump { 
            width: 65px; height: 65px; font-size: 12px; 
            background: radial-gradient(circle at 30% 30%, #7ad5ff, #3a80aa); 
            border-color: #b3e6ff;
        }
        .big-btn:active { transform: scale(0.92); }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           BAG SYSTEM CSS - Full A1K Bag System Styles
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        /* Note: Complete CSS from bag system reference file - ~4300 lines */
        /* CSS will be loaded from external source or injected via JavaScript */

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           FLOATING TEXT & EFFECTS
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #damage-container { position: fixed; inset: 0; pointer-events: none; z-index: 50; }
        .floater { 
            position: absolute; font-weight: 900; font-size: 22px; 
            text-shadow: 2px 2px 0 #000; pointer-events: none; 
            animation: floatUp 0.8s forwards; 
        }
        @keyframes floatUp { 
            0% { transform: translateY(0) scale(1); opacity: 1; } 
            100% { transform: translateY(-80px) scale(1.2); opacity: 0; } 
        }
        
        .cam-instruction {
            position: fixed; top: 20px; right: 20px; color: rgba(255,255,255,0.5); 
            font-size: 12px; pointer-events: none; text-align: right;
        }

        /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
           AI MENU PANEL (Robox Control)
           â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
        #roboxPanel {
            position: fixed; left: 12px; bottom: 262px; width: 680px; max-width: 92vw;
            background: rgba(15, 23, 42, 0.95); border: 2px solid #00E5FF; border-radius: 8px;
            box-shadow: 0 6px 16px rgba(0,0,0,.35); color: #fff;
            font: 13px/1.25 'Segoe UI', sans-serif; padding: 44px 12px 12px 12px;
            display: none; z-index: 12000; -webkit-backdrop-filter: blur(10px); backdrop-filter: blur(10px);
        }
        #roboxPanel.open { display: block; }
        #roboxPanel .rbx-row { display: flex; gap: 10px; }
        #roboxPanel .rbx-col { 
            background: rgba(30, 40, 60, 0.8); border: 2px solid #00E5FF; 
            border-radius: 6px; padding: 10px; display: flex; flex-direction: column; gap: 10px; 
        }
        #roboxPanel .rbx-col h3 { 
            margin: 0; background: rgba(0, 229, 255, 0.2); border: 1px solid #00E5FF; 
            border-radius: 4px; padding: 4px 8px; font-weight: 700; letter-spacing: .06em; 
            text-transform: uppercase; text-align: center; color: #00E5FF;
        }
        #roboxPanel .rbx-meter { display: flex; justify-content: space-between; gap: 12px; }
        #roboxPanel .rbx-btn, #roboxPanel .rbx-chip { 
            cursor: pointer; border: 1px solid #00E5FF; background: rgba(0, 229, 255, 0.1); 
            color: #00E5FF; border-radius: 6px; padding: 6px 10px; -webkit-user-select: none; user-select: none; 
            text-align: center; transition: all 0.1s;
        }
        #roboxPanel .rbx-btn:hover, #roboxPanel .rbx-chip:hover { 
            background: rgba(0, 229, 255, 0.2); transform: translateY(-1px); 
        }
        #roboxPanel .rbx-btn:active, #roboxPanel .rbx-chip:active { transform: translateY(1px); }
        #roboxPanel .rbx-chip.active { background: rgba(0, 229, 255, 0.3); color: #fff; }
        #roboxPanel .rbx-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 8px; }
        #roboxPanel .rbx-skills { display: grid; grid-template-columns: repeat(4, minmax(0, 1fr)); gap: 8px; }
        #roboxPanel .rbx-log { 
            min-height: 160px; max-height: 200px; background: rgba(0,0,0,0.4); 
            border: 1px solid #00E5FF; border-radius: 6px; overflow: auto; padding: 8px; 
            white-space: pre-wrap; font-family: 'Courier New', monospace; font-size: 11px;
        }
        #roboxPanel .rbx-footer { display: flex; gap: 8px; }
        #roboxPanel input.rbx-cmd { 
            flex: 1; min-width: 0; padding: 8px; border: 1px solid #00E5FF; 
            background: rgba(0,0,0,0.5); color: #fff; border-radius: 6px; 
        }
        #roboxPanel .rbx-close {
            position: absolute; top: 10px; right: 12px; width: 26px; height: 26px;
            border: 1px solid #ff5555; border-radius: 4px; background: rgba(255, 85, 85, 0.2);
            color: #ff5555; font-weight: 700; line-height: 20px; cursor: pointer;
        }
        #roboxPanel .rbx-close:hover { background: rgba(255, 85, 85, 0.4); }
    </style>
</head>
<body>

    <div id="debug-console"></div>
    
    <!-- LOADING -->
    <div id="loading-screen">
        <div>INITIALIZING A1K ENGINE...</div>
        <div id="loading-bar-wrap"><div id="loading-bar"></div></div>
    </div>

    <div class="cam-instruction">
        Double Click: Reset Cam<br>
        Drag: Rotate Cam<br>
        Scroll: Zoom
    </div>

    <!-- HUD -->
    <div id="hud-wrap">
        <!-- Left: Utility & Stick -->
        <div id="hud-left">
            <div class="utility-stack">
                <div class="utility-row">
                    <button class="utility-btn" data-btn="pet">PET</button>
                    <button class="utility-btn" data-btn="veh">VEH</button>
                    <button class="utility-btn" data-btn="act">ACT</button>
                    <button class="utility-btn" data-btn="act2">ACT2</button>
                </div>
                <div class="utility-row">
                    <button class="utility-btn" data-btn="bag">BAG</button>
                    <button class="utility-btn" data-btn="ai">AI</button>
                    <button class="utility-btn" data-btn="switch">SWITCH</button>
                </div>
            </div>
            <div id="vj-root">
                <div id="vj-base"></div>
                <div id="vj-knob"></div>
            </div>
        </div>

        <!-- Right: Skills & Combat -->
        <div id="hud-right">
            <div class="skill-column">
                <button class="rage-btn" data-btn="rage" id="rage-btn">RAGE</button>
                <div class="skill-row">
                    <button class="skill-pill s1" data-btn="s1">S1</button>
                    <button class="skill-pill s2" data-btn="s2">S2</button>
                    <button class="skill-pill s3" data-btn="s3">S3</button>
                </div>
            </div>
            <div class="btn-container">
                <button class="big-btn jump" data-btn="jump">JUMP</button>
                <button class="big-btn attack" data-btn="attack">ATK</button>
            </div>
        </div>
    </div>

    <!-- DAMAGE OVERLAY -->
    <div id="damage-container"></div>

    <!-- BAG UI - Will be injected by BagSystem -->

    <!-- AI MENU PANEL (Robox Control) -->
    <div id="roboxPanel">
        <button class="rbx-close" id="rbxClose" aria-label="Close panel">âœ•</button>
        <div class="rbx-row">
            <div class="rbx-col" style="flex:0 0 190px">
                <h3>Companion</h3>
                <div class="rbx-meter">
                    <div>Lvl <span id="rbxLvl">1.0</span></div>
                    <div>Mode <span id="rbxMode">Follow</span></div>
                </div>
                <div class="rbx-grid">
                    <div class="rbx-btn" id="rbxSummon">Summon</div>
                    <div class="rbx-btn" id="rbxDespawn">Despawn</div>
                </div>
            </div>
            <div class="rbx-col" style="flex:0 0 220px">
                <h3>Tactics</h3>
                <div class="rbx-grid">
                    <div class="rbx-chip active" data-mode="follow" id="rbxFollow">Follow</div>
                    <div class="rbx-chip" data-mode="hunt" id="rbxHunt">Hunt</div>
                    <div class="rbx-chip" data-mode="assist" id="rbxAssist">Assist</div>
                    <div class="rbx-chip" data-action="return" id="rbxReturn">Return</div>
                </div>
                <h3>Skills</h3>
                <div class="rbx-skills">
                    <div class="rbx-btn" id="rbxS1">S1</div>
                    <div class="rbx-btn" id="rbxS2">S2</div>
                    <div class="rbx-btn" id="rbxS3">S3</div>
                    <div class="rbx-btn" id="rbxS4">S4</div>
                </div>
            </div>
            <div class="rbx-col">
                <h3>Comm-Link</h3>
                <div class="rbx-log" id="rbxLog">Tip: Press Summon to deploy the companion.</div>
                <div class="rbx-footer">
                    <input id="rbxCmd" class="rbx-cmd" placeholder="Give a command..." maxlength="120">
                    <div class="rbx-btn" id="rbxSend">Send</div>
                </div>
            </div>
        </div>
    </div>

    <!-- GAME LOGIC -->
    <script type="module">
        import * as THREE from 'three';

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ROBOX SYSTEM - Adapted for Three.js
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        // RoboxVFX (placeholder, can enhance later)
        window.RoboxVFX = {
            emitMuzzleFlash: () => {},
            emitDashTrail: () => {},
            emitLightningBurst: () => {},
            emitFlameRing: () => {},
            emitDomainAura: () => {}
        };

        // RoboxProjectiles - Convert to Three.js meshes
        window.RoboxProjectiles = {
            ensureRoboxProjectiles: () => {}
        };

        // RoboxSkills - Adapted for Three.js
        window.RoboxSkills = (function() {
            const DEFAULT_SKILL_MULTIPLIER = 3;

            function skillMultiplier(bot) {
                return bot?.skillMultiplier || DEFAULT_SKILL_MULTIPLIER;
            }

            function spawnSwordSwing(bot, world) {
                if (!bot || !Game.scene) return;
                const damage = bot.atk ?? 300;
                const facingLeft = bot.facingLeft || false;
                
                // Create swing arc mesh
                const arc = new THREE.Mesh(
                    new THREE.TorusGeometry(1.5, 0.2, 4, 8, Math.PI/1.5),
                    new THREE.MeshBasicMaterial({ color: 0x5bffaa, transparent: true, opacity: 0.8 })
                );
                const pos = bot.mesh.position.clone();
                pos.y += 1;
                arc.position.copy(pos);
                arc.rotation.x = Math.PI/2;
                Game.scene.add(arc);
                
                // Animate and remove
                let frame = 0;
                const anim = () => {
                    frame++;
                    arc.rotation.z -= 0.4;
                    if (frame < 8) requestAnimationFrame(anim);
                    else Game.scene.remove(arc);
                };
                anim();
                
                // Hit detection
                Game.enemies.forEach(e => {
                    if (e.hp > 0 && bot.mesh.position.distanceTo(e.mesh.position) < 3) {
                        e.hp -= damage;
                        e.bar.scale.x = Math.max(0, e.hp / 100 * 2);
                        createFloater(Math.round(damage), e.mesh.position, "#5bffaa");
                        if (e.hp <= 0) e.mesh.visible = false;
                    }
                });
            }

            function spawnEnergyBolt(bot, target, world) {
                if (!bot || !Game.scene) return;
                const damage = bot.atk ?? 300;
                const pos = bot.mesh.position.clone();
                pos.y += 1;
                
                let dir;
                if (target && target.mesh) {
                    dir = new THREE.Vector3().subVectors(target.mesh.position, pos).normalize();
                } else {
                    dir = new THREE.Vector3(Math.sin(bot.mesh.rotation.y), 0, Math.cos(bot.mesh.rotation.y));
                }
                
                const bullet = new THREE.Mesh(
                    new THREE.SphereGeometry(0.2),
                    new THREE.MeshBasicMaterial({ color: 0x5ba3ff, emissive: 0x5ba3ff })
                );
                bullet.position.copy(pos);
                Game.scene.add(bullet);
                Game.projectiles.push({
                    mesh: bullet,
                    vel: dir.multiplyScalar(40),
                    life: 2,
                    damage: damage,
                    owner: 'robox'
                });
            }

            function spawnLightningFan(bot, world) {
                if (!bot || !Game.scene) return;
                const damage = bot.atk ?? 300;
                const pos = bot.mesh.position.clone();
                pos.y += 1;
                const count = 6;
                const spacing = Math.PI / 18;
                
                for (let i = 0; i < count; i++) {
                    const angle = (i - (count - 1) / 2) * spacing + bot.mesh.rotation.y;
                    const dir = new THREE.Vector3(Math.sin(angle), 0, Math.cos(angle));
                    const bolt = new THREE.Mesh(
                        new THREE.SphereGeometry(0.15),
                        new THREE.MeshBasicMaterial({ color: 0xb57bff, emissive: 0xb57bff })
                    );
                    bolt.position.copy(pos);
                    Game.scene.add(bolt);
                    Game.projectiles.push({
                        mesh: bolt,
                        vel: dir.multiplyScalar(40),
                        life: 2,
                        damage: damage,
                        owner: 'robox'
                    });
                }
            }

            function spawnDomainPulse(bot, world) {
                if (!bot || !Game.scene) return;
                const damage = bot.atk ?? 300;
                const pos = bot.mesh.position.clone();
                pos.y = 0.1;
                
                const pulse = new THREE.Mesh(
                    new THREE.CylinderGeometry(2.2, 2.2, 0.2, 32),
                    new THREE.MeshBasicMaterial({ color: 0x5ba3ff, transparent: true, opacity: 0.6 })
                );
                pulse.position.copy(pos);
                pulse.rotation.x = -Math.PI/2;
                Game.scene.add(pulse);
                
                // AOE damage
                Game.enemies.forEach(e => {
                    if (e.hp > 0 && pos.distanceTo(e.mesh.position) < 2.2) {
                        e.hp -= damage;
                        e.bar.scale.x = Math.max(0, e.hp / 100 * 2);
                        createFloater(Math.round(damage), e.mesh.position, "#5ba3ff");
                        if (e.hp <= 0) e.mesh.visible = false;
                    }
                });
                
                setTimeout(() => Game.scene.remove(pulse), 900);
            }

            function spawnSpiralVolley(bot, world) {
                if (!bot || !Game.scene) return;
                const damage = bot.atk ?? 300;
                const pos = bot.mesh.position.clone();
                pos.y += 1;
                const count = 8;
                
                for (let i = 0; i < count; i++) {
                    const angle = (Math.PI * 2 * i) / count;
                    const dir = new THREE.Vector3(Math.sin(angle), 0, Math.cos(angle));
                    const bolt = new THREE.Mesh(
                        new THREE.SphereGeometry(0.18),
                        new THREE.MeshBasicMaterial({ color: 0x8a2be2, emissive: 0x8a2be2 })
                    );
                    bolt.position.copy(pos);
                    Game.scene.add(bolt);
                    Game.projectiles.push({
                        mesh: bolt,
                        vel: dir.multiplyScalar(50),
                        life: 2.4,
                        damage: damage,
                        owner: 'robox'
                    });
                }
            }

            function castSkill(key, bot, world) {
                if (!bot) return false;
                const mult = skillMultiplier(bot);
                let handled = false;
                
                switch (String(key || "").toUpperCase()) {
                    case "S1":
                        for (let i = 0; i < 3; i++) {
                            setTimeout(() => spawnSwordSwing({ ...bot, atk: bot.atk * mult }, world), i * 50);
                        }
                        handled = true;
                        break;
                    case "S2":
                        spawnLightningFan({ ...bot, atk: bot.atk * mult }, world);
                        handled = true;
                        break;
                    case "S3":
                        spawnDomainPulse({ ...bot, atk: bot.atk * mult }, world);
                        handled = true;
                        break;
                    case "S4":
                        spawnSpiralVolley({ ...bot, atk: bot.atk * mult }, world);
                        handled = true;
                        break;
                }
                return handled;
            }

            function primaryFire(bot, target, world) {
                if (!bot) return;
                const cycle = bot.attackCycle || { phase: "melee", count: 0 };
                
                if (cycle.phase === "melee") {
                    spawnSwordSwing(bot, world);
                    cycle.count++;
                    if (cycle.count >= 3) {
                        cycle.phase = "ranged";
                        cycle.count = 0;
                    }
                } else {
                    spawnEnergyBolt(bot, target, world);
                    cycle.count++;
                    if (cycle.count >= 3) {
                        cycle.phase = "melee";
                        cycle.count = 0;
                    }
                }
            }

            function cast(id, bot, world) {
                if (!bot) return false;
                const key = typeof id === "number" ? `S${id}` : String(id || "").trim().toUpperCase().replace(/^SKILL/, "S");
                return castSkill(key, bot, world);
            }

            return { primaryFire, cast };
        })();

        // RoboxController - Adapted for Three.js
        window.RoboxController = (function() {
            const DEFAULT_TUNING = { speed: 140, ranged: 300, melee: 90, fireCd: 420 };

            function state() {
                return window.st;
            }

            function ensureArray() {
                const st = state();
                if (!st) return null;
                if (!Array.isArray(st.aiCompanions)) st.aiCompanions = [];
                return st.aiCompanions;
            }

            function get() {
                return Game.roboxBot || null;
            }

            function spawn(options = {}) {
                if (Game.roboxActive && Game.roboxMesh) {
                    if (options.mode && Game.roboxBot) Game.roboxBot.mode = options.mode;
                    return Game.roboxBot;
                }

                const leader = Game.partyMeshes[Game.leaderIndex];
                if (!leader) return null;

                const spawnPos = leader.position.clone();
                spawnPos.x -= 3;
                spawnPos.z -= 2;

                // Create Three.js mesh for robox
                const group = new THREE.Group();
                
                // Body (capsule)
                const body = new THREE.Mesh(
                    new THREE.CapsuleGeometry(0.4, 1.2, 4, 8),
                    new THREE.MeshStandardMaterial({
                        color: 0x101728,
                        emissive: 0x5ba3ff,
                        emissiveIntensity: 0.3
                    })
                );
                body.position.y = 0.6;
                body.castShadow = true;
                group.add(body);

                // Head
                const head = new THREE.Mesh(
                    new THREE.SphereGeometry(0.35, 16, 16),
                    new THREE.MeshStandardMaterial({
                        color: 0x5ba3ff,
                        emissive: 0x5ba3ff,
                        emissiveIntensity: 0.5
                    })
                );
                head.position.y = 1.8;
                group.add(head);

                // Eyes
                const eye1 = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0x5bffaa })
                );
                eye1.position.set(-0.15, 1.85, 0.3);
                group.add(eye1);
                
                const eye2 = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1, 8, 8),
                    new THREE.MeshBasicMaterial({ color: 0x5bffaa })
                );
                eye2.position.set(0.15, 1.85, 0.3);
                group.add(eye2);

                // Thruster glow
                const thruster = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.3, 0.2, 0.3, 16),
                    new THREE.MeshBasicMaterial({
                        color: 0x5ba3ff,
                        emissive: 0x5ba3ff,
                        transparent: true,
                        opacity: 0.6
                    })
                );
                thruster.position.y = 0;
                thruster.rotation.x = Math.PI;
                group.add(thruster);
                group.userData.thruster = thruster;

                group.position.copy(spawnPos);
                Game.scene.add(group);

                // Create bot entity
                const bot = {
                    id: 'Robox',
                    kind: 'robox',
                    hp: 2000,
                    hpMax: 2000,
                    atk: 300,
                    speed: 140,
                    mode: options.mode || 'follow',
                    targetMode: options.targetMode || 'nearest',
                    animState: 'idle',
                    animTime: 0,
                    alive: true,
                    nextFireAt: performance.now() + 320,
                    fireRate: 420,
                    skillMultiplier: 3,
                    attackCycle: { phase: 'melee', count: 0 },
                    pendingSkill: null,
                    tuning: { ...DEFAULT_TUNING },
                    mesh: group,
                    facingLeft: false
                };

                ensureArray().push(bot);
                Game.roboxBot = bot;
                Game.roboxMesh = group;
                Game.roboxActive = true;

                createFloater("ROBOX ONLINE", spawnPos, "#5ba3ff");
                return bot;
            }

            function despawn() {
                if (Game.roboxMesh) {
                    Game.scene.remove(Game.roboxMesh);
                    Game.roboxMesh = null;
                }
                Game.roboxBot = null;
                Game.roboxActive = false;
                const st = state();
                if (st?.aiCompanions) {
                    const idx = st.aiCompanions.findIndex(b => b.kind === 'robox');
                    if (idx >= 0) st.aiCompanions.splice(idx, 1);
                }
                createFloater("ROBOX OFFLINE", Game.partyMeshes[Game.leaderIndex].position, "#ff6666");
            }

            function setMode(mode) {
                const bot = get();
                if (!bot) return;
                bot.mode = mode;
            }

            function setTargetMode(mode) {
                const bot = get();
                if (!bot) return;
                bot.targetMode = mode;
            }

            function cast(id) {
                const bot = get();
                if (!bot) return;
                bot.pendingSkill = id;
            }

            function attach(engine) {
                const api = window.RoboxAI = window.RoboxAI || {};
                Object.assign(api, { spawn, despawn, get, setMode, setTargetMode, cast });
                return api;
            }

            return { attach, spawn, despawn, get, setMode, setTargetMode, cast };
        })();

        // Boot robox module
        window.bootRoboxModule = function() {
            const controller = window.RoboxController;
            if (!controller) return;
            const engine = {
                get state() { return window.st; },
                dispatch(event, detail) {
                    try { window.dispatchEvent?.(new CustomEvent(event, { detail })); } catch (_) {}
                }
            };
            controller.attach(engine);
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // 1. CONFIGURATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const CONFIG = {
            Party: [
                { id: 'A1', color: 0x00E5FF, height: 1.8, scale: 1.0, role: 'Leader' },
                { id: 'MISSY', color: 0xFF69B4, height: 1.6, scale: 0.9, role: 'Mage' },
                { id: 'UNIQUE', color: 0x39FF14, height: 2.0, scale: 1.1, role: 'Tank' }
            ],
            Items: [
                {icon: 'ğŸ—¡ï¸', name: 'Iron Sword', qty: 1}, 
                {icon: 'ğŸ›¡ï¸', name: 'Shield', qty: 1}, 
                {icon: 'ğŸ§ª', name: 'HP Potion', qty: 5}, 
                {icon: 'ğŸ“œ', name: 'Scroll', qty: 2}, 
                {icon: 'ğŸ’', name: 'Gem', qty: 10}, 
                {icon: 'ğŸ', name: 'Food', qty: 3}, 
                {icon: 'ğŸ”®', name: 'Orb', qty: 1}, 
                {icon: 'ğŸ”‘', name: 'Key', qty: 1}, 
                {icon: 'ğŸ’', name: 'Ring', qty: 2}, 
                {icon: 'ğŸ‘¢', name: 'Boots', qty: 1},
                {icon: 'ğŸ§¢', name: 'Hat', qty: 1},
                {icon: 'ğŸ‘“', name: 'Specs', qty: 1}
            ],
            DefaultCamOffset: new THREE.Vector3(0, 15, 15),
            CamZoom: 1.0
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BAG SYSTEM - Integration Notes
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // The bag system is loaded externally via A1KBagSystem.js
        // All templates, styles, and core functionality are provided by the bag system
        // This section is kept for any engine-specific bag integration helpers if needed

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ENGINE-BAG BRIDGE (Hook Points)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        window.A1K_Engine = {
            // Called by Bag System when an item is equipped
            onEquip: (item) => {
                console.log('[A1K_Engine] Item equipped:', item);
                const leader = Game.partyMeshes[Game.leaderIndex];
                if (!leader) return;

                // Update visual representation based on item type
                if (item.category === 'weapon' || item.slot === 'weapon') {
                    // Update weapon mesh if needed
                    const weapon = leader.getObjectByName('weapon');
                    if (weapon) {
                        // Update weapon appearance based on item
                        weapon.material.color.setHex(item.color || 0xffffff);
                    }
                    createFloater(`Equipped: ${item.name}`, leader.position, "#00ff00");
                } else if (item.category === 'armor' || item.slot === 'armor') {
                    // Update armor appearance
                    createFloater(`Equipped: ${item.name}`, leader.position, "#00ff00");
                }

                // Apply stat changes if item has stats
                if (item.stats) {
                    // Stats are managed by bag system, but we can update visual feedback
                    createFloater("Stats Updated!", leader.position, "#00E5FF");
                }
            },

            // Called when a consumable item is used
            onUse: (item) => {
                console.log('[A1K_Engine] Item used:', item);
                const leader = Game.partyMeshes[Game.leaderIndex];
                if (!leader) return;

                // Handle different item effects
                if (item.effect === 'heal' || item.name.toLowerCase().includes('potion')) {
                    // Heal effect - could update health bar if we had one
                    createFloater(`Used: ${item.name}`, leader.position, "#00ff00");
                } else if (item.effect === 'buff') {
                    // Buff effect
                    createFloater(`Buff: ${item.name}`, leader.position, "#ffff00");
                } else {
                    createFloater(`Used: ${item.name}`, leader.position, "#00E5FF");
                }
            },

            // Called when an item is unequipped
            onUnequip: (item) => {
                console.log('[A1K_Engine] Item unequipped:', item);
                const leader = Game.partyMeshes[Game.leaderIndex];
                if (leader) {
                    createFloater(`Unequipped: ${item.name}`, leader.position, "#ff6666");
                }
            },

            // Add loot to bag from game (e.g., from enemies, chests)
            addLoot: (itemId, qty = 1) => {
                if (window.BagSystem && typeof window.BagSystem.addItem === 'function') {
                    window.BagSystem.addItem(itemId, qty);
                    const leader = Game.partyMeshes[Game.leaderIndex];
                    if (leader) {
                        createFloater(`+${qty} ${itemId}`, leader.position, "#FFD700");
                    }
                } else {
                    console.warn('[A1K_Engine] BagSystem not available for addLoot');
                }
            },

            // Get current character stats (for bag system to display)
            getCharacterStats: () => {
                const leader = Game.partyMeshes[Game.leaderIndex];
                if (!leader) return null;
                
                // Return character stats that bag system can use
                return {
                    level: window.gameState?.playerLevel || 1,
                    hp: 100, // Placeholder - would come from actual game state
                    mp: 50,
                    attack: 10,
                    defense: 5,
                    speed: 1.0
                };
            }
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // 1. MASTER DATA CORE V5 (Combo & Destructibles Edition)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (!window.A1K_DATA) {
            window.A1K_DATA = {
                Loadout: {
                    'A1':     { S1: 'WAR_S1', S2: 'WAR_CLONE', S3: 'WAR_S3' },
                    'MISSY':  { S1: 'MAGE_BOLT', S2: 'MAGE_BEAST', S3: 'MAGE_NOVA' },
                    'UNIQUE': { S1: 'TECH_ZAP',  S2: 'TECH_DRONE', S3: 'TECH_NUKE' }
                },
                Skills: {
                    // --- A1 WARRIOR - X PATTERN SYSTEM ---
                    'WAR_S1': { 
                        name: 'Crimson Slash', type: 'combo_x', 
                        slashes: 3, interval: 0.5, dmg: 50, scale: 1.0,
                        icon: 'âš”ï¸', vfx: 'red_x' 
                    },
                    'WAR_S3': { 
                        name: 'Boss Destroyer', type: 'combo_x', 
                        slashes: 5, interval: 0.4, dmg: 80, scale: 1.5,
                        icon: 'ğŸ’¢', vfx: 'red_x_giant' 
                    },
                    'WAR_CLONE': { 
                        name: 'Shadow Clone', type: 'spawn', model: 'clone_hologram', 
                        duration: 20, cd: 30, icon: 'ğŸ‘¥', ai: 'mimic_x'
                    },
                    
                    // MISSY (The Summoner/Mage)
                    'MAGE_BOLT': { name: 'Starfall', type: 'proj', dmg: 50, cd: 0.5, icon: 'âœ¨', vfx: 'star_barrage', homing: true, speed: 20, count: 3 },
                    'MAGE_BEAST': { name: 'Fenrir', type: 'spawn', model: 'giant_wolf', duration: 40, cd: 60, icon: 'ğŸº', ai: 'aggressive_tank' },
                    'MAGE_NOVA': { name: 'Galaxy Collapse', type: 'aoe', dmg: 500, cd: 20, icon: 'ğŸŒŒ', vfx: 'black_hole' },
                    
                    // UNIQUE (The Tech/Cyborg)
                    'TECH_ZAP':  { name: 'Railgun', type: 'beam', dmg: 100, cd: 1.0, icon: 'ğŸ”«', vfx: 'blue_laser_beam', range: 30 },
                    'TECH_DRONE': { name: 'Hunter-Killer', type: 'spawn', model: 'drone_unit', duration: 30, cd: 15, icon: 'ğŸ›¸', ai: 'hover_sniper' },
                    'TECH_NUKE': { name: 'Orbital Laser', type: 'aoe', dmg: 1000, cd: 90, icon: 'â˜¢ï¸', vfx: 'ion_cannon' }
                },
                Environment: {
                    'tree': { hp: 50, drop: { min: 50, max: 150 }, color: 0x228b22, scale: {x:1, y:3, z:1} },
                    'rock': { hp: 100, drop: { min: 100, max: 300 }, color: 0x555555, scale: {x:2, y:1.5, z:2} },
                    'building': { hp: 500, drop: { min: 1000, max: 5000 }, color: 0x333344, scale: {x:5, y:8, z:5} }
                },
                Items: []
            };
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // COMBO STATE TRACKING
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const ComboState = {
            step: 0,
            lastTime: 0,
            skillId: null
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ENVIRONMENT SYSTEM (Destructibles)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const EnvSystem = {
            objects: [],
            
            init: () => {
                if (!Game.scene) {
                    console.warn('[EnvSystem] Game.scene not ready, delaying initialization');
                    setTimeout(() => EnvSystem.init(), 500);
                    return;
                }
                console.log('[EnvSystem] Initializing environment objects...');
                // Spawn Trees
                for(let i=0; i<20; i++) EnvSystem.spawn('tree');
                // Spawn Rocks
                for(let i=0; i<10; i++) EnvSystem.spawn('rock');
                // Spawn Buildings (Rare)
                for(let i=0; i<3; i++) EnvSystem.spawn('building');
                console.log(`[EnvSystem] Spawned ${EnvSystem.objects.length} environment objects`);
            },
            
            spawn: (type) => {
                if (!window.A1K_DATA || !window.A1K_DATA.Environment || !window.A1K_DATA.Environment[type]) return;
                const data = window.A1K_DATA.Environment[type];
                const geo = new THREE.BoxGeometry(1, 1, 1);
                const mat = new THREE.MeshStandardMaterial({ color: data.color });
                const mesh = new THREE.Mesh(geo, mat);
                
                // Scale & Position
                mesh.scale.set(data.scale.x, data.scale.y, data.scale.z);
                mesh.position.set((Math.random()-0.5)*200, data.scale.y/2, (Math.random()-0.5)*200);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                
                // Health Bar
                const bar = new THREE.Mesh(
                    new THREE.PlaneGeometry(data.scale.x, 0.2), 
                    new THREE.MeshBasicMaterial({color:0x00ff00})
                );
                bar.position.y = data.scale.y/2 + 0.5;
                bar.visible = false; // Only show when hit
                mesh.add(bar);
                
                mesh.userData = { 
                    type: 'env', 
                    id: type, 
                    hp: data.hp, 
                    maxHp: data.hp, 
                    bar: bar 
                };
                
                if (Game.scene) {
                    Game.scene.add(mesh);
                    EnvSystem.objects.push(mesh);
                }
            },
            
            takeDamage: (obj, amount) => {
                if(obj.userData.hp <= 0) return;
                
                obj.userData.hp -= amount;
                obj.userData.bar.visible = true;
                obj.userData.bar.scale.x = Math.max(0, obj.userData.hp / obj.userData.maxHp);
                
                // Hit Flash
                const oldColor = obj.material.color.getHex();
                obj.material.color.setHex(0xffffff);
                setTimeout(() => obj.material.color.setHex(oldColor), 50);
                
                // Shake
                const originalX = obj.position.x;
                obj.position.x += (Math.random()-0.5) * 0.5;
                setTimeout(() => obj.position.x = originalX, 50);
                
                createFloater(amount, obj.position, "#fff");
                
                if(obj.userData.hp <= 0) {
                    EnvSystem.destroy(obj);
                }
            },
            
            destroy: (obj) => {
                if (!window.A1K_DATA || !window.A1K_DATA.Environment || !window.A1K_DATA.Environment[obj.userData.id]) return;
                
                // Drop Gold
                const data = window.A1K_DATA.Environment[obj.userData.id];
                const gold = Math.floor(Math.random() * (data.drop.max - data.drop.min) + data.drop.min);
                createFloater(`+${gold} GOLD`, obj.position, "#FFD700");
                
                // Add gold to game state
                if (window.gameState) {
                    window.gameState.gold = (window.gameState.gold || 0) + gold;
                }
                
                // FX
                createExplosion(obj.position, obj.material.color);
                
                if (Game.scene) {
                    Game.scene.remove(obj);
                }
                EnvSystem.objects = EnvSystem.objects.filter(o => o !== obj);
            }
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // 2. GAME STATE
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const Game = {
            scene: null, camera: null, renderer: null,
            partyMeshes: [], // [0]=Leader, [1],[2]=Followers
            enemies: [],
            leaderIndex: 0,
            input: { x: 0, y: 0 },
            keys: { ArrowUp:false, ArrowDown:false, ArrowLeft:false, ArrowRight:false, w:false, a:false, s:false, d:false },
            projectiles: [],
            effects: [],
            clock: new THREE.Clock(),
            
            // Systems
            aiEnabled: false,
            autoAttack: false,
            vehicleActive: false,
            petActive: false,
            petMesh: null,
            
            // Robox System
            roboxMesh: null,
            roboxActive: false,
            roboxBot: null,
            
            // Camera
            camOrbit: { theta: 0, phi: Math.PI/3, radius: 25 },
            mouseDrag: { active: false, x: 0, y: 0 },
            
            // Anime Combat System
            charge: { active: false, startTime: 0, skillKey: null },
            rageMode: false,
            rageEndTime: 0,
            minions: [], // For summons/clones
            
            loaded: false
        };

        // Mock window.st for robox compatibility
        window.st = {
            players: [],
            leader: 0,
            enemies: [],
            aiCompanions: [],
            shots: []
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // GAME STATE INITIALIZATION FOR BAG SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function initializeGameState() {
            // Initialize gameState if it doesn't exist
            if (!window.gameState) {
                window.gameState = {};
            }

            // Map CONFIG.Items to gameState.inventory.items
            if (!window.gameState.inventory) {
                window.gameState.inventory = {};
            }
            
            // Convert CONFIG.Items to bag system format
            window.gameState.inventory.items = CONFIG.Items.map(item => ({
                id: item.name.toLowerCase().replace(/\s+/g, '_'),
                name: item.name,
                icon: item.icon,
                qty: item.qty || 1,
                category: 'consumable',
                type: 'item'
            }));

            // Initialize other inventory arrays
            if (!window.gameState.inventory.gear) window.gameState.inventory.gear = [];
            if (!window.gameState.inventory.pets) window.gameState.inventory.pets = [];
            if (!window.gameState.inventory.vehicles) window.gameState.inventory.vehicles = [];
            if (!window.gameState.inventory.spirits) window.gameState.inventory.spirits = [];
            if (!window.gameState.inventory.robots) window.gameState.inventory.robots = [];
            if (!window.gameState.inventory.skills) window.gameState.inventory.skills = [];
            if (!window.gameState.inventory.abilities) window.gameState.inventory.abilities = [];
            if (!window.gameState.inventory.skins) window.gameState.inventory.skins = [];
            if (!window.gameState.inventory.talents) window.gameState.inventory.talents = [];
            if (!window.gameState.inventory.quests) window.gameState.inventory.quests = [];

            // Initialize currencies
            if (typeof window.gameState.gold !== 'number') window.gameState.gold = 10000;
            if (typeof window.gameState.gems !== 'number') window.gameState.gems = 50;
            if (typeof window.gameState.keys !== 'number') window.gameState.keys = 3;
            if (typeof window.gameState.tickets !== 'number') window.gameState.tickets = 2;
            if (typeof window.gameState.essence !== 'number') window.gameState.essence = 10;

            // Initialize equipped items
            if (!window.gameState.equipped) {
                window.gameState.equipped = {
                    weapon: null,
                    armor: null,
                    accessory: null,
                    pet: null,
                    vehicle: null,
                    spirit: null,
                    robot: null
                };
            }

            // Set current character based on leader index
            const characterMap = { 0: 'A1', 1: 'MISSY', 2: 'UNIQUE' };
            window.gameState.currentCharacter = characterMap[Game.leaderIndex] || 'A1';

            // Initialize level and stats
            if (typeof window.gameState.level !== 'number') window.gameState.level = 1;
            if (typeof window.gameState.playerLevel !== 'number') window.gameState.playerLevel = 1;
            if (typeof window.gameState.rank !== 'number') window.gameState.rank = 1;

            // Initialize settings
            if (!window.gameState.settings) {
                window.gameState.settings = {
                    autoAI: false
                };
            }

            // Initialize missions
            if (!window.gameState.missions) {
                window.gameState.missions = {
                    available: [],
                    active: null,
                    completed: [],
                    progress: {}
                };
            }

            // Initialize talents
            if (!window.gameState.talents) {
                window.gameState.talents = {
                    points: 0,
                    tree: [],
                    allocated: [],
                    synergies: []
                };
            }

            // Initialize ability points
            if (typeof window.gameState.abilityPoints !== 'number') window.gameState.abilityPoints = 0;
            if (typeof window.gameState.pointsInStrength !== 'number') window.gameState.pointsInStrength = 0;
            if (typeof window.gameState.pointsInVitality !== 'number') window.gameState.pointsInVitality = 0;
            if (typeof window.gameState.pointsInAgility !== 'number') window.gameState.pointsInAgility = 0;
            if (typeof window.gameState.pointsInIntelligence !== 'number') window.gameState.pointsInIntelligence = 0;

            // Initialize XP
            if (typeof window.gameState.xp !== 'number') window.gameState.xp = 0;
            if (typeof window.gameState.xpToNext !== 'number') window.gameState.xpToNext = 100;

            console.log('GameState initialized for bag system');
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // 3. INITIALIZATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        async function init() {
            try {
                updateLoadBar(10);

                // STEP 1: Initialize gameState FIRST (before bag system needs it)
                initializeGameState();
                updateLoadBar(20);

                // STEP 2: Wait for bag system scripts to load
                let bagSystemReady = false;
                let attempts = 0;
                const maxAttempts = 50; // Wait up to 5 seconds (50 * 100ms)
                
                while (!bagSystemReady && attempts < maxAttempts) {
                    if (window.BagSystem && typeof window.BagSystem.init === 'function') {
                        bagSystemReady = true;
                        break;
                    }
                    await new Promise(resolve => setTimeout(resolve, 100));
                    attempts++;
                }

                if (!bagSystemReady) {
                    console.warn('[A1K_Engine] BagSystem not loaded after timeout. Continuing without bag system.');
                }

                updateLoadBar(30);

                // STEP 3: Three.js Setup
                Game.scene = new THREE.Scene();
                Game.scene.background = new THREE.Color(0x101015);
                Game.scene.fog = new THREE.Fog(0x101015, 20, 120);

                const aspect = window.innerWidth / window.innerHeight;
                Game.camera = new THREE.PerspectiveCamera(60, aspect, 0.1, 1000);
                // Try WebGL first, check if context was created
                Game.renderer = new THREE.WebGLRenderer({ 
                    antialias: true, 
                    powerPreference: "high-performance",
                    failIfMajorPerformanceCaveat: false,
                    preserveDrawingBuffer: false
                });
                
                // Check if WebGL context was actually created
                const gl = Game.renderer.getContext();
                if (!gl || gl.isContextLost()) {
                    console.warn('WebGL context failed, attempting fallback...');
                    // Try with less strict settings
                    try {
                        Game.renderer.dispose();
                        Game.renderer = new THREE.WebGLRenderer({ 
                            antialias: false,
                            powerPreference: "default",
                            failIfMajorPerformanceCaveat: false
                        });
                        const gl2 = Game.renderer.getContext();
                        if (!gl2 || gl2.isContextLost()) {
                            console.error('WebGL not available. Game may not render properly.');
                            // Continue anyway - some features may not work
                        }
                    } catch (e) {
                        console.error('WebGL initialization failed:', e);
                    }
                }
                
                Game.renderer.setSize(window.innerWidth, window.innerHeight);
                
                // Only enable shadow map if WebGL renderer and context is valid
                if (Game.renderer.shadowMap && Game.renderer.getContext()) {
                    Game.renderer.shadowMap.enabled = true;
                    Game.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                }
                
                document.body.appendChild(Game.renderer.domElement);

                updateLoadBar(50);

                // STEP 4: Environment
                setupLighting();
                setupWorld();

                updateLoadBar(60);

                // STEP 5: Entities
                spawnEnemies();
                spawnParty();
                
                // STEP 5.5: Environment (Destructibles)
                EnvSystem.init();

                updateLoadBar(70);

                // STEP 6: Inputs & Systems
                setupInputs();
                initRoboxUI();
                window.bootRoboxModule();

                updateLoadBar(80);

                // STEP 7: Initialize Bag System (after everything else is ready)
                if (bagSystemReady && window.BagSystem) {
                    try {
                        await window.BagSystem.init();
                        console.log('[A1K_Engine] BagSystem initialized successfully');
                        
                        // Initialize Arcade System if available
                        if (window.ArcadeSystem && typeof window.ArcadeSystem.init === 'function') {
                            window.ArcadeSystem.init(window.BagSystem);
                            console.log('[A1K_Engine] ArcadeSystem initialized');
                        }

                        // Wire up bag system events to engine hooks
                        wireBagSystemEvents();
                    } catch (err) {
                        console.error('[A1K_Engine] BagSystem initialization error:', err);
                    }
                }

                updateLoadBar(100);

                // STEP 8: Start game loop
                setTimeout(() => {
                    document.getElementById('loading-screen').style.opacity = 0;
                    setTimeout(() => document.getElementById('loading-screen').style.display = 'none', 800);
                    Game.loaded = true;
                    animate();
                }, 500);

            } catch (e) {
                console.error('[A1K_Engine] CRITICAL INIT ERROR:', e);
                document.getElementById('debug-console').style.display = 'block';
                document.getElementById('debug-console').innerText = "CRITICAL INIT ERROR: " + e.message;
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BAG SYSTEM EVENT WIRING
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function wireBagSystemEvents() {
            if (!window.BagSystem || !window.A1K_Engine) return;

            // Listen for bag system custom events
            document.addEventListener('itemEquipped', (e) => {
                if (window.A1K_Engine.onEquip) {
                    window.A1K_Engine.onEquip(e.detail);
                }
            });

            document.addEventListener('itemUnequipped', (e) => {
                if (window.A1K_Engine.onUnequip) {
                    window.A1K_Engine.onUnequip(e.detail);
                }
            });

            document.addEventListener('itemUsed', (e) => {
                if (window.A1K_Engine.onUse) {
                    window.A1K_Engine.onUse(e.detail);
                }
            });

            // Patch bag system methods to call engine hooks
            const originalEquipItem = window.BagSystem.equipItem;
            if (originalEquipItem) {
                window.BagSystem.equipItem = function(...args) {
                    const result = originalEquipItem.apply(this, args);
                    // Get item data and call hook
                    if (result && window.A1K_Engine.onEquip) {
                        const itemId = args[0];
                        const item = this.getInventory()?.gear?.find(g => g.id === itemId) ||
                                    this.getInventory()?.items?.find(i => i.id === itemId);
                        if (item) {
                            window.A1K_Engine.onEquip(item);
                        }
                    }
                    return result;
                };
            }

            const originalUseItem = window.BagSystem.useItem;
            if (originalUseItem) {
                window.BagSystem.useItem = function(...args) {
                    const result = originalUseItem.apply(this, args);
                    // Get item data and call hook
                    if (result && window.A1K_Engine.onUse) {
                        const itemId = args[0];
                        const item = this.getInventory()?.items?.find(i => i.id === itemId);
                        if (item) {
                            window.A1K_Engine.onUse(item);
                        }
                    }
                    return result;
                };
            }

            const originalUnequipItem = window.BagSystem.unequipItem;
            if (originalUnequipItem) {
                window.BagSystem.unequipItem = function(...args) {
                    const result = originalUnequipItem.apply(this, args);
                    // Get item data and call hook
                    if (result && window.A1K_Engine.onUnequip) {
                        const itemId = args[0];
                        const item = this.getInventory()?.gear?.find(g => g.id === itemId);
                        if (item) {
                            window.A1K_Engine.onUnequip(item);
                        }
                    }
                    return result;
                };
            }

            console.log('[A1K_Engine] Bag system events wired to engine hooks');
        }

        function updateLoadBar(pct) {
            document.getElementById('loading-bar').style.width = pct + '%';
        }

        function setupLighting() {
            const ambient = new THREE.AmbientLight(0xffffff, 0.5);
            Game.scene.add(ambient);
            
            const sun = new THREE.DirectionalLight(0xffffff, 1.2);
            sun.position.set(30, 50, 30);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 2048;
            sun.shadow.mapSize.height = 2048;
            sun.shadow.camera.near = 0.5;
            sun.shadow.camera.far = 500;
            sun.shadow.camera.left = -50;
            sun.shadow.camera.right = 50;
            sun.shadow.camera.top = 50;
            sun.shadow.camera.bottom = -50;
            Game.scene.add(sun);
        }

        function setupWorld() {
            // Infinite-looking floor
            const floorGeo = new THREE.PlaneGeometry(500, 500);
            const floorMat = new THREE.MeshStandardMaterial({ color: 0x1a1a20, roughness: 0.8, metalness: 0.2 });
            const floor = new THREE.Mesh(floorGeo, floorMat);
            floor.rotation.x = -Math.PI/2;
            floor.receiveShadow = true;
            Game.scene.add(floor);

            // Grid
            const grid = new THREE.GridHelper(500, 100, 0x00E5FF, 0x333333);
            grid.material.opacity = 0.3;
            grid.material.transparent = true;
            Game.scene.add(grid);

            // Random Obstacles (Cubes)
            const boxGeo = new THREE.BoxGeometry(4, 8, 4);
            const boxMat = new THREE.MeshStandardMaterial({ color: 0x444455 });
            for(let i=0; i<30; i++) {
                const mesh = new THREE.Mesh(boxGeo, boxMat);
                mesh.position.set((Math.random()-0.5)*200, 4, (Math.random()-0.5)*200);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                Game.scene.add(mesh);
            }
        }

        function spawnParty() {
            CONFIG.Party.forEach((def, i) => {
                const mesh = createHero(def);
                // Triangle Formation
                if(i === 0) mesh.position.set(0,0,0);
                if(i === 1) mesh.position.set(-3,0,3);
                if(i === 2) mesh.position.set(3,0,3);
                
                Game.scene.add(mesh);
                Game.partyMeshes.push(mesh);
            });
        }

        function createHero(def) {
            const group = new THREE.Group();
            
            // Body
            const body = new THREE.Mesh(
                new THREE.CapsuleGeometry(0.5 * def.scale, def.height * 0.6, 4, 8),
                new THREE.MeshStandardMaterial({ color: def.color, emissive: def.color, emissiveIntensity: 0.3, roughness: 0.4 })
            );
            body.position.y = def.height / 2;
            body.castShadow = true;
            group.add(body);

            // Head
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.4 * def.scale),
                new THREE.MeshStandardMaterial({ color: 0xffe0bd })
            );
            head.position.y = def.height - 0.2;
            group.add(head);

            // Visor/Eyes
            const visor = new THREE.Mesh(
                new THREE.BoxGeometry(0.5 * def.scale, 0.15, 0.3),
                new THREE.MeshBasicMaterial({ color: 0xffffff })
            );
            visor.position.set(0, def.height - 0.2, 0.3 * def.scale);
            group.add(visor);

            // Vehicle Mesh (Hidden initially)
            const board = new THREE.Mesh(
                new THREE.BoxGeometry(1.2, 0.1, 2.5),
                new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.2 })
            );
            board.position.y = 0.2;
            board.visible = false;
            board.name = "hoverboard";
            group.add(board);

            // Glow Ring (Leader indicator)
            const ring = new THREE.Mesh(
                new THREE.RingGeometry(0.8, 1.0, 32),
                new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.0, side: THREE.DoubleSide })
            );
            ring.rotation.x = -Math.PI/2;
            ring.position.y = 0.05;
            ring.name = "leaderRing";
            group.add(ring);

            group.userData = def;
            return group;
        }

        function spawnEnemies() {
            Game.enemies = [];
            const geo = new THREE.BoxGeometry(1.5, 1.5, 1.5);
            const mat = new THREE.MeshStandardMaterial({ color: 0xff3333 });
            
            for(let i=0; i<15; i++) {
                const mesh = new THREE.Mesh(geo, mat);
                mesh.position.set((Math.random()-0.5)*100, 0.75, (Math.random()-0.5)*100);
                mesh.castShadow = true;
                
                // Health Bar
                const barBg = new THREE.Mesh(new THREE.PlaneGeometry(2, 0.2), new THREE.MeshBasicMaterial({color:0x000000}));
                barBg.position.y = 2;
                mesh.add(barBg);
                const barFg = new THREE.Mesh(new THREE.PlaneGeometry(2, 0.2), new THREE.MeshBasicMaterial({color:0xff0000}));
                barFg.position.y = 2; barFg.position.z = 0.01;
                mesh.add(barFg);

                Game.scene.add(mesh);
                Game.enemies.push({ mesh: mesh, hp: 100, bar: barFg });
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // 4. GAME LOOP
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function animate() {
            if(!Game.loaded) return;
            requestAnimationFrame(animate);
            const dt = Game.clock.getDelta();
            
            updatePlayerMovement(dt);
            updateFollowers(dt);
            updateCamera();
            updateProjectiles(dt);
            updateAutoAttack(dt);
            updatePet(dt);
            updateRobox(dt);
            updateClones(dt);
            updateEffects(dt);
            updateRageMode();
            syncGameStateToWindow();

            Game.renderer.render(Game.scene, Game.camera);
        }

        function updatePlayerMovement(dt) {
            const leader = Game.partyMeshes[Game.leaderIndex];
            let dx = 0, dz = 0;

            // Joystick
            dx += Game.input.x;
            dz += Game.input.y;

            // Keyboard
            if (Game.keys.ArrowUp || Game.keys.w) dz -= 1;
            if (Game.keys.ArrowDown || Game.keys.s) dz += 1;
            if (Game.keys.ArrowLeft || Game.keys.a) dx -= 1;
            if (Game.keys.ArrowRight || Game.keys.d) dx += 1;

            // Movement Logic (Camera Relative)
            if (dx !== 0 || dz !== 0) {
                const speed = (Game.vehicleActive ? 25 : 12) * dt;
                
                // Calculate rotation offset based on camera angle
                const camAngle = Math.atan2(
                    Game.camera.position.x - leader.position.x, 
                    Game.camera.position.z - leader.position.z
                );
                const inputAngle = Math.atan2(dx, dz);
                const targetRotation = inputAngle + camAngle;

                leader.rotation.y = targetRotation;
                
                // Move forward in facing direction
                const moveDist = Math.min(1, Math.sqrt(dx*dx + dz*dz)) * speed;
                leader.position.x += Math.sin(targetRotation) * moveDist;
                leader.position.z += Math.cos(targetRotation) * moveDist;
            }

            // Leader Ring Pulse
            const ring = leader.getObjectByName('leaderRing');
            if(ring) {
                ring.material.opacity = 0.5 + Math.sin(Date.now() / 200) * 0.3;
                ring.visible = true;
            }
        }

        function updateFollowers(dt) {
            const leader = Game.partyMeshes[Game.leaderIndex];
            Game.partyMeshes.forEach((p, i) => {
                // Hide ring for non-leaders
                const ring = p.getObjectByName('leaderRing');
                if(ring && i !== Game.leaderIndex) ring.visible = false;

                if(i === Game.leaderIndex) return;
                
                const dist = p.position.distanceTo(leader.position);
                const targetDist = (i === (Game.leaderIndex + 1) % 3) ? 2.5 : 4.0; // V formation

                if (dist > targetDist) {
                    p.lookAt(leader.position);
                    const dir = new THREE.Vector3().subVectors(leader.position, p.position).normalize();
                    const speed = (Game.vehicleActive ? 24 : 11) * dt;
                    p.position.add(dir.multiplyScalar(speed));
                }
            });
        }

        function updateCamera() {
            const leader = Game.partyMeshes[Game.leaderIndex];
            
            // Orbit Controls Logic
            // Convert spherical coords to cartesian
            const y = Game.camOrbit.radius * Math.cos(Game.camOrbit.phi);
            const hRadius = Game.camOrbit.radius * Math.sin(Game.camOrbit.phi);
            const x = hRadius * Math.sin(Game.camOrbit.theta);
            const z = hRadius * Math.cos(Game.camOrbit.theta);

            const targetPos = leader.position.clone().add(new THREE.Vector3(x, y, z));
            
            // Smooth lerp
            Game.camera.position.lerp(targetPos, 0.15);
            Game.camera.lookAt(leader.position);
        }

        // Removed old updateAI - now using updateAutoAttack for ACT2 button
        function updateAutoAttack(dt) {
            if (!Game.autoAttack) return;
            
            const leader = Game.partyMeshes[Game.leaderIndex];
            let nearest = null;
            let minDst = 999;

            // Find target
            Game.enemies.forEach(e => {
                if (e.hp <= 0) return;
                const d = leader.position.distanceTo(e.mesh.position);
                if (d < minDst) { minDst = d; nearest = e; }
            });

            // Auto-attack logic
            if (nearest) {
                if (minDst > 4) {
                    const dir = new THREE.Vector3().subVectors(nearest.mesh.position, leader.position).normalize();
                    leader.position.add(dir.multiplyScalar(10 * dt));
                    leader.lookAt(nearest.mesh.position);
                } else {
                    // Continuous auto-attack with cooldown
                    if (!leader.userData.lastAttackTime) leader.userData.lastAttackTime = 0;
                    const now = Date.now();
                    if (now - leader.userData.lastAttackTime > 500) {
                        performAttack();
                        leader.userData.lastAttackTime = now;
                    }
                }
            }
        }

        function updateRobox(dt) {
            if (!Game.roboxActive || !Game.roboxBot || !Game.roboxMesh) return;
            
            const bot = Game.roboxBot;
            const leader = Game.partyMeshes[Game.leaderIndex];
            if (!leader) return;

            bot.animTime += dt * 1000;

            // Get goal position based on mode
            let goalPos;
            switch (bot.mode) {
                case 'aggro':
                case 'hunt': {
                    const target = findRoboxTarget(bot);
                    if (target) {
                        goalPos = target.mesh.position.clone();
                        goalPos.x -= 2;
                    } else {
                        goalPos = leader.position.clone();
                        goalPos.x -= 3;
                        goalPos.z -= 2;
                    }
                    break;
                }
                case 'assist':
                    goalPos = leader.position.clone();
                    goalPos.y += 2;
                    break;
                case 'follow':
                default:
                    goalPos = leader.position.clone();
                    goalPos.x -= 3;
                    goalPos.z -= 2;
                    break;
            }

            // Move toward goal
            const dx = goalPos.x - bot.mesh.position.x;
            const dz = goalPos.z - bot.mesh.position.z;
            const dist = Math.sqrt(dx*dx + dz*dz);

            if (dist > 1) {
                const speed = (bot.tuning?.speed ?? 140) / 100 * dt;
                bot.mesh.position.x += (dx / dist) * speed;
                bot.mesh.position.z += (dz / dist) * speed;
                bot.mesh.lookAt(goalPos);
                bot.animState = 'run';
                bot.facingLeft = dx < 0;
            } else {
                bot.animState = 'idle';
            }

            // Keep on ground
            bot.mesh.position.y = Math.max(0.6, bot.mesh.position.y);

            // Animation bob
            const bob = Math.sin(bot.animTime * 0.008) * 0.1;
            if (bot.mesh.userData.thruster) {
                bot.mesh.userData.thruster.material.opacity = 0.6 + Math.sin(bot.animTime * 0.01) * 0.2;
            }

            // Auto-attack if in range
            const now = performance.now();
            if (bot.mode === 'aggro' || bot.mode === 'hunt') {
                const target = findRoboxTarget(bot);
                if (target && now >= bot.nextFireAt) {
                    window.RoboxSkills.primaryFire(bot, target, { state: window.st });
                    bot.nextFireAt = now + (bot.tuning?.fireCd ?? bot.fireRate);
                    bot.animState = 'attack';
                }
            }

            // Cast pending skill
            if (bot.pendingSkill && window.RoboxSkills) {
                window.RoboxSkills.cast(bot.pendingSkill, bot, { state: window.st });
                bot.pendingSkill = null;
            }

            // Sync window.st for compatibility
            syncGameStateToWindow();
        }

        function findRoboxTarget(bot) {
            let nearest = null;
            let minDist = Infinity;
            
            Game.enemies.forEach(e => {
                if (e.hp <= 0) return;
                const dist = bot.mesh.position.distanceTo(e.mesh.position);
                if (dist < minDist && dist < 15) {
                    minDist = dist;
                    nearest = e;
                }
            });
            
            return nearest;
        }

        function updateClones(dt) {
            if (!Game.clones || Game.clones.length === 0) return;

            const now = Date.now();
            const leader = Game.partyMeshes[Game.leaderIndex];

            // Update each clone/minion
            Game.clones = Game.clones.filter(clone => {
                if (!clone.data?.alive || !clone.mesh) {
                    if (clone.mesh) Game.scene.remove(clone.mesh);
                    return false;
                }

                const data = clone.data;
                const mesh = clone.mesh;

                // Check lifetime
                const age = (now - data.spawnTime) / 1000;
                if (age >= data.life) {
                    data.alive = false;
                    // Fade out effect
                    mesh.traverse((child) => {
                        if (child.isMesh && child.material) {
                            child.material.opacity = Math.max(0, child.material.opacity - dt * 2);
                        }
                    });
                    if (mesh.material && mesh.material.opacity <= 0) {
                        Game.scene.remove(mesh);
                        return false;
                    }
                    return true;
                }

                // Find nearest enemy
                let nearestEnemy = null;
                let minDist = Infinity;
                Game.enemies.forEach(e => {
                    if (e.hp > 0) {
                        const dist = mesh.position.distanceTo(e.mesh.position);
                        if (dist < minDist && dist < 15) {
                            minDist = dist;
                            nearestEnemy = e;
                        }
                    }
                });

                // AI Behavior based on type
                const ai = data.ai || 'mimic';
                let targetPos;
                
                if (ai === 'hover_sniper') {
                    // DRONE: Hover high, shoot from distance
                    if (nearestEnemy) {
                        targetPos = nearestEnemy.mesh.position.clone();
                        targetPos.y = 2.5; // Stay high
                        targetPos.x += (Math.random() - 0.5) * 3;
                        targetPos.z += (Math.random() - 0.5) * 3;
                    } else {
                        targetPos = leader.position.clone();
                        targetPos.y = 2.5;
                        targetPos.x += 4;
                        targetPos.z += 4;
                    }
                    // Keep drone floating
                    mesh.position.y = 2.0 + Math.sin(now * 0.003) * 0.3;
                    
                    // Shoot laser at enemies
                    if (nearestEnemy && minDist < 12 && now - data.lastAttack > 1500) {
                        const laserDir = nearestEnemy.mesh.position.clone().sub(mesh.position).normalize();
                        const laser = new THREE.Mesh(
                            new THREE.CylinderGeometry(0.1, 0.1, minDist, 8),
                            new THREE.MeshBasicMaterial({ color: 0x00ffff, emissive: 0x00ffff })
                        );
                        laser.position.copy(mesh.position).add(laserDir.clone().multiplyScalar(minDist / 2));
                        laser.lookAt(nearestEnemy.mesh.position);
                        Game.scene.add(laser);
                        setTimeout(() => Game.scene.remove(laser), 200);
                        
                        nearestEnemy.hp -= data.atk;
                        nearestEnemy.bar.scale.x = Math.max(0, nearestEnemy.hp / 100 * 2);
                        createFloater(data.atk, nearestEnemy.mesh.position, "#00ffff");
                        if (nearestEnemy.hp <= 0) nearestEnemy.mesh.visible = false;
                        data.lastAttack = now;
                    }
                } else if (ai === 'aggressive_tank') {
                    // BEAST: Charge at enemies aggressively
                    if (nearestEnemy) {
                        targetPos = nearestEnemy.mesh.position.clone();
                    } else {
                        targetPos = leader.position.clone();
                        targetPos.x += 2;
                        targetPos.z += 2;
                    }
                    mesh.position.y = 0.6;
                    
                    // Melee attack
                    if (nearestEnemy && minDist < 2.5 && now - data.lastAttack > 800) {
                        nearestEnemy.hp -= data.atk * 1.5; // Beast hits harder
                        nearestEnemy.bar.scale.x = Math.max(0, nearestEnemy.hp / 100 * 2);
                        createFloater(Math.round(data.atk * 1.5), nearestEnemy.mesh.position, "#ff69b4");
                        if (nearestEnemy.hp <= 0) nearestEnemy.mesh.visible = false;
                        data.lastAttack = now;
                        screenShake(0.2);
                    }
                } else if (ai === 'mimic_x') {
                    // CLONE/MIMIC_X: Fire mini-X projectiles at enemies
                    if (nearestEnemy) {
                        targetPos = nearestEnemy.mesh.position.clone();
                        targetPos.x += (Math.random() - 0.5) * 2;
                        targetPos.z += (Math.random() - 0.5) * 2;
                    } else {
                        targetPos = leader.position.clone();
                        targetPos.x += 3 + (Math.random() - 0.5) * 2;
                        targetPos.z += 3 + (Math.random() - 0.5) * 2;
                    }
                    mesh.position.y = 0.6;
                    
                    // Fire mini-X projectile at enemies
                    if (nearestEnemy && minDist < 8 && now - data.lastAttack > 900) {
                        const clonePos = mesh.position.clone().add(new THREE.Vector3(0, 1, 0));
                        const toEnemy = nearestEnemy.mesh.position.clone().sub(clonePos).normalize();
                        
                        createXProjectile(clonePos, toEnemy, {
                            dmg: data.atk,
                            scale: 0.5, // Mini-X
                            pierce: 2,
                            owner: 'clone'
                        });
                        createFloater("MINI-X!", clonePos, "#00E5FF");
                        data.lastAttack = now;
                    }
                } else {
                    // CLONE/MIMIC: Follow and copy attacks (legacy)
                    if (nearestEnemy) {
                        targetPos = nearestEnemy.mesh.position.clone();
                        targetPos.x += (Math.random() - 0.5) * 2;
                        targetPos.z += (Math.random() - 0.5) * 2;
                    } else {
                        targetPos = leader.position.clone();
                        targetPos.x += 3 + (Math.random() - 0.5) * 2;
                        targetPos.z += 3 + (Math.random() - 0.5) * 2;
                    }
                    mesh.position.y = 0.6;
                    
                    // Melee attack
                    if (nearestEnemy && minDist < 3 && now - data.lastAttack > 1000) {
                        nearestEnemy.hp -= data.atk;
                        nearestEnemy.bar.scale.x = Math.max(0, nearestEnemy.hp / 100 * 2);
                        createFloater(data.atk, nearestEnemy.mesh.position, "#00E5FF");
                        if (nearestEnemy.hp <= 0) nearestEnemy.mesh.visible = false;
                        data.lastAttack = now;
                    }
                }

                // Move toward target
                const dx = targetPos.x - mesh.position.x;
                const dz = targetPos.z - mesh.position.z;
                const dist = Math.sqrt(dx*dx + dz*dz);
                
                if (dist > 0.5) {
                    const speed = (ai === 'hover_sniper' ? 6 : ai === 'aggressive_tank' ? 10 : 8) * dt;
                    mesh.position.x += (dx / dist) * speed;
                    mesh.position.z += (dz / dist) * speed;
                    if (ai !== 'hover_sniper') {
                        mesh.lookAt(targetPos);
                    } else {
                        mesh.rotation.y = Math.atan2(dx, dz);
                    }
                }

                return true;
            });
        }
        
        function updateEffects(dt) {
            // Update particle effects
            for (let i = Game.effects.length - 1; i >= 0; i--) {
                const effect = Game.effects[i];
                effect.mesh.position.add(effect.vel.clone().multiplyScalar(dt));
                effect.life -= dt;
                if (effect.life <= 0) {
                    Game.scene.remove(effect.mesh);
                    Game.effects.splice(i, 1);
                }
            }
        }
        
        function updateRageMode() {
            // Check if rage mode should end
            if (Game.rageMode && Date.now() >= Game.rageEndTime) {
                Game.rageMode = false;
                Game.rageEndTime = 0;
                const leader = Game.partyMeshes[Game.leaderIndex];
                const aura = leader.getObjectByName("rageAura");
                if (aura) leader.remove(aura);
                createFloater("Rage Ended", leader.position, "#ccc");
            }
            
            // Update button visual state
            const rageBtn = document.getElementById('rage-btn');
            if (rageBtn) {
                if (Game.rageMode) {
                    rageBtn.classList.add('active');
                } else {
                    rageBtn.classList.remove('active');
                }
            }
        }

        function syncGameStateToWindow() {
            if (!window.st) return;
            
            // Sync players
            window.st.players = Game.partyMeshes.map((m, i) => ({
                id: m.userData?.id || CONFIG.Party[i]?.id || `player${i}`,
                x: m.position.x,
                y: m.position.y,
                z: m.position.z,
                position: m.position
            }));
            window.st.leader = Game.leaderIndex;
            
            // Sync enemies
            window.st.enemies = Game.enemies.map(e => ({
                ...e,
                x: e.mesh.position.x,
                y: e.mesh.position.y,
                z: e.mesh.position.z,
                mesh: e.mesh,
                position: e.mesh.position
            }));
            
            // Sync robox
            if (Game.roboxBot) {
                const roboxArray = window.st.aiCompanions || [];
                const idx = roboxArray.findIndex(b => b.kind === 'robox');
                if (idx >= 0) {
                    roboxArray[idx] = Game.roboxBot;
                }
            }
        }

        function updatePet(dt) {
            if (!Game.petActive || !Game.petMesh) return;
            const leader = Game.partyMeshes[Game.leaderIndex];
            
            // Float near left shoulder
            const time = Date.now() * 0.002;
            const target = leader.position.clone().add(new THREE.Vector3(Math.sin(time)*2, 3 + Math.sin(time*2)*0.5, Math.cos(time)*2));
            
            Game.petMesh.position.lerp(target, 0.05);
            Game.petMesh.lookAt(leader.position);
        }

        function updateProjectiles(dt) {
            for(let i=Game.projectiles.length-1; i>=0; i--) {
                const p = Game.projectiles[i];
                
                // Homing projectiles
                if (p.homing && p.target && p.target.hp > 0) {
                    const toTarget = p.target.mesh.position.clone().sub(p.mesh.position).normalize();
                    p.vel.lerp(toTarget.multiplyScalar(p.vel.length()), 0.1);
                }
                
                p.mesh.position.add(p.vel.clone().multiplyScalar(dt));
                p.life -= dt;
                
                // Hit detection - Enemies (with pierce support)
                const pierceCount = p.pierce !== undefined ? p.pierce : 1;
                const hitEnemies = p.hitEnemies || [];
                
                Game.enemies.forEach(e => {
                    // Skip if already hit by this projectile
                    if (hitEnemies.includes(e)) return;
                    
                    if (e.hp > 0 && p.mesh.position.distanceTo(e.mesh.position) < 1.5) {
                        const damage = p.damage || 25;
                        e.hp -= damage;
                        e.bar.scale.x = Math.max(0, e.hp / 100 * 2);
                        createFloater(Math.round(damage), e.mesh.position, p.owner === 'robox' ? "#5ba3ff" : "#fff");
                        
                        if (e.hp <= 0) {
                            e.mesh.visible = false;
                            createFloater("DEAD", e.mesh.position, "#ff0000");
                        }
                        
                        // Track hit enemy and decrement pierce
                        hitEnemies.push(e);
                        p.hitEnemies = hitEnemies;
                        p.pierce = (p.pierce !== undefined ? p.pierce : 1) - 1;
                        
                        // Only destroy projectile when pierce is exhausted
                        if (p.pierce <= 0) {
                            p.life = 0;
                        }
                    }
                });
                
                // Hit detection - Environment
                EnvSystem.objects.forEach(obj => {
                    if (obj.userData && obj.userData.hp > 0 && p.mesh.position.distanceTo(obj.position) < 1.5) {
                        p.life = 0;
                        const damage = p.damage || 25;
                        EnvSystem.takeDamage(obj, damage);
                    }
                });

                if(p.life <= 0 || (p.pierce !== undefined && p.pierce <= 0)) {
                    Game.scene.remove(p.mesh);
                    Game.projectiles.splice(i, 1);
                }
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // 5. ACTION SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // Clone/Summon storage
        Game.clones = [];
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ANIME COMBAT VFX SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function screenShake(intensity) {
            if (!Game.camera) return;
            const originalPos = Game.camera.position.clone();
            let frames = 10;
            
            function shake() {
                if (frames <= 0) {
                    return;
                }
                
                const offset = new THREE.Vector3(
                    (Math.random() - 0.5) * intensity,
                    (Math.random() - 0.5) * intensity,
                    (Math.random() - 0.5) * intensity
                );
                
                Game.camera.position.add(offset);
                frames--;
                requestAnimationFrame(shake);
            }
            shake();
        }
        
        function createExplosion(pos, color) {
            // Particle burst
            for(let i=0; i<20; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1),
                    new THREE.MeshBasicMaterial({ color: color || 0xffff00 })
                );
                particle.position.copy(pos);
                const vel = new THREE.Vector3(
                    (Math.random()-0.5)*5,
                    Math.random()*5,
                    (Math.random()-0.5)*5
                );
                Game.scene.add(particle);
                
                let life = 0.5;
                const anim = () => {
                    life -= 0.02;
                    particle.position.add(vel.clone().multiplyScalar(0.02));
                    vel.multiplyScalar(0.95);
                    particle.material.opacity = life;
                    if(life > 0) {
                        requestAnimationFrame(anim);
                    } else {
                        Game.scene.remove(particle);
                    }
                };
                anim();
            }
            
            // Flash ring
            const ring = new THREE.Mesh(
                new THREE.RingGeometry(0.5, 3, 16),
                new THREE.MeshBasicMaterial({ color: color || 0xffff00, transparent: true, opacity: 0.8, side: THREE.DoubleSide })
            );
            ring.position.copy(pos);
            ring.rotation.x = -Math.PI/2;
            Game.scene.add(ring);
            
            let scale = 1;
            const ringAnim = () => {
                scale += 0.1;
                ring.scale.setScalar(scale);
                ring.material.opacity -= 0.05;
                if(ring.material.opacity > 0) {
                    requestAnimationFrame(ringAnim);
                } else {
                    Game.scene.remove(ring);
                }
            };
            ringAnim();
            
            screenShake(0.3);
        }
        
        function createAnimeSlash(pos, dir, color, scale = 1.0) {
            // Create a massive anime-style slash effect
            const arc = new THREE.Mesh(
                new THREE.TorusGeometry(3 * scale, 0.5 * scale, 8, 16, Math.PI/1.2),
                new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.9, side: THREE.DoubleSide })
            );
            arc.position.copy(pos).add(dir.clone().multiplyScalar(2 * scale));
            arc.rotation.x = Math.PI/2;
            arc.lookAt(pos.clone().add(dir.clone().multiplyScalar(10)));
            Game.scene.add(arc);
            
            // Animate slash
            let frame = 0;
            const anim = () => {
                frame++;
                arc.rotation.z -= 0.3;
                arc.scale.multiplyScalar(1.05);
                if (frame < 15) {
                    requestAnimationFrame(anim);
                } else {
                    Game.scene.remove(arc);
                }
            };
            anim();
            
            // Add particle burst
            for (let i = 0; i < 20; i++) {
                const particle = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1),
                    new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.8 })
                );
                particle.position.copy(pos);
                const vel = new THREE.Vector3(
                    (Math.random() - 0.5) * 5,
                    Math.random() * 3,
                    (Math.random() - 0.5) * 5
                );
                Game.effects.push({ mesh: particle, vel: vel, life: 0.5 });
                Game.scene.add(particle);
            }
        }
        
        function createBeamEffect(pos, dir, color, range) {
            const beam = new THREE.Mesh(
                new THREE.CylinderGeometry(0.5, 0.5, range, 16),
                new THREE.MeshBasicMaterial({ color: color, emissive: color, transparent: true, opacity: 0.9 })
            );
            beam.position.copy(pos).add(dir.clone().multiplyScalar(range / 2));
            beam.lookAt(pos.clone().add(dir.clone().multiplyScalar(range)));
            Game.scene.add(beam);
            
            // Add glow rings
            for (let i = 0; i < 3; i++) {
                const ring = new THREE.Mesh(
                    new THREE.RingGeometry(0.3 + i * 0.2, 0.5 + i * 0.2, 16),
                    new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.6, side: THREE.DoubleSide })
                );
                ring.position.copy(pos);
                ring.rotation.x = -Math.PI/2;
                ring.position.add(dir.clone().multiplyScalar(i * 2));
                Game.scene.add(ring);
                setTimeout(() => Game.scene.remove(ring), 500);
            }
            
            setTimeout(() => Game.scene.remove(beam), 500);
        }
        
        function executeSubSkill(leader, subSkill, multiplier) {
            const pos = leader.position.clone();
            pos.y += 1;
            const dir = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0,1,0), leader.rotation.y);
            const def = leader.userData;
            const color = def.color;
            const dmg = (subSkill.dmg || 10) * multiplier * (Game.rageMode ? 2.0 : 1.0);
            
            // Melee attacks
            if (subSkill.type === 'melee') {
                leader.position.add(dir.clone().multiplyScalar(2.0));
                const width = subSkill.width || 3;
                const range = subSkill.range || 4;
                checkAreaDamage(leader, pos, dir, range, width, dmg);
                
                // Visual slash
                const slash = new THREE.Mesh(
                    new THREE.PlaneGeometry(width, 2),
                    new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.8, side: THREE.DoubleSide })
                );
                slash.position.copy(pos).add(dir.clone().multiplyScalar(2));
                slash.lookAt(pos.clone().add(dir));
                Game.scene.add(slash);
                setTimeout(() => Game.scene.remove(slash), 200);
                screenShake(0.2);
                createFloater(subSkill.name || "SLASH", pos, color);
            }
            // Projectile attacks
            else if (subSkill.type === 'proj') {
                const bullet = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3),
                    new THREE.MeshBasicMaterial({ color: color, emissive: color })
                );
                bullet.position.copy(pos);
                Game.scene.add(bullet);
                const speed = subSkill.speed || 30;
                Game.projectiles.push({
                    mesh: bullet,
                    vel: dir.multiplyScalar(speed),
                    life: 2,
                    damage: dmg,
                    owner: 'player'
                });
                createFloater(subSkill.name || "PROJECTILE", pos, color);
            }
        }
        
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // X-PATTERN PROJECTILE SYSTEM
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        
        function createXProjectile(pos, dir, opts) {
            const scale = opts.scale || 1.0;
            const group = new THREE.Group();
            
            // Red Core
            const bar1 = new THREE.Mesh(
                new THREE.BoxGeometry(2 * scale, 0.2 * scale, 0.5), 
                new THREE.MeshBasicMaterial({color: 0xff0000, emissive: 0xff0000})
            ); 
            bar1.rotation.z = Math.PI / 4;
            
            // Black Shadow
            const bar2 = new THREE.Mesh(
                new THREE.BoxGeometry(2 * scale, 0.2 * scale, 0.5), 
                new THREE.MeshBasicMaterial({color: 0x000000})
            ); 
            bar2.rotation.z = -Math.PI / 4;
            
            group.add(bar1);
            group.add(bar2);
            group.position.copy(pos);
            
            // Orient X in direction of travel
            group.lookAt(pos.clone().add(dir));
            
            Game.scene.add(group);
            
            const projectile = {
                mesh: group,
                vel: dir.clone().multiplyScalar(25), // Fast travel
                life: 1.5,
                damage: opts.dmg || 50,
                pierce: opts.pierce || 3, // Hits multiple enemies
                owner: opts.owner || 'player',
                hitEnemies: [] // Track which enemies already hit
            };
            
            Game.projectiles.push(projectile);
            return projectile;
        }
        
        function queueSequentialX(actor, count, delay, opts) {
            let i = 0;
            const interval = setInterval(() => {
                if (i >= count) {
                    clearInterval(interval);
                    return;
                }
                
                // Fire one X - recalculate position and direction each time (handles player rotation)
                const pos = actor.position.clone().add(new THREE.Vector3(0, 1, 0));
                const fwd = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0,1,0), actor.rotation.y);
                
                // Alternate slight offsets for "Combo" feel
                const offset = (i % 2 === 0) ? 0.5 : -0.5;
                const offsetVec = new THREE.Vector3(
                    Math.cos(actor.rotation.y) * offset, 
                    0, 
                    -Math.sin(actor.rotation.y) * offset
                );
                pos.add(offsetVec);
                
                // Escalating damage: each X does 10% more than previous
                const escalatingDmg = opts.dmg + (i * opts.dmg * 0.1);
                
                createXProjectile(pos, fwd, {
                    dmg: escalatingDmg,
                    scale: opts.scale,
                    pierce: opts.pierce || 3,
                    owner: opts.owner || 'player'
                });
                createFloater("HYAH!", pos, "#fff");
                
                i++;
            }, delay);
        }
        
        function checkAreaDamage(source, pos, dir, radius, angle, damage) {
            // Hit enemies
            Game.enemies.forEach(e => {
                if (e.hp <= 0) return;
                const dist = source.position.distanceTo(e.mesh.position);
                if (dist < radius) {
                    e.hp -= damage;
                    e.bar.scale.x = Math.max(0, e.hp / 100 * 2);
                    createFloater(Math.round(damage), e.mesh.position, "#ff0000");
                    if (e.hp <= 0) {
                        e.mesh.visible = false;
                        createFloater("DEAD", e.mesh.position, "#ff0000");
                    }
                }
            });
            
            // Hit environment objects
            EnvSystem.objects.forEach(obj => {
                if (obj.userData && obj.userData.hp > 0) {
                    const dist = source.position.distanceTo(obj.position);
                    if (dist < radius) {
                        EnvSystem.takeDamage(obj, damage);
                    }
                }
            });
        }
        
        function checkLineDamage(source, pos, dir, range, width, damage) {
            // Hit enemies
            Game.enemies.forEach(e => {
                if (e.hp <= 0) return;
                const toEnemy = e.mesh.position.clone().sub(pos);
                const dist = toEnemy.length();
                if (dist < range) {
                    const dot = toEnemy.normalize().dot(dir);
                    if (dot > 0.9) { // In front
                        e.hp -= damage;
                        e.bar.scale.x = Math.max(0, e.hp / 100 * 2);
                        createFloater(Math.round(damage), e.mesh.position, "#00ffff");
                        if (e.hp <= 0) {
                            e.mesh.visible = false;
                            createFloater("DEAD", e.mesh.position, "#ff0000");
                        }
                    }
                }
            });
            
            // Hit environment objects
            EnvSystem.objects.forEach(obj => {
                if (obj.userData && obj.userData.hp > 0) {
                    const toObj = obj.position.clone().sub(pos);
                    const dist = toObj.length();
                    if (dist < range) {
                        const dot = toObj.normalize().dot(dir);
                        if (dot > 0.9) {
                            EnvSystem.takeDamage(obj, damage);
                        }
                    }
                }
            });
        }
        
        function findNearestEnemy(fromPos) {
            let nearest = null;
            let minDist = Infinity;
            Game.enemies.forEach(e => {
                if (e.hp > 0) {
                    const dist = fromPos.distanceTo(e.mesh.position);
                    if (dist < minDist && dist < 30) {
                        minDist = dist;
                        nearest = e;
                    }
                }
            });
            return nearest;
        }
        
        function activateRageMode(hero, duration) {
            Game.rageMode = true;
            Game.rageEndTime = Date.now() + (duration * 1000);
            createFloater("RAGE MODE!!!", hero.position, "#ff0000");
            screenShake(1.0);
            
            // Visual: Super Saiyan Aura
            const aura = new THREE.Mesh(
                new THREE.SphereGeometry(1.5),
                new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.3, wireframe: true })
            );
            aura.name = "rageAura";
            hero.add(aura);
            
            // Pulsing effect
            let pulse = 0;
            const pulseAnim = () => {
                if (!Game.rageMode || !aura.parent) return;
                pulse += 0.1;
                aura.scale.setScalar(1.0 + Math.sin(pulse) * 0.2);
                requestAnimationFrame(pulseAnim);
            };
            pulseAnim();
            
            setTimeout(() => {
                Game.rageMode = false;
                if (aura.parent) aura.parent.remove(aura);
                createFloater("Rage Ended", hero.position, "#ccc");
            }, duration * 1000);
        }
        
        function spawnAnimeMinion(owner, skillData, ownerDef) {
            let mesh;
            const spawnPos = owner.position.clone();
            spawnPos.x += 2;
            spawnPos.z += 2;
            
            // Determine summon type from skill name or character
            const skillName = (skillData.name || '').toLowerCase();
            const charId = ownerDef.id;
            
            if (skillName.includes('drone') || charId === 'UNIQUE') {
                // DRONE: Floating, Mechanic (for UNIQUE)
                const group = new THREE.Group();
                const core = new THREE.Mesh(
                    new THREE.OctahedronGeometry(0.4),
                    new THREE.MeshBasicMaterial({ color: 0x00ffff, emissive: 0x00ffff })
                );
                const wing1 = new THREE.Mesh(
                    new THREE.BoxGeometry(0.8, 0.05, 0.2),
                    new THREE.MeshBasicMaterial({ color: 0x333333 })
                );
                const wing2 = wing1.clone();
                wing2.rotation.y = Math.PI;
                const thruster = new THREE.Mesh(
                    new THREE.ConeGeometry(0.2, 0.3, 8),
                    new THREE.MeshBasicMaterial({ color: 0x00ffff, emissive: 0x00ffff })
                );
                thruster.position.y = -0.2;
                group.add(core);
                group.add(wing1);
                group.add(wing2);
                group.add(thruster);
                mesh = group;
                mesh.position.y = 2.0; // Fly high
                mesh.userData.ai = 'hover_sniper';
            } 
            else if (skillName.includes('beast') || skillName.includes('pet') || skillName.includes('fenrir') || charId === 'MISSY') {
                // BEAST: Big, Grounded (for MISSY)
                const group = new THREE.Group();
                const body = new THREE.Mesh(
                    new THREE.BoxGeometry(1.2, 0.8, 2.0),
                    new THREE.MeshStandardMaterial({ color: 0xFF69B4, emissive: 0x550055 })
                );
                const head = new THREE.Mesh(
                    new THREE.SphereGeometry(0.5),
                    new THREE.MeshStandardMaterial({ color: 0xFF69B4, emissive: 0x660066 })
                );
                head.position.set(0, 0.4, 1.0);
                const tail = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.2, 1.0),
                    new THREE.MeshStandardMaterial({ color: 0xFF69B4 })
                );
                tail.position.set(0, 0.3, -1.2);
                tail.rotation.x = Math.PI / 4;
                group.add(body);
                group.add(head);
                group.add(tail);
                mesh = group;
                mesh.position.y = 0.6;
                mesh.userData.ai = 'aggressive_tank';
            } 
            else {
                // CLONE: Transparent Copy of Player (for A1)
                mesh = createHero(ownerDef);
                mesh.scale.setScalar(0.9);
                mesh.traverse((child) => {
                    if (child.isMesh) {
                        child.material = child.material.clone();
                        child.material.transparent = true;
                        child.material.opacity = 0.6;
                        if (child.material.color) {
                            child.material.color.setHex(0x00E5FF);
                        }
                    }
                });
                mesh.position.y = 0.6;
                mesh.userData.ai = 'mimic';
            }
            
            // Spawn Logic
            mesh.position.copy(spawnPos);
            mesh.userData.life = skillData.duration || 30;
            mesh.userData.owner = owner;
            mesh.userData.ownerDef = ownerDef;
            mesh.userData.hp = 500;
            mesh.userData.hpMax = 500;
            mesh.userData.atk = skillData.damage || skillData.baseDamage || 30;
            mesh.userData.alive = true;
            mesh.userData.spawnTime = Date.now();
            mesh.userData.lastAttack = 0;
            
            Game.scene.add(mesh);
            Game.clones.push({ mesh: mesh, data: mesh.userData });
            
            // Spawn VFX
            const spawnRing = new THREE.Mesh(
                new THREE.RingGeometry(0.5, 1.5, 16),
                new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8, side: THREE.DoubleSide })
            );
            spawnRing.position.copy(spawnPos);
            spawnRing.rotation.x = -Math.PI/2;
            Game.scene.add(spawnRing);
            setTimeout(() => Game.scene.remove(spawnRing), 500);
        }

        function castSkill(skillKey) {
            const leader = Game.partyMeshes[Game.leaderIndex];
            const def = leader.userData;
            const pos = leader.position.clone();
            pos.y += 1;
            const dir = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0,1,0), leader.rotation.y);

            // First, get the actual skill ID from loadout if using A1K_DATA
            let actualSkillId = skillKey;
            if (window.A1K_DATA && window.A1K_DATA.Loadout && window.A1K_DATA.Loadout[def.id] && window.A1K_DATA.Loadout[def.id][skillKey]) {
                actualSkillId = window.A1K_DATA.Loadout[def.id][skillKey];
                console.log(`[CastSkill] Loadout lookup: ${skillKey} -> ${actualSkillId} for ${def.id}`);
            }

            // Check if skill is a combo type (from A1K_DATA)
            let skillData = null;
            if (window.A1K_DATA && window.A1K_DATA.Skills && window.A1K_DATA.Skills[actualSkillId]) {
                skillData = window.A1K_DATA.Skills[actualSkillId];
                
                // Handle combo_x type (X-Pattern Sequential)
                if (skillData.type === 'combo_x') {
                    const slashCount = skillData.slashes * (Game.rageMode ? 2 : 1);
                    queueSequentialX(leader, slashCount, skillData.interval * 1000, {
                        dmg: skillData.dmg,
                        scale: skillData.scale,
                        pierce: 3,
                        owner: 'player'
                    });
                    createFloater(skillData.name || "X-PATTERN!", pos, "#ff0000");
                    screenShake(0.3);
                    return; // Stop normal execution
                }
                
                // Handle combo type (legacy chain combo)
                if (skillData.type === 'combo') {
                    const now = Date.now();
                    
                    // Reset combo if too slow or different skill
                    if (now - ComboState.lastTime > (skillData.resetTime * 1000) || ComboState.skillId !== actualSkillId) {
                        ComboState.step = 0;
                    }
                    
                    // Get current step skill
                    const subSkillId = skillData.chain[ComboState.step];
                    const subSkill = window.A1K_DATA.Skills[subSkillId];
                    
                    if (subSkill) {
                        console.log(`[Combo] Executing step ${ComboState.step + 1}: ${subSkillId}`, subSkill);
                        // Execute Sub-Skill
                        executeSubSkill(leader, subSkill, 1.0);
                        
                        // Advance Combo
                        ComboState.step = (ComboState.step + 1) % skillData.chain.length;
                        ComboState.lastTime = now;
                        ComboState.skillId = actualSkillId;
                        
                        // Show combo indicator
                        createFloater(`COMBO ${ComboState.step}/${skillData.chain.length}`, pos, "#ffaa00");
                        return; // Stop normal execution
                    } else {
                        console.warn(`[Combo] Sub-skill ${subSkillId} not found in A1K_DATA.Skills`);
                    }
                }
            }

            // Get skill data from bag system equipped skills
            if (!skillData && window.gameState && window.gameState.equippedSkills) {
                // Try multiple possible structures
                const equippedSkills = window.gameState.equippedSkills;
                
                // Structure 1: equippedSkills[characterId][slot] (e.g., equippedSkills['A1']['S2'])
                if (equippedSkills[def.id] && equippedSkills[def.id][skillKey]) {
                    skillData = equippedSkills[def.id][skillKey];
                }
                // Structure 2: equippedSkills[characterId][slotNumber] (e.g., equippedSkills['A1']['slot2'])
                else if (equippedSkills[def.id] && equippedSkills[def.id][`slot${skillKey.slice(1)}`]) {
                    skillData = equippedSkills[def.id][`slot${skillKey.slice(1)}`];
                }
                // Structure 3: Direct slot access (legacy)
                else if (equippedSkills[skillKey]) {
                    skillData = equippedSkills[skillKey];
                }
                else if (equippedSkills[`slot${skillKey.slice(1)}`]) {
                    skillData = equippedSkills[`slot${skillKey.slice(1)}`];
                }
                
                // If still no skill data, try to get from skill database by ID
                if (!skillData) {
                    // Try UNIFIED_SKILLS_DB first
                    if (window.UNIFIED_SKILLS_DB) {
                        const skillId = `${def.id}_${skillKey}`;
                        skillData = window.UNIFIED_SKILLS_DB.find(s => s.id === skillId);
                    }
                    // Try game-data.js skill database
                    if (!skillData && window.gameState && window.gameState.skills) {
                        const skillId = `${def.id}_${skillKey}`;
                        skillData = window.gameState.skills.find(s => s.id === skillId);
                    }
                    // Try accessing via BagSystem
                    if (!skillData && window.BagSystem && window.BagSystem.getSkillData) {
                        const skillId = `${def.id}_${skillKey}`;
                        skillData = window.BagSystem.getSkillData(skillId);
                    }
                }
            } else {
                // If equippedSkills exists but is empty, try database lookup
                if (!skillData) {
                    const skillId = `${def.id}_${skillKey}`;
                    if (window.UNIFIED_SKILLS_DB) {
                        skillData = window.UNIFIED_SKILLS_DB.find(s => s.id === skillId);
                    }
                }
            }

            // If no skill data found, fallback to default attack
            if (!skillData) {
                console.warn(`[Skill Cast] No skill data found for ${skillKey} on ${def.id}. Trying database lookup...`);
                // Final fallback: use skill database directly
                const skillId = `${def.id}_${skillKey}`;
                if (window.UNIFIED_SKILLS_DB) {
                    skillData = window.UNIFIED_SKILLS_DB.find(s => s.id === skillId);
                }
                
                if (!skillData) {
                    console.warn(`[Skill Cast] Skill ${skillId} not found in database. Using default attack.`);
                    performAttack();
                    createFloater(`${skillKey} CAST!`, pos, def.color);
                    return;
                }
            }

            const skillName = skillData.name || skillKey;
            const skillShape = skillData.shape || 'default';
            const skillElement = skillData.element || 'PHYSICAL';
            const skillColor = skillData.color ? parseInt(skillData.color.replace('#', '0x')) : def.color;
            const skillDamage = skillData.damage || skillData.baseDamage || 50;
            const projectileCount = skillData.projectileCount || 1;

            // Handle SUMMON skills (S2 for all characters) - Distinct visuals
            if (skillShape === 'summon' || skillElement === 'SUMMON') {
                spawnAnimeMinion(leader, skillData, def);
                createFloater(`${skillName}!`, leader.position.clone().add(new THREE.Vector3(2, 0, 2)), skillData.color || def.color);
                screenShake(0.3);
                return;
            }

            // Calculate multiplier from charge or rage
            let multiplier = 1.0;
            const wasCharging = Game.charge.active && Game.charge.skillKey === skillKey;
            if (wasCharging) {
                const chargeDuration = (Date.now() - Game.charge.startTime) / 1000;
                multiplier = Math.min(2.0, 1.0 + chargeDuration * 0.5); // Max 2x damage, faster charge
                console.log(`[Charge] Duration: ${chargeDuration.toFixed(2)}s, Multiplier: ${multiplier.toFixed(2)}x`);
                Game.charge.active = false;
                Game.charge.skillKey = null;
            }
            if (Game.rageMode) multiplier *= 2.0;
            
            const finalDamage = skillDamage * multiplier;
            
            // Handle BUFF skills (Rage Mode)
            if (skillShape === 'buff' || skillElement === 'BUFF' || skillName.toLowerCase().includes('rage') || skillName.toLowerCase().includes('limit')) {
                activateRageMode(leader, skillData.duration || 15);
                return;
            }
            
            // Handle X-WAVE/MELEE skills (like Crimson Slash) - Enhanced with anime effects
            if (skillShape === 'xwave' || skillName.toLowerCase().includes('slash') || skillElement === 'PHYSICAL') {
                // Anime dash forward
                leader.position.add(dir.clone().multiplyScalar(3.0 * multiplier));
                
                // Create massive anime slash
                createAnimeSlash(pos, dir, skillColor, multiplier);
                
                // Area damage
                checkAreaDamage(leader, pos, dir, 6 * multiplier, 90, finalDamage);
                
                if (multiplier > 1.5) {
                    createFloater("MAX POWER!", pos, "#ff0000");
                    screenShake(0.5);
                } else {
                    createFloater(`${skillName}!`, pos, `#${skillColor.toString(16)}`);
                    screenShake(0.2);
                }
                return;
            }

            // Handle PLASMA/BULLET skills (projectiles) - Enhanced with homing
            if (skillShape === 'plasma' || skillShape === 'bullet' || skillElement === 'PLASMA' || skillElement === 'LIGHT') {
                const count = projectileCount || 3;
                const homing = skillData.homing || false;
                
                for (let i = 0; i < count; i++) {
                    setTimeout(() => {
                        const angle = count > 1 ? (i - (count-1)/2) * 0.3 : 0;
                        let bulletDir = dir.clone().applyAxisAngle(new THREE.Vector3(0,1,0), angle);
                        
                        // Homing projectiles
                        if (homing) {
                            const target = findNearestEnemy(pos);
                            if (target) {
                                const toTarget = target.mesh.position.clone().sub(pos).normalize();
                                bulletDir = bulletDir.lerp(toTarget, 0.3);
                            }
                        }
                        
                        const bullet = new THREE.Mesh(
                            new THREE.SphereGeometry(0.25),
                            new THREE.MeshBasicMaterial({ color: skillColor, emissive: skillColor })
                        );
                        bullet.position.copy(pos);
                        Game.scene.add(bullet);
                        Game.projectiles.push({ 
                            mesh: bullet, 
                            vel: bulletDir.multiplyScalar(skillData.speed || 50), 
                            life: 2.5, 
                            damage: Math.round(finalDamage / count), 
                            owner: 'player',
                            homing: homing,
                            target: homing ? findNearestEnemy(pos) : null
                        });
                    }, i * 100);
                }
                createFloater(`${skillName}!`, pos, `#${skillColor.toString(16)}`);
                screenShake(0.1);
                return;
            }

            // Handle BEAM skills (Railgun, Energy Beam) - Enhanced
            if (skillShape === 'beam' || skillName.toLowerCase().includes('beam') || skillName.toLowerCase().includes('railgun')) {
                const range = skillData.range || 30;
                createBeamEffect(pos, dir, skillColor, range);
                checkLineDamage(leader, pos, dir, range, 1.0, finalDamage);
                createFloater(`${skillName}!`, pos, `#${skillColor.toString(16)}`);
                screenShake(0.3);
                return;
            }

            // Handle SLASH skills
            if (skillShape === 'slash' || skillName.toLowerCase().includes('dance')) {
                const count = projectileCount || 3;
                for (let i = 0; i < count; i++) {
                    setTimeout(() => {
                        const slash = new THREE.Mesh(
                            new THREE.PlaneGeometry(2, 0.3),
                            new THREE.MeshBasicMaterial({ color: skillColor, transparent: true, opacity: 0.9, side: THREE.DoubleSide })
                        );
                        slash.position.copy(pos).add(dir.clone().multiplyScalar(i * 0.8));
                        slash.lookAt(pos.clone().add(dir.clone().multiplyScalar(10)));
                        slash.rotation.z = i * 0.5;
                        Game.scene.add(slash);
                        
                        setTimeout(() => Game.scene.remove(slash), 300);

                        Game.enemies.forEach(e => {
                            if (e.hp > 0 && leader.position.distanceTo(e.mesh.position) < 4) {
                                e.hp -= skillDamage / count;
                                e.bar.scale.x = Math.max(0, e.hp / 100 * 2);
                                createFloater(Math.round(skillDamage / count), e.mesh.position, `#${skillColor.toString(16)}`);
                                if (e.hp <= 0) e.mesh.visible = false;
                            }
                        });
                    }, i * 120);
                }
                createFloater(`${skillName}!`, pos, `#${skillColor.toString(16)}`);
                return;
            }

            // Default fallback - enhanced attack
            performAttack();
            createFloater(`${skillName}!`, pos, `#${skillColor.toString(16)}`);
        }

        function performAttack() {
            const leader = Game.partyMeshes[Game.leaderIndex];
            const def = leader.userData;
            const pos = leader.position.clone();
            pos.y += 1;
            const dir = new THREE.Vector3(0, 0, 1).applyAxisAngle(new THREE.Vector3(0,1,0), leader.rotation.y);
            
            const damage = Game.rageMode ? 70 : 35;

            if (def.id === 'A1') {
                // Melee Swing
                const arc = new THREE.Mesh(
                    new THREE.TorusGeometry(1.5, 0.2, 4, 8, Math.PI/1.5), 
                    new THREE.MeshBasicMaterial({ color: def.color })
                );
                arc.position.copy(pos).add(dir);
                arc.rotation.x = Math.PI/2;
                arc.lookAt(pos.clone().add(dir));
                Game.scene.add(arc);
                
                // Animate swing
                let f = 0;
                const anim = () => {
                    f++; arc.rotation.z -= 0.4;
                    if(f<8) requestAnimationFrame(anim); else Game.scene.remove(arc);
                };
                anim();
                createFloater("SLASH!", pos, def.color);
                
                // Melee Hit check area - FIXED: Check all enemies properly
                let hitCount = 0;
                Game.enemies.forEach(e => {
                    if (e.hp > 0 && e.mesh && e.mesh.visible) {
                        const dist = leader.position.distanceTo(e.mesh.position);
                        if (dist < 3.5) { // Increased range slightly
                            e.hp -= damage;
                            e.bar.scale.x = Math.max(0, e.hp / 100 * 2);
                            createFloater(damage, e.mesh.position, "#ffff00");
                            hitCount++;
                            
                            if (e.hp <= 0) {
                                e.mesh.visible = false;
                                createFloater("DEAD", e.mesh.position, "#ff0000");
                            }
                        }
                    }
                });
                
                if (hitCount === 0) {
                    // Visual feedback even if no hit
                    screenShake(0.1);
                } else {
                    screenShake(0.2);
                }

            } else {
                // Projectile Shot
                const bullet = new THREE.Mesh(
                    new THREE.SphereGeometry(0.3), 
                    new THREE.MeshBasicMaterial({ color: def.color, emissive: def.color })
                );
                bullet.position.copy(pos);
                Game.scene.add(bullet);
                Game.projectiles.push({ 
                    mesh: bullet, 
                    vel: dir.multiplyScalar(40), 
                    life: 2,
                    damage: damage,
                    owner: 'player'
                });
                createFloater("PEW!", pos, def.color);
            }
        }

        function switchLeader() {
            // Reset scale of old leader
            Game.partyMeshes[Game.leaderIndex].scale.setScalar(1.0);
            
            // Next
            Game.leaderIndex = (Game.leaderIndex + 1) % 3;
            
            // Scale up new leader
            const newLeader = Game.partyMeshes[Game.leaderIndex];
            newLeader.scale.setScalar(1.2);
            
            // Visual
            createFloater("LEADER!", newLeader.position, "#fff");
        }

        function toggleVehicle() {
            Game.vehicleActive = !Game.vehicleActive;
            Game.partyMeshes.forEach(p => {
                const board = p.getObjectByName("hoverboard");
                if(board) board.visible = Game.vehicleActive;
                
                // Lift up
                p.position.y = Game.vehicleActive ? 2.0 : (p.userData.height/2);
            });
            createFloater(Game.vehicleActive ? "HOVER ON" : "HOVER OFF", Game.partyMeshes[Game.leaderIndex].position, "#FFD700");
        }

        function togglePet() {
            if (!Game.petActive) {
                const geo = new THREE.OctahedronGeometry(0.4);
                const mat = new THREE.MeshStandardMaterial({ color: 0x00ff00, emissive: 0x00ff00, emissiveIntensity: 0.5 });
                Game.petMesh = new THREE.Mesh(geo, mat);
                Game.scene.add(Game.petMesh);
                Game.petActive = true;
                createFloater("PET SUMMONED", Game.partyMeshes[Game.leaderIndex].position, "#39FF14");
            } else {
                Game.scene.remove(Game.petMesh);
                Game.petActive = false;
                createFloater("PET DISMISSED", Game.partyMeshes[Game.leaderIndex].position, "#ff0000");
            }
        }

        function doAction(type) {
            const leader = Game.partyMeshes[Game.leaderIndex];
            if (type === 1) {
                // Spin
                let f = 0;
                const s = () => { f++; leader.rotation.y += 0.5; if(f<20) requestAnimationFrame(s); };
                s();
                createFloater("SPIN!", leader.position, "#0ff");
            } else {
                // Jump/Flip
                leader.position.y += 5;
                setTimeout(() => leader.position.y -= 5, 400);
                createFloater("FLIP!", leader.position, "#f0f");
            }
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // 6. INPUT SYSTEM (Mouse + Touch + Keys)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function setupInputs() {
            // --- KEYBOARD ---
            window.addEventListener('keydown', e => Game.keys[e.key] = true);
            window.addEventListener('keyup', e => {
                Game.keys[e.key] = false;
                const k = e.key.toLowerCase();
                if(k === 'b') {
                    if (window.BagSystem && typeof window.BagSystem.toggle === 'function') {
                        window.BagSystem.toggle();
                    }
                }
                if(e.key === 'Tab') { e.preventDefault(); switchLeader(); }
                if(e.code === 'Space') performAttack();
            });

            // --- MOUSE CAMERA CONTROL ---
            document.addEventListener('mousedown', e => {
                Game.mouseDrag.active = true;
                Game.mouseDrag.x = e.clientX;
                Game.mouseDrag.y = e.clientY;
            });
            document.addEventListener('mousemove', e => {
                if(Game.mouseDrag.active) {
                    const deltaX = (e.clientX - Game.mouseDrag.x) * 0.005;
                    const deltaY = (e.clientY - Game.mouseDrag.y) * 0.005;
                    
                    Game.camOrbit.theta -= deltaX;
                    Game.camOrbit.phi = Math.max(0.1, Math.min(Math.PI/2, Game.camOrbit.phi - deltaY));
                    
                    Game.mouseDrag.x = e.clientX;
                    Game.mouseDrag.y = e.clientY;
                }
            });
            document.addEventListener('mouseup', () => Game.mouseDrag.active = false);
            
            // Wheel Zoom
            document.addEventListener('wheel', e => {
                Game.camOrbit.radius = Math.max(5, Math.min(50, Game.camOrbit.radius + e.deltaY * 0.02));
            });

            // Double Click Reset
            document.addEventListener('dblclick', () => {
                Game.camOrbit.theta = 0;
                Game.camOrbit.phi = Math.PI/3;
                Game.camOrbit.radius = 25;
            });

            // --- ON-SCREEN JOYSTICK ---
            const stick = document.getElementById('vj-root');
            const knob = document.getElementById('vj-knob');
            let dragging = false;
            
            const handleStick = (cx, cy) => {
                const rect = stick.getBoundingClientRect();
                const center = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
                let dx = cx - center.x;
                let dy = cy - center.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                const max = 50;
                if(dist > max) { dx = (dx/dist)*max; dy = (dy/dist)*max; }
                knob.style.transform = `translate(${dx}px, ${dy}px)`;
                Game.input.x = dx/max; Game.input.y = dy/max;
            };
            const resetStick = () => { dragging = false; Game.input.x=0; Game.input.y=0; knob.style.transform = `translate(0,0)`; };

            stick.addEventListener('mousedown', () => dragging = true);
            window.addEventListener('mousemove', e => { if(dragging) handleStick(e.clientX, e.clientY); });
            window.addEventListener('mouseup', resetStick);
            
            stick.addEventListener('touchstart', e => { dragging = true; handleStick(e.touches[0].clientX, e.touches[0].clientY); e.preventDefault(); });
            window.addEventListener('touchmove', e => { if(dragging) handleStick(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
            window.addEventListener('touchend', resetStick);

            // --- HUD BUTTONS --- (Anime Combat with Charge Support)
            document.querySelectorAll('[data-btn]').forEach(btn => {
                const type = btn.dataset.btn;
                
                // Handle skill charging (mousedown/mouseup)
                if(type === 's1' || type === 's2' || type === 's3') {
                    const skillKey = type.toUpperCase();
                    
                    // Function to check if skill is chargeable (called each time)
                    const checkIfChargeable = () => {
                        const currentLeader = Game.partyMeshes[Game.leaderIndex];
                        const def = currentLeader?.userData;
                        if (!def) return false;
                        
                        // First check A1K_DATA loadout for combo skills (combos are NOT chargeable)
                        let actualSkillId = skillKey;
                        if (window.A1K_DATA && window.A1K_DATA.Loadout && window.A1K_DATA.Loadout[def.id] && window.A1K_DATA.Loadout[def.id][skillKey]) {
                            actualSkillId = window.A1K_DATA.Loadout[def.id][skillKey];
                            const skillData = window.A1K_DATA.Skills?.[actualSkillId];
                            if (skillData && skillData.type === 'combo') {
                                return false; // Combos execute instantly, no charging
                            }
                        }
                        
                        let skillData = null;
                        if (window.gameState?.equippedSkills?.[def.id]?.[skillKey]) {
                            skillData = window.gameState.equippedSkills[def.id][skillKey];
                        } else if (window.UNIFIED_SKILLS_DB) {
                            const skillId = `${def.id}_${skillKey}`;
                            skillData = window.UNIFIED_SKILLS_DB.find(s => s.id === skillId);
                        }
                        
                        // Default to chargeable for melee/physical skills, or if explicitly set
                        if (skillData) {
                            if (skillData.chargeable === false) return false;
                            if (skillData.chargeable === true || skillData.maxCharge) return true;
                            // Auto-detect: melee/physical skills are chargeable
                            if (skillData.shape === 'xwave' || 
                                skillData.element === 'PHYSICAL' || 
                                skillData.name?.toLowerCase().includes('slash')) {
                                return true;
                            }
                        }
                        // Default: S1 is usually chargeable (melee), others not by default
                        return skillKey === 'S1';
                    };
                    
                    // Start charge on mousedown
                    btn.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const currentLeader = Game.partyMeshes[Game.leaderIndex];
                        if (!currentLeader) return;
                        
                        const isChargeable = checkIfChargeable();
                        if (isChargeable) {
                            Game.charge.active = true;
                            Game.charge.startTime = Date.now();
                            Game.charge.skillKey = skillKey;
                            createFloater("CHARGING...", currentLeader.position, "#ffaa00");
                            btn.classList.add('charging');
                            console.log(`[Charge] Started charging ${skillKey}`);
                        } else {
                            // Instant cast
                            castSkill(skillKey);
                        }
                    });
                    
                    // Release charge on mouseup
                    btn.addEventListener('mouseup', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        if (Game.charge.active && Game.charge.skillKey === skillKey) {
                            console.log(`[Charge] Releasing charge for ${skillKey}`);
                            castSkill(skillKey); // Will use charge multiplier
                            Game.charge.active = false;
                            Game.charge.skillKey = null;
                            btn.classList.remove('charging');
                        } else {
                            // If button was released but not charging, cast normally
                            const isChargeable = checkIfChargeable();
                            if (!isChargeable) {
                                castSkill(skillKey);
                            }
                        }
                    });
                    
                    // Also handle mouseleave to cancel charge if mouse leaves button
                    btn.addEventListener('mouseleave', (e) => {
                        if (Game.charge.active && Game.charge.skillKey === skillKey) {
                            // Cancel charge if mouse leaves
                            Game.charge.active = false;
                            Game.charge.skillKey = null;
                            btn.classList.remove('charging');
                            console.log(`[Charge] Cancelled charge for ${skillKey}`);
                        }
                    });
                    
                    // Touch support
                    btn.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        const currentLeader = Game.partyMeshes[Game.leaderIndex];
                        if (!currentLeader) return;
                        
                        const isChargeable = checkIfChargeable();
                        if (isChargeable) {
                            Game.charge.active = true;
                            Game.charge.startTime = Date.now();
                            Game.charge.skillKey = skillKey;
                            createFloater("CHARGING...", currentLeader.position, "#ffaa00");
                            btn.classList.add('charging');
                            console.log(`[Charge] Started charging ${skillKey} (touch)`);
                        } else {
                            castSkill(skillKey);
                        }
                    });
                    
                    btn.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        if (Game.charge.active && Game.charge.skillKey === skillKey) {
                            console.log(`[Charge] Releasing charge for ${skillKey} (touch)`);
                            castSkill(skillKey);
                            Game.charge.active = false;
                            Game.charge.skillKey = null;
                            btn.classList.remove('charging');
                        } else {
                            const isChargeable = checkIfChargeable();
                            if (!isChargeable) {
                                castSkill(skillKey);
                            }
                        }
                    });
                    
                    btn.addEventListener('touchcancel', (e) => {
                        if (Game.charge.active && Game.charge.skillKey === skillKey) {
                            Game.charge.active = false;
                            Game.charge.skillKey = null;
                            btn.classList.remove('charging');
                            console.log(`[Charge] Cancelled charge for ${skillKey} (touch)`);
                        }
                    });
                    
                    return; // Skip normal click handler for skills
                }
                
                // Handle Rage button separately
                if(type === 'rage') {
                    btn.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        const leader = Game.partyMeshes[Game.leaderIndex];
                        if (!leader) return;
                        
                        if (Game.rageMode) {
                            // Cancel rage mode
                            Game.rageMode = false;
                            Game.rageEndTime = 0;
                            const aura = leader.getObjectByName("rageAura");
                            if (aura) leader.remove(aura);
                            createFloater("Rage Cancelled", leader.position, "#ccc");
                            btn.classList.remove('active');
                        } else {
                            // Activate rage mode
                            activateRageMode(leader, 15); // 15 second duration
                            btn.classList.add('active');
                        }
                    });
                    
                    btn.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        const leader = Game.partyMeshes[Game.leaderIndex];
                        if (!leader) return;
                        
                        if (Game.rageMode) {
                            Game.rageMode = false;
                            Game.rageEndTime = 0;
                            const aura = leader.getObjectByName("rageAura");
                            if (aura) leader.remove(aura);
                            createFloater("Rage Cancelled", leader.position, "#ccc");
                            btn.classList.remove('active');
                        } else {
                            activateRageMode(leader, 15);
                            btn.classList.add('active');
                        }
                    });
                    
                    return; // Skip normal click handler for rage button
                }
                
                // Normal click handlers for other buttons
                const click = (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Logic
                    if(type === 'attack') performAttack();
                    if(type === 'jump') {
                        const l = Game.partyMeshes[Game.leaderIndex];
                        l.position.y += 4; setTimeout(()=>l.position.y -= 4, 300);
                    }
                    if(type === 'switch') switchLeader();
                    if(type === 'bag') {
                        if (window.BagSystem && typeof window.BagSystem.toggle === 'function') {
                            window.BagSystem.toggle();
                        } else {
                            console.warn('BagSystem not initialized yet');
                        }
                    }
                    if(type === 'veh') { toggleVehicle(); btn.classList.toggle('active'); }
                    if(type === 'pet') { togglePet(); btn.classList.toggle('active'); }
                    if(type === 'act') doAction(1);
                    if(type === 'act2') {
                        Game.autoAttack = !Game.autoAttack;
                        btn.classList.toggle('active');
                        createFloater(Game.autoAttack ? "AUTO ATTACK ON" : "AUTO ATTACK OFF", Game.partyMeshes[Game.leaderIndex].position, "#ff7ad9");
                    }
                    if(type === 'ai') {
                        const panel = document.getElementById('roboxPanel');
                        if (panel) {
                            panel.classList.toggle('open');
                            btn.classList.toggle('active');
                        }
                    }
                };
                btn.addEventListener('mousedown', click);
                btn.addEventListener('touchstart', click);
            });
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // 7. UI UTILITIES (Floaters)
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // BagSystem will be defined below

        function createFloater(text, pos, color) {
            const el = document.createElement('div');
            el.className = 'floater';
            el.innerText = text;
            el.style.color = color;
            document.getElementById('damage-container').appendChild(el);
            
            const updatePos = () => {
                if(!el.parentElement) return;
                const vec = pos.clone();
                vec.y += 2.5;
                vec.project(Game.camera);
                const x = (vec.x * .5 + .5) * window.innerWidth;
                const y = (-(vec.y * .5) + .5) * window.innerHeight;
                el.style.left = x + 'px';
                el.style.top = y + 'px';
                requestAnimationFrame(updatePos);
            };
            updatePos();
            
            setTimeout(() => el.remove(), 800);
        }

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ROBOX UI INITIALIZATION
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        function initRoboxUI() {
            const panel = document.getElementById('roboxPanel');
            if (!panel) return;

            const logBox = document.getElementById('rbxLog');
            const lvlLabel = document.getElementById('rbxLvl');
            const modeLabel = document.getElementById('rbxMode');
            const cmdInput = document.getElementById('rbxCmd');
            const sendButton = document.getElementById('rbxSend');
            const closeButton = document.getElementById('rbxClose');

            function log(message) {
                if (!logBox) return;
                const prefix = logBox.textContent ? `${logBox.textContent}\n` : "";
                logBox.textContent = `${prefix}AI: ${message}`;
                logBox.scrollTop = logBox.scrollHeight;
            }

            function updateLevel() {
                const bot = window.RoboxController?.get();
                if (bot && lvlLabel) {
                    lvlLabel.textContent = (bot.hp / bot.hpMax * 10).toFixed(1);
                }
            }

            function setActiveMode(mode) {
                const modeButtons = {
                    follow: document.getElementById('rbxFollow'),
                    hunt: document.getElementById('rbxHunt'),
                    assist: document.getElementById('rbxAssist')
                };
                Object.values(modeButtons).forEach(btn => btn?.classList.remove('active'));
                if (modeButtons[mode]) modeButtons[mode].classList.add('active');
                if (modeLabel) {
                    modeLabel.textContent = mode.charAt(0).toUpperCase() + mode.slice(1);
                }
            }

            function applyMode(mode) {
                const controller = window.RoboxController;
                if (!controller) return;
                controller.setMode(mode);
                setActiveMode(mode);
                log(`Mode set to ${mode}.`);
            }

            function processCommand(raw) {
                const text = String(raw || "").trim();
                if (!text) return;
                const parts = text.split(/\s+/);
                const root = parts[0].toLowerCase();

                const controller = window.RoboxController;
                if (!controller) return;

                switch (root) {
                    case "/summon":
                        controller.spawn();
                        log("Companion online.");
                        updateLevel();
                        break;
                    case "/despawn":
                        controller.despawn();
                        log("Companion dismissed.");
                        break;
                    case "/mode":
                        applyMode((parts[1] || "follow").toLowerCase());
                        break;
                    case "/s1":
                    case "/s2":
                    case "/s3":
                    case "/s4":
                        controller.cast(root.slice(1).toUpperCase());
                        log(`Skill ${root.slice(1).toUpperCase()} queued.`);
                        break;
                    default:
                        log(`Unknown command: ${text}`);
                }
            }

            // Button handlers
            document.getElementById('rbxSummon')?.addEventListener('click', () => {
                window.RoboxController?.spawn();
                log("Companion online.");
                updateLevel();
            });

            document.getElementById('rbxDespawn')?.addEventListener('click', () => {
                window.RoboxController?.despawn();
                log("Companion dismissed.");
            });

            document.getElementById('rbxFollow')?.addEventListener('click', () => applyMode('follow'));
            document.getElementById('rbxHunt')?.addEventListener('click', () => applyMode('aggro'));
            document.getElementById('rbxAssist')?.addEventListener('click', () => applyMode('assist'));
            document.getElementById('rbxReturn')?.addEventListener('click', () => {
                log("Return order acknowledged.");
            });

            document.getElementById('rbxS1')?.addEventListener('click', () => {
                window.RoboxController?.cast('S1');
                log("Skill S1 queued.");
            });
            document.getElementById('rbxS2')?.addEventListener('click', () => {
                window.RoboxController?.cast('S2');
                log("Skill S2 queued.");
            });
            document.getElementById('rbxS3')?.addEventListener('click', () => {
                window.RoboxController?.cast('S3');
                log("Skill S3 queued.");
            });
            document.getElementById('rbxS4')?.addEventListener('click', () => {
                window.RoboxController?.cast('S4');
                log("Skill S4 queued.");
            });

            closeButton?.addEventListener('click', () => {
                panel.classList.remove('open');
                document.querySelector('[data-btn="ai"]')?.classList.remove('active');
            });

            sendButton?.addEventListener('click', () => {
                const value = (cmdInput?.value || "").trim();
                if (!value) return;
                log(">> " + value);
                processCommand(value);
                if (cmdInput) cmdInput.value = "";
            });

            cmdInput?.addEventListener('keydown', (ev) => {
                if (ev.key === "Enter") {
                    ev.preventDefault();
                    sendButton?.click();
                }
            });

            setActiveMode('follow');
            log("Comm-link initialized.");
            
            // Update level periodically
            setInterval(updateLevel, 1000);
        }

        // Resize
        window.addEventListener('resize', () => {
            Game.camera.aspect = window.innerWidth / window.innerHeight;
            Game.camera.updateProjectionMatrix();
            Game.renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // BOOT
        init();
    </script>
</body>
</html>
</html>