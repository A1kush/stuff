<!DOCTYPE html>
<!-- 
  ✅ OFFLINE-READY: This game works without a server!
  All ES6 modules have been converted to standard scripts.
  Just open index.html directly in any modern browser.
-->
<html lang="en">

<head>
  <meta charset="utf-8" />
  <title>A1K Runner — Unified Build (Team HP + A1 Kit v5 + Talents Lanes)</title>
  <meta content="width=device-width,initial-scale=1" name="viewport" />
  <!-- Inlined: styles/styles.css -->
<style>
/* Styles extracted from index.html */
/* From index.html style block 1 */

/* Canvas positioning */
#cv {
  width: 1548.44px;
  height: 871px;
  position: absolute;
  left: 65.7778px;
  top: 0px;
}

/* Currency positioning */
#currency {
  top: 110px;
  left: 10px;
  gap: 8px;
  justify-content: flex-start;
  pointer-events: none;
}

/* Bag header layout */
.bag-header-flex {
  width: 100%;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.bag-auto-actions-width {
  width: 100%;
  margin-top: 8px;
}

/* Player stats layout */
.player-stats-flex {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
}

/* XP bar styling */
.xp-bar {
  margin-top: 8px;
}

.xp-bar .fill {
  transform: scaleX(0);
}

/* Evolution section */
.evolution-section {
  margin-top: 8px;
  display: flex;
  gap: 8px;
}

/* Gear section HR */
.gear-hr {
  margin: 8px 0;
  border-color: var(--line);
}

/* Pet grid HR */
.pet-hr {
  grid-column: 1 / -1;
  margin: 8px 0px;
  border: 1px solid var(--line);
}

/* Vehicle grid HR */
.vehicle-hr {
  grid-column: 1 / -1;
  margin: 8px 0px;
  border: 1px solid var(--line);
}

/* Paper doll layout */
.paper-doll-container {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
  padding: 8px;
}

.paper-doll-hero {
  flex: 1;
  min-width: 160px;
}

.paper-doll-hero-title {
  text-align: center;
  font-size: 12px;
  color: #9baec8;
  margin-bottom: 4px;
}

.paper-doll-hero-display {
  width: 120px;
  height: 160px;
  border: 1px dashed var(--line);
  border-radius: 4px;
  margin: auto;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #3b4d71;
  background: rgba(255, 255, 255, 0.03);
}

.paper-doll-equipment {
  flex: 1;
  min-width: 160px;
}

.paper-doll-section-title {
  font-size: 12px;
  color: #9baec8;
  margin-bottom: 4px;
}

.paper-doll-slot {
  margin-bottom: 4px;
}

.paper-doll-pets-title {
  font-size: 12px;
  color: #9baec8;
  margin: 8px 0 4px;
}

.paper-doll-vehicle-title {
  font-size: 12px;
  color: #9baec8;
  margin: 8px 0 4px;
}

/* Quest content */
.quest-content {
  padding: 8px;
  opacity: 1;
}

.quest-header-title {
  margin: 0 0 8px;
  color: #e9f4ff;
}

.quest-timer {
  font-size: 11px;
  margin-left: 8px;
  color: #ffd56a;
}

.quest-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.quest-progress-fill {
  transform: scaleX(1);
}

.quest-reward-claimed {
  color: #36c777;
  margin-left: 4px;
}

.quest-footer {
  margin-top: 12px;
  padding-top: 8px;
  border-top: 1px solid rgba(123, 97, 255, 0.3);
}

.quest-footer-text {
  margin: 0;
  font-size: 11px;
  color: #9baec8;
}

.endless-stats {
  margin-top: 8px;
  display: none;
}

.endless-title {
  margin: 0 0 4px;
  color: #ffaa00;
}

.endless-score {
  margin: 0;
  font-size: 12px;
  color: #cfe3ff;
}

.endless-time {
  margin: 0;
  font-size: 12px;
  color: #cfe3ff;
}

/* Settings card */
.settings-card {
  background: rgba(255, 255, 255, 0.04);
  padding: 8px;
  border: 1px solid rgba(123, 97, 255, 0.2);
  border-radius: 6px;
}

.settings-title {
  margin: 0 0 6px;
  font-size: 14px;
}

.settings-label {
  display: block;
  margin-top: 6px;
}

.settings-qa-section {
  margin-top: 8px;
}

.settings-qa-button {
  padding: 6px 10px;
  border: 1px solid #3b4d71;
  background: #1a263a;
  color: #d7e9ff;
  border-radius: 6px;
  cursor: pointer;
}

.settings-qa-note {
  opacity: 0.7;
  margin-left: 8px;
}

.qa-tools-flex {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.audio-volume-slider {
  width: 100%;
}

.hud-position-select {
  margin-left: 4px;
}

/* Shared gauge fill */
.shared-gauge-fill {
  transform: scaleX(1);
}

/* Action button styling */
.action-new-display {
  display: flex;
  background-color: var(--pastel-pet);
}

/* Joystick nub positioning */
.nub-center {
  left: 50%;
  top: 50%;
}

/* Duration ring hidden */
.duration-ring-hidden {
  display: none;
}

/* Secret button styling */
.secret-btn-ready {
  opacity: 1;
  pointer-events: auto;
}

/* Hero styling */
.hero-unique-cursor {
  cursor: pointer;
}

.hero-unique-hp-fill {
  transform: scaleX(0.88);
}

.hero-unique-secret-fill {
  transform: scaleX(1);
}

.hero-unique-rage-fill {
  transform: scaleX(0.82);
}

.hero-unique-skill-icons {
  display: flex;
}

.hero-missy-cursor {
  cursor: pointer;
}

.hero-missy-hp-fill {
  transform: scaleX(0.92);
}

.hero-missy-secret-fill {
  transform: scaleX(1);
}

.hero-missy-rage-fill {
  transform: scaleX(0.42);
}

.hero-missy-skill-icons {
  display: flex;
}

.btn-switch-char {
  pointer-events: auto;
  display: none;
}

.hp-fill {
  transform: scaleX(0.28);
}

.mp-fill {
  transform: scaleX(1);
}

.xp-bar-container {
  min-width: 260px;
  position: relative;
}

.xp-dom-fill {
  transform: scaleX(0.9375);
}

.boss-bar-container {
  min-width: 260px;
}

.boss-fill {
  transform: scaleX(0);
}

.gold-pill {
  pointer-events: auto;
}

.toggle-currencies {
  cursor: pointer;
  pointer-events: auto;
}

.extra-currencies {
  display: none;
  gap: 8px;
  pointer-events: auto;
  flex-wrap: wrap;
}

.drop-rate-display {
  pointer-events: auto;
}

/* From index.html style block 2 */

:root {
  --bg: #0d131c;
  --ink: #e9f4ff;
  --muted: #a8b7ce;
  --line: #293854;
  --panel: #121b20;
  --panel2: #0f1826;
  --panel3: #0b1421;
  --hp: #36c777;
  --hp2: #6de38e;
  --mp: #3ec5ff;
  --mp2: #6aa8ff;
  --boss: #ff8c6a;
  --boss2: #ffbb9a;
  --rage: #f9cc2b;
  --rage2: #ff7a31;
  --pastel-pet: #c1ffc1;
  --pastel-action: #add8e6;
  --pastel-veh: #e6e6fa;
  --pastel-attack: #ff6666;
  /* A nice red color */
}

/* New Pixel Art Button Cluster Styles */
.rightDock {
  position: fixed;
  right: 14px;
  bottom: 14px;
  display: flex;
  flex-direction: column;
  gap: 6px;
  align-items: flex-end;
  z-index: 1000;
  pointer-events: auto;
}

.rightDock .row,
.rightDock .sRow {
  display: flex;
  gap: 6px;
  align-items: center;
}

.rightDock .btn {
  cursor: pointer;
  border: 4px solid #000;
  background: rgba(42, 36, 54, 0.9);
  color: #dfe9ff;
  padding: 8px 10px;
  font-family: "Press Start 2P", cursive;
  font-size: 10px;
  image-rendering: pixelated;
  box-shadow: inset -2px -2px 0 0 rgba(0, 0, 0, 0.3);
}

.rightDock .btn:active {
  box-shadow: inset 2px 2px 0 0 rgba(0, 0, 0, 0.3);
  transform: translate(1px, 1px);
}

.rightDock .btn.small {
  padding: 5px 8px;
  font-size: 10px;
}

.rightDock .btn.big {
  width: 96px;
  height: 96px;
  font-weight: 800;
  display: flex;
  align-items: center;
  justify-content: center;
}

.rightDock .btn.border-ink {
  border-color: #ffc800;
}

.rightDock .btn.ready {
  animation: ready-glow 1s infinite alternate;
}

@keyframes ready-glow {
  from {
    box-shadow: 0 0 5px #ffc800;
  }

  to {
    box-shadow: 0 0 15px #ffc800;
  }
}

html,
body {
  margin: 0;
  height: 100%;
  background: var(--bg);
  color: var(--ink);
  font: 14px/1.4 system-ui, Segoe UI, Roboto, Arial, sans-serif;
}

* {
  box-sizing: border-box;
}

#wrap {
  position: relative;
  margin: 0 auto;
  max-width: 1280px;
  height: 100vh;
  overflow: hidden;
  border-left: 1px solid var(--line);
  border-right: 1px solid var(--line);
}

canvas {
  display: block;
  image-rendering: -webkit-optimize-contrast;
  image-rendering: pixelated;
  background: linear-gradient(#0c1420, #0a1018);
}

.hud {
  position: absolute;
  left: 10px;
  right: 10px;
  top: 8px;
  display: flex;
  gap: 10px;
  align-items: center;
  pointer-events: none;
  flex-wrap: wrap;
}

.pill {
  pointer-events: auto;
  background: var(--panel);
  border: 1px solid var(--line);
  border-radius: 10px;
  padding: 6px 10px;
  font-size: 12px;
  color: var(--muted);
}

.bar {
  position: relative;
  height: 12px;
  background: var(--panel);
  border: 1px solid var(--line);
  border-radius: 999px;
  overflow: hidden;
  min-width: 200px;
}

.fill {
  position: absolute;
  inset: 0;
  transform-origin: left center;
}

.hp {
  background: linear-gradient(90deg, var(--hp), var(--hp2));
}

.mp {
  background: linear-gradient(90deg, var(--mp), var(--mp2));
}

.boss {
  background: linear-gradient(90deg, var(--boss), var(--boss2));
}

.xp {
  background: linear-gradient(90deg, #2ea8ff, #7b61ff);
}

.xpText {
  position: absolute;
  left: 0;
  right: 0;
  top: -16px;
  text-align: center;
  font-weight: 700;
  font-size: 12px;
  color: #a8b7ce;
  text-shadow: 0 1px 2px #000;
}

/* Quest tier tags */
.quest-tier {
  font-size: 10px;
  padding: 2px 4px;
  border-radius: 3px;
  margin-left: 4px;
  display: inline-block;
}

.quest-tier.bronze {
  background: #8d5524;
  color: #ffe6b3;
}

.quest-tier.silver {
  background: #8a8a8a;
  color: #f5f5f5;
}

.quest-tier.gold {
  background: #d4af37;
  color: #fff8d4;
}

#xpDomFill.pulse {
  animation: xpGlow 0.6s ease-out;
}

@keyframes xpGlow {
  0% {
    box-shadow: 0 0 0 rgba(123, 97, 255, 0);
  }

  50% {
    box-shadow: 0 0 10px rgba(123, 97, 255, 0.9);
  }

  100% {
    box-shadow: 0 0 0 rgba(123, 97, 255, 0);
  }
}

.subdock {
  position: absolute;
  left: 10px;
  top: 70px;
  display: flex;
  gap: 8px;
  pointer-events: auto;
  flex-wrap: wrap;
}

.btn {
  background: var(--panel2);
  border: 1px solid var(--line);
  color: var(--ink);
  border-radius: 10px;
  padding: 6px 10px;
  cursor: pointer;
}

.btn:active {
  transform: translateY(1px);
}

.controls {
  position: absolute;
  left: 10px;
  right: 10px;
  bottom: 10px;
  display: flex;
  align-items: flex-end;
  justify-content: space-between;
  pointer-events: none;
}

.stick {
  position: relative;
  width: 140px;
  height: 140px;
  border-radius: 50%;
  background: radial-gradient(
    circle at 50% 50%,
    #111b2a 0%,
    #0c1420 60%,
    #0c1420 100%
  );
  border: 1px solid var(--line);
  box-shadow: inset 0 0 18px rgba(0, 0, 0, 0.55);
  pointer-events: auto;
}

.stick .nub {
  position: absolute;
  left: 50%;
  top: 50%;
  width: 64px;
  height: 64px;
  margin: -32px 0 0 -32px;
  border-radius: 50%;
  background: radial-gradient(circle at 35% 35%, #29384f, #1b2639);
  border: 1px solid #3b4d71;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.35);
}

.actions {
  position: relative;
  display: flex;
  gap: 22px;
  pointer-events: auto;
  align-items: flex-end;
}

.col {
  display: flex;
  flex-direction: column;
  gap: 16px;
  align-items: flex-end;
}

.btn-round {
  width: 64px;
  height: 64px;
  border-radius: 50%;
  background: radial-gradient(circle at 40% 35%, #2a384f, #182235);
  border: 1px solid var(--line);
  box-shadow: 0 3px 12px rgba(0, 0, 0, 0.35);
  color: #dfe9ff;
  display: flex;
  align-items: center;
  justify-content: center;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  cursor: pointer;
}

.btn-round.small {
  width: 56px;
  height: 56px;
  font-size: 11px;
}

.btn-round.btn-skill {
  flex-direction: column;
  gap: 2px;
  line-height: 1.1;
  padding: 6px 4px;
}

.btn-skill .key-label {
  font-size: 12px;
  font-weight: 700;
  letter-spacing: 0.03em;
}

.btn-skill .scroll-label {
  font-size: 10px;
  font-weight: 600;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  opacity: 0.75;
  min-height: 12px;
}

.btn-round.has-scroll .scroll-label {
  opacity: 1;
}

.btn-round[data-scroll-hero="A1"] .scroll-label {
  color: #4ecdc4;
}

.btn-round[data-scroll-hero="UNIQUE"] .scroll-label {
  color: #a5d8ff;
}

.btn-round[data-scroll-hero="MISSY"] .scroll-label {
  color: #ffd56a;
}

.btn-round.big {
  width: 86px;
  height: 86px;
  font-weight: 700;
}

.btn-round:active {
  transform: translateY(1px);
}

#itemMenu {
  position: fixed;
  z-index: 10000;
  background: #0f1826;
  border: 1px solid var(--line);
  border-radius: 8px;
  display: none;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.45);
}

#itemMenu button {
  display: block;
  width: 100%;
  padding: 6px 10px;
  background: transparent;
  border: 0;
  color: #cfe3ff;
  text-align: left;
}

#itemMenu button:hover {
  background: #15243a;
}

#notificationWrap {
  position: fixed;
  right: 14px;
  top: 14px;
  z-index: 12000;
  display: flex;
  flex-direction: column;
  gap: 6px;
  pointer-events: none;
}

.toast {
  background: #0f1826;
  border: 1px solid var(--line);
  border-radius: 8px;
  color: #cfe3ff;
  padding: 6px 10px;
  box-shadow: 0 8px 18px rgba(0, 0, 0, 0.35);
  opacity: 0.95;
}

.bag-overlay {
  position: fixed;
  top: 0;
  right: 0;
  bottom: 0;
  width: 60%;
  max-width: 600px;
  background: linear-gradient(rgba(3, 7, 15, 0.95), rgba(3, 7, 15, 0.95));
  box-shadow: 0 0 32px rgba(123, 97, 255, 0.55);
  border-left: 2px solid rgba(123, 97, 255, 0.5);
  padding: 12px;
  display: none;
  flex-direction: column;
  z-index: 1000;
  overflow-y: auto;
}

.bag-overlay.open {
  display: flex;
}

.bag-header {
  display: flex;
  flex-wrap: wrap;
  justify-content: space-between;
  align-items: center;
  padding-bottom: 4px;
  border-bottom: 1px solid rgba(123, 97, 255, 0.3);
  color: #e9f4ff;
}

.bag-nav {
  display: flex;
  flex-direction: column;
  gap: 6px;
  padding-right: 8px;
  border-right: 1px solid rgba(123, 97, 255, 0.3);
}

.bag-nav-item {
  background: rgba(255, 255, 255, 0.05);
  color: #a8b7ce;
  padding: 6px 10px;
  text-align: left;
  cursor: pointer;
  font-weight: 600;
  border-radius: 4px;
  border: 1px solid rgba(123, 97, 255, 0.2);
}

.bag-nav-item:hover {
  background: rgba(123, 97, 255, 0.2);
  color: #e9f4ff;
  border-color: rgba(123, 97, 255, 0.4);
}

.bag-nav-item.active {
  background: linear-gradient(90deg, #2ea8ff, #7b61ff);
  color: #fff;
  border-color: rgba(123, 97, 255, 0.6);
}

.bag-body {
  flex: 1;
  display: flex;
  margin-top: 8px;
}

.bag-content {
  flex: 3;
  padding-right: 8px;
  overflow-y: auto;
}

.bag-detail {
  flex: 2;
  border-left: 1px solid rgba(58, 226, 255, 0.2);
  padding-left: 8px;
  color: #cfe3ff;
  overflow-y: auto;
}

.bag-grid {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  gap: 6px;
}

.gear-grid {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: 6px;
}

.pets-grid {
  display: grid;
  grid-template-columns: repeat(5, 1fr);
  gap: 6px;
}

.vehicles-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(64px, 1fr));
  gap: 6px;
  padding: 8px;
}

.shop-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
  gap: 8px;
  padding: 8px;
}

.shop-item {
  background: rgba(255, 255, 255, 0.04);
  border: 1px solid rgba(123, 97, 255, 0.2);
  border-radius: 6px;
  padding: 8px;
  text-align: center;
  font-size: 12px;
}

.shop-item h5 {
  margin: 0 0 4px;
  font-size: 13px;
  color: #cfe3ff;
}

.shop-item p {
  margin: 0 0 8px;
  color: #9baec8;
  font-size: 11px;
}

.shop-item button {
  background: rgba(123, 97, 255, 0.2);
  border: 1px solid rgba(123, 97, 255, 0.4);
  color: #e9f4ff;
  padding: 4px 8px;
  border-radius: 4px;
  cursor: pointer;
  width: 100%;
}

.shop-item button:hover {
  background: rgba(123, 97, 255, 0.4);
}

.shop-tabs-container {
  display: flex;
  gap: 6px;
  margin-bottom: 8px;
  flex-wrap: wrap;
}

.shop-tab {
  padding: 4px 8px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  background: #1f2e47;
  color: #cfe3ff;
}

.shop-tab-active {
  background: #2ea8ff;
  color: #fff;
}

.self-tests {
  position: fixed;
  right: 8px;
  bottom: 8px;
  background: rgba(11, 18, 32, 0.8);
  padding: 8px 10px;
  border-radius: 8px;
  border: 1px solid rgb(27, 42, 70);
  font: 12px ui-monospace;
  color: rgb(205, 231, 255);
  max-width: 420px;
  z-index: 99999;
  pointer-events: auto;
}

.test-run-btn {
  margin-left: 8px;
  background: #14233a;
  color: #cde7ff;
  border: 1px solid #22314e;
  border-radius: 6px;
  padding: 2px 6px;
  cursor: pointer;
}

.test-log {
  margin-top: 6px;
}

.test-fail {
  color: rgb(255, 182, 182);
}

.test-pass {
  color: rgb(159, 255, 168);
}

.skill-btn-overlay {
  position: absolute;
  inset: 0px;
  z-index: 10000;
  pointer-events: none;
}

.skill-btn {
  display: flex;
}

.toast-warning {
  color: rgb(255, 213, 106);
}

.toast-fading {
  color: rgb(255, 213, 106);
  transition: opacity 0.4s;
  opacity: 0;
}

.bag-panel {
  display: none;
}

.bag-panel.active {
  display: block;
}

.slot-box {
  height: 44px;
  border: 1px dashed rgba(123, 97, 255, 0.4);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  color: #cfe3ff;
  cursor: pointer;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
  background: rgba(255, 255, 255, 0.04);
}

.slot-box.item {
  background: rgba(46, 168, 255, 0.08);
}

.slot-box.equip {
  background: rgba(255, 165, 0, 0.08);
}

.slot-box.pet {
  background: rgba(255, 192, 203, 0.08);
}

.bag-detail-content h4 {
  margin: 0 0 4px 0;
  font-size: 14px;
  color: #cfe3ff;
}

.bag-detail-content p {
  font-size: 12px;
  margin: 0 0 8px 0;
  color: #9baec8;
}

.bag-actions button {
  display: inline-block;
  margin-right: 6px;
  margin-bottom: 6px;
  padding: 4px 8px;
  font-size: 12px;
  border: none;
  border-radius: 4px;
  cursor: pointer;
  background: #0f1826;
  color: #cfe3ff;
}

.bag-actions button:hover {
  background: #1a263a;
}

.drawer-close {
  position: absolute;
  top: 6px;
  right: 8px;
  width: 20px;
  height: 20px;
  border: 0;
  background: transparent;
  color: var(--muted);
  font-size: 16px;
  line-height: 20px;
  cursor: pointer;
  pointer-events: auto;
}

.drawer-close:hover {
  color: var(--ink);
}

/* Talent Lanes */
.lane-wrap {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
}

.lane-col {
  flex: 1 1 160px;
  background: rgba(255, 255, 255, 0.03);
  border: 1px solid rgba(123, 97, 255, 0.25);
  padding: 6px;
  border-radius: 6px;
}

.lane-col h4 {
  margin: 2px 0 6px;
  font-size: 12px;
  letter-spacing: 0.5px;
  color: #cfe3ff;
}

.lane-node {
  display: flex;
  flex-direction: column;
  gap: 2px;
  margin-bottom: 6px;
  padding: 6px;
  background: #0f1826;
  border: 1px solid rgba(123, 97, 255, 0.25);
  border-radius: 4px;
  font-size: 11px;
  cursor: pointer;
  position: relative;
}

.lane-node.owned {
  background: #1d2c48;
  border-color: #63e6ff;
  color: #bfe9ff;
}

.lane-node.locked {
  opacity: 0.45;
  cursor: not-allowed;
}

.lane-node span.cost {
  position: absolute;
  right: 6px;
  top: 4px;
  font-size: 10px;
  color: #ffd56a;
}

.lane-node small {
  color: #8ea5c4;
  font-size: 10px;
}

.lane-node button {
  margin-top: 4px;
  font-size: 10px;
  padding: 3px 6px;
  background: #2d3a54;
  border: 1px solid #4b638b;
  border-radius: 3px;
  color: #d7e9ff;
  cursor: pointer;
}

.lane-node button:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

#talentSummary {
  margin-top: 6px;
  font-size: 11px;
  color: #9baec8;
  line-height: 1.4;
  white-space: pre-wrap;
}

.upgrade-btn[disabled] {
  opacity: 0.4;
  cursor: not-allowed;
}

/* Team Status UI */
.team-status {
  display: flex;
  gap: 8px;
  pointer-events: auto;
  flex-wrap: nowrap;
}

.hero-portrait {
  position: relative;
  background: var(--panel);
  border: 1px solid var(--line);
  border-radius: 6px;
  padding: 4px;
  min-width: 48px;
  text-align: center;
}

.hero-portrait.leader {
  border-color: var(--hp);
  box-shadow: 0 0 8px rgba(54, 199, 119, 0.3);
}

.hero-portrait.defeated {
  opacity: 0.5;
  border-color: #ff4d4f;
}

.hero-portrait.secret-ready {
  box-shadow: 0 0 12px rgba(255, 106, 168, 0.9);
  border-color: #ff6aa8;
  animation: secretGlow 1.2s infinite alternate;
}

@keyframes secretGlow {
  from {
    box-shadow: 0 0 8px rgba(255, 106, 168, 0.7);
  }

  to {
    box-shadow: 0 0 20px rgba(255, 106, 168, 1);
  }
}

.hero-icon {
  font-size: 11px;
  font-weight: 700;
  color: var(--ink);
  margin-bottom: 2px;
}

.hero-hp-bar {
  position: relative;
  height: 4px;
  background: var(--panel2);
  border-radius: 2px;
  overflow: hidden;
  margin-bottom: 2px;
}

.hero-hp-fill {
  position: absolute;
  inset: 0;
  background: linear-gradient(90deg, var(--hp), var(--hp2));
  transform-origin: left center;
}

.hero-status {
  font-size: 8px;
  color: var(--muted);
  min-height: 10px;
}

.hero-portrait.defeated .hero-status {
  color: #ff4d4f;
}

.hero-portrait {
  cursor: pointer;
}

.hero-skill-icons {
  display: none;
  justify-content: center;
  gap: 2px;
  margin-top: 2px;
  height: 8px;
}

.skill-icon {
  width: 8px;
  height: 8px;
  border-radius: 2px;
  background-color: var(--panel2);
  border: 1px solid var(--line);
}

.skill-icon.ready {
  background-color: var(--mp);
  border-color: var(--mp2);
  box-shadow: 0 0 4px var(--mp);
}

/* Secret Gauge */
.secret-gauge {
  position: relative;
  width: 40px;
  height: 8px;
  background: var(--panel2);
  border: 1px solid var(--line);
  border-radius: 4px;
  overflow: hidden;
  margin: 0 auto 4px;
}

.secret-fill {
  position: absolute;
  inset: 0;
  background: linear-gradient(90deg, #ff6aa8, #ffaa00);
  transform-origin: left center;
}

/* Rage Gauge */
.rage-gauge {
  position: relative;
  width: 40px;
  height: 8px;
  background: var(--panel2);
  border: 1px solid var(--line);
  border-radius: 4px;
  overflow: hidden;
  margin: 0 auto 4px;
}

.rage-fill {
  position: absolute;
  inset: 0;
  background: linear-gradient(90deg, var(--rage), var(--rage2));
  transform-origin: left center;
}

.hero-portrait.rage-ready {
  box-shadow: 0 0 10px rgba(249, 204, 43, 0.6);
  border-color: #ffb84d;
}

.btn-round.ready {
  box-shadow: 0 0 10px rgba(255, 218, 120, 0.8),
    0 0 2px rgba(255, 255, 255, 0.4) inset;
  border-color: #ffd56a;
}

/* S2 recall cooldown ring */
#btnS2.coolring {
  position: relative;
  --p: 0deg;
  background: conic-gradient(#6aa8ff var(--p), #182235 0deg);
}

#btnS2.coolring::after {
  content: "";
  position: absolute;
  inset: 5px;
  border-radius: 50%;
  background: radial-gradient(circle at 40% 35%, #2a384f, #182235);
  border: 1px solid var(--line);
}

/* Quest UI */
.quest-item {
  background: rgba(255, 255, 255, 0.04);
  border: 1px solid rgba(123, 97, 255, 0.3);
  border-radius: 6px;
  padding: 8px;
  margin-bottom: 6px;
}

.quest-item.completed {
  border-color: #36c777;
  background: rgba(54, 199, 119, 0.1);
}

.quest-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 4px;
}

.quest-name {
  font-size: 13px;
  color: #cfe3ff;
  font-weight: 600;
}

.quest-progress {
  font-size: 11px;
  color: #9baec8;
}

.quest-description {
  font-size: 11px;
  color: #a8b7ce;
  margin-bottom: 6px;
}

.quest-progress-bar {
  position: relative;
  height: 4px;
  background: var(--panel2);
  border-radius: 2px;
  overflow: hidden;
  margin-bottom: 4px;
}

.quest-progress-fill {
  position: absolute;
  inset: 0;
  background: linear-gradient(90deg, #2ea8ff, #7b61ff);
  transform-origin: left center;
}

.quest-reward {
  font-size: 10px;
  color: #ffd56a;
}

/* Universal Action Button & Shared Gauge */
.shared-gauge {
  position: absolute;
  top: -12px;
  left: 0;
  right: 0;
  height: 4px;
  background: var(--panel);
  border: 1px solid var(--line);
  border-radius: 2px;
  overflow: hidden;
  width: 140px;
  /* Match joyWrap width */
  margin: 0 auto;
}

.shared-gauge .fill {
  background: linear-gradient(90deg, var(--mp), var(--mp2));
  transform: scaleX(0);
  /* Default empty */
}

.action-container {
  position: relative;
  width: 86px;
  height: 86px;
  display: flex;
  align-items: center;
  justify-content: center;
}

.duration-ring {
  position: absolute;
  top: -2px;
  left: -2px;
  width: 90px;
  height: 90px;
  transform: rotate(-90deg);
  pointer-events: none;
  display: none;
  /* hide the duration ring (yellow circle) */
}

/* Hide old universal action container and chest interact overlay */
#universal-action-container {
  display: none !important;
}

#apxInteract {
  display: none !important;
}

.duration-ring circle {
  fill: transparent;
  stroke-width: 4px;
}

.duration-ring .duration-ring-bg {
  stroke: rgba(0, 0, 0, 0.3);
}

.duration-ring .duration-ring-fg {
  stroke: var(--rage);
  stroke-linecap: round;
  transition: stroke-dashoffset 0.1s linear;
}

/* Hide legacy big ACTION circle; we use the compact Act btn next to Pet/Veh */
#btnUniversalAction {
  display: none !important;
}

/* hide the yellow duration ring and chest prompt as requested */
.duration-ring {
  display: none !important;
}

#apxInteract {
  display: none !important;
}

/* hide the old pet ready gauge so only canvas pets show */
#petReady {
  display: none !important;
}

/* Chibi HUD Refresh */
.joyWrap {
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 10px;
}

.micro-actions {
  display: flex;
  gap: 8px;
  pointer-events: auto;
}

.btn-micro {
  background: var(--panel2);
  border: 1px solid var(--line);
  color: var(--ink);
  border-radius: 8px;
  padding: 4px 8px;
  font-size: 10px;
  cursor: pointer;
  font-weight: 600;
}

.btn-micro:active {
  transform: translateY(1px);
}

#btnPet {
  background-color: var(--pastel-pet);
  color: #333;
}

#btnActionNew {
  background-color: var(--pastel-action);
  color: #333;
}

#btnVeh {
  background-color: var(--pastel-veh);
  color: #333;
}

#btnShoot {
  width: 119px;
  height: 119px;
  border-radius: 50%;
  background: var(--pastel-attack);
  color: #333;
  font-weight: 700;
}

.actions-secondary {
  display: flex;
  gap: 16px;
  pointer-events: auto;
  align-items: flex-end;
}

.action-buttons-wrapper {
  display: flex;
  align-items: flex-end;
  gap: 22px;
}

/* Bag Auto Buttons */
.bag-auto-actions {
  display: flex;
  gap: 8px;
  margin-bottom: 10px;
  pointer-events: auto;
}

.btn-auto {
  background: var(--panel2);
  border: 1px solid var(--line);
  color: var(--ink);
  border-radius: 8px;
  padding: 4px 8px;
  font-size: 10px;
  cursor: pointer;
  font-weight: 600;
}

.btn-auto:active {
  transform: translateY(1px);
}

#btnOpenAll {
  background-color: var(--pastel-pet);
}

#btnAutoUp {
  background-color: var(--pastel-attack);
}

#btnAutoEq {
  background-color: var(--pastel-action);
}

#btnAutoFuse {
  background-color: #fffacd;
}

#btnAlchemy {
  background-color: #ffb6c1;
}

/* Alchemy Panel */
.alchemy-body {
  padding: 10px;
}

.alchemy-bag-strip {
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  gap: 6px;
  margin-bottom: 10px;
  background-color: var(--panel);
  padding: 10px;
  border-radius: 8px;
  min-height: 100px;
  /* Placeholder for two rows */
}

.alchemy-info-boxes,
.alchemy-rules-boxes {
  display: flex;
  gap: 10px;
  margin-bottom: 10px;
}

.info-box {
  background-color: var(--panel);
  padding: 10px;
  border-radius: 8px;
  flex: 1;
  font-size: 12px;
  text-align: center;
}

.alchemy-crafting-area {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 20px;
  margin-bottom: 10px;
}

.alchemy-slots {
  display: flex;
  gap: 10px;
}

.alchemy-arrow {
  font-size: 24px;
}

/* Canvas positioning */
#cv {
  width: 1548.44px;
  height: 871px;
  position: absolute;
  left: 65.7778px;
  top: 0px;
}

/* Currency positioning */
#currency {
  top: 110px;
  left: 10px;
  gap: 8px;
  justify-content: flex-start;
  pointer-events: none;
}

/* Bag header layout */
.bag-header-content {
  width: 100%;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.bag-auto-actions-full {
  width: 100%;
  margin-top: 8px;
}

/* Player stats layout */
.player-stats-flex {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
}

/* XP bar styling */
.xp-bar {
  margin-top: 8px;
}

.xp-bar .fill {
  transform: scaleX(0);
}

/* Evolution section */
.evolution-section {
  margin-top: 8px;
  display: flex;
  gap: 8px;
}

/* Gear section HR */
.gear-hr {
  margin: 8px 0;
  border-color: var(--line);
}

/* Pet grid HR */
.pet-hr {
  grid-column: 1 / -1;
  margin: 8px 0px;
  border: 1px solid var(--line);
}

/* Vehicle grid HR */
.vehicle-hr {
  grid-column: 1 / -1;
  margin: 8px 0px;
  border: 1px solid var(--line);
}

/* Paper doll layout */
.paper-doll-container {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
  padding: 8px;
}

.paper-doll-hero {
  flex: 1;
  min-width: 160px;
}

.paper-doll-hero-title {
  text-align: center;
  font-size: 12px;
  color: #9baec8;
  margin-bottom: 4px;
}

.paper-doll-hero-display {
  width: 120px;
  height: 160px;
  border: 1px dashed var(--line);
  border-radius: 4px;
  margin: auto;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #3b4d71;
  background: rgba(255, 255, 255, 0.03);
}

.paper-doll-equipment {
  flex: 1;
  min-width: 160px;
}

.paper-doll-section-title {
  font-size: 12px;
  color: #9baec8;
  margin-bottom: 4px;
}

.paper-doll-slot {
  margin-bottom: 4px;
}

.paper-doll-pets-title {
  font-size: 12px;
  color: #9baec8;
  margin: 8px 0 4px;
}

.paper-doll-vehicle-title {
  font-size: 12px;
  color: #9baec8;
  margin: 8px 0 4px;
}

/* Quest content */
.quest-content {
  padding: 8px;
  opacity: 1;
}

.quest-header-title {
  margin: 0 0 8px;
  color: #e9f4ff;
}

.quest-timer {
  font-size: 11px;
  margin-left: 8px;
  color: #ffd56a;
}

.quest-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.quest-progress-fill {
  transform: scaleX(1);
}

.quest-reward-claimed {
  color: #36c777;
  margin-left: 4px;
}

.quest-footer {
  margin-top: 12px;
  padding-top: 8px;
  border-top: 1px solid rgba(123, 97, 255, 0.3);
}

.quest-footer-text {
  margin: 0;
  font-size: 11px;
  color: #9baec8;
}

.endless-stats {
  margin-top: 8px;
  display: none;
}

.endless-title {
  margin: 0 0 4px;
  color: #ffaa00;
}

.endless-score {
  margin: 0;
  font-size: 12px;
  color: #cfe3ff;
}

.endless-time {
  margin: 0;
  font-size: 12px;
  color: #cfe3ff;
}

/* Settings card */
.settings-card {
  background: rgba(255, 255, 255, 0.04);
  padding: 8px;
  border: 1px solid rgba(123, 97, 255, 0.2);
  border-radius: 6px;
}

.settings-title {
  margin: 0 0 6px;
  font-size: 14px;
}

.settings-label {
  display: block;
  margin-top: 6px;
}

.settings-qa-section {
  margin-top: 8px;
}

.settings-qa-button {
  padding: 6px 10px;
  border: 1px solid #3b4d71;
  background: #1a263a;
  color: #d7e9ff;
  border-radius: 6px;
  cursor: pointer;
}

.settings-qa-note {
  opacity: 0.7;
  margin-left: 8px;
}

.qa-tools-flex {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
}

.audio-volume-slider {
  width: 100%;
}

.hud-position-select {
  margin-left: 4px;
}

/* Shared gauge fill */
.shared-gauge-fill {
  transform: scaleX(1);
}

/* Action button styling */
.action-button-flex {
  display: flex;
  background-color: var(--pastel-pet);
}

/* Joystick nub positioning */
.nub-center {
  left: 50%;
  top: 50%;
}

/* Duration ring hidden */
.duration-ring-hidden {
  display: none;
}

/* Secret button styling */
.secret-button-ready {
  opacity: 1;
  pointer-events: auto;
}

/* Compact stats positioning */
.compact-stats {
  position: absolute;
  top: 8px;
  right: 8px;
  background: rgba(13, 19, 28, 0.85);
  border: 1px solid rgb(41, 56, 84);
  border-radius: 6px;
  padding: 3px 5px;
  font-size: 10px;
  color: rgb(168, 183, 206);
  width: 110px;
  box-shadow: rgba(0, 0, 0, 0.3) 0px 2px 4px;
  pointer-events: none;
  display: flex;
  flex-direction: column;
  gap: 2px;
  z-index: 100;
}

.compact-stats-row {
  display: flex;
  justify-content: space-between;
}

/* DOM sprites positioning */
.dom-sprites {
  position: absolute;
  left: 0;
  top: 0;
  right: 0;
  bottom: 0;
  pointer-events: none;
}

/* From index.html style #b4p-equip-inline-removed */

:root {
  --b4p-overlay: rgba(5, 10, 20, 0.65);
  --b4p-chrome: #0e1624;
  --b4p-line: #2a3b5c;
  --b4p-ink: #e6f2ff;
}

#b4p-equip-root[hidden] {
  display: none;
}

#b4p-equip-root {
  position: fixed;
  inset: 0;
  z-index: 9000;
}

#b4p-equip-root .b4p-overlay {
  position: absolute;
  inset: 0;
  background: var(--b4p-overlay);
}

#b4p-equip-root .b4p-window {
  position: absolute;
  display: flex;
  flex-direction: column;
  gap: 8px;
  background: var(--b4p-chrome);
  border: 1px solid var(--b4p-line);
  border-radius: 10px;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
  color: var(--b4p-ink);
  outline: none;
}

#b4p-equip-root[data-variant="window"] .b4p-window {
  inset: 24px;
}

#b4p-equip-root[data-variant="drawer"] .b4p-window {
  top: 0;
  right: 0;
  bottom: 0;
  width: min(720px, 92vw);
  border-radius: 8px 0 0 8px;
}

#b4p-equip-root .b4p-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 8px;
  padding: 8px 10px;
  border-bottom: 1px solid var(--b4p-line);
}

#b4p-equip-root .b4p-header h2 {
  margin: 0;
  font-size: 16px;
}

#b4p-equip-root .b4p-actions {
  display: inline-flex;
  gap: 6px;
}

#b4p-equip-root .b4p-actions button {
  background: #111b2b;
  border: 1px solid var(--b4p-line);
  color: var(--b4p-ink);
  border-radius: 8px;
  padding: 4px 8px;
  cursor: pointer;
  font-size: 12px;
}

#b4p-content {
  position: relative;
  flex: 1;
  min-height: 0;
  padding: 8px;
}

#b4p-iframe {
  width: 100%;
  height: 100%;
  border: 0;
  border-radius: 6px;
  background: #0b0d12;
}

/* Minimal gallery for QA */
#asset-gallery {
  position: fixed;
  bottom: 8px;
  left: 8px;
  right: 8px;
  max-height: 40vh;
  overflow: auto;
  background: rgba(10, 16, 26, 0.85);
  border: 1px solid var(--b4p-line);
  border-radius: 8px;
  padding: 8px;
  display: none;
  z-index: 9500;
}

#asset-gallery.open {
  display: block;
}

#asset-gallery .grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
  gap: 6px;
}

#asset-gallery figure {
  margin: 0;
  border: 1px solid var(--b4p-line);
  border-radius: 6px;
  padding: 4px;
  background: #0e1624;
  color: #cfe3ff;
  font-size: 10px;
  text-align: center;
}

#asset-gallery img {
  width: 100%;
  image-rendering: pixelated;
}

/* From index.html style #ui-fix-v5 */

/* Hide redundant top bars for cleaner RPG runner look */
#btnSwitchChar {
  display: none !important;
}

/* hide top bars in HUD (hp/mp/xp/boss) and shared gauge */
.hud .bar,
.shared-gauge {
  display: none !important;
}

/* Hide the entire HUD section with all stat bars */
/* show HUD so stage/wave are visible */
/* .hud { display: none !important; } */
/* Ensure team status wraps and spaces portraits to avoid overlap */
#teamStatus,
.hero-portrait {
  display: none !important;
}

#bag-stats,
.bag-nav-item[data-tab="stats"] {
  display: none !important;
}

#bag-paper,
.bag-nav-item[data-tab="paper"] {
  display: none !important;
}

/* Add spacing between dock buttons */
.subdock .btn {
  margin-right: 6px;
}

/* Position the new UI toggle button in the top dock */
#btnHideUITop {
  margin-left: 8px;
}

/* Hidden class for UI toggle */
.hidden {
  display: none !important;
}

/* From index.html style #skill-window-css */

/* Unified Skill Window Styles */
#skill-window-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.7);
  -webkit-backdrop-filter: blur(4px);
  backdrop-filter: blur(4px);
  z-index: 10000;
  display: none;
  align-items: center;
  justify-content: center;
}

#skill-window-card {
  width: min(1200px, 95vw);
  height: min(800px, 90vh);
  background: var(--panel);
  border: 1px solid var(--line);
  border-radius: 16px;
  display: flex;
  flex-direction: column;
  box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
}

.skill-window-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 12px 20px;
  border-bottom: 1px solid var(--line);
}

.skill-window-header h2 {
  margin: 0;
  color: var(--accent2);
}

.skill-window-stats {
  display: flex;
  gap: 20px;
}

#skill-window-close {
  background: none;
  border: none;
  font-size: 24px;
  color: var(--text-1);
  cursor: pointer;
}

.skill-window-body {
  flex: 1;
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 20px;
  padding: 20px;
  overflow: hidden;
}

.skill-window-left,
.skill-window-right {
  display: flex;
  flex-direction: column;
  gap: 15px;
}

.scroll-inventory-list {
  flex: 1;
  overflow-y: auto;
  background: rgba(0, 0, 0, 0.2);
  padding: 10px;
  border-radius: 8px;
}

.equipped-slots-grid {
  display: grid;
  grid-template-columns: repeat(3, 1fr) 0.5fr repeat(2, 1fr);
  gap: 12px;
  align-items: center;
}

.equipped-slots-grid .skillSlot[data-slot="weapon"] {
  grid-column: 5;
}

.equipped-slots-grid .skillSlot[data-slot="pet"] {
  grid-column: 6;
}

#drag-ghost {
  position: fixed;
  pointer-events: none;
  opacity: 0.7;
  z-index: 9999;
  transform: scale(1.1);
  transition: transform 0.1s;
  display: none;
}

.skillSlot.drag-over {
  border-color: var(--accent);
  background-color: rgba(123, 97, 255, 0.2);
  transform: scale(1.05);
}

.small-charge-bar {
  position: absolute;
  bottom: -10px;
  left: 10%;
  width: 80%;
  height: 4px;
  background: var(--panel2);
  border: 1px solid var(--line);
  border-radius: 2px;
  overflow: hidden;
}

.small-charge-bar-fill {
  width: 0%;
  height: 100%;
  background: var(--rage);
  transition: width 0.1s linear;
}

/* From index.html style #ui-fix-v6 */

/* Hide the stage and currency pills */
#currency {
  display: none !important;
}

/* Compact HUD for player stats */
#compact-hud {
  position: fixed;
  top: 10px;
  left: 10px;
  background-color: rgba(0, 0, 0, 0.5);
  color: white;
  padding: 5px;
  border-radius: 5px;
  font-family: sans-serif;
  font-size: 12px;
  z-index: 10001;
  /* Ensure it's on top */
}

/* From index.html style #hide-skill-buttons */

/* === Scroll-Only HUD Patch === */
#btnS1,
#btnS2,
#btnS3,
#btnS4,
#btnS5,
#btnSecret,
#btnShoot,
#btnShield,
#btnRage,
.skill-btn-overlay,
.actions-secondary .col:nth-child(2) {
  display: none !important;
}

/* keep Jump/Shield/Vehicle smalls if present */

/* From index.html style #scrollOverlayCSS */

/* ===== Team Scrolls Overlay ===== */
.scroll-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.55);
  -webkit-backdrop-filter: blur(2px);
  backdrop-filter: blur(2px);
  display: none;
  z-index: 9999;
}

.scroll-overlay.show {
  display: block;
}

.overlay-card {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  width: min(1100px, 92vw);
  height: min(86vh, 820px);
  background: #0e1421;
  border: 1px solid #283852;
  border-radius: 14px;
  display: flex;
  flex-direction: column;
  box-shadow: 0 24px 60px rgba(0, 0, 0, 0.45);
}

.overlay-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 12px;
  border-bottom: 1px solid #26334b;
  background: linear-gradient(160deg, #101828, #0e1220);
}

.overlay-header .title {
  color: #8db4ff;
  font-weight: 800;
}

.overlay-header .stats {
  display: flex;
  gap: 16px;
  color: #dfe9ff;
  opacity: 0.9;
  font-size: 13px;
}

.overlay-close {
  border: 0;
  background: #1b2740;
  color: #e9f4ff;
  border-radius: 10px;
  width: 32px;
  height: 32px;
  cursor: pointer;
}

.overlay-body {
  flex: 1;
  display: grid;
  grid-template-columns: 1.1fr 0.9fr;
  gap: 10px;
  padding: 10px;
}

.left,
.right {
  min-width: 0;
}

.section {
  margin-bottom: 10px;
}

.section.two {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 10px;
}

.section-title {
  color: #ffd56a;
  margin: 6px 0 8px;
}

.panel {
  border: 1px dashed #2a3b5c;
  border-radius: 10px;
  padding: 8px;
  min-height: 80px;
  max-height: 220px;
  overflow: auto;
  background: rgba(255, 255, 255, 0.03);
}

.row {
  display: flex;
  gap: 8px;
  align-items: center;
  flex-wrap: wrap;
}

.btn {
  cursor: pointer;
  border: 1px solid #283852;
  border-radius: 10px;
  padding: 8px 10px;
  background: linear-gradient(145deg, #22324a, #152237);
  color: #dfe9ff;
  font-weight: 600;
}

.btn.primary {
  background: linear-gradient(145deg, #7b61ff, #2ea8ff);
  border: 0;
}

.btn.warn {
  background: linear-gradient(145deg, #7d532b, #4a2a18);
}

.small {
  font-size: 12px;
  opacity: 0.9;
}

/* Slots */
.hero-tabs {
  display: flex;
  gap: 8px;
  margin-bottom: 6px;
  flex-wrap: wrap;
}

.hero-tab {
  padding: 6px 10px;
  border: 1px solid #283852;
  border-radius: 999px;
  background: #0f1a2b;
  color: #dfe9ff;
  cursor: pointer;
  font-size: 12px;
}

.hero-tab.active {
  box-shadow: 0 0 0 1px #2ea8ff;
}

.slotbar {
  display: flex;
  gap: 8px;
  margin-bottom: 6px;
}

.ovSlot {
  width: 86px;
  min-height: 96px;
  border: 2px dashed #3f4e6d;
  border-radius: 14px;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  gap: 6px;
  padding: 8px 6px 10px;
  position: relative;
  background: rgba(255, 255, 255, 0.04);
  text-align: center;
}

.ovSlot.assigned {
  border-style: solid;
  border-color: #8aa7ff;
  background: linear-gradient(
    160deg,
    rgba(123, 97, 255, 0.18),
    rgba(46, 168, 255, 0.18)
  );
}

.ovSlot.ready {
  border-color: #ffd56a;
  box-shadow: 0 0 12px rgba(255, 213, 106, 0.35);
}

.ovSlot .lbl {
  position: absolute;
  top: -15px;
  left: 4px;
  font-size: 11px;
  opacity: 0.8;
  color: #dfe9ff;
}

.ovSlot .ico {
  width: 44px;
  height: 44px;
  border-radius: 12px;
  background: #1f2c44;
  border: 1px solid #283852;
  display: flex;
  align-items: center;
  justify-content: center;
  font-weight: 600;
  letter-spacing: 0.5px;
}

.ovSlot.ready .ico {
  border-color: #ffd56a;
  box-shadow: 0 0 8px rgba(255, 213, 106, 0.4);
}

.ovSlot .name {
  font-size: 12px;
  font-weight: 600;
  line-height: 1.25;
  min-height: 30px;
  color: #dfe9ff;
}

.ovSlot.empty .name {
  color: #7c8ba9;
  font-weight: 500;
}

.ovSlot .detail {
  font-size: 10px;
  color: #9eb0d6;
  min-height: 14px;
}

.ovSlot .small-charge-bar {
  width: 100%;
  margin-top: 2px;
}

.ovSlot:not(.has-charge) .small-charge-bar {
  display: none;
}

.legend {
  opacity: 0.8;
}

/* Picker items */
.pick-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 10px;
  padding: 8px;
  margin: 5px 0;
  background: rgba(255, 255, 255, 0.04);
  border: 1px solid #283852;
  border-radius: 10px;
}

.pick-row .left {
  display: flex;
  align-items: center;
  gap: 10px;
}

.icon {
  width: 28px;
  height: 28px;
  border-radius: 8px;
  background: #2a384f;
  display: flex;
  align-items: center;
  justify-content: center;
}

.tags {
  font-size: 11px;
  opacity: 0.8;
}

.count {
  opacity: 0.85;
}

/* Toast */
.ov-toast {
  position: fixed;
  left: 50%;
  top: 16px;
  transform: translateX(-50%);
  background: rgba(13, 20, 32, 0.98);
  border-left: 4px solid #7b61ff;
  color: #e9f4ff;
  padding: 10px 12px;
  border-radius: 10px;
  z-index: 10000;
}

/* From index.html style #cleanup-bottom-panels */

/* Hide the hero stats bars at the bottom */
#heroHud {
  display: none !important;
}

/* Hide the self-test panel on the bottom-right */
#selfTests {
  display: none !important;
}

/* Hide the debug checkbox panel on the bottom-left */
#debugHud {
  display: none !important;
}

/* From index.html style #hide-old-buttons */

/* Hide the entire old action buttons wrapper and its contents */
.action-buttons-wrapper,
.action-buttons-wrapper .actions,
.action-buttons-wrapper .actions-secondary {
  display: none !important;
}

/* Hide individual old buttons to ensure no duplicates appear */
#btnShoot,
#btnJump,
#btnRage,
#btnShield,
#btnS1,
#btnS2,
#btnS3,
#btnS4,
#btnS5,
#btnSecret {
  display: none !important;
}

/* From index.html style #new-button-styles */

.rightDock {
  display: flex;
  flex-direction: column;
  gap: 6px;
  align-items: flex-end;
}

.rightDock .row,
.rightDock .sRow {
  display: flex;
  gap: 6px;
  align-items: center;
}

.rightDock .mainRow {
  display: flex;
  gap: 6px;
}

.rightDock .col {
  display: flex;
  flex-direction: column;
  gap: 6px;
  align-items: center;
}

.btn.pixel {
  font-family: "Press Start 2P", cursive;
  image-rendering: pixelated;
  border: 4px solid #000;
  background: rgba(42, 36, 54, 0.7);
  color: #dfe9ff;
}

.btn.pixel.main {
  width: 96px;
  height: 96px;
  font-weight: 800;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
}

.btn.pixel.small {
  padding: 5px 8px;
  font-size: 10px;
}

.btn.pixel.tiny {
  padding: 4px;
  font-size: 14px;
}

.btn.pixel.border-ink {
  border-color: #ffc800;
}

.btn.pixel .btn-label {
  font-size: 12px;
}

/* From index.html style block 12 */

/* Fullscreen overlay for the Scroll System.  Covers the entire game without pausing it. */
.scrolls-win {
  position: fixed;
  inset: 0;
  display: none;
  z-index: 12000;
  background: transparent;
}

.scrolls-win.show {
  display: block;
}

#scrollsFrameBig {
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translate(-50%, -50%);
  width: min(1120px, 95vw);
  height: min(88vh, 860px);
  border: 0;
  box-shadow: none;
  background: transparent;
}

#scrollsCloseBtn {
  position: absolute;
  right: max(2vw, 16px);
  top: max(2vh, 12px);
  border: 0;
  background: #000;
  color: #fff;
  font: 700 14px/1 system-ui;
  width: 28px;
  height: 28px;
  cursor: pointer;
  /* Elevate the close button above the iframe so it remains clickable */
  z-index: 12010;
  pointer-events: auto;
}

/* From index.html style block 13 */

/* Preloader */
#apxPre {
  position: fixed;
  inset: 0;
  background: #0a0f18;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 99999;
}

#apxPre h1 {
  margin: 0 0 10px;
  font: 600 14px/1.2 system-ui;
  color: #cfe3ff;
  letter-spacing: 0.6px;
}

#apxPre .bar {
  width: 60%;
  max-width: 520px;
  height: 8px;
  border-radius: 999px;
  background: #111b22;
  border: 1px solid #293854;
  overflow: hidden;
}

#apxPre .fill {
  height: 100%;
  transform-origin: left center;
  background: linear-gradient(90deg, #2ea8ff, #7b61ff);
  transform: scaleX(0.2);
}

/* Floating interact prompt */
#apxInteract {
  position: fixed;
  left: 50%;
  bottom: 120px;
  transform: translateX(-50%);
  background: #0f1826;
  border: 1px solid #293854;
  border-radius: 8px;
  padding: 6px 10px;
  color: #cfe3ff;
  font: 600 12px system-ui;
  display: none;
  z-index: 9000;
}

#apxInteract small {
  color: #8ea5c4;
  font-weight: 500;
  margin-left: 6px;
}

/* QA overlay */
#apxQA {
  position: fixed;
  right: 12px;
  top: 12px;
  width: 310px;
  max-height: 70vh;
  overflow: auto;
  background: #0f1826;
  border: 1px solid #293854;
  border-radius: 8px;
  box-shadow: 0 8px 28px rgba(0, 0, 0, 0.45);
  z-index: 100000;
  display: none;
}

#apxQA header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 10px;
  border-bottom: 1px solid #293854;
  color: #e9f4ff;
  font: 600 12px system-ui;
}

#apxQA .b {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  padding: 10px;
}

#apxQA button {
  background: #1a263a;
  color: #d7e9ff;
  border: 1px solid #3b4d71;
  border-radius: 6px;
  padding: 6px 8px;
  font: 600 11px system-ui;
  cursor: pointer;
}

#apxQA pre {
  background: #0b1421;
  color: #9fb7d8;
  border-top: 1px solid #293854;
  margin: 0;
  padding: 8px;
  max-height: 160px;
  overflow: auto;
  font: 11px/1.4 ui-monospace, Menlo, Consolas, "Liberation Mono";
}

/* Pet/Vehicle barlet + HUD add‑ons */
.apx-barlet {
  position: absolute;
  transform: translate(-50%, -100%);
  width: 32px;
  height: 4px;
  background: #15243a;
  border: 1px solid #293854;
  border-radius: 3px;
  overflow: hidden;
}

.apx-barlet > i {
  display: block;
  height: 100%;
  background: linear-gradient(90deg, #36c777, #6de38e);
  transform-origin: left center;
}

#petReady {
  position: fixed;
  left: 14px;
  bottom: 160px;
  background: #0f1826;
  border: 1px solid #293854;
  border-radius: 8px;
  padding: 4px 8px;
  color: #cfe3ff;
  font: 600 11px system-ui;
  opacity: 0.85;
  display: none;
  z-index: 9000;
}

#vehFuelWrap {
  position: fixed;
  right: 14px;
  bottom: 160px;
  background: #0f1826;
  border: 1px solid #293854;
  border-radius: 8px;
  padding: 6px 8px;
  color: #cfe3ff;
  font: 600 11px system-ui;
  display: none;
  z-index: 9000;
}

#vehFuelWrap .bar {
  width: 160px;
  height: 8px;
  border-radius: 999px;
  background: #111b22;
  border: 1px solid #293854;
  overflow: hidden;
}

#vehFuelWrap {
  display: none !important;
}

#vehFuelWrap .bar .fill {
  height: 100%;
  background: linear-gradient(90deg, #ffaa00, #ff6aa8);
  transform-origin: left center;
}

/* Alchemy: larger slots + drag affordance */
#alchemy-panel .alchemy-slots .slot-box {
  width: 72px;
  height: 72px;
  font-size: 12px;
}

[draggable="true"] {
  cursor: grab;
}

/* From index.html style block 14 */

/* QA Lite & Overlays */
#qaLite {
  position: fixed;
  right: 12px;
  top: 12px;
  width: 280px;
  max-height: 70vh;
  overflow: auto;
  background: #0f1826;
  border: 1px solid #293854;
  border-radius: 8px;
  box-shadow: 0 8px 28px rgba(0, 0, 0, 0.45);
  z-index: 100000;
  display: none;
}

#qaLite header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 10px;
  border-bottom: 1px solid #293854;
  color: #e9f4ff;
  font: 600 12px system-ui;
}

#qaLite .b {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  padding: 10px;
}

#qaLite button {
  background: #1a263a;
  color: #d7e9ff;
  border: 1px solid #3b4d71;
  border-radius: 6px;
  padding: 6px 8px;
  font: 600 11px system-ui;
  cursor: pointer;
}

#countdownPane {
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.55);
  z-index: 90000;
  color: #e9f4ff;
  font: 700 48px/1.1 system-ui;
  text-shadow: 0 2px 10px #000;
}

#gameOverPane {
  position: fixed;
  inset: 0;
  display: none;
  align-items: center;
  justify-content: center;
  background: rgba(0, 0, 0, 0.7);
  z-index: 95000;
}

#gameOverPane .card {
  background: #0f1826;
  border: 1px solid #293854;
  border-radius: 10px;
  padding: 16px;
  min-width: 320px;
  color: #cfe3ff;
}

#gameOverPane .row {
  display: flex;
  gap: 8px;
  justify-content: flex-end;
  margin-top: 10px;
}

#gameOverPane h3 {
  margin: 0 0 6px;
}

#goMsg {
  font-size: 12px;
  color: #9baec8;
}

.hidden {
  display: none !important;
}

#countdownPane.show {
  display: flex !important;
}

/* From index.html style #skill-btn-style */

/* Prevent hero bars from overlapping by allowing wrap and adding margin */
.team-status {
  flex-wrap: wrap;
}

.hero-portrait {
  margin-right: 8px;
}

/* Style for skill buttons that appear over non-leader heroes */
.skill-btn {
  position: absolute;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: #1a263a;
  color: #d7e9ff;
  font-size: 10px;
  font-weight: 600;
  display: flex;
  align-items: center;
  justify-content: center;
  border: 1px solid #3b4d71;
  pointer-events: auto;
  cursor: pointer;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  user-select: none;
}

.skill-btn:hover {
  background: #2e3a52;
}

.skill-btn-1 {
  transform: translate(315.876px, 656.208px);
}

.skill-btn-2 {
  transform: translate(359.39px, 688.971px);
}

.skill-btn-3 {
  transform: translate(741.304px, 287.065px);
}

.skill-btn-4 {
  transform: translate(502.032px, 690.748px);
}

/* From index.html style #test-overrides */

#currency {
  display: flex !important;
}

/* From index.html style #final-hide-old-buttons */

/* Fully hide the legacy round buttons and their wrappers to prevent duplicate controls */
.action-buttons-wrapper,
                  .action-buttons-wrapper .actions,
                  .action-buttons-wrapper .actions-secondary,
                  #btnShoot,
                  #btnJump,
                  #btnRage,
                  #btnShield,
                  #btnS1,
                  #btnS2,
                  #btnS3,
                  #btnS4,
                  #btnS5,
                  #btnSecret,
                  #btnAttack,
                  /* Hide any legacy round attack button that uses the big style */
                  .action-buttons-wrapper .btn-round.big,
                  .btn-round.big#btnShoot,
                  .btn-round.big#btnAttack {
  display: none !important;
}

/* Hide the tiny X button that appears next to the rage button; the scroll button toggles the
   scroll overlay and the ESC key also closes it, so this extra close control is redundant. */
#hudBtnCloseScrolls {
  display: none !important;
}

/* Companion HUD positioning */
#companionHUD {
  position: absolute;
  bottom: 140px;
  left: 16px;
  display: flex;
  flex-direction: column;
  gap: 6px;
  z-index: 100;
}

/* Alchemy Panel positioning */
#alchemy-panel {
  display: none;
  z-index: 2100;
}

/* QA Overlay (Candy Dungeon) */
#apxQA {
  display: none;
  position: fixed;
  right: 12px;
  top: 12px;
  width: 310px;
  max-height: 70vh;
  overflow: auto;
  background: #0f1826;
  border: 1px solid #293854;
  border-radius: 8px;
  box-shadow: 0 8px 28px rgba(0, 0, 0, 0.45);
  z-index: 100000;
}

#apxQA header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 8px 10px;
  border-bottom: 1px solid #293854;
  color: #e9f4ff;
  font: 600 12px system-ui;
}

#apxQAClose {
  padding: 4px 8px;
}

#apxQA .b {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  padding: 10px;
}

 
 
/* ========================================
   INLINE STYLES MOVED TO EXTERNAL CSS
   ======================================== */

/* Stat icon gradients */
.stat-icon-blue { background: linear-gradient(135deg, #74b9ff, #0984e3); }
.stat-icon-green { background: linear-gradient(135deg, #55efc4, #00b894); }
.stat-icon-pink { background: linear-gradient(135deg, #ff85d8, #a855f7); }

/* Dialog styles */
.enter-dialog { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0, 0, 0, 0.45); z-index: 12000; }
.enter-dialog-box { background: #0b1220; border: 1px solid #9fd7ff; border-radius: 10px; padding: 12px 14px; min-width: 240px; box-shadow: 0 10px 24px rgba(0, 0, 0, 0.55); text-align: center; color: #cde7ff; font: 14px ui-monospace, monospace; }
.enter-dialog-title { margin-bottom: 10px; font-weight: 700; }
.enter-dialog-buttons { display: flex; gap: 10px; justify-content: center; }
.enter-dialog-btn-yes { padding: 6px 12px; border: 1px solid #36c777; background: #10281f; color: #a6ffcf; border-radius: 6px; cursor: pointer; }
.enter-dialog-btn-no { padding: 6px 12px; border: 1px solid #ff6aa8; background: #2a1420; color: #ffb6c1; border-radius: 6px; cursor: pointer; }

/* Quest styles */
.quest-placeholder { margin: 0; color: #9baec8; text-align: center; }
.quest-claim-btn { margin-left: 6px; padding: 2px 6px; font-size: 11px; border: none; border-radius: 4px; cursor: pointer; background: #2EA8FF; color: #fff; }
.quest-claimed-badge, .quest-completed-badge { color: #36c777; margin-left: 4px; }

/* Taming dialog */
.taming-dialog { position: fixed; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(0, 0, 0, 0.65); z-index: 15000; }
.taming-dialog-box { background: #0b1220; border: 2px solid #ffd56a; border-radius: 12px; padding: 20px 24px; min-width: 320px; box-shadow: 0 12px 32px rgba(0, 0, 0, 0.7); text-align: center; color: #cde7ff; font: 15px ui-monospace, monospace; }
.taming-boss-name { margin-bottom: 12px; font-weight: 700; font-size: 18px; color: #ffd56a; }
.taming-message { margin-bottom: 16px; color: #9fd7ff; }
.taming-count { margin-bottom: 16px; font-size: 13px; color: #7a9ab8; }
.taming-buttons { display: flex; gap: 12px; justify-content: center; }
.taming-btn-accept { padding: 10px 20px; border: 2px solid #36c777; background: #10281f; color: #a6ffcf; border-radius: 8px; cursor: pointer; font-weight: 700; font-size: 14px; }
.taming-btn-decline { padding: 10px 20px; border: 2px solid #ff6aa8; background: #2a1420; color: #ffb6c1; border-radius: 8px; cursor: pointer; font-weight: 700; font-size: 14px; }

/* Companion card tooltip */
.companion-card-tooltip { background: rgba(11, 18, 32, 0.85); border: 1px solid #ffd56a; border-radius: 6px; padding: 6px 8px; min-width: 140px; }
.companion-card-name { font-size: 11px; color: #ffd56a; margin-bottom: 3px; }
.companion-card-hp-row { display: flex; align-items: center; gap: 6px; }
.companion-card-hp-bar { flex: 1; height: 8px; background: #0d131c; border-radius: 4px; overflow: hidden; }
.companion-card-hp-fill { height: 100%; transition: width 0.2s; }
.companion-card-hp-text { font-size: 10px; color: #9fd7ff; }

/* Clone level label */
.clone-level-label { position: absolute; left: 0; right: 0; top: -18px; text-align: center; font: 600 10px ui-monospace; color: #b9e7ff; }

/* NPC offer card */
.npc-offer { border: 1px solid #2b3c55; border-radius: 8px; padding: 8px 10px; margin: 6px 0; background: #141c2c; }
.npc-offer-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; }
.npc-offer-price { opacity: 0.8; }
.npc-offer-buttons { display: flex; gap: 8px; justify-content: flex-end; }
.npc-offer-btn-gold { padding: 6px 10px; background: #1a2335; color: #e7f1ff; border: 1px solid #2b3c55; border-radius: 6px; cursor: pointer; }
.npc-offer-btn-ticket { padding: 6px 10px; background: #1a2335; color: #ffd56a; border: 1px solid #2b3c55; border-radius: 6px; cursor: pointer; }

/* Self-test panel */
.self-test-panel { position: fixed; right: 8px; bottom: 8px; background: rgba(11, 18, 32, 0.8); padding: 8px 10px; border-radius: 8px; border: 1px solid #1b2a46; font: 12px ui-monospace; color: #cde7ff; max-width: 420px; z-index: 99999; pointer-events: auto; }
.self-test-run-btn { margin-left: 8px; background: #14233a; color: #cde7ff; border: 1px solid #22314e; border-radius: 6px; padding: 2px 6px; cursor: pointer; }
.self-test-log { margin-top: 6px; }

/* Crafting panel */
.crafting-panel { position: fixed; inset: 0; background: rgba(0, 0, 0, 0.85); display: flex; align-items: center; justify-content: center; z-index: 99999; overflow: auto; }

</style>

  <!-- OFFLINE MODE: Inline fetch override (must be first) -->
  <script>
    // CRITICAL: This must run IMMEDIATELY before any other scripts
    (function () {
      'use strict';
      const isFileProtocol = window.location.protocol === 'file:';

      if (isFileProtocol) {
        const originalFetch = window.fetch;

        window.fetch = function (input, init) {
          const url = typeof input === 'string' ? input : input.url;

          // Intercept data/Json requests
          if (url && (url.includes('data/unified_manifests.json') || url.includes('data/Json/'))) {
            console.log('[Offline] Intercepting:', url);
            return Promise.resolve({
              ok: true,
              json: async () => ({}),
              text: async () => '{}',
              status: 200,
              statusText: 'OK'
            });
          }

          // Use original fetch with CORS error handling
          return originalFetch.apply(this, arguments).catch(err => {
            if (err.message && err.message.includes('CORS')) {
              console.warn('[Offline] CORS blocked:', url);
              return {
                ok: true,
                json: async () => ({}),
                text: async () => '{}',
                status: 200,
                statusText: 'OK'
              };
            }
            throw err;
          });
        };

        console.log('[Offline] Fetch override installed for file:// protocol');
      }
    })();
  </script>

  <!-- Load external offline data loader -->
  <!-- Inlined: src/assets/OfflineDataLoader.js -->
<script>
// Offline Data Loader - Embeds JSON data directly in window object for file:// protocol
(function() {
  'use strict';

  // Check if we're running on file:// protocol
  const isFileProtocol = window.location.protocol === 'file:';
  
  // Global data store
  window.OFFLINE_DATA = window.OFFLINE_DATA || {};
  
  /**
   * Initialize offline data - creates dummy/fallback data for offline mode
   */
  function initOfflineData() {
    if (!isFileProtocol) return; // Not needed for HTTP
    
    console.log('[Offline] Initializing offline data for file:// protocol...');
    
    // Create minimal fallback data structure
    window.OFFLINE_DATA.unified_manifests = {
      version: "2.0.0",
      description: "Offline fallback manifest",
      assets: {
        version: "1.0.0",
        categories: {},
        total_assets: 0
      },
      skills: {
        progressive_x_waves: {
          A1: { S1: 4, S3: 6 },
          UNIQUE: { S1: 4, S3: 6 },
          MISSY: { S1: 4, S3: 6 }
        }
      }
    };
    
    // Empty JSON data for missing files
    window.OFFLINE_DATA.parallax = {};
    window.OFFLINE_DATA.platform_colliders = {};
    window.OFFLINE_DATA.platform_layouts = {};
    window.OFFLINE_DATA.city_props = {};
    window.OFFLINE_DATA.manifest = {};
    window.OFFLINE_DATA.assets_manifest = {};
    window.OFFLINE_DATA.complete_manifest = {};
    
    console.log('[Offline] Offline data initialized');
  }
  
  /**
   * Override fetch to return embedded data for file:// protocol
   */
  function createFetchOverride() {
    if (!isFileProtocol) return; // Only override for file://
    
    const originalFetch = window.fetch;
    
    window.fetch = function(input, init) {
      const url = typeof input === 'string' ? input : input.url;
      
      // Check if this is a data/Json/* request
      if (url.includes('data/unified_manifests.json') || 
          url.includes('data/Json/')) {
        
        // Extract filename
        const filename = url.split('/').pop().replace('.json', '');
        
        // Return embedded data if available
        if (window.OFFLINE_DATA[filename]) {
          return Promise.resolve({
            ok: true,
            json: async () => window.OFFLINE_DATA[filename],
            text: async () => JSON.stringify(window.OFFLINE_DATA[filename])
          });
        }
        
        // Return empty object as fallback
        console.warn(`[Offline] No data for ${url}, using empty fallback`);
        return Promise.resolve({
          ok: true,
          json: async () => ({}),
          text: async () => '{}'
        });
      }
      
      // For non-data files, use original fetch but catch CORS errors
      return originalFetch.apply(this, arguments).catch(err => {
        if (err.message.includes('CORS') || err.name === 'TypeError') {
          console.warn(`[Offline] Fetch blocked for ${url}, using fallback`);
          return {
            ok: true,
            json: async () => ({}),
            text: async () => '{}'
          };
        }
        throw err;
      });
    };
  }
  
  // Initialize on load
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      initOfflineData();
      createFetchOverride();
    });
  } else {
    initOfflineData();
    createFetchOverride();
  }
  
  // Export to window
  window.initOfflineData = initOfflineData;
  
  console.log('✅ Offline Data Loader initialized');
  
})();

</script>

  <!-- Asset Loading System (Non-module - works offline) -->
  <!-- Inlined: src/assets/DataLoader.js -->
<script>
// Simple cached fetch with graceful fallback (Non-module version)
(function() {
  'use strict';
  
  async function tryFetchJson(url, { timeoutMs = 1500 } = {}) {
    try {
      const ctrl = new AbortController();
      const t = setTimeout(() => ctrl.abort(), timeoutMs);
      const res = await fetch(url, { signal: ctrl.signal });
      clearTimeout(t);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return await res.json();
    } catch (e) {
      const msg = (e && e.message) || String(e);
      if (msg.includes('HTTP 404')) {
        console.debug('[DataLoader] optional/missing', url);
      } else {
        console.warn('[DataLoader] fail', url, msg);
      }
      return null;
    }
  }

  async function tryFetchJsonList(base, names, opts) {
    for (const name of names) {
      const data = await tryFetchJson(`${base.replace(/\/$/, '')}/${name}`, opts);
      if (data) return { name, data };
    }
    return null;
  }

  function attachToWindow(key, val) {
    try { window[key] = val; } catch {}
  }
  
  // Expose to window
  window.DataLoader = {
    tryFetchJson,
    tryFetchJsonList,
    attachToWindow
  };
  
  // Also expose directly for backward compatibility
  window.tryFetchJson = tryFetchJson;
  window.tryFetchJsonList = tryFetchJsonList;
  window.attachToWindow = attachToWindow;
})();

</script>
  <!-- Inlined: src/assets/AssetRegistry.js -->
<script>
// A1K Asset Registry - Unified loading system for all manifests and assets (Non-module version)
(function() {
  'use strict';
  
  // Use DataLoader functions from window
  const tryFetchJsonList = window.tryFetchJsonList || function() { return null; };
  const attachToWindow = window.attachToWindow || function(k, v) { window[k] = v; };

class AssetRegistry {
  constructor() {
    this.manifests = new Map();
    this.assets = new Map();
    this.loaded = false;
  }

  async loadAllManifests() {
    if (this.loaded) return this.manifests;

    console.log("🔄 Loading A1K manifests...");

    // Load only manifests we ship in this build to avoid noisy 404s
    const manifestFiles = [
      { id: "manifest", file: "data/unified_manifests.json" },
    ];

    // Load each manifest
    for (const { id, file } of manifestFiles) {
      try {
        const response = await fetch(file);
        if (response.ok) {
          const data = await response.json();
          this.manifests.set(id, data);
          console.log(`✅ Loaded ${id}: ${file}`);
        } else {
          console.warn(`⚠️ Failed to load ${file}`);
        }
      } catch (error) {
        console.warn(`❌ Error loading ${file}:`, error);
      }
    }

    // Merge all manifests into a unified structure
    this.createUnifiedManifest();

    this.loaded = true;
    console.log("🎯 A1K Asset Registry loaded successfully");
    return this.manifests;
  }

  createUnifiedManifest() {
    const unified = {
      version: "1.0.0",
      name: "A1K Runner Unified Asset Pack",
      generated: new Date().toISOString(),
      categories: {
        characters: {},
        enemies: {},
        effects: {},
        ui: {},
        backgrounds: {},
        items: {},
        projectiles: {},
        pets: {},
        vehicles: {},
        equipment: {},
      },
      skills: {},
      game_mechanics: {},
      assets: {},
    };

    // Merge all manifests
    for (const [id, manifest] of this.manifests) {
      // Handle nested categories
      if (manifest.categories) {
        for (const [catName, catData] of Object.entries(manifest.categories)) {
          if (!unified.categories[catName]) {
            unified.categories[catName] = {};
          }
          Object.assign(unified.categories[catName], catData);
        }
      }

      // Handle direct asset types (from manifests without "categories" wrapper)
      if (manifest.assets) {
        // Check if assets has nested structure
        if (manifest.assets.pets)
          unified.categories.pets = {
            ...unified.categories.pets,
            ...manifest.assets.pets,
          };
        if (manifest.assets.vehicles)
          unified.categories.vehicles = {
            ...unified.categories.vehicles,
            ...manifest.assets.vehicles,
          };
        if (manifest.assets.equipment)
          unified.categories.equipment = {
            ...unified.categories.equipment,
            ...manifest.assets.equipment,
          };
        if (manifest.assets.characters)
          unified.categories.characters = {
            ...unified.categories.characters,
            ...manifest.assets.characters,
          };
        if (manifest.assets.enemies)
          unified.categories.enemies = {
            ...unified.categories.enemies,
            ...manifest.assets.enemies,
          };
        if (manifest.assets.effects)
          unified.categories.effects = {
            ...unified.categories.effects,
            ...manifest.assets.effects,
          };
        if (manifest.assets.ui)
          unified.categories.ui = {
            ...unified.categories.ui,
            ...manifest.assets.ui,
          };
        if (manifest.assets.backgrounds)
          unified.categories.backgrounds = {
            ...unified.categories.backgrounds,
            ...manifest.assets.backgrounds,
          };
        if (manifest.assets.items)
          unified.categories.items = {
            ...unified.categories.items,
            ...manifest.assets.items,
          };
        if (manifest.assets.projectiles)
          unified.categories.projectiles = {
            ...unified.categories.projectiles,
            ...manifest.assets.projectiles,
          };

        // Otherwise treat as general assets
        unified.assets = { ...unified.assets, ...manifest.assets };
      }

      // Direct top-level types
      if (manifest.characters)
        unified.categories.characters = {
          ...unified.categories.characters,
          ...manifest.characters,
        };
      if (manifest.enemies)
        unified.categories.enemies = {
          ...unified.categories.enemies,
          ...manifest.enemies,
        };
      if (manifest.items)
        unified.categories.items = {
          ...unified.categories.items,
          ...manifest.items,
        };
      if (manifest.effects)
        unified.categories.effects = {
          ...unified.categories.effects,
          ...manifest.effects,
        };
      if (manifest.ui)
        unified.categories.ui = { ...unified.categories.ui, ...manifest.ui };
      if (manifest.projectiles)
        unified.categories.projectiles = {
          ...unified.categories.projectiles,
          ...manifest.projectiles,
        };
      if (manifest.backgrounds)
        unified.categories.backgrounds = {
          ...unified.categories.backgrounds,
          ...manifest.backgrounds,
        };
      if (manifest.pets)
        unified.categories.pets = {
          ...unified.categories.pets,
          ...manifest.pets,
        };
      if (manifest.vehicles)
        unified.categories.vehicles = {
          ...unified.categories.vehicles,
          ...manifest.vehicles,
        };
      if (manifest.equipment)
        unified.categories.equipment = {
          ...unified.categories.equipment,
          ...manifest.equipment,
        };

      // Skills and game mechanics
      if (manifest.skills)
        unified.skills = { ...unified.skills, ...manifest.skills };
      if (manifest.game_mechanics)
        unified.game_mechanics = {
          ...unified.game_mechanics,
          ...manifest.game_mechanics,
        };

      // Sprites and animations
      if (manifest.sprites)
        unified.sprites = { ...unified.sprites, ...manifest.sprites };
      if (manifest.animations)
        unified.animations = { ...unified.animations, ...manifest.animations };
    }

    this.manifests.set("unified", unified);

    // Store in window for global access
    window.A1K_ASSETS = unified;
    window.ASSETS = unified; // Legacy support
    window.GAME_ASSETS = unified; // Additional legacy support

    console.log(
      "📦 Unified manifest created with categories:",
      Object.keys(unified.categories)
    );
    console.log("📦 Category counts:", {
      characters: Object.keys(unified.categories.characters).length,
      enemies: Object.keys(unified.categories.enemies).length,
      effects: Object.keys(unified.categories.effects).length,
      pets: Object.keys(unified.categories.pets).length,
      vehicles: Object.keys(unified.categories.vehicles).length,
      equipment: Object.keys(unified.categories.equipment).length,
    });

    return unified;
  }

  getManifest(id) {
    return this.manifests.get(id);
  }

  getUnifiedManifest() {
    return this.manifests.get("unified");
  }

  async preloadImages(manifest) {
    const images = [];
    const loadPromises = [];

    // Extract all image paths from manifest
    this.extractImagePaths(manifest).forEach((path) => {
      loadPromises.push(this.loadImage(path));
    });

    try {
      const results = await Promise.allSettled(loadPromises);
      const loaded = results.filter((r) => r.status === "fulfilled").length;
      console.log(`🖼️ Preloaded ${loaded}/${loadPromises.length} images`);
      return loaded;
    } catch (error) {
      console.error("❌ Image preload failed:", error);
      return 0;
    }
  }

  extractImagePaths(obj, paths = []) {
    if (typeof obj === "string" && /\.(png|jpg|jpeg|gif|webp)$/i.test(obj)) {
      paths.push(obj);
    } else if (typeof obj === "object" && obj !== null) {
      for (const value of Object.values(obj)) {
        this.extractImagePaths(value, paths);
      }
    }
    return paths;
  }

  async loadImage(src) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve({ src, img });
      img.onerror = () => reject(new Error(`Failed to load: ${src}`));
      img.src = src;
    });
  }

  getAsset(type, name) {
    const unified = this.getUnifiedManifest();
    return unified?.[type]?.[name] || unified?.assets?.[name];
  }

  getCharacterData(name) {
    const unified = this.getUnifiedManifest();
    return unified?.characters?.[name];
  }

  getEnemyData(name) {
    const unified = this.getUnifiedManifest();
    return unified?.enemies?.[name];
  }

  getItemData(name) {
    const unified = this.getUnifiedManifest();
    return unified?.items?.[name];
  }
}

// Probe known manifest filenames under data/Json (legacy support)
const CANDIDATES = [
  "asset_manifest.json",
  "assets_manifest.json",
  "comprehensive_asset_manifest.json",
  "master_manifest.json",
  "asset_index.json",
];

async function pickManifestPath(base = "data/Json") {
  const hit = await tryFetchJsonList(base, CANDIDATES);
  if (hit) {
    attachToWindow("AssetManifest", hit.data);
    console.log("[AssetRegistry] manifest", hit.name);
  } else {
    console.log("[AssetRegistry] no manifest found (fallbacks active)");
  }
  return hit?.data || null;
}

// Global instance
const assetRegistry = new AssetRegistry();

// Expose to window
window.AssetRegistry = AssetRegistry;
window.assetRegistry = assetRegistry;
window.pickManifestPath = pickManifestPath;

// Expose instance for non-module inline scripts
try { attachToWindow("assetRegistry", assetRegistry); } catch {}

})();

</script>
  <!-- Inlined: src/utils/Integrations.js -->
<script>
// Integrations.js - Non-module version
(function() {
  'use strict';
  
  // Use functions from window (loaded by DataLoader and AssetRegistry)
  const tryFetchJson = window.tryFetchJson || function() { return null; };
  const tryFetchJsonList = window.tryFetchJsonList || function() { return null; };
  const attachToWindow = window.attachToWindow || function(k, v) { window[k] = v; };
  const getAssetRegistry = () => window.assetRegistry;

async function loadOptionalData() {
  const assetRegistry = getAssetRegistry();
  // Initialize A1K Asset Registry (loads all manifests)
  if (assetRegistry) {
    await assetRegistry.loadAllManifests();
  }

  // Parallax layers (visual only)
  const px = await tryFetchJson("data/Json/parallax.json");
  if (px) {
    attachToWindow("ParallaxData", px);
    console.log("[Integrations] parallax loaded");
  }

  // Platform colliders / layouts
  const colliders = await tryFetchJson("data/Json/platform_colliders.json");
  if (colliders) {
    attachToWindow("PlatformColliders", colliders);
    console.log("[Integrations] platform_colliders loaded");
  }
  const layouts = await tryFetchJson("data/Json/platform_layouts.json");
  if (layouts) {
    attachToWindow("PlatformLayouts", layouts);
    console.log("[Integrations] platform_layouts loaded");
  }

  // City props (lamps, benches, trees)
  const propsHit = await tryFetchJson("data/Json/city_props.json");
  if (propsHit) {
    attachToWindow("CityProps", propsHit);
    console.log("[Integrations] city_props loaded");
  }

  // Optional: load additional data files if they exist
  const optionalFiles = [
    "data/Json/manifest.json",
    "data/Json/assets_manifest.json",
    "data/Json/complete_manifest.json",
  ];

  for (const file of optionalFiles) {
    try {
      const response = await fetch(file);
      if (response.ok) {
        const data = await response.json();
        console.log(`Loaded optional data: ${file}`);
        // Store in window for access
        const key = file.split("/").pop().replace(".json", "").toUpperCase();
        window[`OPTIONAL_${key}`] = data;
      }
    } catch (e) {
      // Optional files, ignore errors
    }
  }
}

// Bootstrap helper
async function bootData() {
  try {
    await loadOptionalData();
    console.log("🎯 A1K Integrations booted successfully");
  } catch (e) {
    console.warn("[Integrations] bootData error", e);
  }
}

// Expose to window
window.Integrations = {
  loadOptionalData,
  bootData
};
window.bootData = bootData;
window.loadOptionalData = loadOptionalData;

})();

</script>

  <!-- Progression System -->
  <!-- Inlined: src/gameplay/progression_v95.js -->
<script>
/* ===== Progression v9.5 (waves) + Stage(.5) + Area(.5) ===== */
(function () {
  if (window.__PROG95__) return;
  window.__PROG95__ = true;

  // --- Config
  const PROG = {
    WAVES_MAIN: 9, // 1..9
    STEPS_PER_STAGE: 18, // 1..18 (odd=main wave N; even=half wave N.5)
    STAGES_PER_AREA: 2, // Stage 1 / 1.5 then Stage 2 / 2.5
    AREAS_MAX: 100,
  };

  // --- State will be extended from index.html after st is defined
  // We'll add: area, areaHalf, stageInArea, stageHalf, waveStep, loop

  // --- Helper Functions
  function isHalfStep(step) {
    step = step !== undefined ? step : window.st ? window.st.waveStep : 1;
    return step % 2 === 0;
  }

  function baseWave(step) {
    step = step !== undefined ? step : window.st ? window.st.waveStep : 1;
    return Math.ceil(step / 2); // 1..9
  }

  function waveLabel(step) {
    step = step !== undefined ? step : window.st ? window.st.waveStep : 1;
    const n = baseWave(step);
    return isHalfStep(step) ? `${n}.5` : String(n);
  }

  function stageLabel() {
    if (!window.st) return "Stage 1";
    return `Stage ${window.st.stageInArea || 1}${
      window.st.stageHalf ? ".5" : ""
    }`;
  }

  function areaLabel() {
    if (!window.st) return "Area 1";
    return `Area ${window.st.area || 1}${window.st.areaHalf ? ".5" : ""}`;
  }

  // --- Difficulty Calculation
  function getDifficultyMultiplier() {
    if (!window.st) return 1;

    const areaMul =
      1 +
      (window.st.area - 1) * 0.08 +
      (window.st.areaHalf ? 0.04 : 0) +
      window.st.loop * 0.25;
    const stageMul =
      1 + (window.st.stageInArea - 1) * 0.12 + (window.st.stageHalf ? 0.06 : 0);
    // Wave-based HP growth is now handled directly in the spawner baseline.
    const waveMul = 1;
    const halfMul = isHalfStep() ? (0.75 + baseWave() * 0.03) : 1.0;

    return areaMul * stageMul * waveMul * halfMul;
  }

  // --- Progression State Machine
  function advanceProgression() {
    if (!window.st) return;

    const st = window.st;

    // Step forward (1..18 => odd main, even half)
    if (st.waveStep < PROG.STEPS_PER_STAGE) {
      st.waveStep += 1;
      st.wave = baseWave(st.waveStep); // compatibility for spawners
    } else {
      // Finished Wave 9.5 (boss) => Stage complete
      st.waveStep = 1;
      st.wave = 1;

      if (!st.stageHalf) {
        // Enter Stage N.5 (repeat full wave cycle)
        st.stageHalf = true;
      } else {
        // Stage N.5 finished -> next Stage
        st.stageHalf = false;
        st.stageInArea += 1;

        if (st.stageInArea > PROG.STAGES_PER_AREA) {
          // Stage set done -> Area step
          st.stageInArea = 1;

          if (!st.areaHalf) {
            // Area K.5 (repeat 2-stage set)
            st.areaHalf = true;
          } else {
            // Area K.5 complete -> next Area
            st.areaHalf = false;
            st.area += 1;
            if (st.area > PROG.AREAS_MAX) {
              st.area = 1;
              st.loop += 1;
            }
          }
        }
      }

      // On new Stage/Area: re-roll special wave picks & timers
      st.waveLeaderWave = 2 + Math.floor(Math.random() * 8);
      st.treasureWave = 3 + Math.floor(Math.random() * 7);
      st.supplyPlaneWave = 2 + Math.floor(Math.random() * 8);
      st.stageLongToyActive = false;
      st.stageStartTime = performance.now?.() || Date.now();
      st.specialWave = false;

      // Call checkTimeTrials if it exists
      if (typeof window.checkTimeTrials === "function") {
        window.checkTimeTrials();
      }
    }
  }

  // Expose API
  window.__PROG95 = {
    PROG,
    isHalfStep,
    baseWave,
    waveLabel,
    stageLabel,
    areaLabel,
    getDifficultyMultiplier,
    advanceProgression,
  };

  console.log("✅ Progression v9.5 Module Loaded");
})();

</script>

  <!-- Boss Pool System -->
  <!-- Inlined: src/gameplay/boss-pools.js -->
<script>
(function () {
  const R = () => Math.random();

  /* ------------------------ Boss Pools ------------------------ */
  const BOSS_POOLS = {
    gift: [
      {
        name: "Gift Bearer",
        sprite: "pickup_chest.png",
        hpMul: 2.2,
        atkMul: 1.1,
        defMul: 1.0,
        giftDrop: true,
        pool: "gift",
      },
      {
        name: "Treasure Phantom",
        sprite: "enemy_flyer.png",
        hpMul: 2.4,
        atkMul: 1.2,
        defMul: 0.95,
        giftDrop: true,
        pool: "gift",
      },
    ],
    armor: [
      {
        name: "Plate Warden",
        sprite: "enemy_bulwark.png",
        hpMul: 3.2,
        atkMul: 0.9,
        defMul: 2.2,
        armorDrop: true,
        pool: "armor",
      },
    ],
    pet: [
      {
        name: "Menagerie Alpha",
        sprite: "pet_firecub.png",
        hpMul: 2.4,
        atkMul: 1.1,
        defMul: 1.0,
        petDrop: "FireCub",
        pool: "pet",
      },
    ],
    key: [
      {
        name: "Key Warden",
        sprite: "enemy_boss.png",
        hpMul: 3.2,
        atkMul: 1.1,
        defMul: 1.2,
        dropsKey: true,
        pool: "key",
      },
    ],
    gold: [
      {
        name: "Gilded Serpent",
        sprite: "enemy_boss.png",
        hpMul: 2.4,
        atkMul: 1.1,
        defMul: 1.0,
        goldMul: 8,
        pool: "gold",
      },
      {
        name: "Gold Knight",
        sprite: "Boss.png",
        hpMul: 2.6,
        atkMul: 1.0,
        defMul: 1.2,
        goldMul: 6,
        pool: "gold",
      },
    ],
    silver: [
      {
        name: "Silver Phantom",
        sprite: "enemy_flyer.png",
        hpMul: 1.9,
        atkMul: 1.3,
        defMul: 0.8,
        silverMul: 15,
        pool: "silver",
      },
    ],
    miniBoss: [
      {
        name: "Champion Orc",
        sprite: "enemy_miniboss.png",
        hpMul: 3.0,
        atkMul: 1.4,
        defMul: 1.3,
        pool: "miniBoss",
      },
    ],
    bigBoss: [
      {
        name: "Demon King",
        sprite: "boss_slime_king.png",
        hpMul: 6.0,
        atkMul: 2.0,
        defMul: 2.5,
        pool: "bigBoss",
      },
      {
        name: "Leviathan",
        sprite: "mob_boss.png",
        hpMul: 5.6,
        atkMul: 2.2,
        defMul: 2.0,
        pool: "bigBoss",
      },
      {
        name: "Archangel",
        sprite: "enemy_boss.png",
        hpMul: 5.0,
        atkMul: 2.5,
        defMul: 1.9,
        pool: "bigBoss",
      },
      {
        name: "Void Reaver",
        sprite: "Boss.png",
        hpMul: 6.4,
        atkMul: 2.3,
        defMul: 2.2,
        pool: "bigBoss",
      },
    ],
  };

  const AFFIXES = [
    { id: "vampiric", hpMul: 1.2, atkMul: 1.1 },
    { id: "armored", defMul: 1.35 },
    { id: "swift", atkMul: 1.2 },
    { id: "storm", atkMul: 1.15 },
    { id: "arcane", hpMul: 1.1, atkMul: 1.1 },
    { id: "unyielding", defMul: 1.4 },
  ];

  const WAVE_BOSS_CONFIGS = {
    1: { pools: ["armor", "gold", "silver", "pet", "gift"], count: [2, 3] },
    2: { pools: ["gold", "key", "gift"], count: [2, 3] },
    3: { pools: ["armor", "pet", "silver", "gift"], count: [2, 3] },
    4: { pools: ["gold", "silver", "key", "gift"], count: [2, 3] },
    5: { pools: ["pet", "armor", "gift"], count: [2, 3] },
    6: { pools: ["gold", "silver", "gift"], count: [2, 3] },
    7: { pools: ["armor", "key", "pet", "gift"], count: [2, 3] },
    8: { pools: ["gold", "silver", "armor"], count: [2, 3] },
    9: { pools: ["miniBoss"], count: [1] },
    9.5: { pools: ["bigBoss"], count: [1] },
  };

  function choice(arr, rnd = R) {
    return arr[Math.floor(rnd() * arr.length)];
  }

  function getRandomBoss(poolName, rnd = R) {
    const pool = BOSS_POOLS[poolName];
    if (!pool || !pool.length) return null;
    return { ...choice(pool, rnd) };
  }

  function rollAffixes(rnd = R) {
    const roll = rnd();
    const count = roll < 0.45 ? 1 : roll < 0.15 ? 2 : 0;
    const picks = [];
    const opts = AFFIXES.slice();
    for (let i = 0; i < count && opts.length; i++) {
      const ix = Math.floor(rnd() * opts.length);
      picks.push(opts.splice(ix, 1)[0]);
    }
    return picks;
  }

  function applyStats(stage, wave, base, affixes, rnd = R) {
    const cappedStage = Math.min(stage, 2);
    const mainScale = 1 + cappedStage * 0.12 + Math.max(0, wave - 1) * 0.06;
    const waveIndex = Math.max(1, Math.floor(wave || 1));
    const rng = typeof rnd === "function" ? rnd : R;
    const waveBump = 1 + (waveIndex - 1) * (0.02 + rng() * 0.03);
    const scale = mainScale * waveBump;

    let hpMul = base.hpMul || 1;
    let atkMul = base.atkMul || 1;
    let defMul = base.defMul || 1;

    for (const a of affixes) {
      hpMul *= a.hpMul ?? 1;
      atkMul *= a.atkMul ?? 1;
      defMul *= a.defMul ?? 1;
    }

    return {
      hpMax: Math.round(300 * scale * hpMul),
      atk: Math.round(25 * scale * atkMul),
      def: Math.round(8 * scale * defMul),
      critChance: Math.min(0.5, 0.1 + (atkMul - 1) * 0.08),
      critMult: 1.5 + Math.max(0, atkMul - 1) * 0.25,
      resist: base.resist || {},
      speedMul: waveBump,
    };
  }

  function deriveDrops(base, affixes, rnd = R) {
    const drops = [];
    const pool = base.pool || base.type || null;
    const isBig = pool === "bigBoss";

    if (base.goldMul) {
      const baseGold = 100000 + Math.floor(rnd() * 1400000);
      drops.push({ kind: "gold", amount: Math.floor(baseGold * base.goldMul) });
    }
    if (base.silverMul) {
      const baseSilver = 100000 + Math.floor(rnd() * 1400000);
      drops.push({
        kind: "silver",
        amount: Math.floor(baseSilver * base.silverMul),
      });
    }

    if (base.armorDrop) {
      const ranks = isBig ? ["A", "S"] : ["C", "B"];
      drops.push({ kind: "armor", rank: choice(ranks, rnd) });
    }

    if (base.petDrop) {
      const qty = 5 + Math.floor(rnd() * 6);
      drops.push({ kind: "petShard", which: base.petDrop, qty });
    }

    if (base.dropsKey) drops.push({ kind: "bossKey", qty: 1 });
    if (base.giftDrop) drops.push({ kind: "giftBox", qty: 1 });

    for (const a of affixes) {
      if (a.id === "vampiric" && rnd() < 0.35)
        drops.push({ kind: "consumable", id: "rage_pill", qty: 1 });
      if (a.id === "armored" && rnd() < 0.35) {
        const ranks = isBig ? ["A", "S"] : ["C", "B"];
        drops.push({ kind: "armor", rank: choice(ranks, rnd) });
      }
      if (a.id === "swift" && rnd() < 0.25) {
        const ranks = isBig ? ["A", "S"] : ["C", "B"];
        drops.push({ kind: "gear", rank: choice(ranks, rnd), slot: "boots" });
      }
    }

    if (!drops.length) {
      const ranks = isBig ? ["A", "S"] : ["C", "B"];
      drops.push({ kind: "gearKit", rank: choice(ranks, rnd) });
    }

    return drops;
  }

  function buildBoss(stage, wave, base, rnd = R) {
    const affixes = rollAffixes(rnd);
    const stats = applyStats(stage, wave, base, affixes, rnd);
    const drops = deriveDrops(base, affixes, rnd);
    const decoratedName = decorateName(base.name, affixes);
    return {
      ...base,
      name: decoratedName,
      stats,
      drops,
      affixes,
    };
  }

  function decorateName(name, affixes) {
    if (!affixes.length) return name;
    const tags = affixes.map((a) => a.id[0].toUpperCase() + a.id.slice(1));
    return tags.join(" ") + " " + name;
  }

  function getWaveConfig(wave) {
    if (WAVE_BOSS_CONFIGS[wave]) return WAVE_BOSS_CONFIGS[wave];
    const w = Math.floor(wave);
    return WAVE_BOSS_CONFIGS[w] || null;
  }

  function getWaveBosses(wave, opts = {}) {
    const { stage = 1, rng = R } = opts;
    const cfg = getWaveConfig(wave);
    const bosses = [];

    if (!cfg) {
      const injectPool = choice(["armor", "pet", "key", "gold", "silver"], rng);
      const base = getRandomBoss(injectPool, rng);
      if (base) bosses.push(buildBoss(stage, wave, base, rng));
      return bosses;
    }

    const countArr = Array.isArray(cfg.count) ? cfg.count : [cfg.count];
    const count = choice(countArr, rng);

    for (let i = 0; i < count; i++) {
      const poolName = choice(cfg.pools, rng);
      const base = getRandomBoss(poolName, rng);
      if (base) bosses.push(buildBoss(stage, wave, base, rng));
    }

    return bosses;
  }

  window.BossPoolSystem = {
    BOSS_POOLS,
    WAVE_BOSS_CONFIGS,
    getRandomBoss,
    getWaveBosses,
    buildBoss,
  };

  console.log("? Boss Pool System Loaded (boss-only)");
})();

</script>

  <!-- Bridge no longer needed - modules expose themselves to window -->
  <script id="anti-dash-followers-inline">
    (function () {
      const RUN_MAX = 280;
      const WATCH_MARK = '__antiDashWatch';
      const wait = (condition, cb) => condition() ? cb() : setTimeout(() => wait(condition, cb), 50);
      const clamp = (value, min, max) => Math.max(min, Math.min(max, value));
      const muteState = { active: false };

      const withMute = (fn) => {
        try {
          muteState.active = true;
          fn();
        } finally {
          muteState.active = false;
        }
      };

      const logStack = (label, value, owner) => {
        try {
          const err = new Error();
          const trace = (err.stack || '').split('\n').slice(2, 6).join('\n');
          console.warn('[AntiDash] set', label, '->', value, owner?.name || owner?.id || owner, '\n', trace);
        } catch (_) {
          console.warn('[AntiDash] set', label, '->', value);
        }
      };

      const watchProp = (obj, key, label) => {
        if (!obj || !key) return;
        try {
          const store = obj[WATCH_MARK] = obj[WATCH_MARK] || {};
          if (store[key]) return;
          let current = obj[key];
          Object.defineProperty(obj, key, {
            configurable: true,
            enumerable: Object.prototype.propertyIsEnumerable.call(obj, key),
            get() { return current; },
            set(value) {
              if (current === value) { current = value; return; }
              current = value;
              if (!muteState.active) logStack(label || key, value, obj);
            }
          });
          store[key] = true;
        } catch (_) { /* non-configurable property */ }
      };

      const forFollowers = (fn) => {
        const st = window.st;
        if (!st?.players) return;
        const leadIndex = st.leader || 0;
        const players = st.players;
        for (let i = 0; i < players.length; i++) {
          if (i === leadIndex) continue;
          const follower = players[i];
          if (follower) {
            follower._idx = i;
            fn(follower, i, leadIndex);
          }
        }
      };

      const instrumentFollowers = () => {
        forFollowers((p) => {
          ['isDashing', 'dash', 'dashT', 'dashCD', 'blink', 'phase', 'warp', 'speedScale', 'runBoost']
            .forEach((prop) => watchProp(p, prop, 'p.' + prop));
          if (p.pf) {
            ['dash', 'burst', 'boost', 'dashT'].forEach((prop) => watchProp(p.pf, prop, 'p.pf.' + prop));
          }
        });
      };

      const enforceFollowers = () => {
        const st = window.st;
        const players = st?.players;
        if (!players) return;
        const leaderIndex = st.leader || 0;
        const leader = players[leaderIndex];
        forFollowers((p) => {
          withMute(() => {
            if (p.isDashing) p.isDashing = false;
            if (p.dash) p.dash = 0;
            if (p.dashT) p.dashT = 0;
            if (p.dashCD) p.dashCD = 0;
            if (p.pf) {
              if (p.pf.dash) p.pf.dash = false;
              if (p.pf.burst) p.pf.burst = 0;
              if (p.pf.boost) p.pf.boost = 0;
              if (p.pf.dashT) p.pf.dashT = 0;
            }
          });

          if (Math.abs(p.vx || 0) > RUN_MAX) p.vx = Math.sign(p.vx || 0) * RUN_MAX;
          if (leader) {
            const offset = 120 + (p._idx || 0) * 40;
            const targetX = (leader.x || 0) - offset;
            const delta = targetX - (p.x || 0);
            if (Math.abs(delta) > 360) {
              p.x = targetX;
              p.vx = 0;
            } else {
              p.x += delta * 0.08;
              p.vx = clamp(p.vx || 0, -RUN_MAX, RUN_MAX);
            }
            p.y = leader.y;
          }
        });
      };

      const wrapUpdate = () => {
        const original = window.update;
        if (typeof original !== 'function' || original.__antiDashWrapped) return;
        const wrapped = function () {
          const result = original.apply(this, arguments);
          enforceFollowers();
          return result;
        };
        wrapped.__antiDashWrapped = true;
        window.update = wrapped;
      };

      const reassertGlobals = () => {
        try {
          if (window.INPUT) window.INPUT.doubleTapToDash = false;
          if (window.Config && 'dashEnabled' in window.Config) window.Config.dashEnabled = false;
        } catch (_) { }
      };

      const boot = () => {
        reassertGlobals();
        instrumentFollowers();
        wrapUpdate();
        enforceFollowers();
        setInterval(instrumentFollowers, 1500);
        setInterval(() => {
          reassertGlobals();
          enforceFollowers();
        }, 250);
        console.log('[AntiDash] followers locked to smooth follow (no burst)');
      };

      wait(() => window.st?.players && typeof window.update === 'function', boot);
    })();
  </script>

  <script>
    // Flow config: set true only if you WANT to force clears at edge
    window.REQUIRE_CLEAR_FOR_TRANSITION = false;
  </script>
  <script>
    window.A1K_FLAGS = Object.assign({
      SHOW_COMBO: false,
      SHOW_WP: false,
      SHOW_RIGHT_STATS: false,
      TEAM_MENU_ENABLED: true
    }, window.A1K_FLAGS || {});
  </script>

  <!-- Early no-op stubs to avoid ReferenceError before later definitions -->
  <script>
    window.addDamageNumber = window.addDamageNumber || function () { };
    window.updateDamageNumbers = window.updateDamageNumbers || function () { };
    window.drawDamageNumbers = window.drawDamageNumbers || function () { };
    if (location.protocol === 'file:') {
      console.warn('[A1K] Running over file:// will block fetch() and modules in Firefox. Please serve via HTTP (e.g., npx http-server).');
    }
  </script>

  <!-- Game Integration Script -->
  <script>
    // A1K Game Integration - Initialize Asset Loading System
    (async function () {
      try {
        console.log('🚀 A1K Game Integration Starting...');

        // Initialize asset registry and load all manifests
        if (window.assetRegistry) {
          await window.assetRegistry.loadAllManifests();
        }

        // Boot integrations (parallax, platforms, etc.)
        if (window.bootData) {
          await window.bootData();
        }

        // Initialize game data access
        if (window.A1K_ASSETS) {
          console.log('🎯 A1K Assets loaded successfully');
          console.log('📦 Available asset categories:', Object.keys(window.A1K_ASSETS.categories || {}));
          console.log('🔧 Available game mechanics:', Object.keys(window.A1K_ASSETS.game_mechanics || {}));
        }

        // Make assets globally accessible for the main game
        window.GAME_ASSETS = window.A1K_ASSETS;
        window.ASSETS = window.A1K_ASSETS; // Legacy support

        console.log('✅ A1K Game Integration Complete');

      } catch (error) {
        console.error('❌ A1K Game Integration Failed:', error);
      }
    })();
  </script>

  <!-- Unified Game System (ES module) -->
  <script>window.UNIFIED_RENDERER = true;</script>
  <!-- Inlined: src/core/a1k_game.js -->
<script>
// A1K Runner - Integrated Game System
// Unified game file that integrates all systems and assets (Non-module version)

(function () {
  "use strict";

  // Use functions from window
  const assetRegistry = () => window.assetRegistry;
  const bootData = () => window.bootData;

  // Shared shop data so both modular code and the compiled bundle stay in sync.
  const SHOP_ITEMS = [
    // Consumables
    {
      id: "hp_potion",
      name: "HP Potion",
      description: "Heals 40% leader HP.",
      cost: 60,
      type: "consumable",
      category: "consumable",
    },
    {
      id: "rage_pill",
      name: "Rage Pill",
      description: "Grants +30 Rage to party.",
      cost: 90,
      type: "consumable",
      category: "consumable",
    },
    {
      id: "revive_token",
      name: "Revive Token",
      description: "Instantly revives one defeated hero.",
      cost: 80,
      type: "consumable",
      category: "consumable",
    },
    {
      id: "wave_skip",
      name: "Wave Skip",
      description: "Skips the current wave.",
      cost: 100,
      type: "consumable",
      category: "consumable",
    },
    {
      id: "stage_skip",
      name: "Stage Skip",
      description: "Skips the current stage.",
      cost: 500,
      type: "consumable",
      category: "consumable",
    },
    {
      id: "boss_skip_pass",
      name: "Boss Skip Pass",
      description: "Skips to the next boss.",
      cost: 1000,
      type: "consumable",
      category: "consumable",
    },
    {
      id: "treasure_box_boss_pass",
      name: "Treasure Box Boss Pass",
      description: "Unlocks a special treasure boss.",
      cost: 2000,
      type: "consumable",
      category: "consumable",
    },
    {
      id: "ap_reset",
      name: "AP Reset",
      description: "Refund all spent AP.",
      cost: 400,
      type: "consumable",
      category: "consumable",
    },
    // Containers and misc
    {
      id: "gold_bag",
      name: "Gold Bag",
      description: "Open for 500-5000 gold.",
      cost: 300,
      type: "item",
      category: "misc",
    },
    {
      id: "big_gold_bag",
      name: "Big Gold Bag",
      description: "Open for 2000-10000 gold.",
      cost: 1200,
      type: "item",
      category: "misc",
    },
    {
      id: "gear_kit",
      name: "Random Gear Kit",
      description: "Adds 3 random gear pieces.",
      cost: 250,
      type: "item",
      category: "gear",
    },
    {
      id: "pet_box",
      name: "Pet Box",
      description: "Contains a random pet.",
      cost: 500,
      type: "item",
      category: "misc",
    },
    {
      id: "vehicle_box",
      name: "Vehicle Box",
      description: "Contains a random vehicle.",
      cost: 750,
      type: "item",
      category: "misc",
    },
    {
      id: "super_equipment_pack",
      name: "Super Equipment Pack",
      description: "Contains B-A rank gear.",
      cost: 1500,
      type: "item",
      category: "gear",
    },
    {
      id: "big_box",
      name: "Big Box",
      description:
        "Contains 3 random items, 1 pet, 1 vehicle, and 1 set of A-C gear.",
      cost: 3000,
      type: "item",
      category: "misc",
    },
    // Armor pieces
    {
      id: "vanguard_armor",
      name: "Vanguard Armor",
      description: "Sturdy armor boosting DEF by 50.",
      cost: 500,
      type: "gear",
      category: "armor",
      slot: "armor",
      def: 50,
      set: "Vanguard",
    },
    {
      id: "mystic_robes",
      name: "Mystic Robes",
      description: "Robes boosting DEF by 40 and MP.",
      cost: 600,
      type: "gear",
      category: "armor",
      slot: "armor",
      def: 40,
      mp: 50,
      set: "Mystic",
    },
    // Spell scrolls
    {
      id: "spell_scroll_fireball",
      name: "Spell Scroll: Fireball",
      description: "Learn the Fireball skill.",
      cost: 400,
      type: "scroll",
      category: "scroll",
      use: "learn_fireball",
    },
    {
      id: "spell_scroll_heal",
      name: "Spell Scroll: Heal",
      description: "Learn the Heal skill.",
      cost: 500,
      type: "scroll",
      category: "scroll",
      use: "learn_heal",
    },
    // Premium S-rank gear
    {
      id: "aether_greatblade",
      name: "Aether Greatblade",
      description: "Legendary blade imbued with cosmic power.",
      cost: 5000,
      type: "gear",
      category: "srank",
      slot: "weapon",
      atk: 55,
      rank: "S",
    },
    {
      id: "starlit_carapace",
      name: "Starlit Carapace",
      description: "Radiant armor forged from starlight.",
      cost: 5000,
      type: "gear",
      category: "srank",
      slot: "armor",
      def: 60,
      rank: "S",
    },
    {
      id: "celestial_loop",
      name: "Celestial Loop",
      description: "Ring that channels celestial energy.",
      cost: 5000,
      type: "gear",
      category: "srank",
      slot: "accessory",
      atk: 65,
      rank: "S",
    },
  ];

  const SHOP_CATEGORIES = [
    { cat: "all", id: "all", label: "All" },
    { cat: "consumable", id: "consumable", label: "Consumables" },
    { cat: "gear", id: "gear", label: "Gear" },
    { cat: "armor", id: "armor", label: "Armor" },
    { cat: "scroll", id: "scroll", label: "Scrolls" },
    { cat: "srank", id: "srank", label: "S Rank" },
  ];

  // Global game state
  const Game = {
    state: {
      running: true,
      speed: 1,
      time: 0,
      dt: 0,
      started: false,
      stage: 1,
      wave: 1,
      wavesPerStage: 10,
      kills: 0,
      gold: 10000,
      silver: 10000,
      tickets: 20,
      gems: 50,
      bossKills: 0,
      giftKeys: 20,
      bossKeys: 5,

      // Player state
      players: [
        {
          id: "A1",
          x: 200,
          y: 560,
          vx: 0,
          vy: 0,
          hpMax: 700,
          hp: 700,
          isDefeated: false,
          reviveT: 0,
          dmgBase: 120,
          rage: 0,
          rageMax: 100,
          rageOn: false,
          rageDur: 0,
          rageICD: 0,
          secretGauge: 0,
          secretMax: 100,
          secretActive: false,
          secretTimer: 0,
          exhaustionT: 0,
          _gcdT: 0,
          _atkMul: 1,
          _speedMul: 1,
          facingLeft: false,
          def: 200,
          aura: 200,
          luck: 100,
        },
        {
          id: "Unique",
          x: 240,
          y: 530,
          vx: 0,
          vy: 0,
          hpMax: 640,
          hp: 640,
          isDefeated: false,
          reviveT: 0,
          dmgBase: 110,
          rage: 0,
          rageMax: 100,
          rageOn: false,
          rageDur: 0,
          rageICD: 0,
          secretGauge: 0,
          secretMax: 100,
          secretActive: false,
          secretTimer: 0,
          exhaustionT: 0,
          _gcdT: 0,
          _atkMul: 1,
          _speedMul: 1,
          facingLeft: false,
          def: 100,
          aura: 100,
          luck: 50,
        },
        {
          id: "Missy",
          x: 220,
          y: 500,
          vx: 0,
          vy: 0,
          hpMax: 640,
          hp: 640,
          isDefeated: false,
          reviveT: 0,
          dmgBase: 100,
          rage: 0,
          rageMax: 100,
          rageOn: false,
          rageDur: 0,
          rageICD: 0,
          secretGauge: 0,
          secretMax: 100,
          secretActive: false,
          secretTimer: 0,
          exhaustionT: 0,
          _gcdT: 0,
          _atkMul: 1,
          _speedMul: 1,
          facingLeft: false,
          def: 100,
          aura: 100,
          luck: 50,
        },
      ],

      leader: 0,
      enemies: [],
      shots: [],
      eShots: [],
      pickups: [],
      effects: [],
      bossAlive: false,
      bossHP: 0,
      bossMax: 1000,

      // Game state
      cds: {
        A1: { S1: 0, S2: 0, S3: 0, S4: 0, S5: 0, X1: 0 },
        Unique: { S1: 0, S2: 0, S3: 0, S4: 0, S5: 0, X1: 0 },
        Missy: { S1: 0, S2: 0, S3: 0, S4: 0, S5: 0, X1: 0 },
      },

      // Inventory / Gear
      inv: [],
      invRows: 5,
      equippedGear: {
        weapon: null,
        weapon2: null,
        armor: null,
        acc1: null,
        acc2: null,
      },
      equippedPets: [null, null],
      petSlots: 2,
      equippedVehicle: null,

      // Active instances
      activePets: [],
      vehicles: [],
      activeClones: [], // A1 clones
      activeMiniPets: [], // Mini pets
      bagOpen: false,
      bagTab: "items",

      // Talent system
      talentLanes: {},
      talentPicks: new Set(),
      _talentStats: {},
      sharedEnergy: { current: 0, max: 100 },

      // Game state flags
      isGameOver: false,
      gameComplete: false,
      _globalSkillLock: 0,
      reviveTokens: 20,
      learnedSpells: {},
      stageStartTime: null,
      matchStarted: true,
      auto: true,
      shopCategory: "all",
      parryT: 0,

      // Clone and mini pet settings
      _cloneStance: "assault",
      _equippedCore: null,

      // Asset system integration
      assets: null,
      assetsLoaded: false,

      // Map system (disabled - start immediately in battle mode)
      gameMode: "battle",
      // Interactive buildings and NPCs
      interactables: [],
      party: [],
      universalActionTarget: null,
      universalActionType: null,
      // Building interior overlays
      insideBuilding: null, // 'tavern', 'arcade', or null
      // availableMaps: [
      //   { id: "forest", name: "Forest Ruins", difficulty: "Easy" },
      //   { id: "desert", name: "Desert Wasteland", difficulty: "Medium" },
      //   { id: "ice", name: "Frozen Caverns", difficulty: "Hard" },
      //   { id: "volcano", name: "Volcanic Core", difficulty: "Extreme" },
      // ],
      // selectedMap: null,
    },

    // Structured shop metadata used by UI renderers.
    shopCatalog: {
      get categories() {
        return SHOP_CATEGORIES;
      },
      get items() {
        return SHOP_ITEMS;
      },
      filter(category = "all") {
        if (!category || category === "all") return SHOP_ITEMS;
        return SHOP_ITEMS.filter((item) => item.category === category);
      },
      getItem(id) {
        return SHOP_ITEMS.find((item) => item.id === id) || null;
      },
    },

    // Asset management
    async initialize() {
      console.log("🚀 A1K Game System Initializing...");

      try {
        // Load all manifests and assets while booting integrations in parallel
        const manifestsPromise = assetRegistry.loadAllManifests();
        const bootPromise = bootData();

        await manifestsPromise;
        Game.state.assets = assetRegistry.getUnifiedManifest();
        Game.state.assetsLoaded = true;

        await bootPromise;

        console.log("✅ A1K Game System Initialized");
        console.log("📦 Assets available at: window.A1K_ASSETS");
        console.log("🎯 Game state available at: window.Game.state");

        return true;
      } catch (error) {
        console.error("❌ A1K Game System Initialization Failed:", error);
        return false;
      }
    },

    // Get current leader
    getLeader() {
      if (!Game.state.players || Game.state.players.length === 0) return null;
      if (
        Game.state.leader < 0 ||
        Game.state.leader >= Game.state.players.length
      )
        return null;
      return Game.state.players[Game.state.leader];
    },

    // Add gold
    addGold(amount) {
      const leader = Game.getLeader();
      const luck = leader?.luck || 0;
      const bonus = 1 + luck / 200;
      Game.state.gold += Math.floor(amount * bonus);
      Game.updateCurrencies();
    },

    // Add silver
    addSilver(amount) {
      const leader = Game.getLeader();
      const luck = leader?.luck || 0;
      const bonus = 1 + luck / 200;
      Game.state.silver += Math.floor(amount * bonus);
      Game.updateCurrencies();
    },

    // Add gems
    addGems(amount) {
      Game.state.gems += amount;
      Game.updateCurrencies();
    },

    // Add keys
    addGiftKeys(amount) {
      Game.state.giftKeys += amount;
      Game.updateCurrencies();
    },
    addBossKeys(amount) {
      Game.state.bossKeys += amount;
      Game.updateCurrencies();
    },

    // Add item to bag
    addItem(item) {
      if (!item) return;
      const maxSlots = Game.maxBagSlots();
      if (Game.state.inv.length >= maxSlots) {
        return false;
      }
      Game.state.inv.push(item);

      // Check for auto-open if BagItemHandler is available
      if (window.BagItemHandler && window.BagItemHandler.checkAutoOpen) {
        window.BagItemHandler.checkAutoOpen(item);
      }

      if (Game.state.bagOpen) {
        Game.renderBag();
      }
      return true;
    },

    // Get max bag slots
    maxBagSlots() {
      return Game.state.invRows * 8;
    },

    // Entity management
    addEnemy(enemy) {
      Game.state.enemies.push(enemy);
    },

    removeEnemy(index) {
      Game.state.enemies.splice(index, 1);
    },

    addShot(shot) {
      Game.state.shots.push(shot);
    },

    clearDeadEntities() {
      Game.state.enemies = Game.state.enemies.filter((e) => e.hp > 0);
      Game.state.shots = Game.state.shots.filter((s) => s.active);
      Game.state.eShots = Game.state.eShots.filter((s) => s.active);
    },

    // Boss management
    spawnBoss(bossData) {
      Game.state.bossAlive = true;
      Game.state.bossHP = bossData.maxHP;
      Game.state.bossMax = bossData.maxHP;
    },

    damageBoss(damage) {
      if (!Game.state.bossAlive) return;
      Game.state.bossHP = Math.max(0, Game.state.bossHP - damage);
      if (Game.state.bossHP <= 0) {
        Game.state.bossAlive = false;
        Game.state.bossKills++;
      }
    },

    // Update currencies display
    updateCurrencies() {
      try {
        if (Game._currencyUpdateScheduled) return; // throttle to once per frame
        Game._currencyUpdateScheduled = true;

        requestAnimationFrame(() => {
          try {
            // Cache DOM element refs and state bindings once
            if (!Game._currencyElements) {
              Game._currencyElements = {
                goldVal: document.getElementById("goldVal"),
                silverVal: document.getElementById("silverVal"),
                ticketVal: document.getElementById("ticketVal"),
                gemVal: document.getElementById("gemVal"),
                bossKillsVal: document.getElementById("bossKillsVal"),
                giftKeyVal: document.getElementById("giftKeyVal"),
                bossKeyVal: document.getElementById("bossKeyVal"),
                bagGoldVal: document.getElementById("bagGoldVal"),
              };
            }

            if (!Game._currencyBindings) {
              // Explicit bindings avoid per-frame string replacement and fix pluralization
              Game._currencyBindings = {
                goldVal: "gold",
                silverVal: "silver",
                ticketVal: "tickets",
                gemVal: "gems",
                bossKillsVal: "bossKills",
                giftKeyVal: "giftKeys",
                bossKeyVal: "bossKeys",
                bagGoldVal: "gold",
              };
              Game._currencyBindingKeys = Object.keys(Game._currencyBindings);
            }

            const elements = Game._currencyElements;
            const bindingKeys = Game._currencyBindingKeys;
            for (let i = 0; i < bindingKeys.length; i++) {
              const elId = bindingKeys[i];
              const el = elements[elId];
              if (!el) continue;
              const stateKey = Game._currencyBindings[elId];
              const value = Game.state[stateKey] || 0;
              // Avoid DOM writes if unchanged
              if (el.textContent !== String(value)) {
                el.textContent = value;
              }
            }
          } catch (error) {
            console.warn("Currency update failed:", error.message);
          } finally {
            Game._currencyUpdateScheduled = false;
          }
        });
      } catch (error) {
        console.warn("Currency update scheduling failed:", error.message);
      }
    },

    // Render bag contents with stacking
    renderBag() {
      if (!Game.state.bagOpen) return;

      // Throttle DOM-heavy bag rendering to once per frame
      if (Game._bagRenderScheduled) return;
      Game._bagRenderScheduled = true;

      requestAnimationFrame(() => {
        Game._bagRenderScheduled = false;

        const bagGrid = document.getElementById("bagGrid");
        if (!bagGrid) {
          console.warn("Bag grid element not found");
          return;
        }

        try {
          // Group items by name and count them
          const itemCounts = {};
          const inventory = Game.state.inv;
          for (let i = 0; i < inventory.length; i++) {
            const entry = inventory[i];
            const key = typeof entry === "string" ? entry : entry.name;
            const qty = typeof entry === "string" ? 1 : entry.quantity || 1;
            itemCounts[key] = (itemCounts[key] || 0) + qty;
          }

          // Clear existing items
          bagGrid.innerHTML = "";

          // Display stacked items
          const itemEntries = Object.entries(itemCounts);
          const fragment = document.createDocumentFragment();

          for (let i = 0; i < itemEntries.length; i++) {
            const [itemName, count] = itemEntries[i];
            const itemDiv = document.createElement("div");
            itemDiv.className = "slot-box item";
            itemDiv.textContent =
              count > 1 ? `${itemName} x${count}` : itemName;
            itemDiv.title = `${itemName} (${count})`;

            // Add click handler for item interactions
            itemDiv.addEventListener("click", (e) => {
              e.stopPropagation();
              const rect = itemDiv.getBoundingClientRect();

              // Find actual item object
              const itemObj = Game.state.inv.find((item) => {
                const name = typeof item === "string" ? item : item.name;
                return name === itemName;
              });

              if (window.BagItemHandler && itemObj) {
                window.BagItemHandler.showItemMenu(
                  rect.right + 5,
                  rect.top,
                  itemObj,
                  itemDiv
                );
              }
            });

            fragment.appendChild(itemDiv);
          }

          // Add empty slots if needed
          const totalSlots = 32;
          const currentSlots = itemEntries.length;
          for (let i = currentSlots; i < totalSlots; i++) {
            const emptyDiv = document.createElement("div");
            emptyDiv.className = "slot-box";
            emptyDiv.textContent = "+";
            fragment.appendChild(emptyDiv);
          }

          bagGrid.appendChild(fragment);
        } catch (error) {
          console.error("Bag rendering failed:", error.message);
        }
      });
    },

    // Initialize game
    async start() {
      try {
        const success = await Game.initialize();
        if (success) {
          Game.enterLobby();
          Game.gameLoop();
        } else {
          console.error("Game initialization failed");
        }
      } catch (error) {
        console.error("Game start failed:", error.message);
      }
    },

    // Enter lobby mode (disabled - start in battle mode)
    enterLobby() {
      // Game.state.gameMode = "lobby";
      // Game.state.running = false;
      // Game.state.started = false;
      console.log("🏠 Lobby disabled - starting in battle mode");
    },

    // Show map selection (disabled)
    showMapSelection() {
      // Map selection disabled - start immediately in battle mode
      Game.startBattle();
    },

    // Select map and start battle (disabled)
    selectMap(mapIndex) {
      // Map selection disabled - start immediately in battle mode
      Game.startBattle();
    },

    // Start battle mode
    startBattle() {
      Game.state.gameMode = "battle";
      Game.state.running = true;
      Game.state.started = false;
      const mapName = Game.state.selectedMap?.name || "Unknown Map";
      console.log(`⚔️ Battle Started: ${mapName}`);

      // Set up interactive buildings when battle starts
      this.setupInteractiveBuildings();
    },

    // Setup interactive buildings in the game world
    setupInteractiveBuildings() {
      const st = Game.state;
      st.interactables = st.interactables || [];

      // Clear existing buildings to prevent duplicates
      st.interactables = st.interactables.filter((b) => b.type !== "building");

      // Try to load buildings from JSON manifest
      this.loadBuildingsFromManifest();

      // Fallback: Add buildings if none were loaded
      if (!st.interactables.some((b) => b.type === "building")) {
        console.log(
          "No buildings loaded from manifest, creating fallback buildings"
        );

        // Add a Tavern
        const tavern = {
          id: "tavern",
          type: "building",
          x: 800,
          y: 350,
          width: 150,
          height: 100,
          label: "Tavern",
          color: "#8B4513",
          strokeColor: "#D2691E",
          roofColor: "#A52A2A",
          doorColor: "#4d2600",
          windowColor: "#FFF8DC",
        };
        st.interactables.push(tavern);

        // Add an Arcade
        const arcade = {
          id: "arcade",
          type: "building",
          x: 1400,
          y: 350,
          width: 150,
          height: 100,
          label: "Arcade",
          color: "#4682B4",
          strokeColor: "#1E90FF",
          roofColor: "#6495ED",
          doorColor: "#191970",
          neonColor: "#FF1493",
        };
        st.interactables.push(arcade);
      }

      console.log("🏠 Interactive buildings setup complete");
      console.log(
        "Buildings found:",
        st.interactables.filter((b) => b.type === "building")
      );
      console.log("Total interactables:", st.interactables.length);
    },

    // Load buildings from JSON manifest
    async loadBuildingsFromManifest() {
      try {
        const response = await fetch("data/Json/buildings.json");
        if (response.ok) {
          const data = await response.json();
          const buildings = Object.values(data.buildings || {});

          console.log("Loaded buildings from manifest:", buildings);

          buildings.forEach((building) => {
            Game.state.interactables.push(building);
          });
        }
      } catch (error) {
        console.log("Could not load buildings manifest:", error.message);
      }
    },

    // Main game loop
    gameLoop() {
      const loop = (timestamp) => {
        const dt = (timestamp - Game.lastTimestamp) / 1000 || 0.016;
        Game.lastTimestamp = timestamp;

        if (Game.state.running) {
          Game.state.time += dt * Game.state.speed;
          Game.state.dt = dt * Game.state.speed;

          if (Game.state.gameMode === "battle" && !Game.state.started) {
            Game.state.started = true;
            Game.spawnWave();
          }

          // Update game systems based on mode
          if (Game.state.gameMode === "battle") {
            Game.update(dt);
          } else {
            Game.updateLobby(dt);
          }
        }

        // Render
        Game.render();

        requestAnimationFrame(loop);
      };

      Game.lastTimestamp = performance.now();
      requestAnimationFrame(loop);
    },

    // Update game systems
    update(dt) {
      // Don't update combat when inside a building
      const insideBuilding = Game.state.insideBuilding;

      if (!insideBuilding) {
        // Update players
        Game.updatePlayers(dt);

        // Update hired NPCs
        Game.updateNpcs(dt);

        // Update enemies
        Game.updateEnemies(dt);
        try {
          if (
            window.enemyAbilities &&
            typeof window.enemyAbilities.update === "function"
          ) {
            window.enemyAbilities.update(Game.state, dt);
          }
        } catch (_) {}

        // Update projectiles
        Game.updateProjectiles(dt);

        // Update effects
        Game.updateEffects(dt);
      }

      // Always update UI
      Game.updateUI();

      // Auto-consume items: heal and revive
      try {
        const st = Game.state;
        const inv = Array.isArray(st.inv) ? st.inv : [];
        const takeOne = (predicate) => {
          const index = inv.findIndex(predicate);
          if (index >= 0) {
            const item = inv.splice(index, 1)[0];
            if (st.bagOpen && typeof window.renderBag === "function") {
              window.renderBag();
            }
            return item;
          }
          return null;
        };

        const leader = Game.getLeader();
        if (
          leader &&
          !leader.isDefeated &&
          leader.hp > 0 &&
          leader.hpMax > 0 &&
          leader.hp < leader.hpMax * 0.5
        ) {
          const potion = takeOne(
            (it) =>
              it &&
              (it.id === "hp_potion" ||
                it.type === "hp_potion" ||
                (it.type === "consumable" &&
                  String(it.name || "")
                    .toLowerCase()
                    .includes("potion")))
          );
          if (potion) {
            const heal = Math.round(leader.hpMax * 0.4);
            leader.hp = Math.min(leader.hpMax, (leader.hp || 0) + heal);
            if (window.notify) window.notify("Auto-Heal +" + heal, "#36c777");
          }
        }

        for (const player of st.players || []) {
          if (!player || (!player.isDefeated && player.hp > 0)) continue;
          const revive = takeOne(
            (it) =>
              it &&
              (it.id === "revive_token" ||
                it.type === "revive_token" ||
                (it.type === "consumable" &&
                  String(it.name || "")
                    .toLowerCase()
                    .includes("revive")))
          );
          if (revive) {
            player.isDefeated = false;
            player.hp = Math.max(1, Math.round(player.hpMax * 0.6));
            if (window.notify) window.notify("Auto-Revive used", "#ffd56a");
          }
        }
      } catch (_) {}

      // Update cooldowns
      Game.tickCooldowns(dt);

      // Update pickups
      Game.updatePickups(dt);

      // Check wave progression
      Game.checkWaveProgress();
    },

    // Render game
    render() {
      if (!Game._canvas) {
        Game._canvas = document.getElementById("cv");
        if (!Game._canvas) return;
        Game._ctx = Game._canvas.getContext("2d");
      }

      const ctx = Game._ctx;

      if (typeof window !== "undefined" && window.VFX) {
        try {
          if (!Game._vfxBooted) {
            window.VFX.init({ canvas: Game._canvas, autoResize: true });
            window.VFX.Presets?.pixelCRT?.();
            Game._vfxBooted = true;
          } else if (Game._vfxBooted) {
            window.VFX.resize(Game._canvas.width, Game._canvas.height);
          }
        } catch (err) {
          console.error("[VFX] init error", err);
          Game._vfxBooted = false;
        }
      }

      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.fillStyle = "#0b1421";
      ctx.fillRect(0, 0, Game._canvas.width, Game._canvas.height);

      if (Game.state.gameMode === "lobby") {
        Game.renderLobby(ctx);
      } else if (Game.state.gameMode === "map") {
        Game.renderBattle(ctx); // Skip map selection, go straight to battle
      } else if (Game.state.gameMode === "battle") {
        Game.renderBattle(ctx);

        // Draw building interior overlay if inside a building
        if (Game.state.insideBuilding === "tavern") {
          Game.renderTavernOverlay(ctx);
        } else if (Game.state.insideBuilding === "arcade") {
          Game.renderArcadeOverlay(ctx);
        }
      }
    },

    // Render lobby
    renderLobby(ctx) {
      ctx.fillStyle = "#1a2332";
      ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

      ctx.fillStyle = "#ffffff";
      ctx.font = "48px Arial";
      ctx.textAlign = "center";
      ctx.fillText("A1K RUNNER", ctx.canvas.width / 2, 150);

      ctx.font = "24px Arial";
      ctx.fillText("Press M for Map Selection", ctx.canvas.width / 2, 300);
      ctx.fillText("Press I for Inventory", ctx.canvas.width / 2, 340);

      // Draw players in lobby
      Game.drawPlayers(ctx);
    },

    // Render Tavern interior overlay
    renderTavernOverlay(ctx) {
      // Draw tavern background
      ctx.fillStyle = "#3c2415"; // Dark wood background
      ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

      // Draw wooden floor
      ctx.fillStyle = "#8b5a2b";
      ctx.fillRect(0, ctx.canvas.height - 150, ctx.canvas.width, 150);

      // Draw wooden beams
      ctx.fillStyle = "#4d2600";
      for (let i = 0; i < 5; i++) {
        ctx.fillRect(i * 200, 0, 20, ctx.canvas.height - 150);
      }

      // Draw bar counter
      ctx.fillStyle = "#6d4c41";
      ctx.fillRect(50, 200, 300, 50);
      ctx.fillRect(50, 250, 20, 200);
      ctx.fillRect(330, 250, 20, 200);

      // Draw bartender
      ctx.fillStyle = "#d7ccc8";
      ctx.fillRect(180, 150, 40, 50); // Head
      ctx.fillStyle = "#795548";
      ctx.fillRect(160, 200, 80, 100); // Body

      // Draw tavern title
      ctx.fillStyle = "#ffd700";
      ctx.font = "48px Arial";
      ctx.textAlign = "center";
      ctx.fillText("TAVERN", ctx.canvas.width / 2, 80);

      // Draw exit door
      ctx.fillStyle = "#5d4037";
      ctx.fillRect(ctx.canvas.width - 100, ctx.canvas.height - 120, 70, 120);
      ctx.fillStyle = "#ffeb3b";
      ctx.font = "16px Arial";
      ctx.fillText("EXIT", ctx.canvas.width - 65, ctx.canvas.height - 60);

      // Draw NPC roster section
      this.renderNpcRoster(ctx);

      // Draw player
      const leader = this.getLeader();
      if (leader) {
        ctx.fillStyle = "#2196f3";
        ctx.fillRect(leader.x, leader.y - 50, 30, 50);
      }

      // Add click handler for exit door
      if (!this._tavernExitClickHandlerAdded) {
        this._tavernExitClickHandlerAdded = true;
        document.getElementById("cv").addEventListener("click", (e) => {
          if (Game.state.insideBuilding !== "tavern") return;

          const rect = e.target.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;

          // Check if exit door was clicked
          if (
            x >= ctx.canvas.width - 100 &&
            x <= ctx.canvas.width - 30 &&
            y >= ctx.canvas.height - 120 &&
            y <= ctx.canvas.height
          ) {
            if (
              window.PlatformInteractables &&
              typeof window.PlatformInteractables.exitBuilding === "function"
            ) {
              window.PlatformInteractables.exitBuilding();
            }
          }
        });
      }
    },

    // Render Arcade interior overlay
    renderArcadeOverlay(ctx) {
      // Draw arcade background
      ctx.fillStyle = "#1a1a2e"; // Dark blue background
      ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

      // Draw neon grid floor
      ctx.strokeStyle = "#4361ee";
      ctx.lineWidth = 2;
      for (let i = 0; i < ctx.canvas.width; i += 50) {
        ctx.beginPath();
        ctx.moveTo(i, 0);
        ctx.lineTo(i, ctx.canvas.height);
        ctx.stroke();
      }
      for (let i = 0; i < ctx.canvas.height; i += 50) {
        ctx.beginPath();
        ctx.moveTo(0, i);
        ctx.lineTo(ctx.canvas.width, i);
        ctx.stroke();
      }

      // Draw arcade title
      ctx.fillStyle = "#ff9f1c";
      ctx.font = "48px Arial";
      ctx.textAlign = "center";
      ctx.fillText("ARCADE", ctx.canvas.width / 2, 80);

      // Draw exit door
      ctx.fillStyle = "#3a0ca3";
      ctx.fillRect(ctx.canvas.width - 100, ctx.canvas.height - 120, 70, 120);
      ctx.fillStyle = "#f72585";
      ctx.font = "16px Arial";
      ctx.fillText("EXIT", ctx.canvas.width - 65, ctx.canvas.height - 60);

      // Draw arcade machines
      this.renderArcadeMachines(ctx);

      // Draw player
      const leader = this.getLeader();
      if (leader) {
        ctx.fillStyle = "#2196f3";
        ctx.fillRect(leader.x, leader.y - 50, 30, 50);
      }

      // Draw RPS dialog if active
      this.drawRpsDialog(ctx);

      // Add click handler for exit door
      if (!this._arcadeExitClickHandlerAdded) {
        this._arcadeExitClickHandlerAdded = true;
        document.getElementById("cv").addEventListener("click", (e) => {
          if (Game.state.insideBuilding !== "arcade") return;

          const rect = e.target.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;

          // Check if exit door was clicked
          if (
            x >= ctx.canvas.width - 100 &&
            x <= ctx.canvas.width - 30 &&
            y >= ctx.canvas.height - 120 &&
            y <= ctx.canvas.height
          ) {
            if (
              window.PlatformInteractables &&
              typeof window.PlatformInteractables.exitBuilding === "function"
            ) {
              window.PlatformInteractables.exitBuilding();
            }
          }
        });
      }
    },

    // Render arcade machines for minigames
    renderArcadeMachines(ctx) {
      if (!window.ShopMinigames) {
        ctx.fillStyle = "#ff6b6b";
        ctx.font = "24px Arial";
        ctx.textAlign = "center";
        ctx.fillText("Arcade Games Unavailable", ctx.canvas.width / 2, 250);
        return;
      }

      // Define arcade machines
      const machines = [
        {
          id: "rps",
          name: "Rock Paper Scissors",
          x: 200,
          y: 200,
          width: 180,
          height: 250,
          color: "#f72585",
          game: "rockPaperScissors",
        },
        {
          id: "slots",
          name: "High-Stakes Slots",
          x: 500,
          y: 200,
          width: 180,
          height: 250,
          color: "#4cc9f0",
          game: "slotMachine",
        },
        {
          id: "hol",
          name: "Higher or Lower",
          x: 800,
          y: 200,
          width: 180,
          height: 250,
          color: "#4361ee",
          game: "higherOrLower",
        },
      ];

      // Draw each machine
      machines.forEach((machine) => {
        // Machine cabinet
        ctx.fillStyle = machine.color;
        ctx.fillRect(machine.x, machine.y, machine.width, machine.height);

        // Screen
        ctx.fillStyle = "#000000";
        ctx.fillRect(
          machine.x + 20,
          machine.y + 30,
          machine.width - 40,
          machine.height - 100
        );

        // Controls
        ctx.fillStyle = "#ffff00";
        ctx.fillRect(machine.x + 40, machine.y + machine.height - 60, 30, 30); // Button 1
        ctx.fillRect(
          machine.x + machine.width - 70,
          machine.y + machine.height - 60,
          30,
          30
        ); // Button 2

        // Machine name
        ctx.fillStyle = "#ffffff";
        ctx.font = "18px Arial";
        ctx.textAlign = "center";
        ctx.fillText(
          machine.name,
          machine.x + machine.width / 2,
          machine.y + 20
        );

        // Game-specific UI elements
        if (machine.game === "rockPaperScissors") {
          // Draw RPS symbols on screen
          ctx.fillStyle = "#ffffff";
          ctx.font = "24px Arial";
          ctx.fillText(
            "✊ ✋ ✌️",
            machine.x + machine.width / 2,
            machine.y + 80
          );

          // Cost display
          ctx.font = "16px Arial";
          ctx.fillText(
            "500 Gold / Play",
            machine.x + machine.width / 2,
            machine.y + 120
          );

          // Win display
          ctx.fillStyle = "#4ecdc4";
          ctx.fillText(
            "Win up to 100,000 Gold!",
            machine.x + machine.width / 2,
            machine.y + 150
          );
        } else if (machine.game === "slotMachine") {
          // Draw slot symbols
          ctx.fillStyle = "#ffffff";
          ctx.font = "24px Arial";
          ctx.fillText(
            "🍒 🎰 🔔",
            machine.x + machine.width / 2,
            machine.y + 80
          );

          // Cost display
          ctx.font = "16px Arial";
          ctx.fillText(
            "10,000 Gold / Spin",
            machine.x + machine.width / 2,
            machine.y + 120
          );

          // Jackpot display
          ctx.fillStyle = "#ffd700";
          ctx.fillText(
            "JACKPOT: 700,000 Gold!",
            machine.x + machine.width / 2,
            machine.y + 150
          );
        } else if (machine.game === "higherOrLower") {
          // Draw card symbols
          ctx.fillStyle = "#ffffff";
          ctx.font = "24px Arial";
          ctx.fillText("🂡 🂮 🃏", machine.x + machine.width / 2, machine.y + 80);

          // Coming soon
          ctx.fillStyle = "#ffaa00";
          ctx.font = "16px Arial";
          ctx.fillText(
            "Coming Soon!",
            machine.x + machine.width / 2,
            machine.y + 120
          );
        }

        // Play button
        ctx.fillStyle = "#4caf50";
        ctx.fillRect(
          machine.x + 30,
          machine.y + machine.height - 100,
          machine.width - 60,
          30
        );
        ctx.fillStyle = "#ffffff";
        ctx.font = "16px Arial";
        ctx.fillText(
          "PLAY",
          machine.x + machine.width / 2,
          machine.y + machine.height - 80
        );

        // Store machine data for click handling
        if (!this._arcadeMachines) this._arcadeMachines = [];
        this._arcadeMachines.push({
          id: machine.id,
          game: machine.game,
          playButton: {
            x: machine.x + 30,
            y: machine.y + machine.height - 100,
            width: machine.width - 60,
            height: 30,
          },
        });
      });

      // Add click handler for playing games
      if (!this._arcadeClickHandlerAdded) {
        this._arcadeClickHandlerAdded = true;
        document.getElementById("cv").addEventListener("click", (e) => {
          if (Game.state.insideBuilding !== "arcade" || !this._arcadeMachines)
            return;

          const rect = e.target.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;

          for (const machine of this._arcadeMachines) {
            const btn = machine.playButton;
            if (
              x >= btn.x &&
              x <= btn.x + btn.width &&
              y >= btn.y &&
              y <= btn.y + btn.height
            ) {
              if (
                window.ShopMinigames &&
                typeof window.ShopMinigames[machine.game] === "function"
              ) {
                if (machine.game === "rockPaperScissors") {
                  // For RPS, show a choice dialog
                  this.showRpsChoiceDialog();
                } else {
                  // For other games, call directly
                  window.ShopMinigames[machine.game]();
                }
              }
              break;
            }
          }
        });
      }
    },

    // Show Rock Paper Scissors choice dialog
    showRpsChoiceDialog() {
      // Clear any existing dialog
      this._rpsDialogActive = true;

      // Add one-time click handler for RPS choice
      const handleRpsChoice = (e) => {
        if (!this._rpsDialogActive) return;

        const rect = e.target.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const cv = document.getElementById("cv");
        const centerX = cv.width / 2;
        const centerY = cv.height / 2;

        // Check which choice was clicked
        if (y >= centerY - 50 && y <= centerY + 50) {
          if (x >= centerX - 180 && x <= centerX - 80) {
            // Rock
            window.ShopMinigames.rockPaperScissors("rock");
            this._rpsDialogActive = false;
          } else if (x >= centerX - 50 && x <= centerX + 50) {
            // Paper
            window.ShopMinigames.rockPaperScissors("paper");
            this._rpsDialogActive = false;
          } else if (x >= centerX + 80 && x <= centerX + 180) {
            // Scissors
            window.ShopMinigames.rockPaperScissors("scissors");
            this._rpsDialogActive = false;
          }
        }
      };

      document
        .getElementById("cv")
        .addEventListener("click", handleRpsChoice, { once: true });
    },

    // Draw RPS choice dialog during render if active
    drawRpsDialog(ctx) {
      if (!this._rpsDialogActive) return;

      // Semi-transparent background
      ctx.fillStyle = "rgba(0, 0, 0, 0.7)";
      ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

      // Dialog box
      ctx.fillStyle = "#2c3e50";
      ctx.fillRect(
        ctx.canvas.width / 2 - 250,
        ctx.canvas.height / 2 - 150,
        500,
        300
      );
      ctx.strokeStyle = "#3498db";
      ctx.lineWidth = 4;
      ctx.strokeRect(
        ctx.canvas.width / 2 - 250,
        ctx.canvas.height / 2 - 150,
        500,
        300
      );

      // Title
      ctx.fillStyle = "#ffffff";
      ctx.font = "24px Arial";
      ctx.textAlign = "center";
      ctx.fillText(
        "Choose Your Move",
        ctx.canvas.width / 2,
        ctx.canvas.height / 2 - 100
      );

      // Options
      const centerX = ctx.canvas.width / 2;
      const centerY = ctx.canvas.height / 2;

      // Rock
      ctx.fillStyle = "#e74c3c";
      ctx.fillRect(centerX - 180, centerY - 50, 100, 100);
      ctx.fillStyle = "#ffffff";
      ctx.font = "20px Arial";
      ctx.fillText("ROCK", centerX - 130, centerY - 10);
      ctx.font = "36px Arial";
      ctx.fillText("✊", centerX - 130, centerY + 30);

      // Paper
      ctx.fillStyle = "#3498db";
      ctx.fillRect(centerX - 50, centerY - 50, 100, 100);
      ctx.fillStyle = "#ffffff";
      ctx.font = "20px Arial";
      ctx.fillText("PAPER", centerX, centerY - 10);
      ctx.font = "36px Arial";
      ctx.fillText("✋", centerX, centerY + 30);

      // Scissors
      ctx.fillStyle = "#2ecc71";
      ctx.fillRect(centerX + 80, centerY - 50, 100, 100);
      ctx.fillStyle = "#ffffff";
      ctx.font = "20px Arial";
      ctx.fillText("SCISSORS", centerX + 130, centerY - 10);
      ctx.font = "36px Arial";
      ctx.fillText("✌️", centerX + 130, centerY + 30);
    },

    // Render NPC roster for hiring
    renderNpcRoster(ctx) {
      if (
        !window.PlatformInteractables ||
        !window.PlatformInteractables.NPC_ROSTER
      ) {
        ctx.fillStyle = "#ff6b6b";
        ctx.font = "24px Arial";
        ctx.textAlign = "center";
        ctx.fillText("NPC System Unavailable", ctx.canvas.width / 2, 250);
        return;
      }

      const roster = window.PlatformInteractables.NPC_ROSTER;
      const npcIds = Object.keys(roster);

      // Draw section title
      ctx.fillStyle = "#ffffff";
      ctx.font = "32px Arial";
      ctx.textAlign = "center";
      ctx.fillText("Hire Mercenaries", ctx.canvas.width / 2, 150);

      // Draw NPC cards in a grid
      const startX = 400;
      const startY = 200;
      const cardWidth = 160;
      const cardHeight = 180;
      const cardsPerRow = 3;

      npcIds.forEach((npcId, index) => {
        const npc = roster[npcId];
        const row = Math.floor(index / cardsPerRow);
        const col = index % cardsPerRow;
        const x = startX + col * (cardWidth + 20);
        const y = startY + row * (cardHeight + 20);

        // Draw card background based on rank
        let cardColor;
        switch (npc.rank) {
          case "S":
            cardColor = "#ffd700";
            break; // Gold
          case "A":
            cardColor = "#c0c0c0";
            break; // Silver
          case "B":
            cardColor = "#cd7f32";
            break; // Bronze
          default:
            cardColor = "#a1887f";
            break; // Common
        }

        // Card background
        ctx.fillStyle = cardColor;
        ctx.fillRect(x, y, cardWidth, cardHeight);

        // Card border
        ctx.strokeStyle = "#000000";
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, cardWidth, cardHeight);

        // NPC name
        ctx.fillStyle = "#000000";
        ctx.font = "16px Arial";
        ctx.textAlign = "center";
        ctx.fillText(npc.name, x + cardWidth / 2, y + 25);

        // NPC rank
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(x + 10, y + 35, 30, 30);
        ctx.fillStyle = "#000000";
        ctx.font = "bold 20px Arial";
        ctx.fillText(npc.rank, x + 25, y + 58);

        // NPC cost
        ctx.fillStyle = "#ffffff";
        ctx.font = "14px Arial";
        ctx.fillText(
          `${npc.cost.toLocaleString()} Gold`,
          x + cardWidth / 2,
          y + 80
        );

        // NPC skills
        ctx.font = "12px Arial";
        ctx.textAlign = "left";
        npc.skills.forEach((skill, i) => {
          ctx.fillText(`• ${skill}`, x + 10, y + 105 + i * 18);
        });

        // Hire button
        ctx.fillStyle = "#4caf50";
        ctx.fillRect(x + 20, y + cardHeight - 30, cardWidth - 40, 20);
        ctx.fillStyle = "#ffffff";
        ctx.textAlign = "center";
        ctx.font = "14px Arial";
        ctx.fillText("HIRE", x + cardWidth / 2, y + cardHeight - 15);

        // Make the button clickable
        if (!this._npcButtons) this._npcButtons = [];
        this._npcButtons.push({
          id: npcId,
          x: x + 20,
          y: y + cardHeight - 30,
          width: cardWidth - 40,
          height: 20,
        });
      });

      // Add click handler for NPC hiring
      if (!this._npcClickHandlerAdded) {
        this._npcClickHandlerAdded = true;
        document.getElementById("cv").addEventListener("click", (e) => {
          if (Game.state.insideBuilding !== "tavern" || !Game._npcButtons)
            return;

          const rect = e.target.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;

          for (const btn of Game._npcButtons) {
            if (
              x >= btn.x &&
              x <= btn.x + btn.width &&
              y >= btn.y &&
              y <= btn.y + btn.height
            ) {
              if (
                window.PlatformInteractables &&
                typeof window.PlatformInteractables.hireNpc === "function"
              ) {
                window.PlatformInteractables.hireNpc(btn.id);
              }
              break;
            }
          }
        });
      }
    },

    // Render map selection
    // renderMapSelection(ctx) {  // DISABLED - Map selection not needed
    //   ctx.fillStyle = "#0f1419";
    //   ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);

    //   ctx.fillStyle = "#ffffff";
    //   ctx.font = "36px Arial";
    //   ctx.textAlign = "center";
    //   ctx.fillText("SELECT BATTLEFIELD", ctx.canvas.width / 2, 80);

    //   // Draw map options
    //   if (!Game.state.availableMaps || !Array.isArray(Game.state.availableMaps))
    //     return;
    //   Game.state.availableMaps.forEach((map, i) => {
    //     const y = 150 + i * 80;
    //     ctx.font = "24px Arial";
    //     ctx.fillStyle = "#ffaa00";
    //     ctx.fillText(`${i + 1}. ${map.name}`, ctx.canvas.width / 2, y);

    //     ctx.font = "16px Arial";
    //     ctx.fillStyle = "#888888";
    //     ctx.fillText(
    //       `Difficulty: ${map.difficulty}`,
    //       ctx.canvas.width / 2,
    //       y + 25
    //     );
    //   });

    //   ctx.font = "18px Arial";
    //   ctx.fillStyle = "#ffffff";
    //   ctx.fillText(
    //     "Press 1-4 to select, ESC to return",
    //     ctx.canvas.width / 2,
    //     550
    //   );
    // },

    // Render battle
    // === RENDERING MODULE ===
    renderBattle(ctx) {
      const V = typeof window !== "undefined" ? window.VFX : null;
      this.renderer.drawBackground(ctx);

      ctx.save();
      if (V?.Camera?.apply) {
        const cam = Game.getCameraState
          ? Game.getCameraState()
          : { x: 0, y: 0, zoom: 1 };
        V.Camera.apply(ctx, cam);
      }
      this.renderer.drawWorld(ctx);
      ctx.restore();

      if (V) {
        try {
          V.drawOverlays?.(
            ctx,
            typeof performance !== "undefined" ? performance.now() : Date.now()
          );
          V.Post?.run?.();
        } catch (err) {
          console.error("[VFX] overlay error", err);
        }
      }

      this.renderer.drawHud(ctx);
    },

    getCameraState() {
      const cam = (Game.state && Game.state.camera) || {};
      return {
        x: cam.x || 0,
        y: cam.y || 0,
        zoom: cam.zoom || 1,
      };
    },

    renderer: {
      drawBackground(ctx) {
        const mapBg = Game.getMapBackground();
        if (mapBg) {
          ctx.fillStyle = mapBg;
          ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        }
      },

      drawWorld(ctx) {
        Game.drawPlayers(ctx);
        Game.drawNpcs(ctx);
        Game.drawEnemies(ctx);
        Game.drawProjectiles(ctx);
        Game.drawEffects(ctx);
        Game.drawPickups(ctx);
        Game.drawBuildings(ctx);
      },

      drawHud(ctx) {
        Game.drawUI(ctx);
      },
    },

    // === UPDATE MODULE ===
    updater: {
      updateEnemies(dt) {
        /* Enemy update logic */
      },

      updateProjectiles(dt) {
        const st = Game.state || (Game.state = {});
        st.projectiles = st.projectiles || [];
        const list = st.projectiles;
        const dtSec = Math.max(
          0.008,
          (typeof dt === "number" ? dt : 16) / 1000
        );
        const now = performance.now ? performance.now() : Date.now();
        for (let i = list.length - 1; i >= 0; i--) {
          const p = list[i];
          if (now - p.birth > p.life) {
            list.splice(i, 1);
            continue;
          }
          const hasCustomUpdate = typeof p.update === "function";
          if (hasCustomUpdate) {
            try {
              p.update(dtSec * 1000);
            } catch (err) {
              console.error("[Projectiles] update error", err);
            }
            if (p.dead) {
              list.splice(i, 1);
            }
            continue;
          }

          // integrate default projectiles
          p.vx = p.vx || 0;
          p.vy = p.vy || 0;
          p.x += p.vx * dtSec;
          p.y += p.vy * dtSec;
          if (p.dead) {
            list.splice(i, 1);
            continue;
          }

          // collision (simple AoE)
          const enemies = Game.state?.enemies || [];
          const rad = p.radius || 16;
          const rad2 = rad * rad;
          for (const e of enemies) {
            if (!e || e.dead || e.hp <= 0) continue;
            const dx = (e.x || 0) - p.x;
            const dy = (e.y || 0) - p.y;
            if (dx * dx + dy * dy <= rad2) {
              e.hp -= p.dmg || 40;
              if (e.hp <= 0) {
                e.dead = true;
                try {
                  window.killEnemy?.(e);
                } catch (_) {}
              }
              if (!p.pierce || --p.pierce <= 0) {
                list.splice(i, 1);
                break;
              }
            }
          }
        }
      },

      updateEffects(dt) {
        try {
          if (window.VFX?.update) window.VFX.update(dt * 1000);
        } catch (err) {
          console.error("[VFX] update error", err);
        }
      },

      updateUI() {
        /* UI update logic */
      },
    },

    // === STATS & GEAR MODULE ===
    statsManager: {
      recalculateStats(player) {
        const stats = this.getBaseStats(player);
        this.applyGearBonuses(stats);
        this.applyTalentBonuses(stats);

        player._effectiveStats = stats;
        if (player.hp > stats.hpMax) player.hp = stats.hpMax;
      },

      getBaseStats(player) {
        return {
          hpMax: player.hpMax,
          dmgBase: player.dmgBase,
          def: player.def,
          aura: player.aura,
          luck: player.luck,
        };
      },

      applyGearBonuses(stats) {
        const gear = Game.state.equippedGear || {};
        Object.values(gear).forEach((item) => {
          if (item?.bonuses) {
            Object.entries(item.bonuses).forEach(([k, v]) => {
              stats[k] = (stats[k] || 0) + (v || 0);
            });
          }
        });
      },

      applyTalentBonuses(stats) {
        const tStats = Game.state._talentStats || {};
        Object.entries(tStats).forEach(([k, v]) => {
          stats[k] = (stats[k] || 0) + (v || 0);
        });
      },
    },

    // Gear management
    equipGear(slot, item, playerIndex = Game.state.leader) {
      Game.state.equippedGear[slot] = item;
      const player = Game.state.players[playerIndex];
      this.statsManager.recalculateStats(player);
      return true;
    },

    unequipGear(slot, playerIndex = Game.state.leader) {
      Game.state.equippedGear[slot] = null;
      const player = Game.state.players[playerIndex];
      this.statsManager.recalculateStats(player);
      return true;
    },
    autoEquipBestGear(silent = false) {
      const st = Game.state;
      if (!Array.isArray(st.inv)) {
        if (!silent)
          console.warn("[Game.autoEquipBestGear] Inventory missing.");
        return false;
      }

      const inventory = st.inv;
      const equipped = st.equippedGear || (st.equippedGear = {});
      const slots = [
        "weapon",
        "weapon2",
        "armor",
        "acc1",
        "acc2",
        "pet",
        "vehicle",
      ];
      const score = (item) => {
        if (!item) return -1;
        const atk = Number(item.atk || 0);
        const def = Number(item.def || 0);
        const level = Number(item.level || 0);
        return atk * 1.2 + def + level;
      };
      const acceptsSlot = (slot, itemSlot) => {
        if (slot === "weapon2")
          return itemSlot === "weapon" || itemSlot === "weapon2";
        if (slot === "acc1" || slot === "acc2")
          return (
            itemSlot === "acc1" ||
            itemSlot === "acc2" ||
            itemSlot === "accessory"
          );
        return slot === itemSlot;
      };

      let equippedCount = 0;

      for (let i = 0; i < slots.length; i++) {
        const slot = slots[i];

        const candidates = inventory.filter((item) => {
          if (!item) return false;
          const itemSlot = item.slot || item.type;
          return acceptsSlot(slot, itemSlot);
        });
        if (!candidates.length) continue;

        const bestCandidate = candidates.reduce((best, item) =>
          score(item) > score(best) ? item : best
        );

        const current = equipped[slot];
        if (score(bestCandidate) <= score(current)) continue;

        if (current) inventory.push(current);
        equipped[slot] = bestCandidate;

        const idx = inventory.indexOf(bestCandidate);
        if (idx >= 0) inventory.splice(idx, 1);

        equippedCount++;
      }

      if (equippedCount > 0) {
        Game.state.players.forEach((player) => Game.recalculateStats(player));
        if (Game.state.bagOpen) Game.renderBag();
        if (!silent) {
          try {
            window.notify?.(
              `Auto-equipped ${equippedCount} item(s).`,
              "#4ecdc4"
            );
          } catch (_) {
            console.log(
              `[Game.autoEquipBestGear] Equipped ${equippedCount} items.`
            );
          }
        }
        return true;
      }

      if (!silent) {
        try {
          window.notify?.("No better gear to equip.", "#ffaa00");
        } catch (_) {
          console.log("[Game.autoEquipBestGear] No upgrades found.");
        }
      }
      return false;
    },

    // === COMBAT MODULE ===
    combat: {
      useSkill(playerId, skillId) {
        const cds = Game.state.cds[playerId];
        if (!cds) return false;
        const skill = Game.skillBook[playerId]?.[skillId];
        if (!skill) return false;
        if (cds[skillId] > 0) return false;
        cds[skillId] = skill.cooldown;
        return true;
      },

      calculateDamage(attacker, target, damageMultiplier = 1) {
        const a = attacker._effectiveStats || attacker;
        const base = (a.dmgBase || 1) * damageMultiplier;
        const critChance = Math.min(0.5, (a.luck || 0) / 100);
        const isCrit = Math.random() < critChance;
        const raw = base * (isCrit ? 2 : 1);
        const def = target?.def || 0;
        const mitigation = 1 - def / (def + 100);
        return Math.max(1, Math.floor(raw * mitigation));
      },
    },

    // === LOOT MODULE ===
    loot: {
      defaultTable: [
        { type: "Gold", chance: 0.85, min: 50, max: 150 },
        { type: "Silver", chance: 0.7, min: 40, max: 120 },
        { type: "Gem", chance: 0.3, min: 1, max: 3 },
        { type: "GiftKey", chance: 0.2, min: 1, max: 1 },
      ],

      dropLoot(enemy) {
        const lootTable = enemy?.lootTable || this.defaultTable;
        const x = enemy?.x ?? 300;
        const y = enemy?.y ?? 300;
        const newPickups = [];

        lootTable.forEach((drop) => {
          if (Math.random() < drop.chance) {
            const amt = drop.min
              ? Math.floor(Math.random() * (drop.max - drop.min + 1)) + drop.min
              : 1;
            newPickups.push(Game.createResourceBox(drop.type, amt, x, y));
          }
        });

        if (newPickups.length > 0) {
          Game.state.pickups.push(...newPickups);
        }
      },
    },

    // === CORE SYSTEM ===
    coreSystem: {
      DARK: {
        id: "dark",
        icon: "⚫",
        name: "Dark Core",
        rank: "SSS",
        passive: "HP drain for true dmg. 10% chance to spawn A1 clone on kill.",
        effects: {
          trueDmg: 35,
          hpDrain: 8,
          cloneChance: 10,
          cloneMaxCount: 3,
          cloneDuration: 15000,
        },
      },
      LIGHT: {
        id: "light",
        icon: "⭐",
        name: "Light Core",
        rank: "SSS",
        passive: "Heal aura and auto-revive.",
        effects: { hpRegen: 3, autoReviveCD: 300, luckBonus: 75 },
      },
      GOLD: {
        id: "gold",
        icon: "💰",
        name: "Gold Core",
        rank: "S",
        passive: "+100% gold.",
      },
      ELEMENTAL: {
        id: "elemental",
        icon: "🔥",
        name: "Elemental Core",
        rank: "S",
        passive: "Cycle fire/ice/lightning",
      },
      GADGET: {
        id: "gadget",
        icon: "⚙️",
        name: "Gadget Core",
        rank: "S",
        passive: "-12% CD, turret, overclock",
      },
      BEAST: {
        id: "beast",
        icon: "🐾",
        name: "Beast Core",
        rank: "S",
        passive: "+pet dmg/hp, wolves, roar",
      },
      CRYSTAL: {
        id: "crystal",
        icon: "💎",
        name: "Crystal Core",
        rank: "A",
        passive: "+armor, barrier",
      },
      CHAOS: {
        id: "chaos",
        icon: "🌀",
        name: "Chaos Core",
        rank: "A",
        passive: "Random bonus on cast",
      },
    },

    drawEnemies(ctx) {
      if (typeof window.drawAdvancedEnemies === "function") {
        window.drawAdvancedEnemies(ctx);
      }
    },
    drawProjectiles(ctx) {
      const st = Game.state || (Game.state = {});
      const list = st.projectiles || [];
      const now = performance.now ? performance.now() : Date.now();
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      for (const p of list) {
        const life = Math.max(0, 1 - (now - p.birth) / p.life);
        if (life <= 0) continue;
        ctx.globalAlpha = Math.max(0.1, life);
        if (p.type === "beam") {
          // draw beam as rotated rect with inner core
          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(p.dir || 0);
          const w = p.length || 320;
          const th = p.thickness || 16;
          ctx.fillStyle = p.color || "#6aa8ff";
          ctx.fillRect(0, -th / 2, w, th);
          ctx.globalAlpha = life * 0.6;
          ctx.fillStyle = p.core || "#e9f4ff";
          ctx.fillRect(0, -th * 0.25, w, th * 0.5);
          ctx.restore();
        } else if (p.type === "slash") {
          // X slash
          ctx.strokeStyle = p.color || "#ff6b6b";
          ctx.lineWidth = p.size * 0.18;
          ctx.beginPath();
          ctx.moveTo(p.x - p.size * 0.5, p.y - p.size * 0.5);
          ctx.lineTo(p.x + p.size * 0.5, p.y + p.size * 0.5);
          ctx.moveTo(p.x + p.size * 0.5, p.y - p.size * 0.5);
          ctx.lineTo(p.x - p.size * 0.5, p.y + p.size * 0.5);
          ctx.stroke();
        } else if (p.type === "shard") {
          // diamond shard
          ctx.fillStyle = p.color || "#74b9ff";
          ctx.beginPath();
          ctx.moveTo(p.x, p.y - p.size);
          ctx.lineTo(p.x + p.size * 0.5, p.y);
          ctx.lineTo(p.x, p.y + p.size);
          ctx.lineTo(p.x - p.size * 0.5, p.y);
          ctx.closePath();
          ctx.fill();
        }
      }
      ctx.restore();
    },
    drawEffects(ctx) {
      /* Effect drawing logic */
    },
    drawUI(ctx) {
      /* UI drawing logic */
    },

    // Draw interactive buildings
    drawBuildings(ctx) {
      const buildings = (Game.state.interactables || []).filter(
        (b) => b.type === "building"
      );

      // Debug logging
      console.log("Drawing buildings:", buildings.length, "buildings found");
      if (Game.state.interactables) {
        console.log("All interactables:", Game.state.interactables);
      }

      if (!buildings.length) {
        console.log(
          "No buildings to draw, interactables array:",
          Game.state.interactables
        );

        // EMERGENCY FALLBACK: Create a test building to ensure something is visible
        console.log("Creating emergency test building");
        const testBuilding = {
          id: "test_building",
          type: "building",
          x: 600,
          y: 400,
          width: 200,
          height: 150,
          label: "TEST BUILDING",
          color: "#FF0000",
          strokeColor: "#FFFFFF",
          roofColor: "#AA0000",
          doorColor: "#000000",
          windowColor: "#FFFF00",
        };
        buildings.push(testBuilding);
        Game.state.interactables.push(testBuilding);
      }

      ctx.save();

      for (const building of buildings) {
        // Use colors from building data or defaults
        const color = building.color || "#8B4513";
        const strokeColor = building.strokeColor || "#D2691E";
        const roofColor = building.roofColor || "#A52A2A";
        const doorColor = building.doorColor || "#4d2600";

        ctx.fillStyle = color;
        ctx.strokeStyle = strokeColor;
        ctx.lineWidth = 4;

        // Main building
        ctx.fillRect(
          building.x,
          building.y - building.height,
          building.width,
          building.height
        );
        ctx.strokeRect(
          building.x,
          building.y - building.height,
          building.width,
          building.height
        );

        // Draw the building based on its type
        if (building.id === "tavern") {
          // Triangular roof
          ctx.fillStyle = roofColor;
          ctx.beginPath();
          ctx.moveTo(building.x - 10, building.y - building.height);
          ctx.lineTo(
            building.x + building.width / 2,
            building.y - building.height - 40
          );
          ctx.lineTo(
            building.x + building.width + 10,
            building.y - building.height
          );
          ctx.closePath();
          ctx.fill();
          ctx.stroke();

          // Door
          ctx.fillStyle = doorColor;
          ctx.fillRect(
            building.x + building.width / 2 - 15,
            building.y - 40,
            30,
            40
          );

          // Windows
          ctx.fillStyle = building.windowColor || "#FFF8DC";
          ctx.fillRect(
            building.x + 20,
            building.y - building.height + 20,
            25,
            25
          );
          ctx.fillRect(
            building.x + building.width - 45,
            building.y - building.height + 20,
            25,
            25
          );
        } else if (building.id === "arcade") {
          // Dome roof
          ctx.fillStyle = roofColor;
          ctx.beginPath();
          ctx.ellipse(
            building.x + building.width / 2,
            building.y - building.height,
            building.width / 2,
            30,
            0,
            Math.PI,
            0,
            true
          );
          ctx.fill();
          ctx.stroke();

          // Door
          ctx.fillStyle = doorColor;
          ctx.fillRect(
            building.x + building.width / 2 - 15,
            building.y - 40,
            30,
            40
          );

          // Neon sign
          ctx.fillStyle = building.neonColor || "#FF1493";
          ctx.fillRect(
            building.x + 10,
            building.y - building.height - 20,
            building.width - 20,
            15
          );
        } else if (building.id === "test_building") {
          // Test building - simple rectangular building
          ctx.fillStyle = roofColor;
          ctx.fillRect(
            building.x,
            building.y - building.height - 20,
            building.width,
            20
          );

          // Door
          ctx.fillStyle = doorColor;
          ctx.fillRect(
            building.x + building.width / 2 - 20,
            building.y - 50,
            40,
            50
          );

          // Windows
          ctx.fillStyle = building.windowColor || "#FFFF00";
          ctx.fillRect(
            building.x + 20,
            building.y - building.height + 30,
            30,
            30
          );
          ctx.fillRect(
            building.x + building.width - 50,
            building.y - building.height + 30,
            30,
            30
          );
        }

        // Draw label above building
        ctx.fillStyle = "#FFFFFF";
        ctx.font = "16px Arial";
        ctx.textAlign = "center";
        ctx.fillText(
          building.label,
          building.x + building.width / 2,
          building.y - building.height - 50
        );

        // Draw "Press E to Enter" when player is nearby
        const leader = Game.getLeader();
        if (leader) {
          const dx = Math.abs(leader.x - (building.x + building.width / 2));
          const dy = Math.abs(leader.y - building.y);
          if (dx < 100 && dy < 80) {
            ctx.fillStyle = "#FFFF00";
            ctx.font = "14px Arial";
            ctx.fillText(
              "Press E to Enter",
              building.x + building.width / 2,
              building.y - building.height - 30
            );
          }
        }
      }

      ctx.restore();
    },

    // Update hired NPCs
    updateNpcs(dt) {
      const npcs = this.state.party || [];
      if (!npcs.length) return;

      const leader = this.getLeader();
      if (!leader) return;

      // Target the closest enemy
      const findClosestEnemy = (npc) => {
        const enemies = this.state.enemies || [];
        if (!enemies.length) return null;

        let closest = null;
        let closestDist = Infinity;

        for (const enemy of enemies) {
          if (!enemy || enemy.hp <= 0) continue;

          const dx = enemy.x - npc.x;
          const dy = enemy.y - npc.y;
          const dist = Math.sqrt(dx * dx + dy * dy);

          if (dist < closestDist) {
            closest = enemy;
            closestDist = dist;
          }
        }

        return closest;
      };

      // Update each NPC
      for (const npc of npcs) {
        if (npc.type !== "npc") continue;

        // Follow leader behavior
        const followDist = 100 + npcs.indexOf(npc) * 30; // Staggered following
        const dx = leader.x - npc.x;
        const dy = leader.y - npc.y;
        const distToLeader = Math.sqrt(dx * dx + dy * dy);

        // Initialize properties if needed
        npc.x = npc.x || leader.x - followDist;
        npc.y = npc.y || leader.y;
        npc.vx = npc.vx || 0;
        npc.vy = npc.vy || 0;
        npc._attackCooldown = npc._attackCooldown || 0;
        npc._gcdT = npc._gcdT || 0;
        npc.facingLeft = leader.facingLeft;

        // Move toward leader if too far
        if (distToLeader > followDist) {
          const speed = 150; // Movement speed
          const angle = Math.atan2(dy, dx);
          npc.vx = Math.cos(angle) * speed;
          npc.vy = Math.sin(angle) * speed;
        } else {
          // Slow down when close enough
          npc.vx *= 0.9;
          npc.vy *= 0.9;
        }

        // Apply velocity
        npc.x += npc.vx * dt;
        npc.y += npc.vy * dt;

        // Keep NPC on screen
        npc.x = Math.max(50, Math.min(this._canvas.width - 50, npc.x));
        npc.y = Math.max(50, Math.min(this._canvas.height - 50, npc.y));

        // Update renderer animation
        if (npc.renderer && npc.renderer.update) {
          npc.renderer.update(dt);
        }

        // Track movement state for animation
        npc._moving = Math.abs(npc.vx) > 1 || Math.abs(npc.vy) > 1;

        // Attack behavior
        if (npc._attackCooldown > 0) {
          npc._attackCooldown -= dt;
        } else {
          const target = findClosestEnemy(npc);
          if (target) {
            const attackRange = 200; // Attack range
            const dx = target.x - npc.x;
            const dy = target.y - npc.y;
            const distToTarget = Math.sqrt(dx * dx + dy * dy);

            if (distToTarget < attackRange) {
              // Attack the target
              const damage = npc.dmg || 100;
              target.hp -= damage;

              // Create visual effect for the attack
              this.state.effects.push({
                x: target.x,
                y: target.y,
                type: "hit",
                color: "#ff5722",
                size: 30,
                duration: 0.5,
                timer: 0.5,
              });

              // Show damage number
              if (typeof window.notify === "function") {
                window.notify(`${npc.name} hits for ${damage}`, "#ff9800");
              }

              // Set attack cooldown
              npc._attackCooldown = 2.0; // 2 seconds between attacks

              // Face the target
              npc.facingLeft = target.x < npc.x;
            }
          }
        }

        // Tick down global cooldown
        if (npc._gcdT > 0) {
          npc._gcdT -= dt;
        }
      }
    },

    // Draw hired NPCs
    drawNpcs(ctx) {
      const npcs = this.state.party || [];
      if (!npcs.length) return;

      ctx.save();

      for (const npc of npcs) {
        if (npc.type !== "npc") continue;

        // Determine color based on rank
        let color;
        switch (npc.rank) {
          case "S":
            color = "#ffd700";
            break; // Gold
          case "A":
            color = "#c0c0c0";
            break; // Silver
          case "B":
            color = "#cd7f32";
            break; // Bronze
          default:
            color = "#a1887f";
            break; // Common
        }

        // Initialize renderer if needed
        if (!npc.renderer && window.NPCCharacterRenderer) {
          const npcKey = (npc.name || "grunt").toLowerCase();
          npc.renderer = new window.NPCCharacterRenderer(npcKey, {
            rank: npc.rank,
            color: color,
          });
        }

        // Determine animation state
        const animState =
          npc._attackCooldown > 0 ? "attack" : npc._moving ? "run" : "idle";

        // Render NPC with procedural renderer
        if (npc.renderer) {
          npc.renderer.render(ctx, npc.x, npc.y - 25, {
            animState: animState,
            animTime: performance.now(),
            facingLeft: false,
          });
        } else {
          // Fallback rendering if renderer not available
          ctx.fillStyle = color;
          ctx.fillRect(npc.x - 15, npc.y - 50, 30, 50);
          ctx.fillStyle = "#f5f5f5";
          ctx.fillRect(npc.x - 12, npc.y - 70, 24, 20);
        }

        // Draw rank indicator
        ctx.fillStyle = "#000000";
        ctx.font = "bold 14px Arial";
        ctx.textAlign = "center";
        ctx.fillText(npc.rank, npc.x, npc.y - 55);

        // Draw name above
        ctx.fillStyle = "#ffffff";
        ctx.font = "12px Arial";
        ctx.fillText(npc.name, npc.x, npc.y - 80);

        // Draw health bar
        const healthPct = npc.hp / npc.hpMax;
        ctx.fillStyle = "#333333";
        ctx.fillRect(npc.x - 20, npc.y - 85, 40, 5);
        ctx.fillStyle =
          healthPct > 0.5
            ? "#4caf50"
            : healthPct > 0.25
            ? "#ff9800"
            : "#f44336";
        ctx.fillRect(npc.x - 20, npc.y - 85, 40 * healthPct, 5);

        // Draw attack cooldown indicator
        if (npc._attackCooldown > 0) {
          ctx.fillStyle = "#ff5722";
          ctx.beginPath();
          ctx.arc(npc.x, npc.y - 30, 5, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      ctx.restore();
    },

    // Draw pickups
    drawPickups(ctx) {
      const pickups = Game.state.pickups;
      if (!pickups.length) return;

      ctx.save();
      const typeColors = {
        Gold: "#ffd200",
        Silver: "#c0c0c0",
        Gem: "#4ef5ff",
        GiftKey: "#9b59b6",
        BossKey: "#e74c3c",
      };

      // Group pickups by type for batch rendering
      const groupedPickups = {};
      for (let i = 0; i < pickups.length; i++) {
        const pickup = pickups[i];
        const type = pickup.type || "unknown";
        if (!groupedPickups[type]) groupedPickups[type] = [];
        groupedPickups[type].push(pickup);
      }

      // Render each type in batches
      const typeKeys = Object.keys(groupedPickups);
      for (let i = 0; i < typeKeys.length; i++) {
        const type = typeKeys[i];
        const typePickups = groupedPickups[type];
        const color = typeColors[type] || "#ffffff";

        ctx.fillStyle = color;
        ctx.beginPath();
        for (let j = 0; j < typePickups.length; j++) {
          const p = typePickups[j];
          ctx.moveTo(p.x + 8, p.y);
          ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
        }
        ctx.fill();
      }

      ctx.restore();
    },

    // Cooldowns ticking for skills
    tickCooldowns(dt) {
      const cds = Game.state.cds;
      // Cache key arrays to avoid per-frame allocations
      if (!Game._cdKeyCache) Game._cdKeyCache = {};
      const cdKeyCache = Game._cdKeyCache;
      const playerIds = Object.keys(cds);
      for (let i = 0; i < playerIds.length; i++) {
        const pid = playerIds[i];
        const row = cds[pid];
        let skillKeys = cdKeyCache[pid];
        if (!skillKeys) {
          skillKeys = Object.keys(row);
          cdKeyCache[pid] = skillKeys;
        }
        for (let j = 0; j < skillKeys.length; j++) {
          const k = skillKeys[j];
          if (row[k] > 0) row[k] = Math.max(0, row[k] - dt);
        }
      }
    },

    // Resource box factory
    createResourceBox(type, amount, x, y) {
      return {
        id: `RB_${Date.now()}_${Math.random()}`,
        type,
        amount,
        x,
        y,
        vx: 0,
        vy: -30,
        ttl: 10,
      };
    },

    // Apply pickup effects
    collectPickup(p) {
      if (!p || !p.type) return false;

      try {
        switch (p.type) {
          case "Gold":
            Game.addGold(p.amount || 1);
            break;
          case "Silver":
            Game.addSilver(p.amount || 1);
            break;
          case "Gem":
            Game.addGems(p.amount || 1);
            break;
          case "GiftKey":
            Game.addGiftKeys(p.amount || 1);
            break;
          case "BossKey":
            Game.addBossKeys(p.amount || 1);
            break;
          default:
            Game.addItem(p.type);
        }
        return true;
      } catch (error) {
        console.warn("Pickup collection failed:", error.message);
        return false;
      }
    },

    // === WAVE PROGRESSION MODULE ===
    waveManager: {
      canSpawn() {
        if (Game.state.gameComplete || !Game.state.running) return false;

        const now = performance?.now() || Date.now();
        if (Game._lastSpawnAt && now - Game._lastSpawnAt < 200) return false;
        Game._lastSpawnAt = now;
        return true;
      },

      validateWaveState(area, stageInArea, wave) {
        return (
          area >= 1 &&
          area <= 100 &&
          stageInArea >= 1 &&
          stageInArea <= 2 &&
          wave >= 1 &&
          wave <= 9.5
        );
      },

      createBoss(area, stageInArea) {
        const hp = Math.min(50000, 800 + area * 50 + stageInArea * 200);
        const boss = {
          id: `boss_${area}_${stageInArea}`,
          x: 800,
          y: 300,
          vx: -20,
          vy: 0,
          hpMax: hp,
          hp: hp,
          dmg: Math.min(500, 30 + area * 4 + stageInArea * 10),
          type: "boss",
          kind: "boss",
          lastAttack: 0,
        };
        Game.state.enemies.push(boss);
        Game.state.bossAlive = true;
        console.log(
          `👹 Boss spawned for Area ${area} Stage ${stageInArea} (HP: ${hp})`
        );
      },

      spawnWave() {
        if (!this.canSpawn()) return;

        if (window.Waves?.spawnWaveForState) {
          window.Waves.spawnWaveForState(Game.state);
          return;
        }

        const { wave, area, stageInArea } = Game.state;
        if (!this.validateWaveState(area || 1, stageInArea || 1, wave)) {
          console.error(
            `Invalid area/stage/wave: ${area}/${stageInArea}/${wave}`
          );
          return;
        }

        if (wave === 9.5) {
          this.createBoss(area || 1, stageInArea || 1);
        } else {
          console.log(`Wave ${wave} - Boss-only system active`);
        }
      },

      checkProgress() {
        if (Game._progressingWave) return;
        if (!Game.state.running) return;

        if (Game.state.enemies.length === 0) {
          Game._progressingWave = true;

          const proceed = () => {
            try {
              if (!Game.state.running) return;

              if (window.__PROG95?.advanceProgression) {
                window.__PROG95.advanceProgression();
                this.spawnWave();
                return;
              }

              this.advanceFallbackProgression();
              this.spawnWave();
            } finally {
              Game._progressingWave = false;
            }
          };

          const delay = window.Waves?.nextWaveForState ? 100 : 100;
          setTimeout(proceed, delay);
        }
      },

      advanceFallbackProgression() {
        Game.state.wave++;
        if (Game.state.wave > 9.5) {
          Game.state.wave = 1;
          const stageInArea = Game.state.stageInArea || 1;
          const area = Game.state.area || 1;

          if (stageInArea >= 2) {
            Game.state.stageInArea = 1;
            Game.state.area = area + 1;

            if (Game.state.area > 100) {
              Game.state.gameComplete = true;
              Game.state.running = false;
              console.log("🎉 All 100 Areas Complete!");
              return;
            }
          } else {
            Game.state.stageInArea = 2;
          }

          console.log(
            `🎯 Area ${Game.state.area} Stage ${Game.state.stageInArea} begins!`
          );
        }
      },
    },

    // Legacy methods for compatibility
    spawnWave() {
      return this.waveManager.spawnWave();
    },
    checkWaveProgress() {
      return this.waveManager.checkProgress();
    },

    // Clone and Mini Pet integration
    spawnA1Clone(stance = "assault") {
      const leader = this.getLeader();
      if (leader && leader.id === "A1" && window.A1_CLONE_SYSTEM) {
        return window.A1_CLONE_SYSTEM.spawnClone(leader, stance);
      }
      return null;
    },

    spawnMiniPet(owner, petType = "companion") {
      if (owner && window.MINI_PET_SYSTEM) {
        return window.MINI_PET_SYSTEM.spawnMiniPet(owner, petType);
      }
      return null;
    },

    // Check for clone spawn on enemy kill
    checkCloneSpawn(killer) {
      if (killer && killer.id === "A1" && this.state._equippedCore === "dark") {
        if (window.A1_CLONE_SYSTEM) {
          window.A1_CLONE_SYSTEM.checkCloneSpawn(killer);
        }
      }
    },

    // Check for mini pet spawn on pet skill use
    checkMiniPetSpawn(owner, skillData) {
      if (
        owner &&
        skillData &&
        skillData.miniPetChance &&
        window.MINI_PET_SYSTEM
      ) {
        if (Math.random() < skillData.miniPetChance) {
          const petType = skillData.miniPetType || "companion";
          window.MINI_PET_SYSTEM.spawnMiniPet(owner, petType);
        }
      }
    },

    // Update pickups system
    updatePickups(dt) {
      const pickups = Game.state.pickups;
      for (let i = pickups.length - 1; i >= 0; i--) {
        const pickup = pickups[i];
        pickup.ttl -= dt;
        pickup.x += pickup.vx * dt;
        pickup.y += pickup.vy * dt;

        if (pickup.ttl <= 0) {
          pickups.splice(i, 1);
        }
      }
    },

    // Scroll/Skill equip system for bridge integration
    equipScroll(slot, scrollId) {
      const player = Game.getLeader();
      if (!player) return false;

      if (!player.scrolls) player.scrolls = {};
      player.scrolls[slot] = scrollId;

      console.log(
        `✨ ${player.id} equipped scroll ${scrollId} to slot ${slot}`
      );
      return true;
    },

    // Get equipped scroll for slot
    getEquippedScroll(slot, playerId = null) {
      const player = playerId
        ? Game.state.players.find((p) => p.id === playerId)
        : Game.getLeader();
      return player?.scrolls?.[slot] || null;
    },

    // === LEGACY COMPATIBILITY ===
    recalculateStats(player) {
      return this.statsManager.recalculateStats(player);
    },
    useSkill(playerId, skillId) {
      return this.combat.useSkill(playerId, skillId);
    },
    calculateDamage(attacker, target, mult) {
      return this.combat.calculateDamage(attacker, target, mult);
    },
    dropLoot(enemy) {
      return this.loot.dropLoot(enemy);
    },
    updateEnemies(dt) {
      return this.updater.updateEnemies(dt);
    },
    updateProjectiles(dt) {
      return this.updater.updateProjectiles(dt);
    },
    updateEffects(dt) {
      return this.updater.updateEffects(dt);
    },
    updateUI() {
      return this.updater.updateUI();
    },

    // Global access
    getState() {
      return Game.state;
    },
    getAssets() {
      return Game.state.assets;
    },

    // Core system integration
    equipCore(coreId) {
      this.state._equippedCore = coreId;
      window.EQUIPPED_CORE = coreId;
      console.log(`🔮 Equipped ${coreId} core`);
    },

    unequipCore() {
      this.state._equippedCore = null;
      window.EQUIPPED_CORE = null;
      console.log("🔮 Unequipped core");
    },

    // Clone stance management
    setCloneStance(stance) {
      if (["assault", "guard", "support"].includes(stance)) {
        this.state._cloneStance = stance;
        console.log(`⚔️ Clone stance set to ${stance}`);
      }
    },

    // === INTERACTIVE PLATFORM SYSTEM ===

    // Find nearby interactable objects (buildings, NPCs, etc.)
    findNearbyInteractables() {
      const leader = this.getLeader();
      if (!leader) return null;

      const interactables = this.state.interactables || [];
      let closest = null;
      let closestDist = Infinity;

      // Check buildings first (higher priority)
      for (const building of interactables.filter(
        (i) => i.type === "building"
      )) {
        const dx = Math.abs(leader.x - (building.x + building.width / 2));
        const dy = Math.abs(leader.y - building.y);
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < 100 && dist < closestDist) {
          closest = building;
          closestDist = dist;
        }
      }

      // If we found a building, return it
      if (closest) {
        return {
          target: closest,
          type: "building",
          action: "enter",
        };
      }

      // Check for other interactables here (NPCs, items, etc.)

      return null;
    },

    // Perform a universal action based on context
    performUniversalAction() {
      // First, find what we can interact with
      const actionContext = this.findNearbyInteractables();
      if (!actionContext) {
        notify("Nothing to interact with nearby.", "#ffaa00");
        return;
      }

      // Store the action context
      this.state.universalActionTarget = actionContext.target;
      this.state.universalActionType = actionContext.type;

      // Handle different action types
      if (actionContext.type === "building") {
        if (actionContext.action === "enter") {
          // Enter the building
          if (
            window.PlatformInteractables &&
            typeof window.PlatformInteractables.enterBuilding === "function"
          ) {
            window.PlatformInteractables.enterBuilding(actionContext.target.id);
          } else {
            notify("Building interaction not available.", "#ff6b6b");
          }
        }
      }
      // Add more action types as needed
    },

    // Handle key press for universal action (E key)
    handleUniversalActionKey() {
      this.performUniversalAction();
    },

    // Test function to manually create buildings
    testBuildings() {
      console.log("🧪 Testing building system...");
      this.setupInteractiveBuildings();
      console.log(
        "Buildings created:",
        Game.state.interactables.filter((b) => b.type === "building")
      );

      // Force a render to see if buildings appear
      if (Game._ctx) {
        Game.drawBuildings(Game._ctx);
      }
    },

    // Create procedural houses
    createProceduralHouses() {
      const st = Game.state;
      st.interactables = st.interactables || [];

      // Clear existing buildings
      st.interactables = st.interactables.filter((b) => b.type !== "building");

      // Generate 3-5 random houses
      const numHouses = 3 + Math.floor(Math.random() * 3);
      const houseTypes = ["tavern", "arcade", "shop", "house"];

      for (let i = 0; i < numHouses; i++) {
        const houseType =
          houseTypes[Math.floor(Math.random() * houseTypes.length)];
        const x = 500 + i * 300 + Math.random() * 200;
        const y = 350 + Math.random() * 100;
        const width = 120 + Math.random() * 80;
        const height = 80 + Math.random() * 60;

        const colors = [
          { color: "#8B4513", strokeColor: "#D2691E", roofColor: "#A52A2A" },
          { color: "#4682B4", strokeColor: "#1E90FF", roofColor: "#6495ED" },
          { color: "#228B22", strokeColor: "#32CD32", roofColor: "#006400" },
          { color: "#B22222", strokeColor: "#DC143C", roofColor: "#8B0000" },
          { color: "#9370DB", strokeColor: "#8A2BE2", roofColor: "#4B0082" },
        ];

        const colorSet = colors[Math.floor(Math.random() * colors.length)];

        st.interactables.push({
          id: `procedural_${houseType}_${i}`,
          type: "building",
          x: x,
          y: y,
          width: width,
          height: height,
          label: houseType.charAt(0).toUpperCase() + houseType.slice(1),
          ...colorSet,
          doorColor: "#4d2600",
          windowColor: "#FFF8DC",
          isProcedural: true,
        });
      }

      console.log(`🏘️ Created ${numHouses} procedural houses`);
      return st.interactables.filter((b) => b.type === "building");
    },
  };

  // Global test functions for debugging
  window.testBuildings = () => {
    if (window.Game && window.Game.testBuildings) {
      window.Game.testBuildings();
    } else {
      console.log("Game not initialized yet");
    }
  };

  window.createProceduralHouses = () => {
    if (window.Game && window.Game.createProceduralHouses) {
      return window.Game.createProceduralHouses();
    } else {
      console.log("Game not initialized yet");
      return [];
    }
  };

  // Initialize game when DOM is ready
  document.addEventListener("DOMContentLoaded", () => {
    const hasUnifiedRenderer = window.UNIFIED_RENDERER === true;

    if (!hasUnifiedRenderer) {
      Game.start();
    } else {
      console.debug(
        "[A1K] Skipping standalone renderer (unified renderer active)"
      );
    }

    // Add event listener for the universal action key (E)
    document.addEventListener("keydown", (event) => {
      if (event.key === "e" || event.key === "E") {
        Game.handleUniversalActionKey();
      }
    });
  });

  // Export for module usage
  if (typeof module !== "undefined" && module.exports) {
    module.exports = Game;
  }

  // Expose shared data for legacy inline scripts.
  Game.SHOP_ITEMS = SHOP_ITEMS;
  Game.SHOP_CATEGORIES = SHOP_CATEGORIES;

  // Global access
  window.Game = Game;
  window.A1K_GAME = Game;
})();

</script>

  <!-- ===== GENERATIVE ART SYSTEMS ===== -->
  <!-- Core generative art engine -->
  <!-- Inlined: src/effects/generative-art.js -->
<script>
// Generative Art Engine - Core procedural graphics system
// Provides SVG primitives, color palettes, noise, and animation curves

(function () {
  "use strict";

  // ============= NOISE UTILITIES =============
  class SimplexNoise {
    constructor(seed = Math.random()) {
      this.seed = seed;
      this.p = this.buildPermutationTable(seed);
    }

    buildPermutationTable(seed) {
      const p = [];
      for (let i = 0; i < 256; i++) p[i] = i;
      // Shuffle based on seed
      let rng = seed;
      const random = () => {
        rng = (rng * 9301 + 49297) % 233280;
        return rng / 233280;
      };
      for (let i = 255; i > 0; i--) {
        const j = Math.floor(random() * (i + 1));
        [p[i], p[j]] = [p[j], p[i]];
      }
      return [...p, ...p]; // Double for overflow
    }

    noise2D(x, y) {
      const X = Math.floor(x) & 255;
      const Y = Math.floor(y) & 255;
      x -= Math.floor(x);
      y -= Math.floor(y);
      const u = this.fade(x);
      const v = this.fade(y);
      const a = this.p[X] + Y;
      const b = this.p[X + 1] + Y;
      return this.lerp(
        v,
        this.lerp(
          u,
          this.grad(this.p[a], x, y),
          this.grad(this.p[b], x - 1, y)
        ),
        this.lerp(
          u,
          this.grad(this.p[a + 1], x, y - 1),
          this.grad(this.p[b + 1], x - 1, y - 1)
        )
      );
    }

    fade(t) {
      return t * t * t * (t * (t * 6 - 15) + 10);
    }
    lerp(t, a, b) {
      return a + t * (b - a);
    }
    grad(hash, x, y) {
      const h = hash & 3;
      const u = h < 2 ? x : y;
      const v = h < 2 ? y : x;
      return (h & 1 ? -u : u) + (h & 2 ? -v : v);
    }
  }

  // ============= COLOR PALETTES =============
  const PALETTES = {
    candy: {
      primary: ["#FF6B9D", "#C44569", "#FFA69E", "#FF8FAB"],
      secondary: ["#B4E1FF", "#A8E6CF", "#FFD93D", "#FFB6C1"],
      accents: ["#F8B500", "#FF6F91", "#B4A7D6", "#95E1D3"],
      glow: ["#FFDEE9", "#B5FFFC", "#FFF5BA", "#FFE5EC"],
    },
    pixel: {
      primary: ["#FF0040", "#FF0080", "#00FFFF", "#FFFF00"],
      secondary: ["#7C3AED", "#10B981", "#F59E0B", "#EF4444"],
      accents: ["#FFFFFF", "#000000", "#808080", "#C0C0C0"],
      glow: ["#FF00FF", "#00FFFF", "#FFFF00", "#00FF00"],
    },
    chili: {
      primary: ["#FF4500", "#DC143C", "#B22222", "#8B0000"],
      secondary: ["#FF6347", "#FF7F50", "#FFA500", "#FFD700"],
      accents: ["#8B4513", "#A0522D", "#CD853F", "#DEB887"],
      glow: ["#FFA07A", "#FF8C00", "#FF6B35", "#F77F00"],
    },
  };

  // ============= SEEDED RANDOM =============
  class SeededRandom {
    constructor(seed = Date.now()) {
      this.seed = seed;
      this.m = 2 ** 31 - 1;
      this.a = 1103515245;
      this.c = 12345;
      this.state = seed;
    }

    random() {
      this.state = (this.a * this.state + this.c) % this.m;
      return this.state / this.m;
    }

    range(min, max) {
      return min + this.random() * (max - min);
    }

    int(min, max) {
      return Math.floor(this.range(min, max + 1));
    }

    choice(arr) {
      return arr[this.int(0, arr.length - 1)];
    }
  }

  // ============= SVG SHAPE PRIMITIVES =============
  const SVG = {
    // Create SVG element with proper namespace
    createElement(tag, attrs = {}) {
      const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
      Object.entries(attrs).forEach(([key, value]) => {
        el.setAttribute(key, value);
      });
      return el;
    },

    // Basic shapes
    circle(x, y, r, fill = "#fff", stroke = "none", strokeWidth = 0) {
      return this.createElement("circle", {
        cx: x,
        cy: y,
        r,
        fill,
        stroke,
        "stroke-width": strokeWidth,
      });
    },

    rect(x, y, w, h, fill = "#fff", stroke = "none", strokeWidth = 0) {
      return this.createElement("rect", {
        x,
        y,
        width: w,
        height: h,
        fill,
        stroke,
        "stroke-width": strokeWidth,
      });
    },

    polygon(points, fill = "#fff", stroke = "none", strokeWidth = 0) {
      const pointsStr = points.map((p) => `${p[0]},${p[1]}`).join(" ");
      return this.createElement("polygon", {
        points: pointsStr,
        fill,
        stroke,
        "stroke-width": strokeWidth,
      });
    },

    line(x1, y1, x2, y2, stroke = "#fff", strokeWidth = 2) {
      return this.createElement("line", {
        x1,
        y1,
        x2,
        y2,
        stroke,
        "stroke-width": strokeWidth,
      });
    },

    path(d, fill = "none", stroke = "#fff", strokeWidth = 2) {
      return this.createElement("path", {
        d,
        fill,
        stroke,
        "stroke-width": strokeWidth,
      });
    },

    // Complex shapes
    star(cx, cy, points, outerRadius, innerRadius, fill = "#fff") {
      const pts = [];
      const angleStep = (Math.PI * 2) / points;
      for (let i = 0; i < points * 2; i++) {
        const angle = (i * angleStep) / 2 - Math.PI / 2;
        const radius = i % 2 === 0 ? outerRadius : innerRadius;
        pts.push([
          cx + Math.cos(angle) * radius,
          cy + Math.sin(angle) * radius,
        ]);
      }
      return this.polygon(pts, fill);
    },

    regularPolygon(cx, cy, sides, radius, rotation = 0, fill = "#fff") {
      const pts = [];
      const angleStep = (Math.PI * 2) / sides;
      for (let i = 0; i < sides; i++) {
        const angle = i * angleStep + rotation;
        pts.push([
          cx + Math.cos(angle) * radius,
          cy + Math.sin(angle) * radius,
        ]);
      }
      return this.polygon(pts, fill);
    },

    // Bezier curve helpers
    bezierPath(points, closed = false) {
      if (points.length < 2) return "";
      let d = `M ${points[0][0]} ${points[0][1]}`;
      for (let i = 1; i < points.length; i++) {
        const p = points[i];
        if (i === 1) {
          d += ` L ${p[0]} ${p[1]}`;
        } else {
          const prev = points[i - 1];
          const cpx = (prev[0] + p[0]) / 2;
          const cpy = (prev[1] + p[1]) / 2;
          d += ` Q ${cpx} ${cpy} ${p[0]} ${p[1]}`;
        }
      }
      if (closed) d += " Z";
      return d;
    },
  };

  // ============= ANIMATION CURVES =============
  const Curves = {
    linear(t) {
      return t;
    },
    easeIn(t) {
      return t * t;
    },
    easeOut(t) {
      return t * (2 - t);
    },
    easeInOut(t) {
      return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
    },
    easeInCubic(t) {
      return t * t * t;
    },
    easeOutCubic(t) {
      return --t * t * t + 1;
    },
    elastic(t) {
      return t === 0 || t === 1
        ? t
        : -Math.pow(2, 10 * (t - 1)) * Math.sin((t - 1.1) * 5 * Math.PI);
    },
    bounce(t) {
      if (t < 1 / 2.75) return 7.5625 * t * t;
      if (t < 2 / 2.75) return 7.5625 * (t -= 1.5 / 2.75) * t + 0.75;
      if (t < 2.5 / 2.75) return 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375;
      return 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375;
    },
  };

  // ============= WAVE GENERATORS =============
  const Waves = {
    sine(x, amplitude = 1, frequency = 1, phase = 0) {
      return amplitude * Math.sin(frequency * x + phase);
    },
    cosine(x, amplitude = 1, frequency = 1, phase = 0) {
      return amplitude * Math.cos(frequency * x + phase);
    },
    square(x, amplitude = 1, frequency = 1) {
      return amplitude * Math.sign(Math.sin(frequency * x));
    },
    sawtooth(x, amplitude = 1, frequency = 1) {
      return amplitude * 2 * (frequency * x - Math.floor(0.5 + frequency * x));
    },
  };

  // ============= CANVAS RENDERING UTILITIES =============
  const CanvasUtils = {
    // Render SVG to canvas context
    renderSVGElement(ctx, svgEl, x, y) {
      const tag = svgEl.tagName;
      ctx.save();
      ctx.translate(x, y);

      switch (tag) {
        case "circle":
          this.renderCircle(ctx, svgEl);
          break;
        case "rect":
          this.renderRect(ctx, svgEl);
          break;
        case "polygon":
          this.renderPolygon(ctx, svgEl);
          break;
        case "line":
          this.renderLine(ctx, svgEl);
          break;
        case "path":
          this.renderPath(ctx, svgEl);
          break;
      }

      ctx.restore();
    },

    renderCircle(ctx, el) {
      const cx = parseFloat(el.getAttribute("cx") || 0);
      const cy = parseFloat(el.getAttribute("cy") || 0);
      const r = parseFloat(el.getAttribute("r") || 0);
      const fill = el.getAttribute("fill");
      const stroke = el.getAttribute("stroke");
      const strokeWidth = parseFloat(el.getAttribute("stroke-width") || 0);

      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI * 2);
      if (fill && fill !== "none") {
        ctx.fillStyle = fill;
        ctx.fill();
      }
      if (stroke && stroke !== "none" && strokeWidth > 0) {
        ctx.strokeStyle = stroke;
        ctx.lineWidth = strokeWidth;
        ctx.stroke();
      }
    },

    renderRect(ctx, el) {
      const x = parseFloat(el.getAttribute("x") || 0);
      const y = parseFloat(el.getAttribute("y") || 0);
      const w = parseFloat(el.getAttribute("width") || 0);
      const h = parseFloat(el.getAttribute("height") || 0);
      const fill = el.getAttribute("fill");
      const stroke = el.getAttribute("stroke");
      const strokeWidth = parseFloat(el.getAttribute("stroke-width") || 0);

      if (fill && fill !== "none") {
        ctx.fillStyle = fill;
        ctx.fillRect(x, y, w, h);
      }
      if (stroke && stroke !== "none" && strokeWidth > 0) {
        ctx.strokeStyle = stroke;
        ctx.lineWidth = strokeWidth;
        ctx.strokeRect(x, y, w, h);
      }
    },

    renderPolygon(ctx, el) {
      const pointsStr = el.getAttribute("points") || "";
      const points = pointsStr
        .trim()
        .split(/\s+/)
        .map((p) => {
          const [x, y] = p.split(",").map(Number);
          return { x, y };
        });
      if (points.length < 2) return;

      const fill = el.getAttribute("fill");
      const stroke = el.getAttribute("stroke");
      const strokeWidth = parseFloat(el.getAttribute("stroke-width") || 0);

      ctx.beginPath();
      ctx.moveTo(points[0].x, points[0].y);
      for (let i = 1; i < points.length; i++) {
        ctx.lineTo(points[i].x, points[i].y);
      }
      ctx.closePath();

      if (fill && fill !== "none") {
        ctx.fillStyle = fill;
        ctx.fill();
      }
      if (stroke && stroke !== "none" && strokeWidth > 0) {
        ctx.strokeStyle = stroke;
        ctx.lineWidth = strokeWidth;
        ctx.stroke();
      }
    },

    renderLine(ctx, el) {
      const x1 = parseFloat(el.getAttribute("x1") || 0);
      const y1 = parseFloat(el.getAttribute("y1") || 0);
      const x2 = parseFloat(el.getAttribute("x2") || 0);
      const y2 = parseFloat(el.getAttribute("y2") || 0);
      const stroke = el.getAttribute("stroke");
      const strokeWidth = parseFloat(el.getAttribute("stroke-width") || 2);

      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      if (stroke && stroke !== "none") {
        ctx.strokeStyle = stroke;
        ctx.lineWidth = strokeWidth;
        ctx.stroke();
      }
    },

    renderPath(ctx, el) {
      // Simplified path rendering - supports basic commands
      const d = el.getAttribute("d") || "";
      const fill = el.getAttribute("fill");
      const stroke = el.getAttribute("stroke");
      const strokeWidth = parseFloat(el.getAttribute("stroke-width") || 2);

      const path = new Path2D(d);
      if (fill && fill !== "none") {
        ctx.fillStyle = fill;
        ctx.fill(path);
      }
      if (stroke && stroke !== "none") {
        ctx.strokeStyle = stroke;
        ctx.lineWidth = strokeWidth;
        ctx.stroke(path);
      }
    },
  };

  // ============= COLOR UTILITIES =============
  const ColorUtils = {
    hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result
        ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16),
          }
        : null;
    },

    rgbToHex(r, g, b) {
      return (
        "#" +
        [r, g, b]
          .map((x) => {
            const hex = Math.round(x).toString(16);
            return hex.length === 1 ? "0" + hex : hex;
          })
          .join("")
      );
    },

    lerp(color1, color2, t) {
      const c1 = this.hexToRgb(color1);
      const c2 = this.hexToRgb(color2);
      if (!c1 || !c2) return color1;
      return this.rgbToHex(
        c1.r + (c2.r - c1.r) * t,
        c1.g + (c2.g - c1.g) * t,
        c1.b + (c2.b - c1.b) * t
      );
    },

    addAlpha(hex, alpha) {
      const rgb = this.hexToRgb(hex);
      if (!rgb) return hex;
      return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${alpha})`;
    },

    randomFromPalette(theme = "candy", category = "primary") {
      const palette = PALETTES[theme];
      if (!palette || !palette[category]) return "#FFFFFF";
      const colors = palette[category];
      return colors[Math.floor(Math.random() * colors.length)];
    },
  };

  // ============= EXPORT =============
  window.GenerativeArt = {
    SimplexNoise,
    SeededRandom,
    SVG,
    Curves,
    Waves,
    CanvasUtils,
    ColorUtils,
    PALETTES,
  };

  console.log("✨ Generative Art Engine loaded");
})();

</script>

  <!-- Particle system for effects -->
  <!-- Inlined: src/effects/particle-system.js -->
<script>
/**
 * Particle System Stub
 * This file provides a minimal particle system interface
 */

(function () {
  "use strict";

  window.ParticleSystem = {
    init: function () {
      console.log("✨ Particle System initialized (stub)");
    },

    createParticle: function (x, y, options = {}) {
      // Stub implementation - can be expanded later
      return {
        x: x,
        y: y,
        vx: options.vx || 0,
        vy: options.vy || 0,
        life: options.life || 1.0,
        color: options.color || "#ffffff",
        size: options.size || 3,
      };
    },

    emit: function (x, y, count = 10, options = {}) {
      // Stub - particle emission
      return [];
    },

    update: function (deltaTime) {
      // Stub - particle update
    },

    render: function (ctx) {
      // Stub - particle rendering
    },

    clear: function () {
      // Stub - clear all particles
    },
  };

  // Auto-initialize
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () =>
      window.ParticleSystem.init()
    );
  } else {
    window.ParticleSystem.init();
  }
})();

</script>
  <!-- Inlined: src/effects/vfx-generator.js -->
<script>
// VFX Generator - Procedural visual effects for skills and projectiles
// Replaces image-based sprites with code-generated graphics

(function () {
  "use strict";

  const GA = window.GenerativeArt;
  const PS = window.ParticleSystem;

  // ============= PROJECTILE RENDERERS =============
  const ProjectileRenderers = {
    // Basic player bullet
    playerBullet(ctx, x, y, opts = {}) {
      const color =
        opts.color || GA.ColorUtils.randomFromPalette("candy", "primary");
      const size = opts.size || 4;
      const glow = opts.glow !== false;

      if (glow) {
        ctx.shadowBlur = 7;
        ctx.shadowColor = color;
      }

      // Core bullet
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.arc(x, y, size, 0, Math.PI * 2);
      ctx.fill();

      // Inner glow
      const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
      gradient.addColorStop(0, "#FFFFFF");
      gradient.addColorStop(0.5, color);
      gradient.addColorStop(1, GA.ColorUtils.addAlpha(color, 0.3));
      ctx.fillStyle = gradient;
      ctx.fill();

      ctx.shadowBlur = 0;
    },

    // Enemy projectile
    enemyBullet(ctx, x, y, opts = {}) {
      const color = opts.color || "#ff4444";
      const size = opts.size || 3;

      ctx.save();
      ctx.shadowBlur = 5;
      ctx.shadowColor = color;

      // Hexagon shape
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (i * Math.PI * 2) / 6;
        const px = x + Math.cos(angle) * size;
        const py = y + Math.sin(angle) * size;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.fillStyle = color;
      ctx.fill();
      ctx.strokeStyle = "#ff0000";
      ctx.lineWidth = 2;
      ctx.stroke();

      ctx.restore();
    },

    // Energy wave (A1 S1)
    energyWave(ctx, x, y, opts = {}) {
      const size = opts.size || 8;
      const color = opts.color || "#ff8c6a";
      const angle = opts.angle || 0;

      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);

      // Outer glow
      ctx.shadowBlur = 10;
      ctx.shadowColor = color;

      // Wave shape
      const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size);
      gradient.addColorStop(0, "#FFFFFF");
      gradient.addColorStop(0.3, color);
      gradient.addColorStop(1, GA.ColorUtils.addAlpha(color, 0));

      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.ellipse(0, 0, size * 1.5, size * 0.8, 0, 0, Math.PI * 2);
      ctx.fill();

      // Core slash
      ctx.strokeStyle = "#FFFFFF";
      ctx.lineWidth = 3;
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(-size, 0);
      ctx.lineTo(size, 0);
      ctx.stroke();

      ctx.restore();
    },

    // Explosion burst (A1 S2)
    explosionBurst(ctx, x, y, opts = {}) {
      const radius = opts.radius || 30;
      const progress = opts.progress || 0; // 0 to 1
      const color = opts.color || "#ff6b35";

      ctx.save();

      // Expanding ring
      const currentRadius = radius * progress;
      const thickness = 4 * (1 - progress);

      ctx.globalAlpha = (1 - progress) * 0.5;
      ctx.shadowBlur = 10;
      ctx.shadowColor = color;

      ctx.strokeStyle = color;
      ctx.lineWidth = thickness;
      ctx.beginPath();
      ctx.arc(x, y, currentRadius, 0, Math.PI * 2);
      ctx.stroke();

      // Inner flash
      if (progress < 0.3) {
        const flashGradient = ctx.createRadialGradient(
          x,
          y,
          0,
          x,
          y,
          currentRadius
        );
        flashGradient.addColorStop(0, GA.ColorUtils.addAlpha("#FFFFFF", 0.8));
        flashGradient.addColorStop(1, GA.ColorUtils.addAlpha(color, 0));
        ctx.fillStyle = flashGradient;
        ctx.fill();
      }

      ctx.restore();
    },

    // Storm burst (A1 S3)
    stormWave(ctx, x, y, opts = {}) {
      const radius = opts.radius || 20;
      const color = opts.color || "#4c6ef5";
      const rotation = opts.rotation || 0;

      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rotation);

      // Lightning arcs
      ctx.strokeStyle = "#FFFFFF";
      ctx.lineWidth = 2;
      ctx.shadowBlur = 7;
      ctx.shadowColor = color;

      for (let i = 0; i < 6; i++) {
        const angle = (i * Math.PI * 2) / 6;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        const endX = Math.cos(angle) * radius;
        const endY = Math.sin(angle) * radius;
        ctx.lineTo(endX, endY);
        ctx.stroke();
      }

      // Core orb
      const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, radius * 0.4);
      gradient.addColorStop(0, "#FFFFFF");
      gradient.addColorStop(0.5, color);
      gradient.addColorStop(1, GA.ColorUtils.addAlpha(color, 0.3));
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(0, 0, radius * 0.4, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    },

    // Charged wave (A1 S4)
    chargedWave(ctx, x, y, opts = {}) {
      const size = opts.size || 12;
      const color = opts.color || "#ff00ff";
      const angle = opts.angle || 0;
      const chromatic = opts.chromatic !== false;

      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(angle);

      if (chromatic) {
        // Chromatic aberration effect
        const offsets = [
          { x: -1, y: 0, color: "#ff0000" },
          { x: 0, y: 0, color: color },
          { x: 1, y: 0, color: "#00ffff" },
        ];

        offsets.forEach((offset) => {
          ctx.globalAlpha = 0.35;
          ctx.shadowBlur = 12;
          ctx.shadowColor = offset.color;

          const gradient = ctx.createRadialGradient(
            offset.x,
            offset.y,
            0,
            offset.x,
            offset.y,
            size
          );
          gradient.addColorStop(0, "#FFFFFF");
          gradient.addColorStop(0.3, offset.color);
          gradient.addColorStop(1, GA.ColorUtils.addAlpha(offset.color, 0));

          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.ellipse(offset.x, offset.y, size * 2, size, 0, 0, Math.PI * 2);
          ctx.fill();
        });
      }

      ctx.restore();
    },

    // Mega explosion (A1 S5)
    megaExplosion(ctx, x, y, opts = {}) {
      const radius = opts.radius || 60;
      const progress = opts.progress || 0;
      const color = opts.color || "#ff0080";

      ctx.save();

      const currentRadius = radius * progress;

      // Multiple expanding rings
      for (let i = 0; i < 3; i++) {
        const ringProgress = Math.max(0, progress - i * 0.1);
        const ringRadius = currentRadius * (1 + i * 0.2);
        const alpha = (1 - ringProgress) * 0.25;

        ctx.globalAlpha = alpha;
        ctx.shadowBlur = 15;
        ctx.shadowColor = color;
        ctx.strokeStyle = i % 2 === 0 ? color : "#FFFFFF";
        ctx.lineWidth = 5 * (1 - ringProgress);
        ctx.beginPath();
        ctx.arc(x, y, ringRadius, 0, Math.PI * 2);
        ctx.stroke();
      }

      // Fractal burst pattern
      if (progress < 0.4) {
        ctx.globalAlpha = (1 - progress / 0.4) * 0.5;
        ctx.strokeStyle = "#FFFFFF";
        ctx.lineWidth = 2;
        ctx.shadowBlur = 12;

        for (let i = 0; i < 12; i++) {
          const angle = (i * Math.PI * 2) / 12;
          const dist = currentRadius * 0.7;
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(x + Math.cos(angle) * dist, y + Math.sin(angle) * dist);
          ctx.stroke();
        }
      }

      ctx.restore();
    },
  };

  // ============= TRAIL SYSTEM =============
  class Trail {
    constructor(maxLength = 10) {
      this.points = [];
      this.maxLength = maxLength;
    }

    addPoint(x, y) {
      this.points.push({ x, y, time: Date.now() });
      if (this.points.length > this.maxLength) {
        this.points.shift();
      }
    }

    render(ctx, color = "#FFA69E", width = 2) {
      if (this.points.length < 2) return;

      ctx.save();
      ctx.lineCap = "round";
      ctx.lineJoin = "round";

      for (let i = 1; i < this.points.length; i++) {
        const p1 = this.points[i - 1];
        const p2 = this.points[i];
        const alpha = i / this.points.length;

        ctx.globalAlpha = alpha * 0.3;
        ctx.strokeStyle = color;
        ctx.lineWidth = width * alpha;
        ctx.shadowBlur = 5;
        ctx.shadowColor = color;

        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
      }

      ctx.restore();
    }

    clear() {
      this.points = [];
    }
  }

  // ============= IMPACT EFFECTS =============
  const ImpactEffects = {
    // Fractal crack on hit
    crack(ctx, x, y, opts = {}) {
      const size = opts.size || 15;
      const color = opts.color || "#FFFFFF";
      const branches = opts.branches || 4;

      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = 1;
      ctx.shadowBlur = 5;
      ctx.shadowColor = color;
      ctx.globalAlpha = 0.4;

      for (let i = 0; i < branches; i++) {
        const angle =
          (i * Math.PI * 2) / branches + (Math.random() - 0.5) * 0.5;
        const length = size * (0.5 + Math.random() * 0.5);

        ctx.beginPath();
        ctx.moveTo(x, y);

        // Create jagged line
        let currentX = x;
        let currentY = y;
        const segments = 3 + Math.floor(Math.random() * 3);

        for (let j = 0; j < segments; j++) {
          const segLength = length / segments;
          const jitter = (Math.random() - 0.5) * 20;
          currentX +=
            Math.cos(angle) * segLength +
            Math.cos(angle + Math.PI / 2) * jitter;
          currentY +=
            Math.sin(angle) * segLength +
            Math.sin(angle + Math.PI / 2) * jitter;
          ctx.lineTo(currentX, currentY);
        }

        ctx.stroke();
      }

      ctx.restore();
    },

    // Shockwave ring
    shockwave(ctx, x, y, opts = {}) {
      const radius = opts.radius || 25;
      const progress = opts.progress || 0;
      const color = opts.color || "#FFD93D";

      ctx.save();

      const currentRadius = radius * progress;
      const alpha = (1 - progress) * 0.5;

      ctx.globalAlpha = alpha;
      ctx.shadowBlur = 10;
      ctx.shadowColor = color;
      ctx.strokeStyle = color;
      ctx.lineWidth = 3 * (1 - progress * 0.5);

      ctx.beginPath();
      ctx.arc(x, y, currentRadius, 0, Math.PI * 2);
      ctx.stroke();

      // Secondary ring
      ctx.globalAlpha = alpha * 0.5;
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(x, y, currentRadius * 1.2, 0, Math.PI * 2);
      ctx.stroke();

      ctx.restore();
    },

    // Hit flash
    flash(ctx, x, y, opts = {}) {
      const size = opts.size || 20;
      const color = opts.color || "#FFFFFF";

      ctx.save();
      ctx.globalAlpha = opts.alpha || 0.4;
      ctx.shadowBlur = 15;
      ctx.shadowColor = color;

      // Star burst
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.lineCap = "round";

      for (let i = 0; i < 4; i++) {
        const angle = (i * Math.PI * 2) / 8;
        const length = size * (0.5 + Math.random() * 0.5);
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
        ctx.stroke();
      }

      ctx.restore();
    },
  };

  // ============= CHARGE EFFECTS =============
  const ChargeEffects = {
    // Charging circle indicator
    chargingCircle(ctx, x, y, progress, opts = {}) {
      const radius = opts.radius || 25;
      const color = opts.color || "#FFD93D";

      ctx.save();

      // Background circle
      ctx.globalAlpha = 0.15;
      ctx.strokeStyle = GA.ColorUtils.addAlpha(color, 0.15);
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.stroke();

      // Progress arc
      ctx.globalAlpha = 0.4;
      ctx.strokeStyle = color;
      ctx.lineWidth = 3;
      ctx.shadowBlur = 7;
      ctx.shadowColor = color;
      ctx.beginPath();
      ctx.arc(
        x,
        y,
        radius,
        -Math.PI / 2,
        -Math.PI / 2 + Math.PI * 2 * progress
      );
      ctx.stroke();

      // Pulsing center
      const pulseSize = 5 + Math.sin(Date.now() * 0.01) * 2;
      const gradient = ctx.createRadialGradient(x, y, 0, x, y, pulseSize);
      gradient.addColorStop(0, "#FFFFFF");
      gradient.addColorStop(1, color);
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(x, y, pulseSize, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    },

    // Ready glow (for secret skill)
    readyGlow(ctx, x, y, opts = {}) {
      const size = opts.size || 30;
      const color = opts.color || "#9b59b6";
      const pulse = Math.sin(Date.now() * 0.005) * 0.15 + 0.35;

      ctx.save();
      ctx.globalAlpha = pulse;
      ctx.shadowBlur = 20;
      ctx.shadowColor = color;

      const gradient = ctx.createRadialGradient(x, y, 0, x, y, size);
      gradient.addColorStop(0, GA.ColorUtils.addAlpha("#FFFFFF", 0.8));
      gradient.addColorStop(0.3, GA.ColorUtils.addAlpha(color, 0.6));
      gradient.addColorStop(1, GA.ColorUtils.addAlpha(color, 0));

      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(x, y, size, 0, Math.PI * 2);
      ctx.fill();

      // Rotating runes
      const time = Date.now() * 0.001;
      ctx.strokeStyle = color;
      ctx.lineWidth = 3;
      for (let i = 0; i < 6; i++) {
        const angle = time + (i * Math.PI * 2) / 6;
        const rx = x + Math.cos(angle) * size * 0.7;
        const ry = y + Math.sin(angle) * size * 0.7;
        ctx.beginPath();
        ctx.arc(rx, ry, 5, 0, Math.PI * 2);
        ctx.stroke();
      }

      ctx.restore();
    },
  };

  // ============= SHIELD EFFECTS =============
  const ShieldEffects = {
    // Spawn shield (2 second invulnerability)
    spawnShield(ctx, x, y, opts = {}) {
      const radius = opts.radius || 20;
      const color = opts.color || "#4ecdc4";
      const pulse = Math.sin(Date.now() * 0.01) * 0.1 + 0.4;

      ctx.save();
      ctx.globalAlpha = 0.25 * pulse;
      ctx.shadowBlur = 10;
      ctx.shadowColor = color;

      // Hexagonal shield
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = (i * Math.PI * 2) / 6 + Date.now() * 0.001;
        const px = x + Math.cos(angle) * radius;
        const py = y + Math.sin(angle) * radius;
        if (i === 0) ctx.moveTo(px, py);
        else ctx.lineTo(px, py);
      }
      ctx.closePath();
      ctx.stroke();

      // Energy shimmer
      const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
      gradient.addColorStop(0, GA.ColorUtils.addAlpha(color, 0));
      gradient.addColorStop(0.7, GA.ColorUtils.addAlpha(color, 0.2 * pulse));
      gradient.addColorStop(1, GA.ColorUtils.addAlpha(color, 0));
      ctx.fillStyle = gradient;
      ctx.fill();

      ctx.restore();
    },
  };

  // ============= EXPORT =============
  const existingVFX = (typeof window !== "undefined" && window.VFX) || {};

  // Extend the existing VFX object instead of replacing it so core skill
  // helpers (slash, summon, etc.) stay intact.
  existingVFX.ProjectileRenderers = Object.assign(
    {},
    existingVFX.ProjectileRenderers || {},
    ProjectileRenderers
  );
  existingVFX.ImpactEffects = Object.assign(
    {},
    existingVFX.ImpactEffects || {},
    ImpactEffects
  );
  existingVFX.ChargeEffects = Object.assign(
    {},
    existingVFX.ChargeEffects || {},
    ChargeEffects
  );
  existingVFX.ShieldEffects = Object.assign(
    {},
    existingVFX.ShieldEffects || {},
    ShieldEffects
  );
  existingVFX.Trail = existingVFX.Trail || Trail;

  window.VFX = existingVFX;

  // Make Trail available globally for other modules
  window.Trail = Trail;

  console.log("✨ VFX Generator loaded");
})();

</script>
  <!-- Inlined: src/effects/vfx_supersuite.js -->
<script>
// VFX Supersuite - condensed implementation for A1 Runner
// Provides camera shake, particle overlays, lighting halos, simple post effects
// and named skill FX helpers used by the simplified skill system. (Non-module version)

(function () {
  "use strict";

  const TAU = Math.PI * 2;
  const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
  const lerp = (a, b, t) => a + (b - a) * t;
  const rand = (n = 1) => Math.random() * n;
  const randint = (n = 1) => (Math.random() * n) | 0;
  const nowMS = () =>
    typeof performance !== "undefined" && performance.now
      ? performance.now()
      : Date.now();

  const colorWithAlpha = (hex, alpha = 1) => {
    if (!hex || typeof hex !== "string") return hex;
    const norm = hex.replace("#", "");
    const size = norm.length;
    if (size === 3) {
      const r = parseInt(norm[0] + norm[0], 16);
      const g = parseInt(norm[1] + norm[1], 16);
      const b = parseInt(norm[2] + norm[2], 16);
      return `rgba(${r},${g},${b},${alpha})`;
    }
    if (size === 6) {
      const r = parseInt(norm.slice(0, 2), 16);
      const g = parseInt(norm.slice(2, 4), 16);
      const b = parseInt(norm.slice(4, 6), 16);
      return `rgba(${r},${g},${b},${alpha})`;
    }
    return hex;
  };

  const VFX = { version: "1.0.0" };

  // ---------------------------------------------------------------------------
  // Core buffers for post-processing
  // ---------------------------------------------------------------------------
  const Core = {
    canvas: null,
    ctx: null,
    buffer: null,
    bctx: null,
    post: null,
    pctx: null,
    w: 1,
    h: 1,
    dpr: 1,
    autoResize: false,
    init(options = {}) {
      this.canvas =
        options.canvas ||
        (typeof document !== "undefined"
          ? document.querySelector("canvas")
          : null);
      if (!this.canvas) throw new Error("[VFX] init: canvas required");
      this.dpr = clamp(
        options.dpr ||
          (typeof devicePixelRatio !== "undefined" ? devicePixelRatio : 1),
        1,
        3
      );
      this.ctx = this.canvas.getContext("2d", { alpha: false });
      this.buffer = document.createElement("canvas");
      this.post = document.createElement("canvas");
      this.bctx = this.buffer.getContext("2d");
      this.pctx = this.post.getContext("2d");
      this.resize();
      if (options.autoResize) {
        this.autoResize = true;
        window.addEventListener("resize", () => this.resize());
      }
      VFX.Trails._boot();
      VFX.Particles._boot();
      VFX.Lighting._boot();
      VFX.Aura._boot();
      VFX.Transitions._boot();
      VFX.FX._boot();
      return VFX;
    },
    resize(width, height) {
      if (!this.canvas) return;
      const cssW = width || this.canvas.clientWidth || 1280;
      const cssH = height || this.canvas.clientHeight || 720;
      this.w = Math.max(1, (cssW * this.dpr) | 0);
      this.h = Math.max(1, (cssH * this.dpr) | 0);
      this.canvas.width = this.w;
      this.canvas.height = this.h;
      this.buffer.width = this.w;
      this.buffer.height = this.h;
      this.post.width = this.w;
      this.post.height = this.h;
      if (this.ctx) this.ctx.imageSmoothingEnabled = false;
      if (this.bctx) this.bctx.imageSmoothingEnabled = false;
      if (this.pctx) this.pctx.imageSmoothingEnabled = false;
    },
    capture() {
      if (!this.ctx || !this.bctx) return;
      this.bctx.clearRect(0, 0, this.w, this.h);
      this.bctx.drawImage(this.canvas, 0, 0, this.w, this.h);
    },
    blit(src, dstCtx) {
      dstCtx.drawImage(src, 0, 0, this.w, this.h);
    },
  };

  VFX.Core = Core;

  // ---------------------------------------------------------------------------
  // Camera shake helper
  // ---------------------------------------------------------------------------
  VFX.Camera = {
    _mag: 0,
    _timer: 0,
    _duration: 0,
    _freq: 16,
    _offsetX: 0,
    _offsetY: 0,
    _rot: 0,
    apply(ctx, cam = { x: 0, y: 0, zoom: 1 }) {
      const t = nowMS();
      if (this._timer < this._duration) {
        const progress = this._timer / this._duration;
        const falloff = 1 - Math.pow(progress, 1.5);
        const noise = Math.sin(t * 0.02);
        const noiseY = Math.cos(t * 0.017);
        this._offsetX = noise * this._mag * falloff;
        this._offsetY = noiseY * this._mag * falloff;
        this._rot = Math.sin(t * 0.0015) * 0.015 * falloff;
        this._timer += this._freq;
      } else {
        this._offsetX = this._offsetY = this._rot = 0;
      }
      ctx.setTransform(cam.zoom, 0, 0, cam.zoom, this._offsetX, this._offsetY);
      if (this._rot) ctx.rotate(this._rot);
      if (cam.x || cam.y) ctx.translate(-cam.x, -cam.y);
    },
    shake(magnitude = 6, duration = 260, frequency = 16) {
      this._mag = magnitude;
      this._duration = duration;
      this._timer = 0;
      this._freq = frequency;
    },
  };

  // ---------------------------------------------------------------------------
  // Trail ribbons
  // ---------------------------------------------------------------------------
  VFX.Trails = {
    _items: [],
    defaults: {
      life: 280,
      width: 10,
      color: "#6aa8ff",
      fade: 0.8,
      additive: true,
      maxPoints: 48,
    },
    _boot() {
      this._items.length = 0;
    },
    spawn(options = {}) {
      const trail = Object.assign(
        { points: [], birth: nowMS() },
        this.defaults,
        options
      );
      this._items.push(trail);
      return trail;
    },
    pushPoint(trail, x, y) {
      const pts = trail.points;
      const last = pts[pts.length - 1];
      if (!last || last.x !== x || last.y !== y) {
        pts.push({ x, y, t: nowMS() });
        while (pts.length > trail.maxPoints) pts.shift();
      }
    },
    step() {
      const T = nowMS();
      for (let i = this._items.length - 1; i >= 0; i -= 1) {
        const trail = this._items[i];
        if (T - trail.birth > trail.life) this._items.splice(i, 1);
      }
    },
    draw(ctx) {
      const T = nowMS();
      for (const trail of this._items) {
        const age = (T - trail.birth) / trail.life;
        const alpha = clamp(1 - age, 0, 1) * trail.fade;
        if (alpha <= 0.02 || trail.points.length < 2) continue;
        ctx.save();
        if (trail.additive) ctx.globalCompositeOperation = "lighter";
        ctx.globalAlpha = alpha;
        ctx.lineWidth = trail.width * (1 - age * 0.4);
        ctx.lineCap = "round";
        ctx.lineJoin = "round";
        ctx.strokeStyle = trail.color;
        ctx.beginPath();
        for (let i = 0; i < trail.points.length; i += 1) {
          const p = trail.points[i];
          if (i === 0) ctx.moveTo(p.x, p.y);
          else ctx.lineTo(p.x, p.y);
        }
        ctx.stroke();
        ctx.restore();
      }
    },
  };

  // ---------------------------------------------------------------------------
  // Lighting halos / aura pulses
  // ---------------------------------------------------------------------------
  VFX.Lighting = {
    _items: [],
    _boot() {
      this._items.length = 0;
    },
    halo(x, y, radius = 80, color = "#ffffff", power = 1, life = 320) {
      this._items.push({ x, y, radius, color, power, birth: nowMS(), life });
    },
    aura(x, y, radius = 90, color = "#6aa8ff", life = 600) {
      this._items.push({
        x,
        y,
        radius,
        color,
        power: 1,
        birth: nowMS(),
        life,
        aura: true,
      });
    },
    step() {
      const T = nowMS();
      for (let i = this._items.length - 1; i >= 0; i -= 1) {
        const item = this._items[i];
        if (T - item.birth > item.life) this._items.splice(i, 1);
      }
    },
    draw(ctx) {
      const T = nowMS();
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      for (const item of this._items) {
        const age = (T - item.birth) / item.life;
        const alpha = clamp(1 - age, 0, 1) * item.power;
        if (alpha <= 0.02) continue;
        const radius =
          item.radius * (item.aura ? 0.9 + Math.sin(T * 0.003) * 0.1 : 1);
        const gradient = ctx.createRadialGradient(
          item.x,
          item.y,
          0,
          item.x,
          item.y,
          radius
        );
        gradient.addColorStop(0, colorWithAlpha(item.color, 0.75 * alpha));
        gradient.addColorStop(1, colorWithAlpha(item.color, 0));
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(item.x, item.y, radius, 0, TAU);
        ctx.fill();
      }
      ctx.restore();
    },
  };

  // ---------------------------------------------------------------------------
  // Particle system (very lightweight)
  // ---------------------------------------------------------------------------
  VFX.Particles = {
    _list: [],
    _boot() {
      this._list.length = 0;
    },
    emit(type, x, y, options = {}) {
      const count = options.count || 20;
      for (let i = 0; i < count; i += 1) {
        const particle = { type, x, y, birth: nowMS() };
        if (type === "sparkle") {
          particle.life = 300 + randint(200);
          particle.size = options.size || 3;
          particle.color = options.color || "#e9f4ff";
          particle.vx = (Math.random() - 0.5) * 90;
          particle.vy = (Math.random() - 0.5) * 90;
        } else if (type === "dust") {
          particle.life = 700 + randint(400);
          particle.color = options.color || "#c7c7c7";
          particle.size = 4 + rand(2);
          particle.vx = (Math.random() - 0.5) * 60;
          particle.vy = rand(40);
          particle.gravity = 18;
        } else if (type === "confetti") {
          particle.life = 900 + randint(400);
          particle.color = options.palette
            ? options.palette[randint(options.palette.length)]
            : ["#ff6677", "#7b61ff", "#2ea8ff", "#ffd56a", "#36c777"][
                randint(5)
              ];
          particle.vx = (Math.random() - 0.5) * 160;
          particle.vy = -rand(120);
          particle.w = 3 + randint(4);
          particle.h = 2 + randint(4);
          particle.rot = rand(TAU);
          particle.spin = (Math.random() - 0.5) * 0.2;
          particle.gravity = 70;
        } else if (type === "fire") {
          particle.life = 520 + randint(260);
          particle.color =
            options.color || ["#ff7a31", "#ffd02b", "#ff3b3b"][randint(3)];
          particle.size = 6 + rand(10);
          particle.vx = (Math.random() - 0.5) * 70;
          particle.vy = -(20 + rand(60));
          particle.fade = 0.94;
        } else if (type === "smoke") {
          particle.life = 800 + randint(400);
          particle.color = options.color || "#a0a8ba";
          particle.size = 10 + rand(12);
          particle.vx = (Math.random() - 0.5) * 40;
          particle.vy = -(10 + rand(30));
          particle.fade = 0.96;
        } else if (type === "lightning") {
          particle.life = 140 + randint(120);
          particle.color = options.color || "#9bbcff";
          particle.points = [];
          const segments = options.segments || 6;
          const length = options.length || 220;
          const angle = options.dir || 0;
          for (let s = 0; s <= segments; s += 1) {
            const tSeg = s / segments;
            const jitter =
              (Math.random() - 0.5) * 30 * (1 - Math.abs(0.5 - tSeg) * 2);
            particle.points.push({
              x: x + Math.cos(angle) * length * tSeg + Math.sin(angle) * jitter,
              y: y + Math.sin(angle) * length * tSeg + Math.cos(angle) * jitter,
            });
          }
        } else {
          continue;
        }
        this._list.push(particle);
      }
    },
    step(dtMs = 16) {
      const dt = dtMs / 1000;
      const T = nowMS();
      for (let i = this._list.length - 1; i >= 0; i -= 1) {
        const p = this._list[i];
        if (T - p.birth > p.life) {
          this._list.splice(i, 1);
          continue;
        }
        if (p.type === "lightning") continue;
        p.vx = p.vx || 0;
        p.vy = (p.vy || 0) + (p.gravity || 0) * dt;
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        if (p.spin) p.rot += p.spin;
        if (p.fade) p.size *= p.fade;
      }
    },
    draw(ctx) {
      const T = nowMS();
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      for (const p of this._list) {
        const life = clamp(1 - (T - p.birth) / p.life, 0, 1);
        if (life <= 0.02) continue;
        ctx.globalAlpha = life;
        if (p.type === "lightning") {
          ctx.strokeStyle = p.color;
          ctx.lineWidth = 3;
          ctx.beginPath();
          for (let i = 0; i < p.points.length; i += 1) {
            const pt = p.points[i];
            if (i === 0) ctx.moveTo(pt.x, pt.y);
            else ctx.lineTo(pt.x, pt.y);
          }
          ctx.stroke();
          ctx.globalAlpha = life * 0.2;
          ctx.lineWidth = 6;
          ctx.stroke();
          ctx.globalAlpha = life;
        } else if (p.type === "confetti") {
          ctx.save();
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rot || 0);
          ctx.fillStyle = p.color;
          ctx.fillRect(-(p.w || 4) / 2, -(p.h || 3) / 2, p.w || 4, p.h || 3);
          ctx.restore();
        } else {
          ctx.fillStyle = p.color;
          const radius = Math.max(0.8, p.size || 3);
          ctx.beginPath();
          ctx.arc(p.x, p.y, radius, 0, TAU);
          ctx.fill();
        }
      }
      ctx.restore();
    },
  };

  // ---------------------------------------------------------------------------
  // Aura composer (static attachments)
  // ---------------------------------------------------------------------------
  VFX.Aura = {
    _items: [],
    _boot() {
      this._items.length = 0;
    },
    attach(target, options = {}) {
      const item = Object.assign(
        {
          target,
          kind: "orb",
          color: "#64e6ff",
          scale: 1,
          life: Infinity,
          birth: nowMS(),
        },
        options
      );
      this._items.push(item);
      return item;
    },
    detachAllOf(target) {
      this._items = this._items.filter((a) => a.target !== target);
    },
    step() {
      const T = nowMS();
      this._items = this._items.filter((a) => T - a.birth < a.life);
    },
    draw(ctx) {
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      const T = nowMS() * 0.001;
      for (const a of this._items) {
        const baseX = a.x != null ? a.x : a.target?.x || 0;
        const baseY = a.y != null ? a.y : a.target?.y || 0;
        const radius = 30 * a.scale;
        const gradient = ctx.createRadialGradient(
          baseX,
          baseY,
          0,
          baseX,
          baseY,
          radius
        );
        gradient.addColorStop(
          0,
          colorWithAlpha(a.color, 0.65 + Math.sin(T * 3) * 0.1)
        );
        gradient.addColorStop(1, colorWithAlpha(a.color, 0));
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(baseX, baseY, radius, 0, TAU);
        ctx.fill();
      }
      ctx.restore();
    },
  };

  // ---------------------------------------------------------------------------
  // Transition overlays
  // ---------------------------------------------------------------------------
  VFX.Transitions = {
    _queue: [],
    _boot() {
      this._queue.length = 0;
    },
    play(kind, duration = 600, options = {}) {
      this._queue.push({ kind, start: nowMS(), duration, options });
    },
    draw(ctx) {
      const T = nowMS();
      for (let i = this._queue.length - 1; i >= 0; i -= 1) {
        const trans = this._queue[i];
        const progress = clamp((T - trans.start) / trans.duration, 0, 1);
        if (progress >= 1) {
          this._queue.splice(i, 1);
          continue;
        }
        ctx.save();
        if (trans.kind === "neonflash") {
          ctx.fillStyle = colorWithAlpha(
            trans.options.color || "#00e5ff",
            0.7 * (1 - progress)
          );
          ctx.fillRect(0, 0, Core.w, Core.h);
        } else if (trans.kind === "wipe") {
          const width = Core.w * progress;
          ctx.fillStyle = trans.options.color || "#0b1220";
          ctx.fillRect(0, 0, width, Core.h);
        } else if (trans.kind === "scanfade") {
          const spacing = 20 + progress * 80;
          ctx.fillStyle = trans.options.color || "#000";
          for (let y = 0; y < Core.h; y += spacing) {
            ctx.fillRect(0, y, Core.w, spacing * 0.4);
          }
          ctx.globalAlpha = 0.3 * progress;
          ctx.fillRect(0, 0, Core.w, Core.h);
        }
        ctx.restore();
      }
    },
  };

  // ---------------------------------------------------------------------------
  // Post-processing chain (lightweight implementations)
  // ---------------------------------------------------------------------------
  VFX.Post = {
    _chain: [],
    add(effect) {
      if (typeof effect === "function") this._chain.push(effect);
      return this;
    },
    clear() {
      this._chain.length = 0;
    },
    run() {
      if (!Core.ctx || this._chain.length === 0) return;
      Core.capture();
      let src = Core.buffer;
      let srcCtx = Core.bctx;
      let dst = Core.post;
      let dstCtx = Core.pctx;
      for (let i = 0; i < this._chain.length; i += 1) {
        const fx = this._chain[i];
        dstCtx.clearRect(0, 0, Core.w, Core.h);
        fx(dstCtx, src, Core.w, Core.h, nowMS());
        const tmpCanvas = src;
        const tmpCtx = srcCtx;
        src = dst;
        srcCtx = dstCtx;
        dst = tmpCanvas;
        dstCtx = tmpCtx;
      }
      Core.ctx.setTransform(1, 0, 0, 1, 0, 0);
      Core.ctx.globalCompositeOperation = "source-over";
      Core.ctx.drawImage(src, 0, 0, Core.w, Core.h);
    },
  };

  VFX.PostFX = {
    heatwave({ amplitude = 3, frequency = 3, speed = 0.6 } = {}) {
      return (dstCtx, src, w, h, t) => {
        const temp = document.createElement("canvas");
        temp.width = w;
        temp.height = 1;
        const tctx = temp.getContext("2d");
        const phase = t * 0.001 * speed;
        for (let y = 0; y < h; y += 1) {
          const offset =
            Math.sin((y / h) * frequency * TAU + phase) * amplitude;
          tctx.clearRect(0, 0, w, 1);
          tctx.drawImage(src, 0, y, w, 1, offset, 0, w, 1);
          dstCtx.drawImage(temp, 0, y);
        }
      };
    },
    ripple({ x = 0.5, y = 0.5, radius = 0.35, strength = 16, speed = 1 } = {}) {
      return (dstCtx, src, w, h, t) => {
        const cx = w * x;
        const cy = h * y;
        const base = t * 0.002 * speed;
        const temp = document.createElement("canvas");
        temp.width = w;
        temp.height = 1;
        const tctx = temp.getContext("2d");
        for (let row = 0; row < h; row += 1) {
          const dy = row - cy;
          tctx.clearRect(0, 0, w, 1);
          for (let col = 0; col < w; col += 1) {
            const dx = col - cx;
            const dist =
              Math.sqrt(dx * dx + dy * dy) / Math.sqrt(w * w + h * h);
            const ring =
              Math.sin((dist - base) * 40) *
              strength *
              (1 - clamp(dist / radius, 0, 1));
            const sx = clamp(Math.round(col + ring), 0, w - 1);
            tctx.drawImage(src, sx, row, 1, 1, col, 0, 1, 1);
          }
          dstCtx.drawImage(temp, 0, row);
        }
      };
    },
    chromatic({ shift = 2 } = {}) {
      return (dstCtx, src) => {
        dstCtx.globalCompositeOperation = "screen";
        dstCtx.globalAlpha = 0.9;
        dstCtx.drawImage(src, shift, 0);
        dstCtx.drawImage(src, -shift, 0);
        dstCtx.drawImage(src, 0, shift);
        dstCtx.globalAlpha = 1;
        dstCtx.globalCompositeOperation = "source-over";
      };
    },
    crt({ lineAlpha = 0.15, vignette = 0.25 } = {}) {
      return (dstCtx, src, w, h) => {
        dstCtx.drawImage(src, 0, 0);
        dstCtx.save();
        dstCtx.globalAlpha = lineAlpha;
        dstCtx.fillStyle = "#000";
        for (let y = 0; y < h; y += 2) dstCtx.fillRect(0, y, w, 1);
        dstCtx.restore();
        const g = dstCtx.createRadialGradient(
          w / 2,
          h / 2,
          Math.min(w, h) * 0.2,
          w / 2,
          h / 2,
          Math.max(w, h) * 0.75
        );
        g.addColorStop(0, "rgba(0,0,0,0)");
        g.addColorStop(1, `rgba(0,0,0,${vignette})`);
        dstCtx.fillStyle = g;
        dstCtx.fillRect(0, 0, w, h);
      };
    },
  };

  VFX.Presets = {
    pixelCRT() {
      VFX.Post.clear();
      VFX.Post.add(
        VFX.PostFX.heatwave({ amplitude: 1.5, frequency: 2.4, speed: 0.4 })
      )
        .add(VFX.PostFX.chromatic({ shift: 1 }))
        .add(VFX.PostFX.crt({ lineAlpha: 0.12, vignette: 0.2 }));
      return VFX;
    },
    shockRippleAt(xNorm = 0.5, yNorm = 0.5) {
      VFX.Post.clear();
      VFX.Post.add(
        VFX.PostFX.ripple({
          x: xNorm,
          y: yNorm,
          radius: 0.38,
          strength: 14,
          speed: 1.2,
        })
      );
      return VFX;
    },
  };

  // ---------------------------------------------------------------------------
  // FX Library (named combos)
  // ---------------------------------------------------------------------------
  VFX.FX = {
    _defs: new Map(),
    _boot() {
      this._defs.clear();
      this.define("explosion", (options = {}) => {
        const { x = 0, y = 0, scale = 1, color = "#ffd56a" } = options;
        VFX.Lighting.halo(x, y, 140 * scale, color, 1, 240);
        VFX.Particles.emit("fire", x, y, { count: 14 + randint(10) });
        VFX.Particles.emit("sparkle", x, y, { count: 12, color });
        VFX.Camera.shake(6 * scale, 220, 16);
      });
      this.define("implosion", (options = {}) => {
        const { x = 0, y = 0, color = "#74b9ff" } = options;
        VFX.Lighting.halo(x, y, 120, color, 1, 320);
        for (let i = 0; i < 20; i += 1) {
          const trail = VFX.Trails.spawn({
            color,
            life: 320,
            width: 8,
            maxPoints: 16,
          });
          VFX.Trails.pushPoint(
            trail,
            x + randint(120) - 60,
            y + randint(120) - 60
          );
          VFX.Trails.pushPoint(trail, x, y);
        }
        VFX.Camera.shake(5, 200, 18);
      });
      this.define("missy_treasure_explosion", (options = {}) => {
        const { x = 0, y = 0, scale = 1.2 } = options;
        this.play("explosion", { x, y, scale, color: "#ffd700" });
        VFX.Particles.emit("confetti", x, y, { count: 42 });
        VFX.Particles.emit("sparkle", x, y, { count: 26, color: "#fff6c1" });
        VFX.Transitions.play("neonflash", 160, {
          color: "rgba(255,215,0,0.55)",
        });
      });
      this.define("unique_laser_burst", (options = {}) => {
        const { x = 0, y = 0, dir = 0 } = options;
        for (let i = 0; i < 5; i += 1) {
          VFX.Particles.emit("lightning", x, y, {
            count: 1,
            dir,
            length: 260 + rand(80),
          });
        }
        VFX.Lighting.halo(x, y, 150, "#6aa8ff", 1.2, 260);
        const trail = VFX.Trails.spawn({
          color: "#6aa8ff",
          life: 360,
          width: 10,
          maxPoints: 32,
        });
        const len = 260;
        for (let i = 0; i <= 20; i += 1) {
          const t = i / 20;
          const px = x + Math.cos(dir) * (30 + len * t);
          const py = y + Math.sin(dir) * (30 + len * t);
          VFX.Trails.pushPoint(trail, px, py);
        }
        VFX.Camera.shake(6, 200, 18);
      });
      this.define("a1_crimson_execution", (options = {}) => {
        const { x = 0, y = 0, scale = 1.2 } = options;
        this.play("explosion", { x, y, scale, color: "#ff4d4f" });
        VFX.Particles.emit("fire", x, y, { count: 28 });
        VFX.Particles.emit("sparkle", x, y, { count: 12, color: "#ffe0e0" });
        VFX.Transitions.play("neonflash", 140, {
          color: "rgba(255,77,79,0.55)",
        });
      });
    },
    define(name, fn) {
      this._defs.set(name, fn);
    },
    play(name, options) {
      const fn = this._defs.get(name);
      if (fn) fn.call(this, options || {});
    },
  };

  // ---------------------------------------------------------------------------
  // Shape helpers
  // ---------------------------------------------------------------------------
  VFX.Shapes = {
    drawRing(ctx, x, y, radius, thickness, color) {
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = thickness;
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, TAU);
      ctx.stroke();
      ctx.restore();
    },
    drawXSlash(ctx, x, y, size, color) {
      ctx.save();
      ctx.strokeStyle = color;
      ctx.lineWidth = size * 0.15;
      ctx.lineCap = "round";
      ctx.beginPath();
      ctx.moveTo(x - size * 0.5, y - size * 0.5);
      ctx.lineTo(x + size * 0.5, y + size * 0.5);
      ctx.moveTo(x + size * 0.5, y - size * 0.5);
      ctx.lineTo(x - size * 0.5, y + size * 0.5);
      ctx.stroke();
      ctx.restore();
    },
    drawBeam(ctx, x, y, length, thickness, dir, colorA, colorB) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(dir);
      ctx.globalCompositeOperation = "lighter";
      ctx.fillStyle = colorWithAlpha(colorA, 0.85);
      ctx.fillRect(0, -thickness / 2, length, thickness);
      if (colorB) {
        ctx.globalAlpha = 0.75;
        ctx.fillStyle = colorWithAlpha(colorB, 0.75);
        ctx.fillRect(0, -thickness * 0.25, length, thickness * 0.5);
      }
      ctx.restore();
    },
  };

  // ---------------------------------------------------------------------------
  // Step & draw orchestration
  // ---------------------------------------------------------------------------
  VFX.step = function step(dtMs = 16) {
    const dt = typeof dtMs === "number" ? dtMs : 16;
    VFX.Trails.step();
    VFX.Particles.step(dt);
    VFX.Lighting.step(dt);
    VFX.Aura.step(dt);
  };

  VFX.drawOverlays = function drawOverlays(ctx, timestamp = nowMS()) {
    VFX.Lighting.draw(ctx, timestamp);
    VFX.Trails.draw(ctx);
    VFX.Particles.draw(ctx);
    VFX.Aura.draw(ctx, timestamp);
    VFX.Transitions.draw(ctx, timestamp);
  };

  VFX.update = (dt) => {
    const ms = typeof dt === "number" ? (dt > 5 ? dt : dt * 1000) : 16;
    VFX.step(ms);
  };

  VFX.draw = (ctx, t) => {
    VFX.drawOverlays(ctx, t || nowMS());
    VFX.Post.run();
  };

  VFX.init = (options) => Core.init(options || {});
  VFX.resize = (w, h) => Core.resize(w, h);

  // ---------------------------------------------------------------------------
  // SkillFX helpers (canvas immediate painters)
  // ---------------------------------------------------------------------------
  const SkillFX = {
    XSlash(ctx, x, y, size = 64, color = "#ff4d4f") {
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      for (let i = 0; i < 3; i += 1) {
        const alpha = 0.35 - i * 0.1;
        ctx.globalAlpha = alpha;
        ctx.lineWidth = size * (0.24 + i * 0.1);
        ctx.strokeStyle = colorWithAlpha(color, alpha);
        ctx.beginPath();
        ctx.moveTo(x - size * 0.5, y - size * 0.5);
        ctx.lineTo(x + size * 0.5, y + size * 0.5);
        ctx.moveTo(x + size * 0.5, y - size * 0.5);
        ctx.lineTo(x - size * 0.5, y + size * 0.5);
        ctx.stroke();
      }
      ctx.globalAlpha = 1;
      ctx.lineWidth = size * 0.16;
      ctx.strokeStyle = color;
      ctx.beginPath();
      ctx.moveTo(x - size * 0.5, y - size * 0.5);
      ctx.lineTo(x + size * 0.5, y + size * 0.5);
      ctx.moveTo(x + size * 0.5, y - size * 0.5);
      ctx.lineTo(x - size * 0.5, y + size * 0.5);
      ctx.stroke();
      ctx.restore();
    },
    Beam(
      ctx,
      x,
      y,
      length = 220,
      thickness = 18,
      dir = 0,
      colorA = "#6aa8ff",
      colorB = "#e9f4ff"
    ) {
      VFX.Shapes.drawBeam(ctx, x, y, length, thickness, dir, colorA, colorB);
      const tipX = x + Math.cos(dir) * length;
      const tipY = y + Math.sin(dir) * length;
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      ctx.strokeStyle = colorA;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(tipX - 3, tipY);
      ctx.lineTo(tipX + 3, tipY);
      ctx.moveTo(tipX, tipY - 3);
      ctx.lineTo(tipX, tipY + 3);
      ctx.stroke();
      ctx.restore();
    },
    Ring(ctx, x, y, r = 32, color = "#ffd56a", thickness = 3) {
      VFX.Shapes.drawRing(ctx, x, y, r, thickness, color);
    },
    Coin(ctx, x, y, r = 12, color = "#ffd700", t = 0) {
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.ellipse(x, y, r, r * 0.74 + Math.sin(t * 12) * 1.2, 0, 0, TAU);
      ctx.fill();
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.restore();
    },
    FrostShard(ctx, x, y, size = 26, t = 0) {
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      ctx.translate(x, y);
      ctx.rotate(Math.sin(t * 3) * 0.2);
      ctx.fillStyle = "#b4dcff";
      ctx.beginPath();
      ctx.moveTo(0, -size * 0.5);
      ctx.lineTo(size * 0.28, 0);
      ctx.lineTo(0, size * 0.5);
      ctx.lineTo(-size * 0.28, 0);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle = "#e9f4ff";
      ctx.lineWidth = 1;
      ctx.stroke();
      ctx.restore();
    },
  };

  // ---------------------------------------------------------------------------
  // Export and globals
  // ---------------------------------------------------------------------------
  // Expose to window
  if (typeof window !== "undefined") {
    window.VFX = VFX;
    window.SkillFX = SkillFX;
    window.VFXExport = VFX;
  }
})();

</script>

  <!-- CORE DATABASE INITIALIZATION -->
  <!-- Inlined: src/core/core_database_loader.js -->
<script>
// 🗄️ CORE DATABASE LOADER
// Initializes CORE_DATABASE before other systems that depend on it

(function () {
  "use strict";

  // Core database with all core types and their weapon skills
  window.CORE_DATABASE = {
    // Basic Core (C-Rank)
    core_basic: {
      id: "core_basic",
      name: "Basic Core",
      rarity: "C",
      icon: "🔹",
      weaponSkill: {
        name: "Spark Pulse",
        cooldown: 4000,
        trigger: "time",
        damage: 50,
        range: 80,
        effects: [
          "Tiny shockwave in short cone",
          "Basic damage with no special effects",
        ],
      },
      passiveEffects: ["+5% skill XP gain (helps level early abilities)"],
    },

    // Rare Core (A-Rank)
    core_rare: {
      id: "core_rare",
      name: "Rare Core",
      rarity: "A",
      icon: "🔸",
      weaponSkill: {
        name: "Arc Burst",
        cooldown: 6000,
        trigger: "damage",
        damage: 120,
        range: 120,
        effects: [
          "Circular blast that slows enemies by 25% for 3s",
          "Area of effect damage",
        ],
      },
      passiveEffects: ["+8% cooldown recovery speed"],
    },

    // Myth Core (S-Rank)
    core_myth: {
      id: "core_myth",
      name: "Myth Core",
      rarity: "S",
      icon: "🔮",
      weaponSkill: {
        name: "Eclipse Nova",
        cooldown: 10000,
        trigger: "combo",
        damage: 300,
        range: 200,
        effects: [
          "200% AoE damage burst",
          "Temporarily nullifies enemy shields",
          "Screen-wide explosion",
        ],
      },
      passiveEffects: ["+10% all-damage", "+10% crit-rate"],
    },

    // Dark Core (SSS-Rank) - DUAL SKILLS
    core_dark: {
      id: "core_dark",
      name: "Dark Core",
      rarity: "SSS",
      icon: "⚫",
      weaponSkill: {
        name: "Void Strike",
        cooldown: 8000,
        trigger: "time",
        damage: 400,
        range: 150,
        effects: [
          "Dark energy blade with 180° sweep",
          "Creates temporary void zone (3s)",
          "Void zone deals 50% damage per second",
        ],
      },
      passiveEffects: ["+15% all-damage", "+20% crit-rate", "+10% movement speed"],
    },

    // Light Core (SSS-Rank) - DUAL SKILLS
    core_light: {
      id: "core_light",
      name: "Light Core",
      rarity: "SSS",
      icon: "⚪",
      weaponSkill: {
        name: "Divine Beam",
        cooldown: 8000,
        trigger: "time",
        damage: 400,
        range: 200,
        effects: [
          "Piercing light beam through all enemies",
          "Heals player for 25% of damage dealt",
          "Grants 5s of invulnerability after cast",
        ],
      },
      passiveEffects: ["+15% all-damage", "+20% crit-rate", "+10% movement speed"],
    },

    // 🔥 FIRE CORES
    "core_fire_basic": {
      id: "core_fire_basic",
      name: "Fire Core",
      rarity: "C",
      weaponSkill: {
        name: "Flame Slash",
        cooldown: 3000,
        trigger: "time",
        damage: 80,
        range: 120,
        effects: [
          "Deals fire damage in 90° arc",
          "10% chance to ignite (5s DoT)"
        ]
      }
    },
    "core_fire_inferno": {
      id: "core_fire_inferno",
      name: "Inferno Core",
      rarity: "B",
      weaponSkill: {
        name: "Inferno Burst",
        cooldown: 5000,
        trigger: "damage",
        damage: 150,
        range: 180,
        effects: [
          "360° fire explosion",
          "Guaranteed ignite (8s DoT)",
          "Knockback effect"
        ]
      }
    },
    "core_fire_phoenix": {
      id: "core_fire_phoenix",
      name: "Phoenix Core",
      rarity: "A",
      weaponSkill: {
        name: "Phoenix Rising",
        cooldown: 8000,
        trigger: "kill",
        damage: 200,
        range: 200,
        effects: [
          "Fire trail follows player for 3s",
          "Heals 20% max HP on cast",
          "Next 3 attacks deal +50% fire damage"
        ]
      }
    },
    "core_fire_dragon": {
      id: "core_fire_dragon",
      name: "Dragon Core",
      rarity: "S",
      weaponSkill: {
        name: "Dragon Breath",
        cooldown: 12000,
        trigger: "combo",
        damage: 300,
        range: 250,
        effects: [
          "Cone-shaped fire breath",
          "Burns through multiple enemies",
          "Creates fire wall for 5s",
          "Resets all skill cooldowns"
        ]
      }
    },

    // ❄️ ICE CORES
    "core_ice_basic": {
      id: "core_ice_basic",
      name: "Ice Core",
      rarity: "C",
      weaponSkill: {
        name: "Frost Slash",
        cooldown: 3000,
        trigger: "time",
        damage: 80,
        range: 120,
        effects: [
          "Deals ice damage in 90° arc",
          "15% chance to freeze (2s stun)"
        ]
      }
    },
    "core_ice_blizzard": {
      id: "core_ice_blizzard",
      name: "Blizzard Core",
      rarity: "B",
      weaponSkill: {
        name: "Blizzard Burst",
        cooldown: 5000,
        trigger: "damage",
        damage: 150,
        range: 180,
        effects: [
          "360° ice explosion",
          "Guaranteed freeze (3s stun)",
          "Slows all enemies by 30% for 5s"
        ]
      }
    },
    "core_ice_glacier": {
      id: "core_ice_glacier",
      name: "Glacier Core",
      rarity: "A",
      weaponSkill: {
        name: "Glacier Wall",
        cooldown: 8000,
        trigger: "kill",
        damage: 200,
        range: 200,
        effects: [
          "Creates ice wall that blocks projectiles",
          "Wall deals damage to enemies touching it",
          "Next 3 attacks have +100% range"
        ]
      }
    },
    "core_ice_frost_giant": {
      id: "core_ice_frost_giant",
      name: "Frost Giant Core",
      rarity: "S",
      weaponSkill: {
        name: "Frost Giant Slam",
        cooldown: 12000,
        trigger: "combo",
        damage: 300,
        range: 250,
        effects: [
          "Massive ice slam with ground crack",
          "Freezes all enemies in large area",
          "Creates ice spikes that deal damage over time",
          "Player becomes immune to damage for 3s"
        ]
      }
    },

    // ⚡ LIGHTNING CORES
    "core_lightning_basic": {
      id: "core_lightning_basic",
      name: "Lightning Core",
      rarity: "C",
      weaponSkill: {
        name: "Thunder Strike",
        cooldown: 3000,
        trigger: "time",
        damage: 80,
        range: 120,
        effects: [
          "Deals lightning damage in 90° arc",
          "20% chance to chain to nearby enemies"
        ]
      }
    },
    "core_lightning_storm": {
      id: "core_lightning_storm",
      name: "Storm Core",
      rarity: "B",
      weaponSkill: {
        name: "Lightning Storm",
        cooldown: 5000,
        trigger: "damage",
        damage: 150,
        range: 180,
        effects: [
          "360° lightning explosion",
          "Chains to 3 additional enemies",
          "Stuns all hit enemies for 1s"
        ]
      }
    },
    "core_lightning_thunder": {
      id: "core_lightning_thunder",
      name: "Thunder Core",
      rarity: "A",
      weaponSkill: {
        name: "Thunder Call",
        cooldown: 8000,
        trigger: "kill",
        damage: 200,
        range: 200,
        effects: [
          "Calls down lightning from sky",
          "Hits all enemies in large area",
          "Next 3 attacks have +200% attack speed"
        ]
      }
    },
    "core_lightning_zeus": {
      id: "core_lightning_zeus",
      name: "Zeus Core",
      rarity: "S",
      weaponSkill: {
        name: "Zeus Wrath",
        cooldown: 12000,
        trigger: "combo",
        damage: 300,
        range: 250,
        effects: [
          "Massive lightning bolt with screen-wide effect",
          "Stuns all enemies for 3s",
          "Creates lightning field that chains damage",
          "Player gains +100% movement speed for 5s"
        ]
      }
    },

    // 🌿 NATURE CORES
    "core_nature_basic": {
      id: "core_nature_basic",
      name: "Nature Core",
      rarity: "C",
      weaponSkill: {
        name: "Vine Whip",
        cooldown: 3000,
        trigger: "time",
        damage: 80,
        range: 120,
        effects: [
          "Deals nature damage in 90° arc",
          "15% chance to root enemy (2s immobilize)"
        ]
      }
    },
    "core_nature_forest": {
      id: "core_nature_forest",
      name: "Forest Core",
      rarity: "B",
      weaponSkill: {
        name: "Forest Burst",
        cooldown: 5000,
        trigger: "damage",
        damage: 150,
        range: 180,
        effects: [
          "360° nature explosion",
          "Roots all enemies for 2s",
          "Heals player for 20% of damage dealt"
        ]
      }
    },
    "core_nature_earth": {
      id: "core_nature_earth",
      name: "Earth Core",
      rarity: "A",
      weaponSkill: {
        name: "Earth Spike",
        cooldown: 8000,
        trigger: "kill",
        damage: 200,
        range: 200,
        effects: [
          "Creates earth spikes in line",
          "Spikes block enemy movement",
          "Next 3 attacks have +150% damage"
        ]
      }
    },
    "core_nature_ancient": {
      id: "core_nature_ancient",
      name: "Ancient Core",
      rarity: "S",
      weaponSkill: {
        name: "Ancient Awakening",
        cooldown: 12000,
        trigger: "combo",
        damage: 300,
        range: 250,
        effects: [
          "Summons ancient tree that attacks enemies",
          "Tree heals player over time",
          "All nature damage increased by 100% for 10s",
          "Player becomes immune to status effects"
        ]
      }
    },

    // 🌑 DARK CORES
    "core_dark_basic": {
      id: "core_dark_basic",
      name: "Dark Core",
      rarity: "C",
      weaponSkill: {
        name: "Shadow Slash",
        cooldown: 3000,
        trigger: "time",
        damage: 80,
        range: 120,
        effects: [
          "Deals dark damage in 90° arc",
          "10% chance to curse (reduces enemy damage by 50% for 3s)"
        ]
      }
    },
    "core_dark_void": {
      id: "core_dark_void",
      name: "Void Core",
      rarity: "B",
      weaponSkill: {
        name: "Void Burst",
        cooldown: 5000,
        trigger: "damage",
        damage: 150,
        range: 180,
        effects: [
          "360° dark explosion",
          "Curses all enemies for 5s",
          "Player becomes invisible for 2s"
        ]
      }
    },
    "core_dark_shadow": {
      id: "core_dark_shadow",
      name: "Shadow Core",
      rarity: "A",
      weaponSkill: {
        name: "Shadow Clone",
        cooldown: 8000,
        trigger: "kill",
        damage: 200,
        range: 200,
        effects: [
          "Creates shadow clone that attacks enemies",
          "Clone deals 50% of player damage",
          "Next 3 attacks have +100% crit chance"
        ]
      }
    },
    "core_dark_necromancer": {
      id: "core_dark_necromancer",
      name: "Necromancer Core",
      rarity: "S",
      weaponSkill: {
        name: "Necromancer Ritual",
        cooldown: 12000,
        trigger: "combo",
        damage: 300,
        range: 250,
        effects: [
          "Summons undead minions from defeated enemies",
          "Minions deal damage and absorb enemy attacks",
          "All dark damage increased by 100% for 10s",
          "Player gains lifesteal for 5s"
        ]
      }
    },

    // ☀️ LIGHT CORES
    "core_light_basic": {
      id: "core_light_basic",
      name: "Light Core",
      rarity: "C",
      weaponSkill: {
        name: "Holy Strike",
        cooldown: 3000,
        trigger: "time",
        damage: 80,
        range: 120,
        effects: [
          "Deals light damage in 90° arc",
          "15% chance to blind enemy (reduces accuracy by 50% for 3s)"
        ]
      }
    },
    "core_light_radiant": {
      id: "core_light_radiant",
      name: "Radiant Core",
      rarity: "B",
      weaponSkill: {
        name: "Radiant Burst",
        cooldown: 5000,
        trigger: "damage",
        damage: 150,
        range: 180,
        effects: [
          "360° light explosion",
          "Blinds all enemies for 3s",
          "Heals player for 30% of damage dealt"
        ]
      }
    },
    "core_light_divine": {
      id: "core_light_divine",
      name: "Divine Core",
      rarity: "A",
      weaponSkill: {
        name: "Divine Blessing",
        cooldown: 8000,
        trigger: "kill",
        damage: 200,
        range: 200,
        effects: [
          "Creates divine aura around player",
          "Aura heals player and damages enemies",
          "Next 3 attacks have +200% healing"
        ]
      }
    },
    "core_light_archangel": {
      id: "core_light_archangel",
      name: "Archangel Core",
      rarity: "S",
      weaponSkill: {
        name: "Archangel Wrath",
        cooldown: 12000,
        trigger: "combo",
        damage: 300,
        range: 250,
        effects: [
          "Summons archangel that attacks enemies",
          "Archangel heals player and grants buffs",
          "All light damage increased by 100% for 10s",
          "Player becomes immune to debuffs for 5s"
        ]
      }
    },

    // 🔬 ADVANCED CORES
    "core_advanced_tech": {
      id: "core_advanced_tech",
      name: "Tech Core",
      rarity: "A",
      weaponSkill: {
        name: "Tech Blast",
        cooldown: 6000,
        trigger: "time",
        damage: 180,
        range: 150,
        effects: [
          "Deals tech damage with energy beam",
          "Pierces through all enemies",
          "Has 25% chance to reset cooldown"
        ]
      }
    },
    "core_advanced_cyber": {
      id: "core_advanced_cyber",
      name: "Cyber Core",
      rarity: "S",
      weaponSkill: {
        name: "Cyber Overload",
        cooldown: 10000,
        trigger: "combo",
        damage: 250,
        range: 200,
        effects: [
          "Massive tech explosion",
          "Stuns all enemies for 2s",
          "Player gains +50% attack speed for 5s",
          "Next 5 attacks have +100% damage"
        ]
      }
    },

    // 🌌 FUSION CORES
    "core_fusion_cosmic": {
      id: "core_fusion_cosmic",
      name: "Cosmic Core",
      rarity: "SS",
      weaponSkill: {
        name: "Cosmic Wave",
        cooldown: 15000,
        trigger: "combo",
        damage: 400,
        range: 300,
        effects: [
          "Massive cosmic explosion",
          "Deals all element types",
          "Stuns all enemies for 4s",
          "Player gains all elemental resistances for 10s"
        ]
      }
    },
    "core_fusion_prismatic": {
      id: "core_fusion_prismatic",
      name: "Prismatic Core",
      rarity: "SSS",
      weaponSkill: {
        name: "Prismatic Storm",
        cooldown: 20000,
        trigger: "combo",
        damage: 500,
        range: 350,
        effects: [
          "Ultimate fusion attack",
          "Deals all element types with 200% damage",
          "Stuns all enemies for 5s",
          "Player becomes invulnerable for 3s",
          "Resets all skill cooldowns"
        ]
      }
    }
  };

  console.log("🗄️ Core Database loaded with", Object.keys(window.CORE_DATABASE).length, "cores");
})();

</script>

  <!-- NEW: Two-Source Skills System (CSP-safe, file://-safe) -->
  <!-- Inlined: src/skills/skill_fx_manifest.js -->
<script>
(function () {
  "use strict";

  const TAU = Math.PI * 2;

  const toOrigin = (player, extra = {}) => ({
    x: extra.x != null ? extra.x : player?.x || 0,
    y: extra.y != null ? extra.y : player?.y || 0,
  });

  function ensureVfx() {
    return typeof window !== "undefined" ? (window.VFX || window.VFXExport) : undefined;
  }

  function fallbackBurst(x, y, color, radius = 120, life = 0.45) {
    const st = window.st;
    if (!st) return;
    if (!Array.isArray(st.effects)) st.effects = [];
    st.effects.push({
      kind: "circle",
      x,
      y,
      radius,
      color: color || "#ffffff",
      life,
      maxLife: life,
    });
  }

  function createSlashTrail(vfx, x, y, size, color) {
    if (!vfx?.Trails || typeof vfx.Trails.spawn !== "function") {
      fallbackBurst(x, y, color, size * 0.6, 0.35);
      return;
    }
    const trail = vfx.Trails.spawn({
      color,
      life: 260,
      width: size * 0.12,
      maxPoints: 16,
    });
    vfx.Trails.pushPoint(trail, x - size * 0.5, y - size * 0.5);
    vfx.Trails.pushPoint(trail, x + size * 0.5, y + size * 0.5);
    const trail2 = vfx.Trails.spawn({
      color,
      life: 260,
      width: size * 0.12,
      maxPoints: 16,
    });
    vfx.Trails.pushPoint(trail2, x + size * 0.5, y - size * 0.5);
    vfx.Trails.pushPoint(trail2, x - size * 0.5, y + size * 0.5);
  }

  const SKILL_FX_MANIFEST = {
    A1: {
      S1(player, extra = {}) {
        const pos = toOrigin(player, extra);
        const V = ensureVfx();
        if (!V) {
          fallbackBurst(pos.x, pos.y, "#ff6b6b", extra.radius || 160);
          return;
        }
        createSlashTrail(V, pos.x, pos.y, extra.radius || 160, "#ff6b6b");
        if (V.Lighting?.halo) {
          V.Lighting.halo(pos.x, pos.y, 120, "#ff3b3b", 1.2, 220);
        } else {
          fallbackBurst(pos.x, pos.y, "#ff3b3b", 140, 0.3);
        }
      },
      S2(player, extra = {}) {
        const pos = toOrigin(player, extra);
        const V = ensureVfx();
        if (!V) {
          fallbackBurst(pos.x, pos.y, "#ff4f81", 140);
          return;
        }
        if (V.Aura?.attach) {
          for (let i = 0; i < 5; i += 1) {
            const angle = (i / 5) * TAU;
            const dist = 80 + Math.random() * 30;
            V.Aura.attach(null, {
              x: pos.x + Math.cos(angle) * dist,
              y: pos.y + Math.sin(angle) * dist,
              color: "#ff4f81",
              scale: 0.8,
              life: 1200,
            });
          }
        } else {
          fallbackBurst(pos.x, pos.y, "#ff4f81", 140);
        }
        if (V.Particles?.emit) {
          V.Particles.emit("sparkle", pos.x, pos.y, { count: 22, color: "#ff66aa" });
        }
      },
      S3(player, extra = {}) {
        const pos = toOrigin(player, extra);
        const V = ensureVfx();
        if (!V) {
          fallbackBurst(pos.x, pos.y, "#ff4d4f", extra.radius || 200);
          return;
        }
        if (V.FX?.play) {
          V.FX.play("explosion", { x: pos.x, y: pos.y, scale: 1.1, color: "#ff4d4f" });
        } else {
          fallbackBurst(pos.x, pos.y, "#ff4d4f", extra.radius || 200);
        }
      },
      S4(player, extra = {}) {
        const pos = toOrigin(player, extra);
        const V = ensureVfx();
        if (!V) {
          fallbackBurst(pos.x, pos.y, "#ff4d4f", extra.radius || 240);
          return;
        }
        if (V.FX?.play) {
          V.FX.play("a1_crimson_execution", { x: pos.x, y: pos.y, scale: 1.2 });
        } else {
          fallbackBurst(pos.x, pos.y, "#ff4d4f", extra.radius || 240);
        }
      },
    },
    UNIQUE: {
      S1(player, extra = {}) {
        const pos = toOrigin(player, extra);
        const V = ensureVfx();
        if (!V) {
          fallbackBurst(pos.x, pos.y, "#74b9ff", extra.radius || 200);
          return;
        }
        if (V.Particles?.emit) {
          V.Particles.emit("sparkle", pos.x, pos.y, { count: 26, color: "#74b9ff" });
        }
        if (V.Lighting?.halo) {
          V.Lighting.halo(pos.x, pos.y, 150, "#74b9ff", 1.1, 260);
        } else {
          fallbackBurst(pos.x, pos.y, "#74b9ff", 150);
        }
      },
      S2(player, extra = {}) {
        const pos = toOrigin(player, extra);
        const V = ensureVfx();
        if (!V) {
          fallbackBurst(pos.x, pos.y, "#00cec9", 150);
          return;
        }
        if (V.Particles?.emit) {
          V.Particles.emit("lightning", pos.x, pos.y, { count: 3, length: 180 });
        }
        if (V.Lighting?.halo) {
          V.Lighting.halo(pos.x, pos.y, 120, "#00cec9", 1.2, 220);
        } else {
          fallbackBurst(pos.x, pos.y, "#00cec9", 160);
        }
      },
      S3(player, extra = {}) {
        const pos = toOrigin(player, extra);
        const V = ensureVfx();
        if (!V) {
          fallbackBurst(pos.x, pos.y, "#55a3ff", extra.radius || 220);
          return;
        }
        if (V.FX?.play) {
          V.FX.play("unique_laser_burst", { x: pos.x, y: pos.y, dir: 0 });
          V.FX.play("unique_laser_burst", { x: pos.x, y: pos.y, dir: Math.PI * 0.5 });
        } else {
          fallbackBurst(pos.x, pos.y, "#55a3ff", extra.radius || 220);
        }
      },
      S4(player, extra = {}) {
        const pos = toOrigin(player, extra);
        const V = ensureVfx();
        if (!V) {
          fallbackBurst(pos.x, pos.y, "#55a3ff", extra.radius || 240);
          return;
        }
        if (V.FX?.play) {
          V.FX.play("unique_laser_burst", { x: pos.x, y: pos.y, dir: 0 });
          V.FX.play("unique_laser_burst", { x: pos.x, y: pos.y, dir: Math.PI * 0.33 });
          V.FX.play("unique_laser_burst", { x: pos.x, y: pos.y, dir: Math.PI * 0.66 });
        } else {
          fallbackBurst(pos.x, pos.y, "#55a3ff", extra.radius || 240);
        }
      },
    },
    MISSY: {
      S1(player, extra = {}) {
        const pos = toOrigin(player, extra);
        const V = ensureVfx();
        if (!V) {
          fallbackBurst(pos.x, pos.y, "#ffd56a", extra.radius || 200);
          return;
        }
        if (V.Particles?.emit) {
          V.Particles.emit("confetti", pos.x, pos.y, { count: 20 });
        }
        if (V.Lighting?.halo) {
          V.Lighting.halo(pos.x, pos.y, 140, "#ffd56a", 1, 240);
        } else {
          fallbackBurst(pos.x, pos.y, "#ffd56a", 160);
        }
      },
      S2(player, extra = {}) {
        const pos = toOrigin(player, extra);
        const V = ensureVfx();
        if (!V) {
          fallbackBurst(pos.x, pos.y, "#55efc4", 160);
          return;
        }
        if (V.Lighting?.halo) {
          V.Lighting.halo(pos.x, pos.y, 120, "#55efc4", 1.3, 340);
        } else {
          fallbackBurst(pos.x, pos.y, "#55efc4", 160);
        }
        if (V.Particles?.emit) {
          V.Particles.emit("sparkle", pos.x, pos.y, { count: 24, color: "#55efc4" });
        }
      },
      S3(player, extra = {}) {
        const pos = toOrigin(player, extra);
        const V = ensureVfx();
        if (!V) {
          fallbackBurst(pos.x, pos.y, "#ffd700", extra.radius || 240);
          return;
        }
        if (V.FX?.play) {
          V.FX.play("missy_treasure_explosion", { x: pos.x, y: pos.y, scale: 1.2 });
        } else {
          fallbackBurst(pos.x, pos.y, "#ffd700", extra.radius || 240);
        }
      },
      S4(player, extra = {}) {
        const pos = toOrigin(player, extra);
        const V = ensureVfx();
        if (!V) {
          fallbackBurst(pos.x, pos.y, "#ffd700", extra.radius || 260);
          return;
        }
        if (V.Particles?.emit) {
          V.Particles.emit("confetti", pos.x, pos.y, { count: 40 });
          V.Particles.emit("sparkle", pos.x, pos.y - 40, { count: 30, color: "#ffd700" });
        }
        if (V.Lighting?.halo) {
          V.Lighting.halo(pos.x, pos.y, 200, "#ffd700", 1.4, 600);
        } else {
          fallbackBurst(pos.x, pos.y, "#ffd700", extra.radius || 260);
        }
      },
    },
  };

  window.SKILL_FX_MANIFEST = SKILL_FX_MANIFEST;
})();

</script>
  <!-- Inlined: src/skills/simple_skills.js -->
<script>
// SIMPLIFIED SKILL SYSTEM - 4 Skills Per Character + Leveling Summons
// Recreates the lightweight 12-skill framework used by A1 Runner.

(function () {
  "use strict";

  const TAU = Math.PI * 2;
  const nowMS = () =>
    typeof performance !== "undefined" && performance.now
      ? performance.now()
      : Date.now();

  const SKILL_COLORS = {
    A1: "#ff0000", // Pure red
    UNIQUE: "#0000ff", // Pure blue
    MISSY: "#ffd56a",
  };

  // === X-Wave Emitter ===
  (function(){
    const SPEED=980, LIFE=760, AOE=32, PIERCE=2; // Increased AOE for thicker X

    function emitXWave(a, angle=0, opt={}) {
      if (!window.st) return null;
      const face = ((a.face??a.dir)??1)>=0 ? 1 : -1;
      const th = angle + (face<0 ? Math.PI : 0);
      // create shot with anime-style visual presets and trail history
      const s = {
        kind: 'a1_xwave',
        x: (a.x || 0) + 26,
        y: (a.y || 0) - 36,
        vx: Math.cos(th) * (opt.speed ?? SPEED),
        vy: Math.sin(th) * (opt.speed ?? SPEED),
        life: (opt.life ?? LIFE),
        aoe: (opt.aoe ?? AOE),
        dmg: Math.round((a.dmg || 60) * (opt.dmgM ?? 1.0)),
        pierce: (opt.pierce ?? PIERCE),
        homing: (opt.homing ?? 0.08), // Homing effect
        // visual presets
        color: opt.color || '#ff2d2d', // core
        color2: opt.color2 || '#0a0a0a', // rim/outline
        colorEdge: opt.colorEdge || 'rgba(255,220,180,0.85)',
        bloom: opt.bloom ?? 0.6,
        size: opt.size ?? ((opt.aoe || AOE) * 1.0),
        trailSteps: opt.trailSteps ?? 12,
        trail: [], // per-frame recorded positions for ribbon trail
        ownerId: a.id,
        preset: opt.preset || 'anime_slash'
      };
      (window.st.shots||(window.st.shots=[])).push(s);
      return s;
    }

    // fire N X's at 0.5s cadence; size scales hit radius/dmgM via opt
    window.queueX = (a, n, opt={})=>{
      console.log('[queueX] Firing', n, 'X-waves at 0.5s cadence with opt:', opt);
      for(let i=0;i<n;i++) setTimeout(()=>emitXWave(a, 0, opt), i*500);
    };

    // optional: radial burst
    window.emitXCrossBurst = (a, n=6, spread=Math.PI*2, opt={})=>{
      for(let i=0;i<n;i++) emitXWave(a, (i*spread)/n, opt);
    };
    window.emitXWave = emitXWave;
  })();

  // Shape rendering functions
  function renderTriangle(ctx, x, y, radius, color) {
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    ctx.fillStyle = color;
    ctx.beginPath();
    const h = radius * 0.866; // height of equilateral triangle
    ctx.moveTo(x, y - h * 0.67); // top vertex
    ctx.lineTo(x - radius * 0.5, y + h * 0.33); // bottom left
    ctx.lineTo(x + radius * 0.5, y + h * 0.33); // bottom right
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function renderSquare(ctx, x, y, radius, color) {
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    ctx.fillStyle = color;
    const size = radius * 0.7; // make square fit in circle
    ctx.fillRect(x - size, y - size, size * 2, size * 2);
    ctx.restore();
  }

  function renderCircle(ctx, x, y, radius, color) {
    ctx.save();
    ctx.globalCompositeOperation = "lighter";
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.arc(x, y, radius, 0, TAU);
    ctx.fill();
    ctx.restore();
  }

  // Effect renderer - call this from your main render loop
  function renderEffects(ctx) {
    const st = gameState();
    if (!st.effects) return;

    for (let i = st.effects.length - 1; i >= 0; i--) {
      const effect = st.effects[i];
      if (!effect) continue;

      // Update effect life
      effect.life -= 1 / 60; // assuming 60 FPS
      if (effect.life <= 0) {
        st.effects.splice(i, 1);
        continue;
      }

      // Calculate alpha based on remaining life
      const alpha = effect.life / effect.maxLife;
      const color =
        effect.color +
        Math.floor(alpha * 255)
          .toString(16)
          .padStart(2, "0");

      // Render based on effect kind
      switch (effect.kind) {
        case "triangle":
          renderTriangle(ctx, effect.x, effect.y, effect.radius, color);
          break;
        case "square":
          renderSquare(ctx, effect.x, effect.y, effect.radius, color);
          break;
        case "circle":
        default:
          renderCircle(ctx, effect.x, effect.y, effect.radius, color);
          break;
      }
    }
  }

  // Export the renderer so it can be called from your main game loop
  window.renderEffects = renderEffects;

  function gameState() {
    return (window.st = window.st || {});
  }

  function clamp(value, min, max) {
    return Math.max(min, Math.min(max, value));
  }

  function getNearbyEnemies(source, radius) {
    const st = gameState();
    const list = st.enemies || [];
    if (!source) return [];
    return list.filter((enemy) => {
      if (!enemy || enemy.dead || enemy.hp <= 0) return false;
      const dx = (enemy.x || 0) - (source.x || 0);
      const dy = (enemy.y || 0) - (source.y || 0);
      return dx * dx + dy * dy <= radius * radius;
    });
  }

  function showDamage(x, y, value, color = "#ffffff") {
    const st = gameState();
    if (!st.damageText) st.damageText = [];
    const label = typeof value === "number" ? Math.round(value) : value;
    st.damageText.push({
      x: x || 0,
      y: (y || 0) - 20,
      text: String(label),
      color,
      life: 1,
      vy: -40,
    });
  }

  function simpleEffect(x, y, radius, color, duration = 0.3) {
    const st = gameState();
    if (!st.effects) st.effects = [];
    st.effects.push({
      kind: "triangle",
      x: x || 0,
      y: y || 0,
      radius,
      color,
      life: duration,
      maxLife: duration,
    });
  }

  function showMessage(msg) {
    if (typeof window.note === "function") window.note(msg);
    console.log(msg);
  }

  function damageEnemies(enemies, amount, color = "#ffffff") {
    enemies.forEach((enemy) => {
      if (!enemy || enemy.dead) return;
      enemy.hp -= amount;
      showDamage(enemy.x, enemy.y, amount, color);
      if (enemy.hp <= 0) {
        enemy.dead = true;
        if (typeof window.killEnemy === "function") {
          window.killEnemy(enemy);
        }
      }
    });
  }

  function healPlayer(player, amount) {
    if (!player) return;
    const healAmt = Math.round(amount);
    player.hp = Math.min(player.hpMax || player.hp, (player.hp || 0) + healAmt);
    showDamage(player.x, player.y, "+" + healAmt, "#55ff88");
  }

  function applyVacuumForce(enemies, center, strength = 120) {
    enemies.forEach((enemy) => {
      const dx = (center.x || 0) - (enemy.x || 0);
      const dy = (center.y || 0) - (enemy.y || 0);
      enemy.x += dx * 0.1;
      enemy.y += dy * 0.1;
      if (!enemy.vx) enemy.vx = 0;
      if (!enemy.vy) enemy.vy = 0;
      enemy.vx += clamp(dx, -strength, strength) * 0.001;
      enemy.vy += clamp(dy, -strength, strength) * 0.001;
    });
  }

  function announceSkill(player, text, color) {
    if (!player || !text) return;
    showDamage(player.x || 0, (player.y || 0) - 48, text, color || "#ffd700");
  }

  function emitTauntRing(owner, color = "#ffd56a", duration = 480) {
    const st = gameState();
    st.effects = st.effects || [];
    st.effects.push({
      kind: "charge",
      owner,
      color,
      t: 0,
      max: duration,
      life: duration,
    });
  }

  function cloneSummonExtra(extra) {
    if (!extra) return {};
    const copy = { ...extra };
    if (Array.isArray(extra.comboSkills))
      copy.comboSkills = [...extra.comboSkills];
    if (extra.projectileVolley)
      copy.projectileVolley = { ...extra.projectileVolley };
    if (Array.isArray(extra.entryVolley))
      copy.entryVolley = [...extra.entryVolley];
    if (Array.isArray(extra.fxTrail)) copy.fxTrail = [...extra.fxTrail];
    return copy;
  }

  function spawnOrLevelSummon(owner, type, config = {}) {
    if (!owner) return null;
    const st = gameState();
    const summons = (st.summons = st.summons || []);
    const maxCount = config.maxCount || 5;
    const existing = summons.filter(
      (summon) => summon.owner === owner && summon.type === type && !summon.dead
    );

    if (existing.length >= maxCount) {
      let leveled = 0;
      existing.forEach((summon) => {
        if (summon.level < (config.maxLevel || 50)) {
          summon.level += 1;
          summon.hpMax += config.levelHp || 10;
          summon.hp = Math.min(
            summon.hpMax,
            summon.hp + (config.levelHp || 10)
          );
          summon.dmg += config.levelDmg || 2;
          summon.def = (summon.def || 0) + (config.levelDef || 1);
          leveled += 1;
          simpleEffect(summon.x, summon.y, 50, "#ffff00", 0.5);
          showDamage(summon.x, summon.y - 30, `LVL ${summon.level}`, "#ffff00");
        }
      });
      if (leveled > 0) {
        showMessage(`${type.toUpperCase()} leveled up! (+${leveled})`);
      } else {
        showMessage(`${type.toUpperCase()} summons are at max level`);
      }
      return null;
    }

    const summon = {
      type,
      owner,
      x: owner.x + 40 - Math.random() * 80,
      y: owner.y - 20,
      level: 1,
      hp: config.baseHp || 50,
      hpMax: config.baseHp || 50,
      dmg: config.baseDmg || 30,
      def: config.baseDef || 0,
      attackCD: config.attackCD || 800,
      lastAttack: 0,
      color: config.color || "#0000ff",
      healAmount: config.healAmount || 0,
      healCD: config.healCD || 0,
      lastHeal: 0,
      extra: null,
      attackRadius: config.attackRadius || 200,
      tauntRadius: config.tauntRadius || 0,
      tauntDuration: config.tauntDuration || 2200,
    };

    const extraClone = cloneSummonExtra(config.extra);
    summon.extra =
      extraClone && Object.keys(extraClone).length ? extraClone : null;

    const extra = summon.extra;
    if (extra) {
      if (extra.comboSkills?.length) {
        extra.comboCooldown = extra.comboCooldown || 1.8;
        extra.comboRange = extra.comboRange || summon.attackRadius || 240;
      }
      if (extra.projectileVolley) {
        extra.projectileVolley.count = extra.projectileVolley.count || 5;
        extra.projectileVolley.speed = extra.projectileVolley.speed || 580;
        extra.projectileVolley.cooldown =
          extra.projectileVolley.cooldown || 2.6;
        extra.projectileVolley.spread =
          typeof extra.projectileVolley.spread === "number"
            ? extra.projectileVolley.spread
            : Math.PI / 1.4;
      }
      extra.followSpeed = extra.followSpeed || 4.6;
      extra.chaseSpeed = extra.chaseSpeed || 7.6;
      extra.dashSpeed = extra.dashSpeed || 15;
      extra.dashDuration = extra.dashDuration || 0.22;
      extra.dashCooldown = extra.dashCooldown || 1.9;
      extra.dashChance = extra.dashChance || 0.35;
      extra.lootAffinity = extra.lootAffinity || 0.35;
      extra.lootRadius = extra.lootRadius || 420;
      extra.animeColor = extra.animeColor || summon.color;
    }

    summons.push(summon);
    st.targetSummon = summon;
    simpleEffect(summon.x, summon.y, 50, summon.color, 0.6);
    emitTauntRing(summon, summon.color || "#ffd56a", 760);
    showMessage(
      `${type.toUpperCase()} summoned! (${existing.length + 1}/${maxCount})`
    );
    return summon;
  }

  function normalizeHeroId(raw) {
    if (!raw) return "";
    const cleaned = String(raw).trim().toUpperCase();
    const collapsed = cleaned.replace(/\s+/g, "");
    if (collapsed.startsWith("A1")) return "A1";
    if (collapsed.startsWith("UNIQUE")) return "UNIQUE";
    if (collapsed.startsWith("MISSY")) return "MISSY";
    return collapsed;
  }

  function triggerSkillFx(player, skillKey, extra = {}) {
    if (!player || !skillKey) return;
    const manifest = window.SKILL_FX_MANIFEST;
    if (!manifest) return;
    const heroKey = normalizeHeroId(player.id);
    if (!heroKey) return;
    const handler = manifest[heroKey]?.[skillKey];
    if (typeof handler === "function") {
      try {
        handler(player, extra);
      } catch (err) {
        console.debug(
          "[SkillFX] handler fallback",
          heroKey,
          skillKey,
          err?.message || err
        );
      }
    }
  }

  function executeEnemy(enemy, player) {
    enemy.hp = 0;
    enemy.dead = true;
    simpleEffect(enemy.x, enemy.y, 90, "#ff0000", 0.4);
    showDamage(enemy.x, enemy.y, "EXECUTED", "#ff0000");
    showMessage(`${player.id} executed ${enemy.name || "enemy"}!`);
    if (typeof window.killEnemy === "function") window.killEnemy(enemy);
  }

  function chainDamage(enemies, baseDamage, maxTargets = 5) {
    let remaining = maxTargets;
    let damage = baseDamage;
    enemies.forEach((enemy) => {
      if (remaining <= 0) return;
      enemy.hp -= damage;
      showDamage(enemy.x, enemy.y, damage, "#ffd700");
      if (enemy.hp <= 0) {
        enemy.dead = true;
        if (typeof window.killEnemy === "function") window.killEnemy(enemy);
      }
      // decay damage and limit targets
      damage = Math.max(baseDamage * 0.7, damage * 0.85);
      remaining -= 1;
    });
  }

  // === PROJECTILE HELPERS ===
  function ensureProjectileList() {
    const st = gameState();
    if (!Array.isArray(st.projectiles)) st.projectiles = [];
    return st.projectiles;
  }

  function animeBurst(x, y, color, radius = 90, count = 14) {
    const st = gameState();
    st.effects = st.effects || [];
    const hue = color || "#ffffff";
    st.effects.push({
      kind: "circle",
      x: x || 0,
      y: y || 0,
      radius,
      color: hue,
      life: 0.32,
      maxLife: 0.32,
    });
    for (let i = 0; i < count; i++) {
      st.effects.push({
        kind: "fire_particle",
        x: (x || 0) + (Math.random() - 0.5) * radius * 1.8,
        y: (y || 0) + (Math.random() - 0.5) * radius * 1.8,
        vx: (Math.random() - 0.5) * 8,
        vy: (Math.random() - 0.5) * 8,
        color: hue,
        life: 260,
        max: 260,
      });
    }
  }

  function spawnSummonSpreadProjectiles(source, target, options = {}) {
    if (!source) return;
    const list = ensureProjectileList();
    const count = options.count || 6;
    const color = options.color || source.color || "#ffffff";
    const speed = options.speed || 580;
    const radius = options.radius || 18;
    const life = options.life || 1000;
    const damage =
      (options.damageBase || source.dmg || 24) * (options.damageScale || 1);
    const homing = !!options.homing;
    const scatter = options.scatter || 0;
    const startAngle = target
      ? Math.atan2((target.y || 0) - source.y, (target.x || 0) - source.x)
      : 0;
    const fullCircle = options.spread === "full";
    const spread = fullCircle
      ? TAU
      : typeof options.spread === "number"
      ? options.spread
      : Math.PI;
    const birth = nowMS();

    for (let i = 0; i < count; i++) {
      const offset = count > 1 ? i / (count - 1) - 0.5 : 0;
      const aim = fullCircle
        ? (TAU * i) / count
        : startAngle + offset * spread + (Math.random() - 0.5) * scatter;

      const projectile = {
        type: options.type || "summon_arc",
        x: (source.x || 0) + (options.offsetX || 0),
        y: (source.y || 0) + (options.offsetY || -18),
        vx: Math.cos(aim) * speed,
        vy: Math.sin(aim) * speed,
        radius,
        dmg: damage,
        pierce: options.pierce ?? 3,
        color,
        life,
        birth,
        rotation: 0,
        homing,
        update(dtMs) {
          const st = gameState();
          const dt = (typeof dtMs === "number" ? dtMs : 16) / 1000;
          if (this.homing) {
            const enemies = st.enemies || [];
            let nearest = null;
            let best = Infinity;
            for (const e of enemies) {
              if (!e || e.dead || e.hp <= 0) continue;
              const dx = (e.x || 0) - this.x;
              const dy = (e.y || 0) - this.y;
              const dist2 = dx * dx + dy * dy;
              if (dist2 < best && dist2 < 260000) {
                best = dist2;
                nearest = e;
              }
            }
            if (nearest) {
              const dist = Math.max(12, Math.sqrt(best));
              const desiredVx = (((nearest.x || 0) - this.x) / dist) * speed;
              const desiredVy = (((nearest.y || 0) - this.y) / dist) * speed;
              this.vx += (desiredVx - this.vx) * 0.18;
              this.vy += (desiredVy - this.vy) * 0.18;
            }
          }

          this.x += this.vx * dt;
          this.y += this.vy * dt;
          this.rotation += dt * 6;

          const enemies = st.enemies || [];
          const r2 = (this.radius || 18) * (this.radius || 18);
          for (const enemy of enemies) {
            if (!enemy || enemy.dead || enemy.hp <= 0) continue;
            const dx = (enemy.x || 0) - this.x;
            const dy = (enemy.y || 0) - this.y;
            if (dx * dx + dy * dy <= r2) {
              enemy.hp -= this.dmg || 26;
              animeBurst(enemy.x, enemy.y, this.color || "#ffffff", 60, 12);
              showDamage(enemy.x, enemy.y, this.dmg, this.color);
              if (enemy.hp <= 0) {
                enemy.dead = true;
                try {
                  window.killEnemy?.(enemy);
                } catch (_) {}
              }
              this.dead = true;
              break;
            }
          }

          if (nowMS() - this.birth > (this.life || 1000)) this.dead = true;
        },
        render(ctx) {
          ctx.save();
          ctx.globalCompositeOperation = "lighter";
          ctx.translate(this.x, this.y);
          ctx.rotate(this.rotation);
          ctx.strokeStyle = this.color || "#ffffff";
          ctx.lineWidth = 4;
          ctx.shadowBlur = 16;
          ctx.shadowColor = this.color || "#ffffff";
          ctx.beginPath();
          ctx.arc(0, 0, (this.radius || 18) * 0.9, 0, TAU);
          ctx.stroke();
          ctx.strokeStyle = "#ffffff";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(0, 0, (this.radius || 18) * 0.5, 0, TAU);
          ctx.stroke();
          ctx.restore();
        },
      };
      list.push(projectile);
    }
  }

  function spawnSummonMeteor(target, color, damage, radius = 28) {
    if (!target) return;
    const list = ensureProjectileList();
    const birth = nowMS();
    const meteor = {
      type: "summon_meteor",
      x: (target.x || 0) + (Math.random() - 0.5) * 60,
      y: (target.y || 0) - 480,
      vx: (Math.random() - 0.5) * 60,
      vy: 720,
      radius,
      dmg: damage,
      color: color || "#ffd56a",
      pierce: 1,
      life: 1600,
      birth,
      update(dtMs) {
        const st = gameState();
        const dt = (typeof dtMs === "number" ? dtMs : 16) / 1000;
        this.x += (this.vx || 0) * dt;
        this.y += (this.vy || 0) * dt;
        const enemies = st.enemies || [];
        const r2 = (this.radius || 26) * (this.radius || 26);
        for (const enemy of enemies) {
          if (!enemy || enemy.dead || enemy.hp <= 0) continue;
          const dx = (enemy.x || 0) - this.x;
          const dy = (enemy.y || 0) - this.y;
          if (dx * dx + dy * dy <= r2) {
            enemy.hp -= this.dmg || 60;
            animeBurst(enemy.x, enemy.y, this.color, this.radius * 2, 20);
            showDamage(enemy.x, enemy.y, this.dmg, this.color);
            if (enemy.hp <= 0) {
              enemy.dead = true;
              try {
                window.killEnemy?.(enemy);
              } catch (_) {}
            }
            this.dead = true;
            break;
          }
        }
        if (nowMS() - this.birth > (this.life || 1200)) this.dead = true;
      },
      render(ctx) {
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        ctx.fillStyle = this.color || "#ffd56a";
        ctx.shadowBlur = 25;
        ctx.shadowColor = this.color || "#ffd56a";
        ctx.beginPath();
        ctx.arc(this.x, this.y, (this.radius || 26) * 0.8, 0, TAU);
        ctx.fill();
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(this.x, this.y, (this.radius || 26) * 0.5, 0, TAU);
        ctx.stroke();
        ctx.restore();
      },
    };
    list.push(meteor);
  }

  function unleashSummonEntryVolley(player, entryConfig, fallbackColor) {
    if (!player || !entryConfig) return;
    spawnSummonSpreadProjectiles(player, null, {
      count: entryConfig.count || 8,
      spread: "full",
      speed: entryConfig.speed || 620,
      radius: entryConfig.radius || 18,
      color: entryConfig.color || fallbackColor,
      damageScale: entryConfig.damageScale || 0.9,
      life: entryConfig.life || 960,
      pierce: entryConfig.pierce ?? 2,
      offsetY: entryConfig.offsetY ?? -32,
    });
    animeBurst(
      player.x || 0,
      (player.y || 0) - 20,
      entryConfig.color || fallbackColor,
      120,
      20
    );
  }

  function selectSummonEnemy(summon, enemies, extra) {
    let best = null;
    let bestScore = Infinity;
    for (const enemy of enemies) {
      if (!enemy || enemy.dead || enemy.hp <= 0) continue;
      const dx = (enemy.x || 0) - (summon.x || 0);
      const dy = (enemy.y || 0) - (summon.y || 0);
      const dist2 = dx * dx + dy * dy;
      let score = dist2;
      if (extra?.lowHpExecute && enemy.hpMax)
        score *= enemy.hp <= enemy.hpMax * 0.35 ? 0.55 : 1;
      if (extra?.bossPriority && (enemy.boss || enemy.elite)) score *= 0.6;
      if (extra?.focusOwner && summon.owner) {
        const ox = (enemy.x || 0) - (summon.owner.x || 0);
        const oy = (enemy.y || 0) - (summon.owner.y || 0);
        score += (ox * ox + oy * oy) * 0.18;
      }
      if (score < bestScore) {
        bestScore = score;
        best = enemy;
      }
    }
    return best;
  }

  const SUMMON_COMBO_HANDLERS = {
    A1_S1(summon, owner, target) {
      if (!target) return false;
      animeBurst(target.x, target.y, "#ff3355", 96, 18);
      damageEnemies([target], (summon.dmg || 32) * 1.25, "#ff3355");
      spawnSummonSpreadProjectiles(summon, target, {
        count: 5,
        spread: Math.PI / 3,
        speed: 660,
        radius: 20,
        color: "#ff3355",
        damageScale: 1.05,
        pierce: 4,
        scatter: 0.22,
      });
      summon._swordT = Math.max(summon._swordT || 0, 260);
      return true;
    },
    A1_S3(summon, owner, target) {
      const anchor = target || summon;
      const victims = getNearbyEnemies(anchor, 160);
      if (!victims.length) return false;
      animeBurst(anchor.x, anchor.y, "#ff1f3d", 140, 22);
      damageEnemies(victims, (summon.dmg || 32) * 1.35, "#ff1f3d");
      spawnSummonSpreadProjectiles(summon, null, {
        count: 8,
        spread: "full",
        speed: 640,
        radius: 22,
        color: "#ff1f3d",
        damageScale: 1,
      });
      return true;
    },
    A1_S4(summon, owner, target) {
      if (!target) return false;
      const threshold = (target.hpMax || 600) * 0.32;
      if (target.hp <= threshold) {
        executeEnemy(target, owner || summon.owner || summon);
        animeBurst(target.x, target.y, "#ff1235", 160, 26);
      } else {
        damageEnemies([target], (summon.dmg || 32) * 1.55, "#ff1235");
        animeBurst(target.x, target.y, "#ff1235", 120, 20);
      }
      spawnSummonSpreadProjectiles(summon, target, {
        count: 10,
        spread: Math.PI / 1.15,
        speed: 720,
        radius: 24,
        color: "#ff1235",
        damageScale: 1.12,
        pierce: 5,
      });
      return true;
    },
    UNIQUE_ION(summon, owner, target) {
      if (!target) return false;
      animeBurst(target.x, target.y, "#74b9ff", 86, 16);
      damageEnemies([target], (summon.dmg || 28) * 1.2, "#74b9ff");
      spawnSummonSpreadProjectiles(summon, target, {
        count: 4,
        spread: Math.PI / 5,
        speed: 700,
        radius: 18,
        color: "#74b9ff",
        damageScale: 1,
        homing: true,
        scatter: 0.18,
      });
      return true;
    },
    UNIQUE_STORM(summon, owner, target) {
      const anchor = target || summon;
      const victims = getNearbyEnemies(anchor, 130);
      if (!victims.length) return false;
      animeBurst(anchor.x, anchor.y, "#55a3ff", 150, 20);
      damageEnemies(victims, (summon.dmg || 28) * 1.25, "#55a3ff");
      spawnSummonSpreadProjectiles(summon, null, {
        count: 6,
        spread: "full",
        speed: 720,
        radius: 18,
        color: "#55a3ff",
        damageScale: 1.1,
      });
      return true;
    },
    UNIQUE_ORDER(summon, owner, target) {
      if (!target) return false;
      animeBurst(target.x, target.y, "#ffd56a", 90, 18);
      damageEnemies([target], (summon.dmg || 34) * 1.2, "#ffd56a");
      spawnSummonSpreadProjectiles(summon, target, {
        count: 5,
        spread: Math.PI / 4,
        speed: 660,
        radius: 20,
        color: "#ffd56a",
        damageScale: 1.05,
        pierce: 4,
      });
      return true;
    },
    UNIQUE_LUNA(summon, owner, target) {
      const anchor = target || summon;
      const victims = getNearbyEnemies(anchor, 150);
      if (!victims.length) return false;
      animeBurst(anchor.x, anchor.y, "#ffea8b", 150, 24);
      damageEnemies(victims, (summon.dmg || 34) * 1.25, "#ffea8b");
      spawnSummonSpreadProjectiles(summon, null, {
        count: 7,
        spread: "full",
        speed: 680,
        radius: 20,
        color: "#ffea8b",
        damageScale: 1.05,
      });
      return true;
    },
    UNIQUE_SOL(summon, owner, target) {
      const anchor = target || summon;
      const victims = getNearbyEnemies(anchor, 120);
      if (!victims.length) return false;
      animeBurst(anchor.x, anchor.y, "#ffd56a", 80, 16);
      damageEnemies(victims, (summon.dmg || 34) * 1.1, "#ffd56a");
      spawnSummonSpreadProjectiles(summon, anchor, {
        count: 6,
        spread: Math.PI / 3,
        speed: 640,
        radius: 18,
        color: "#ffd56a",
        damageScale: 1,
      });
      return true;
    },
    MISSY_METEOR(summon, owner, target) {
      if (!target) return false;
      spawnSummonMeteor(target, "#ffd56a", (summon.dmg || 34) * 1.45, 30);
      return true;
    },
    MISSY_HEAL(summon, owner, target) {
      if (!owner) return false;
      const healAmt = 18 + (summon.level || 1) * 4;
      healPlayer(owner, healAmt);
      animeBurst(owner.x, owner.y, "#ffd56a", 80, 16);
      if (target)
        damageEnemies([target], (summon.dmg || 34) * 0.7, "#ffd56a");
      return true;
    },
  };

  function runSummonCombo(summon, owner, target, extra) {
    if (!extra?.comboSkills?.length) return false;
    const pick =
      extra.comboSkills[Math.floor(Math.random() * extra.comboSkills.length)];
    const handler = SUMMON_COMBO_HANDLERS[pick];
    if (typeof handler !== "function") return false;
    return handler(summon, owner, target);
  }

  function processSummonCombos(summon, owner, target, extra, dtSeconds) {
    if (!extra?.comboSkills?.length) return;
    summon._comboTimer = Math.max(0, (summon._comboTimer || 0) - dtSeconds);
    if (summon._comboTimer > 0) return;
    if (runSummonCombo(summon, owner, target, extra)) {
      const cd = Math.max(0.6, extra.comboCooldown || 1.8);
      summon._comboTimer = cd + Math.random() * (cd * 0.35);
    }
  }

  function processSummonVolley(summon, owner, target, extra, dtSeconds) {
    const volley = extra?.projectileVolley;
    if (!volley) return;
    summon._volleyTimer = Math.max(0, (summon._volleyTimer || 0) - dtSeconds);
    if (!target || summon._volleyTimer > 0) return;
    spawnSummonSpreadProjectiles(summon, target, {
      count: volley.count || 6,
      spread: volley.spread,
      speed: volley.speed,
      radius: volley.radius || 20,
      color: volley.color || summon.color,
      damageScale: volley.damageScale || 1,
      pierce: volley.pierce ?? 3,
      homing: !!volley.homing,
      scatter: volley.scatter || 0,
    });
    summon._volleyFlash = 0.3;
    summon._volleyTimer = Math.max(0.6, volley.cooldown || 2.6);
  }

  function pullNearbyLoot(summon, owner, extra, dtSeconds) {
    if (!extra || extra.lootAffinity <= 0) return;
    summon._lootTimer = Math.max(0, (summon._lootTimer || 0) - dtSeconds);
    if (summon._lootTimer > 0) return;
    const st = gameState();
    const items = st.items || [];
    if (!items.length) return;
    const radius = extra.lootRadius || 420;
    const r2 = radius * radius;
    let closest = null;
    let best = r2;
    for (const item of items) {
      if (
        !item ||
        typeof item.x !== "number" ||
        typeof item.y !== "number"
      )
        continue;
      const dx = item.x - (summon.x || 0);
      const dy = item.y - (summon.y || 0);
      const dist2 = dx * dx + dy * dy;
      if (dist2 < best) {
        best = dist2;
        closest = item;
      }
    }
    if (!closest) return;
    const dist = Math.max(18, Math.sqrt(best));
    const pull = (extra.lootPull || 220) * dtSeconds;
    closest.x -= ((closest.x - summon.x) / dist) * pull;
    closest.y -= ((closest.y - summon.y) / dist) * pull;
    const dxOwner = (closest.x || 0) - (owner?.x || 0);
    const dyOwner = (closest.y || 0) - (owner?.y || 0);
    if (dxOwner * dxOwner + dyOwner * dyOwner < 900) {
      closest.x = owner?.x || closest.x;
      closest.y = owner?.y || closest.y;
    }
    const jitter = Math.max(0.25, 1.1 - extra.lootAffinity * 0.4);
    summon._lootTimer = 0.45 + Math.random() * jitter;
  }

  function applySummonAura(summon, extra, dtSeconds) {
    if (!extra?.animeColor) return;
    summon._auraTimer = Math.max(0, (summon._auraTimer || 0) - dtSeconds);
    if (summon._auraTimer > 0) return;
    const st = gameState();
    st.effects = st.effects || [];
    st.effects.push({
      kind: "square",
      x: summon.x || 0,
      y: (summon.y || 0) - 18,
      radius: 20,
      color: extra.animeColor,
      life: 0.2,
      maxLife: 0.2,
    });
    summon._auraTimer = extra.auraInterval || 0.4 + Math.random() * 0.3;
  }

  function processSummonSupport(summon, owner, target, extra, dtSeconds) {
    if (!extra) return;
    applySummonAura(summon, extra, dtSeconds);
    pullNearbyLoot(summon, owner, extra, dtSeconds);
    processSummonVolley(summon, owner, target, extra, dtSeconds);
    processSummonCombos(summon, owner, target, extra, dtSeconds);
    if (extra.buffOwner && owner) {
      summon._supportTimer = Math.max(
        0,
        (summon._supportTimer || 0) - dtSeconds
      );
      if (summon._supportTimer <= 0) {
        healPlayer(owner, 10 + (summon.level || 1) * 2);
        summon._supportTimer = 5.5;
      }
    }
  }

  function spawnSlashProjectiles(
    player,
    color = "#ff0000",
    count = 3,
    speed = 420,
    size = 46,
    homing = true
  ) {
    const list = ensureProjectileList();
    const baseX = player.x + 24;
    const baseY = player.y - 28;
    const birth = nowMS();
    for (let i = 0; i < count; i++) {
      const dir = -0.25 + (i / (count - 1 || 1)) * 0.5; // fan
      const proj = {
        type: "slash",
        x: baseX,
        y: baseY,
        vx: speed * Math.cos(dir),
        vy: speed * Math.sin(dir),
        size,
        color,
        life: 1260, // Increased 80%: 700 * 1.8 = 1260
        birth,
        pierce: 5, // Increased pierce to hit more enemies
        dmg: 140,
        radius: 28, // Increased 80%: 24 * 1.8 ≈ 43, using 28 for balance
        homing: homing,
        homingStrength: 0.18, // Increased 80%: 0.12 * 1.5 = 0.18
        target: null,
        update(dtMs) {
          const st = gameState();
          const dt = (typeof dtMs === "number" ? dtMs : 16) / 1000;

          // HOMING: Find and track nearest enemy
          if (this.homing) {
            const enemies = st.enemies || [];
            let nearestDist = Infinity;
            let nearest = null;

            for (const e of enemies) {
              if (!e || e.dead || e.hp <= 0) continue;
              const dx = (e.x || 0) - this.x;
              const dy = (e.y || 0) - this.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist < nearestDist && dist < 720) {
                // Increased 80%: 400 * 1.8 = 720
                nearestDist = dist;
                nearest = e;
              }
            }

            // Home in on target
            if (nearest) {
              this.target = nearest;
              const dx = nearest.x - this.x;
              const dy = nearest.y - this.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist > 0) {
                const targetVx = (dx / dist) * 420;
                const targetVy = (dy / dist) * 420;
                this.vx += (targetVx - this.vx) * this.homingStrength;
                this.vy += (targetVy - this.vy) * this.homingStrength;
              }
            }
          }

          this.x += (this.vx || 0) * dt;
          this.y += (this.vy || 0) * dt;
          const enemies = st.enemies || [];
          const r2 = (this.radius || 24) * (this.radius || 24);
          for (const e of enemies) {
            if (!e || e.dead || e.hp <= 0) continue;
            const dx = (e.x || 0) - this.x;
            const dy = (e.y || 0) - this.y;
            if (dx * dx + dy * dy <= r2) {
              e.hp -= this.dmg || 100;

              // HIT EFFECT
              showDamage(e.x, e.y, this.dmg, this.color);
              simpleEffect(e.x, e.y, 40, this.color, 0.3);
              st.effects = st.effects || [];

              // Impact sparkles
              for (let j = 0; j < 4; j++) {
                st.effects.push({
                  kind: "fire_particle",
                  x: e.x + (Math.random() - 0.5) * 30,
                  y: e.y + (Math.random() - 0.5) * 30,
                  vx: (Math.random() - 0.5) * 4,
                  vy: (Math.random() - 0.5) * 4,
                  color: this.color,
                  life: 250,
                  max: 250,
                });
              }

              if (e.hp <= 0) {
                e.dead = true;
                try {
                  window.killEnemy?.(e);
                } catch (_) {}
              }
              if (!this.pierce || --this.pierce <= 0) {
                this.dead = true;
                break;
              }
            }
          }
          if (nowMS() - this.birth > this.life) this.dead = true;
        },
        render(ctx) {
          ctx.save();
          ctx.globalCompositeOperation = "lighter";
          ctx.strokeStyle = this.color || "#ff0000";
          ctx.lineWidth = Math.max(2, (this.size || 40) * 0.12);
          ctx.shadowBlur = 10;
          ctx.shadowColor = this.color || "#ff0000";
          ctx.beginPath();
          // X shape
          ctx.moveTo(
            this.x - (this.size || 40) * 0.5,
            this.y - (this.size || 40) * 0.5
          );
          ctx.lineTo(
            this.x + (this.size || 40) * 0.5,
            this.y + (this.size || 40) * 0.5
          );
          ctx.moveTo(
            this.x + (this.size || 40) * 0.5,
            this.y - (this.size || 40) * 0.5
          );
          ctx.lineTo(
            this.x - (this.size || 40) * 0.5,
            this.y + (this.size || 40) * 0.5
          );
          ctx.stroke();
          ctx.restore();
        },
      };
      list.push(proj);
    }
  }

  function spawnXProjectile(
    player,
    color = "#ff0000",
    speed = 600,
    size = 80,
    homing = true
  ) {
    const list = ensureProjectileList();
    const baseX = player.x + 24;
    const baseY = player.y - 28;
    const birth = nowMS();
    const dir = player.facingLeft ? Math.PI : 0;

    const proj = {
      type: "x_wave",
      x: baseX,
      y: baseY,
      vx: speed * Math.cos(dir),
      vy: speed * Math.sin(dir), // Use dir for Y velocity too
      size,
      color,
      life: 2000, // Long range
      birth,
      pierce: 999, // Hits all enemies
      dmg: 400,
      radius: 50,
      rotation: 0,
      homing: homing,
      homingStrength: 0.15,
      target: null,
      update(dtMs) {
        const st = gameState();
        const dt = (typeof dtMs === "number" ? dtMs : 16) / 1000;

        // HOMING: Find and track nearest enemy
        if (this.homing) {
          const enemies = st.enemies || [];
          let nearestDist = Infinity;
          let nearest = null;

          for (const e of enemies) {
            if (!e || e.dead || e.hp <= 0) continue;
            const dx = (e.x || 0) - this.x;
            const dy = (e.y || 0) - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < nearestDist && dist < 600) {
              nearestDist = dist;
              nearest = e;
            }
          }

          // Home in on target
          if (nearest) {
            this.target = nearest;
            const dx = nearest.x - this.x;
            const dy = nearest.y - this.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist > 0) {
              const targetVx = (dx / dist) * 600;
              const targetVy = (dy / dist) * 600;
              this.vx += (targetVx - this.vx) * this.homingStrength;
              this.vy += (targetVy - this.vy) * this.homingStrength;
            }
          }
        }

        this.x += (this.vx || 0) * dt;
        this.y += (this.vy || 0) * dt;
        this.rotation += dt * 8; // Spin effect

        const enemies = st.enemies || [];
        const r2 = (this.radius || 50) * (this.radius || 50);
        for (const e of enemies) {
          if (!e || e.dead || e.hp <= 0 || e._hitByXWave === this.birth)
            continue;
          const dx = (e.x || 0) - this.x;
          const dy = (e.y || 0) - this.y;
          if (dx * dx + dy * dy <= r2) {
            e.hp -= this.dmg || 400;
            e._hitByXWave = this.birth; // Mark to prevent double-hit
            showDamage(e.x, e.y, this.dmg, this.color);

            // HIT EFFECT: Multiple layers
            simpleEffect(e.x, e.y, 60, this.color, 0.4);
            st.effects = st.effects || [];

            // Explosion ring
            st.effects.push({
              kind: "screen_shockwave",
              x: e.x,
              y: e.y,
              radius: 80,
              color: this.color,
              life: 400,
              max: 400,
            });

            // Impact sparkles
            for (let i = 0; i < 8; i++) {
              st.effects.push({
                kind: "fire_particle",
                x: e.x + (Math.random() - 0.5) * 40,
                y: e.y + (Math.random() - 0.5) * 40,
                vx: (Math.random() - 0.5) * 5,
                vy: (Math.random() - 0.5) * 5,
                color: this.color,
                life: 300,
                max: 300,
              });
            }

            if (e.hp <= 0) {
              e.dead = true;
              try {
                window.killEnemy?.(e);
              } catch (_) {}
            }
          }
        }
        if (nowMS() - this.birth > this.life) this.dead = true;
      },
      render(ctx) {
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);

        // X shape with glow
        ctx.strokeStyle = this.color || "#ff0000";
        ctx.lineWidth = 6;
        ctx.shadowBlur = 20;
        ctx.shadowColor = this.color || "#ff0000";
        ctx.beginPath();
        ctx.moveTo(-this.size * 0.5, -this.size * 0.5);
        ctx.lineTo(this.size * 0.5, this.size * 0.5);
        ctx.moveTo(this.size * 0.5, -this.size * 0.5);
        ctx.lineTo(-this.size * 0.5, this.size * 0.5);
        ctx.stroke();

        // Inner bright core
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 3;
        ctx.shadowBlur = 15;
        ctx.beginPath();
        ctx.moveTo(-this.size * 0.4, -this.size * 0.4);
        ctx.lineTo(this.size * 0.4, this.size * 0.4);
        ctx.moveTo(this.size * 0.4, -this.size * 0.4);
        ctx.lineTo(-this.size * 0.4, this.size * 0.4);
        ctx.stroke();

        ctx.restore();
      },
    };
    list.push(proj);
  }

  function spawnShardVolleys(
    player,
    color = "#0000ff",
    count = 5,
    speed = 520,
    size = 14,
    homing = true
  ) {
    const list = ensureProjectileList();
    const baseX = player.x + 24;
    const baseY = player.y - 28;
    const birth = nowMS();
    for (let i = 0; i < count; i++) {
      const dir = -0.35 + (i / (count - 1 || 1)) * 0.7;
      const proj = {
        type: "shard",
        x: baseX,
        y: baseY,
        vx: speed * Math.cos(dir),
        vy: speed * Math.sin(dir),
        size,
        color,
        life: 900,
        birth,
        pierce: 1,
        dmg: 120,
        radius: 16,
        homing: homing,
        homingStrength: 0.1,
        target: null,
        update(dtMs) {
          const st = gameState();
          const dt = (typeof dtMs === "number" ? dtMs : 16) / 1000;

          // HOMING: Find and track nearest enemy
          if (this.homing) {
            const enemies = st.enemies || [];
            let nearestDist = Infinity;
            let nearest = null;

            for (const e of enemies) {
              if (!e || e.dead || e.hp <= 0) continue;
              const dx = (e.x || 0) - this.x;
              const dy = (e.y || 0) - this.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist < nearestDist && dist < 500) {
                nearestDist = dist;
                nearest = e;
              }
            }

            // Home in on target
            if (nearest) {
              this.target = nearest;
              const dx = nearest.x - this.x;
              const dy = nearest.y - this.y;
              const dist = Math.sqrt(dx * dx + dy * dy);
              if (dist > 0) {
                const targetVx = (dx / dist) * 520;
                const targetVy = (dy / dist) * 520;
                this.vx += (targetVx - this.vx) * this.homingStrength;
                this.vy += (targetVy - this.vy) * this.homingStrength;
              }
            }
          }

          this.x += (this.vx || 0) * dt;
          this.y += (this.vy || 0) * dt;
          this.vy += 0.0; // no gravity by default
          const enemies = st.enemies || [];
          const r2 = (this.radius || 16) * (this.radius || 16);
          for (const e of enemies) {
            if (!e || e.dead || e.hp <= 0) continue;
            const dx = (e.x || 0) - this.x;
            const dy = (e.y || 0) - this.y;
            if (dx * dx + dy * dy <= r2) {
              e.hp -= this.dmg || 80;

              // HIT EFFECT
              showDamage(e.x, e.y, this.dmg, this.color);
              simpleEffect(e.x, e.y, 35, this.color, 0.25);
              st.effects = st.effects || [];

              // Impact sparkles
              for (let j = 0; j < 3; j++) {
                st.effects.push({
                  kind: "fire_particle",
                  x: e.x + (Math.random() - 0.5) * 25,
                  y: e.y + (Math.random() - 0.5) * 25,
                  vx: (Math.random() - 0.5) * 3,
                  vy: (Math.random() - 0.5) * 3,
                  color: this.color,
                  life: 200,
                  max: 200,
                });
              }

              if (e.hp <= 0) {
                e.dead = true;
                try {
                  window.killEnemy?.(e);
                } catch (_) {}
              }
              if (!this.pierce || --this.pierce <= 0) {
                this.dead = true;
                break;
              }
            }
          }
          if (nowMS() - this.birth > this.life) this.dead = true;
        },
        render(ctx) {
          ctx.save();
          ctx.globalCompositeOperation = "lighter";
          ctx.fillStyle = this.color || "#0000ff";
          const s = this.size || 14;
          ctx.beginPath();
          ctx.moveTo(this.x, this.y - s * 0.5);
          ctx.lineTo(this.x + s * 0.28, this.y);
          ctx.lineTo(this.x, this.y + s * 0.5);
          ctx.lineTo(this.x - s * 0.28, this.y);
          ctx.closePath();
          ctx.fill();
          ctx.restore();
        },
      };
      list.push(proj);
    }
  }

  function spawnBeam(
    player,
    colorA = "#6aa8ff",
    colorB = "#e9f4ff",
    length = 520,
    th = 24,
    duration = 420
  ) {
    const list = ensureProjectileList();
    const birth = nowMS();
    const proj = {
      type: "beam",
      x: player.x + 28,
      y: player.y - 30,
      dir: 0,
      length,
      thickness: th,
      color: colorA,
      core: colorB,
      life: duration,
      birth,
      pierce: 99,
      dmg: 160,
      radius: th * 0.9,
      vx: 0,
      vy: 0,
      update(dtMs) {
        const st = gameState();
        const enemies = st.enemies || [];
        // Beam is instant; check overlap along line segment
        const r = this.radius || (this.thickness || 18) * 0.9;
        const tipX = this.x + Math.cos(this.dir || 0) * (this.length || 380);
        const tipY = this.y + Math.sin(this.dir || 0) * (this.length || 380);
        for (const e of enemies) {
          if (!e || e.dead || e.hp <= 0) continue;
          // distance from point to line segment
          const px = e.x || 0,
            py = e.y || 0;
          const x1 = this.x,
            y1 = this.y,
            x2 = tipX,
            y2 = tipY;
          const A = px - x1,
            B = py - y1,
            C = x2 - x1,
            D = y2 - y1;
          const dot = A * C + B * D;
          const len_sq = C * C + D * D || 1;
          let t = dot / len_sq;
          t = t < 0 ? 0 : t > 1 ? 1 : t;
          const cx = x1 + C * t,
            cy = y1 + D * t;
          const dx = px - cx,
            dy = py - cy;
          if (dx * dx + dy * dy <= r * r) {
            e.hp -= this.dmg || 140;
            if (e.hp <= 0) {
              e.dead = true;
              try {
                window.killEnemy?.(e);
              } catch (_) {}
            }
            // Beam shockwave: subtle effect at contact point
            const stE = gameState();
            stE.effects = stE.effects || [];
            stE.effects.push({
              kind: "square",
              x: px,
              y: py,
              radius: Math.max(30, r * 1.2),
              color: this.core || "#ff0000",
              life: 0.18,
              maxLife: 0.18,
            });
          }
        }
        if (nowMS() - this.birth > this.life) this.dead = true;
      },
      render(ctx) {
        const dir = this.dir || 0;
        const len = this.length || 380;
        const thk = this.thickness || 18;
        // Outer glow
        ctx.save();
        ctx.globalCompositeOperation = "lighter";
        ctx.strokeStyle = this.color || "#0000ff";
        ctx.lineWidth = thk;
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x + Math.cos(dir) * len, this.y + Math.sin(dir) * len);
        ctx.stroke();
        // Core
        ctx.strokeStyle = this.core || "#ff0000";
        ctx.lineWidth = Math.max(2, thk * 0.45);
        ctx.beginPath();
        ctx.moveTo(this.x, this.y);
        ctx.lineTo(this.x + Math.cos(dir) * len, this.y + Math.sin(dir) * len);
        ctx.stroke();
        ctx.restore();
      },
    };
    list.push(proj);
  }

  // === COMMON CAST HELPERS (unify visual style) ===
  function castS1Common(player, color) {
    const power = 140;
    const enemies = getNearbyEnemies(player, 180);
    damageEnemies(enemies, power, color);
    simpleEffect(player.x, player.y, 180, color, 0.3);
    // uniform forward shard fan
    spawnShardVolleys(player, color, 6, 540, 16);
  }

  function castS2Common(player, summonType, config, color) {
    const enemies = getNearbyEnemies(player, 160);
    damageEnemies(enemies, config.power || 100, color);
    spawnOrLevelSummon(player, summonType, config);
    if (config.entryVolley) {
      unleashSummonEntryVolley(player, config.entryVolley, color);
    }
    // Visible taunt ring on cast
    emitTauntRing({ x: player.x, y: player.y }, color, 680);
  }

  function castS3Common(player, colorA, colorB) {
    // Unify beam effect for all heroes
    simpleEffect(player.x, player.y, 220, colorA, 0.35);
    spawnBeam(player, colorA, colorB, 520, 24, 420);
  }

  // RAGE SYSTEM FUNCTIONS
  function isRageMode(player) {
    // Also honor global Rage toggle if present
    try { if (window.Rage && window.Rage.active) return true; } catch (_) {}
    return (player.rage || 0) >= 80 || player.rageMode || player.rageOn;
  }

  function getRageMultiplier(skillType) {
    const multipliers = {
      S1: { projectiles: 1.5, size: 1.3, duration: 1.2 },
      S2: { summons: 1.8, size: 1.4, duration: 1.3 },
      S3: { projectiles: 2.0, size: 1.5, duration: 1.4 },
      S4: { projectiles: 2.5, size: 1.8, duration: 1.5 },
    };
    return (
      multipliers[skillType] || { projectiles: 1.5, size: 1.3, duration: 1.2 }
    );
  }

  function addRageVisuals(player, skillType) {
    if (!isRageMode(player)) return;

    const st = gameState();
    st.effects = st.effects || [];

    // Rage aura around character
    st.effects.push({
      kind: "rage_aura",
      x: player.x,
      y: player.y,
      radius: 60,
      color: "#ff4444",
      life: 800,
      max: 800,
    });

    // Fire particles trailing
    for (let i = 0; i < 8; i++) {
      st.effects.push({
        kind: "fire_particle",
        x: player.x + (Math.random() - 0.5) * 40,
        y: player.y + (Math.random() - 0.5) * 40,
        vx: (Math.random() - 0.5) * 2,
        vy: (Math.random() - 0.5) * 2,
        color: "#ff6b6b",
        life: 400,
        max: 400,
      });
    }
  }

  const SIMPLE_SKILLS = {
    A1: {
      S1: {
        name: "Crimson Slash",
        cooldown: 2500,
        power: 140,
        cast(player) {
          console.log('[A1 S1] Cast started');
          const st = gameState();
          
          // Check charge (NO RAGE MODE - only tap/charge)
          const held = performance.now() - (player._hold?.s1start || performance.now());
          const isCharge = held >= 120;
          console.log('[A1 S1] Hold time:', held, 'ms. isCharge:', isCharge);

          const power = this.power || 140;
          const cadence = 500; // 0.5s between slashes
          const totalSlashes = 3; // Always 3 slashes

          // Execute 3 sword slashes
          for (let slashIdx = 0; slashIdx < totalSlashes; slashIdx++) {
            setTimeout(() => {
              const enemies = getNearbyEnemies(player, 180);
              damageEnemies(enemies, power, "#ff4d4f");
              simpleEffect(player.x, player.y, 120, "#ff4d4f", 0.25);

              st.effects.push({
                kind: "luna_arc",
                x: player.x + 20,
                y: player.y - 20,
                radius: 80 + slashIdx * 10,
                angle: (slashIdx * Math.PI) / 6 - Math.PI / 12,
                color: "#ff4d4f",
                life: 350,
                max: 350,
                direction: player.facingLeft ? -1 : 1,
              });
              st.effects.push({
                kind: "luna_arc",
                x: player.x + 20,
                y: player.y - 20,
                radius: 65 + slashIdx * 8,
                angle: (slashIdx * Math.PI) / 6 - Math.PI / 12,
                color: "#1a1a1a",
                life: 350,
                max: 350,
                direction: player.facingLeft ? -1 : 1,
              });
            }, slashIdx * cadence);
          }

          // Fire X-waves AFTER slashes complete (1.5s delay)
          const xStartDelay = totalSlashes * cadence;
          
          setTimeout(() => {
            if (!isCharge) {
              // TAP: 3 X-waves, 0.5s apart, normal size/dmg
              console.log('[A1 S1] TAP mode: Firing 3 X-waves');
              window.queueX?.(player, 3, { dmgM: 1.2, pierce: 4, aoe: 28 });
            } else {
              // CHARGE: 1 big X, then 2 normal X
              console.log('[A1 S1] CHARGE mode: Firing 1 big + 2 normal X-waves');
              window.queueX?.(player, 1, { dmgM: 1.6, pierce: 6, aoe: 36 });
              setTimeout(() => {
                window.queueX?.(player, 2, { dmgM: 1.2, pierce: 4, aoe: 28 });
              }, 500);
            }
          }, xStartDelay);

          // Bullet deflection window
          player._deflecting = true;
          player._deflectTime = nowMS() + 300;
        },
      },
      S2: {
        name: "Shadow Clone Army",
        cooldown: 6000,
        power: 100,
        cast(player) {
          // RAGE + HOLD DETECTION
          const rageMode = isRageMode(player);
          const holdResult = window.lastHoldS2 || { held: false, ms: 0, mode: 'tap' };
          const mode = rageMode ? (holdResult.held ? 'rageHold' : 'rageTap') : (holdResult.held ? 'hold' : 'tap');
          const plan = window.SkillPlanner ? window.SkillPlanner.getSlashPlan('S2', mode) : { extras: { dashRange: 500, dashSpeed: 14 } };
          
          const rageMult = getRageMultiplier("S2");
          addRageVisuals(player, "S2");

          // PLAYER DASH TO NEAREST ENEMY BEFORE SUMMONING
          const st = gameState();
          const enemies = st.enemies || [];
          const dashRange = plan.extras.dashRange || 500;
          const dashSpeed = plan.extras.dashSpeed || 14;
          const target = window.nearestEnemyStrict ? window.nearestEnemyStrict(player) : enemies.find(e => !e.dead);
          
          if (target) {
            const dx = target.x - player.x;
            const dy = target.y - player.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist > 80 && dist < dashRange) {
              const dashDist = Math.min(dist - 60, dashRange);
              const steps = 10;
              const stepX = (dx / dist) * dashDist / steps;
              const stepY = (dy / dist) * dashDist / steps;
              player.facingLeft = dx < 0;
              
              // Animate player dash
              for (let i = 0; i < steps; i++) {
                setTimeout(() => {
                  player.x += stepX;
                  player.y += stepY;
                  
                  // Ghost trail effect
                  st.effects = st.effects || [];
                  st.effects.push({
                    kind: "luna_arc",
                    x: player.x,
                    y: player.y,
                    radius: 30,
                    angle: 0,
                    color: mode === 'rageHold' ? "#ff4f8199" : "#ff4f8166",
                    life: 200,
                    max: 200,
                    direction: player.facingLeft ? -1 : 1
                  });
                }, i * 20);
              }
            }
          }

          // Delay summoning until after dash completes (200ms)
          setTimeout(() => {
            // RAGE: More clones and enhanced stats
            const maxCount = rageMode ? 8 : 5;
            const baseHp = rageMode ? 80 : 60;
            const baseDmg = rageMode ? 50 : 35;

            castS2Common(
              player,
              "clone",
              {
                maxCount: maxCount,
                baseHp: baseHp,
                baseDmg: baseDmg,
                levelHp: 12,
                levelDmg: 3,
                attackCD: 500,
                color: "#ff4f81",
                attackRadius: 260,
                tauntRadius: 280,
                tauntDuration: 2800,
                power: this.power,
                rageMode: rageMode, // Pass rage state to clones
                extra: {
                  chaseSpeed: rageMode ? 9.5 : 8.4,
                  followSpeed: 5.2,
                  dashSpeed: 18,
                  dashDuration: 0.24,
                  dashCooldown: rageMode ? 1.4 : 1.65,
                  dashChance: rageMode ? 0.55 : 0.4,
                  comboSkills: ["A1_S1", "A1_S3", "A1_S4"],
                  comboCooldown: rageMode ? 1.4 : 1.75,
                  comboRange: 320,
                  projectileVolley: {
                    count: rageMode ? 8 : 6,
                    speed: 640,
                    radius: 22,
                    color: "#ff4f81",
                    damageScale: rageMode ? 1.18 : 1.05,
                    scatter: 0.25,
                    cooldown: rageMode ? 2.0 : 2.4,
                  },
                  lootAffinity: 0.6,
                  lootPull: 260,
                  animeColor: "#ff2a4b",
                  lowHpExecute: true,
                  bossPriority: true,
                },
                entryVolley: {
                  count: rageMode ? 14 : 10,
                  speed: 680,
                  radius: 22,
                  color: "#ff4f81",
                  damageScale: rageMode ? 1.1 : 0.95,
                },
              },
              "#ff4f81"
            );

            // RAGE: All clones get rage aura
            if (rageMode) {
              st.effects = st.effects || [];

              // Spawn rage particles for each clone
              for (let i = 0; i < maxCount; i++) {
                setTimeout(() => {
                  st.effects.push({
                    kind: "rage_aura",
                    x: player.x + (Math.random() - 0.5) * 200,
                    y: player.y + (Math.random() - 0.5) * 200,
                    radius: 40,
                    color: "#ff4444",
                    life: 1000,
                    max: 1000,
                  });
                }, i * 100);
              }
            }
          }, 200);
        },
      },
      S3: {
        name: "BOSS DESTROYER",
        cooldown: 12000,
        power: 110,
        cast(player) {
          console.log('[A1 S3] Cast started - Boss Destroyer with thick X-waves');
          
          // Check RAGE and CHARGE state
          const rageMode = isRageMode(player);
          const held = performance.now() - (player._hold?.s3start || performance.now());
          const chargeK = Math.min(1, held / 400); // 0 to 1 over 400ms
          const isCharged = chargeK >= 0.4;
          
          console.log('[A1 S3] Rage:', rageMode, 'Hold:', held, 'ms, chargeK:', chargeK, 'isCharged:', isCharged);
          
          const st = gameState();
          const power = this.power || 110;
          const slashes = rageMode ? 6 : 5;
          const cadence = 500; // 0.5s between slashes

          // Execute 5-6 slashes with damage splash and visible red/black arcs
          for (let i = 0; i < slashes; i++) {
            setTimeout(() => {
              const enemies = getNearbyEnemies(player, 190);
              const dmg = Math.round(power * (rageMode ? 1.3 : 1.2));
              damageEnemies(enemies, dmg, '#ff5979');
              simpleEffect(player.x, player.y, 120 + i * 10, '#ff5979', 0.28);

              // Add red arc stroke (outer)
              st.effects = st.effects || [];
              st.effects.push({
                kind: "luna_arc",
                x: player.x + 20,
                y: player.y - 20,
                radius: 100 + i * 15,
                angle: (i * Math.PI) / 4,
                color: "#ff0000",
                life: 500,
                max: 500,
                direction: player.facingLeft ? -1 : 1,
              });
              // Add black arc stroke (inner shadow)
              st.effects.push({
                kind: "luna_arc",
                x: player.x + 20,
                y: player.y - 20,
                radius: 85 + i * 12,
                angle: (i * Math.PI) / 4,
                color: "#1a1a1a",
                life: 500,
                max: 500,
                direction: player.facingLeft ? -1 : 1,
              });

              // On last slash, release the X-waves
              if (i === slashes - 1) {
                if (isCharged) {
                  // CHARGED: Auto-float ~0.9s, then 2 XXL thick X's (50% bigger = 2.4x total)
                  console.log('[A1 S3] CHARGE mode: Auto-float + 2 XXL X-waves');
                  
                  // Auto-float effect (if VFX available)
                  if (window.VFX?.autoFloat) {
                    window.VFX.autoFloat(player, 900);
                  } else {
                    // Simple float substitute
                    const origY = player.y;
                    player.y -= 15;
                    setTimeout(() => { player.y = origY; }, 900);
                  }
                  
                  // Fire 2 XXL X-waves after float delay (600ms into float)
                  setTimeout(() => {
                    console.log('[A1 S3] Firing 2 XXL X-waves');
                    window.queueX?.(player, 2, {
                      size: 2.4,       // 1.6 × 1.5 = 50% bigger
                      armPct: 35,      // Thicker arms
                      dmgM: 1.5,
                      pierce: 999,     // Hit all enemies
                      speed: 1120,
                      aoe: 60,         // 50% bigger AOE (40 × 1.5)
                      life: 1600,      // Longer lifetime
                      color: '#ff0000',    // Pure red core
                      color2: '#000000',   // Pure black rim
                      colorEdge: '#ff4444' // Red edge trail
                    });
                  }, 600);
                  
                } else {
                  // TAP: 4 big thick X's (50% bigger = 1.95x total)
                  console.log('[A1 S3] TAP mode: Firing 4 thick X-waves');
                  window.queueX?.(player, 4, {
                    size: 1.95,      // 1.3 × 1.5 = 50% bigger
                    armPct: 33,      // Thicker arms
                    dmgM: rageMode ? 1.3 : 1.2,
                    pierce: 999,     // Hit all enemies
                    speed: 1080,
                    aoe: 52,         // 50% bigger AOE (35 × 1.5)
                    life: 1500,      // Longer lifetime
                    color: '#ff0000',    // Pure red core
                    color2: '#000000',   // Pure black rim
                    colorEdge: '#ff4444' // Red edge trail
                  });
                }
              }
            }, i * cadence);
          }
        },
      },
      S4: {
        name: "CRIMSON EXECUTION",
        cooldown: 20000,
        power: 800,
        rageRequired: 100,
        cast(player) {
          if ((player.rage || 0) < this.rageRequired) {
            showMessage("Need 100 Rage!");
            return false;
          }
          player.rage -= this.rageRequired;

          // RAGE DETECTION
          const rageMode = isRageMode(player);
          const rageMult = getRageMultiplier("S4");
          addRageVisuals(player, "S4");

          showMessage("CRIMSON EXECUTION!");
          const enemies = getNearbyEnemies(player, 280);

          // RAGE: More hits and enhanced effects
          const hitCount = rageMode ? 20 : 10;
          const hitDelay = rageMode ? 50 : 100;

          for (let i = 0; i < hitCount; i++) {
            setTimeout(() => {
              enemies.forEach((enemy) => {
                const threshold = (enemy.hpMax || 1000) * 0.3;
                if (enemy.hp <= threshold) {
                  executeEnemy(enemy, player);
                } else {
                  const dmg = this.power / hitCount;
                  enemy.hp -= dmg;
                  showDamage(enemy.x, enemy.y, dmg, "#ff4d4f");
                  if (enemy.hp <= 0) executeEnemy(enemy, player);
                }
              });

              // RAGE: Red lightning between hits
              if (rageMode && i % 3 === 0) {
                const st = gameState();
                st.effects = st.effects || [];

                st.effects.push({
                  kind: "lightning_bolt",
                  x: player.x,
                  y: player.y,
                  targetX: player.x + (Math.random() - 0.5) * 400,
                  targetY: player.y + (Math.random() - 0.5) * 400,
                  color: "#ff4444",
                  life: 200,
                  max: 200,
                });
              }
            }, i * hitDelay);
          }

          // Enhanced effects (NO BEAM)
          const effectRadius = rageMode ? 400 : 320;
          simpleEffect(
            player.x,
            player.y,
            effectRadius,
            "#ff4d4f",
            rageMode ? 1.0 : 0.8
          );
          window.VFX?.Camera?.shake?.(rageMode ? 15 : 10, 260, 16);
          triggerSkillFx(player, "S4", { x: player.x, y: player.y });

          // Spawn multiple crimson X waves instead of beam - spread in different directions
          const xWaveCount = rageMode ? 8 : 5;
          for (let j = 0; j < xWaveCount; j++) {
            setTimeout(() => {
              // Create X projectile in fan pattern
              const list = ensureProjectileList();
              const baseX = player.x + 24;
              const baseY = player.y - 28;
              const birth = nowMS();
              const dir = player.facingLeft ? Math.PI : 0;
              const spread = (j / (xWaveCount - 1 || 1) - 0.5) * 0.8; // Fan spread

              const proj = {
                type: "x_wave",
                x: baseX,
                y: baseY,
                vx: 700 * Math.cos(dir + spread),
                vy: 700 * Math.sin(dir + spread),
                size: 60,
                color: "#ff4d4f",
                life: 2000,
                birth,
                pierce: 999,
                dmg: 80,
                radius: 50,
                rotation: 0,
                update(dtMs) {
                  const st = gameState();
                  const dt = (typeof dtMs === "number" ? dtMs : 16) / 1000;
                  this.x += (this.vx || 0) * dt;
                  this.y += (this.vy || 0) * dt;
                  this.rotation += dt * 8;

                  const enemies = st.enemies || [];
                  const r2 = (this.radius || 50) * (this.radius || 50);
                  for (const e of enemies) {
                    if (
                      !e ||
                      e.dead ||
                      e.hp <= 0 ||
                      e._hitByXWave === this.birth
                    )
                      continue;
                    const dx = (e.x || 0) - this.x;
                    const dy = (e.y || 0) - this.y;
                    if (dx * dx + dy * dy <= r2) {
                      e.hp -= this.dmg || 80;
                      e._hitByXWave = this.birth;
                      showDamage(e.x, e.y, this.dmg, this.color);
                      simpleEffect(e.x, e.y, 40, this.color, 0.3);
                      if (e.hp <= 0) {
                        e.dead = true;
                        try {
                          window.killEnemy?.(e);
                        } catch (_) {}
                      }
                    }
                  }
                  if (nowMS() - this.birth > this.life) this.dead = true;
                },
                render(ctx) {
                  ctx.save();
                  ctx.globalCompositeOperation = "lighter";
                  ctx.translate(this.x, this.y);
                  ctx.rotate(this.rotation);

                  ctx.strokeStyle = this.color || "#ff4d4f";
                  ctx.lineWidth = 6;
                  ctx.shadowBlur = 20;
                  ctx.shadowColor = this.color || "#ff4d4f";
                  ctx.beginPath();
                  ctx.moveTo(-this.size * 0.5, -this.size * 0.5);
                  ctx.lineTo(this.size * 0.5, this.size * 0.5);
                  ctx.moveTo(this.size * 0.5, -this.size * 0.5);
                  ctx.lineTo(-this.size * 0.5, this.size * 0.5);
                  ctx.stroke();

                  ctx.strokeStyle = "#ffffff";
                  ctx.lineWidth = 3;
                  ctx.shadowBlur = 15;
                  ctx.beginPath();
                  ctx.moveTo(-this.size * 0.4, -this.size * 0.4);
                  ctx.lineTo(this.size * 0.4, this.size * 0.4);
                  ctx.moveTo(this.size * 0.4, -this.size * 0.4);
                  ctx.lineTo(-this.size * 0.4, this.size * 0.4);
                  ctx.stroke();

                  ctx.restore();
                },
              };
              list.push(proj);
            }, j * 100);
          }

          // RAGE: Screen flash
          if (rageMode) {
            const st = gameState();
            st.effects = st.effects || [];

            st.effects.push({
              kind: "screen_flash",
              color: "#ff4444",
              life: 300,
              max: 300,
            });
          }

          return true;
        },
      },
    },
    UNIQUE: {
      S1: {
        name: "Frost Wave",
        cooldown: 2500,
        power: 130,
        cast(player) {
          // RAGE DETECTION
          const rageMode = isRageMode(player);
          const rageMult = getRageMultiplier("S1");
          addRageVisuals(player, "S1");

          const power = 130;
          const enemies = getNearbyEnemies(player, 180);
          damageEnemies(enemies, power, "#74b9ff");

          // Ice wave effect
          simpleEffect(player.x, player.y, 180, "#74b9ff", 0.3);

          // RAGE: Multiple ice waves with BIGGER projectiles
          const waveCount = rageMode ? 4 : 1;
          for (let i = 0; i < waveCount; i++) {
            setTimeout(() => {
              spawnShardVolleys(player, "#74b9ff", 6, 540, 24); // Increased from 16 to 24

              // Frost particles
              const st = gameState();
              st.effects = st.effects || [];
              for (let j = 0; j < 5; j++) {
                st.effects.push({
                  kind: "fire_particle",
                  x: player.x + (Math.random() - 0.5) * 60,
                  y: player.y + (Math.random() - 0.5) * 60,
                  vx: (Math.random() - 0.5) * 3,
                  vy: (Math.random() - 0.5) * 3,
                  color: "#74b9ff",
                  life: 300,
                  max: 300,
                });
              }
            }, i * 120);
          }
        },
      },
      S2: {
        name: "Combat Drone Fleet",
        cooldown: 6000,
        power: 80,
        cast(player) {
          // RAGE + HOLD DETECTION
          const rageMode = isRageMode(player);
          const holdResult = window.lastHoldS2 || { held: false, ms: 0, mode: 'tap' };
          const mode = rageMode ? (holdResult.held ? 'rageHold' : 'rageTap') : (holdResult.held ? 'hold' : 'tap');
          const plan = window.SkillPlanner ? window.SkillPlanner.getSlashPlan('S2', mode) : { extras: { dashRange: 500, dashSpeed: 14 } };
          
          const rageMult = getRageMultiplier("S2");
          addRageVisuals(player, "S2");

          // PLAYER DASH TO NEAREST ENEMY BEFORE SUMMONING
          const st = gameState();
          const enemies = st.enemies || [];
          const dashRange = plan.extras.dashRange || 500;
          const dashSpeed = plan.extras.dashSpeed || 14;
          const target = window.nearestEnemyStrict ? window.nearestEnemyStrict(player) : enemies.find(e => !e.dead);
          
          if (target) {
            const dx = target.x - player.x;
            const dy = target.y - player.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist > 80 && dist < dashRange) {
              const dashDist = Math.min(dist - 60, dashRange);
              const steps = 10;
              const stepX = (dx / dist) * dashDist / steps;
              const stepY = (dy / dist) * dashDist / steps;
              player.facingLeft = dx < 0;
              
              // Animate player dash with frost trail
              for (let i = 0; i < steps; i++) {
                setTimeout(() => {
                  player.x += stepX;
                  player.y += stepY;
                  
                  st.effects = st.effects || [];
                  st.effects.push({
                    kind: "luna_arc",
                    x: player.x,
                    y: player.y,
                    radius: 30,
                    angle: 0,
                    color: mode === 'rageHold' ? "#00cec999" : "#00cec966",
                    life: 200,
                    max: 200,
                    direction: player.facingLeft ? -1 : 1
                  });
                }, i * 20);
              }
            }
          }

          // Delay summoning until after dash completes
          setTimeout(() => {
            // RAGE: More drones and enhanced stats
            const maxCount = rageMode ? 8 : 4;
            const baseHp = rageMode ? 60 : 40;
            const baseDmg = rageMode ? 40 : 28;

            healPlayer(player, 40);
            castS2Common(
              player,
              "drone",
              {
                maxCount: maxCount,
                baseHp: baseHp,
                baseDmg: baseDmg,
                levelHp: 8,
                levelDmg: 2,
                attackCD: 450,
                healAmount: 6,
                healCD: 1000,
                color: "#00cec9",
                attackRadius: 260,
                tauntRadius: 260,
                tauntDuration: 2600,
                power: this.power,
                rageMode: rageMode,
                extra: {
                  chaseSpeed: rageMode ? 8.8 : 7.8,
                  followSpeed: 5,
                  dashSpeed: 16,
                  dashDuration: 0.2,
                  dashCooldown: rageMode ? 1.6 : 2.1,
                  dashChance: rageMode ? 0.42 : 0.32,
                  comboSkills: ["UNIQUE_ION", "UNIQUE_STORM"],
                  comboCooldown: rageMode ? 1.6 : 1.9,
                  comboRange: 320,
                  projectileVolley: {
                    count: rageMode ? 7 : 5,
                    speed: 700,
                    radius: 18,
                    color: "#74b9ff",
                    damageScale: 0.98,
                    homing: true,
                    scatter: 0.18,
                    cooldown: rageMode ? 2.2 : 2.6,
                  },
                  lootAffinity: 0.45,
                  lootPull: 220,
                  animeColor: "#74b9ff",
                  bossPriority: true,
                  buffOwner: true,
                },
                entryVolley: {
                  count: rageMode ? 10 : 8,
                  speed: 640,
                  radius: 18,
                  color: "#74b9ff",
                  damageScale: 0.92,
                },
              },
              "#00cec9"
            );

            // RAGE: Lightning aura for drones
            if (rageMode) {
              const st = gameState();
              st.effects = st.effects || [];
              for (let i = 0; i < maxCount; i++) {
                setTimeout(() => {
                  st.effects.push({
                    kind: "rage_aura",
                    x: player.x + (Math.random() - 0.5) * 200,
                    y: player.y + (Math.random() - 0.5) * 200,
                    radius: 40,
                    color: "#74b9ff",
                    life: 1000,
                    max: 1000,
                  });
                }, i * 100);
              }
            }
          }, 200);
        },
      },
      S3: {
        name: "MOB ANNIHILATOR",
        cooldown: 12000,
        power: 300,
        cast(player) {
          // RAGE DETECTION
          const rageMode = isRageMode(player);
          const rageMult = getRageMultiplier("S3");
          addRageVisuals(player, "S3");

          const st = gameState();
          const enemies = (st.enemies || []).filter(
            (enemy) => !enemy.dead && enemy.hp > 0
          );

          // Screen-wide lightning storm
          enemies.forEach((enemy) => {
            const neighbors = getNearbyEnemies(enemy, 120).length;
            const bonus = neighbors * 20;
            const damage = this.power + bonus;
            enemy.hp -= damage;
            showDamage(enemy.x, enemy.y, damage, "#55a3ff");

            // Lightning beam to each enemy
            st.effects = st.effects || [];
            st.effects.push({
              kind: "lightning_bolt",
              x: player.x,
              y: player.y,
              targetX: enemy.x,
              targetY: enemy.y,
              color: "#74b9ff",
              life: 400,
              max: 400,
            });

            if (enemy.hp <= 0) {
              enemy.dead = true;
              if (typeof window.killEnemy === "function")
                window.killEnemy(enemy);
            }
          });

          // Large impact effect (NO BEAM)
          simpleEffect(player.x, player.y, 320, "#74b9ff", 0.7);
          window.VFX?.Camera?.shake?.(rageMode ? 12 : 8, 260, 16);

          // RAGE: Multiple lightning storms
          if (rageMode) {
            for (let i = 1; i < 3; i++) {
              setTimeout(() => {
                enemies.forEach((enemy) => {
                  if (!enemy.dead && enemy.hp > 0) {
                    enemy.hp -= this.power * 0.5;
                    showDamage(enemy.x, enemy.y, this.power * 0.5, "#74b9ff");

                    st.effects.push({
                      kind: "lightning_bolt",
                      x: player.x,
                      y: player.y,
                      targetX: enemy.x,
                      targetY: enemy.y,
                      color: "#74b9ff",
                      life: 400,
                      max: 400,
                    });
                  }
                });
              }, i * 300);
            }
          }
        },
      },
      S4: {
        name: "CHAIN DESTRUCTION",
        cooldown: 20000,
        power: 500,
        rageRequired: 100,
        cast(player) {
          if ((player.rage || 0) < this.rageRequired) {
            showMessage("Need 100 Rage!");
            return false;
          }
          player.rage -= this.rageRequired;

          // RAGE DETECTION
          const rageMode = isRageMode(player);
          const rageMult = getRageMultiplier("S4");
          addRageVisuals(player, "S4");

          showMessage("CHAIN DESTRUCTION!");
          const enemies = getNearbyEnemies(player, 300);
          enemies.sort((a, b) => (a.hp || 0) - (b.hp || 0));
          chainDamage(enemies, this.power, rageMode ? 15 : 8);

          // Chain lightning visuals
          const st = gameState();
          st.effects = st.effects || [];
          for (let i = 0; i < Math.min(enemies.length, 8); i++) {
            if (enemies[i] && !enemies[i].dead) {
              st.effects.push({
                kind: "lightning_bolt",
                x: i === 0 ? player.x : enemies[i - 1].x,
                y: i === 0 ? player.y : enemies[i - 1].y,
                targetX: enemies[i].x,
                targetY: enemies[i].y,
                color: "#6aa8ff",
                life: 600,
                max: 600,
              });
            }
          }

          simpleEffect(player.x, player.y, 320, "#6aa8ff", 0.7);
          triggerSkillFx(player, "S4", { x: player.x, y: player.y });
          window.VFX?.Camera?.shake?.(rageMode ? 12 : 8, 260, 16);

          // RAGE: Screen flash
          if (rageMode) {
            st.effects.push({
              kind: "screen_flash",
              color: "#74b9ff",
              life: 300,
              max: 300,
            });
          }

          return true;
        },
      },
    },
    MISSY: {
      S1: {
        name: "Lucky Spin",
        cooldown: 2500,
        power: 150,
        cast(player) {
          // RAGE DETECTION
          const rageMode = isRageMode(player);
          const rageMult = getRageMultiplier("S1");
          addRageVisuals(player, "S1");

          const power = 150;
          const enemies = getNearbyEnemies(player, 180);
          damageEnemies(enemies, power, "#ffd56a");

          // Golden tornado effect
          simpleEffect(player.x, player.y, 180, "#ffd56a", 0.3);

          // Loot vacuum
          const st = gameState();
          const items = st.items || [];
          items.forEach((item) => {
            const dx = player.x - item.x;
            const dy = player.y - item.y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 1400) {
              item.x += (dx / dist) * 10;
              item.y += (dy / dist) * 10;
            }
          });

          // RAGE: Gold beams rain from sky (BIGGER projectiles)
          const beamCount = rageMode ? 12 : 8;
          for (let i = 0; i < beamCount; i++) {
            setTimeout(() => {
              // Spawn gold beams from above the player
              const list = ensureProjectileList();
              const randomX = player.x + (Math.random() - 0.5) * 400;
              const startY = player.y - 600; // Start high above
              const birth = nowMS();

              const beam = {
                type: "gold_beam",
                x: randomX,
                y: startY,
                vx: 0,
                vy: 800, // Fall down fast
                size: 28, // BIGGER beam
                color: "#ffd56a",
                life: 2000,
                birth,
                pierce: 5,
                dmg: 150,
                radius: 30,
                homing: false,
                update(dtMs) {
                  const st = gameState();
                  const dt = (typeof dtMs === "number" ? dtMs : 16) / 1000;
                  this.x += (this.vx || 0) * dt;
                  this.y += (this.vy || 0) * dt;

                  const enemies = st.enemies || [];
                  const r2 = (this.radius || 30) * (this.radius || 30);
                  for (const e of enemies) {
                    if (!e || e.dead || e.hp <= 0) continue;
                    const dx = (e.x || 0) - this.x;
                    const dy = (e.y || 0) - this.y;
                    if (dx * dx + dy * dy <= r2) {
                      e.hp -= this.dmg || 150;

                      // HIT EFFECT
                      showDamage(e.x, e.y, this.dmg, this.color);
                      simpleEffect(e.x, e.y, 50, this.color, 0.35);
                      st.effects = st.effects || [];

                      // Gold sparkles
                      for (let j = 0; j < 6; j++) {
                        st.effects.push({
                          kind: "fire_particle",
                          x: e.x + (Math.random() - 0.5) * 30,
                          y: e.y + (Math.random() - 0.5) * 30,
                          vx: (Math.random() - 0.5) * 4,
                          vy: (Math.random() - 0.5) * 4,
                          color: this.color,
                          life: 250,
                          max: 250,
                        });
                      }

                      if (e.hp <= 0) {
                        e.dead = true;
                        try {
                          window.killEnemy?.(e);
                        } catch (_) {}
                      }
                      if (!this.pierce || --this.pierce <= 0) {
                        this.dead = true;
                        break;
                      }
                    }
                  }
                  if (nowMS() - this.birth > this.life) this.dead = true;
                },
                render(ctx) {
                  ctx.save();
                  ctx.globalCompositeOperation = "lighter";

                  // Golden beam falling from sky
                  ctx.strokeStyle = this.color || "#ffd56a";
                  ctx.lineWidth = this.size || 28;
                  ctx.shadowBlur = 25;
                  ctx.shadowColor = this.color || "#ffd56a";
                  ctx.lineCap = "round";

                  ctx.beginPath();
                  ctx.moveTo(this.x, this.y - 100);
                  ctx.lineTo(this.x, this.y + 100);
                  ctx.stroke();

                  // Inner bright core
                  ctx.strokeStyle = "#ffffff";
                  ctx.lineWidth = (this.size || 28) * 0.5;
                  ctx.shadowBlur = 15;
                  ctx.beginPath();
                  ctx.moveTo(this.x, this.y - 100);
                  ctx.lineTo(this.x, this.y + 100);
                  ctx.stroke();

                  ctx.restore();
                },
              };
              list.push(beam);

              // Gold particles for visual effect
              st.effects = st.effects || [];
              for (let j = 0; j < 5; j++) {
                st.effects.push({
                  kind: "fire_particle",
                  x: randomX + (Math.random() - 0.5) * 40,
                  y: startY + (Math.random() - 0.5) * 40,
                  vx: (Math.random() - 0.5) * 2,
                  vy: Math.random() * 3 + 2,
                  color: "#ffd56a",
                  life: 400,
                  max: 400,
                });
              }
            }, i * 80);
          }
        },
      },
      S2: {
        name: "Lucky Battle Pets",
        cooldown: 6000,
        power: 120,
        cast(player) {
          // RAGE + HOLD DETECTION
          const rageMode = isRageMode(player);
          const holdResult = window.lastHoldS2 || { held: false, ms: 0, mode: 'tap' };
          const mode = rageMode ? (holdResult.held ? 'rageHold' : 'rageTap') : (holdResult.held ? 'hold' : 'tap');
          const plan = window.SkillPlanner ? window.SkillPlanner.getSlashPlan('S2', mode) : { extras: { dashRange: 500, dashSpeed: 14 } };
          
          const rageMult = getRageMultiplier("S2");
          addRageVisuals(player, "S2");

          // PLAYER DASH TO NEAREST ENEMY BEFORE SUMMONING
          const st = gameState();
          const enemies = st.enemies || [];
          const dashRange = plan.extras.dashRange || 500;
          const dashSpeed = plan.extras.dashSpeed || 14;
          const target = window.nearestEnemyStrict ? window.nearestEnemyStrict(player) : enemies.find(e => !e.dead);
          
          if (target) {
            const dx = target.x - player.x;
            const dy = target.y - player.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            if (dist > 80 && dist < dashRange) {
              const dashDist = Math.min(dist - 60, dashRange);
              const steps = 6;
              const stepX = (dx / dist) * dashDist / steps;
              const stepY = (dy / dist) * dashDist / steps;
              player.facingLeft = dx < 0;
              
              // Animate player dash with golden trail
              for (let i = 0; i < steps; i++) {
                setTimeout(() => {
                  player.x += stepX;
                  player.y += stepY;
                  
                  if (i % 2 === 0) {
                    st.effects = st.effects || [];
                    st.effects.push({
                      kind: "luna_arc",
                      x: player.x,
                      y: player.y,
                      radius: 24,
                      angle: 0,
                      color: mode === 'rageHold' ? "#ffd56a66" : "#ffd56a44",
                      life: 140,
                      max: 140,
                      direction: player.facingLeft ? -1 : 1
                    });
                  }
                }, i * 20);
              }
            }
          }

          // Delay summoning until after dash completes
          setTimeout(() => {
            // RAGE: More pets and enhanced stats
            const maxCount = rageMode ? 7 : 4;
            const baseHp = rageMode ? 86 : 68;
            const baseDmg = rageMode ? 42 : 30;

            healPlayer(player, 60);
            castS2Common(
              player,
              "pet",
              {
                maxCount: maxCount,
                baseHp: baseHp,
                baseDmg: baseDmg,
                levelHp: 10,
                levelDmg: 2,
                attackCD: 600,
                color: "#55efc4",
                attackRadius: 260,
                tauntRadius: 300,
                tauntDuration: 3000,
                power: this.power,
                rageMode: rageMode,
                extra: {
                  chaseSpeed: rageMode ? 8.6 : 7.8,
                  followSpeed: 5.2,
                  dashSpeed: 15,
                  dashDuration: 0.18,
                  dashCooldown: rageMode ? 1.8 : 2.2,
                  dashChance: rageMode ? 0.4 : 0.28,
                  comboSkills: ["MISSY_BITE", "MISSY_CLAW", "MISSY_HEAL"],
                  comboCooldown: rageMode ? 1.8 : 2.1,
                  comboRange: 300,
                  projectileVolley: {
                    count: rageMode ? 6 : 4,
                    speed: 580,
                    radius: 18,
                    color: "#ffd56a",
                    damageScale: rageMode ? 1.02 : 0.9,
                    scatter: 0.24,
                    cooldown: rageMode ? 2.1 : 2.5,
                  },
                  lootAffinity: 0.6,
                  lootPull: 220,
                  animeColor: "#ffd56a88",
                  lowHpExecute: false,
                  bossPriority: true,
                  buffOwner: true,
                },
                entryVolley: {
                  count: rageMode ? 8 : 5,
                  speed: 580,
                  radius: 18,
                  color: "#ffd56a",
                  damageScale: rageMode ? 0.98 : 0.85,
                },
              },
              "#55efc4"
            );

            // RAGE: Golden aura for pets
            if (rageMode) {
              st.effects = st.effects || [];
              const auraCount = Math.min(maxCount, 5);
              for (let i = 0; i < auraCount; i++) {
                setTimeout(() => {
                  st.effects.push({
                    kind: "rage_aura",
                    x: player.x + (Math.random() - 0.5) * 200,
                    y: player.y + (Math.random() - 0.5) * 200,
                    radius: 34,
                    color: "#ffd56a",
                    life: 720,
                    max: 720,
                  });
                }, i * 120);
              }
            }
          }, 200);
        },
      },
      S3: {
        name: "TREASURE NUKE",
        cooldown: 10000,
        power: 350,
        cast(player) {
          // RAGE DETECTION
          const rageMode = isRageMode(player);
          const rageMult = getRageMultiplier("S3");
          addRageVisuals(player, "S3");

          const st = gameState();
          const goldBonus = (st.gold || 0) * 0.005;
          const totalDamage = this.power + goldBonus;
          const enemies = getNearbyEnemies(player, 260);
          damageEnemies(enemies, totalDamage, "#ffd700");

          // Drop extra loot
          enemies.forEach((enemy) => {
            if (Math.random() < (rageMode ? 0.8 : 0.5)) {
              st.items = st.items || [];
              st.items.push({
                x: enemy.x,
                y: enemy.y,
                type: "gold",
                value: 100 + Math.round(Math.random() * 200),
              });
            }
          });

          // RAGE: Multiple golden projectiles (BIGGER)
          const projectileCount = rageMode ? 5 : 3;
          for (let i = 0; i < projectileCount; i++) {
            setTimeout(() => {
              // Large golden impact (NO BEAM)
              simpleEffect(player.x, player.y, 220, "#ffd700", 0.35);

              // Golden projectiles (BIGGER SIZE)
              spawnShardVolleys(player, "#ffd700", 8, 600, 28);

              // Treasure particles
              st.effects = st.effects || [];
              for (let j = 0; j < 10; j++) {
                st.effects.push({
                  kind: "fire_particle",
                  x: player.x + (Math.random() - 0.5) * 100,
                  y: player.y + (Math.random() - 0.5) * 100,
                  vx: (Math.random() - 0.5) * 4,
                  vy: (Math.random() - 0.5) * 4,
                  color: "#ffd700",
                  life: 400,
                  max: 400,
                });
              }
            }, i * 150);
          }

          window.VFX?.Camera?.shake?.(rageMode ? 10 : 6, 260, 16);
        },
      },
      S4: {
        name: "DIVINE JACKPOT",
        cooldown: 20000,
        power: 600,
        rageRequired: 100,
        cast(player) {
          if ((player.rage || 0) < this.rageRequired) {
            showMessage("Need 100 Rage!");
            return false;
          }
          player.rage -= this.rageRequired;

          // RAGE DETECTION
          const rageMode = isRageMode(player);
          const rageMult = getRageMultiplier("S4");
          addRageVisuals(player, "S4");

          showMessage("DIVINE JACKPOT!");

          player.flying = true;
          player.flyingTimer = rageMode ? 15000 : 10000; // Extended in rage
          player.invulnerableUntil =
            (player.invulnerableUntil || nowMS()) + (rageMode ? 15000 : 10000);
          player._flightStartY = player.y;

          const pets = (gameState().summons || []).filter(
            (s) => s.owner === player && s.type === "pet" && !s.dead
          );
          pets.forEach((pet) => {
            const levels = Math.min(rageMode ? 20 : 10, 50 - pet.level || 0);
            pet.level += levels;
            pet.hpMax += levels * 12;
            pet.hp = pet.hpMax;
            pet.dmg += levels * 3;
            pet.def += levels;
            simpleEffect(pet.x, pet.y, 70, "#ffd700", 0.6);
          });

          const enemies = getNearbyEnemies(player, 320);
          damageEnemies(enemies, this.power, "#ffd700");
          simpleEffect(player.x, player.y, 320, "#ffd700", 0.8);
          triggerSkillFx(player, "S4", { x: player.x, y: player.y });
          window.VFX?.Camera?.shake?.(rageMode ? 12 : 8, 260, 16);

          // Rainbow golden waves (NO BEAM) - BIGGER projectiles
          for (let i = 0; i < 8; i++) {
            setTimeout(() => {
              spawnShardVolleys(player, "#ffd700", 10, 700, 26); // Increased from 18 to 26
            }, i * 80);
          }

          // RAGE: Screen flash
          if (rageMode) {
            const st = gameState();
            st.effects = st.effects || [];
            st.effects.push({
              kind: "screen_flash",
              color: "#ffd700",
              life: 300,
              max: 300,
            });
          }

          return true;
        },
      },
    },
  };

  window.SIMPLE_SKILLS = SIMPLE_SKILLS;

  window.useSimpleSkill = function (player, skillKey) {
    if (!player || player.isDefeated) return false;
    const heroId = normalizeHeroId(player.id);
    const heroSkills = SIMPLE_SKILLS[heroId];
    if (!heroSkills) {
      console.error("No skills for hero:", player.id, "Normalized:", heroId);
      return false;
    }
    const skill = heroSkills[skillKey];
    if (!skill) {
      console.error("No skill:", skillKey);
      return false;
    }
    const now = Date.now();
    player.cooldowns = player.cooldowns || {};
    if (player.cooldowns[skillKey] && now < player.cooldowns[skillKey]) {
      showMessage("Skill on cooldown!");
      return false;
    }
    const result = skill.cast(player);
    if (result === false) return false;
    player.cooldowns[skillKey] = now + (skill.cooldown || 0);
    showMessage(`${skill.name}!`);
    announceSkill(player, skill.name, SKILL_COLORS[heroId] || "#ffd700");
    return true;
  };

  function updateSummons(dtSeconds) {
    const st = gameState();
    const summons = st.summons || [];
    const enemies = st.enemies || [];
    for (let i = summons.length - 1; i >= 0; i -= 1) {
      const summon = summons[i];
      if (!summon || summon.dead) {
        summons.splice(i, 1);
        continue;
      }
      const owner = summon.owner;
      if (!owner || owner.isDefeated) {
        summon.dead = true;
        continue;
      }

      const extra = summon.extra || {};
      summon._dashCD = Math.max(0, (summon._dashCD || 0) - dtSeconds);
      summon._dashWindow = Math.max(0, (summon._dashWindow || 0) - dtSeconds);
      summon._volleyFlash = Math.max(0, (summon._volleyFlash || 0) - dtSeconds);

      const now = nowMS();
      const range = summon.attackRadius || 200;
      const targetEnemy =
        selectSummonEnemy(summon, enemies, extra) ||
        getNearbyEnemies(summon, range * 1.5)[0];
      const activeTarget =
        targetEnemy && !targetEnemy.dead ? targetEnemy : null;

      if (summon.attackCD && now - summon.lastAttack >= summon.attackCD) {
        if (activeTarget) {
          const damage = (summon.dmg || 10) * (extra.damageScale || 1);
          activeTarget.hp -= damage;
          showDamage(
            activeTarget.x,
            activeTarget.y,
            damage,
            summon.color || "#ffffff"
          );
          simpleEffect(
            activeTarget.x,
            activeTarget.y,
            Math.min(52, range * 0.28),
            summon.color || "#ffffff",
            0.24
          );
          summon._swordT = Math.max(summon._swordT || 0, 260);
          if (activeTarget.hp <= 0) {
            activeTarget.dead = true;
            if (typeof window.killEnemy === "function")
              window.killEnemy(activeTarget);
          }
          summon.lastAttack = now;
        }
      }

      if (
        summon.healAmount &&
        summon.healCD &&
        now - summon.lastHeal >= summon.healCD
      ) {
        healPlayer(owner, summon.healAmount);
        summon.lastHeal = now;
      }

      if (summon._swordT > 0) summon._swordT -= dtSeconds * 1000;

      let targetX;
      let targetY;
      if (activeTarget) {
        targetX = activeTarget.x;
        targetY = activeTarget.y;
        summon.chasing = true;
      } else {
        targetX = owner.x || 0;
        targetY = owner.y || 0;
        summon.chasing = false;
      }

      const dx = targetX - (summon.x || 0);
      const dy = targetY - (summon.y || 0);
      const dist = Math.sqrt(dx * dx + dy * dy) || 0;

      if (
        summon.chasing &&
        dist > 100 &&
        extra.dashChance > 0 &&
        summon._dashCD <= 0
      ) {
        if (Math.random() < extra.dashChance) {
          summon._dashWindow = extra.dashDuration || 0.22;
          summon._dashCD = (extra.dashCooldown || 1.9) + Math.random() * 0.4;
          animeBurst(
            summon.x,
            summon.y,
            extra.animeColor || summon.color,
            70,
            12
          );
        }
      }

      if (dist > 18) {
        let speed = summon.chasing
          ? extra.chaseSpeed || 6
          : extra.followSpeed || 4;
        if (summon._dashWindow > 0) speed = extra.dashSpeed || 15;
        const step = clamp(dtSeconds * speed * 60, 0, dist);
        if (dist > 0) {
          summon.x += (dx / dist) * step;
          summon.y += (dy / dist) * step;
        }
      }

      if (summon.tauntRadius) {
        const tauntSq = summon.tauntRadius * summon.tauntRadius;
        if (!summon._lastTauntFx || now - summon._lastTauntFx > 800) {
          emitTauntRing(summon, summon.color || "#ffd56a", 520);
          summon._lastTauntFx = now;
        }
        for (const enemy of enemies) {
          if (!enemy || enemy.dead) continue;
          const dxEnemy = (enemy.x || 0) - summon.x;
          const dyEnemy = (enemy.y || 0) - summon.y;
          if (dxEnemy * dxEnemy + dyEnemy * dyEnemy <= tauntSq) {
            enemy.tauntTarget = summon;
            enemy.tauntUntil = now + summon.tauntDuration;
          }
        }
      }

      processSummonSupport(summon, owner, activeTarget, extra, dtSeconds);
    }
  }

  function updateFlight(dtSeconds) {
    const st = gameState();
    const players = st.players || [];
    players.forEach((player) => {
      if (!player || !player.flying) return;
      player.flyingTimer -= dtSeconds * 1000;
      player.y = (player._flightStartY || player.y) - 20;
      if (player.flyingTimer <= 0) {
        player.flying = false;
        player.y = player._flightStartY || player.y;
      }
    });
  }

  const originalUpdate = window.update;
  window.update = function (dt) {
    if (typeof originalUpdate === "function") originalUpdate(dt);
    const dtSeconds = typeof dt === "number" && dt > 0 ? dt / 1000 : 0.016;
    updateSummons(dtSeconds);
    updateFlight(dtSeconds);
  };

  console.log("[SIMPLE_SKILLS] Loaded 12-skill simplified system");
  console.log(
    "   A1: Crimson Slash, Shadow Clone Army, BOSS DESTROYER, CRIMSON EXECUTION"
  );
  console.log(
    "   UNIQUE: Frost Wave, Combat Drone Fleet, MOB ANNIHILATOR, CHAIN DESTRUCTION"
  );
  console.log(
    "   MISSY: Lucky Spin, Lucky Battle Pets, TREASURE NUKE, DIVINE JACKPOT"
  );
})();

</script>
  <!-- Inlined: src/skills/mini-pet-system.js -->
<script>
// src/mini-pet-system.js - Mini Pet System with Sprite Rendering
// Handles mini pet spawning, AI, and sprite rendering

(function() {
  'use strict';

  // Mini pet system configuration
  const MINI_PET_CONFIG = {
    maxPets: 2,
    spawnChance: 0.15, // 15% chance on pet skill use
    duration: 20000, // 20 seconds
    types: {
      companion: {
        name: 'Mini Companion',
        damageMultiplier: 0.5,
        healthMultiplier: 0.4,
        speedMultiplier: 1.2,
        color: '#81ff4f',
        behavior: 'follow'
      },
      guardian: {
        name: 'Mini Guardian',
        damageMultiplier: 0.3,
        healthMultiplier: 0.8,
        speedMultiplier: 0.8,
        color: '#4f81ff',
        behavior: 'guard'
      },
      hunter: {
        name: 'Mini Hunter',
        damageMultiplier: 0.7,
        healthMultiplier: 0.3,
        speedMultiplier: 1.5,
        color: '#ff4f81',
        behavior: 'hunt'
      }
    }
  };

  // Mini pet sprite data
  const MINI_PET_SPRITES = {
    idle: {
      frames: 8,
      fps: 6,
      width: 32,
      height: 32
    },
    hop: {
      frames: 4,
      fps: 10,
      width: 32,
      height: 32
    }
  };

  // Global mini pet state
  window.MINI_PET_SYSTEM = {
    activePets: [],
    config: MINI_PET_CONFIG,
    sprites: MINI_PET_SPRITES,
    
    // Spawn a new mini pet
    spawnMiniPet(owner, petType = 'companion') {
      if (!owner) return null;
      if (this.activePets.length >= MINI_PET_CONFIG.maxPets) return null;

      const typeData = MINI_PET_CONFIG.types[petType] || MINI_PET_CONFIG.types.companion;
      
      const miniPet = {
        id: `mini_pet_${Date.now()}_${Math.random()}`,
        type: 'mini_pet',
        petType: petType,
        owner: owner.id,
        x: owner.x + (Math.random() - 0.5) * 60,
        y: owner.y + (Math.random() - 0.5) * 30,
        vx: 0,
        vy: 0,
        
        // Stats based on owner's stats
        hpMax: Math.round((owner.hpMax || 100) * typeData.healthMultiplier),
        hp: Math.round((owner.hpMax || 100) * typeData.healthMultiplier),
        dmg: Math.round((owner.dmg || 20) * typeData.damageMultiplier),
        speed: 1.0 * typeData.speedMultiplier,
        
        // Mini pet specific properties
        duration: MINI_PET_CONFIG.duration,
        timeLeft: MINI_PET_CONFIG.duration,
        lastAttack: 0,
        attackCooldown: 800,
        
        // AI state
        aiState: typeData.behavior,
        aiTimer: 0,
        target: null,
        homePosition: { x: owner.x, y: owner.y },
        
        // Visual properties
        color: typeData.color,
        size: 16,
        
        // Sprite state
        sprite: {
          animation: 'idle',
          frame: 0,
          frameTimer: 0,
          facingLeft: false
        },
        
        // Skill buttons for UI
        _skillButtons: [
          { x: 0, y: 0, size: 12, skill: 'PET_ATTACK', active: true }
        ]
      };

      this.activePets.push(miniPet);
      
      // Add spawn effect
      if (window.st && window.st.effects) {
        window.st.effects.push({
          kind: 'cast',
          x: miniPet.x,
          y: miniPet.y,
          color: typeData.color,
          life: 600,
          max: 600
        });
      }

      console.log(`🐾 Mini ${typeData.name} spawned`);
      return miniPet;
    },

    // Update all active mini pets
    update(dt) {
      const dtMs = dt * 1000;
      
      for (let i = this.activePets.length - 1; i >= 0; i--) {
        const pet = this.activePets[i];
        
        // Update lifetime
        pet.timeLeft -= dtMs;
        if (pet.timeLeft <= 0 || pet.hp <= 0) {
          this.despawnMiniPet(i);
          continue;
        }
        
        // Update AI
        this.updateMiniPetAI(pet, dt);
        
        // Update sprite animation
        this.updateMiniPetSprite(pet, dt);
        
        // Update skill buttons position
        this.updateMiniPetSkillButtons(pet);
        
        // Update cooldowns
        if (pet.lastAttack > 0) {
          pet.lastAttack = Math.max(0, pet.lastAttack - dtMs);
        }
      }
    },

    // Update mini pet AI behavior
    updateMiniPetAI(pet, dt) {
      const st = window.st;
      if (!st) return;

      const owner = st.players && st.players.find(p => p.id === pet.owner);
      if (!owner) return;

      pet.aiTimer += dt * 1000;

      switch (pet.aiState) {
        case 'follow':
          this.followOwner(pet, owner, dt);
          // Check for enemies to attack
          if (pet.aiTimer > 300) {
            const enemy = this.findNearestEnemy(pet);
            if (enemy && this.getDistance(pet, enemy) < 100) {
              pet.target = enemy;
              pet.aiState = 'attack';
              pet.aiTimer = 0;
            }
          }
          break;
          
        case 'attack':
          if (pet.target && pet.target.hp > 0) {
            this.attackTarget(pet, pet.target, dt);
          } else {
            pet.aiState = 'follow';
            pet.target = null;
            pet.aiTimer = 0;
          }
          break;
          
        case 'guard':
          this.guardOwner(pet, owner, dt);
          break;
          
        case 'hunt':
          this.huntEnemies(pet, dt);
          break;
      }
    },

    // Follow the owner
    followOwner(pet, owner, dt) {
      const dx = owner.x - pet.x;
      const dy = owner.y - pet.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist > 40) {
        const speed = pet.speed * 80 * dt;
        pet.vx = (dx / dist) * speed;
        pet.vy = (dy / dist) * speed;
        pet.x += pet.vx;
        pet.y += pet.vy;
        
        pet.sprite.facingLeft = dx < 0;
        pet.sprite.animation = 'hop';
      } else {
        pet.vx = 0;
        pet.vy = 0;
        pet.sprite.animation = 'idle';
      }
    },

    // Attack target
    attackTarget(pet, target, dt) {
      const dx = target.x - pet.x;
      const dy = target.y - pet.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      pet.sprite.facingLeft = dx < 0;
      
      if (dist > 50) {
        // Move closer
        const speed = pet.speed * 90 * dt;
        pet.vx = (dx / dist) * speed;
        pet.vy = (dy / dist) * speed;
        pet.x += pet.vx;
        pet.y += pet.vy;
        pet.sprite.animation = 'hop';
      } else {
        // Attack
        pet.vx = 0;
        pet.vy = 0;
        
        if (pet.lastAttack <= 0) {
          this.performMiniPetAttack(pet, target);
          pet.lastAttack = pet.attackCooldown;
        }
        
        pet.sprite.animation = 'idle';
      }
    },

    // Guard owner
    guardOwner(pet, owner, dt) {
      const angle = pet.guardAngle || 0;
      const radius = 50;
      const targetX = owner.x + Math.cos(angle) * radius;
      const targetY = owner.y + Math.sin(angle) * radius;
      
      const dx = targetX - pet.x;
      const dy = targetY - pet.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      
      if (dist > 15) {
        const speed = pet.speed * 60 * dt;
        pet.vx = (dx / dist) * speed;
        pet.vy = (dy / dist) * speed;
        pet.x += pet.vx;
        pet.y += pet.vy;
        pet.sprite.animation = 'hop';
      } else {
        pet.vx = 0;
        pet.vy = 0;
        pet.sprite.animation = 'idle';
      }
      
      pet.sprite.facingLeft = dx < 0;
      
      // Look for nearby enemies to attack
      if (pet.aiTimer > 500) {
        const enemy = this.findNearestEnemy(pet);
        if (enemy && this.getDistance(pet, enemy) < 80) {
          pet.target = enemy;
          pet.aiState = 'attack';
          pet.aiTimer = 0;
        }
      }
    },

    // Hunt enemies aggressively
    huntEnemies(pet, dt) {
      if (!pet.target || pet.target.hp <= 0) {
        pet.target = this.findNearestEnemy(pet);
      }
      
      if (pet.target) {
        this.attackTarget(pet, pet.target, dt);
      } else {
        // Return to owner if no enemies
        const owner = window.st?.players?.find(p => p.id === pet.owner);
        if (owner) {
          this.followOwner(pet, owner, dt);
        }
      }
    },

    // Perform mini pet attack
    performMiniPetAttack(pet, target) {
      const damage = pet.dmg + Math.floor(Math.random() * (pet.dmg * 0.2));
      
      // Apply damage
      target.hp -= damage;
      
      // Add damage floater
      if (window.addFloater) {
        window.addFloater(target.x, target.y - 20, `-${damage}`, pet.color);
      }
      
      // Add attack effect
      if (window.st && window.st.effects) {
        window.st.effects.push({
          kind: 'impact',
          x: target.x,
          y: target.y,
          color: pet.color,
          life: 200,
          max: 200
        });
      }
      
      // Check if target is killed
      if (target.hp <= 0 && window.onEnemyKilled) {
        window.onEnemyKilled(target);
      }
    },

    // Update mini pet sprite animation
    updateMiniPetSprite(pet, dt) {
      const sprite = pet.sprite;
      const animData = MINI_PET_SPRITES[sprite.animation] || MINI_PET_SPRITES.idle;
      
      sprite.frameTimer += dt * 1000;
      const frameTime = 1000 / animData.fps;
      
      if (sprite.frameTimer >= frameTime) {
        sprite.frame = (sprite.frame + 1) % animData.frames;
        sprite.frameTimer = 0;
      }
    },

    // Update skill button positions
    updateMiniPetSkillButtons(pet) {
      if (!pet._skillButtons) return;
      
      pet._skillButtons[0].x = pet.x;
      pet._skillButtons[0].y = pet.y - 25;
    },

    // Find nearest enemy to pet
    findNearestEnemy(pet) {
      const st = window.st;
      if (!st || !st.enemies) return null;
      
      let nearest = null;
      let minDist = Infinity;
      
      for (const enemy of st.enemies) {
        if (enemy.hp <= 0) continue;
        
        const dist = this.getDistance(pet, enemy);
        if (dist < minDist) {
          minDist = dist;
          nearest = enemy;
        }
      }
      
      return nearest;
    },

    // Get distance between two entities
    getDistance(a, b) {
      const dx = a.x - b.x;
      const dy = a.y - b.y;
      return Math.sqrt(dx * dx + dy * dy);
    },

    // Despawn mini pet
    despawnMiniPet(index) {
      const pet = this.activePets[index];
      if (!pet) return;
      
      // Add despawn effect
      if (window.st && window.st.effects) {
        window.st.effects.push({
          kind: 'cast',
          x: pet.x,
          y: pet.y,
          color: pet.color,
          life: 400,
          max: 400
        });
      }
      
      this.activePets.splice(index, 1);
      console.log('🐾 Mini pet despawned');
    },

    // Use mini pet skill
    useMiniPetSkill(pet, skillKey) {
      if (!pet || pet.hp <= 0) return false;
      
      switch (skillKey) {
        case 'PET_ATTACK':
          if (pet.lastAttack <= 0) {
            const target = this.findNearestEnemy(pet);
            if (target) {
              pet.target = target;
              pet.aiState = 'attack';
              pet.aiTimer = 0;
              return true;
            }
          }
          break;
      }
      
      return false;
    },

    // Render all mini pets
    render(ctx) {
      if (!ctx) return;
      
      for (const pet of this.activePets) {
        this.renderMiniPet(ctx, pet);
      }
    },

    // Render individual mini pet
    renderMiniPet(ctx, pet) {
      ctx.save();
      
      // Apply camera offset if available
      const camera = window.camera || { x: 0, y: 0 };
      const screenX = pet.x - camera.x;
      const screenY = pet.y - camera.y;
      
      // Skip if off-screen
      if (screenX < -50 || screenX > ctx.canvas.width + 50 || 
          screenY < -50 || screenY > ctx.canvas.height + 50) {
        ctx.restore();
        return;
      }
      
      // Draw mini pet sprite
      this.drawMiniPetSprite(ctx, pet, screenX, screenY);
      
      // Draw health bar
      this.drawMiniPetHealthBar(ctx, pet, screenX, screenY);
      
      // Draw skill buttons
      this.drawMiniPetSkillButtons(ctx, pet, screenX, screenY);
      
      ctx.restore();
    },

    // Draw mini pet sprite
    drawMiniPetSprite(ctx, pet, x, y) {
      const sprite = pet.sprite;
      const animData = MINI_PET_SPRITES[sprite.animation] || MINI_PET_SPRITES.idle;
      
      // For now, draw a simple representation
      // In a full implementation, this would load and draw actual sprite frames
      ctx.fillStyle = pet.color;
      ctx.globalAlpha = 0.9;
      
      // Draw body (smaller than clone)
      const size = pet.size;
      ctx.fillRect(x - size/2, y - size, size, size);
      
      // Draw eyes
      ctx.fillStyle = '#ffffff';
      const eyeOffset = sprite.facingLeft ? -4 : 4;
      ctx.fillRect(x + eyeOffset - 1, y - size + 4, 2, 2);
      
      // Draw movement indicator for hopping
      if (sprite.animation === 'hop') {
        ctx.fillStyle = pet.color;
        ctx.globalAlpha = 0.3;
        ctx.fillRect(x - size/2, y - 2, size, 4);
      }
      
      ctx.globalAlpha = 1;
    },

    // Draw mini pet health bar
    drawMiniPetHealthBar(ctx, pet, x, y) {
      const barWidth = 24;
      const barHeight = 3;
      const barX = x - barWidth / 2;
      const barY = y - pet.size - 8;
      
      // Background
      ctx.fillStyle = '#333333';
      ctx.fillRect(barX, barY, barWidth, barHeight);
      
      // Health
      const healthRatio = pet.hp / pet.hpMax;
      ctx.fillStyle = healthRatio > 0.5 ? '#4CAF50' : healthRatio > 0.25 ? '#FF9800' : '#F44336';
      ctx.fillRect(barX, barY, barWidth * healthRatio, barHeight);
    },

    // Draw mini pet skill buttons
    drawMiniPetSkillButtons(ctx, pet, x, y) {
      if (!pet._skillButtons) return;
      
      for (const btn of pet._skillButtons) {
        const btnScreenX = btn.x - (window.camera?.x || 0);
        const btnScreenY = btn.y - (window.camera?.y || 0);
        
        if (!btn.active) continue;
        
        // Button background
        ctx.fillStyle = pet.color;
        ctx.globalAlpha = 0.6;
        ctx.beginPath();
        ctx.arc(btnScreenX, btnScreenY, btn.size, 0, Math.PI * 2);
        ctx.fill();
        
        // Button icon
        ctx.fillStyle = '#ffffff';
        ctx.globalAlpha = 1;
        ctx.font = '8px Arial';
        ctx.textAlign = 'center';
        ctx.fillText('⚔', btnScreenX, btnScreenY + 2);
      }
    },

    // Check for mini pet spawn on pet skill use
    checkMiniPetSpawn(owner, petType = null) {
      if (!owner) return;
      
      if (Math.random() < MINI_PET_CONFIG.spawnChance) {
        // Random pet type if not specified
        if (!petType) {
          const types = Object.keys(MINI_PET_CONFIG.types);
          petType = types[Math.floor(Math.random() * types.length)];
        }
        
        this.spawnMiniPet(owner, petType);
      }
    }
  };

  // Handle mini pet skill button clicks
  window.handleMiniPetSkillButtonClick = function(clickX, clickY) {
    const petSystem = window.MINI_PET_SYSTEM;
    if (!petSystem) return false;
    
    for (const pet of petSystem.activePets) {
      if (!pet._skillButtons) continue;
      
      for (const btn of pet._skillButtons) {
        const dist = Math.hypot(clickX - btn.x, clickY - btn.y);
        if (dist < btn.size && btn.active) {
          petSystem.useMiniPetSkill(pet, btn.skill);
          return true;
        }
      }
    }
    
    return false;
  };

  // Integration with main game loop
  if (typeof window !== 'undefined') {
    // Hook into main update loop
    const originalUpdate = window.update;
    window.update = function(dt) {
      if (originalUpdate) originalUpdate(dt);
      
      if (window.MINI_PET_SYSTEM) {
        window.MINI_PET_SYSTEM.update(dt);
      }
    };
    
    // Hook into render loop
    const originalRender = window.render;
    window.render = function() {
      if (originalRender) originalRender();
      
      const ctx = window.g?.ctx || document.getElementById('cv')?.getContext('2d');
      if (ctx && window.MINI_PET_SYSTEM) {
        window.MINI_PET_SYSTEM.render(ctx);
      }
    };
  }

  console.log('✅ Mini Pet System loaded');
})();
</script>
  <!-- Inlined: src/skills/vfx.js -->
<script>

/*=============================================
  A1K — VFX ENGINE (single-file, CSP-safe, file://-safe)
  Exposes window.VFX with: init(), useCanvas(id), update(dt), draw(), spawn(kind,opts), beam(), burst(), slash(), xSlash(), summon(), impact(), floater().
  No fetch(), no eval(), no inline handlers. External script only.
=============================================*/
(function(){
  if (typeof window === "undefined") return;
  if (window.__SimpleVFXPluginLoaded) return;
  window.__SimpleVFXPluginLoaded = true;
  const VFX = {};
  const TAU = Math.PI * 2;
  const clamp01 = (v)=>v<0?0:(v>1?1:v);

  // Canvas wiring
  let canvas = null, ctx = null;
  let lastT = 0, acc = 0;
  const fixedDt = 1000/60;
  const effects = [];
  const pool = { effects };

  function getCanvas(id){
    if (canvas && ctx) return true;
    const el = document.getElementById(id || "cv") || document.querySelector("canvas");
    if (!el) return false;
    canvas = el;
    ctx = canvas.getContext("2d");
    return true;
  }

  function useCanvas(id){ getCanvas(id); }

  function init(opts){
    useCanvas(opts && opts.canvasId);
    if (!lastT) lastT = performance.now();
  }

  function update(dtms){
    if (!ctx) getCanvas();
    const dt = (typeof dtms === "number") ? dtms : fixedDt;
    for (let i = effects.length - 1; i >= 0; i--) {
      const e = effects[i];
      e.t += dt;
      const t = 1 - (e.t / e.life);
      if (e.step) e.step(e, dt, t);
      if (e.t >= e.life) effects.splice(i, 1);
    }
  }

  function draw(){
    if (!ctx) return;
    // Draw on top of game. We assume the game already cleared the canvas.
    ctx.save();
    for (const e of effects) {
      const t = clamp01(1 - e.t / e.life);
      ctx.globalAlpha = (e.alpha0 || 1) * (0.2 + 0.8 * t);
      switch (e.kind) {
        case "beam":
          ctx.strokeStyle = e.color || "#9fd7ff";
          ctx.lineWidth = (e.thick || 4) * (0.6 + 0.4 * t);
          ctx.beginPath();
          ctx.moveTo(e.x1, e.y1);
          ctx.lineTo(e.x2, e.y2);
          ctx.stroke();
          break;
        case "burst":
          ctx.fillStyle = e.color || "#ff6adf";
          ctx.beginPath();
          ctx.arc(e.x, e.y, e.r0 + (1 - t) * (e.r1 - e.r0), 0, TAU);
          ctx.fill();
          break;
        case "slash":
          ctx.strokeStyle = e.color || "#51d7ff";
          ctx.fillStyle   = e.fill   || "rgba(81,215,255,0.30)";
          ctx.lineWidth = e.line || 4;
          ctx.shadowBlur = e.shadow || 16;
          ctx.shadowColor = ctx.strokeStyle;
          const w = e.w0 + (1 - t) * (e.w1 - e.w0);
          const h = e.h || 20;
          const off = (1 - t) * e.off;
          ctx.beginPath();
          ctx.moveTo(e.x + off - w/2, e.y - h/2);
          ctx.quadraticCurveTo(e.x + off, e.y, e.x + off + w/2, e.y + h/2);
          ctx.lineTo(e.x + off + w/2 - 10, e.y + h/2 - 5);
          ctx.quadraticCurveTo(e.x + off, e.y, e.x + off - w/2 + 10, e.y - h/2 + 5);
          ctx.closePath();
          ctx.fill();
          ctx.stroke();
          ctx.shadowBlur = 0;
          break;
        case "xslash":
          ctx.strokeStyle = e.color || "#a78bfa";
          ctx.lineWidth = e.line || 5;
          ctx.lineCap = "round";
          ctx.shadowBlur = e.shadow || 18;
          ctx.shadowColor = ctx.strokeStyle;
          const s = e.size0 + (1 - t) * (e.size1 - e.size0);
          ctx.beginPath();
          ctx.moveTo(e.x - s/2, e.y - s/2);
          ctx.lineTo(e.x + s/2, e.y + s/2);
          ctx.moveTo(e.x + s/2, e.y - s/2);
          ctx.lineTo(e.x - s/2, e.y + s/2);
          ctx.stroke();
          ctx.shadowBlur = 0;
          break;
        case "summon":
          ctx.strokeStyle = e.color || "#ffd56a";
          ctx.lineWidth = e.line || 3;
          ctx.shadowBlur = e.shadow || 25;
          ctx.shadowColor = ctx.strokeStyle;
          const radius = e.r0 + (1 - t) * (e.r1 - e.r0);
          const rot = (e.rot0 || 0) + (1 - t) * (e.rot1 - (e.rot0 || 0));
          ctx.beginPath();
          ctx.arc(e.x, e.y, radius, 0, TAU);
          ctx.stroke();
          for (let i=0;i<6;i++){
            const a = (i/6)*TAU + rot;
            const sx = e.x + Math.cos(a) * radius * 0.7;
            const sy = e.y + Math.sin(a) * radius * 0.7;
            ctx.beginPath();
            ctx.arc(sx, sy, 4, 0, TAU);
            ctx.fillStyle = ctx.strokeStyle;
            ctx.fill();
          }
          // center glow
          const grd = ctx.createRadialGradient(e.x, e.y, 0, e.x, e.y, 25);
          grd.addColorStop(0, "rgba(255,213,106,0.6)");
          grd.addColorStop(1, "rgba(255,213,106,0)");
          ctx.fillStyle = grd;
          ctx.fillRect(e.x-25, e.y-25, 50, 50);
          ctx.shadowBlur = 0;
          break;
        case "impact":
          ctx.fillStyle = e.color || "#ffd56a";
          const rr = e.r0 + (1 - t) * (e.r1 - e.r0);
          ctx.beginPath();
          ctx.arc(e.x, e.y, rr, 0, TAU);
          ctx.fill();
          break;
        case "floater":
          ctx.fillStyle = e.color || "#ffffff";
          ctx.font = (e.size || 16) + "px monospace";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          const yy = e.y - (1 - t) * e.dy;
          ctx.fillText(e.text || "", e.x, yy);
          break;
      }
    }
    ctx.restore();
  }

  // spawners
  function spawn(kind, opts){
    opts = opts || {};
    const e = Object.assign({kind, t:0, life: opts.life || 300}, opts);
    effects.push(e);
    return e;
  }

  function beam(x1,y1,x2,y2, color, life, thick){
    return spawn("beam", {x1,y1,x2,y2,color,life: life||320, thick: thick||5});
  }
  function burst(x,y,color, life, r0, r1){
    return spawn("burst",{x,y,color,life: life||240, r0: r0||6, r1: r1||24});
  }
  function slash(x,y){
    return spawn("slash",{x,y, w0:80, w1:120, h:20, off:100, life:600});
  }
  function xSlash(x,y){
    return spawn("xslash",{x,y, size0:60, size1:84, life:500});
  }
  function summon(x,y){
    return spawn("summon",{x,y, r0:40, r1:70, rot0:0, rot1:Math.PI*2, life:800});
  }
  function impact(x,y,color){
    return spawn("impact",{x,y,color, r0:4, r1:18, life:180});
  }
  function floater(x,y,text,color,size){
    return spawn("floater",{x,y,text,color,size: size||16, dy: 36, life: 650});
  }

  // Attach and hook into game loop if available
  function hookGameLoop(){
    if (hookGameLoop._done) return;
    const originalUpdate = window.update;
    if (typeof originalUpdate === "function"){
      const wrapped = function(){
        const result = originalUpdate.apply(this, arguments);
        // We don't know the game clear/draw order; so just draw after update using same canvas.
        VFX.update(fixedDt);
        VFX.draw();
        return result;
      };
      wrapped.__vfxWrapped = true;
      window.update = wrapped;
      hookGameLoop._done = true;
      console.log("[VFX] Hooked into window.update");
    } else {
      // Fallback RAF
      let last = performance.now();
      function tick(now){
        const dt = now - last; last = now;
        VFX.update(dt);
        VFX.draw();
        requestAnimationFrame(tick);
      }
      requestAnimationFrame(tick);
      console.log("[VFX] Using self-RAF");
    }
  }

  VFX.init = init;
  VFX.useCanvas = useCanvas;
  VFX.update = update;
  VFX.draw = draw;
  VFX.spawn = spawn;
  VFX.beam = beam;
  VFX.burst = burst;
  VFX.slash = slash;
  VFX.xSlash = xSlash;
  VFX.summon = summon;
  VFX.impact = impact;
  VFX.floater = floater;
  VFX.hookGameLoop = hookGameLoop;

  const target = window.VFX || (window.VFX = {});
  const attach = (name, fn) => {
    if (typeof target[name] !== "function") target[name] = fn;
  };

  attach("beam", beam);
  attach("burst", burst);
  attach("slash", slash);
  attach("xSlash", xSlash);
  attach("summon", summon);
  attach("impact", impact);
  attach("floater", floater);
  if (typeof target.spawn !== "function") target.spawn = spawn;
  if (!target.__simpleVFX) target.__simpleVFX = VFX;

  // Auto-boot
  setTimeout(function(){ VFX.init({canvasId:"cv"}); VFX.hookGameLoop(); }, 0);
})();

</script>
  <!-- Inlined: src/skills/skills.js -->
<script>

/*==========================================================
  A1K — TWO-SOURCE SKILL WRAPPER (skills.js)
  Exposes window.SKILLS with:
    cast(hero, key), bindKeys(), wireHUD(), setCooldown(slot,ms), getLoadout(hero),
    register(name, fn), testDemo().
  Depends only on window.VFX (effects) and existing globals (st.players, addFloater).
  CSP-safe, no fetch(), no eval(). Works over file://.
==========================================================*/
(function(){
  if (window.SKILLS) return;
  const EV = {};
  const listeners = {};
  EV.on = (type, fn)=>{ (listeners[type] = listeners[type]||[]).push(fn); };
  EV.emit = (type, payload)=>{ (listeners[type]||[]).forEach((fn)=>{try{fn(payload);}catch(e){}}); };

  // Utils
  function leader(){
    try{
      const st = window.st; if (!st) return null;
      const idx = st.leader || 0;
      return (st.players || [])[idx] || null;
    }catch(_){ return null; }
  }
  function nearestEnemy(x,y, maxDist){
    maxDist = maxDist || 360;
    // Try indoor combat targets first
    const ic = window.HouseInterior && window.HouseInterior.indoorCombat;
    let best=null, bestD = Infinity;
    if (ic && ic.enemies){
      for (const e of ic.enemies){
        const d = Math.hypot((e.x-x),(e.y-y));
        if (d < bestD && d <= maxDist){ best = {x:e.x,y:e.y, obj:e}; bestD = d; }
      }
    }
    // TODO world enemies here if needed
    return best;
  }
  function damageAt(x,y, amount, color){
    if (window.addDamageNumber) window.addDamageNumber(x,y, -amount, color||"#ff6aa8");
    if (window.VFX) window.VFX.impact(x,y,color||"#ff6aa8");
    // Affect indoor enemy if overlapping
    const ic = window.HouseInterior && window.HouseInterior.indoorCombat;
    if (ic && ic.enemies){
      for (const e of ic.enemies){
        const d = Math.hypot(e.x-x, e.y-y);
        if (d < 40){
          e.hp = Math.max(0, (e.hp||0) - amount);
        }
      }
    }
  }
  function pushFloater(x,y, text, color){ try{ window.VFX && window.VFX.floater(x,y,text,color); }catch(_){ } }

  // Cooldown system (simple, per hero+slot string)
  const cooldowns = Object.create(null);
  function cdKey(hero, slot){ return hero+"::"+slot; }
  function isReady(hero, slot){
    const k = cdKey(hero,slot);
    const t = cooldowns[k] || 0;
    return (performance.now() >= t);
  }
  function normalizeCooldownHero(id){
    if (!id) return "";
    const raw = String(id).trim();
    const upper = raw.toUpperCase();
    if (upper === "UNIQUE") return "Unique";
    if (upper === "MISSY") return "Missy";
    if (upper === "CLONE") return "clone";
    if (upper.startsWith("A1")) return "A1";
    return raw;
  }

  function syncGlobalCooldown(hero, slot, ms){
    const st = window.st;
    if (!st) return;
    const normalize = typeof window.normalizeHeroIdForCd === "function" ? window.normalizeHeroIdForCd : normalizeCooldownHero;
    const heroKey = normalize(hero) || hero;
    if (!heroKey) return;
    if (typeof window.ensureCooldownRow === "function") window.ensureCooldownRow(heroKey);
    const cds = st.cds && st.cds[heroKey];
    if (!cds) return;
    const current = cds[slot] || 0;
    cds[slot] = Math.max(current, ms);
  }

  function setCooldown(hero, slot, ms){
    cooldowns[cdKey(hero,slot)] = performance.now() + ms;
    EV.emit("cooldown", {hero, slot, endAt: cooldowns[cdKey(hero,slot)]});
    syncGlobalCooldown(hero, slot, ms);
  }

  const SIMPLE_COOLDOWNS = Object.freeze({
    A1: { S1: 2500, S2: 6000, S3: 12000, S4: 20000 },
    Unique: { S1: 2500, S2: 6000, S3: 12000, S4: 20000 },
    Missy: { S1: 2500, S2: 6000, S3: 10000, S4: 20000 }
  });

  function ensureSimplePlayer(heroName){
    const player = leader();
    if (!player) return null;
    if (!player.id) player.id = heroName;
    return player;
  }

  function trySimpleCast(heroName, slot){
    if (typeof window.useSimpleSkill !== "function") return false;
    const player = ensureSimplePlayer(heroName);
    if (!player) return false;
    try {
      const ok = window.useSimpleSkill(player, slot, { __skipBridge: true });
      if (ok) {
        const cd = SIMPLE_COOLDOWNS[heroName]?.[slot];
        if (cd) setCooldown(heroName, slot, cd);
      }
      return !!ok;
    } catch (err) {
      console.warn("[SKILLS] simple skill error", err);
      return false;
    }
  }

  // Minimal loadouts
  const LOADOUT = {
    A1:   { S1:"A1_S1", S2:"A1_S2", S3:"A1_S3", S4:"A1_S4", ATTACK:"A1_ATK" },
    Unique:{ S1:"UQ_S1", S2:"UQ_S2", S3:"UQ_S3", S4:"UQ_S4", ATTACK:"UQ_ATK" },
    Missy:{ S1:"MS_S1", S2:"MS_S2", S3:"MS_S3", S4:"MS_S4", ATTACK:"MS_ATK" }
  };
  function getActiveHeroName(){
    const st = window.st || {}; const idx = st.leader || 0;
    return ["A1","Unique","Missy"][idx] || "A1";
  }

  // Skill registry
  const REG = Object.create(null);
  function register(name, fn){ REG[name] = fn; }

  // Skill implementations — purely VFX + simple damage. Connect world hits if needed.
  function HPos(){ const L = leader(); if (L) return {x:L.x||0, y:(L.y||0)-14}; const W=900,H=540; return {x:W*0.5,y:H*0.65}; }

  // A1
  register("A1_ATK", ()=>{
    const {x,y} = HPos();
    window.VFX && window.VFX.slash(x,y);
    damageAt(x+40,y, 120+Math.round(Math.random()*40));
    pushFloater(x+40, y-40, "-ATK-", "#ff6b35");
    setCooldown("A1","ATTACK", 120);
  });
  register("A1_S1", ()=>{
    if (trySimpleCast("A1", "S1")) return;
    const {x,y} = HPos();
    window.VFX && window.VFX.slash(x,y);
    // wave forward
    for (let i=0;i<3;i++){
      setTimeout(()=>{ damageAt(x+80+ i*40, y, 140 + (i*30)); }, i*80);
    }
    setCooldown("A1","S1", SIMPLE_COOLDOWNS.A1.S1);
  });
  register("A1_S2", ()=>{
    if (trySimpleCast("A1", "S2")) return;
    const {x,y} = HPos();
    window.VFX && window.VFX.xSlash(x,y);
    // shadow clones pseudo-hits
    for (let i=0;i<4;i++){
      setTimeout(()=>{
        window.VFX && window.VFX.xSlash(x + (i%2? -40:40), y-10);
        damageAt(x + (i%2? -60:60), y, 90 + i*20);
      }, 120*i);
    }
    setCooldown("A1","S2", SIMPLE_COOLDOWNS.A1.S2);
  });
  register("A1_S3", ()=>{
    if (trySimpleCast("A1", "S3")) return;
    const {x,y} = HPos();
    window.VFX && window.VFX.summon(x,y);
    // summon shock
    setTimeout(()=>{
      damageAt(x+30,y, 240);
      for (let k=0;k<3;k++) window.VFX && window.VFX.burst(x+ (k-1)*24, y-10, "#ffd56a", 280);
    }, 260);
    setCooldown("A1","S3", SIMPLE_COOLDOWNS.A1.S3);
  });
  register("A1_S4", ()=>{
    if (trySimpleCast("A1", "S4")) return;
    const {x,y} = HPos();
    window.VFX && window.VFX.burst(x, y, "#ff4d4f", 640, 18, 90);
    for (let i=0;i<6;i++){
      setTimeout(()=>{
        damageAt(x + (i-2.5)*52, y, 260 - i*18);
        window.VFX && window.VFX.xSlash(x + (i-2.5)*48, y-12);
      }, i*90);
    }
    setCooldown("A1","S4", SIMPLE_COOLDOWNS.A1.S4);
  });

  // Unique
  register("UQ_ATK", ()=>{
    const {x,y} = HPos();
    const tgt = nearestEnemy(x,y) || {x:x+120,y:y};
    window.VFX && window.VFX.beam(x,y, tgt.x, tgt.y, "#9fd7ff", 240, 4);
    damageAt(tgt.x, tgt.y, 110);
    pushFloater(tgt.x, tgt.y-30, "•", "#9fd7ff");
    setCooldown("Unique","ATTACK", 110);
  });
  register("UQ_S1", ()=>{
    if (trySimpleCast("Unique", "S1")) return;
    const {x,y} = HPos();
    const tgt = nearestEnemy(x,y) || {x:x+160,y:y};
    window.VFX && window.VFX.beam(x,y, tgt.x, tgt.y, "#71c7ff", 300, 6);
    damageAt(tgt.x, tgt.y, 200);
    setCooldown("Unique","S1", SIMPLE_COOLDOWNS.Unique.S1);
  });
  register("UQ_S2", ()=>{
    if (trySimpleCast("Unique", "S2")) return;
    const {x,y} = HPos();
    for (let i=0;i<3;i++){
      setTimeout(()=>{
        const tgt = nearestEnemy(x,y) || {x:x+180+i*10,y:y-10+i*6};
        window.VFX && window.VFX.beam(x,y, tgt.x, tgt.y, "#51d7ff", 260, 5);
        damageAt(tgt.x, tgt.y, 120 + i*40);
      }, i*120);
    }
    setCooldown("Unique","S2", SIMPLE_COOLDOWNS.Unique.S2);
  });
  register("UQ_S3", ()=>{
    if (trySimpleCast("Unique", "S3")) return;
    const {x,y} = HPos();
    window.VFX && window.VFX.burst(x,y, "#a1f0ff", 420, 8, 48);
    setTimeout(()=>{
      for (let i=0;i<5;i++){
        const ang = (i/5)*Math.PI*2;
        const tx = x + Math.cos(ang)*140;
        const ty = y + Math.sin(ang)*80;
        window.VFX && window.VFX.beam(x,y,tx,ty, "#b5ffff", 320, 3);
        damageAt(tx,ty, 90);
      }
    }, 160);
    setCooldown("Unique","S3", SIMPLE_COOLDOWNS.Unique.S3);
  });
  register("UQ_S4", ()=>{
    if (trySimpleCast("Unique", "S4")) return;
    const {x,y} = HPos();
    for (let i=0;i<6;i++){
      setTimeout(()=>{
        const ang = (i/6) * Math.PI * 2;
        const tx = x + Math.cos(ang) * 220;
        const ty = y + Math.sin(ang) * 120;
        window.VFX && window.VFX.beam(x, y, tx, ty, "#74b9ff", 420, 7);
        damageAt(tx, ty, 180);
      }, i * 110);
    }
    setCooldown("Unique","S4", SIMPLE_COOLDOWNS.Unique.S4);
  });

  // Missy
  register("MS_ATK", ()=>{
    const {x,y} = HPos();
    window.VFX && window.VFX.burst(x+24,y-8, "#ff8cc6", 220, 4, 16);
    damageAt(x+60,y-8, 95);
    setCooldown("Missy","ATTACK", 140);
  });
  register("MS_S1", ()=>{
    if (trySimpleCast("Missy", "S1")) return;
    const {x,y} = HPos();
    window.VFX && window.VFX.slash(x,y);
    damageAt(x+90,y, 160);
    setCooldown("Missy","S1", SIMPLE_COOLDOWNS.Missy.S1);
  });
  register("MS_S2", ()=>{
    if (trySimpleCast("Missy", "S2")) return;
    const {x,y} = HPos();
    window.VFX && window.VFX.summon(x,y);
    setTimeout(()=>damageAt(x+30,y, 200), 240);
    setCooldown("Missy","S2", SIMPLE_COOLDOWNS.Missy.S2);
  });
  register("MS_S3", ()=>{
    if (trySimpleCast("Missy", "S3")) return;
    const {x,y} = HPos();
    for (let i=0;i<6;i++){
      setTimeout(()=>{
        window.VFX && window.VFX.burst(x + i*18, y-10, "#ff6adf", 200, 6, 18);
        damageAt(x+ (40+i*12), y-10, 70);
      }, i*70);
    }
    setCooldown("Missy","S3", SIMPLE_COOLDOWNS.Missy.S3);
  });
  register("MS_S4", ()=>{
    if (trySimpleCast("Missy", "S4")) return;
    const {x,y} = HPos();
    for (let i=0;i<8;i++){
      setTimeout(()=>{
        window.VFX && window.VFX.burst(x + (Math.random() - 0.5) * 160, y - 20, "#ffd56a", 280, 12, 40);
        damageAt(x + (Math.random() - 0.5) * 180, y - 10, 110);
      }, i * 80);
    }
    setCooldown("Missy","S4", SIMPLE_COOLDOWNS.Missy.S4);
  });

  function cast(heroName, slot){
    heroName = heroName || getActiveHeroName();
    const load = LOADOUT[heroName] || LOADOUT.A1;
    const key = load[slot];
    if (!key){ console.warn("[SKILLS] Unknown slot:", heroName, slot); return false; }
    if (!isReady(heroName, slot)){ pushFloater((leader()?.x||450), (leader()?.y||300)-80, "CD", "#ffd56a"); return false; }
    const fn = REG[key];
    if (typeof fn !== "function"){ console.warn("[SKILLS] Missing impl for", key); return false; }
    fn();
    EV.emit("cast", {hero: heroName, slot, when: performance.now()});
    return true;
  }

  // Key + HUD binding (CSP-safe: no inline attributes)
  function bindKeys(){
    const hold = { S1:false, S2:false, S3:false };
    addEventListener("keydown", (ev)=>{
      const k = ev.code;
      if (k === "Digit1") { ev.preventDefault(); if (!hold.S1 && window.beginHold) { window.beginHold("S1"); hold.S1 = true; } }
      else if (k === "Digit2"){ ev.preventDefault(); if (!hold.S2 && window.beginHold) { window.beginHold("S2"); hold.S2 = true; } }
      else if (k === "Digit3"){ ev.preventDefault(); if (!hold.S3 && window.beginHold) { window.beginHold("S3"); hold.S3 = true; } }
      else if (k === "Digit4"){ ev.preventDefault(); cast(getActiveHeroName(),"S4"); }
      else if (k === "KeyR") { ev.preventDefault(); cast(getActiveHeroName(),"ATTACK"); }
    }, true);
    addEventListener("keyup", (ev)=>{
      const k = ev.code;
      if (k === "Digit1") { ev.preventDefault(); if (hold.S1 && window.endHold) { window.endHold("S1"); } hold.S1 = false; cast(getActiveHeroName(),"S1"); }
      else if (k === "Digit2"){ ev.preventDefault(); if (hold.S2 && window.endHold) { window.endHold("S2"); } hold.S2 = false; cast(getActiveHeroName(),"S2"); }
      else if (k === "Digit3"){ ev.preventDefault(); if (hold.S3 && window.endHold) { window.endHold("S3"); } hold.S3 = false; cast(getActiveHeroName(),"S3"); }
    }, true);
  }

  // Tries to wire buttons if they exist: #btnS1/#btnS2/#btnS3/#btnS4/#btnAtk
  function wireHUD(ids){
    ids = ids || { S1:"#hudBtnS1,#btnS1", S2:"#hudBtnS2,#btnS2", S3:"#hudBtnS3,#btnS3", S4:"#hudBtnS4,#btnS4", ATTACK:"#hudBtnAttack,#btnAtk" };
    for (const [slot, sel] of Object.entries(ids)){
      const el = document.querySelector(sel);
      if (!el) continue;
      el.addEventListener("click", function(ev){
        ev.preventDefault();
        cast(getActiveHeroName(), slot);
      });
    }
  }

  // Demo mode for proof — indoor combat aware
  function testDemo(){
    console.log("[SKILLS] Running demo burst...");
    const name = getActiveHeroName();
    cast(name, "ATTACK");
    setTimeout(()=>cast(name,"S1"), 200);
    setTimeout(()=>cast(name,"S2"), 600);
    setTimeout(()=>cast(name,"S3"), 1200);
    setTimeout(()=>cast(name,"S4"), 2200);
  }

  // Public API
  window.SKILLS = {
    cast, bindKeys, wireHUD, register, setCooldown, getLoadout:(h)=>LOADOUT[h||getActiveHeroName()], on:EV.on, testDemo
  };

  // Auto-bind
  function autoInit(){
    bindKeys();
    if (document.readyState === "loading") {
      document.addEventListener("DOMContentLoaded", ()=>wireHUD(), { once: true });
    } else {
      wireHUD();
    }
  }
  setTimeout(autoInit, 0);
})();

</script>

  <!-- ⚡ MODULAR ANIME VFX + SKILL SYSTEM ⚡ -->
  <!-- These files have been consolidated into unified systems -->

  <!-- Enemy Overhaul and VFX System -->
  <!-- Load the enemy overhaul script early to cap HP and remove
       dangerous abilities in early waves. -->
  <!-- Inlined: src/systems/enemy-overhaul.js -->
<script>
(function () {
  if (window.__ENEMY_OVERHAUL__) return;
  window.__ENEMY_OVERHAUL__ = true;
  const g = window;

  // Boss-only overhaul: regular mobs are removed in favour of boss-pool elites.
  const ENEMIES = Object.freeze({});

  function randomInt(min, max) {
    return min + Math.floor(Math.random() * (max - min + 1));
  }

  function getBossPoolSystem() {
    return g.BossPoolSystem || window.BossPoolSystem || null;
  }

  function poolColor(pool) {
    switch (pool) {
      case "gold":
        return "#f7c84b";
      case "silver":
        return "#b1c4ff";
      case "armor":
        return "#8a99a6";
      case "behavior":
        return "#ff6b6b";
      case "pet":
        return "#8dd58a";
      case "vehicle":
        return "#ffa86b";
      case "gear":
        return "#b57fe0";
      case "gift":
        return "#ff9cf3";
      case "key":
        return "#6bc0ff";
      case "miniBoss":
        return "#f45b69";
      case "bigBoss":
        return "#d354ff";
      default:
        return "#bf5dff";
    }
  }

  function cleanupBossSummons(state, bossId) {
    if (!state || !bossId) return;

    const enemies = state.enemies;
    if (Array.isArray(enemies)) {
      for (let i = enemies.length - 1; i >= 0; i--) {
        const unit = enemies[i];
        if (!unit) continue;
        if (!unit.isBoss && unit.summonerId && unit.summonerId === bossId) {
          enemies.splice(i, 1);
        }
      }
    }

    if (Array.isArray(state.eShots)) {
      for (let i = state.eShots.length - 1; i >= 0; i--) {
        const shot = state.eShots[i];
        if (shot && shot.ownerId === bossId) {
          state.eShots.splice(i, 1);
        }
      }
    }

    if (Array.isArray(state.effects)) {
      for (let i = state.effects.length - 1; i >= 0; i--) {
        const fx = state.effects[i];
        if (fx && fx.sourceId === bossId) {
          state.effects.splice(i, 1);
        }
      }
    }
  }

  function normalizePoolName(name) {
    if (!name) return undefined;
    const raw = String(name).trim().toLowerCase();
    if (!raw) return undefined;
    const base = raw.endsWith("boss") ? raw.slice(0, -4) : raw;
    const aliases = {
      gold: "gold",
      golden: "gold",
      armor: "armor",
      tank: "armor",
      shield: "armor",
      pet: "pet",
      beast: "pet",
      animal: "pet",
      vehicle: "vehicle",
      mech: "vehicle",
      gear: "gear",
      weapon: "gear",
      gift: "gift",
      treasure: "gift",
      loot: "gift",
      key: "key",
      lock: "key",
      behavior: "behavior",
      tactic: "behavior",
      pattern: "behavior",
      silver: "silver",
      mini: "miniBoss",
      minib: "miniBoss",
      big: "bigBoss",
      mega: "bigBoss",
    };
    return aliases[raw] || aliases[base];
  }

  function makeBiasedRng(cfg, targetPool) {
    if (!cfg) return null;
    const queued = [];
    const counts = Array.isArray(cfg.count) ? cfg.count : [cfg.count ?? 1];
    const countIndex = counts.indexOf(1);
    if (countIndex >= 0) {
      queued.push((countIndex + 0.05) / counts.length);
    } else if (counts.length) {
      const nzIndex = counts.findIndex((c) => (c || 0) > 0);
      if (nzIndex >= 0) queued.push((nzIndex + 0.05) / counts.length);
    }
    if (cfg.pools && cfg.pools.length) {
      const poolIndex = cfg.pools.indexOf(targetPool);
      if (poolIndex >= 0) {
        queued.push((poolIndex + 0.05) / cfg.pools.length);
      } else {
        queued.push(Math.random());
      }
    }
    let i = 0;
    return () => (i < queued.length ? queued[i++] : Math.random());
  }

  function resolveBossData(stage = 1, preferPool) {
    const system = getBossPoolSystem();
    if (!system || !system.getWaveBosses) return null;
    const pools = system.BOSS_POOLS
      ? Object.keys(system.BOSS_POOLS)
      : Object.keys(system) || [];
    if (!pools.length) return null;
    const targetPool =
      preferPool && pools.includes(preferPool)
        ? preferPool
        : pools[Math.floor(Math.random() * pools.length)];

    const waveCandidates = Object.entries(system.WAVE_BOSS_CONFIGS || {}).filter(
      ([, cfg]) => cfg?.pools?.includes(targetPool)
    );

    const pair =
      waveCandidates.length > 0
        ? waveCandidates[Math.floor(Math.random() * waveCandidates.length)]
        : [8, system.WAVE_BOSS_CONFIGS?.[8]];

    const waveKey = Number(pair[0]) || 8;
    const cfg = pair[1];

    const rng = makeBiasedRng(cfg, targetPool);
    const bosses =
      system.getWaveBosses(waveKey, {
        stage: Math.max(1, stage),
        injectChance: 1.0,
        rng: rng || undefined,
      }) || [];

    if (bosses.length > 0) {
      return bosses[Math.floor(Math.random() * bosses.length)];
    }
    return null;
  }

  function createBossFromData(stage, wave, preferPool) {
    const bossData = resolveBossData(stage, preferPool);
    if (bossData) {
      const color = poolColor(bossData.pool);
      const enemy = {
        id: Math.random(),
        type: bossData.pool ? `boss:${bossData.pool}` : "bossPool",
        name: bossData.name,
        x: (g.DESIGN_W || 900) + 120,
        y: (g.DESIGN_H || 540) - 140,
        hp: bossData.stats?.hpMax ?? 600,
        max: bossData.stats?.hpMax ?? 600,
        dmg: bossData.stats?.atk ?? 45,
        vx: -(0.12 + Math.random() * 0.08),
        vy: 0,
        color,
        size: 58,
        fireCD: 0,
        speedMul: bossData.stats?.speedMul ?? 1,
        def: bossData.stats?.def ?? 25,
        ranged: bossData.ai?.kind === "ranged",
        flying: false,
        repelsShots: false,
        isBoss: true,
        pool: bossData.pool,
        drops: bossData.drops || [],
        affixes: bossData.affixes || [],
        critChance: bossData.stats?.critChance ?? 0.1,
        critMult: bossData.stats?.critMult ?? 1.5,
        spawnShieldT: 1500,
        canJump: false,
      };
      return enemy;
    }

    const fallback = {
      id: Math.random(),
      type: preferPool ? 'boss:' + preferPool : 'rogueBoss',
      name: 'Rogue Boss',
      x: (g.DESIGN_W || 900) + 120,
      y: (g.DESIGN_H || 540) - 140,
      hp: 800,
      max: 800,
      dmg: 50,
      vx: -(0.12 + Math.random() * 0.08),
      vy: 0,
      color: poolColor(preferPool),
      size: 58,
      fireCD: 0,
      speedMul: 1,
      def: 30,
      ranged: false,
      flying: false,
      repelsShots: false,
      isBoss: true,
      pool: preferPool,
      drops: [],
      affixes: [],
      critChance: 0.12,
      critMult: 1.6,
      spawnShieldT: 1500,
      canJump: false,
    };
    return fallback;
  }

  const BOSSES = {};

  function createEnemy(type, stage = 1) {
    const pool = normalizePoolName(type);
    const enemy = createBossFromData(stage, 1, pool);
    if (enemy && !enemy.type) {
      enemy.type = pool ? `boss:${pool}` : "bossPool";
    }
    return enemy;
  }

  function createBoss(stage) {
    const template = BOSSES[stage] || BOSSES[10];
    return {
      id: Math.random(),
      type: "boss",
      name: template.name,
      x: (g.DESIGN_W || 900) - 150,
      y: (g.DESIGN_H || 540) - 100,
      hp: template.hp,
      max: template.hp,
      dmg: template.dmg,
      vx: -template.speed,
      vy: 0,
      color: template.color,
      size: 64,
      fireCD: 0,
      isBoss: true,
      spawnShieldT: 2000, // 2 second spawn shield
      canJump: false, // Bosses don't need to jump
    };
  }

  function updateEnemies(dt) {
    const S = g.st || g.Game?.state || {};
    if (!S.enemies) return;

    for (let i = S.enemies.length - 1; i >= 0; i--) {
      const e = S.enemies[i];
      if (e.hp <= 0) {
        // Boss reward: increased gold rewards
        if (e.isBoss) {
          let baseReward = 50000;
          if (e.isBigBoss) baseReward = 150000; // Boss wave bosses
          else if (e.isMiniBoss) baseReward = 100000; // Mini boss wave bosses
          
          const reward = baseReward + Math.floor(Math.random() * baseReward);
          S.gold = (S.gold || 0) + reward;
          S.bossAlive = false;
          try {
            window.notify &&
              window.notify(`Boss defeated! +${reward} Gold`, "#ffd56a");
          } catch (_) {}
          cleanupBossSummons(S, e.id);
        }
        S.enemies.splice(i, 1);
        continue;
      }

      // Update cooldowns
      if (e.fireCD > 0) e.fireCD -= dt * 1000;

      // Movement and AI
      const leader =
        g.Game?.getLeader?.() || (S.players && S.players[S.leader || 0]);
      if (leader && !leader.isDefeated) {
        const dx = leader.x - e.x;
        const dist = Math.abs(dx);

        if (e.ranged && dist < 400) {
          // Ranged enemies keep distance and shoot
          if (dist < 200) e.vx = Math.sign(e.x - leader.x) * 0.1;
          else e.vx = 0;

          if (e.fireCD <= 0) {
            shootAtPlayer(e, leader);
            e.fireCD = 1500;
          }
        } else {
          // Melee enemies move toward player
          e.vx = Math.sign(dx) * Math.abs(e.vx || 0.2);
        }
      }

      // Apply movement
      e.x += (e.vx || 0) * dt * 60;
      e.y += (e.vy || 0) * dt * 60;

      // Wrap around screen
      if (e.x < -100) e.x = (g.DESIGN_W || 900) + 100;
    }
  }

  function shootAtPlayer(enemy, player) {
    const S = g.st || g.Game?.state || {};
    if (!S.eShots) S.eShots = [];

    const dx = player.x - enemy.x;
    const dy = player.y - enemy.y;
    const angle = Math.atan2(dy, dx);
    const speed = 200;

    S.eShots.push({
      x: enemy.x,
      y: enemy.y,
      vx: Math.cos(angle) * speed,
      vy: Math.sin(angle) * speed,
      dmg: enemy.dmg,
      life: 3000,
      color: enemy.color || "#ff4444",
    });
  }

    function spawnWave(stage, wave) {
    const S = g.st || g.Game?.state || {};
    if (!S.enemies) S.enemies = [];

    const now = (g.performance?.now?.() || Date.now()) | 0;
    if (!S._lastSpawnAt) S._lastSpawnAt = 0;
    if (now - S._lastSpawnAt < 250) return;
    S._lastSpawnAt = now;

    const P = g.__PROG95 || window.__PROG95;
    const halfStep = !!(P && typeof P.isHalfStep === "function" && P.isHalfStep());
    const base = P && typeof P.baseWave === "function" ? P.baseWave() : wave;
    const isBossWave = wave === 9.5 || wave === 10 || (base === 9 && halfStep);
    const isMiniBossWave = base === 9 && !halfStep;

    if (isBossWave) {
      const spawned = [];
      const big = createBossFromData(stage, wave, "bigBoss");
      big.x += Math.random() * 160;
      big.y = (g.DESIGN_H || 540) - 160 + (Math.random() - 0.5) * 120;
      big.vx = -(0.1 + Math.random() * 0.12) * (big?.speedMul || big?.stats?.speedMul || 1);
      big.isBoss = true;
      big.isBigBoss = true;
      big.spawnShieldT = 3000;
      big.canTeleport = true; big.canSummon = true; big.canParry = true; big.parryFlash = 0;
      big.abilities = Array.from(new Set([...(big.abilities || []), "teleport", "summon", "parry"]));
      S.enemies.push(big); spawned.push(big);

      const joiners = randomInt(3, 7);
      const system = getBossPoolSystem();
      const poolKeys = system?.BOSS_POOLS ? Object.keys(system.BOSS_POOLS).filter((k) => k !== "bigBoss" && k !== "miniBoss") : ["armor","gold","silver","behavior","pet","vehicle","gear","gift","key"];
      for (let i = 0; i < joiners; i++) {
        const pool = poolKeys[Math.floor(Math.random() * poolKeys.length)] || null;
        const j = createBossFromData(stage, wave, pool);
        if (!j) continue;
        j.x += 220 + Math.random() * 220 + i * 24;
        j.y = (g.DESIGN_H || 540) - 140 + (Math.random() - 0.5) * 180;
        j.vx = -(0.12 + Math.random() * 0.15) * (j?.speedMul || j?.stats?.speedMul || 1);
        j.waveTag = `wave:${wave || 0}`;
        j.isBoss = true; j.spawnShieldT = 3000;
        j.canTeleport = true; j.canSummon = true; j.canParry = true; j.parryFlash = 0;
        j.abilities = Array.from(new Set([...(j.abilities || []), "teleport", "summon", "parry"]));
        S.enemies.push(j); spawned.push(j);
      }
      S.bossAlive = true;
      const topHP = spawned.reduce((max, enemy) => Math.max(max, enemy.max ?? enemy.hp ?? 0), 0);
      if (topHP > 0) { S.bossHP = topHP; S.bossMax = topHP; }
      console.log(`Boss wave ${wave}: spawned 1 bigBoss + ${joiners} joiners`);
      return;
    }

    if (S.enemies.some((enemy) => enemy?.isBoss)) { console.warn("Bosses still active; delaying next spawn."); return; }

    let bossCount;
    if (isMiniBossWave) { bossCount = randomInt(2, 3); } else { bossCount = Math.max(2, randomInt(2, 5)); }

    const system = getBossPoolSystem();
    const poolKeys = system?.BOSS_POOLS ? Object.keys(system.BOSS_POOLS).filter((k) => k !== "miniBoss" && k !== "bigBoss") : ["armor","gold","silver","behavior","pet","vehicle","gear","gift","key"];
    const availablePools = poolKeys.slice();
    const spawned = [];

    for (let i = 0; i < bossCount; i++) {
      let preferPool = null;
      if (isMiniBossWave) { preferPool = "miniBoss"; } else {
        if (availablePools.length) { const pick = Math.floor(Math.random() * availablePools.length); preferPool = availablePools.splice(pick, 1)[0]; }
        else if (poolKeys.length) { preferPool = poolKeys[Math.floor(Math.random() * poolKeys.length)]; }
      }
      const bossEnemy = createBossFromData(stage, wave, preferPool);
      if (!bossEnemy) continue;
      bossEnemy.x += Math.random() * 220;
      bossEnemy.y = (g.DESIGN_H || 540) - 140 + (Math.random() - 0.5) * 180;
      bossEnemy.vx = -(0.1 + Math.random() * 0.12) * (bossEnemy?.speedMul || bossEnemy?.stats?.speedMul || 1);
      bossEnemy.waveTag = `wave:${wave || 0}`;
      bossEnemy.isBoss = true; bossEnemy.isMiniBoss = isMiniBossWave; bossEnemy.spawnShieldT = 3000;
      bossEnemy.canTeleport = true; bossEnemy.canSummon = true; bossEnemy.canParry = true; bossEnemy.parryFlash = 0;
      bossEnemy.abilities = Array.from(new Set([...(bossEnemy.abilities || []), "teleport", "summon", "parry"]));
      spawned.push(bossEnemy); S.enemies.push(bossEnemy);
    }

    if (!spawned.length) {
      const fallback = createBossFromData(stage, wave, null);
      fallback.x += Math.random() * 160;
      fallback.vx = -(0.1 + Math.random() * 0.12) * (fallback?.speedMul || fallback?.stats?.speedMul || 1);
      fallback.waveTag = `wave:${wave || 0}`;
      fallback.isBoss = true; fallback.speedMul = fallback.speedMul || 1; fallback.spawnShieldT = 3000; fallback.canTeleport = true; fallback.canSummon = true; fallback.canParry = true; fallback.parryFlash = 0;
      S.enemies.push(fallback); spawned.push(fallback);
    }

    if (spawned.length) {
      S.bossAlive = true;
      const topHP = spawned.reduce((max, enemy) => Math.max(max, enemy.max ?? enemy.hp ?? 0), 0);
      if (topHP > 0) { S.bossHP = topHP; S.bossMax = topHP; }
    }

    console.log(`Wave ${wave}: spawned ${spawned.length} random bosses`);
}// Hook into game systems
  if (g.Game) {
    const originalUpdate = g.Game.updateEnemies;
    g.Game.updateEnemies = function (dt) {
      updateEnemies(dt);
      if (originalUpdate) originalUpdate.call(this, dt);
    };

    const originalSpawn = g.Game.spawnWave;
    g.Game.spawnWave = function () {
      const S = g.Game.state;
      spawnWave(S.stage, S.wave);
      // DO NOT call originalSpawn - this was causing double spawning
    };
  }

  // Legacy support
  g.createEnemy = createEnemy;
  g.createBoss = createBoss;
  g.spawnWave = spawnWave;
  g.updateEnemies = updateEnemies;
  g.cleanupBossSummons = cleanupBossSummons;

  console.log("⚔️ Enemy Overhaul System Loaded");
})();















</script>

  <!-- Dynamic sky and background system -->
  <!-- Inlined: src/rendering/dynamic-sky.js -->
<script>
// Dynamic Sky System - Procedural backgrounds that evolve by stage
// Includes gradients, clouds, parallax, and flora generation

(function () {
  "use strict";

  const GA = window.GenerativeArt;

  // ============= SKY GRADIENTS BY STAGE =============
  const SKY_THEMES = {
    1: { top: "#87CEEB", bottom: "#E0F6FF", name: "Dawn" },
    2: { top: "#4A90E2", bottom: "#87CEEB", name: "Morning" },
    3: { top: "#5A7FBF", bottom: "#4A90E2", name: "Day" },
    4: { top: "#FF7F50", bottom: "#FFB347", name: "Sunset" },
    5: { top: "#FF6B6B", bottom: "#FF8787", name: "Dusk" },
    6: { top: "#2C3E50", bottom: "#34495E", name: "Twilight" },
    7: { top: "#1a1a2e", bottom: "#16213e", name: "Night" },
    8: { top: "#0f0f23", bottom: "#1a1a2e", name: "Deep Night" },
    9: { top: "#4B0082", bottom: "#8B00FF", name: "Void" },
    10: { top: "#000000", bottom: "#1a0033", name: "Abyss" },
  };

  // ============= CLOUD GENERATION =============
  class Cloud {
    constructor(x, y, stage = 1) {
      this.x = x;
      this.y = y;
      this.speed = 0.1 + Math.random() * 0.2;
      this.size = 60 + Math.random() * 100;
      this.opacity = 0.3 + Math.random() * 0.4;
      this.noise = new GA.SimplexNoise(Math.random());
      this.offset = Math.random() * 1000;
      this.stage = stage;
    }

    update(dt, width) {
      this.x += this.speed * dt * 60;
      if (this.x > width + this.size) {
        this.x = -this.size;
      }
    }

    render(ctx) {
      ctx.save();
      ctx.globalAlpha = this.opacity;

      // Use noise to create organic cloud shape
      const time = Date.now() * 0.0001 + this.offset;
      const segments = 20;
      ctx.fillStyle = this.stage >= 7 ? "#2C3E50" : "#FFFFFF";
      ctx.shadowBlur = 20;
      ctx.shadowColor = ctx.fillStyle;

      ctx.beginPath();
      for (let i = 0; i <= segments; i++) {
        const angle = (i / segments) * Math.PI * 2;
        const noiseVal = this.noise.noise2D(
          Math.cos(angle) * 0.5 + time,
          Math.sin(angle) * 0.5 + time
        );
        const radius = this.size * (0.7 + noiseVal * 0.3);
        const x = this.x + Math.cos(angle) * radius;
        const y = this.y + Math.sin(angle) * radius * 0.6; // Flatten vertically

        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }
  }

  // ============= PARALLAX LAYER =============
  class ParallaxLayer {
    constructor(depth, stage = 1) {
      this.depth = depth; // 0-1, where 0 is farthest
      this.offset = 0;
      this.elements = [];
      this.stage = stage;
      this.generateElements();
    }

    generateElements() {
      // Generate distant mountains or hills based on depth
      const count = Math.floor(10 / (this.depth + 0.1));
      for (let i = 0; i < count; i++) {
        this.elements.push({
          x: i * 200 - 100,
          height: 100 + Math.random() * 150,
          width: 150 + Math.random() * 100,
          color: this.getLayerColor(),
        });
      }
    }

    getLayerColor() {
      // Darker colors for distant layers
      const opacity = 0.2 + this.depth * 0.3;
      if (this.stage <= 3) {
        return GA.ColorUtils.addAlpha("#4A90E2", opacity);
      } else if (this.stage <= 6) {
        return GA.ColorUtils.addAlpha("#FF8C69", opacity);
      } else {
        return GA.ColorUtils.addAlpha("#2C3E50", opacity);
      }
    }

    update(cameraX) {
      this.offset = -cameraX * this.depth * 0.5;
    }

    render(ctx, canvasHeight) {
      ctx.save();
      ctx.fillStyle = this.getLayerColor();

      for (const el of this.elements) {
        const x = el.x + this.offset;
        const y = canvasHeight - el.height;

        // Draw rounded hill shape
        ctx.beginPath();
        ctx.moveTo(x, canvasHeight);
        ctx.lineTo(x, y + el.height * 0.3);
        ctx.quadraticCurveTo(
          x + el.width / 2,
          y,
          x + el.width,
          y + el.height * 0.3
        );
        ctx.lineTo(x + el.width, canvasHeight);
        ctx.closePath();
        ctx.fill();
      }

      ctx.restore();
    }
  }

  // ============= L-SYSTEM FLORA GENERATOR =============
  class FloraGenerator {
    constructor() {
      this.rules = {
        tree: {
          axiom: "F",
          rules: { F: "FF+[+F-F-F]-[-F+F+F]" },
          angle: 22.5,
          iterations: 3,
        },
        bush: {
          axiom: "F",
          rules: { F: "F[+F]F[-F]F" },
          angle: 25,
          iterations: 3,
        },
        grass: {
          axiom: "F",
          rules: { F: "F[+F][-F]" },
          angle: 30,
          iterations: 2,
        },
      };
    }

    generate(type, iterations) {
      const system = this.rules[type];
      if (!system) return system.axiom;

      let result = system.axiom;
      for (let i = 0; i < (iterations || system.iterations); i++) {
        let next = "";
        for (const char of result) {
          next += system.rules[char] || char;
        }
        result = next;
      }
      return result;
    }

    renderPlant(ctx, x, y, pattern, angleStep, length, color) {
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(Math.PI); // Start pointing up
      ctx.strokeStyle = color;
      ctx.lineWidth = 2;
      ctx.lineCap = "round";

      const stack = [];
      let currentAngle = 0;

      for (const char of pattern) {
        switch (char) {
          case "F":
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.lineTo(0, length);
            ctx.stroke();
            ctx.translate(0, length);
            break;
          case "+":
            currentAngle += angleStep;
            ctx.rotate((angleStep * Math.PI) / 180);
            break;
          case "-":
            currentAngle -= angleStep;
            ctx.rotate((-angleStep * Math.PI) / 180);
            break;
          case "[":
            stack.push({ angle: currentAngle, transform: ctx.getTransform() });
            break;
          case "]":
            if (stack.length > 0) {
              const state = stack.pop();
              ctx.setTransform(state.transform);
              currentAngle = state.angle;
            }
            break;
        }
      }

      ctx.restore();
    }
  }

  // ============= MAIN DYNAMIC SKY SYSTEM =============
  class DynamicSky {
    constructor(width, height, stage = 1) {
      this.width = width;
      this.height = height;
      this.stage = stage;
      this.theme = SKY_THEMES[stage] || SKY_THEMES[1];
      this.clouds = [];
      this.parallaxLayers = [];
      this.flora = new FloraGenerator();
      this.cameraX = 0;

      this.initialize();
      // Listen for theme changes (e.g., Candy Mode)
      try {
        window.addEventListener('theme:changed', (ev) => {
          const name = ev?.detail?.theme;
          if (name === 'candy') {
            // Pastel candy sky gradient (cotton-pink -> taffy-blue)
            this.theme = { top: '#FFB5E8', bottom: '#B5F5FF', name: 'Candy Sky' };
            // optionally tint clouds slightly
            for (const c of this.clouds) c.colorTint = '#FFFFFF';
          } else {
            this.theme = SKY_THEMES[this.stage] || SKY_THEMES[1];
          }
        });
      } catch (_) {}
    }

    initialize() {
      // Create clouds
      for (let i = 0; i < 8; i++) {
        this.clouds.push(
          new Cloud(
            Math.random() * this.width,
            50 + Math.random() * 150,
            this.stage
          )
        );
      }

      // Create parallax layers
      for (let i = 0; i < 3; i++) {
        this.parallaxLayers.push(new ParallaxLayer(i * 0.3, this.stage));
      }
    }

    setStage(stage) {
      if (stage !== this.stage) {
        this.stage = stage;
        this.theme = SKY_THEMES[stage] || SKY_THEMES[1];

        // Update clouds and parallax
        this.clouds.forEach((cloud) => (cloud.stage = stage));
        this.parallaxLayers.forEach((layer) => {
          layer.stage = stage;
          layer.generateElements();
        });
      }
    }

    update(dt, cameraX = 0) {
      this.cameraX = cameraX;

      // Update clouds
      for (const cloud of this.clouds) {
        cloud.update(dt, this.width);
      }

      // Update parallax
      for (const layer of this.parallaxLayers) {
        layer.update(cameraX);
      }
    }

    render(ctx) {
      // Sky gradient
      const gradient = ctx.createLinearGradient(0, 0, 0, this.height);
      gradient.addColorStop(0, this.theme.top);
      gradient.addColorStop(1, this.theme.bottom);
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, this.width, this.height);



      // Parallax background layers
      for (const layer of this.parallaxLayers) {
        layer.render(ctx, this.height);
      }

      // Clouds
      for (const cloud of this.clouds) {
        cloud.render(ctx);
      }
    }



    renderGround(ctx, y) {
      // Simple ground layer
      ctx.save();

      const groundGradient = ctx.createLinearGradient(0, y, 0, this.height);
      if (this.stage <= 3) {
        groundGradient.addColorStop(0, "#8BC34A");
        groundGradient.addColorStop(1, "#689F38");
      } else if (this.stage <= 6) {
        groundGradient.addColorStop(0, "#795548");
        groundGradient.addColorStop(1, "#5D4037");
      } else {
        groundGradient.addColorStop(0, "#37474F");
        groundGradient.addColorStop(1, "#263238");
      }

      ctx.fillStyle = groundGradient;
      ctx.fillRect(0, y, this.width, this.height - y);

      // Add some flora if early stages
      if (this.stage <= 3) {
        this.renderGroundFlora(ctx, y);
      }

      ctx.restore();
    }

    renderGroundFlora(ctx, groundY) {
      const spacing = 80;
      const count = Math.floor(this.width / spacing);

      for (let i = 0; i < count; i++) {
        const x = i * spacing + ((this.cameraX * 0.3) % spacing);
        if (x < -50 || x > this.width + 50) continue;

        const type = i % 3 === 0 ? "tree" : "grass";
        const pattern = this.flora.generate(type);
        const color = type === "tree" ? "#558B2F" : "#7CB342";
        const length = type === "tree" ? 8 : 4;
        const angle = type === "tree" ? 25 : 30;

        this.flora.renderPlant(ctx, x, groundY, pattern, angle, length, color);
      }
    }
  }

  // ============= EXPORT =============
  window.DynamicSky = DynamicSky;
  window.FloraGenerator = FloraGenerator;

  console.log("✨ Dynamic Sky System loaded");
})();

</script>

  <!-- Procedural character renderer -->
  <!-- Inlined: src/rendering/character-renderer.js -->
<script>
// Character Renderer - Procedural player character generation
// Creates A1, Unique, and Missy with distinct visual styles

(function () {
  "use strict";

  const GA = window.GenerativeArt;

  const THEME_STATE = {
    current: (window.Theme && window.Theme.get && window.Theme.get()) || "default",
    palette: {
      primary: "#FFB6D9",
      blue: "#B4E7FF",
      lemon: "#FFD56A",
      mint: "#C8F4D9",
      grape: "#9B59B6",
      rim1: "#00E5FF",
      rim2: "#A78BFA",
      danger: "#FF3B3B",
    },
  };

  function updateThemeState(detail) {
    if (!detail) return;
    THEME_STATE.current = detail.theme || "default";
    if (detail.palette) {
      THEME_STATE.palette = {
        primary: detail.palette.primary || THEME_STATE.palette.primary,
        blue: detail.palette.blue || THEME_STATE.palette.blue,
        lemon: detail.palette.lemon || THEME_STATE.palette.lemon,
        mint: detail.palette.mint || THEME_STATE.palette.mint,
        grape: detail.palette.grape || THEME_STATE.palette.grape,
        rim1: detail.palette.rim1 || THEME_STATE.palette.rim1,
        rim2: detail.palette.rim2 || THEME_STATE.palette.rim2,
        danger: detail.palette.danger || THEME_STATE.palette.danger,
      };
    }
  }

  try {
    window.addEventListener("theme:changed", (ev) => updateThemeState(ev?.detail));
  } catch (_) {}

  // ============= CHARACTER DEFINITIONS =============
  const CHARACTERS = {
    A1: {
      name: "A1",
      type: "warrior",
      baseColor: "#FF6B9D",
      accentColor: "#C44569",
      style: "angular",
      theme: "chili",
    },
    Unique: {
      name: "Unique",
      type: "rogue",
      baseColor: "#4ECDC4",
      accentColor: "#45B7D1",
      style: "fluid",
      theme: "candy",
    },
    Missy: {
      name: "Missy",
      type: "mage",
      baseColor: "#B4A7D6",
      accentColor: "#9B59B6",
      style: "geometric",
      theme: "pixel",
    },
  };

  // ============= CHARACTER RENDERER =============
  class CharacterRenderer {
    constructor(characterId) {
      this.id = characterId;
      this.config = CHARACTERS[characterId] || CHARACTERS.A1;
      this.animTime = 0;
    }

    render(ctx, x, y, opts = {}) {
      const facingLeft = opts.facingLeft || false;
      const isDefeated = opts.isDefeated || false;
      const animState = opts.animState || "idle"; // idle, run, attack, jump

      if (isDefeated) {
        this.renderDefeated(ctx, x, y, facingLeft);
        return;
      }

      // Check for equipped skin first
      if (window.characterSkinSystem) {
        const skin = window.characterSkinSystem.getEquippedSkin(this.id);
        if (skin && skin.type === 'sprite' && skin.spriteData) {
          // Use sprite rendering
          if (window.animationHandler) {
            window.animationHandler.renderSprite(ctx, skin.spriteData, x, y, {
              animState,
              animTime: opts.animTime || this.animTime,
              facingLeft,
              scale: opts.scale || 1,
              alpha: opts.alpha || 1,
              skinScale: skin.scale || 1 // Use skin's scale property
            });
            return;
          }
        }
      }

      // Fallback to procedural rendering
      ctx.save();
      ctx.translate(x, y);
      if (facingLeft) ctx.scale(-1, 1);

      const useChibi = THEME_STATE.current === "candy" || opts.style === "chibi";

      this.animTime = opts.animTime || this.animTime;

      if (useChibi) {
        this.renderChibi(ctx, animState);
        ctx.restore();
        return;
      }

      switch (this.id) {
        case "A1":
          this.renderA1(ctx, animState);
          break;
        case "Unique":
          this.renderUnique(ctx, animState);
          break;
        case "Missy":
          this.renderMissy(ctx, animState);
          break;
      }

      ctx.restore();
    }

    renderA1(ctx, animState) {
      // A1: Angular warrior with dual sabers
      const bob = Math.sin(this.animTime * 0.008) * 2;

      // Body - angular, sharp edges
      ctx.fillStyle = this.config.baseColor;
      ctx.strokeStyle = this.config.accentColor;
      ctx.lineWidth = 2;

      // Torso (trapezoid)
      ctx.beginPath();
      ctx.moveTo(-12, -20 + bob);
      ctx.lineTo(12, -20 + bob);
      ctx.lineTo(10, 10 + bob);
      ctx.lineTo(-10, 10 + bob);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // Head (angular)
      ctx.fillStyle = this.config.accentColor;
      ctx.beginPath();
      ctx.moveTo(-8, -35 + bob);
      ctx.lineTo(8, -35 + bob);
      ctx.lineTo(10, -20 + bob);
      ctx.lineTo(-10, -20 + bob);
      ctx.closePath();
      ctx.fill();

      // Eyes
      ctx.fillStyle = "#FFFFFF";
      ctx.fillRect(-6, -30 + bob, 3, 3);
      ctx.fillRect(3, -30 + bob, 3, 3);

      // Arms
      ctx.strokeStyle = this.config.baseColor;
      ctx.lineWidth = 4;
      ctx.lineCap = "round";

      const armSwing =
        animState === "attack"
          ? Math.PI / 4
          : Math.sin(this.animTime * 0.01) * 0.2;

      // Left arm
      ctx.save();
      ctx.translate(-10, -10 + bob);
      ctx.rotate(-armSwing);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(-8, 12);
      ctx.stroke();
      ctx.restore();

      // Right arm
      ctx.save();
      ctx.translate(10, -10 + bob);
      ctx.rotate(armSwing);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(8, 12);
      ctx.stroke();
      ctx.restore();

      // Dual sabers
      this.renderSabers(ctx, bob, armSwing);

      // Legs
      ctx.strokeStyle = this.config.baseColor;
      ctx.lineWidth = 5;

      const legSwing =
        animState === "run" ? Math.sin(this.animTime * 0.02) * 0.3 : 0;

      // Left leg
      ctx.beginPath();
      ctx.moveTo(-5, 10 + bob);
      ctx.lineTo(-5 - Math.sin(legSwing) * 5, 25 + bob);
      ctx.stroke();

      // Right leg
      ctx.beginPath();
      ctx.moveTo(5, 10 + bob);
      ctx.lineTo(5 + Math.sin(legSwing) * 5, 25 + bob);
      ctx.stroke();
    }

    renderSabers(ctx, bob, armSwing) {
      ctx.save();
      ctx.shadowBlur = 10;
      ctx.shadowColor = "#FF6B35";
      ctx.strokeStyle = "#FF6B35";
      ctx.lineWidth = 3;
      ctx.lineCap = "round";

      // Left saber
      ctx.save();
      ctx.translate(-10, -10 + bob);
      ctx.rotate(-armSwing);
      ctx.beginPath();
      ctx.moveTo(-8, 12);
      ctx.lineTo(-8, 30);
      ctx.stroke();
      ctx.restore();

      // Right saber
      ctx.save();
      ctx.translate(10, -10 + bob);
      ctx.rotate(armSwing);
      ctx.beginPath();
      ctx.moveTo(8, 12);
      ctx.lineTo(8, 30);
      ctx.stroke();
      ctx.restore();

      ctx.restore();
    }

    renderUnique(ctx, animState) {
      // Unique: Fluid, rounded rogue character
      const bob = Math.sin(this.animTime * 0.01) * 3;

      // Body - organic curves
      ctx.fillStyle = this.config.baseColor;
      ctx.strokeStyle = this.config.accentColor;
      ctx.lineWidth = 2;

      // Torso (rounded)
      ctx.beginPath();
      ctx.ellipse(0, -5 + bob, 12, 18, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // Head (circular)
      ctx.fillStyle = this.config.accentColor;
      ctx.beginPath();
      ctx.arc(0, -28 + bob, 10, 0, Math.PI * 2);
      ctx.fill();

      // Eyes
      ctx.fillStyle = "#FFFFFF";
      ctx.beginPath();
      ctx.arc(-4, -30 + bob, 2, 0, Math.PI * 2);
      ctx.arc(4, -30 + bob, 2, 0, Math.PI * 2);
      ctx.fill();

      // Hood/Hair flowing effect
      ctx.strokeStyle = this.config.accentColor;
      ctx.lineWidth = 3;
      ctx.lineCap = "round";
      const flow = Math.sin(this.animTime * 0.008);
      ctx.beginPath();
      ctx.moveTo(-10, -30 + bob);
      ctx.quadraticCurveTo(
        -15 + flow * 3,
        -25 + bob,
        -12 + flow * 5,
        -15 + bob
      );
      ctx.stroke();

      // Arms (thin, agile)
      ctx.strokeStyle = this.config.baseColor;
      ctx.lineWidth = 3;

      const armSwing =
        animState === "attack"
          ? Math.PI / 6
          : Math.sin(this.animTime * 0.012) * 0.15;

      ctx.save();
      ctx.translate(-10, -8 + bob);
      ctx.rotate(-armSwing);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(-6, 15);
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.translate(10, -8 + bob);
      ctx.rotate(armSwing);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(6, 15);
      ctx.stroke();
      ctx.restore();

      // Legs (slim)
      const legSwing =
        animState === "run" ? Math.sin(this.animTime * 0.025) * 0.4 : 0;
      ctx.lineWidth = 4;

      ctx.beginPath();
      ctx.moveTo(-4, 13 + bob);
      ctx.lineTo(-4 - Math.sin(legSwing) * 6, 28 + bob);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(4, 13 + bob);
      ctx.lineTo(4 + Math.sin(legSwing) * 6, 28 + bob);
      ctx.stroke();
    }

    renderMissy(ctx, animState) {
      // Missy: Geometric, pixel-art style mage
      const bob = Math.sin(this.animTime * 0.009) * 2;

      // Body - geometric shapes
      ctx.fillStyle = this.config.baseColor;
      ctx.strokeStyle = this.config.accentColor;
      ctx.lineWidth = 2;

      // Torso (hexagon)
      const hexPoints = [];
      for (let i = 0; i < 6; i++) {
        const angle = (i * Math.PI * 2) / 6;
        hexPoints.push([Math.cos(angle) * 11, Math.sin(angle) * 14 - 5 + bob]);
      }
      ctx.beginPath();
      ctx.moveTo(hexPoints[0][0], hexPoints[0][1]);
      for (let i = 1; i < hexPoints.length; i++) {
        ctx.lineTo(hexPoints[i][0], hexPoints[i][1]);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // Head (octagon)
      ctx.fillStyle = this.config.accentColor;
      ctx.beginPath();
      for (let i = 0; i < 8; i++) {
        const angle = (i * Math.PI * 2) / 8;
        const x = Math.cos(angle) * 9;
        const y = Math.sin(angle) * 9 - 28 + bob;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();

      // Eyes (square pixels)
      ctx.fillStyle = "#FFFFFF";
      ctx.fillRect(-5, -31 + bob, 3, 3);
      ctx.fillRect(2, -31 + bob, 3, 3);

      // Magic staff
      if (animState === "attack") {
        ctx.save();
        ctx.strokeStyle = "#9B59B6";
        ctx.lineWidth = 4;
        ctx.shadowBlur = 15;
        ctx.shadowColor = "#9B59B6";

        ctx.beginPath();
        ctx.moveTo(12, -8 + bob);
        ctx.lineTo(20, -20 + bob);
        ctx.stroke();

        // Staff crystal
        ctx.fillStyle = "#FFFFFF";
        ctx.beginPath();
        ctx.arc(20, -20 + bob, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      // Arms (angular)
      ctx.strokeStyle = this.config.baseColor;
      ctx.lineWidth = 4;
      ctx.lineCap = "square";

      const armAngle = animState === "attack" ? -Math.PI / 3 : 0;

      ctx.save();
      ctx.translate(-8, -8 + bob);
      ctx.rotate(-Math.PI / 6);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(-6, 12);
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.translate(8, -8 + bob);
      ctx.rotate(armAngle);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(6, 12);
      ctx.stroke();
      ctx.restore();

      // Legs (blocky)
      ctx.lineWidth = 5;
      ctx.lineCap = "square";

      ctx.strokeRect(-5, 9 + bob, 4, 16);
      ctx.strokeRect(1, 9 + bob, 4, 16);
    }

    renderChibi(ctx, animState) {
      // Candy theme variant: large head, pill body, neon rim-light
      const palette = THEME_STATE.palette;
      const bob = Math.sin(this.animTime * 0.012) * 4;
      const runCycle = Math.sin(this.animTime * 0.02);

      ctx.save();
      ctx.lineJoin = "round";
      ctx.lineCap = "round";

      ctx.shadowColor = palette.rim2 || "#A78BFA";
      ctx.shadowBlur = 12;

      // Head
      ctx.fillStyle = palette.primary || "#FFB5E8";
      ctx.strokeStyle = palette.rim1 || "#00E5FF";
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(0, -32 + bob, 18, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      ctx.shadowBlur = 0;

      // Face accents
      ctx.fillStyle = "#FFFFFF";
      ctx.beginPath();
      ctx.arc(-6, -35 + bob, 3, 0, Math.PI * 2);
      ctx.arc(6, -35 + bob, 3, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = palette.rim2 || "#A78BFA";
      ctx.beginPath();
      ctx.arc(-5, -35 + bob, 1.5, 0, Math.PI * 2);
      ctx.arc(7, -35 + bob, 1.5, 0, Math.PI * 2);
      ctx.fill();

      // Body - soft pill
      ctx.fillStyle = palette.mint || "#B9FBC0";
      ctx.strokeStyle = palette.rim1 || "#00E5FF";
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.moveTo(-12, -8 + bob);
      ctx.quadraticCurveTo(-16, 2 + bob, -12, 14 + bob);
      ctx.lineTo(12, 14 + bob);
      ctx.quadraticCurveTo(16, 2 + bob, 12, -8 + bob);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // Belt stripe
      ctx.fillStyle = palette.lemon || "#FFD56A";
      ctx.fillRect(-12, 4 + bob, 24, 4);

      // Arms
      ctx.strokeStyle = palette.primary || "#FFB5E8";
      ctx.lineWidth = 3;
      const armSwing = animState === "attack" ? Math.PI / 3 : runCycle * 0.4;

      ctx.save();
      ctx.translate(-12, -2 + bob);
      ctx.rotate(-armSwing * 0.5);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(-10, 8);
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.translate(12, -2 + bob);
      ctx.rotate(armSwing * 0.5);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(10, 8);
      ctx.stroke();
      ctx.restore();

      // Legs - keep baseline steady
      ctx.strokeStyle = palette.primary || "#FFB5E8";
      ctx.lineWidth = 4;
      const legSwing = animState === "run" ? runCycle * 6 : Math.sin(this.animTime * 0.018) * 4;

      ctx.beginPath();
      ctx.moveTo(-6, 14 + bob);
      ctx.quadraticCurveTo(-8 + legSwing, 26 + bob, -2, 30 + bob);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(6, 14 + bob);
      ctx.quadraticCurveTo(8 + legSwing, 26 + bob, 2, 30 + bob);
      ctx.stroke();

      // Boots
      ctx.fillStyle = palette.blue || "#B5F5FF";
      ctx.fillRect(-8, 30 + bob, 6, 3);
      ctx.fillRect(2, 30 + bob, 6, 3);

      // Neon rim light outline
      ctx.strokeStyle = palette.rim2 || "#A78BFA";
      ctx.lineWidth = 1.5;
      ctx.globalAlpha = 0.6;
      ctx.beginPath();
      ctx.arc(0, -32 + bob, 20, 0, Math.PI * 2);
      ctx.stroke();

      ctx.globalAlpha = 1;
      ctx.restore();
    }

    renderDefeated(ctx, x, y, facingLeft) {
      ctx.save();
      ctx.translate(x, y + 20);
      if (facingLeft) ctx.scale(-1, 1);

      ctx.globalAlpha = 0.5;
      ctx.fillStyle = this.config.baseColor;

      // Simple collapsed shape
      ctx.beginPath();
      ctx.ellipse(0, 0, 20, 10, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    update(dt) {
      this.animTime += dt * 1000;
    }
  }

  // ============= EXPORT =============
  window.CharacterRenderer = CharacterRenderer;

  // Create instances for each character
  window.CharacterRenderers = {
    A1: new CharacterRenderer("A1"),
    Unique: new CharacterRenderer("Unique"),
    Missy: new CharacterRenderer("Missy"),
  };

  console.log("✨ Character Renderer loaded");
})();

</script>
  <!-- Inlined: src/rendering/npc-character-renderer.js -->
<script>
// NPC Character Renderer - Procedural NPC generation with profession-specific styles
// Extends CharacterRenderer to create distinct visual styles for all friendly NPCs

(function () {
  "use strict";

  const THEME_STATE = {
    current: (window.Theme && window.Theme.get && window.Theme.get()) || "default",
    palette: {
      primary: "#FFB6D9",
      blue: "#B4E7FF",
      lemon: "#FFD56A",
      mint: "#C8F4D9",
      grape: "#9B59B6",
      rim1: "#00E5FF",
      rim2: "#A78BFA",
      danger: "#FF3B3B",
    },
  };

  function updateThemeState(detail) {
    if (!detail) return;
    THEME_STATE.current = detail.theme || "default";
    if (detail.palette) {
      THEME_STATE.palette = {
        primary: detail.palette.primary || THEME_STATE.palette.primary,
        blue: detail.palette.blue || THEME_STATE.palette.blue,
        lemon: detail.palette.lemon || THEME_STATE.palette.lemon,
        mint: detail.palette.mint || THEME_STATE.palette.mint,
        grape: detail.palette.grape || THEME_STATE.palette.grape,
        rim1: detail.palette.rim1 || THEME_STATE.palette.rim1,
        rim2: detail.palette.rim2 || THEME_STATE.palette.rim2,
        danger: detail.palette.danger || THEME_STATE.palette.danger,
      };
    }
  }

  try {
    window.addEventListener("theme:changed", (ev) => updateThemeState(ev?.detail));
  } catch (_) {}

  // ============= NPC ARCHETYPE MAPPINGS =============
  const NPC_ARCHETYPE_MAP = {
    // World NPCs (by spriteType)
    maid: { archetype: "support", accessory: "apron", baseColor: "#ff93d3" },
    merchant: {
      archetype: "merchant",
      accessory: "coinBag",
      baseColor: "#9fd7ff",
    },
    blacksmith: {
      archetype: "crafter",
      accessory: "hammer",
      baseColor: "#ff8a3a",
    },
    alchemist: {
      archetype: "support",
      accessory: "potion",
      baseColor: "#36c777",
    },
    dealer: { archetype: "rogue", accessory: "cloak", baseColor: "#7b61ff" },
    librarian: {
      archetype: "support",
      accessory: "book",
      baseColor: "#c9a6ff",
    },
    quest: { archetype: "support", accessory: "scroll", baseColor: "#ffd56a" },
    priestess: { archetype: "mage", accessory: "halo", baseColor: "#b1fff6" },
    postman: {
      archetype: "support",
      accessory: "mailbag",
      baseColor: "#6ec1ff",
    },
    engineer: {
      archetype: "crafter",
      accessory: "goggles",
      baseColor: "#ffa96e",
    },
    arena: {
      archetype: "warrior",
      accessory: "swordAura",
      baseColor: "#ff7171",
    },
    photographer: {
      archetype: "support",
      accessory: "camera",
      baseColor: "#9fd7ff",
    },

    // Hired NPCs (by name/rank)
    grunt: { archetype: "warrior", rank: "C", baseColor: "#a1887f" },
    scout: { archetype: "rogue", rank: "C", baseColor: "#a1887f" },
    knight: { archetype: "warrior", rank: "B", baseColor: "#cd7f32" },
    ranger: { archetype: "rogue", rank: "B", baseColor: "#cd7f32" },
    sorcerer: { archetype: "mage", rank: "A", baseColor: "#c0c0c0" },
    assassin: { archetype: "rogue", rank: "A", baseColor: "#c0c0c0" },
    archmage: { archetype: "mage", rank: "S", baseColor: "#ffd700" },
    blademaster: { archetype: "warrior", rank: "S", baseColor: "#ffd700" },
    celestial: { archetype: "mage", rank: "S", baseColor: "#ffd700" },
    voidwalker: { archetype: "mage", rank: "S", baseColor: "#ffd700" },
  };

  // ============= NPC CHARACTER RENDERER =============
  class NPCCharacterRenderer {
    constructor(npcId, config = {}) {
      this.npcId = npcId;
      this.spriteType = config.spriteType;
      this.rank = config.rank || "C";

      // Determine archetype and accessory
      const mapping = NPC_ARCHETYPE_MAP[this.spriteType] ||
        NPC_ARCHETYPE_MAP[npcId?.toLowerCase()] || {
          archetype: "support",
          baseColor: "#ffd56a",
        };

      this.archetype = mapping.archetype;
      this.accessory = mapping.accessory;
      this.baseColor = config.color || mapping.baseColor;
      this.accentColor = this.shadeColor(this.baseColor, -30);

      this.animTime = 0;
    }

    shadeColor(hex, amt) {
      const num = parseInt(hex.replace("#", ""), 16);
      const r = Math.min(255, Math.max(0, ((num >> 16) & 0xff) + amt));
      const g = Math.min(255, Math.max(0, ((num >> 8) & 0xff) + amt));
      const b = Math.min(255, Math.max(0, (num & 0xff) + amt));
      return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }

    render(ctx, x, y, opts = {}) {
      const facingLeft = opts.facingLeft || false;
      const isDefeated = opts.isDefeated || false;
      const animState = opts.animState || "idle";

      if (isDefeated) {
        this.renderDefeated(ctx, x, y, facingLeft);
        return;
      }

      // Check for NPC sprite first
      if (window.npcSpriteSystem) {
        const npcSprite = window.npcSpriteSystem.getSprite(this.npcId);
        if (npcSprite) {
          // Use sprite rendering
          if (window.animationHandler) {
            window.animationHandler.renderNPCSprite(ctx, npcSprite, x, y, {
              animState,
              animTime: opts.animTime || this.animTime,
              facingLeft,
              rank: this.rank,
              type: this.archetype,
              scale: opts.scale || 1,
              alpha: opts.alpha || 1
            });
            return;
          }
        }
      }

      // Fallback to procedural rendering
      ctx.save();
      ctx.translate(x, y);
      if (facingLeft) ctx.scale(-1, 1);

      this.animTime = opts.animTime || this.animTime;

      if (THEME_STATE.current === "candy" || opts.style === "candyChibi") {
        this.renderCandyChibi(ctx, animState, opts);
        ctx.restore();
        return;
      }

      // Render based on archetype
      switch (this.archetype) {
        case "warrior":
          this.renderWarriorNPC(ctx, animState);
          break;
        case "mage":
          this.renderMageNPC(ctx, animState);
          break;
        case "rogue":
          this.renderRogueNPC(ctx, animState);
          break;
        case "support":
          this.renderSupportNPC(ctx, animState);
          break;
        case "merchant":
          this.renderMerchantNPC(ctx, animState);
          break;
        case "crafter":
          this.renderCrafterNPC(ctx, animState);
          break;
        default:
          this.renderSupportNPC(ctx, animState);
      }

      // Render accessory if present
      if (this.accessory) {
        this.renderAccessory(ctx, animState);
      }

      ctx.restore();
    }

    // ============= ARCHETYPE RENDERS =============

    renderWarriorNPC(ctx, animState) {
      const bob = Math.sin(this.animTime * 0.008) * 2;
      const complexity = this.getRankComplexity();

      // Body - angular warrior style
      ctx.fillStyle = this.baseColor;
      ctx.strokeStyle = this.accentColor;
      ctx.lineWidth = 2;

      // Torso (trapezoid)
      ctx.beginPath();
      ctx.moveTo(-10, -18 + bob);
      ctx.lineTo(10, -18 + bob);
      ctx.lineTo(8, 8 + bob);
      ctx.lineTo(-8, 8 + bob);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // Head (angular)
      ctx.fillStyle = this.accentColor;
      ctx.beginPath();
      ctx.moveTo(-7, -30 + bob);
      ctx.lineTo(7, -30 + bob);
      ctx.lineTo(8, -18 + bob);
      ctx.lineTo(-8, -18 + bob);
      ctx.closePath();
      ctx.fill();

      // Eyes
      ctx.fillStyle = "#FFFFFF";
      ctx.fillRect(-5, -26 + bob, 2, 2);
      ctx.fillRect(3, -26 + bob, 2, 2);

      // Arms
      ctx.strokeStyle = this.baseColor;
      ctx.lineWidth = 3;
      ctx.lineCap = "round";

      const armSwing =
        animState === "attack"
          ? Math.PI / 4
          : Math.sin(this.animTime * 0.01) * 0.15;

      // Left arm
      ctx.save();
      ctx.translate(-8, -10 + bob);
      ctx.rotate(-armSwing);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(-6, 10);
      ctx.stroke();
      ctx.restore();

      // Right arm
      ctx.save();
      ctx.translate(8, -10 + bob);
      ctx.rotate(armSwing);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(6, 10);
      ctx.stroke();
      ctx.restore();

      // Legs
      ctx.strokeStyle = this.baseColor;
      ctx.lineWidth = 4;

      const legSwing =
        animState === "run" ? Math.sin(this.animTime * 0.02) * 0.3 : 0;

      ctx.beginPath();
      ctx.moveTo(-4, 8 + bob);
      ctx.lineTo(-4 - Math.sin(legSwing) * 4, 20 + bob);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(4, 8 + bob);
      ctx.lineTo(4 + Math.sin(legSwing) * 4, 20 + bob);
      ctx.stroke();

      // Rank effects
      if (complexity >= 3) {
        // A-Rank glow
        ctx.save();
        ctx.shadowBlur = 8;
        ctx.shadowColor = this.baseColor;
        ctx.strokeStyle = this.baseColor;
        ctx.lineWidth = 1;
        ctx.strokeRect(-10, -30 + bob, 20, 38);
        ctx.restore();
      }

      if (complexity >= 4) {
        // S-Rank aura
        ctx.save();
        ctx.strokeStyle = this.shadeColor(this.baseColor, 50);
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.3 + Math.sin(this.animTime * 0.01) * 0.2;
        ctx.beginPath();
        ctx.arc(0, -10 + bob, 18, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }
    }

    renderMageNPC(ctx, animState) {
      const bob = Math.sin(this.animTime * 0.009) * 2;
      const complexity = this.getRankComplexity();

      // Body - geometric mage style
      ctx.fillStyle = this.baseColor;
      ctx.strokeStyle = this.accentColor;
      ctx.lineWidth = 2;

      // Torso (hexagon)
      const hexPoints = [];
      for (let i = 0; i < 6; i++) {
        const angle = (i * Math.PI * 2) / 6;
        hexPoints.push([Math.cos(angle) * 9, Math.sin(angle) * 12 - 5 + bob]);
      }
      ctx.beginPath();
      ctx.moveTo(hexPoints[0][0], hexPoints[0][1]);
      for (let i = 1; i < hexPoints.length; i++) {
        ctx.lineTo(hexPoints[i][0], hexPoints[i][1]);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // Head (octagon)
      ctx.fillStyle = this.accentColor;
      ctx.beginPath();
      for (let i = 0; i < 8; i++) {
        const angle = (i * Math.PI * 2) / 8;
        const x = Math.cos(angle) * 7;
        const y = Math.sin(angle) * 7 - 24 + bob;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();

      // Eyes
      ctx.fillStyle = "#FFFFFF";
      ctx.fillRect(-4, -26 + bob, 2, 2);
      ctx.fillRect(2, -26 + bob, 2, 2);

      // Arms (angular)
      ctx.strokeStyle = this.baseColor;
      ctx.lineWidth = 3;
      ctx.lineCap = "square";

      const armAngle = animState === "attack" ? -Math.PI / 3 : 0;

      ctx.save();
      ctx.translate(-7, -8 + bob);
      ctx.rotate(-Math.PI / 6);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(-5, 10);
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.translate(7, -8 + bob);
      ctx.rotate(armAngle);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(5, 10);
      ctx.stroke();
      ctx.restore();

      // Legs (blocky)
      ctx.lineWidth = 4;
      ctx.lineCap = "square";

      ctx.strokeRect(-4, 7 + bob, 3, 13);
      ctx.strokeRect(1, 7 + bob, 3, 13);

      // Rank effects
      if (complexity >= 2) {
        // B-Rank outline
        ctx.strokeStyle = this.shadeColor(this.baseColor, 40);
        ctx.lineWidth = 1;
        ctx.strokeRect(-10, -30 + bob, 20, 38);
      }

      if (complexity >= 3) {
        // A-Rank magic circle
        ctx.save();
        ctx.strokeStyle = this.baseColor;
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.4;
        ctx.beginPath();
        ctx.arc(0, -24 + bob, 10, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }

      if (complexity >= 4) {
        // S-Rank particles
        ctx.save();
        ctx.fillStyle = this.shadeColor(this.baseColor, 80);
        ctx.globalAlpha = 0.5 + Math.sin(this.animTime * 0.015) * 0.3;
        for (let i = 0; i < 3; i++) {
          const angle = (i / 3) * Math.PI * 2 + this.animTime * 0.002;
          const x = Math.cos(angle) * 12;
          const y = Math.sin(angle) * 12 - 10 + bob;
          ctx.beginPath();
          ctx.arc(x, y, 2, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
      }
    }

    renderRogueNPC(ctx, animState) {
      const bob = Math.sin(this.animTime * 0.01) * 3;
      const complexity = this.getRankComplexity();

      // Body - fluid rogue style
      ctx.fillStyle = this.baseColor;
      ctx.strokeStyle = this.accentColor;
      ctx.lineWidth = 2;

      // Torso (rounded)
      ctx.beginPath();
      ctx.ellipse(0, -5 + bob, 10, 15, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // Head (circular)
      ctx.fillStyle = this.accentColor;
      ctx.beginPath();
      ctx.arc(0, -24 + bob, 8, 0, Math.PI * 2);
      ctx.fill();

      // Eyes
      ctx.fillStyle = "#FFFFFF";
      ctx.beginPath();
      ctx.arc(-3, -26 + bob, 1.5, 0, Math.PI * 2);
      ctx.arc(3, -26 + bob, 1.5, 0, Math.PI * 2);
      ctx.fill();

      // Hood flow
      ctx.strokeStyle = this.accentColor;
      ctx.lineWidth = 2;
      ctx.lineCap = "round";
      const flow = Math.sin(this.animTime * 0.008);
      ctx.beginPath();
      ctx.moveTo(-8, -26 + bob);
      ctx.quadraticCurveTo(
        -12 + flow * 2,
        -22 + bob,
        -10 + flow * 4,
        -14 + bob
      );
      ctx.stroke();

      // Arms (thin)
      ctx.strokeStyle = this.baseColor;
      ctx.lineWidth = 2.5;

      const armSwing =
        animState === "attack"
          ? Math.PI / 6
          : Math.sin(this.animTime * 0.012) * 0.15;

      ctx.save();
      ctx.translate(-8, -8 + bob);
      ctx.rotate(-armSwing);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(-5, 12);
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.translate(8, -8 + bob);
      ctx.rotate(armSwing);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(5, 12);
      ctx.stroke();
      ctx.restore();

      // Legs (slim)
      const legSwing =
        animState === "run" ? Math.sin(this.animTime * 0.025) * 0.4 : 0;
      ctx.lineWidth = 3;

      ctx.beginPath();
      ctx.moveTo(-3, 10 + bob);
      ctx.lineTo(-3 - Math.sin(legSwing) * 5, 23 + bob);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(3, 10 + bob);
      ctx.lineTo(3 + Math.sin(legSwing) * 5, 23 + bob);
      ctx.stroke();

      // Rank effects
      if (complexity >= 3) {
        // A-Rank shadow trail
        ctx.save();
        ctx.globalAlpha = 0.2;
        ctx.fillStyle = this.accentColor;
        ctx.beginPath();
        ctx.ellipse(-2, -5 + bob, 10, 15, 0, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      if (complexity >= 4) {
        // S-Rank shadow aura
        ctx.save();
        ctx.strokeStyle = "#000000";
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.3 + Math.sin(this.animTime * 0.01) * 0.2;
        ctx.beginPath();
        ctx.arc(0, -8 + bob, 16, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }
    }

    renderSupportNPC(ctx, animState) {
      const bob = Math.sin(this.animTime * 0.009) * 2;
      const complexity = this.getRankComplexity();

      // Body - soft geometric support style
      ctx.fillStyle = this.baseColor;
      ctx.strokeStyle = this.accentColor;
      ctx.lineWidth = 2;

      // Torso (rounded rectangle)
      ctx.beginPath();
      ctx.roundRect(-9, -18 + bob, 18, 24, 4);
      ctx.fill();
      ctx.stroke();

      // Head (rounded)
      ctx.fillStyle = this.accentColor;
      ctx.beginPath();
      ctx.arc(0, -26 + bob, 8, 0, Math.PI * 2);
      ctx.fill();

      // Eyes
      ctx.fillStyle = "#FFFFFF";
      ctx.fillRect(-4, -28 + bob, 2, 2);
      ctx.fillRect(2, -28 + bob, 2, 2);

      // Smile
      ctx.strokeStyle = "#FFFFFF";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.arc(0, -24 + bob, 3, 0, Math.PI);
      ctx.stroke();

      // Arms
      ctx.strokeStyle = this.baseColor;
      ctx.lineWidth = 3;
      ctx.lineCap = "round";

      const armSwing = Math.sin(this.animTime * 0.01) * 0.1;

      ctx.save();
      ctx.translate(-9, -10 + bob);
      ctx.rotate(-Math.PI / 4 - armSwing);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(-5, 10);
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.translate(9, -10 + bob);
      ctx.rotate(Math.PI / 4 + armSwing);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(5, 10);
      ctx.stroke();
      ctx.restore();

      // Legs
      ctx.lineWidth = 4;

      ctx.beginPath();
      ctx.moveTo(-4, 6 + bob);
      ctx.lineTo(-4, 18 + bob);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(4, 6 + bob);
      ctx.lineTo(4, 18 + bob);
      ctx.stroke();

      // Rank effects
      if (complexity >= 2) {
        // B-Rank soft glow
        ctx.save();
        ctx.shadowBlur = 5;
        ctx.shadowColor = this.baseColor;
        ctx.strokeStyle = this.baseColor;
        ctx.lineWidth = 1;
        ctx.strokeRect(-10, -32 + bob, 20, 38);
        ctx.restore();
      }

      if (complexity >= 3) {
        // A-Rank healing aura
        ctx.save();
        ctx.strokeStyle = this.shadeColor(this.baseColor, 60);
        ctx.lineWidth = 1.5;
        ctx.globalAlpha = 0.4;
        ctx.beginPath();
        ctx.arc(0, -10 + bob, 14, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }
    }

    renderMerchantNPC(ctx, animState) {
      const bob = Math.sin(this.animTime * 0.01) * 3;

      // Body - fluid merchant style (similar to rogue but more rounded)
      ctx.fillStyle = this.baseColor;
      ctx.strokeStyle = this.accentColor;
      ctx.lineWidth = 2;

      // Torso (wide oval - prosperous merchant)
      ctx.beginPath();
      ctx.ellipse(0, -4 + bob, 11, 14, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // Head (circular)
      ctx.fillStyle = this.accentColor;
      ctx.beginPath();
      ctx.arc(0, -24 + bob, 8, 0, Math.PI * 2);
      ctx.fill();

      // Eyes
      ctx.fillStyle = "#FFFFFF";
      ctx.beginPath();
      ctx.arc(-3, -26 + bob, 1.5, 0, Math.PI * 2);
      ctx.arc(3, -26 + bob, 1.5, 0, Math.PI * 2);
      ctx.fill();

      // Arms
      ctx.strokeStyle = this.baseColor;
      ctx.lineWidth = 3;
      ctx.lineCap = "round";

      const armSwing = Math.sin(this.animTime * 0.01) * 0.1;

      ctx.save();
      ctx.translate(-9, -6 + bob);
      ctx.rotate(-armSwing);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(-6, 12);
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.translate(9, -6 + bob);
      ctx.rotate(armSwing);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(6, 12);
      ctx.stroke();
      ctx.restore();

      // Legs
      ctx.lineWidth = 4;

      ctx.beginPath();
      ctx.moveTo(-4, 10 + bob);
      ctx.lineTo(-4, 22 + bob);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(4, 10 + bob);
      ctx.lineTo(4, 22 + bob);
      ctx.stroke();
    }

    renderCrafterNPC(ctx, animState) {
      const bob = Math.sin(this.animTime * 0.008) * 2;

      // Body - angular crafter style (similar to warrior but stockier)
      ctx.fillStyle = this.baseColor;
      ctx.strokeStyle = this.accentColor;
      ctx.lineWidth = 2;

      // Torso (wide trapezoid - strong build)
      ctx.beginPath();
      ctx.moveTo(-11, -18 + bob);
      ctx.lineTo(11, -18 + bob);
      ctx.lineTo(9, 8 + bob);
      ctx.lineTo(-9, 8 + bob);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // Head (square-ish)
      ctx.fillStyle = this.accentColor;
      ctx.fillRect(-7, -30 + bob, 14, 12);

      // Eyes
      ctx.fillStyle = "#FFFFFF";
      ctx.fillRect(-5, -26 + bob, 2, 2);
      ctx.fillRect(3, -26 + bob, 2, 2);

      // Arms (strong)
      ctx.strokeStyle = this.baseColor;
      ctx.lineWidth = 4;
      ctx.lineCap = "round";

      const armSwing =
        animState === "attack"
          ? Math.PI / 3
          : Math.sin(this.animTime * 0.01) * 0.1;

      ctx.save();
      ctx.translate(-9, -10 + bob);
      ctx.rotate(-armSwing);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(-7, 10);
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.translate(9, -10 + bob);
      ctx.rotate(armSwing);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(7, 10);
      ctx.stroke();
      ctx.restore();

      // Legs (sturdy)
      ctx.lineWidth = 5;

      ctx.beginPath();
      ctx.moveTo(-4, 8 + bob);
      ctx.lineTo(-4, 20 + bob);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(4, 8 + bob);
      ctx.lineTo(4, 20 + bob);
      ctx.stroke();
    }

    renderCandyChibi(ctx, animState) {
      const palette = THEME_STATE.palette || {};
      const bob = Math.sin(this.animTime * 0.012) * 3;
      const runCycle = Math.sin(this.animTime * 0.02);
      const base = this.baseColor || palette.mint || "#B9FBC0";
      const jellyBody = this.shadeColor(base, 20);
      const jellyAccent = this.shadeColor(base, -25);
      const rim = palette.rim1 || "#00E5FF";
      const glow = palette.rim2 || "#A78BFA";

      ctx.save();
      ctx.lineJoin = "round";
      ctx.lineCap = "round";

      ctx.shadowColor = glow;
      ctx.shadowBlur = 8 + this.getRankComplexity() * 2;

      // Head
      ctx.fillStyle = palette.primary || "#FFB5E8";
      ctx.strokeStyle = rim;
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.arc(0, -26 + bob, 15, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      ctx.shadowBlur = 0;

      // Face accents
      ctx.fillStyle = "#FFFFFF";
      ctx.beginPath();
      ctx.arc(-5, -28 + bob, 2.4, 0, Math.PI * 2);
      ctx.arc(5, -28 + bob, 2.4, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = glow;
      ctx.beginPath();
      ctx.arc(-5, -28 + bob, 1.1, 0, Math.PI * 2);
      ctx.arc(5, -28 + bob, 1.1, 0, Math.PI * 2);
      ctx.fill();

      ctx.globalAlpha = 0.55;
      ctx.fillStyle = palette.lemon || "#FFD56A";
      ctx.beginPath();
      ctx.arc(-8, -22 + bob, 3, 0, Math.PI * 2);
      ctx.arc(8, -22 + bob, 3, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1;

      // Body - soft jelly pill
      ctx.fillStyle = jellyBody;
      ctx.strokeStyle = rim;
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-11, -6 + bob);
      ctx.quadraticCurveTo(-15, 4 + bob, -10, 14 + bob);
      ctx.lineTo(10, 14 + bob);
      ctx.quadraticCurveTo(15, 4 + bob, 11, -6 + bob);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // Waist frosting stripe
      ctx.fillStyle = palette.blue || "#B5F5FF";
      ctx.fillRect(-10, 2 + bob, 20, 3.2);

      this.renderCandyArchetypeAccent(ctx, bob, palette, jellyAccent);

      // Arms - marshmallow limbs
      const armSwing = animState === "attack" ? Math.PI / 3 : runCycle * 0.35;
      ctx.strokeStyle = jellyAccent;
      ctx.lineWidth = 3;

      ctx.save();
      ctx.translate(-11, -2 + bob);
      ctx.rotate(-armSwing * 0.5);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(-9, 7);
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.translate(11, -2 + bob);
      ctx.rotate(armSwing * 0.5);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(9, 7);
      ctx.stroke();
      ctx.restore();

      // Legs - gummy drops
      const legSwing = animState === "run" ? runCycle * 6 : Math.sin(this.animTime * 0.018) * 4;
      ctx.strokeStyle = jellyAccent;
      ctx.lineWidth = 4;

      ctx.beginPath();
      ctx.moveTo(-5, 14 + bob);
      ctx.quadraticCurveTo(-8 + legSwing, 26 + bob, -1, 28 + bob);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(5, 14 + bob);
      ctx.quadraticCurveTo(8 + legSwing, 26 + bob, 1, 28 + bob);
      ctx.stroke();

      ctx.fillStyle = palette.mint || "#B9FBC0";
      ctx.fillRect(-7, 28 + bob, 5, 3);
      ctx.fillRect(2, 28 + bob, 5, 3);

      this.renderCandyRankAura(ctx, bob, palette);

      if (this.accessory) {
        ctx.save();
        ctx.scale(0.9, 0.9);
        this.renderAccessory(ctx, animState);
        ctx.restore();
      }

      ctx.restore();
    }

    renderCandyArchetypeAccent(ctx, bob, palette, jellyAccent) {
      ctx.save();

      switch (this.archetype) {
        case "warrior": {
          ctx.strokeStyle = palette.danger || "#FF3B3B";
          ctx.lineWidth = 3;
          ctx.beginPath();
          ctx.moveTo(-10, -3 + bob);
          ctx.lineTo(10, 7 + bob);
          ctx.stroke();

          ctx.fillStyle = palette.grape || "#A78BFA";
          ctx.beginPath();
          ctx.arc(14, -1 + bob, 4, 0, Math.PI * 2);
          ctx.fill();

          ctx.strokeStyle = jellyAccent;
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.moveTo(14, -1 + bob);
          ctx.lineTo(14, 12 + bob);
          ctx.stroke();
          break;
        }
        case "mage": {
          ctx.fillStyle = palette.grape || "#A78BFA";
          ctx.beginPath();
          ctx.moveTo(-6, -32 + bob);
          ctx.lineTo(0, -42 + bob);
          ctx.lineTo(6, -32 + bob);
          ctx.closePath();
          ctx.fill();

          ctx.fillStyle = palette.blue || "#B5F5FF";
          ctx.beginPath();
          ctx.arc(0, -43 + bob, 3, 0, Math.PI * 2);
          ctx.fill();
          break;
        }
        case "rogue": {
          const flow = Math.sin(this.animTime * 0.01) * 2;
          ctx.fillStyle = "rgba(23, 24, 35, 0.55)";
          ctx.beginPath();
          ctx.moveTo(-12, -6 + bob);
          ctx.quadraticCurveTo(-18 - flow, 6 + bob, -6, 16 + bob);
          ctx.lineTo(-2, 16 + bob);
          ctx.closePath();
          ctx.fill();
          break;
        }
        case "merchant": {
          ctx.fillStyle = palette.lemon || "#FFD56A";
          ctx.fillRect(-6, 6 + bob, 12, 4);
          ctx.strokeStyle = jellyAccent;
          ctx.lineWidth = 1.5;
          ctx.beginPath();
          ctx.moveTo(-4, 6 + bob);
          ctx.lineTo(-4, 10 + bob);
          ctx.moveTo(0, 6 + bob);
          ctx.lineTo(0, 10 + bob);
          ctx.moveTo(4, 6 + bob);
          ctx.lineTo(4, 10 + bob);
          ctx.stroke();
          break;
        }
        case "crafter": {
          ctx.fillStyle = this.shadeColor(jellyAccent, -20);
          ctx.fillRect(-9, -4 + bob, 18, 5);
          ctx.strokeStyle = palette.blue || "#B5F5FF";
          ctx.lineWidth = 2;
          ctx.strokeRect(-7, -2 + bob, 14, 3);
          break;
        }
        default: {
          ctx.fillStyle = palette.mint || "#B9FBC0";
          ctx.beginPath();
          ctx.arc(0, 0 + bob, 4, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = palette.primary || "#FFB5E8";
          ctx.beginPath();
          ctx.arc(0, 0 + bob, 2, 0, Math.PI * 2);
          ctx.fill();
          break;
        }
      }

      ctx.restore();
    }

    renderCandyRankAura(ctx, bob, palette) {
      const complexity = this.getRankComplexity();
      if (complexity <= 1) {
        return;
      }

      ctx.save();
      ctx.globalAlpha = 0.28 + complexity * 0.08;
      ctx.strokeStyle = palette.rim2 || "#A78BFA";
      ctx.lineWidth = 1 + complexity * 0.5;
      ctx.beginPath();
      ctx.arc(0, -26 + bob, 17 + complexity * 2, 0, Math.PI * 2);
      ctx.stroke();

      if (complexity >= 3) {
        ctx.fillStyle = palette.blue || "#B5F5FF";
        const sparkleCount = 3 + complexity;
        for (let i = 0; i < sparkleCount; i++) {
          const angle = (i / sparkleCount) * Math.PI * 2 + this.animTime * 0.003;
          const radius = 12 + complexity * 2;
          const sx = Math.cos(angle) * radius;
          const sy = Math.sin(angle) * radius - 26 + bob;
          ctx.beginPath();
          ctx.arc(sx, sy, 1.5, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      ctx.restore();
    }

    // ============= ACCESSORY RENDERS =============

    renderAccessory(ctx, animState) {
      const bob = Math.sin(this.animTime * 0.009) * 2;

      switch (this.accessory) {
        case "apron":
          this.renderApron(ctx, bob);
          break;
        case "coinBag":
          this.renderCoinBag(ctx, bob);
          break;
        case "hammer":
          this.renderHammer(ctx, bob, animState);
          break;
        case "potion":
          this.renderPotion(ctx, bob);
          break;
        case "cloak":
          this.renderCloak(ctx, bob);
          break;
        case "book":
          this.renderBook(ctx, bob);
          break;
        case "scroll":
          this.renderScroll(ctx, bob);
          break;
        case "halo":
          this.renderHalo(ctx, bob);
          break;
        case "mailbag":
          this.renderMailbag(ctx, bob);
          break;
        case "goggles":
          this.renderGoggles(ctx, bob);
          break;
        case "swordAura":
          this.renderSwordAura(ctx, bob);
          break;
        case "camera":
          this.renderCamera(ctx, bob);
          break;
      }
    }

    renderApron(ctx, bob) {
      ctx.fillStyle = "#ffffff";
      ctx.strokeStyle = "#ffd6ea";
      ctx.lineWidth = 1;

      // Apron body
      ctx.beginPath();
      ctx.moveTo(-6, -12 + bob);
      ctx.lineTo(6, -12 + bob);
      ctx.lineTo(6, 4 + bob);
      ctx.lineTo(-6, 4 + bob);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // Apron pocket
      ctx.strokeRect(-4, -2 + bob, 8, 4);
    }

    renderCoinBag(ctx, bob) {
      const sway = Math.sin(this.animTime * 0.01) * 2;

      ctx.save();
      ctx.translate(10 + sway, 6 + bob);

      // Bag
      ctx.fillStyle = "#6f4c2f";
      ctx.beginPath();
      ctx.ellipse(0, 0, 5, 6, 0, 0, Math.PI * 2);
      ctx.fill();

      // Coin symbol
      ctx.strokeStyle = "#ffd56a";
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(0, -2, 3, 0, Math.PI * 2);
      ctx.stroke();

      ctx.restore();
    }

    renderHammer(ctx, bob, animState) {
      const swing = animState === "attack" ? Math.PI / 4 : 0;

      ctx.save();
      ctx.translate(8, -8 + bob);
      ctx.rotate(swing);

      // Handle
      ctx.fillStyle = "#8b5520";
      ctx.fillRect(-1, 0, 2, 12);

      // Head
      ctx.fillStyle = "#41464f";
      ctx.fillRect(-4, 2, 8, 4);

      ctx.restore();
    }

    renderPotion(ctx, bob) {
      const float = Math.sin(this.animTime * 0.012) * 2;

      ctx.save();
      ctx.translate(10, 4 + bob + float);

      // Bottle
      ctx.fillStyle = "rgba(54,199,119,0.65)";
      ctx.beginPath();
      ctx.ellipse(0, 0, 4, 6, 0, 0, Math.PI * 2);
      ctx.fill();

      // Cork
      ctx.fillStyle = "#8b5520";
      ctx.fillRect(-2, -5, 4, 3);

      ctx.restore();
    }

    renderCloak(ctx, bob) {
      const flow = Math.sin(this.animTime * 0.008);

      ctx.fillStyle = "rgba(11,18,32,0.7)";

      // Left cloak
      ctx.beginPath();
      ctx.moveTo(-9, -18 + bob);
      ctx.lineTo(-12 + flow * 2, 10 + bob);
      ctx.lineTo(-6, 12 + bob);
      ctx.closePath();
      ctx.fill();

      // Right cloak
      ctx.beginPath();
      ctx.moveTo(9, -18 + bob);
      ctx.lineTo(12 - flow * 2, 10 + bob);
      ctx.lineTo(6, 12 + bob);
      ctx.closePath();
      ctx.fill();
    }

    renderBook(ctx, bob) {
      const float = Math.sin(this.animTime * 0.01) * 1;

      ctx.save();
      ctx.translate(-10, 0 + bob + float);

      // Book cover
      ctx.fillStyle = "#6c4cff";
      ctx.fillRect(0, 0, 6, 8);

      // Pages
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0.5, 0.5, 5, 7);

      ctx.restore();
    }

    renderScroll(ctx, bob) {
      const float = Math.sin(this.animTime * 0.011) * 1.5;

      ctx.save();
      ctx.translate(10, 2 + bob + float);

      // Scroll paper
      ctx.fillStyle = "#ffd56a";
      ctx.fillRect(-4, 0, 8, 3);

      // Scroll ends
      ctx.fillStyle = "#cfa84b";
      ctx.fillRect(-5, -0.5, 1.5, 4);
      ctx.fillRect(3.5, -0.5, 1.5, 4);

      ctx.restore();
    }

    renderHalo(ctx, bob) {
      const pulse = Math.sin(this.animTime * 0.01) * 0.5;

      ctx.save();
      ctx.strokeStyle = "#9fd7ff";
      ctx.lineWidth = 2;
      ctx.globalAlpha = 0.7 + pulse * 0.3;

      ctx.beginPath();
      ctx.ellipse(0, -36 + bob, 9, 3, 0, 0, Math.PI * 2);
      ctx.stroke();

      ctx.restore();
    }

    renderMailbag(ctx, bob) {
      ctx.save();
      ctx.translate(10, 6 + bob);

      // Bag
      ctx.fillStyle = "#2e3b58";
      ctx.fillRect(-4, 0, 8, 10);

      // Flap
      ctx.fillStyle = "#6ec1ff";
      ctx.beginPath();
      ctx.moveTo(-4, 0);
      ctx.lineTo(4, 0);
      ctx.lineTo(0, 3);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }

    renderGoggles(ctx, bob) {
      ctx.save();
      ctx.translate(0, -28 + bob);

      // Strap
      ctx.fillStyle = "#303a4f";
      ctx.fillRect(-6, 0, 12, 2);

      // Lenses
      ctx.fillStyle = "#c3d1ff";
      ctx.fillRect(-6, 0, 4, 2);
      ctx.fillRect(2, 0, 4, 2);

      ctx.restore();
    }

    renderSwordAura(ctx, bob) {
      const pulse = Math.sin(this.animTime * 0.012);

      ctx.save();
      ctx.translate(12, -6 + bob);

      // Aura glow
      ctx.fillStyle = "rgba(255,113,113,0.3)";
      ctx.globalAlpha = 0.5 + pulse * 0.3;
      ctx.fillRect(-2, -8, 4, 20);

      // Sword blade
      ctx.fillStyle = "#ff7171";
      ctx.fillRect(-1, -8, 2, 18);

      ctx.restore();
    }

    renderCamera(ctx, bob) {
      const float = Math.sin(this.animTime * 0.01) * 1;

      ctx.save();
      ctx.translate(10, 4 + bob + float);

      // Camera body
      ctx.fillStyle = "#1b1f2a";
      ctx.fillRect(-4, -3, 8, 6);

      // Lens
      ctx.fillStyle = "#9fd7ff";
      ctx.beginPath();
      ctx.arc(0, 0, 2.5, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    // ============= HELPER METHODS =============

    getRankComplexity() {
      switch (this.rank) {
        case "S":
          return 4;
        case "A":
          return 3;
        case "B":
          return 2;
        case "C":
          return 1;
        default:
          return 1;
      }
    }

    renderDefeated(ctx, x, y, facingLeft) {
      ctx.save();
      ctx.translate(x, y + 15);
      if (facingLeft) ctx.scale(-1, 1);

      ctx.globalAlpha = 0.5;
      ctx.fillStyle = this.baseColor;

      // Collapsed shape
      ctx.beginPath();
      ctx.ellipse(0, 0, 16, 8, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.restore();
    }

    update(dt) {
      this.animTime += dt * 1000;
    }
  }

  // ============= EXPORT =============
  window.NPCCharacterRenderer = NPCCharacterRenderer;

  console.log("✨ NPC Character Renderer loaded");
})();

</script>

  <!-- UNIFIED: Consolidated Sprite & Animation System -->
  <!-- <script src="src/unified_animation_sprites.js"></script> -->

  <!-- Procedural enemy renderer -->
  <!-- Inlined: src/rendering/enemy-renderer.js -->
<script>
// Enemy Renderer - Procedural enemy generation that evolves by stage
// Creates unique enemies with increasing complexity

(function () {
  "use strict";

  const GA = window.GenerativeArt;

  // ============= ENEMY TYPE TEMPLATES =============
  const ENEMY_TYPES = {
    basic: {
      shapes: ["circle", "square", "triangle"],
      complexity: 1,
      colorVariants: 2,
    },
    elite: {
      shapes: ["hexagon", "octagon", "star"],
      complexity: 2,
      colorVariants: 3,
    },
    boss: {
      shapes: ["complex", "fractal", "organic"],
      complexity: 4,
      colorVariants: 4,
    },
  };

  // ============= ENEMY RENDERER =============
  class EnemyRenderer {
    constructor() {
      this.cache = new Map(); // Cache rendered enemies
    }

    render(ctx, enemy, opts = {}) {
      const stage = opts.stage || 1;
      const isBoss = enemy.isBoss || enemy.kind === "boss" || false;
      const type = enemy.type || "basic";

      const x = enemy.x || 0;
      const y = enemy.y || 0;
      const size = enemy.size || 32;

      ctx.save();
      ctx.translate(x, y);

      // Determine complexity based on stage
      let complexity = "basic";
      if (stage >= 7 || isBoss) complexity = "boss";
      else if (stage >= 4) complexity = "elite";

      // Render based on type and complexity
      if (isBoss) {
        this.renderBoss(ctx, enemy, stage, size);
      } else {
        this.renderEnemy(ctx, enemy, stage, size, complexity);
      }

      // Render spawn shield if active
      if (enemy.spawnShieldT && enemy.spawnShieldT > 0) {
        window.VFX?.ShieldEffects?.spawnShield(ctx, 0, 0, {
          radius: size * 1.2,
        });
      }

      // Draw the enemy's name or type above their health bar.  Having
      // labels on screen helps players identify targets, especially when
      // procedural sprites vary widely in appearance.  For bosses use
      // the provided name; otherwise fall back to the type.
      const label = enemy.name || enemy.type;
      if (label) {
        ctx.save();
        ctx.fillStyle = '#ffffff';
        ctx.font = '12px sans-serif';
        ctx.textAlign = 'center';
        // Position the label just above the health bar, accounting for
        // boss size differences.
        const yOff = -size - (enemy.isBoss || enemy.kind === 'boss' ? 32 : 20);
        ctx.fillText(String(label), 0, yOff);
        ctx.restore();
      }

      ctx.restore();
    }

    renderEnemy(ctx, enemy, stage, size, complexity) {
      // Generate consistent color based on enemy ID
      const seed = this.hashCode(enemy.id || Math.random());
      const rng = new GA.SeededRandom(seed);

      const palette = this.getPaletteForStage(stage);
      const baseColor = rng.choice(palette.primary);
      const accentColor = rng.choice(palette.secondary);

      const animTime = Date.now() * 0.001;
      const pulse = Math.sin(animTime * 2 + seed) * 0.1 + 0.9;

      ctx.fillStyle = baseColor;
      ctx.strokeStyle = accentColor;
      ctx.lineWidth = 2;
      ctx.shadowBlur = 10;
      ctx.shadowColor = baseColor;

      switch (complexity) {
        case "basic":
          this.renderBasicEnemy(ctx, size, baseColor, accentColor, pulse);
          break;
        case "elite":
          this.renderEliteEnemy(ctx, size, baseColor, accentColor, pulse, rng);
          break;
        case "boss":
          // Regular enemies at boss-level complexity
          this.renderComplexEnemy(
            ctx,
            size,
            baseColor,
            accentColor,
            pulse,
            rng
          );
          break;
      }

      // HP bar
      if (enemy.hp && enemy.max) {
        this.renderHealthBar(
          ctx,
          0,
          -size - 10,
          size * 1.5,
          enemy.hp,
          enemy.max
        );
      }
    }

    renderBasicEnemy(ctx, size, baseColor, accentColor, pulse) {
      const s = size * pulse;

      // Simple geometric body
      ctx.beginPath();
      ctx.arc(0, 0, s, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // Eyes
      ctx.fillStyle = "#FF0000";
      ctx.beginPath();
      ctx.arc(-s * 0.3, -s * 0.2, s * 0.15, 0, Math.PI * 2);
      ctx.arc(s * 0.3, -s * 0.2, s * 0.15, 0, Math.PI * 2);
      ctx.fill();
    }

    renderEliteEnemy(ctx, size, baseColor, accentColor, pulse, rng) {
      const s = size * pulse;
      const sides = 6 + rng.int(0, 2);

      // Polygonal body
      ctx.beginPath();
      for (let i = 0; i < sides; i++) {
        const angle = (i * Math.PI * 2) / sides;
        const x = Math.cos(angle) * s;
        const y = Math.sin(angle) * s;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // Inner core
      ctx.fillStyle = accentColor;
      ctx.beginPath();
      ctx.arc(0, 0, s * 0.5, 0, Math.PI * 2);
      ctx.fill();

      // Spikes or details
      ctx.strokeStyle = "#FFFFFF";
      ctx.lineWidth = 2;
      for (let i = 0; i < sides; i++) {
        const angle = (i * Math.PI * 2) / sides;
        ctx.beginPath();
        ctx.moveTo(Math.cos(angle) * s * 0.7, Math.sin(angle) * s * 0.7);
        ctx.lineTo(Math.cos(angle) * s * 1.3, Math.sin(angle) * s * 1.3);
        ctx.stroke();
      }
    }

    renderComplexEnemy(ctx, size, baseColor, accentColor, pulse, rng) {
      const s = size * pulse;
      const animTime = Date.now() * 0.001;

      // Layered complex shape
      ctx.globalAlpha = 0.6;
      ctx.fillStyle = baseColor;
      ctx.beginPath();
      ctx.arc(0, 0, s * 1.3, 0, Math.PI * 2);
      ctx.fill();

      ctx.globalAlpha = 1;

      // Main body with noise-based deformation
      const segments = 16;
      ctx.fillStyle = baseColor;
      ctx.beginPath();
      for (let i = 0; i <= segments; i++) {
        const angle = (i / segments) * Math.PI * 2;
        const noiseOffset = Math.sin(angle * 3 + animTime) * 0.2;
        const radius = s * (0.9 + noiseOffset);
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      // Rotating patterns
      ctx.save();
      ctx.rotate(animTime * 0.5);
      ctx.strokeStyle = accentColor;
      ctx.lineWidth = 3;

      for (let i = 0; i < 8; i++) {
        const angle = (i * Math.PI * 2) / 8;
        ctx.beginPath();
        ctx.moveTo(Math.cos(angle) * s * 0.5, Math.sin(angle) * s * 0.5);
        ctx.lineTo(Math.cos(angle) * s * 0.8, Math.sin(angle) * s * 0.8);
        ctx.stroke();
      }
      ctx.restore();

      // Eyes
      ctx.fillStyle = "#FF0000";
      ctx.shadowBlur = 15;
      ctx.shadowColor = "#FF0000";
      ctx.beginPath();
      ctx.arc(-s * 0.25, -s * 0.15, s * 0.12, 0, Math.PI * 2);
      ctx.arc(s * 0.25, -s * 0.15, s * 0.12, 0, Math.PI * 2);
      ctx.fill();
    }

    renderBoss(ctx, boss, stage, baseSize) {
      const size = baseSize || 64;
      const animTime = Date.now() * 0.001;
      const pulse = Math.sin(animTime * 1.5) * 0.15 + 0.85;

      // Boss-specific colors
      const bossColors = this.getBossColorsForStage(stage);
      const baseColor = bossColors.primary;
      const accentColor = bossColors.accent;

      ctx.shadowBlur = 30;
      ctx.shadowColor = baseColor;

      // Outer aura
      ctx.globalAlpha = 0.3;
      const auraGradient = ctx.createRadialGradient(
        0,
        0,
        0,
        0,
        0,
        size * 1.5 * pulse
      );
      auraGradient.addColorStop(0, baseColor);
      auraGradient.addColorStop(1, GA.ColorUtils.addAlpha(baseColor, 0));
      ctx.fillStyle = auraGradient;
      ctx.beginPath();
      ctx.arc(0, 0, size * 1.5 * pulse, 0, Math.PI * 2);
      ctx.fill();

      ctx.globalAlpha = 1;

      // Main boss body - ornate design
      ctx.fillStyle = baseColor;
      ctx.strokeStyle = accentColor;
      ctx.lineWidth = 4;

      // Central core
      ctx.beginPath();
      ctx.arc(0, 0, size * 0.8, 0, Math.PI * 2);
      ctx.fill();
      ctx.stroke();

      // Rotating outer ring
      ctx.save();
      ctx.rotate(animTime * 0.3);
      ctx.strokeStyle = accentColor;
      ctx.lineWidth = 6;

      const segments = 12;
      for (let i = 0; i < segments; i++) {
        const angle = (i * Math.PI * 2) / segments;
        const innerR = size * 0.9;
        const outerR = size * 1.2;

        ctx.beginPath();
        ctx.arc(0, 0, innerR, angle, angle + Math.PI / segments);
        ctx.stroke();

        // Spikes
        if (i % 2 === 0) {
          ctx.beginPath();
          ctx.moveTo(Math.cos(angle) * innerR, Math.sin(angle) * innerR);
          ctx.lineTo(Math.cos(angle) * outerR, Math.sin(angle) * outerR);
          ctx.stroke();
        }
      }
      ctx.restore();

      // Inner patterns
      ctx.save();
      ctx.rotate(-animTime * 0.5);
      ctx.fillStyle = accentColor;

      for (let i = 0; i < 8; i++) {
        const angle = (i * Math.PI * 2) / 8;
        const x = Math.cos(angle) * size * 0.4;
        const y = Math.sin(angle) * size * 0.4;
        ctx.beginPath();
        ctx.arc(x, y, size * 0.1, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();

      // Boss face/eyes
      ctx.fillStyle = "#FF0000";
      ctx.shadowBlur = 20;
      ctx.shadowColor = "#FF0000";
      ctx.beginPath();
      ctx.arc(-size * 0.25, -size * 0.2, size * 0.15, 0, Math.PI * 2);
      ctx.arc(size * 0.25, -size * 0.2, size * 0.15, 0, Math.PI * 2);
      ctx.fill();

      // Glowing core
      const coreGradient = ctx.createRadialGradient(0, 0, 0, 0, 0, size * 0.3);
      coreGradient.addColorStop(0, "#FFFFFF");
      coreGradient.addColorStop(0.5, accentColor);
      coreGradient.addColorStop(1, GA.ColorUtils.addAlpha(accentColor, 0));
      ctx.fillStyle = coreGradient;
      ctx.shadowBlur = 0;
      ctx.beginPath();
      ctx.arc(0, size * 0.3, size * 0.3, 0, Math.PI * 2);
      ctx.fill();

      // Boss HP bar (larger)
      if (boss.hp && boss.max) {
        this.renderHealthBar(
          ctx,
          0,
          -size - 20,
          size * 2,
          boss.hp,
          boss.max,
          true
        );
      }
    }

    renderHealthBar(ctx, x, y, width, hp, maxHp, isBoss = false) {
      const height = isBoss ? 8 : 4;
      const percentage = Math.max(0, Math.min(1, hp / maxHp));

      ctx.save();
      ctx.shadowBlur = 0;

      // Background
      ctx.fillStyle = "#000000";
      ctx.globalAlpha = 0.5;
      ctx.fillRect(x - width / 2, y, width, height);

      // HP bar
      ctx.globalAlpha = 1;
      let barColor = "#36c777";
      if (percentage < 0.3) barColor = "#ff4f4f";
      else if (percentage < 0.6) barColor = "#f9cc2b";

      if (isBoss) {
        const gradient = ctx.createLinearGradient(
          x - width / 2,
          y,
          x + width / 2,
          y
        );
        gradient.addColorStop(0, barColor);
        gradient.addColorStop(0.5, "#FFFFFF");
        gradient.addColorStop(1, barColor);
        ctx.fillStyle = gradient;
      } else {
        ctx.fillStyle = barColor;
      }

      ctx.fillRect(x - width / 2, y, width * percentage, height);

      // Border
      ctx.strokeStyle = "#FFFFFF";
      ctx.lineWidth = 1;
      ctx.strokeRect(x - width / 2, y, width, height);

      ctx.restore();
    }

    getPaletteForStage(stage) {
      if (stage <= 3) {
        return {
          primary: ["#6B8E23", "#8FBC8F", "#20B2AA"],
          secondary: ["#2F4F4F", "#556B2F", "#3CB371"],
        };
      } else if (stage <= 6) {
        return {
          primary: ["#CD5C5C", "#D2691E", "#B8860B"],
          secondary: ["#8B4513", "#A0522D", "#CD853F"],
        };
      } else {
        return {
          primary: ["#4B0082", "#483D8B", "#6A5ACD"],
          secondary: ["#8B008B", "#9370DB", "#BA55D3"],
        };
      }
    }

    getBossColorsForStage(stage) {
      const bossColors = {
        1: { primary: "#DC143C", accent: "#FFD700" },
        2: { primary: "#1B1B2B", accent: "#8B00FF" },
        3: { primary: "#1E90FF", accent: "#00CED1" },
        4: { primary: "#000000", accent: "#8B008B" },
        5: { primary: "#FFD700", accent: "#FF4500" },
        6: { primary: "#2F4F4F", accent: "#4682B4" },
        7: { primary: "#4169E1", accent: "#00BFFF" },
        8: { primary: "#F5F5DC", accent: "#FF69B4" },
        9: { primary: "#1C1C1C", accent: "#DC143C" },
        10: { primary: "#4B0082", accent: "#FF00FF" },
      };
      return bossColors[stage] || bossColors[1];
    }

    hashCode(str) {
      let hash = 0;
      const s = String(str);
      for (let i = 0; i < s.length; i++) {
        const char = s.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash;
      }
      return Math.abs(hash);
    }
  }

  // ============= EXPORT =============
  window.EnemyRenderer = new EnemyRenderer();

  console.log("✨ Enemy Renderer loaded");
})();

</script>

  <!-- ===== COMBAT SYSTEMS ===== -->
  <!-- OLD charge system removed - not needed with simple_skills.js -->

  <!-- Enhanced enemy AI -->
  <!-- Inlined: src/systems/enemy-ai-enhanced.js -->
<script>
// Enhanced Enemy AI - Smart targeting and movement
// Enemies target all players, never walk past, and maintain optimal range

(function () {
  "use strict";

  // ============= TARGET SELECTION =============
  class TargetSelector {
    constructor() {
      this.targetSwitchInterval = 3000; // 3-5 seconds
      this.lastSwitchTime = new Map();
    }

    selectTarget(enemy, players) {
      if (!players || players.length === 0) return null;

      const alivePlayers = players.filter((p) => !p.isDefeated);
      if (alivePlayers.length === 0) return null;

      // Check if we should switch targets
      const now = Date.now();
      const lastSwitch = this.lastSwitchTime.get(enemy.id) || 0;
      const shouldSwitch =
        now - lastSwitch > this.targetSwitchInterval + Math.random() * 2000;

      // If we have a current target and shouldn't switch, keep it
      if (enemy.currentTarget && !shouldSwitch) {
        const stillAlive = alivePlayers.find(
          (p) => p.id === enemy.currentTarget.id
        );
        if (stillAlive) return enemy.currentTarget;
      }

      // Select new target
      let target;

      if (enemy.role === "shooter" || enemy.ranged) {
        // Ranged enemies prefer distant targets
        target = this.selectFarthestTarget(enemy, alivePlayers);
      } else {
        // Melee enemies prefer nearest target
        target = this.selectNearestTarget(enemy, alivePlayers);
      }

      if (target) {
        enemy.currentTarget = target;
        this.lastSwitchTime.set(enemy.id, now);
      }

      return target;
    }

    selectNearestTarget(enemy, players) {
      let nearest = null;
      let minDist = Infinity;

      for (const player of players) {
        const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
        if (dist < minDist) {
          minDist = dist;
          nearest = player;
        }
      }

      return nearest;
    }

    selectFarthestTarget(enemy, players) {
      // Select a player at medium distance, not too close, not too far
      let best = null;
      let bestScore = -Infinity;

      for (const player of players) {
        const dist = Math.hypot(player.x - enemy.x, player.y - enemy.y);
        // Ideal distance is 200-300px for ranged
        const idealDist = 250;
        const score = -Math.abs(dist - idealDist);

        if (score > bestScore) {
          bestScore = score;
          best = player;
        }
      }

      return best || players[0];
    }

    distributeTargets(enemies, players) {
      // Distribute enemy attention across players
      const alivePlayers = players.filter((p) => !p.isDefeated);
      if (alivePlayers.length === 0) return;

      const targetCounts = new Map();
      alivePlayers.forEach((p) => targetCounts.set(p.id, 0));

      // Count current targets
      for (const enemy of enemies) {
        if (enemy.currentTarget) {
          const count = targetCounts.get(enemy.currentTarget.id) || 0;
          targetCounts.set(enemy.currentTarget.id, count + 1);
        }
      }

      // Rebalance if needed
      const maxImbalance = 3;
      const avgPerPlayer = enemies.length / alivePlayers.length;

      for (const enemy of enemies) {
        if (!enemy.currentTarget) continue;

        const currentCount = targetCounts.get(enemy.currentTarget.id) || 0;
        if (currentCount > avgPerPlayer + maxImbalance) {
          // Find least targeted player
          let minCount = Infinity;
          let leastTargeted = null;

          for (const player of alivePlayers) {
            const count = targetCounts.get(player.id) || 0;
            if (count < minCount) {
              minCount = count;
              leastTargeted = player;
            }
          }

          if (leastTargeted) {
            targetCounts.set(enemy.currentTarget.id, currentCount - 1);
            targetCounts.set(leastTargeted.id, minCount + 1);
            enemy.currentTarget = leastTargeted;
          }
        }
      }
    }
  }

  // ============= MOVEMENT CONTROLLER =============
  class MovementController {
    constructor() {
      this.optimalRanges = {
        melee: { min: 30, max: 60 },
        shooter: { min: 180, max: 280 },
        boss: { min: 100, max: 200 },
      };
    }

    updateMovement(enemy, target, dt) {
      if (!target) return;

      const dx = target.x - enemy.x;
      const dy = target.y - enemy.y;
      const dist = Math.hypot(dx, dy);

      // Determine optimal range
      let range = this.optimalRanges.melee;
      if (enemy.role === "shooter" || enemy.ranged) {
        range = this.optimalRanges.shooter;
      } else if (enemy.isBoss || enemy.kind === "boss") {
        range = this.optimalRanges.boss;
      }

      // Calculate desired movement
      let moveX = 0;
      let moveY = 0;

      if (dist > range.max) {
        // Move closer
        moveX = (dx / dist) * Math.abs(enemy.vx || 0.2);
        moveY = (dy / dist) * Math.abs(enemy.vy || 0) * 0.5; // Less vertical movement
      } else if (dist < range.min) {
        // Move away
        moveX = -(dx / dist) * Math.abs(enemy.vx || 0.2) * 0.5;
        moveY = -(dy / dist) * Math.abs(enemy.vy || 0) * 0.5;
      } else {
        // In optimal range, hover/circle
        const time = Date.now() * 0.001;
        const hoverAmount = Math.sin(time + (enemy.id || 0)) * 0.05;
        moveX = hoverAmount;
        moveY = Math.cos(time + (enemy.id || 0)) * 0.03;
      }

      // Never walk past player (X-axis check)
      if (enemy.x < target.x && moveX > 0) {
        // Enemy is to the left, moving right - OK
      } else if (enemy.x > target.x && moveX < 0) {
        // Enemy is to the right, moving left - OK
      } else if (Math.abs(dx) < 20) {
        // Too close on X-axis, stop X movement
        moveX = 0;
      }

      // Apply movement
      enemy.vx = moveX;
      enemy.vy = moveY;

      // Update facing direction
      if (dx < 0) {
        enemy.facingLeft = true;
      } else if (dx > 0) {
        enemy.facingLeft = false;
      }
    }

    checkJumpNeeded(enemy, target) {
      // Ground enemies can jump over obstacles or to reach targets
      if (enemy.isFlying) return false;
      if (!enemy.canJump) return false;

      const dx = target.x - enemy.x;
      const dy = target.y - enemy.y;

      // Jump if target is significantly higher
      if (dy < -50 && Math.abs(dx) < 200) {
        return true;
      }

      // Random occasional jump for evasion
      if (Math.random() < 0.01) {
        return true;
      }

      return false;
    }
  }

  // ============= ATTACK CONTROLLER =============
  class AttackController {
    constructor() {
      this.attackCooldowns = new Map();
    }

    shouldAttack(enemy, target) {
      if (!target) return false;

      const now = Date.now();
      const lastAttack = this.attackCooldowns.get(enemy.id) || 0;
      const cooldown = enemy.attackCooldown || 1500;

      if (now - lastAttack < cooldown) return false;

      const dist = Math.hypot(target.x - enemy.x, target.y - enemy.y);
      const attackRange = enemy.role === "shooter" || enemy.ranged ? 400 : 80;

      if (dist <= attackRange) {
        this.attackCooldowns.set(enemy.id, now);
        return true;
      }

      return false;
    }

    performAttack(enemy, target, gameState) {
      // Trigger attack based on enemy type
      if (enemy.role === "shooter" || enemy.ranged) {
        this.rangedAttack(enemy, target, gameState);
      } else {
        this.meleeAttack(enemy, target, gameState);
      }
    }

    rangedAttack(enemy, target, gameState) {
      if (!gameState.eShots) gameState.eShots = [];

      const dx = target.x - enemy.x;
      const dy = target.y - enemy.y;
      const angle = Math.atan2(dy, dx);
      const speed = 200;

      gameState.eShots.push({
        x: enemy.x,
        y: enemy.y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        dmg: enemy.dmg || 10,
        life: 3000,
        color: enemy.color || "#ff4444",
        active: true,
      });
    }

    meleeAttack(enemy, target, gameState) {
      // Melee attacks handled by collision detection
      // Just mark that we're attacking for animation purposes
      enemy.isAttacking = true;
      setTimeout(() => {
        enemy.isAttacking = false;
      }, 300);
    }
  }

  // ============= ENHANCED ENEMY AI SYSTEM =============
  class EnhancedEnemyAI {
    constructor() {
      this.targetSelector = new TargetSelector();
      this.movementController = new MovementController();
      this.attackController = new AttackController();
    }

    update(gameState, dt) {
      if (!gameState || !gameState.enemies || !gameState.players) return;

      const enemies = gameState.enemies;
      const players = gameState.players;

      // Distribute targets across players
      this.targetSelector.distributeTargets(enemies, players);

      // Update each enemy
      for (const enemy of enemies) {
        if (enemy.hp <= 0) continue;
        if (enemy.kind === "plane") continue; // Skip special enemies

        // Spawn shield countdown
        if (enemy.spawnShieldT > 0) {
          enemy.spawnShieldT -= dt * 1000;
        }

        // Select target
        const target = this.targetSelector.selectTarget(enemy, players);
        if (!target) continue;

        // Update movement
        this.movementController.updateMovement(enemy, target, dt);

        // Check if should jump
        if (this.movementController.checkJumpNeeded(enemy, target)) {
          if (!enemy.isJumping && enemy.onGround !== false) {
            enemy.vy = -0.3;
            enemy.isJumping = true;
            setTimeout(() => {
              enemy.isJumping = false;
            }, 500);
          }
        }

        // Attack if in range
        if (this.attackController.shouldAttack(enemy, target)) {
          this.attackController.performAttack(enemy, target, gameState);
        }
      }
    }

    reset() {
      this.targetSelector.lastSwitchTime.clear();
      this.attackController.attackCooldowns.clear();
    }
  }

  // ============= EXPORT =============
  window.EnhancedEnemyAI = EnhancedEnemyAI;

  // Create global instance
  window.enhancedEnemyAI = new EnhancedEnemyAI();

  console.log("✨ Enhanced Enemy AI loaded");
})();

</script>

  <!-- Enemy special abilities -->
  <!-- Inlined: src/gameplay/enemy-abilities.js -->
<script>
// Boss Ability System - teleport, parry, summons and projectiles
(function () {
  "use strict";

  const DEFAULT_PROJECTILE_COLOR = "#ff8a65";

  const ABILITIES = {
    megaBlast: { name: "Mega Blast", cooldown: 5000, minStage: 1 },
    groundSlam: {
      name: "Ground Slam",
      cooldown: 8000,
      minStage: 2,
      projectiles: 8,
    },
    summonMinions: {
      name: "Summon Vanguard",
      cooldown: 9000,
      minStage: 1,
      maxSummons: 4,
      count: 2,
    },
    teleportStrike: { name: "Teleport Strike", cooldown: 6500, minStage: 1 },
    parryWindow: {
      name: "Parry Window",
      cooldown: 6000,
      minStage: 1,
      duration: 650,
    },
  };

  function now() {
    return window.performance?.now?.() || Date.now();
  }

  function ensureArray(target, key) {
    if (!target) return [];
    if (!Array.isArray(target[key])) target[key] = [];
    return target[key];
  }

  function getPrimaryTarget(state, enemy) {
    if (!state) return null;

    if (state.targetSummon && state.targetSummon.dead) {
      state.targetSummon = null;
    }

    if (enemy) {
      if (
        enemy.tauntTarget &&
        !enemy.tauntTarget.dead &&
        (!enemy.tauntUntil || enemy.tauntUntil > now())
      ) {
        return enemy.tauntTarget;
      }
      if (enemy.tauntUntil && enemy.tauntUntil <= now()) {
        enemy.tauntTarget = null;
      }
    }

    const summonCandidates = Array.isArray(state.summons)
      ? state.summons.filter((summon) => summon && !summon.dead)
      : [];
    if (summonCandidates.length) {
      if (enemy) {
        let closest = null;
        let closestDist = Infinity;
        for (const summon of summonCandidates) {
          const dx = (summon.x || 0) - (enemy.x || 0);
          const dy = (summon.y || 0) - (enemy.y || 0);
          const dist = dx * dx + dy * dy;
          if (dist < closestDist) {
            closest = summon;
            closestDist = dist;
          }
        }
        if (closest) {
          state.targetSummon = closest;
          return closest;
        }
      }
      if (state.targetSummon && !state.targetSummon.dead) {
        return state.targetSummon;
      }
      return summonCandidates[0];
    }

    const direct = state.target;
    if (direct && typeof direct.x === "number" && typeof direct.y === "number")
      return direct;

    const leaderIndex =
      typeof state.leader === "number" ? state.leader : state.leader ?? 0;
    if (Array.isArray(state.players) && state.players[leaderIndex])
      return state.players[leaderIndex];

    if (window.Game && typeof window.Game.getLeader === "function") {
      const leader = window.Game.getLeader();
      if (leader) return leader;
    }

    if (state.player && typeof state.player.x === "number") return state.player;
    if (Array.isArray(state.heroes) && state.heroes.length)
      return state.heroes[0];

    return { x: (window.DESIGN_W || 900) / 2, y: (window.DESIGN_H || 540) / 2 };
  }

  function shiftColor(hex, amount) {
    if (typeof hex !== "string" || !/^#?[0-9a-f]{6}$/i.test(hex)) {
      return DEFAULT_PROJECTILE_COLOR;
    }
    const norm = hex.startsWith("#") ? hex.slice(1) : hex;
    let r = parseInt(norm.slice(0, 2), 16);
    let g = parseInt(norm.slice(2, 4), 16);
    let b = parseInt(norm.slice(4, 6), 16);
    r = Math.max(0, Math.min(255, r + amount));
    g = Math.max(0, Math.min(255, g + amount));
    b = Math.max(0, Math.min(255, b + amount));
    const toHex = (v) => v.toString(16).padStart(2, "0");
    return "#" + toHex(r) + toHex(g) + toHex(b);
  }

  class AbilityManager {
    constructor() {
      this.cooldowns = new Map();
      this.activeAbilities = new Set();
      this._lastStageUpdate = undefined;
      this._advancedUnlocked = undefined;
    }

    updateAvailableAbilities(stage) {
      this.activeAbilities.clear();
      Object.entries(ABILITIES).forEach(([key, ability]) => {
        if (!ability.minStage || stage >= ability.minStage)
          this.activeAbilities.add(key);
      });
    }

    canUseAbility(enemy, abilityName) {
      const ability = ABILITIES[abilityName];
      if (!ability) return false;
      if (!this.activeAbilities.has(abilityName)) return false;
      if (!enemy || enemy.hp <= 0) return false;

      const enemyCooldowns = this.cooldowns.get(enemy.id) || {};
      const lastUse = enemyCooldowns[abilityName] || 0;
      return now() - lastUse >= ability.cooldown;
    }

    useAbility(enemy, abilityName) {
      const enemyCooldowns = this.cooldowns.get(enemy.id) || {};
      enemyCooldowns[abilityName] = now();
      this.cooldowns.set(enemy.id, enemyCooldowns);
    }

    executeMegaBlast(enemy, gameState) {
      const target = getPrimaryTarget(gameState, enemy);
      if (!target) return false;

      const dx = target.x - enemy.x;
      const dy = target.y - enemy.y;
      const angle = Math.atan2(dy, dx);
      const speed = 260;
      const dmg = Math.max(20, Math.round((enemy.dmg || 40) * 1.35));

      const shots = ensureArray(gameState, "eShots");
      shots.push({
        x: enemy.x,
        y: enemy.y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        dmg,
        life: 3500,
        color: enemy.color || DEFAULT_PROJECTILE_COLOR,
        ownerId: enemy.id,
        ability: "megaBlast",
        radius: 10,
      });

      const effects = ensureArray(gameState, "effects");
      effects.push({
        x: enemy.x,
        y: enemy.y - 45,
        txt: "Mega Blast!",
        color: "#ff7a6a",
        life: 600,
        vy: -40,
        sourceId: enemy.id,
      });
      return true;
    }

    executeGroundSlam(enemy, gameState) {
      const ability = ABILITIES.groundSlam;
      const shots = ensureArray(gameState, "eShots");
      const count = ability.projectiles || 8;
      const speed = 180;
      const baseDmg = Math.max(16, Math.round((enemy.dmg || 36) * 0.8));

      for (let i = 0; i < count; i++) {
        const angle = (Math.PI * 2 * i) / count;
        shots.push({
          x: enemy.x,
          y: enemy.y,
          vx: Math.cos(angle) * speed,
          vy: Math.sin(angle) * speed,
          dmg: baseDmg,
          life: 1400,
          color: shiftColor(enemy.color || DEFAULT_PROJECTILE_COLOR, -20),
          ownerId: enemy.id,
          ability: "groundSlam",
          radius: 12,
        });
      }

      const effects = ensureArray(gameState, "effects");
      effects.push({
        x: enemy.x,
        y: enemy.y - 30,
        txt: "Ground Slam",
        color: "#ffa94d",
        life: 550,
        vy: -35,
        sourceId: enemy.id,
      });
      return true;
    }

    executeSummonMinions(enemy, gameState) {
      const ability = ABILITIES.summonMinions;
      const enemies = ensureArray(gameState, "enemies");
      const existing = enemies.filter(
        (unit) => unit && !unit.isBoss && unit.summonerId === enemy.id
      ).length;
      if (existing >= (ability.maxSummons || 0)) return false;

      const count = ability.count || 2;
      for (let i = 0; i < count; i++) {
        const minion = {
          id: Math.random(),
          x: enemy.x + (Math.random() - 0.5) * 140,
          y: enemy.y + (Math.random() - 0.5) * 100,
          hp: Math.max(120, Math.round((enemy.max || 600) * 0.25)),
          max: Math.max(120, Math.round((enemy.max || 600) * 0.25)),
          dmg: Math.max(18, Math.round((enemy.dmg || 40) * 0.55)),
          vx: -(0.22 + Math.random() * 0.08),
          vy: 0,
          color: shiftColor(enemy.color || DEFAULT_PROJECTILE_COLOR, 18),
          size: 36,
          fireCD: 0,
          def: Math.max(8, Math.round((enemy.def || 20) * 0.5)),
          ranged: false,
          isBoss: false,
          isSummonedMinion: true,
          behavior: "relentless",
          summonerId: enemy.id,
          spawnShieldT: 600,
          waveTag: enemy.waveTag || null,
        };
        enemies.push(minion);
      }

      const effects = ensureArray(gameState, "effects");
      effects.push({
        x: enemy.x,
        y: enemy.y - 50,
        txt: "Summon Vanguard",
        color: "#8dd58a",
        life: 650,
        vy: -30,
        sourceId: enemy.id,
      });
      return true;
    }

    executeTeleportStrike(enemy, gameState) {
      const target = getPrimaryTarget(gameState, enemy);
      if (!target) return false;

      const offsetX = (Math.random() - 0.5) * 120;
      const offsetY = (Math.random() - 0.5) * 60;
      const facing = target.facingLeft ? -1 : 1;
      enemy.x = target.x + facing * 140 + offsetX;
      enemy.y = target.y + offsetY;

      const shots = ensureArray(gameState, "eShots");
      const angle = Math.atan2(target.y - enemy.y, target.x - enemy.x);
      shots.push({
        x: enemy.x,
        y: enemy.y,
        vx: Math.cos(angle) * 280,
        vy: Math.sin(angle) * 280,
        dmg: Math.max(18, Math.round((enemy.dmg || 45) * 0.85)),
        life: 1800,
        color: shiftColor(enemy.color || DEFAULT_PROJECTILE_COLOR, 12),
        ownerId: enemy.id,
        ability: "teleportStrike",
        radius: 10,
      });

      const effects = ensureArray(gameState, "effects");
      effects.push({
        x: enemy.x,
        y: enemy.y - 40,
        txt: "Teleport!",
        color: "#9b5de5",
        life: 520,
        vy: -28,
        sourceId: enemy.id,
      });
      return true;
    }

    triggerParry(enemy, gameState) {
      const ability = ABILITIES.parryWindow;
      enemy._parryUntil = now() + (ability.duration || 600);
      enemy.parryFlash = ability.duration
        ? Math.ceil((ability.duration / 33) * 0.2)
        : 4; // Reduced by 80%

      const effects = ensureArray(gameState, "effects");
      // Parry text VFX reduced by 80%
      effects.push({
        x: enemy.x,
        y: enemy.y - 55,
        txt: "Parry!",
        color: "#4ecdc4",
        life: 84, // Reduced from 420ms to 84ms (80% reduction)
        vy: -24,
        sourceId: enemy.id,
      });
    }

    autoUseAbilities(enemy, gameState, dt) {
      if (!enemy || enemy.hp <= 0) return;
      if (!gameState) return;

      const stage = gameState.stage || 1;
      const waveRaw = gameState.wave;
      const waveNumber =
        typeof waveRaw === "number" ? waveRaw : parseFloat(waveRaw) || 0;
      const advancedUnlocked = waveNumber >= 9;

      if (
        this._lastStageUpdate !== stage ||
        this._advancedUnlocked !== advancedUnlocked
      ) {
        this.updateAvailableAbilities(stage);
        this._lastStageUpdate = stage;
        this._advancedUnlocked = advancedUnlocked;
      }

      const hpRatio = enemy.max ? enemy.hp / enemy.max : 1;

      if (this.canUseAbility(enemy, "megaBlast") && Math.random() < 0.01) {
        if (this.executeMegaBlast(enemy, gameState))
          this.useAbility(enemy, "megaBlast");
      }

      if (
        this.canUseAbility(enemy, "groundSlam") &&
        (hpRatio < 0.7 ? Math.random() < 0.02 : Math.random() < 0.006)
      ) {
        if (this.executeGroundSlam(enemy, gameState))
          this.useAbility(enemy, "groundSlam");
      }

      if (
        enemy.canSummon !== false &&
        this.canUseAbility(enemy, "summonMinions") &&
        advancedUnlocked &&
        hpRatio < 0.65 &&
        Math.random() < 0.018
      ) {
        if (this.executeSummonMinions(enemy, gameState))
          this.useAbility(enemy, "summonMinions");
      }

      if (
        enemy.canTeleport === true &&
        this.canUseAbility(enemy, "teleportStrike") &&
        Math.random() < 0.012
      ) {
        if (this.executeTeleportStrike(enemy, gameState))
          this.useAbility(enemy, "teleportStrike");
      }

      if (
        enemy.canParry === true &&
        this.canUseAbility(enemy, "parryWindow") &&
        Math.random() < 0.02
      ) {
        this.triggerParry(enemy, gameState);
        this.useAbility(enemy, "parryWindow");
      }

      if (enemy.parryFlash > 0) {
        enemy.parryFlash = Math.max(0, enemy.parryFlash - 1);
      }
    }

    update(gameState, dt) {
      if (!gameState || !Array.isArray(gameState.enemies)) return;
      for (const enemy of gameState.enemies) {
        this.autoUseAbilities(enemy, gameState, dt);
      }
    }

    attemptParry() {
      return false;
    }

    reset() {
      this.cooldowns.clear();
      this.activeAbilities.clear();
      this._lastStageUpdate = undefined;
      this._advancedUnlocked = undefined;
    }
  }

  function interceptProjectileHit(enemy, shot, gameState) {
    if (!enemy || !shot) return false;
    if (enemy._parryUntil && enemy._parryUntil > now()) {
      const target = getPrimaryTarget(gameState, enemy) || {
        x: shot.x + (-shot.vx || 1) * 16,
        y: shot.y,
      };
      const dx = target.x - enemy.x;
      const dy = target.y - enemy.y;
      const angle = Math.atan2(dy, dx);
      const reflected = ensureArray(gameState, "eShots");
      // Parry VFX reduced by 80%
      reflected.push({
        x: enemy.x,
        y: enemy.y,
        vx: Math.cos(angle) * 300,
        vy: Math.sin(angle) * 300,
        dmg: Math.max(14, Math.round((enemy.dmg || 30) * 0.7)),
        life: 1600,
        color: "#4ecdc4",
        ownerId: enemy.id,
        ability: "parry",
        radius: 2, // Reduced from 8 to 2 (75% reduction)
      });
      return true;
    }
    return false;
  }

  window.EnemyAbilities = {
    AbilityManager,
    ABILITIES,
    interceptProjectileHit,
  };

  window.enemyAbilities = new AbilityManager();

  console.log("? Boss Ability System loaded (teleport + parry + summons)");
})();

</script>

  <!-- Spell glyph system -->
  <!-- Inlined: src/skills/spell-glyphs.js -->
<script>
// Spell Glyph System - Procedural runes for skill casting
// Generates unique glyphs based on skill ID and element type

(function () {
  "use strict";

  const GA = window.GenerativeArt;

  // ============= ELEMENT TYPES =============
  const ELEMENT_COLORS = {
    physical: { primary: "#ff6b6b", secondary: "#ff8787", glow: "#ffa5a5" },
    magic: { primary: "#4c6ef5", secondary: "#748ffc", glow: "#a5b4fc" },
    fire: { primary: "#ff6b35", secondary: "#f7931e", glow: "#ffb347" },
    ice: { primary: "#4ecdc4", secondary: "#45b7d1", glow: "#a8e6cf" },
    chaos: { primary: "#9b59b6", secondary: "#e74c3c", glow: "#f8b500" },
    light: { primary: "#ffd93d", secondary: "#ffffff", glow: "#fffacd" },
    dark: { primary: "#2c3e50", secondary: "#34495e", glow: "#7f8c8d" },
  };

  // ============= GLYPH GENERATOR =============
  class GlyphGenerator {
    constructor() {
      this.cache = new Map(); // Cache generated glyphs
    }

    generate(skillId, element = "magic", opts = {}) {
      const cacheKey = `${skillId}_${element}`;
      if (this.cache.has(cacheKey)) {
        return this.cache.get(cacheKey);
      }

      const seed = this.hashString(skillId);
      const rng = new GA.SeededRandom(seed);
      const colors = ELEMENT_COLORS[element] || ELEMENT_COLORS.magic;

      const glyph = {
        layers: [],
        colors,
        seed,
        rotation: 0,
        scale: 1,
        ...opts,
      };

      // Base circle
      glyph.layers.push({
        type: "circle",
        radius: 1.0,
        stroke: colors.primary,
        strokeWidth: 0.08,
        fill: "none",
      });

      // Inner circle
      glyph.layers.push({
        type: "circle",
        radius: 0.7,
        stroke: colors.secondary,
        strokeWidth: 0.05,
        fill: "none",
      });

      // Geometric pattern based on seed
      const pattern = rng.int(0, 4);
      switch (pattern) {
        case 0: // Star pattern
          glyph.layers.push(this.createStarLayer(rng, colors));
          break;
        case 1: // Polygon pattern
          glyph.layers.push(this.createPolygonLayer(rng, colors));
          break;
        case 2: // Cross pattern
          glyph.layers.push(this.createCrossLayer(rng, colors));
          break;
        case 3: // Rune lines
          glyph.layers.push(this.createRuneLayer(rng, colors));
          break;
        case 4: // Spiral
          glyph.layers.push(this.createSpiralLayer(rng, colors));
          break;
      }

      // Central symbol
      glyph.layers.push({
        type: "circle",
        radius: 0.15,
        stroke: "none",
        fill: colors.glow,
      });

      // Dots around circle
      const dotCount = 4 + rng.int(0, 4);
      for (let i = 0; i < dotCount; i++) {
        const angle = (i * Math.PI * 2) / dotCount;
        glyph.layers.push({
          type: "dot",
          x: Math.cos(angle) * 0.85,
          y: Math.sin(angle) * 0.85,
          radius: 0.06,
          fill: colors.primary,
        });
      }

      this.cache.set(cacheKey, glyph);
      return glyph;
    }

    createStarLayer(rng, colors) {
      const points = 5 + rng.int(0, 2);
      return {
        type: "star",
        points,
        outerRadius: 0.6,
        innerRadius: 0.3,
        stroke: colors.secondary,
        strokeWidth: 0.06,
        fill: "none",
      };
    }

    createPolygonLayer(rng, colors) {
      const sides = 3 + rng.int(0, 4);
      return {
        type: "polygon",
        sides,
        radius: 0.55,
        rotation: rng.range(0, Math.PI * 2),
        stroke: colors.secondary,
        strokeWidth: 0.06,
        fill: "none",
      };
    }

    createCrossLayer(rng, colors) {
      return {
        type: "cross",
        size: 0.6,
        width: 0.08,
        rotation: rng.range(0, Math.PI / 4),
        stroke: colors.secondary,
      };
    }

    createRuneLayer(rng, colors) {
      const lineCount = 4 + rng.int(0, 3);
      const lines = [];
      for (let i = 0; i < lineCount; i++) {
        const angle = (i * Math.PI * 2) / lineCount + rng.range(-0.3, 0.3);
        lines.push({
          x1: Math.cos(angle) * 0.2,
          y1: Math.sin(angle) * 0.2,
          x2: Math.cos(angle) * 0.6,
          y2: Math.sin(angle) * 0.6,
        });
      }
      return {
        type: "runes",
        lines,
        stroke: colors.secondary,
        strokeWidth: 0.05,
      };
    }

    createSpiralLayer(rng, colors) {
      const turns = 2 + rng.range(0, 1);
      const points = [];
      const segments = 20;
      for (let i = 0; i <= segments; i++) {
        const t = i / segments;
        const angle = t * Math.PI * 2 * turns;
        const radius = 0.2 + t * 0.4;
        points.push({
          x: Math.cos(angle) * radius,
          y: Math.sin(angle) * radius,
        });
      }
      return {
        type: "spiral",
        points,
        stroke: colors.secondary,
        strokeWidth: 0.05,
      };
    }

    render(ctx, glyph, x, y, size, opts = {}) {
      const rotation = opts.rotation || glyph.rotation;
      const scale = (opts.scale || glyph.scale) * size;
      const alpha = opts.alpha !== undefined ? opts.alpha : 1;
      const animTime = opts.animTime || 0;

      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(rotation);
      ctx.scale(scale, scale);
      ctx.globalAlpha = alpha;

      // Glow effect
      if (opts.glow !== false) {
        ctx.shadowBlur = 15;
        ctx.shadowColor = glyph.colors.glow;
      }

      // Render each layer
      for (const layer of glyph.layers) {
        this.renderLayer(ctx, layer, animTime);
      }

      ctx.restore();
    }

    renderLayer(ctx, layer, animTime) {
      ctx.strokeStyle = layer.stroke || "#FFFFFF";
      ctx.fillStyle = layer.fill || "none";
      ctx.lineWidth = layer.strokeWidth || 0.05;

      switch (layer.type) {
        case "circle":
          ctx.beginPath();
          ctx.arc(0, 0, layer.radius, 0, Math.PI * 2);
          if (layer.fill && layer.fill !== "none") ctx.fill();
          if (layer.stroke && layer.stroke !== "none") ctx.stroke();
          break;

        case "star":
          this.renderStar(ctx, layer);
          break;

        case "polygon":
          this.renderPolygon(ctx, layer);
          break;

        case "cross":
          this.renderCross(ctx, layer);
          break;

        case "runes":
          this.renderRunes(ctx, layer);
          break;

        case "spiral":
          this.renderSpiral(ctx, layer);
          break;

        case "dot":
          ctx.fillStyle = layer.fill;
          ctx.beginPath();
          ctx.arc(layer.x, layer.y, layer.radius, 0, Math.PI * 2);
          ctx.fill();
          break;
      }
    }

    renderStar(ctx, layer) {
      ctx.save();
      if (layer.rotation) ctx.rotate(layer.rotation);

      ctx.beginPath();
      for (let i = 0; i < layer.points * 2; i++) {
        const angle = (i * Math.PI) / layer.points - Math.PI / 2;
        const radius = i % 2 === 0 ? layer.outerRadius : layer.innerRadius;
        const x = Math.cos(angle) * radius;
        const y = Math.sin(angle) * radius;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      if (layer.fill && layer.fill !== "none") ctx.fill();
      if (layer.stroke && layer.stroke !== "none") ctx.stroke();

      ctx.restore();
    }

    renderPolygon(ctx, layer) {
      ctx.save();
      if (layer.rotation) ctx.rotate(layer.rotation);

      ctx.beginPath();
      for (let i = 0; i < layer.sides; i++) {
        const angle = (i * Math.PI * 2) / layer.sides - Math.PI / 2;
        const x = Math.cos(angle) * layer.radius;
        const y = Math.sin(angle) * layer.radius;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
      if (layer.fill && layer.fill !== "none") ctx.fill();
      if (layer.stroke && layer.stroke !== "none") ctx.stroke();

      ctx.restore();
    }

    renderCross(ctx, layer) {
      ctx.save();
      if (layer.rotation) ctx.rotate(layer.rotation);

      ctx.strokeStyle = layer.stroke;
      ctx.lineWidth = layer.width;
      ctx.lineCap = "round";

      // Vertical
      ctx.beginPath();
      ctx.moveTo(0, -layer.size);
      ctx.lineTo(0, layer.size);
      ctx.stroke();

      // Horizontal
      ctx.beginPath();
      ctx.moveTo(-layer.size, 0);
      ctx.lineTo(layer.size, 0);
      ctx.stroke();

      ctx.restore();
    }

    renderRunes(ctx, layer) {
      ctx.strokeStyle = layer.stroke;
      ctx.lineWidth = layer.strokeWidth;
      ctx.lineCap = "round";

      for (const line of layer.lines) {
        ctx.beginPath();
        ctx.moveTo(line.x1, line.y1);
        ctx.lineTo(line.x2, line.y2);
        ctx.stroke();
      }
    }

    renderSpiral(ctx, layer) {
      ctx.strokeStyle = layer.stroke;
      ctx.lineWidth = layer.strokeWidth;
      ctx.lineCap = "round";

      ctx.beginPath();
      const points = layer.points;
      if (points.length > 0) {
        ctx.moveTo(points[0].x, points[0].y);
        for (let i = 1; i < points.length; i++) {
          ctx.lineTo(points[i].x, points[i].y);
        }
      }
      ctx.stroke();
    }

    hashString(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash;
      }
      return Math.abs(hash);
    }
  }

  // ============= CASTING EFFECT =============
  class CastingEffect {
    constructor(x, y, skillId, element, duration = 1000) {
      this.x = x;
      this.y = y;
      this.skillId = skillId;
      this.element = element;
      this.duration = duration;
      this.startTime = Date.now();
      this.glyph = window.spellGlyphs.generate(skillId, element);
      this.active = true;
    }

    update(dt) {
      const elapsed = Date.now() - this.startTime;
      if (elapsed >= this.duration) {
        this.active = false;
      }
    }

    render(ctx) {
      if (!this.active) return;

      const elapsed = Date.now() - this.startTime;
      const progress = elapsed / this.duration;

      // Fade in then out
      let alpha = 1;
      if (progress < 0.2) {
        alpha = progress / 0.2;
      } else if (progress > 0.8) {
        alpha = (1 - progress) / 0.2;
      }

      // Rotate and scale
      const rotation = progress * Math.PI * 2;
      const scale = 0.5 + progress * 0.5;

      window.spellGlyphs.render(ctx, this.glyph, this.x, this.y, 60, {
        rotation,
        scale,
        alpha,
        glow: true,
      });
    }
  }

  // ============= GLYPH MANAGER =============
  class GlyphManager {
    constructor() {
      this.generator = new GlyphGenerator();
      this.activeEffects = [];
    }

    generate(skillId, element) {
      return this.generator.generate(skillId, element);
    }

    render(ctx, glyph, x, y, size, opts) {
      return this.generator.render(ctx, glyph, x, y, size, opts);
    }

    castEffect(x, y, skillId, element, duration) {
      const effect = new CastingEffect(x, y, skillId, element, duration);
      this.activeEffects.push(effect);
      return effect;
    }

    update(dt) {
      for (let i = this.activeEffects.length - 1; i >= 0; i--) {
        this.activeEffects[i].update(dt);
        if (!this.activeEffects[i].active) {
          this.activeEffects.splice(i, 1);
        }
      }
    }

    renderAll(ctx) {
      for (const effect of this.activeEffects) {
        effect.render(ctx);
      }
    }

    clear() {
      this.activeEffects = [];
    }
  }

  // ============= EXPORT =============
  window.SpellGlyphs = {
    GlyphGenerator,
    CastingEffect,
    GlyphManager,
    ELEMENT_COLORS,
  };

  // Create global instance
  window.spellGlyphs = new GlyphManager();

  console.log("✨ Spell Glyph System loaded");
})();

</script>

  <!-- Color logic palette system -->
  <!-- Inlined: src/assets/color-logic-palette.js -->
<script>
// Color Logic Palette System
// Maps damage/element types to visual colors and effects
// Integrates with VFX Generator and Particle System

(function () {
  "use strict";

  // ============= COLOR PALETTES BY ELEMENT TYPE =============
  const ElementPalettes = {
    // Water/Ice element
    water: {
      primary: "#4A90E2",
      secondary: "#7EC8E3",
      accent: "#9FDBFE",
      glow: "#B8E6FF",
      particles: ["#4A90E2", "#7EC8E3", "#9FDBFE"],
      effects: {
        trail: "flow",
        impact: "splash",
        glow: "soft",
      },
    },

    // Fire/Pyro element
    fire: {
      primary: "#FF4757",
      secondary: "#FF6348",
      accent: "#FFA502",
      glow: "#FFD93D",
      particles: ["#FF4757", "#FF6348", "#FFA502", "#FFD93D"],
      effects: {
        trail: "ember",
        impact: "explosion",
        glow: "intense",
      },
    },

    pyro: {
      // Alias for fire
      primary: "#FF4757",
      secondary: "#FF6348",
      accent: "#FFA502",
      glow: "#FFD93D",
      particles: ["#FF4757", "#FF6348", "#FFA502"],
      effects: {
        trail: "ember",
        impact: "burn",
        glow: "intense",
      },
    },

    // Lightning/Electric element
    lightning: {
      primary: "#FFEB3B",
      secondary: "#FDD835",
      accent: "#F9A825",
      glow: "#FFF59D",
      particles: ["#FFEB3B", "#FDD835", "#FFFFFF"],
      effects: {
        trail: "spark",
        impact: "shock",
        glow: "pulse",
      },
    },

    electric: {
      // Alias for lightning
      primary: "#FFEB3B",
      secondary: "#FDD835",
      accent: "#F9A825",
      glow: "#FFF59D",
      particles: ["#FFEB3B", "#FDD835", "#FFFFFF"],
      effects: {
        trail: "spark",
        impact: "shock",
        glow: "pulse",
      },
    },

    // Shadow/Dark element
    shadow: {
      primary: "#5F27CD",
      secondary: "#341F97",
      accent: "#8E44AD",
      glow: "#9B59B6",
      particles: ["#5F27CD", "#341F97", "#8E44AD"],
      effects: {
        trail: "smoke",
        impact: "void",
        glow: "dark",
      },
    },

    dark: {
      // Alias for shadow
      primary: "#2C2C54",
      secondary: "#474787",
      accent: "#5F27CD",
      glow: "#9B59B6",
      particles: ["#2C2C54", "#474787", "#5F27CD"],
      effects: {
        trail: "smoke",
        impact: "void",
        glow: "dark",
      },
    },

    // Time/Temporal element
    time: {
      primary: "#00D2D3",
      secondary: "#01A3A4",
      accent: "#4ECDC4",
      glow: "#80E9EA",
      particles: ["#00D2D3", "#01A3A4", "#4ECDC4"],
      effects: {
        trail: "ripple",
        impact: "distortion",
        glow: "shimmer",
      },
    },

    temporal: {
      // Alias for time
      primary: "#00D2D3",
      secondary: "#01A3A4",
      accent: "#4ECDC4",
      glow: "#80E9EA",
      particles: ["#00D2D3", "#01A3A4", "#4ECDC4"],
      effects: {
        trail: "ripple",
        impact: "distortion",
        glow: "shimmer",
      },
    },

    // Arcane/Magic element
    arcane: {
      primary: "#E91E63",
      secondary: "#C2185B",
      accent: "#F06292",
      glow: "#F8BBD0",
      particles: ["#E91E63", "#C2185B", "#F06292"],
      effects: {
        trail: "magic",
        impact: "burst",
        glow: "mystical",
      },
    },

    magic: {
      // Alias for arcane
      primary: "#E91E63",
      secondary: "#C2185B",
      accent: "#F06292",
      glow: "#F8BBD0",
      particles: ["#E91E63", "#C2185B", "#F06292"],
      effects: {
        trail: "magic",
        impact: "burst",
        glow: "mystical",
      },
    },

    // Physical/Neutral damage
    physical: {
      primary: "#A8A8A8",
      secondary: "#D0D0D0",
      accent: "#E8E8E8",
      glow: "#FFFFFF",
      particles: ["#A8A8A8", "#D0D0D0", "#E8E8E8"],
      effects: {
        trail: "dust",
        impact: "crack",
        glow: "none",
      },
    },

    // Healing/Support
    heal: {
      primary: "#36C777",
      secondary: "#6AD395",
      accent: "#9EDFB3",
      glow: "#C8F4D9",
      particles: ["#36C777", "#6AD395", "#9EDFB3"],
      effects: {
        trail: "sparkle",
        impact: "bloom",
        glow: "soft",
      },
    },

    // Default/Unknown
    default: {
      primary: "#FFB6D9",
      secondary: "#D4A5FF",
      accent: "#B4E7FF",
      glow: "#FFF5BA",
      particles: ["#FFB6D9", "#D4A5FF", "#B4E7FF"],
      effects: {
        trail: "glow",
        impact: "burst",
        glow: "soft",
      },
    },
    // Candy theme (pastel + neon rims)
    candy: {
      primary: "#FFB5E8", // cotton-pink
      secondary: "#B5F5FF", // taffy-blue
      accent: "#FFD56A", // lemon-cream
      glow: "#A78BFA", // grape rim-glow
      particles: ["#FFB5E8", "#B5F5FF", "#B9FBC0", "#A78BFA"],
      effects: {
        trail: "sprinkle",
        impact: "frosting",
        glow: "soft",
      },
    },
  };

  // ============= TAG-BASED COLOR MAPPING =============
  /**
   * Get color palette for skill based on its tags
   * @param {Array<string>} tags - Skill tags from skills-data.json
   * @returns {Object} Color palette object
   */
  function getPaletteForTags(tags = []) {
    if (!Array.isArray(tags) || tags.length === 0) {
      return ElementPalettes.default;
    }

    // Priority order for element detection
    const elementPriority = [
      "fire",
      "pyro",
      "water",
      "lightning",
      "electric",
      "shadow",
      "dark",
      "time",
      "temporal",
      "arcane",
      "magic",
      "heal",
      "physical",
    ];

    // Find first matching element in tags
    for (const element of elementPriority) {
      if (tags.includes(element)) {
        return ElementPalettes[element];
      }
    }

    // Special case: if has "heal" or "buff" tag
    if (tags.includes("heal") || tags.includes("buff")) {
      return ElementPalettes.heal;
    }

    // Default palette
    return ElementPalettes.default;
  }

  /**
   * Get primary color for a skill
   * @param {Object} skill - Skill object from skills-data.json
   * @returns {string} Hex color
   */
  function getColorForSkill(skill) {
    if (!skill) return ElementPalettes.default.primary;
    const palette = getPaletteForTags(skill.tags);
    return palette.primary;
  }

  /**
   * Get full color set for a skill
   * @param {Object} skill - Skill object from skills-data.json
   * @returns {Object} { primary, secondary, accent, glow, particles }
   */
  function getColorsForSkill(skill) {
    if (!skill) return ElementPalettes.default;
    return getPaletteForTags(skill.tags);
  }

  /**
   * Get particle colors for a skill
   * @param {Object} skill - Skill object from skills-data.json
   * @returns {Array<string>} Array of hex colors
   */
  function getParticleColors(skill) {
    const palette = getPaletteForTags(skill?.tags);
    return palette.particles;
  }

  /**
   * Get effect style for a skill
   * @param {Object} skill - Skill object from skills-data.json
   * @returns {Object} { trail, impact, glow }
   */
  function getEffectStyle(skill) {
    const palette = getPaletteForTags(skill?.tags);
    return palette.effects;
  }

  /**
   * Apply color logic to canvas context
   * Automatically sets appropriate colors based on skill element
   */
  function applyColorLogic(ctx, skill, effectType = "primary") {
    const colors = getColorsForSkill(skill);

    switch (effectType) {
      case "primary":
        ctx.fillStyle = colors.primary;
        ctx.strokeStyle = colors.primary;
        break;
      case "secondary":
        ctx.fillStyle = colors.secondary;
        ctx.strokeStyle = colors.secondary;
        break;
      case "accent":
        ctx.fillStyle = colors.accent;
        ctx.strokeStyle = colors.accent;
        break;
      case "glow":
        ctx.shadowColor = colors.glow;
        ctx.shadowBlur = 20;
        break;
    }
  }

  /**
   * Get gradient for skill element
   */
  function createElementGradient(ctx, x, y, radius, skill) {
    const colors = getColorsForSkill(skill);
    const gradient = ctx.createRadialGradient(x, y, 0, x, y, radius);
    gradient.addColorStop(0, colors.accent);
    gradient.addColorStop(0.5, colors.primary);
    gradient.addColorStop(1, colors.secondary + "44"); // Add transparency
    return gradient;
  }

  // ============= INTEGRATION WITH EXISTING SYSTEMS =============
  /**
   * Get color for VFX based on skill
   * Integrates with vfx-generator.js
   */
  function getVFXColor(skill, fallback = "#FF6AA8") {
    if (!skill || !skill.tags) return fallback;
    return getColorForSkill(skill);
  }

  /**
   * Get particle config for skill
   * Integrates with particle-system.js
   */
  function getParticleConfig(skill) {
    const colors = getColorsForSkill(skill);
    const effects = getEffectStyle(skill);

    return {
      colors: colors.particles,
      style: effects.trail,
      glow: effects.glow !== "none",
    };
  }

  // ============= EXPORTS =============
  window.ColorLogicPalette = {
    ElementPalettes,
    getPaletteForTags,
    getColorForSkill,
    getColorsForSkill,
    getParticleColors,
    getEffectStyle,
    applyColorLogic,
    createElementGradient,
    getVFXColor,
    getParticleConfig,
  };

  console.log("✅ Color Logic Palette System loaded");
  console.log(
    "   Supported elements:",
    Object.keys(ElementPalettes).join(", ")
  );
})();

</script>
  <!-- Inlined: src/assets/theme-manager.js -->
<script>
(function(){
  "use strict";

  // Minimal Theme manager: sets CSS vars, keeps state, emits 'theme:changed'
  const CANDY_PALETTE = {
    primary: '#FFB5E8', // cotton-pink
    blue: '#B5F5FF', // taffy-blue
    lemon: '#FFD56A', // lemon-cream
    mint: '#B9FBC0',
    grape: '#A78BFA',
    rim1: '#00E5FF',
    rim2: '#A78BFA',
    danger: '#FF3B3B'
  };

  const DEFAULT_PALETTE = {
    primary: '#FFB6D9',
    blue: '#B4E7FF',
    lemon: '#FFD56A',
    mint: '#C8F4D9',
    grape: '#9B59B6',
    rim1: '#00E5FF',
    rim2: '#A78BFA',
    danger: '#FF3B3B'
  };

  const listeners = [];
  let current = 'default';

  function applyCssVars(p) {
    try {
      const root = document.documentElement.style;
      root.setProperty('--candy-primary', p.primary);
      root.setProperty('--candy-blue', p.blue);
      root.setProperty('--candy-lemon', p.lemon);
      root.setProperty('--candy-mint', p.mint);
      root.setProperty('--candy-grape', p.grape);
      root.setProperty('--candy-rim1', p.rim1);
      root.setProperty('--candy-rim2', p.rim2);
      root.setProperty('--candy-danger', p.danger);
    } catch (e) { /* noop on server or missing DOM */ }
  }

  function emitChange(name, palette) {
    const ev = new CustomEvent('theme:changed', { detail: { theme: name, palette } });
    try { window.dispatchEvent(ev); } catch (_) {}
    for (const cb of listeners.slice()) try { cb(name, palette); } catch (_) {}
  }

  function setTheme(name) {
    name = (name || 'default').toString();
    current = name;
    if (name === 'candy') {
      applyCssVars(CANDY_PALETTE);
      emitChange('candy', CANDY_PALETTE);
    } else {
      // fallback to default
      applyCssVars(DEFAULT_PALETTE);
      emitChange('default', DEFAULT_PALETTE);
    }
    console.log('Theme.set ->', name);
  }

  window.Theme = {
    set: setTheme,
    get: () => current,
    onChange: (cb) => { if (typeof cb === 'function') listeners.push(cb); return () => { const i = listeners.indexOf(cb); if (i >= 0) listeners.splice(i,1); }; },
  };

  // apply default at load
  try { if (document && document.readyState === 'complete') { setTheme('default'); } else { window.addEventListener('load', () => setTheme('default')); } } catch (_) { setTheme('default'); }

  console.log('🔔 Theme manager loaded');
})();

</script>
  <!-- Inlined: src/assets/theme-ui-bridge.js -->
<script>
(function(){
  'use strict';

  function applyToDOM(detail) {
    try {
      // Update body background via existing applyStageTheme if available
      if (typeof window.applyStageTheme === 'function') {
        try { window.applyStageTheme(); } catch (_) {}
      }

      // Update common HUD elements colored by CSS variables
      const bg = getComputedStyle(document.documentElement).getPropertyValue('--candy-primary') || detail.palette?.primary;
      const rim = getComputedStyle(document.documentElement).getPropertyValue('--candy-rim1') || detail.palette?.rim1;

      // Apply to HUD pills
      const pills = document.querySelectorAll('.hud-pill, .hud-button');
      for (const p of pills) {
        try { p.style.background = `linear-gradient(135deg, ${bg || '#FFB5E8'}, ${detail.palette?.blue || '#B5F5FF'})`; p.style.borderColor = rim || '#00E5FF'; } catch (_) {}
      }

      // Update damage numbers color if drawing uses a global var
      try { if (window.DAMAGE_NUMBER_COLOR) window.DAMAGE_NUMBER_COLOR = detail.palette?.primary || '#FFB5E8'; } catch (_) {}

      // Request VFX system to re-evaluate any theme-specific tints
      try { window.VFX && window.VFX.setTheme && window.VFX.setTheme(detail.theme); } catch (_) {}

    } catch (e) {
      // Ignore DOM-less environments
    }
  }

  function onTheme(ev) {
    const d = ev?.detail || { theme: 'default', palette: {} };
    applyToDOM(d);
  }

  try {
    window.addEventListener('theme:changed', onTheme);
    // Also apply current theme immediately if available
    try { const cur = (window.Theme && window.Theme.get && window.Theme.get()) || 'default'; window.dispatchEvent(new CustomEvent('theme:changed',{detail:{theme:cur, palette:null}})); } catch(_){}
  } catch (_) {}

  console.log('Theme UI bridge loaded');
})();

</script>

  <!-- ===== GAME API & SKILLS SYSTEM ===== -->
  <!-- OLD skills data and clone system removed - now handled by simple_skills.js -->

  <!-- Mini Pet System -->

  <!-- Sprite Loader for Clone and Mini Pet sprites -->
  <!-- Inlined: src/rendering/sprite-loader.js -->
<script>
// src/sprite-loader.js - Simple sprite loader for miniClone and miniPet
// Loads and manages sprite assets for the clone and mini pet systems

(function () {
  "use strict";

  // Sprite loader configuration
  // NOTE: Sprites are now handled by CombatFX.attachProceduralSprite
  // This config is kept for backwards compatibility but is no longer used
  const SPRITE_CONFIG = {
    basePath: "./output/summons/",
    sprites: {
      // Old system - no longer used
      // Summons are now rendered procedurally via CombatFX
    },
  };

  // Global sprite loader
  window.SPRITE_LOADER = {
    loadedSprites: {},
    loadingPromises: {},

    // Load a sprite sheet
    async loadSprite(spriteName, animationName) {
      const key = `${spriteName}_${animationName}`;

      // Return cached sprite if already loaded
      if (this.loadedSprites[key]) {
        return this.loadedSprites[key];
      }

      // Return existing promise if already loading
      if (this.loadingPromises[key]) {
        return this.loadingPromises[key];
      }

      // Start loading
      this.loadingPromises[key] = this._loadSpriteInternal(
        spriteName,
        animationName
      );

      try {
        const sprite = await this.loadingPromises[key];
        this.loadedSprites[key] = sprite;
        delete this.loadingPromises[key];
        return sprite;
      } catch (error) {
        delete this.loadingPromises[key];
        console.warn(`Failed to load sprite ${key}:`, error);
        return this._createFallbackSprite(spriteName, animationName);
      }
    },

    // Internal sprite loading
    async _loadSpriteInternal(spriteName, animationName) {
      const spritePath = `${SPRITE_CONFIG.basePath}${spriteName}/${animationName}.png`;
      const jsonPath = `${SPRITE_CONFIG.basePath}${spriteName}/${animationName}.json`;

      // Load sprite data and image
      const [spriteData, image] = await Promise.all([
        this._loadJSON(jsonPath),
        this._loadImage(spritePath),
      ]);

      return {
        image: image,
        data: spriteData,
        frameWidth: spriteData.frameSize ? spriteData.frameSize[0] : 64,
        frameHeight: spriteData.frameSize ? spriteData.frameSize[1] : 64,
        frames: spriteData.frames || 1,
        fps: spriteData.fps || 8,
      };
    },

    // Load JSON data
    async _loadJSON(path) {
      try {
        const response = await fetch(path);
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        return await response.json();
      } catch (error) {
        console.warn(`Failed to load JSON ${path}:`, error);
        return { frameSize: [64, 64], frames: 1, fps: 8 };
      }
    },

    // Load image
    async _loadImage(path) {
      return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error(`Failed to load image: ${path}`));
        img.src = path;
      });
    },

    // Create fallback sprite for missing assets
    _createFallbackSprite(spriteName, animationName) {
      let canvas = null;
      if (window.CombatFX?.attachProceduralSprite) {
        try {
          const dummy = {
            id: spriteName === "miniClone" ? "clone" : "pet",
            x: 36,
            y: 48,
          };
          const element = spriteName === "miniClone" ? "water" : "light";
          const image = window.CombatFX.attachProceduralSprite(dummy, {
            element,
          });
          if (image) {
            canvas = image;
          }
        } catch (_e) {
          /* ignore */
        }
      }

      if (!canvas) {
        canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = 64;
        canvas.height = 64;
        const bodyColor = spriteName === "miniClone" ? "#5fb0ff" : "#86f085";
        const accent = spriteName === "miniClone" ? "#ffe166" : "#fff9c2";

        ctx.fillStyle = "rgba(0,0,0,0.25)";
        ctx.beginPath();
        ctx.ellipse(32, 56, 20, 6, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = bodyColor;
        ctx.beginPath();
        ctx.roundRect(24, 26, 24, 30, 10);
        ctx.fill();

        ctx.strokeStyle = bodyColor;
        ctx.lineWidth = 8;
        ctx.lineCap = "round";
        ctx.beginPath();
        ctx.moveTo(28, 40);
        ctx.lineTo(16, 52);
        ctx.moveTo(40, 40);
        ctx.lineTo(52, 52);
        ctx.moveTo(30, 54);
        ctx.lineTo(24, 66);
        ctx.moveTo(38, 54);
        ctx.lineTo(44, 66);
        ctx.stroke();

        ctx.fillStyle = accent;
        ctx.beginPath();
        ctx.ellipse(32, 24, 10, 9, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "#ffffff";
        ctx.beginPath();
        ctx.arc(28, 22, 4, 0, Math.PI * 2);
        ctx.arc(36, 22, 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "#222222";
        ctx.beginPath();
        ctx.arc(28, 22, 2, 0, Math.PI * 2);
        ctx.arc(36, 22, 2, 0, Math.PI * 2);
        ctx.fill();
      }

      return {
        image: canvas,
        data: { frameSize: [canvas.width, canvas.height], frames: 1, fps: 8 },
        frameWidth: canvas.width,
        frameHeight: canvas.height,
        frames: 1,
        fps: 8,
      };
    },

    // Get sprite (load if not cached)
    async getSprite(spriteName, animationName) {
      return await this.loadSprite(spriteName, animationName);
    },

    // Draw sprite frame
    drawSprite(
      ctx,
      spriteName,
      animationName,
      frame,
      x,
      y,
      scale = 1,
      flipX = false
    ) {
      const key = `${spriteName}_${animationName}`;
      const sprite = this.loadedSprites[key];

      if (!sprite) {
        // Draw fallback if sprite not loaded
        this._drawFallback(ctx, spriteName, x, y, scale);
        return;
      }

      const frameWidth = sprite.frameWidth;
      const frameHeight = sprite.frameHeight;
      const framesPerRow = Math.floor(sprite.image.width / frameWidth);

      const srcX = (frame % framesPerRow) * frameWidth;
      const srcY = Math.floor(frame / framesPerRow) * frameHeight;

      ctx.save();

      if (flipX) {
        ctx.scale(-1, 1);
        x = -x - frameWidth * scale;
      }

      ctx.drawImage(
        sprite.image,
        srcX,
        srcY,
        frameWidth,
        frameHeight,
        x,
        y,
        frameWidth * scale,
        frameHeight * scale
      );

      ctx.restore();
    },

    // Draw fallback sprite
    _drawFallback(ctx, spriteName, x, y, scale) {
      const size = 32 * scale;
      const dummy = {
        id: spriteName === "miniClone" ? "clone" : "pet",
        x: x + size / 2,
        y: y + size / 2,
      };
      let fallbackSprite = null;
      if (window.CombatFX?.attachProceduralSprite) {
        try {
          fallbackSprite = window.CombatFX.attachProceduralSprite(dummy, {
            element: spriteName === "miniClone" ? "water" : "light",
          });
        } catch (_e) {
          /* ignore */
        }
      }
      if (fallbackSprite) {
        ctx.drawImage(fallbackSprite, x, y, size, size);
        return;
      }

      const color = spriteName === "miniClone" ? "#5fb0ff" : "#86f085";
      ctx.fillStyle = color;
      ctx.beginPath();
      ctx.roundRect(x, y, size, size, 8 * scale);
      ctx.fill();

      ctx.fillStyle = "#ffffff";
      const eyeSize = 5 * scale;
      ctx.beginPath();
      ctx.arc(x + 14 * scale, y + 14 * scale, eyeSize, 0, Math.PI * 2);
      ctx.arc(x + 22 * scale, y + 14 * scale, eyeSize, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = "#222222";
      ctx.beginPath();
      ctx.arc(x + 14 * scale, y + 14 * scale, eyeSize * 0.5, 0, Math.PI * 2);
      ctx.arc(x + 22 * scale, y + 14 * scale, eyeSize * 0.5, 0, Math.PI * 2);
      ctx.fill();
    },

    // Preload all sprites
    async preloadAllSprites() {
      // NOTE: Sprites are now procedurally generated via CombatFX
      // No need to preload anything
      console.log("✅ Sprite loader ready (using procedural sprites)");
      return Promise.resolve();
    },
  };

  // Enhanced sprite rendering for clone and mini pet systems
  if (window.A1_CLONE_SYSTEM) {
    const originalDrawCloneSprite = window.A1_CLONE_SYSTEM.drawCloneSprite;
    window.A1_CLONE_SYSTEM.drawCloneSprite = function (ctx, clone, x, y) {
      const sprite = clone.sprite;
      const animationName = sprite.animation || "idle";
      const frame = sprite.frame || 0;
      const scale = 0.5; // Mini clones are smaller

      // Try to draw actual sprite
      if (window.SPRITE_LOADER.loadedSprites[`miniClone_${animationName}`]) {
        window.SPRITE_LOADER.drawSprite(
          ctx,
          "miniClone",
          animationName,
          frame,
          x - 16,
          y - 32,
          scale,
          sprite.facingLeft
        );
      } else {
        // Fall back to original drawing method
        if (originalDrawCloneSprite) {
          originalDrawCloneSprite.call(this, ctx, clone, x, y);
        }
      }
    };
  }

  if (window.MINI_PET_SYSTEM) {
    const originalDrawMiniPetSprite = window.MINI_PET_SYSTEM.drawMiniPetSprite;
    window.MINI_PET_SYSTEM.drawMiniPetSprite = function (ctx, pet, x, y) {
      const sprite = pet.sprite;
      const animationName = sprite.animation || "idle";
      const frame = sprite.frame || 0;
      const scale = 0.4; // Mini pets are even smaller

      // Try to draw actual sprite
      if (window.SPRITE_LOADER.loadedSprites[`miniPet_${animationName}`]) {
        window.SPRITE_LOADER.drawSprite(
          ctx,
          "miniPet",
          animationName,
          frame,
          x - 12,
          y - 16,
          scale,
          sprite.facingLeft
        );
      } else {
        // Fall back to original drawing method
        if (originalDrawMiniPetSprite) {
          originalDrawMiniPetSprite.call(this, ctx, pet, x, y);
        }
      }
    };
  }

  // Auto-preload sprites when page loads
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", () => {
      setTimeout(() => {
        window.SPRITE_LOADER.preloadAllSprites();
      }, 1000);
    });
  } else {
    setTimeout(() => {
      window.SPRITE_LOADER.preloadAllSprites();
    }, 1000);
  }

  console.log("✅ Sprite Loader initialized");
})();

</script>
  <!-- Inlined: src/rendering/summon-sprites.js -->
<script>
(function () {
  "use strict";

  if (window.SummonSprites) {
    return;
  }

  const TAU = Math.PI * 2;

  function degToRad(deg) {
    return (deg * Math.PI) / 180;
  }

  function resolveScale(multiplier) {
    return Number.isFinite(multiplier) && multiplier > 0 ? multiplier : 1;
  }

  function bouncePhase(seed = 0, time = 0, amplitude = 2) {
    const t = (time || performance.now?.() || Date.now()) * 0.006;
    return Math.sin(t + seed) * amplitude;
  }

  function renderShadowClone(ctx, summon, time, sizeMultiplier) {
    if (!ctx || !summon) return false;
    const scale = resolveScale(sizeMultiplier);
    const x = summon.x || 0;
    const y = summon.y || 0;
    const seed = (summon.id?.length || 0) * 0.7;
    const bounce = bouncePhase(seed, time, 3 * scale);
    const facing = summon.facingLeft ? -1 : 1;

    ctx.save();
    ctx.translate(x, y + bounce);
    ctx.scale(scale, scale);

    const robeGradient = ctx.createLinearGradient
      ? ctx.createLinearGradient(0, -24, 0, 8)
      : null;
    if (robeGradient) {
      robeGradient.addColorStop(0, summon.color || "#3b4c8c");
      robeGradient.addColorStop(1, "#1a1a2e");
    }

    ctx.fillStyle = robeGradient || summon.color || "#3b4c8c";
    ctx.fillRect(-10, -24, 20, 26);

    ctx.fillStyle = "#ffe8d6";
    ctx.beginPath();
    ctx.arc(0, -32, 8, 0, TAU);
    ctx.fill();

    ctx.fillStyle = "#0f0f21";
    ctx.fillRect(-3, -35, 2, 3);
    ctx.fillRect(1, -35, 2, 3);

    ctx.strokeStyle = summon.color || "#4fc3f7";
    ctx.lineWidth = 3;
    ctx.lineCap = "round";
    ctx.beginPath();
    ctx.moveTo(-12 * facing, -18);
    ctx.lineTo(-22 * facing, -6);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(12 * facing, -18);
    ctx.lineTo(22 * facing, -4);
    ctx.stroke();

    ctx.strokeStyle = "rgba(79, 195, 247, 0.45)";
    ctx.lineWidth = 6;
    ctx.beginPath();
    ctx.arc(0, -16, 18, degToRad(-70 * facing), degToRad(260 * facing));
    ctx.stroke();

    ctx.restore();

    const auraColor = summon.extra?.animeColor || summon.color;
    if (auraColor) {
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      ctx.globalAlpha = 0.35;
      ctx.strokeStyle = auraColor;
      ctx.lineWidth = 6 * scale;
      ctx.beginPath();
      ctx.arc(x, y + bounce - 4 * scale, 28 * scale, 0, TAU);
      ctx.stroke();
      ctx.restore();
    }

    if ((summon._swordT || 0) > 0) {
      const swing = Math.min(1, (summon._swordT || 0) / 260);
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      ctx.lineWidth = 5 * scale;
      ctx.strokeStyle = summon.color || "#ff4f81";
      ctx.beginPath();
      ctx.moveTo(x - 20 * facing * scale, y - 28 * scale);
      ctx.lineTo(x + 24 * facing * scale, y - 6 * scale - swing * 20 * scale);
      ctx.stroke();
      ctx.strokeStyle = "rgba(255, 255, 255, 0.8)";
      ctx.lineWidth = 3 * scale;
      ctx.beginPath();
      ctx.moveTo(x - 18 * facing * scale, y - 30 * scale);
      ctx.lineTo(x + 20 * facing * scale, y - 4 * scale - swing * 18 * scale);
      ctx.stroke();
      ctx.restore();
    }

    return true;
  }

  function renderRobotDrone(ctx, summon, time, sizeMultiplier) {
    if (!ctx || !summon) return false;
    const scale = resolveScale(sizeMultiplier);
    const x = summon.x || 0;
    const y = summon.y || 0;
    const seed = (summon.id?.length || 0) * 0.45;
    const bob = bouncePhase(seed, time, 4 * scale);

    ctx.save();
    ctx.translate(x, y + bob - 8 * scale);
    ctx.scale(scale, scale);

    const bodyGradient = ctx.createLinearGradient
      ? ctx.createLinearGradient(-12, -6, 12, 16)
      : null;
    if (bodyGradient) {
      bodyGradient.addColorStop(0, summon.color || "#46a1ff");
      bodyGradient.addColorStop(1, "#2346c9");
    }

    ctx.fillStyle = bodyGradient || summon.color || "#46a1ff";
    ctx.beginPath();
    ctx.moveTo(-14, -4);
    ctx.quadraticCurveTo(-14, -10, -8, -10);
    ctx.lineTo(8, -10);
    ctx.quadraticCurveTo(14, -10, 14, -4);
    ctx.lineTo(14, 10);
    ctx.quadraticCurveTo(14, 16, 8, 16);
    ctx.lineTo(-8, 16);
    ctx.quadraticCurveTo(-14, 16, -14, 10);
    ctx.closePath();
    ctx.fill();

    ctx.fillStyle = "#d0f4ff";
    ctx.beginPath();
    ctx.arc(0, -2, 6, 0, TAU);
    ctx.fill();

    ctx.strokeStyle = "rgba(180, 220, 255, 0.85)";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(-20, -2);
    ctx.lineTo(-32, -12);
    ctx.moveTo(20, -2);
    ctx.lineTo(32, -12);
    ctx.stroke();

    ctx.strokeStyle = "rgba(130, 200, 255, 0.35)";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.ellipse(0, 18, 22, 6, 0, 0, TAU);
    ctx.stroke();

    ctx.restore();

    const auraColor = summon.extra?.animeColor || summon.color;
    if (auraColor) {
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      ctx.globalAlpha = 0.45;
      ctx.strokeStyle = auraColor;
      ctx.lineWidth = 5 * scale;
      ctx.beginPath();
      ctx.arc(x, y + bob - 8 * scale, 24 * scale, 0, TAU);
      ctx.stroke();
      ctx.restore();
    }

    if ((summon._volleyFlash || 0) > 0) {
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      ctx.fillStyle = auraColor || "#74b9ff";
      ctx.globalAlpha = 0.6;
      ctx.beginPath();
      ctx.arc(x, y + bob - 18 * scale, 10 * scale, 0, TAU);
      ctx.fill();
      ctx.restore();
    }

    return true;
  }

  function renderTigerPet(ctx, summon, time, sizeMultiplier) {
    if (!ctx || !summon) return false;
    const scale = resolveScale(sizeMultiplier);
    const x = summon.x || 0;
    const y = summon.y || 0;
    const seed = (summon.id?.length || 0) * 0.55;
    const bounce = bouncePhase(seed, time, 2.5 * scale);

    ctx.save();
    ctx.translate(x, y + bounce - 6 * scale);
    ctx.scale(scale, scale);

    const baseColor = summon.color || "#ffb74d";
    const bodyGradient = ctx.createLinearGradient
      ? ctx.createLinearGradient(-14, 6, 14, 26)
      : null;
    if (bodyGradient) {
      bodyGradient.addColorStop(0, baseColor);
      bodyGradient.addColorStop(1, "#f57c00");
    }

    ctx.fillStyle = bodyGradient || baseColor;
    ctx.beginPath();
    ctx.ellipse(0, 10, 16, 12, 0, 0, TAU);
    ctx.fill();

    ctx.fillStyle = "#ffe0b2";
    ctx.beginPath();
    ctx.ellipse(0, -2, 12, 10, 0, 0, TAU);
    ctx.fill();

    ctx.fillStyle = "#3e2723";
    ctx.beginPath();
    ctx.arc(-4, -4, 1.4, 0, TAU);
    ctx.arc(4, -4, 1.4, 0, TAU);
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(-8, 4);
    ctx.lineTo(-2, 12);
    ctx.moveTo(8, 4);
    ctx.lineTo(2, 12);
    ctx.strokeStyle = "rgba(62, 39, 35, 0.45)";
    ctx.lineWidth = 2;
    ctx.stroke();

    ctx.strokeStyle = "rgba(255, 255, 255, 0.65)";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(14, 6);
    ctx.lineTo(24, -6);
    ctx.lineTo(26, 10);
    ctx.stroke();

    ctx.restore();

    const auraColor = summon.extra?.animeColor || summon.color;
    if (auraColor) {
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      ctx.globalAlpha = 0.4;
      ctx.strokeStyle = auraColor;
      ctx.lineWidth = 4 * scale;
      ctx.beginPath();
      ctx.arc(x, y + bounce - 10 * scale, 22 * scale, 0, TAU);
      ctx.stroke();
      ctx.restore();
    }

    if ((summon._swordT || 0) > 0) {
      const claw = Math.min(1, (summon._swordT || 0) / 280);
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      ctx.strokeStyle = auraColor || "#ffd56a";
      ctx.lineWidth = 5 * scale;
      ctx.beginPath();
      ctx.arc(x, y + bounce - 2 * scale, 24 * scale, -claw * Math.PI, 0);
      ctx.stroke();
      ctx.restore();
    }

    return true;
  }

  window.SummonSprites = {
    renderShadowClone,
    renderRobotDrone,
    renderTigerPet,
  };

  console.log("✅ Summon sprite renderer initialized");
})();

</script>

  <!-- OLD clone integration removed - summons now in simple_skills.js -->

  <!-- Auto helper - simplified automation -->
  <!-- Inlined: src/utils/auto-helper.js -->
<script>
// src/auto-helper.js
// Simplified automation helpers extracted from scroll_system.html

(function () {
  "use strict";

  /* ===== Helper Functions ===== */

  function notify(msg, color = "#6aa8ff") {
    if (window.notify) {
      window.notify(msg, color);
    } else {
      console.log("[Auto]", msg);
    }
  }

  function ensureElementalState() {
    const meta = window.CORE_METADATA?.elemental;
    const cycle =
      Array.isArray(meta?.cycle) && meta.cycle.length > 0
        ? meta.cycle
        : ["fire", "ice", "lightning"];
    if (!window._coreElementState) {
      window._coreElementState = {
        cycle: cycle.slice(),
        index: -1,
        active: cycle[0] || null,
        lastSwap: 0,
        lastHeroId: null,
        lastMessage: 0,
      };
    } else {
      if (
        !Array.isArray(window._coreElementState.cycle) ||
        window._coreElementState.cycle.length === 0
      ) {
        window._coreElementState.cycle = cycle.slice();
      }
      if (
        !window._coreElementState.cycle.includes(
          window._coreElementState.active
        )
      ) {
        window._coreElementState.active =
          window._coreElementState.cycle[0] || null;
      }
    }
    if (
      window.CORE_RUNTIME_STATE?.elemental &&
      window._coreElementState.active
    ) {
      const runtime = window.CORE_RUNTIME_STATE.elemental;
      runtime.activeElement = window._coreElementState.active;
      runtime.cycleIndex =
        typeof window._coreElementState.index === "number" &&
        window._coreElementState.index >= 0
          ? window._coreElementState.index
          : 0;
    }
    return window._coreElementState;
  }

  function ensureGadgetState() {
    const meta = window.CORE_METADATA?.gadget;
    const defaults = meta?.overclock || {
      duration: 4000,
      atkPerStack: 0.08,
      critPerStack: 6,
      speedPerStack: 0.05,
      maxStacks: 3,
    };
    if (!window._coreGadgetState) {
      window._coreGadgetState = {
        overclockStacks: 0,
        overclockExpires: 0,
        lastTrigger: 0,
        lastHeroId: null,
        params: { ...defaults },
      };
    }
    if (!window._coreGadgetState.params) {
      window._coreGadgetState.params = { ...defaults };
    }
    return window._coreGadgetState;
  }

  function ensureBeastState() {
    const meta = window.CORE_METADATA?.beast;
    const petDefaults = meta?.petBonuses || {
      power: 1.25,
      cooldown: 0.85,
      hp: 1.5,
    };
    const howlDefaults = meta?.howl || {
      duration: 6000,
      cooldown: 14000,
      atkBonus: 0.18,
      hasteBonus: 0.08,
    };
    if (!window._coreBeastState) {
      window._coreBeastState = {
        howlExpires: 0,
        howlReadyAt: 0,
        lastHowl: 0,
        params: {
          petPower: petDefaults.power,
          petCooldown: petDefaults.cooldown,
          petHp: petDefaults.hp,
          duration: howlDefaults.duration,
          cooldown: howlDefaults.cooldown,
          atkBonus: howlDefaults.atkBonus,
          hasteBonus: howlDefaults.hasteBonus,
        },
      };
    }
    if (!window._coreBeastState.params) {
      window._coreBeastState.params = {
        petPower: petDefaults.power,
        petCooldown: petDefaults.cooldown,
        petHp: petDefaults.hp,
        duration: howlDefaults.duration,
        cooldown: howlDefaults.cooldown,
        atkBonus: howlDefaults.atkBonus,
        hasteBonus: howlDefaults.hasteBonus,
      };
    }
    return window._coreBeastState;
  }

  function emitCoreSynergy(coreId, tags) {
    if (!coreId || !Array.isArray(tags) || !tags.length) return;
    const rules = window.SYNERGY_MATRIX?.[coreId];
    if (!rules) return;
    if (!window._coreSynergyStamp) window._coreSynergyStamp = {};
    const now =
      typeof performance !== "undefined" && performance.now
        ? performance.now()
        : Date.now();
    tags.forEach((tag) => {
      const synergy = rules[tag];
      if (!synergy) return;
      const key = `${coreId}:${tag}`;
      if (
        window._coreSynergyStamp[key] &&
        now - window._coreSynergyStamp[key] < 1200
      )
        return;
      window._coreSynergyStamp[key] = now;
      notify(synergy.message, "#ffd166");
    });
  }

  function applyElementalModifiers(skill, basePower, skillId, tagAccumulator) {
    if (window.EQUIPPED_CORE !== "elemental") return basePower;
    const state = ensureElementalState();
    const cycle = state.cycle || [];
    if (!cycle.length) return basePower;
    if (!state.active) {
      state.active = cycle[0] || null;
    }
    const element = state.active;
    const tags = skill.tags || [];
    const now =
      typeof performance !== "undefined" && performance.now
        ? performance.now()
        : Date.now();
    let modifiedPower = basePower;
    let procEffect = null;

    if (element === "fire") {
      if (
        tags.some((tag) => ["aoe", "explosion", "burn", "fire"].includes(tag))
      ) {
        modifiedPower *= 1.18;
        procEffect = "burn";
      }
    } else if (element === "ice") {
      if (
        tags.some((tag) =>
          ["water", "cc", "control", "slow", "support"].includes(tag)
        )
      ) {
        modifiedPower *= 1.12;
        procEffect = "slow";
      }
      tagAccumulator.add("water");
    } else if (element === "lightning") {
      if (
        tags.some((tag) => ["beam", "lightning", "dps", "chain"].includes(tag))
      ) {
        modifiedPower *= 1.15;
        procEffect = "shock";
      }
      tagAccumulator.add("lightning");
    }

    state.lastEvaluated = now;
    state.lastSkill = skillId;
    if (procEffect) {
      state.lastProc = { element, effect: procEffect, skillId, time: now };
    }
    if (window.CORE_RUNTIME_STATE?.elemental) {
      const runtime = window.CORE_RUNTIME_STATE.elemental;
      runtime.cycleIndex =
        typeof state.index === "number" && state.index >= 0 ? state.index : 0;
      runtime.activeElement = element;
    }

    return modifiedPower;
  }

  function applyGadgetModifiers(skill, basePower, tagAccumulator) {
    if (window.EQUIPPED_CORE !== "gadget") return basePower;
    const state = ensureGadgetState();
    const params = state.params ||
      window.CORE_METADATA?.gadget?.overclock || {
        duration: 4000,
        atkPerStack: 0.08,
        maxStacks: 3,
      };
    const now =
      typeof performance !== "undefined" && performance.now
        ? performance.now()
        : Date.now();
    let stacks = state.overclockStacks || 0;
    const runtime = window.CORE_RUNTIME_STATE?.gadget;
    if (runtime) {
      const expires = runtime.overclockExpires || 0;
      if (expires > 0 && now > expires) {
        runtime.stacks = 0;
      }
      stacks = Math.max(stacks, runtime.stacks || 0);
    }
    const expires = state.overclockExpires || 0;
    if (expires > 0 && now > expires) {
      state.overclockStacks = 0;
      stacks = runtime ? Math.max(0, runtime.stacks || 0) : 0;
    }
    if (stacks <= 0) return basePower;
    const atkPerStack = params.atkPerStack || 0.08;
    const multiplier = 1 + stacks * atkPerStack;
    if (tagAccumulator) tagAccumulator.add("tech");
    return basePower * multiplier;
  }

  function applyBeastModifiers(skill, basePower, tagAccumulator) {
    if (window.EQUIPPED_CORE !== "beast") return basePower;
    const tags = skill.tags || [];
    const hasPetTag = tags.some((tag) =>
      ["pet", "summon", "companion"].includes(tag)
    );
    if (!hasPetTag) return basePower;
    const state = ensureBeastState();
    const params = state.params || {};
    if (tagAccumulator) tagAccumulator.add("pet");
    const multiplier = Number(params.petPower) || 1.25;
    return basePower * multiplier;
  }

  function effCd(skillId) {
    const skill = window.SKILLS_LIB?.[skillId];
    if (!skill) return 6;
    let cd = skill.cd || 6;
    // Apply core modifiers
    if (window.EQUIPPED_CORE === "gadget") cd *= 0.88; // -12%
    if (
      window.EQUIPPED_CORE === "beast" &&
      skill.tags?.some((tag) => ["pet", "summon", "companion"].includes(tag))
    ) {
      const state = ensureBeastState();
      const params = state.params || {};
      const cdMul = Number(params.petCooldown) || 0.85;
      cd *= cdMul;
    }
    return Math.max(0.5, cd);
  }

  function skillPower(skillId) {
    const skill = window.SKILLS_LIB?.[skillId];
    if (!skill) return 0;
    const inv = window.SKILLS_INV?.[skillId];
    const lvl = inv?.lvl || 1;
    let power = (skill.power || 100) * (1 + 0.1 * (lvl - 1));
    const synergyTags = new Set(skill.tags || []);

    if (window.EQUIPPED_CORE === "elemental") {
      power = applyElementalModifiers(skill, power, skillId, synergyTags);
    }
    if (window.EQUIPPED_CORE === "gadget") {
      power = applyGadgetModifiers(skill, power, synergyTags);
    }
    if (window.EQUIPPED_CORE === "beast") {
      power = applyBeastModifiers(skill, power, synergyTags);
    }

    // Apply core bonuses
    if (
      window.EQUIPPED_CORE === "elemental" &&
      skill.tags?.some((t) => t === "aoe" || t === "beam")
    ) {
      power *= 1.15;
    }
    if (window.EQUIPPED_CORE === "dark") {
      power *= 1.35; // True damage bonus
    }
    if (
      window.EQUIPPED_CORE === "light" &&
      skill.tags?.some((t) => t === "heal" || t === "buff")
    ) {
      power *= 1.15;
    }

    emitCoreSynergy(window.EQUIPPED_CORE, Array.from(synergyTags));

    return power;
  }

  function skillDPS(skillId) {
    return skillPower(skillId) / Math.max(0.1, effCd(skillId));
  }

  function setSlot(heroId, slot, skillId) {
    if (typeof window.setHeroSlot === "function") {
      window.setHeroSlot(heroId, slot, skillId);
    } else if (window.HERO_SLOTS && window.HERO_SLOTS[heroId]) {
      window.HERO_SLOTS[heroId][slot] = skillId;
    }
  }

  /* ===== Auto Equip Best ===== */
  window.autoEquipBest = function () {
    if (!window.SKILLS_LIB || !window.HERO_SLOTS) {
      notify("Skills system not loaded", "#ff6b6b");
      return;
    }

    const heroes = ["A1", "UNIQUE", "MISSY"];
    let equipped = 0;

    // Enhanced scoring function for better auto-equip decisions
    const scoreItem = (item) => {
      if (!item) return -1;
      const rarityScore =
        { SSS: 1000, SS: 800, S: 600, A: 400, B: 200, C: 100 }[
          item.rarity || "C"
        ] || 0;
      const statScore =
        (item.atk || 0) * 1.5 + (item.def || 0) + (item.hp || 0) / 10;
      const levelScore = (item.level || 1) * 10;
      return rarityScore + statScore + levelScore;
    };

    const skillList = Object.values(window.SKILLS_LIB || {});
    const powerOf = (id) => {
      const s = window.SKILLS_LIB?.[id];
      if (!s) return 0;
      const mult = s.multiplier || 1;
      const base = s.power || 0;
      return base * mult;
    };
    const effCd = (id) =>
      Math.max(
        0.1,
        window.SKILLS_LIB?.[id]?.cooldown || window.SKILLS_LIB?.[id]?.cd || 1
      );
    const dpsOf = (id) => powerOf(id) / effCd(id);

    const setSlot = (hero, slot, skillId) => {
      if (!window.HERO_SLOTS[hero]) window.HERO_SLOTS[hero] = {};
      if (!window.HERO_SLOTS[hero][slot]) {
        if (typeof window.setHeroSlot === "function")
          window.setHeroSlot(hero, slot, skillId);
        window.HERO_SLOTS[hero][slot] = skillId;
        equipped++;
      }
    };

    heroes.forEach((heroId) => {
      const slots =
        window.HERO_SLOTS[heroId] || (window.HERO_SLOTS[heroId] = {});
      const heroSkills = skillList
        .filter((s) => s.hero === heroId && (!s.kind || s.kind === "skill"))
        .sort((a, b) => dpsOf(b.id) - dpsOf(a.id));

      // Unique: force Drone + Harmonic Field in S1 if available
      if (heroId === "UNIQUE" && !slots[1]) {
        const drone = window.SKILLS_LIB["u_s2"];
        if (drone) setSlot(heroId, 1, "u_s2");
      }

      // Fill S1-S3 with best remaining
      for (let i = 1, pickIdx = 0; i <= 3; i++) {
        if (slots[i]) continue;
        // Skip u_s2 if we already set it for UNIQUE
        while (
          heroSkills[pickIdx] &&
          heroSkills[pickIdx].id === "u_s2" &&
          heroId === "UNIQUE"
        )
          pickIdx++;
        if (heroSkills[pickIdx]) {
          setSlot(heroId, i, heroSkills[pickIdx].id);
          pickIdx++;
        }
      }

      // Best weapon to slot 4
      if (!slots[4]) {
        const weapons = skillList
          .filter((s) => s.kind === "weapon")
          .sort((a, b) => powerOf(b.id) - powerOf(a.id));
        if (weapons[0]) setSlot(heroId, 4, weapons[0].id);
      }
      // Best pet to slot 5
      if (!slots[5]) {
        const pets = skillList
          .filter((s) => s.kind === "pet")
          .sort((a, b) => powerOf(b.id) - powerOf(a.id));
        if (pets[0]) setSlot(heroId, 5, pets[0].id);
      }
      // Best vehicle to slot 6
      if (!slots[6]) {
        const vehs = skillList
          .filter((s) => s.kind === "veh")
          .sort((a, b) => powerOf(b.id) - powerOf(a.id));
        if (vehs[0]) setSlot(heroId, 6, vehs[0].id);
      }
    });

    // Equip best core if none equipped (skip plain 'S' rank cores)
    if (!window.EQUIPPED_CORE) {
      const meta = (window.Game && window.Game.coreSystem) || {};
      const families = Object.keys(window.CORE_DATA || {});
      const rankToIdx = (r) =>
        ["SSS", "SS", "S", "A", "B", "C"].indexOf((r || "A").toUpperCase());
      const pref = [
        "dark",
        "crystal",
        "beast",
        "gadget",
        "elemental",
        "gold",
        "light",
        "chaos",
      ];
      const prefIdx = (id) => {
        const k = (id || "").toLowerCase();
        const i = pref.indexOf(k);
        return i < 0 ? 999 : i;
      };
      const candidates = families
        .map((id) => ({
          id,
          rank: (meta[id.toUpperCase()]?.rank || "A").toUpperCase(),
        }))
        .filter((c) => window.CORE_INV?.[c.id]?.count > 0)
        .filter((c) => c.rank !== "S") // do not equip S rank cores
        .sort((a, b) => {
          const dr = rankToIdx(a.rank) - rankToIdx(b.rank);
          return dr !== 0 ? dr : prefIdx(a.id) - prefIdx(b.id);
        });
      if (candidates[0]) window.EQUIPPED_CORE = candidates[0].id;
    }

    if (equipped > 0) {
      notify(`Auto Equip: Equipped ${equipped} items`, "#4ecdc4");
      if (window.renderSkillsUI) window.renderSkillsUI();
    } else {
      notify("All slots already filled", "#ffaa00");
    }
  };

  /* ===== Auto Upgrade All ===== */
  window.autoUpgradeAll = function () {
    if (!window.SKILLS_INV || !window.HERO_SLOTS) {
      notify("Skills system not loaded", "#ff6b6b");
      return;
    }

    const st = window.st || {};
    if (!st.gold || st.gold < 100) {
      notify("Not enough gold to upgrade", "#ff6b6b");
      return;
    }

    let upgraded = 0;
    let goldSpent = 0;

    // Upgrade all equipped skills
    Object.values(window.HERO_SLOTS).forEach((slots) => {
      for (let i = 1; i <= 6; i++) {
        const skillId = slots[i];
        if (!skillId) continue;

        const inv = window.SKILLS_INV[skillId];
        if (!inv) continue;

        const cost = 100 * (inv.lvl + 1);
        if (st.gold >= cost) {
          inv.lvl++;
          st.gold -= cost;
          goldSpent += cost;
          upgraded++;
        }
      }
    });

    // Upgrade equipped core
    if (window.EQUIPPED_CORE && window.CORE_INV?.[window.EQUIPPED_CORE]) {
      const coreInv = window.CORE_INV[window.EQUIPPED_CORE];
      const cost = 500 * (coreInv.lvl + 1);
      if (st.gold >= cost) {
        coreInv.lvl++;
        st.gold -= cost;
        goldSpent += cost;
        upgraded++;
      }
    }

    if (upgraded > 0) {
      notify(
        `Upgraded ${upgraded} items for ${goldSpent.toLocaleString()}g`,
        "#4ecdc4"
      );
      if (window.updateCurrencies) window.updateCurrencies();
      if (window.renderSkillsUI) window.renderSkillsUI();
    } else {
      notify("No upgrades available or not enough gold", "#ffaa00");
    }
  };

  /* ===== Auto Fuse All ===== */
  window.autoFuseAll = function () {
    if (!window.SKILLS_INV) {
      notify("Skills system not loaded", "#ff6b6b");
      return;
    }

    let fused = 0;

    Object.values(window.SKILLS_INV).forEach((inv) => {
      // Need at least 2 copies to fuse
      while (inv.count >= 2) {
        inv.count -= 2;
        inv.lvl += 2;
        fused++;
      }
    });

    if (fused > 0) {
      notify(`Fused ${fused} skills (+2 levels each)`, "#4ecdc4");
      if (window.renderSkillsUI) window.renderSkillsUI();
    } else {
      notify("No skills available to fuse (need 2+ copies)", "#ffaa00");
    }
  };

  /* ===== Auto Equip All Equipment ===== */
  window.autoEquipAll = function () {
    const st = window.st || {};
    if (!st.inv || !Array.isArray(st.inv)) {
      notify("Inventory not found", "#ff6b6b");
      return;
    }

    const scoreItem = (item) => {
      if (!item) return -1;
      const rarityScore =
        { SSS: 1000, SS: 800, S: 600, A: 400, B: 200, C: 100 }[
          item.rarity || "C"
        ] || 0;
      const statScore =
        (item.atk || 0) * 1.5 + (item.def || 0) + (item.hp || 0) / 10;
      const levelScore = (item.level || 1) * 10;
      return rarityScore + statScore + levelScore;
    };

    const slots = [
      "weapon",
      "weapon2",
      "armor",
      "acc1",
      "acc2",
      "pet",
      "vehicle",
    ];
    const equipped = st.equippedGear || (st.equippedGear = {});
    let equippedCount = 0;

    slots.forEach((slot) => {
      const candidates = st.inv.filter((item) => {
        const itemSlot = item.slot || item.type;
        // Handle slot compatibility
        if (slot === "weapon2")
          return itemSlot === "weapon" || itemSlot === "weapon2";
        if (slot === "acc1" || slot === "acc2")
          return itemSlot.startsWith("acc");
        return itemSlot === slot;
      });

      if (candidates.length === 0) return;

      // Find best candidate
      const best = candidates.reduce((a, b) =>
        scoreItem(a) > scoreItem(b) ? a : b
      );
      const current = equipped[slot];

      if (scoreItem(best) > scoreItem(current)) {
        // Swap items
        if (current) st.inv.push(current);
        equipped[slot] = best;
        st.inv = st.inv.filter((it) => it !== best);
        equippedCount++;
      }
    });

    // Recalculate stats
    if (window.Game && window.Game.statsManager) {
      window.Game.statsManager.recalculateStats(st.players[st.leader || 0]);
    }

    if (equippedCount > 0) {
      notify(`Auto-equipped ${equippedCount} items!`, "#4CAF50");
    } else {
      notify("All slots have best gear", "#2196F3");
    }
  };

  console.log(
    "✅ Auto helper loaded (autoEquipBest, autoEquipAll, autoUpgradeAll, autoFuseAll)"
  );
})();

// Post-load assist: pre-equip skills and tidy bag
(function () {
  try {
    document.addEventListener("DOMContentLoaded", () => {
      try {
        if (typeof window.autoEquipBest === "function") window.autoEquipBest();
      } catch (_) {}
      try {
        if (
          window.Game &&
          typeof window.Game.autoEquipBestGear === "function"
        ) {
          window.Game.autoEquipBestGear(true);
        }
      } catch (_) {}
      try {
        if (typeof window.autoOpenAll === "function") window.autoOpenAll();
      } catch (_) {}
    });
  } catch (_) {}
})();

</script>
  <!-- Inlined: src/ui/platform-interactables.js -->
<script>
// src/platform-interactables.js
// Manages NPCs, player housing, and other interactive elements in the game world.

(function () {
  "use strict";

  if (window.PlatformInteractables) return;

  // ============= Hireable NPC Data =============
  const NPC_ROSTER = {
    // C-Rank
    npc_grunt: {
      name: "Grunt",
      rank: "C",
      cost: 10000,
      skills: ["Power Strike", "Shield Bash", "War Cry"],
    },
    npc_scout: {
      name: "Scout",
      rank: "C",
      cost: 12000,
      skills: ["Quick Shot", "Poison Dart", "Evasion"],
    },
    // B-Rank
    npc_knight: {
      name: "Knight",
      rank: "B",
      cost: 50000,
      skills: ["Holy Blade", "Divine Shield", "Healing Light"],
    },
    npc_ranger: {
      name: "Ranger",
      rank: "B",
      cost: 60000,
      skills: ["Triple Shot", "Freezing Trap", "Beast Companion"],
    },
    // A-Rank
    npc_sorcerer: {
      name: "Sorcerer",
      rank: "A",
      cost: 250000,
      skills: ["Meteor Swarm", "Chain Lightning", "Arcane Barrier"],
    },
    npc_assassin: {
      name: "Assassin",
      rank: "A",
      cost: 300000,
      skills: ["Shadow Strike", "Smoke Bomb", "Execute"],
    },
    // S-Rank
    npc_archmage: {
      name: "Archmage",
      rank: "S",
      cost: 1000000,
      skills: ["Time Stop", "Summon Elemental", "Gravity Well"],
    },
    npc_blademaster: {
      name: "Blademaster",
      rank: "S",
      cost: 1200000,
      skills: ["Omnislash", "Mirror Image", "Blade Dance"],
    },
    npc_celestial: {
      name: "Celestial",
      rank: "S",
      cost: 2000000,
      skills: ["Starfall", "Cosmic Guardian", "Celestial Blessing"],
    },
    npc_voidwalker: {
      name: "Voidwalker",
      rank: "S",
      cost: 2500000,
      skills: ["Void Rift", "Entropy Blast", "Shadow Clone"],
    },
  };

  const PARTY_CAP = 10;

  /**
   * Hires an NPC, adds them to the player's party if there's room and enough gold.
   * @param {string} npcId - The ID of the NPC to hire (e.g., "npc_grunt").
   */
  // Accept gold OR tickets (1 ticket per 1000 gold, rounded up)
  function hireNpc(npcId, useTickets = false) {
    const npcData = NPC_ROSTER[npcId];
    if (!npcData) {
      notify("This mercenary is not available.", "#ff6b6b");
      return;
    }

    // Ensure party array exists
    st.party = st.party || [];
    const currentPartySize =
      st.players.length +
      st.party.filter((member) => member.type === "npc").length;

    if (currentPartySize >= PARTY_CAP) {
      notify("Your party is full!", "#ffaa00");
      return;
    }

    const goldCost = npcData.cost | 0;
    const ticketCost = Math.ceil(goldCost / 1000);
    if (useTickets) {
      if ((st.tickets | 0) < ticketCost) {
        notify(`You need ${ticketCost} tickets to hire ${npcData.name}.`, "#ff6b6b");
        return;
      }
      st.tickets -= ticketCost;
    } else {
      if ((st.gold | 0) < goldCost) {
        notify(`You need ${goldCost.toLocaleString()} gold to hire ${npcData.name}.`, "#ff6b6b");
        return;
      }
      st.gold -= goldCost;
    }
    try { updateCurrencies(); } catch (_) { }

    const newNpc = {
      ...npcData,
      id: `npc_${Date.now()}`,
      type: "npc",
      hp: 1000 * (["C", "B", "A", "S"].indexOf(npcData.rank) + 1), // Example stats
      dmg: 100 * (["C", "B", "A", "S"].indexOf(npcData.rank) + 1),
    };

    st.party.push(newNpc);
    notify(
      `${npcData.name} (${npcData.rank}-Rank) has joined your party!`,
      "#4ecdc4"
    );
  }

  function enterBuilding(buildingType) {
    if (st.insideBuilding === buildingType) return; // Already inside

    st.insideBuilding = buildingType; // Enter the building (e.g., 'tavern', 'arcade')
    notify(`Entering the ${buildingType}.`, "#6aa8ff");
  }

  function exitBuilding() {
    if (!st.insideBuilding) return; // Not inside a building

    notify("Leaving the building.", "#ffaa00");
    st.insideBuilding = null; // Exit the building
  }

  window.PlatformInteractables = {
    NPC_ROSTER,
    hireNpc,
    enterBuilding,
    exitBuilding,
  };

  console.log("🤝 Platform Interactables module loaded.");
})();

</script>
  <!-- Vehicles placeholder system -->
  <!-- Inlined: src/systems/vehicle-system.js -->
<script>
(function defineVehicleSystem(){
  'use strict';

  if (window.VehicleSystem) return;

  const SYS = {
    list: [],
    spawn(owner, type = 'bike') {
      const st = window.st; if (!st || !owner) return null;
      const spec = {
        bike: { speed: 1.4, color: '#9fd7ff', w: 44, h: 20 },
        gyro: { speed: 1.1, color: '#ffd46e', w: 52, h: 26 },
        tank: { speed: 0.8, color: '#ff8c6a', w: 60, h: 28 },
      }[String(type).toLowerCase()] || { speed: 1, color: '#9fd7ff', w: 44, h: 20 };
      const veh = {
        id: `veh_${type}_${Date.now()}_${Math.random()}`,
        type,
        x: owner.x + 16,
        y: owner.y,
        vx: 0, vy: 0,
        facingLeft: !!owner.facingLeft,
        speedMul: spec.speed,
        color: spec.color,
        w: spec.w, h: spec.h,
        life: 60000, // 60s placeholder lifetime
        ownerId: owner.id
      };
      this.list.push(veh);
      try { window.notify && window.notify(`Vehicle: ${type} ready`, '#9fd7ff'); } catch(_){}
      return veh;
    },
    despawn(index) {
      if (index < 0 || index >= this.list.length) return; this.list.splice(index,1);
    },
    update(dt) {
      const st = window.st; if (!st) return;
      const dtMs = dt * 1000;
      for (let i=this.list.length-1;i>=0;i--) {
        const v = this.list[i]; v.life -= dtMs; if (v.life <= 0) { this.despawn(i); continue; }
        // Simple follow the owner and add tiny jitter as placeholder art
        const owner = (st.players||[]).find(p=>p?.id===v.ownerId); if (!owner) { this.despawn(i); continue; }
        const dx = (owner.x + (owner.facingLeft? -18:18)) - v.x; const dy = owner.y - v.y;
        v.vx = dx * 6 * dt; v.vy = dy * 6 * dt; v.x += v.vx; v.y += v.vy; v.facingLeft = owner.facingLeft;
        // Placeholder engine puff
        try { if (window.VFX) window.VFX.play('afterimage', { x: v.x - (v.facingLeft?-10:10), y: v.y - 10, hue:v.color }); } catch(_){ }
      }
    },
    // Quick draw onto the main canvas if available; otherwise no-op
    draw(ctx) {
      if (!ctx) return;
      ctx.save();
      for (const v of this.list) {
        ctx.fillStyle = v.color;
        ctx.globalAlpha = 0.85;
        ctx.fillRect(Math.round(v.x - v.w/2), Math.round(v.y - v.h - 12), v.w, v.h);
        ctx.globalAlpha = 1;
      }
      ctx.restore();
    }
  };

  window.VehicleSystem = SYS;

  // Lightweight ticker to keep the system alive without hard-coupling to the game loop
  let last = 0; function loop(ts){ if(!last) last = ts; const dt = Math.min(0.1, Math.max(0, (ts-last)/1000)); last = ts; try { SYS.update(dt); } catch(_){} requestAnimationFrame(loop); }
  requestAnimationFrame(loop);
})();


</script>
  <!-- Transportation system (train, rental, bus) -->
  <!-- Inlined: src/systems/transportation-system.js -->
<script>
// ============================================================================
// A1K TRANSPORTATION SYSTEM
// ----------------------------------------------------------------------------
// Provides three travel features for the overworld:
//   * Train station encounter in the TRAIN zone
//   * Gold-based car rental service in the MARKET zone
//   * Automated bus line that cruises along floating strips
// The systems expose a minimal API on window.TransportSystem and integrate
// with the main game loop via update/draw helpers.
// ============================================================================

(function defineTransportationSystem() {
  "use strict";

  if (typeof window === "undefined") return;
  if (window.TransportSystem) return;

  const WORLD_WIDTH = (() => {
    if (typeof window.WORLD_WIDTH === "number") return window.WORLD_WIDTH;
    if (typeof window.DESIGN_W === "number")
      return Math.max(6400, window.DESIGN_W);
    if (
      typeof globalThis !== "undefined" &&
      typeof globalThis.WORLD_WIDTH === "number"
    ) {
      return globalThis.WORLD_WIDTH;
    }
    return 6400;
  })();

  const ZONES = {
    ENTRY: { x: 0, end: 600 },
    TRAIN: { x: 600, end: 1200 },
    PLAZA: { x: 1200, end: 1800 },
    HOME_ROW: { x: 1800, end: 2400 },
    MARKET: { x: 2400, end: 3000 },
    ARCADE: { x: 3000, end: 3600 },
    TOWER_GATE: { x: 3600, end: 4200 },
    PET_YARD: { x: 4200, end: 4800 },
    SKY_RAIL: { x: 4800, end: 5400 },
    GARDEN: { x: 5400, end: 6000 },
    BOSS_TOWER: { x: 6000, end: 6400 },
  };

  // Computes the shared floating strip Y position for buses and trains,
  // lowered by 10% of the current viewport height from the original base.
  const getSharedStripY = () => {
    const baseStripY = 250;
    const ch =
      typeof window !== "undefined" && window.innerHeight
        ? window.innerHeight
        : 720;
    return baseStripY + Math.round(ch * 0.3);
  };

  // ========================================
  // 1. TRAIN STATION SYSTEM
  // ========================================
  const TrainStation = {
    location: { x: 1100, y: 200 },
    platforms: [],
    trains: [],
    stops: [],
    stripY: 250,

    init() {
      this.stripY = getSharedStripY();

      this.building = {
        x: 3400,
        y: this.stripY - Math.round(120 * 0.9),
        w: Math.round(200 * 0.9),
        h: Math.round(120 * 0.9),
        label: "Train Station",
        color: "#8B5A2B",
        interactRadius: 90,
      };

      this.platforms = [
        {
          id: "p1",
          x: this.building.x - 80,
          y: this.stripY - 10,
          w: 120,
          h: 10,
          label: "Platform 1",
        },
        {
          id: "p2",
          x: this.building.x + 80,
          y: this.stripY - 10,
          w: 120,
          h: 10,
          label: "Platform 2",
        },
      ];

      // Use prominent world waypoints; buses share this strip as well
      this.stops = [
        { id: "entry", x: 300, name: "Entry" },
        { id: "plaza", x: 1500, name: "Plaza" },
        { id: "market", x: 2700, name: "Market" },
        { id: "arcade", x: 3300, name: "Arcade" },
        { id: "skyrail", x: 5100, name: "Sky Rail" },
        { id: "garden", x: 5700, name: "Garden" },
      ];

      this.spawnTrain("express", 1050);
    },

    spawnTrain(type, x) {
      const trainTypes = {
        express: {
          speed: 400,
          color: "#FF4444",
          capacity: 10,
          w: Math.round(180 * 0.9),
          h: Math.round(60 * 0.9),
        },
        local: {
          speed: 220,
          color: "#4444FF",
          capacity: 20,
          w: Math.round(160 * 0.9),
          h: Math.round(50 * 0.9),
        },
        freight: {
          speed: 160,
          color: "#666666",
          capacity: 5,
          w: Math.round(200 * 0.9),
          h: Math.round(70 * 0.9),
        },
      };

      const spec = trainTypes[type] || trainTypes.express;
      const startX = typeof x === "number" ? x : this.stops[0]?.x || 1100;
      const train = {
        id: `train_${Date.now()}_${Math.random()}`,
        type,
        x: startX,
        y: this.stripY - spec.h,
        vx: 0,
        facingLeft: false,
        ...spec,
        passengers: [],
        state: "moving",
        waitTimer: 0,
        waitDuration: 6000,
        currentStopIndex: 0,
        nextStopIndex: 1,
      };

      this.trains.push(train);
      return train;
    },

    update(dt) {
      const st = window.st;
      this.stripY = getSharedStripY();

      for (const train of this.trains) {
        const stops = this.stops;
        const nextStop = stops[train.nextStopIndex];

        switch (train.state) {
          case "moving": {
            const dx = nextStop.x - train.x;
            const dist = Math.abs(dx);
            if (dist < 12) {
              train.state = "stopping";
              train.x = nextStop.x;
              train.vx = 0;
            } else {
              const dir = dx > 0 ? 1 : -1;
              train.vx = train.speed * dir;
              train.x += train.vx * dt;
              train.facingLeft = dir < 0;
            }
            break;
          }
          case "stopping":
            train.state = "waiting";
            train.waitTimer = train.waitDuration;
            try {
              window.notify?.(`Train arrived at ${nextStop.name}`, "#FF4444");
            } catch (_) {}
            break;
          case "waiting":
            train.waitTimer -= dt * 1000;
            if (train.waitTimer <= 0) {
              train.currentStopIndex = train.nextStopIndex;
              train.nextStopIndex = (train.nextStopIndex + 1) % stops.length;
              train.state = "moving";
            }
            break;
          default:
            break;
        }

        // Keep wheels on the strip
        train.y = this.stripY - train.h;

        // Move boarded players with the train
        if (st?.players && train.passengers.length) {
          for (const pid of train.passengers) {
            const p = st.players.find((pl) => pl?.id === pid);
            if (p) {
              p.x = train.x;
              p.y = train.y;
              p.facingLeft = train.facingLeft;
            }
          }
        }

        // Horizontal wrap
        if (train.state === "moving") {
          if (train.vx > 0 && train.x > WORLD_WIDTH) train.x = 0;
          else if (train.vx < 0 && train.x < 0) train.x = WORLD_WIDTH;
        }
      }
    },

    draw(ctx, cameraX) {
      if (!this.building) return;

      // Rail line
      const railY = this.stripY + 6;
      ctx.fillStyle = "#666666";
      ctx.fillRect(-cameraX, railY, WORLD_WIDTH, 4);

      // Chibi station: rounded body + roof + door
      const screenX = this.building.x - cameraX;
      const b = this.building;
      const radius = 10;
      ctx.fillStyle = b.color;
      ctx.beginPath();
      ctx.moveTo(screenX + radius, b.y);
      ctx.lineTo(screenX + b.w - radius, b.y);
      ctx.quadraticCurveTo(screenX + b.w, b.y, screenX + b.w, b.y + radius);
      ctx.lineTo(screenX + b.w, b.y + b.h - radius);
      ctx.quadraticCurveTo(
        screenX + b.w,
        b.y + b.h,
        screenX + b.w - radius,
        b.y + b.h
      );
      ctx.lineTo(screenX + radius, b.y + b.h);
      ctx.quadraticCurveTo(screenX, b.y + b.h, screenX, b.y + b.h - radius);
      ctx.lineTo(screenX, b.y + radius);
      ctx.quadraticCurveTo(screenX, b.y, screenX + radius, b.y);
      ctx.fill();

      // Roof
      ctx.fillStyle = "#B0723B";
      ctx.fillRect(screenX - 6, b.y - 8, b.w + 12, 10);

      // Door and windows
      ctx.fillStyle = "#3B2F2F";
      ctx.fillRect(
        screenX + Math.round(b.w * 0.1),
        b.y + Math.round(b.h * 0.45),
        18,
        Math.round(b.h * 0.55)
      );
      ctx.fillStyle = "#87CEEB";
      ctx.fillRect(screenX + Math.round(b.w * 0.4), b.y + 20, 20, 16);
      ctx.fillRect(screenX + Math.round(b.w * 0.65), b.y + 20, 20, 16);

      ctx.fillStyle = "#FFFFFF";
      ctx.font = "bold 16px Arial";
      ctx.textAlign = "center";
      ctx.fillText(
        this.building.label,
        screenX + this.building.w / 2,
        this.building.y - 10
      );

      for (const platform of this.platforms) {
        const px = platform.x - cameraX;
        ctx.fillStyle = "#555555";
        ctx.fillRect(px - platform.w / 2, platform.y, platform.w, platform.h);
      }

      for (const train of this.trains) {
        const tx = train.x - cameraX;
        ctx.save();
        ctx.translate(tx, train.y);
        if (train.facingLeft) ctx.scale(-1, 1);

        ctx.fillStyle = train.color;
        ctx.fillRect(-train.w / 2, 0, train.w, train.h);

        ctx.fillStyle = "#87CEEB";
        for (let i = 0; i < 4; i++) {
          const wx = -train.w / 2 + 18 + i * 36;
          ctx.fillRect(
            wx,
            Math.round(train.h * 0.25),
            22,
            Math.round(train.h * 0.33)
          );
        }

        ctx.fillStyle = "#222222";
        ctx.beginPath();
        ctx.arc(-train.w / 2 + 18, train.h + 4, 8, 0, Math.PI * 2);
        ctx.arc(train.w / 2 - 18, train.h + 4, 8, 0, Math.PI * 2);
        ctx.fill();

        ctx.restore();

        ctx.fillStyle = "#FFFFFF";
        ctx.font = "12px Arial";
        ctx.textAlign = "center";
        ctx.fillText(train.type.toUpperCase(), tx, train.y - 6);

        if (train.state === "waiting") {
          ctx.fillStyle = "#FF6B6B";
          ctx.font = "bold 12px Arial";
          const waitSec = Math.ceil(train.waitTimer / 1000);
          ctx.fillText(`Boarding ${waitSec}s`, tx, train.y - 22);
        }
      }
    },

    interact(player, gameState) {
      if (!this.building) return null;

      // Prefer context near a waiting train
      const nearTrain = this.getNearestTrain(player.x, player.y, 120);
      if (nearTrain && nearTrain.state === "waiting") {
        const options = ["Board Train (1,000g)", "Disembark", "Cancel"];
        return {
          type: "train_menu",
          options,
          onSelect: (opt) => {
            if (opt.startsWith("Board"))
              this.boardTrain(player, nearTrain, gameState);
            else if (opt === "Disembark") this.disembarkTrain(player.id);
          },
        };
      }

      // Station interaction
      const dx = player.x - this.building.x;
      const dy = player.y - this.building.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist < this.building.interactRadius) {
        return {
          type: "train_menu",
          options: ["View Schedule", "Cancel"],
        };
      }
      return null;
    },

    getNearestTrain(x, y, maxDistance = 150) {
      let nearest = null;
      let minDist = maxDistance;
      for (const t of this.trains) {
        const dx = t.x - x;
        const dy = t.y + t.h / 2 - y;
        const d = Math.sqrt(dx * dx + dy * dy);
        if (d < minDist) {
          minDist = d;
          nearest = t;
        }
      }
      return nearest;
    },

    boardTrain(player, train, gameState, skipFee = false) {
      if (!train || train.state !== "waiting") return false;
      if (train.passengers.includes(player.id)) return true;
      if (!skipFee) {
        const gold = gameState?.gold ?? 0;
        if (gold < 1000) {
          try {
            window.notify?.("Need 1,000 gold to board.", "#FF6B6B");
          } catch (_) {}
          return false;
        }
        if (typeof gameState?.addGold === "function") gameState.addGold(-1000);
        else if (typeof gameState?.gold === "number") gameState.gold -= 1000;
      }
      train.passengers.push(player.id);
      try {
        window.notify?.("Boarded the train!", "#4A90E2");
      } catch (_) {}
      return true;
    },

    disembarkTrain(playerId) {
      for (const t of this.trains) {
        const i = t.passengers.indexOf(playerId);
        if (i !== -1 && t.state === "waiting") {
          t.passengers.splice(i, 1);
          try {
            window.notify?.("Disembarked.", "#AAAAAA");
          } catch (_) {}
          return true;
        }
      }
      return false;
    },
  };

  // ========================================
  // 2. CAR RENTAL SYSTEM
  // ========================================
  const CarRentalSystem = {
    location: { x: 2600, y: 200 },
    rentals: [],
    activeRentals: [],
    packages: [
      {
        id: "basic_20m",
        name: "Basic Car - 20min",
        duration: 1_200_000,
        cost: 10_000,
        speed: 1.5,
        color: "#4A90E2",
        w: 50,
        h: 24,
      },
      {
        id: "sport_1h",
        name: "Sport Car - 1hr",
        duration: 3_600_000,
        cost: 35_000,
        speed: 2.0,
        color: "#E74C3C",
        w: 56,
        h: 26,
      },
      {
        id: "luxury_3h",
        name: "Luxury Car - 3hr",
        duration: 10_800_000,
        cost: 75_000,
        speed: 1.8,
        color: "#9B59B6",
        w: 60,
        h: 28,
      },
      {
        id: "suv_10h",
        name: "SUV - 10hr",
        duration: 36_000_000,
        cost: 100_000,
        speed: 1.6,
        color: "#2ECC71",
        w: 64,
        h: 30,
      },
    ],

    init() {
      // Place in Market District open space and make 10% smaller
      const ch =
        typeof window !== "undefined" && window.innerHeight
          ? window.innerHeight
          : 720;
      const stripY = getSharedStripY();
      this.building = {
        x: 2900,
        y: stripY - 70,
        w: Math.round(180 * 0.9),
        h: Math.round(100 * 0.9),
        label: "Car Rental",
        color: "#E67E22",
        interactRadius: 80,
      };
    },

    rentCar(player, packageId, gameState) {
      const pkg = this.packages.find((p) => p.id === packageId);
      if (!pkg) return { success: false, message: "Invalid package" };

      const gold = gameState?.gold ?? 0;
      if (gold < pkg.cost) {
        return {
          success: false,
          message: `Need ${pkg.cost} gold (have ${gold})`,
        };
      }

      const existing = this.activeRentals.find((r) => r.ownerId === player.id);
      if (existing) {
        return { success: false, message: "You already have a rented vehicle" };
      }

      if (typeof gameState?.addGold === "function") {
        gameState.addGold(-pkg.cost);
      } else if (typeof gameState?.gold === "number") {
        gameState.gold -= pkg.cost;
      }

      const rental = {
        id: `rental_${Date.now()}_${Math.random()}`,
        ownerId: player.id,
        packageId: pkg.id,
        name: pkg.name,
        x: player.x + 40,
        y: player.y,
        vx: 0,
        vy: 0,
        facingLeft: player.facingLeft || false,
        speedMul: pkg.speed,
        color: pkg.color,
        w: pkg.w,
        h: pkg.h,
        expiresAt: Date.now() + pkg.duration,
        remainingMs: pkg.duration,
        mounted: false,
      };

      this.activeRentals.push(rental);

      try {
        window.notify?.(`Rented ${pkg.name} for ${pkg.cost} gold!`, pkg.color);
      } catch (_) {
        /* ignore notify failures */
      }

      return { success: true, rental };
    },

    update(dt) {
      const now = Date.now();
      const st = window.st;

      for (let i = this.activeRentals.length - 1; i >= 0; i--) {
        const rental = this.activeRentals[i];
        rental.remainingMs = rental.expiresAt - now;

        if (rental.remainingMs <= 0) {
          this.activeRentals.splice(i, 1);
          try {
            window.notify?.("Rental expired!", "#FF6B6B");
          } catch (_) {
            /* ignore */
          }
          continue;
        }

        if (rental.remainingMs < 120_000 && !rental._warned) {
          rental._warned = true;
          try {
            window.notify?.("Rental expires in 2 minutes!", "#FFA500");
          } catch (_) {
            /* ignore */
          }
        }

        const owner = (st?.players || []).find((p) => p?.id === rental.ownerId);
        if (!owner) {
          this.activeRentals.splice(i, 1);
          continue;
        }

        const dx = owner.x + (owner.facingLeft ? -30 : 30) - rental.x;
        const dy = owner.y - rental.y;
        rental.vx = dx * 8 * dt;
        rental.vy = dy * 8 * dt;
        rental.x += rental.vx;
        rental.y += rental.vy;
        rental.facingLeft = owner.facingLeft;

        try {
          if (window.VFX && Math.random() < 0.3) {
            window.VFX.play("afterimage", {
              x: rental.x - (rental.facingLeft ? -15 : 15),
              y: rental.y - 5,
              hue: rental.color,
            });
          }
        } catch (_) {
          /* ignore visual effect failure */
        }
      }
    },

    draw(ctx, cameraX) {
      if (!this.building) return;
      const screenX = this.building.x - cameraX;
      const b = this.building;
      // Chibi building sprite: rounded body, roof, door, window, sign
      const r = 8;
      ctx.fillStyle = b.color;
      ctx.beginPath();
      ctx.moveTo(screenX + r, b.y);
      ctx.lineTo(screenX + b.w - r, b.y);
      ctx.quadraticCurveTo(screenX + b.w, b.y, screenX + b.w, b.y + r);
      ctx.lineTo(screenX + b.w, b.y + b.h - r);
      ctx.quadraticCurveTo(
        screenX + b.w,
        b.y + b.h,
        screenX + b.w - r,
        b.y + b.h
      );
      ctx.lineTo(screenX + r, b.y + b.h);
      ctx.quadraticCurveTo(screenX, b.y + b.h, screenX, b.y + b.h - r);
      ctx.lineTo(screenX, b.y + r);
      ctx.quadraticCurveTo(screenX, b.y, screenX + r, b.y);
      ctx.fill();

      // Roof
      ctx.fillStyle = "#B86A1F";
      ctx.fillRect(screenX - 6, b.y - 8, b.w + 12, 10);

      // Door & window
      ctx.fillStyle = "#3B2F2F";
      ctx.fillRect(
        screenX + Math.round(b.w * 0.08),
        b.y + Math.round(b.h * 0.45),
        16,
        Math.round(b.h * 0.55)
      );
      ctx.fillStyle = "#87CEEB";
      ctx.fillRect(screenX + Math.round(b.w * 0.62), b.y + 18, 20, 16);

      // Sign
      ctx.fillStyle = "#FFFFFF";
      ctx.font = "bold 14px Arial";
      ctx.textAlign = "center";
      ctx.fillText(this.building.label, screenX + b.w / 2, b.y - 10);

      for (const rental of this.activeRentals) {
        const rx = rental.x - cameraX;

        ctx.save();
        ctx.fillStyle = rental.color;
        ctx.globalAlpha = 0.9;
        ctx.fillRect(
          Math.round(rx - rental.w / 2),
          Math.round(rental.y - rental.h - 12),
          rental.w,
          rental.h
        );

        ctx.fillStyle = "#87CEEB";
        ctx.globalAlpha = 0.7;
        ctx.fillRect(
          Math.round(rx - rental.w / 4),
          Math.round(rental.y - rental.h - 8),
          rental.w / 2,
          rental.h / 3
        );

        ctx.globalAlpha = 1;
        ctx.fillStyle = "#222222";
        ctx.beginPath();
        ctx.arc(
          Math.round(rx - rental.w / 3),
          Math.round(rental.y - 12),
          4,
          0,
          Math.PI * 2
        );
        ctx.arc(
          Math.round(rx + rental.w / 3),
          Math.round(rental.y - 12),
          4,
          0,
          Math.PI * 2
        );
        ctx.fill();
        ctx.restore();

        const minutes = Math.floor(rental.remainingMs / 60_000);
        const seconds = Math.floor((rental.remainingMs % 60_000) / 1_000);
        ctx.fillStyle = minutes < 2 ? "#FF6B6B" : "#FFFFFF";
        ctx.font = "10px Arial";
        ctx.textAlign = "center";
        ctx.fillText(
          `${minutes}:${String(seconds).padStart(2, "0")}`,
          rx,
          rental.y - rental.h - 20
        );
      }
    },

    interact(player, gameState) {
      if (!this.building) return null;

      const dx = player.x - this.building.x;
      const dy = player.y - this.building.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist < this.building.interactRadius) {
        return {
          type: "rental_menu",
          packages: this.packages,
          playerGold: gameState?.gold || 0,
        };
      }
      return null;
    },

    getRentalForPlayer(playerId) {
      return this.activeRentals.find((r) => r.ownerId === playerId);
    },
  };

  // ========================================
  // 3. BUS SYSTEM (Automated)
  // ========================================
  const BusSystem = {
    buses: [],
    stops: [],
    routes: [],

    init() {
      // Bus rides slightly lower than trains: 30% of screen from base.
      const baseStripY = 250;
      const ch =
        typeof window !== "undefined" && window.innerHeight
          ? window.innerHeight
          : 720;
      let strip = baseStripY + Math.round(ch * 0.3);
      const maxY = Math.max(120, ch - 120);
      if (strip > maxY) strip = maxY;
      this.routes = [
        {
          id: "main_route",
          name: "Main Line",
          color: "#FFD700",
          stops: [
            { id: "entry", x: 300, y: strip, name: "Entry Plaza" },
            { id: "plaza", x: 1500, y: strip, name: "Central Plaza" },
            { id: "market", x: 2700, y: strip, name: "Market District" },
            { id: "arcade", x: 3300, y: strip, name: "Arcade Zone" },
            { id: "skyrail", x: 5100, y: strip, name: "Sky Rail" },
            { id: "garden", x: 5700, y: strip, name: "Garden" },
          ],
          stripY: strip,
        },
      ];

      for (const route of this.routes) {
        for (const stop of route.stops) {
          this.stops.push({
            ...stop,
            routeId: route.id,
            w: 80,
            h: 20,
            waiting: [],
          });
        }
      }

      this.spawnBus("main_route", 0);
      this.spawnBus("main_route", 3);
    },

    spawnBus(routeId, startStopIndex = 0) {
      const route = this.routes.find((r) => r.id === routeId);
      if (!route) return null;

      const stops = route.stops;
      const startStop = stops[startStopIndex];

      const bus = {
        id: `bus_${Date.now()}_${Math.random()}`,
        routeId,
        x: startStop.x,
        y: route.stripY,
        vx: 0,
        facingLeft: false,
        speed: 180,
        w: 100,
        h: 50,
        color: route.color,
        currentStopIndex: startStopIndex,
        nextStopIndex: (startStopIndex + 1) % stops.length,
        state: "moving",
        waitTimer: 0,
        waitDuration: 6000,
        passengers: [],
        capacity: 15,
      };

      this.buses.push(bus);
      return bus;
    },

    update(dt) {
      for (const bus of this.buses) {
        const route = this.routes.find((r) => r.id === bus.routeId);
        if (!route) continue;

        const stops = route.stops;
        const nextStop = stops[bus.nextStopIndex];

        switch (bus.state) {
          case "moving": {
            const dx = nextStop.x - bus.x;
            const dist = Math.abs(dx);

            if (dist < 10) {
              bus.state = "stopping";
              bus.x = nextStop.x;
              bus.vx = 0;
            } else {
              const dir = dx > 0 ? 1 : -1;
              bus.vx = bus.speed * dir;
              bus.x += bus.vx * dt;
              bus.facingLeft = dir < 0;
            }
            break;
          }
          case "stopping":
            bus.state = "waiting";
            bus.waitTimer = bus.waitDuration;
            try {
              if (window.notify && Math.random() < 0.3) {
                window.notify(`Bus arrived at ${nextStop.name}`, route.color);
              }
            } catch (_) {
              /* ignore */
            }
            break;
          case "waiting":
            bus.waitTimer -= dt * 1000;
            if (bus.waitTimer <= 0) {
              bus.currentStopIndex = bus.nextStopIndex;
              bus.nextStopIndex = (bus.nextStopIndex + 1) % stops.length;
              bus.state = "moving";
            }
            break;
          default:
            break;
        }

        try {
          if (window.VFX && bus.state === "moving" && Math.random() < 0.2) {
            window.VFX.play("smoke", {
              x: bus.x - (bus.facingLeft ? -40 : 40),
              y: bus.y + 20,
              hue: "#888888",
            });
          }
        } catch (_) {
          /* ignore */
        }

        // Carry boarded passengers
        const st = window.st;
        if (st?.players && bus.passengers?.length) {
          for (const pid of bus.passengers) {
            const p = st.players.find((pl) => pl?.id === pid);
            if (p) {
              p.x = bus.x;
              p.y = bus.y;
              p.facingLeft = bus.facingLeft;
            }
          }
        }
      }
    },

    draw(ctx, cameraX) {
      for (const stop of this.stops) {
        const sx = stop.x - cameraX;
        ctx.fillStyle = "#666666";
        ctx.fillRect(sx - stop.w / 2, stop.y, stop.w, stop.h);

        ctx.fillStyle = "#FFD700";
        ctx.beginPath();
        ctx.arc(sx, stop.y - 20, 8, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "#FFFFFF";
        ctx.font = "bold 11px Arial";
        ctx.textAlign = "center";
        ctx.fillText(stop.name, sx, stop.y - 30);
      }

      for (const bus of this.buses) {
        const bx = bus.x - cameraX;

        ctx.save();
        ctx.translate(bx, bus.y);
        if (bus.facingLeft) ctx.scale(-1, 1);

        ctx.fillStyle = bus.color;
        ctx.fillRect(-bus.w / 2, 0, bus.w, bus.h);

        ctx.fillStyle = "#FF6B6B";
        ctx.fillRect(-bus.w / 2, bus.h / 2 - 3, bus.w, 6);

        ctx.fillStyle = "#87CEEB";
        for (let i = 0; i < 5; i++) {
          const wx = -bus.w / 2 + 10 + i * 18;
          ctx.fillRect(wx, 10, 14, 18);
        }

        ctx.fillStyle = "#222222";
        ctx.beginPath();
        ctx.arc(-bus.w / 2 + 15, bus.h, 6, 0, Math.PI * 2);
        ctx.arc(bus.w / 2 - 15, bus.h, 6, 0, Math.PI * 2);
        ctx.fill();

        if (bus.state === "moving") {
          ctx.fillStyle = "#FFFF00";
          ctx.globalAlpha = 0.6;
          ctx.beginPath();
          ctx.arc(bus.w / 2 - 5, bus.h - 10, 4, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
        }

        ctx.restore();

        if (bus.state === "waiting") {
          ctx.fillStyle = "#FF6B6B";
          ctx.font = "bold 12px Arial";
          ctx.textAlign = "center";
          const waitSec = Math.ceil(bus.waitTimer / 1000);
          ctx.fillText(`Boarding ${waitSec}s`, bx, bus.y - 10);
        }

        ctx.fillStyle = "#FFFFFF";
        ctx.font = "10px Arial";
        ctx.textAlign = "center";
        ctx.fillText("BUS", bx, bus.y - 2);
      }
    },

    getNearestBus(x, y, maxDistance = 150) {
      let nearest = null;
      let minDist = maxDistance;

      for (const bus of this.buses) {
        const dx = bus.x - x;
        const dy = bus.y - y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < minDist) {
          minDist = dist;
          nearest = bus;
        }
      }
      return nearest;
    },

    getNearestStop(x, y, maxDistance = 100) {
      let nearest = null;
      let minDist = maxDistance;

      for (const stop of this.stops) {
        const dx = stop.x - x;
        const dy = stop.y - y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < minDist) {
          minDist = dist;
          nearest = stop;
        }
      }
      return nearest;
    },

    // Boarding helpers for bus
    getNearestBusWaiting(x, y, maxDistance = 150) {
      let nearest = null;
      let minDist = maxDistance;
      for (const b of this.buses) {
        if (b.state !== "waiting") continue;
        const dx = b.x - x;
        const dy = b.y - y;
        const d = Math.sqrt(dx * dx + dy * dy);
        if (d < minDist) {
          minDist = d;
          nearest = b;
        }
      }
      return nearest;
    },

    boardBus(player, bus, skipFee = false) {
      if (!bus || bus.state !== "waiting") return false;
      if (!skipFee && this?.fare) {
        const st = window.st;
        const gold = st?.gold ?? 0;
        if (gold < this.fare) {
          window.notify?.(`Need ${this.fare} gold to board.`, "#FF6B6B");
          return false;
        }
        if (typeof st?.addGold === "function") st.addGold(-this.fare);
        else if (typeof st?.gold === "number") st.gold -= this.fare;
      }
      if (!bus.passengers.includes(player.id)) bus.passengers.push(player.id);
      try {
        window.notify?.("Boarded the bus!", "#FFD700");
      } catch (_) {}
      return true;
    },

    disembarkBus(playerId) {
      for (const b of this.buses) {
        const i = b.passengers.indexOf(playerId);
        if (i !== -1 && b.state === "waiting") {
          b.passengers.splice(i, 1);
          try {
            window.notify?.("Disembarked bus.", "#AAA");
          } catch (_) {}
          return true;
        }
      }
      return false;
    },

    interact(player) {
      const b = this.getNearestBusWaiting(player.x, player.y, 120);
      if (!b) return null;
      return {
        type: "bus_menu",
        options: ["Board Bus", "Disembark", "Cancel"],
        onSelect: (opt) => {
          if (opt === "Board Bus") this.boardBus(player, b);
          else if (opt === "Disembark") this.disembarkBus(player.id);
        },
      };
    },
  };

  // ========================================
  // 4. TICKET SYSTEM (Shared state for rides)
  // ========================================
  const TicketSystem = {
    store: new Map(),

    get(playerId, type) {
      const playerTickets = this.store.get(playerId);
      return playerTickets?.[type];
    },

    set(ticket) {
      if (!this.store.has(ticket.ownerId)) {
        this.store.set(ticket.ownerId, {});
      }
      const playerTickets = this.store.get(ticket.ownerId);
      playerTickets[ticket.type] = ticket;
    },

    expire(playerId, type) {
      const t = this.get(playerId, type);
      if (t) {
        t.status = "expired";
        try {
          window.notify?.(`${type} ticket expired`, "#FF6B6B");
        } catch (_) {}
      }
    },

    remainingMs(playerId, type) {
      const t = this.get(playerId, type);
      if (!t || t.status !== "active") return 0;
      return Math.max(0, t.expiresAt - Date.now());
    },

    sweepExpired() {
      const now = Date.now();
      for (const [pid, tickets] of this.store) {
        for (const type of ["car", "train", "bus"]) {
          const t = tickets[type];
          if (t && t.status === "active" && now >= t.expiresAt) {
            this.expire(pid, type);
          }
        }
      }
    },
  };

  // ========================================
  // 5. NPC SYSTEM (Ticket vendors)
  // ========================================
  const NPCSystem = {
    npcs: [],

    init(trainStation, carRental, busStops) {
      const rentalBuilding = carRental?.building || {
        x: 0,
        y: 0,
        h: 0,
      };
      const stationPlatform =
        Array.isArray(trainStation?.platforms) &&
        trainStation.platforms.length > 0
          ? trainStation.platforms[0]
          : null;
      const stationX =
        stationPlatform?.x ??
        trainStation?.building?.x ??
        trainStation?.platforms?.[0]?.x ??
        0;
      const stationY =
        (stationPlatform?.y ??
          trainStation?.building?.y ??
          trainStation?.stripY ??
          0) - 30;
      const targetStop = Array.isArray(busStops) ? busStops[2] : null;

      this.npcs = [
        {
          id: "car_dealer",
          type: "car",
          name: "Car Dealer",
          x: rentalBuilding.x - 30,
          y: rentalBuilding.y + rentalBuilding.h + 20,
          talkRadius: 80,
          packages: [
            { id: "mini_20", name: "Mini 20min", price: 30000, duration: 1200000 },
            { id: "standard_25", name: "Standard 25min", price: 60000, duration: 1500000 },
            { id: "sport_30", name: "Sport 30min", price: 200000, duration: 1800000 },
          ],
        },
        {
          id: "station_agent",
          type: "train",
          name: "Station Agent",
          x: stationX,
          y: stationY,
          talkRadius: 80,
          packages: [
            { id: "local_20", name: "Local 20min", price: 30000, duration: 1200000 },
            { id: "express_25", name: "Express 25min", price: 80000, duration: 1500000 },
            { id: "vip_30", name: "VIP 30min", price: 200000, duration: 1800000 },
          ],
        },
        {
          id: "bus_dispatcher",
          type: "bus",
          name: "Bus Dispatcher",
          x: targetStop?.x || 2700,
          y: (targetStop?.y || 250) - 35,
          talkRadius: 80,
          packages: [
            { id: "bus_20", name: "Bus Pass 20min", price: 30000, duration: 1200000 },
            { id: "bus_25", name: "Bus Pass 25min", price: 80000, duration: 1500000 },
            { id: "bus_30", name: "Bus Pass 30min", price: 200000, duration: 1800000 },
          ],
        },
      ];
    },

    draw(ctx, cameraX) {
      for (const npc of this.npcs) {
        const sx = npc.x - cameraX;
        ctx.fillStyle = "#5A9BD5";
        ctx.fillRect(sx - 8, npc.y - 20, 16, 20);

        ctx.fillStyle = "#FFD7A8";
        ctx.beginPath();
        ctx.arc(sx, npc.y - 26, 8, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "#FFFFFF";
        ctx.font = "bold 10px Arial";
        ctx.textAlign = "center";
        ctx.fillText(npc.name, sx, npc.y - 36);
      }
    },

    interact(player, gameState) {
      for (const npc of this.npcs) {
        const dx = player.x - npc.x;
        const dy = player.y - npc.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist < npc.talkRadius) {
          return this.buildMenu(npc, player, gameState);
        }
      }
      return null;
    },

    buildMenu(npc, player, gameState) {
      const options = npc.packages.map(
        (p) => `${p.name} (${(p.price / 1000).toFixed(0)}k gold)`
      );
      options.push("My Ticket", "Cancel");

      return {
        type: "npc_ticket_menu",
        options,
        onSelect: (opt) => {
          if (opt === "Cancel") return;
          if (opt === "My Ticket") {
            const t = TicketSystem.get(player.id, npc.type);
            if (!t || t.status !== "active") {
              window.notify?.("No active ticket", "#999");
            } else {
              const mins = Math.floor(
                TicketSystem.remainingMs(player.id, npc.type) / 60000
              );
              window.notify?.(`${npc.type} ticket: ${mins}min left`, "#4A90E2");
            }
            return;
          }

          const pkg = npc.packages.find((p) => opt.includes(p.name));
          if (pkg) this.purchaseTicket(npc, pkg, player, gameState);
        },
      };
    },

    purchaseTicket(npc, pkg, player, gameState) {
      const gold = gameState?.gold ?? 0;
      if (gold < pkg.price) {
        window.notify?.(`Need ${pkg.price} gold`, "#FF6B6B");
        return;
      }

      if (typeof gameState?.addGold === "function") {
        gameState.addGold(-pkg.price);
      } else if (typeof gameState?.gold === "number") {
        gameState.gold -= pkg.price;
      }

      const ticket = {
        id: `ticket_${Date.now()}_${Math.random()}`,
        type: npc.type,
        ownerId: player.id,
        tierId: pkg.id,
        price: pkg.price,
        expiresAt: Date.now() + pkg.duration,
        status: "active",
      };
      TicketSystem.set(ticket);
      window.notify?.(`Purchased ${pkg.name}!`, "#4A90E2");
    },

    getNearestNPC(x, y, maxDist = 100) {
      let nearest = null;
      let minDist = maxDist;
      for (const npc of this.npcs) {
        const d = Math.sqrt((npc.x - x) ** 2 + (npc.y - y) ** 2);
        if (d < minDist) {
          minDist = d;
          nearest = npc;
        }
      }
      return nearest;
    },
  };

  // ========================================
  // MAIN TRANSPORT SYSTEM MANAGER
  // ========================================
  const TransportSystem = {
    train: TrainStation,
    rental: CarRentalSystem,
    bus: BusSystem,
    initialized: false,
    actions: {
      _overlay: null,
      _onSelect: null,
      _lastSpec: null,
      _getLocalPlayer() {
        const st = window.st || {};
        if (st.localPlayer) return st.localPlayer;
        if (Array.isArray(st.players)) {
          const flagged = st.players.find(
            (p) => p && (p.isLocal || p.local || p.me)
          );
          return flagged || st.players[0];
        }
        return null;
      },
      init() {
        if (this._overlay) return;
        const el = document.createElement("div");
        el.style.position = "fixed";
        el.style.left = "50%";
        el.style.bottom = "12%";
        el.style.transform = "translateX(-50%)";
        el.style.background = "rgba(0,0,0,0.72)";
        el.style.color = "#fff";
        el.style.fontFamily = "Arial, sans-serif";
        el.style.fontSize = "14px";
        el.style.borderRadius = "8px";
        el.style.padding = "8px 10px";
        el.style.display = "none";
        el.style.zIndex = "9999";
        el.style.boxShadow = "0 4px 10px rgba(0,0,0,0.35)";
        el.setAttribute("data-ts-actions", "");
        document.body.appendChild(el);
        this._overlay = el;

        // Wire the existing HTML #btnAct2 button
        try {
          const btnAct2 = document.getElementById("btnAct2");
          if (btnAct2 && !btnAct2._tsHooked) {
            btnAct2.addEventListener("click", () => this.trigger());
            btnAct2._tsHooked = true;
          }
        } catch (_) {}

        // Subscribe to global action events
        try {
          if (window.EventBus && typeof window.EventBus.on === "function") {
            let lastAt = 0;
            window.EventBus.on("action:trigger", () => {
              const now = Date.now();
              if (now - lastAt < 100) return;
              lastAt = now;
              const player = this._getLocalPlayer?.();
              if (!player || !window.TransportSystem?.initialized) return;
              const spec = window.TransportSystem.interact(player, window.st);
              if (spec && spec.options?.length) {
                const onSelect =
                  typeof spec.onSelect === "function" ? spec.onSelect : null;
                this.show("Actions", spec.options, onSelect);
              }
            });
          }
        } catch (_) {}

        // Wrap window.triggerAction
        try {
          const prevTrigger = window.triggerAction;
          window.triggerAction = function wrappedGlobalAction() {
            try {
              const player =
                window.TransportSystem?.actions?._getLocalPlayer?.();
              if (player && window.TransportSystem?.initialized) {
                const spec = window.TransportSystem.interact(
                  player,
                  window.st
                );
                if (spec && spec.options?.length) {
                  const onSelect =
                    typeof spec.onSelect === "function" ? spec.onSelect : null;
                  window.TransportSystem.actions.show(
                    "Actions",
                    spec.options,
                    onSelect
                  );
                }
              }
            } catch (_) {}
            if (typeof prevTrigger === "function") {
              return prevTrigger.apply(this, arguments);
            }
            return undefined;
          };
        } catch (_) {}

        document.addEventListener("keydown", (e) => {
          if (e.key === "Escape") this.hide();
          if (e.key === "e" || e.key === "E") this.trigger();
        });
      },
      show(title, options, onSelect) {
        this.init();
        this._onSelect = onSelect || null;
        this._overlay.innerHTML = "";
        const header = document.createElement("div");
        header.textContent = title || "Actions";
        header.style.fontWeight = "bold";
        header.style.marginBottom = "6px";
        this._overlay.appendChild(header);
        options.forEach((opt) => {
          const btn = document.createElement("button");
          btn.textContent = opt;
          btn.style.margin = "2px";
          btn.style.padding = "6px 8px";
          btn.style.borderRadius = "6px";
          btn.style.border = "none";
          btn.style.cursor = "pointer";
          btn.style.background = "#4A90E2";
          btn.style.color = "#fff";
          btn.addEventListener("click", () => {
            try {
              this._onSelect && this._onSelect(opt);
            } finally {
              this.hide();
            }
          });
          this._overlay.appendChild(btn);
        });
        this._overlay.style.display = "block";
      },
      hide() {
        if (this._overlay) this._overlay.style.display = "none";
        this._onSelect = null;
        this._lastSpec = null;
      },
      setActive(active) {
        try {
          const btn = document.getElementById("btnAct2");
          if (!btn) return;
          if (active) {
            btn.style.boxShadow = "0 0 18px 6px rgba(74,144,226,0.85)";
            btn.style.filter = "brightness(1.3)";
          } else {
            btn.style.boxShadow = "";
            btn.style.filter = "";
          }
        } catch (_) {}
      },
      trigger() {
        const player = this._getLocalPlayer();
        if (!player || !window.TransportSystem?.initialized) return;
        const gameState = window.st;
        const spec = window.TransportSystem.interact(player, gameState);
        if (spec && spec.options && Array.isArray(spec.options)) {
          const onSelect =
            typeof spec.onSelect === "function" ? spec.onSelect : null;
          this.show("Actions", spec.options, onSelect);
          this._lastSpec = spec;
        } else {
          try {
            window.notify?.("No actions here.", "#999");
          } catch (_) {}
        }
      },
    },

    init() {
      if (this.initialized) return;

      try {
        this.train.init();
        this.rental.init();
        this.bus.init();
        NPCSystem.init(this.train, this.rental, this.bus.stops);
        this.actions.init();
        this.initialized = true;

        if (window.notify) {
          window.notify("Transportation system online!", "#4A90E2");
        }

        console.log("[TransportSystem] Initialized");
      } catch (e) {
        console.error("Failed to initialize TransportSystem:", e);
      }
    },

    update(dt) {
      if (!this.initialized) return;

      try {
        this.train.update(dt);
        this.rental.update(dt);
        this.bus.update(dt);
        TicketSystem.sweepExpired();

        const player = this.actions._getLocalPlayer();
        if (player) {
          this.tryAutoBoardTrain(player);
          this.tryAutoBoardBus(player);
          this.tryAutoSpawnCar(player);
        }

        // Apply moving-platform physics so players can ride
        this.applyPhysicalRiding(window.st, dt);

        // Proximity glow for action button
        if (player) {
          const spec = this.interact(player, window.st);
          this.actions.setActive(!!spec);
        } else {
          this.actions.setActive(false);
        }
      } catch (e) {
        console.error("TransportSystem update error:", e);
      }
    },

    draw(ctx, cameraX) {
      if (!this.initialized) return;

      try {
        this.bus.draw(ctx, cameraX);
        this.train.draw(ctx, cameraX);
        this.rental.draw(ctx, cameraX);
        NPCSystem.draw(ctx, cameraX);
      } catch (e) {
        console.error("TransportSystem draw error:", e);
      }
    },

    tryAutoBoardTrain(player) {
      const ticket = TicketSystem.get(player.id, "train");
      if (!ticket || ticket.status !== "active") return;
      const train = this.train.getNearestTrain(player.x, player.y, 150);
      if (
        train &&
        train.state === "waiting" &&
        !train.passengers.includes(player.id)
      ) {
        this.train.boardTrain(player, train, window.st, true);
      }
    },

    tryAutoBoardBus(player) {
      const ticket = TicketSystem.get(player.id, "bus");
      if (!ticket || ticket.status !== "active") return;
      const bus = this.bus.getNearestBusWaiting(player.x, player.y, 150);
      if (bus && !bus.passengers.includes(player.id)) {
        this.bus.boardBus(player, bus, true);
      }
    },

    tryAutoSpawnCar(player) {
      const ticket = TicketSystem.get(player.id, "car");
      if (!ticket || ticket.status !== "active") return;
      const existing = this.rental.getRentalForPlayer(player.id);
      if (existing) return;

      const tierMap = {
        mini_20: "basic_20m",
        standard_25: "sport_1h",
        sport_30: "luxury_3h",
      };
      const pkgId = tierMap[ticket.tierId] || "basic_20m";
      const pkg = this.rental.packages.find((p) => p.id === pkgId);
      if (!pkg) return;

      const rental = {
        id: `rental_${Date.now()}_${Math.random()}`,
        ownerId: player.id,
        packageId: pkg.id,
        name: pkg.name,
        x: player.x + 40,
        y: player.y,
        vx: 0,
        vy: 0,
        facingLeft: player.facingLeft || false,
        speedMul: pkg.speed,
        color: pkg.color,
        w: pkg.w,
        h: pkg.h,
        expiresAt: ticket.expiresAt,
        remainingMs: ticket.expiresAt - Date.now(),
        mounted: false,
      };
      this.rental.activeRentals.push(rental);
      window.notify?.(`Auto-spawned ${pkg.name}!`, pkg.color);
    },

    interact(player, gameState) {
      if (!this.initialized) return null;

      const trainInteract = this.train.interact(player, gameState);
      if (trainInteract) return trainInteract;

      const busInteract = this.bus.interact(player);
      if (busInteract) return busInteract;

      const rentalInteract = this.rental.interact(player, gameState);
      if (rentalInteract) return rentalInteract;

      const npcInteract = NPCSystem.interact(player, gameState);
      if (npcInteract) return npcInteract;

      return null;
    },

    rentCarQuick(player, packageId, gameState) {
      return this.rental.rentCar(player, packageId, gameState);
    },

    debug: {
      snapshot() {
        try {
          const canvas = document.querySelector("canvas");
          if (!canvas) return false;
          const link = document.createElement("a");
          link.download = "transport-snapshot.png";
          link.href = canvas.toDataURL("image/png");
          link.click();
          return true;
        } catch (_) {
          return false;
        }
      },
    },

    // Returns an array of simple moving/standing surfaces in world coords
    // { id, x1, x2, y, dx }
    getPhysicalSurfaces(dt) {
      const surfaces = [];

      // Rail line across the world
      const railY = this.train.stripY; // top surface of rail
      surfaces.push({ id: "rail", x1: 0, x2: WORLD_WIDTH, y: railY, dx: 0 });

      // Train roofs as moving platforms
      for (const t of this.train.trains) {
        const x1 = t.x - t.w / 2;
        const x2 = t.x + t.w / 2;
        surfaces.push({ id: `train:${t.id}`, x1, x2, y: t.y, dx: t.vx * dt });
      }

      // Bus roofs as moving platforms
      for (const b of this.bus.buses) {
        const x1 = b.x - b.w / 2;
        const x2 = b.x + b.w / 2;
        surfaces.push({ id: `bus:${b.id}`, x1, x2, y: b.y, dx: b.vx * dt });
      }

      // Bus stop platforms (static)
      for (const s of this.bus.stops) {
        const x1 = s.x - s.w / 2;
        const x2 = s.x + s.w / 2;
        surfaces.push({ id: `stop:${s.id}`, x1, x2, y: s.y, dx: 0 });
      }

      // Train station platforms (static)
      for (const p of this.train.platforms) {
        const x1 = p.x - p.w / 2;
        const x2 = p.x + p.w / 2;
        surfaces.push({ id: `plat:${p.id}`, x1, x2, y: p.y, dx: 0 });
      }

      return surfaces;
    },

    // Snap players to nearby surfaces and move them with dx while on top
    applyPhysicalRiding(st, dt) {
      if (!st || !Array.isArray(st.players)) return;
      const surfaces = this.getPhysicalSurfaces(dt);
      const verticalSnap = 12; // px tolerance to snap to surface

      for (const player of st.players) {
        if (!player) continue;
        let onSurface = null;
        for (const surf of surfaces) {
          if (player.x >= surf.x1 && player.x <= surf.x2) {
            const dy = Math.abs(player.y - surf.y);
            // Only snap if player is close to the top of the surface
            if (dy <= verticalSnap) {
              onSurface = surf;
              break;
            }
          }
        }

        if (onSurface) {
          if (player.y !== onSurface.y) player.y = onSurface.y;
          // Carry player with the surface's horizontal displacement
          if (onSurface.dx) player.x += onSurface.dx;
          player._tsSurfaceId = onSurface.id;
        } else {
          if (player._tsSurfaceId) delete player._tsSurfaceId;
        }
      }
    },
  };

  window.TransportSystem = TransportSystem;

  if (
    document.readyState === "complete" ||
    document.readyState === "interactive"
  ) {
    setTimeout(() => TransportSystem.init(), 1000);
  } else {
    window.addEventListener("DOMContentLoaded", () => {
      setTimeout(() => TransportSystem.init(), 1000);
    });
  }

  console.log("[TransportSystem] Module loaded");
})();

</script>
  <!-- House skeleton: config + system -->
  <!-- house-system disabled -->

  <!-- Global Action Handler -->
  <script>
    // Universal Action button handler (A key)
    // Integrates house interactions, chests, pickups, etc.
    window.triggerAction = function () {
      try {
        if (window.HouseInterior?.active) { window.HouseInterior.interact(); return; }
        // Confirm enter if house nearby
        const H = (window.Platform?.layers?.houses) || []; const L = (window.st?.players?.[window.st.leader || 0]);
        let near = null; for (const h of H) { const d = h?.door; if (!d) continue; if (Math.abs((L?.x || 0) - d.x) < 70 && Math.abs((L?.y || 0) - d.y) < 100) { near = h; break; } }
        if (near && window.HouseUI) { window.HouseUI.confirmEnter(() => { window.enterNearestHouse && window.enterNearestHouse(); }); return; }
      } catch (_) { }
      // Chest/pickup fallbacks
      try { if (window.tryOpenChest) window.tryOpenChest(); } catch (_) { }
      try { if (window.ItemSystem?.tryPickupNearbyItem) window.ItemSystem.tryPickupNearbyItem(); } catch (_) { }
      try { if (window.EventBus) window.EventBus.emit('action:trigger', { timestamp: Date.now(), source: 'keyboard' }); } catch (_) { }
    };
  </script>

  <!-- Inlined: src/gameplay/shop-minigames.js -->
<script>
// src/shop-minigames.js
// Provides minigames for the shop to earn gold.

(function () {
  "use strict";

  if (window.ShopMinigames) return;

  const state = {
    rockPaperScissors: {
      cost: 500,
      rewards: { win: [5000, 100000], tie: 500, loss: 0 },
      cooldown: 2000, // 2 seconds
      lastPlay: 0,
    },
    slotMachine: {
      cost: 10000,
      rewards: {
        jackpot: [10000, 700000],
        three_cherries: 100000,
        three_bars: 50000,
        any_two_cherries: 20000,
        any_one_cherry: 10000,
      },
      cooldown: 5000, // 5 seconds
      lastPlay: 0,
    },
  };

  /**
   * Plays a game of Rock, Paper, Scissors against the AI.
   * @param {string} playerChoice - Must be 'rock', 'paper', or 'scissors'.
   */
  function rockPaperScissors(playerChoice) {
    const game = state.rockPaperScissors;
    const now = Date.now();

    if (now - game.lastPlay < game.cooldown) {
      notify("Please wait a moment before playing again.", "#ffaa00");
      return;
    }

    if (st.gold < game.cost) {
      notify(`You need ${game.cost} gold to play.`, "#ff6b6b");
      return;
    }

    st.gold -= game.cost;
    game.lastPlay = now;
    updateCurrencies();

    const choices = ["rock", "paper", "scissors"];
    if (!choices.includes(playerChoice)) {
      notify(
        "Invalid choice. Please pick rock, paper, or scissors.",
        "#ff6b6b"
      );
      return;
    }

    const aiChoice = choices[Math.floor(Math.random() * choices.length)];
    let resultMessage = `You chose ${playerChoice}, AI chose ${aiChoice}. `;

    if (playerChoice === aiChoice) {
      st.gold += game.rewards.tie;
      resultMessage += `It's a tie! You get ${game.rewards.tie} gold back.`;
      notify(resultMessage, "#6aa8ff");
    } else if (
      (playerChoice === "rock" && aiChoice === "scissors") ||
      (playerChoice === "paper" && aiChoice === "rock") ||
      (playerChoice === "scissors" && aiChoice === "paper")
    ) {
      const reward =
        Math.floor(
          Math.random() * (game.rewards.win[1] - game.rewards.win[0] + 1)
        ) + game.rewards.win[0];
      st.gold += reward;
      resultMessage += `You win! You receive ${reward} gold!`;
      notify(resultMessage, "#4ecdc4");
    } else {
      resultMessage += "You lose!";
      notify(resultMessage, "#ff6b6b");
    }
    updateCurrencies();
  }

  /**
   * Plays the high-stakes slot machine.
   */
  function slotMachine() {
    const game = state.slotMachine;
    const now = Date.now();

    if (now - game.lastPlay < game.cooldown) {
      notify("The machine is cooling down.", "#ffaa00");
      return;
    }

    if (st.gold < game.cost) {
      notify(
        `You need ${game.cost} gold to play the high-stakes slots.`,
        "#ff6b6b"
      );
      return;
    }

    st.gold -= game.cost;
    game.lastPlay = now;
    updateCurrencies();

    const reels = ["cherry", "bar", "bell", "seven", "grape"];
    const results = [
      reels[Math.floor(Math.random() * reels.length)],
      reels[Math.floor(Math.random() * reels.length)],
      reels[Math.floor(Math.random() * reels.length)],
    ];

    let reward = 0;
    let message = `[ ${results.join(" | ")} ] --- `;

    const cherryCount = results.filter((r) => r === "cherry").length;

    if (
      results[0] === "bell" &&
      results[1] === "bell" &&
      results[2] === "bell"
    ) {
      reward =
        Math.floor(
          Math.random() *
            (game.rewards.jackpot[1] - game.rewards.jackpot[0] + 1)
        ) + game.rewards.jackpot[0];
      message += `JACKPOT!!! You win ${reward} gold!`;
    } else if (
      results[0] === "cherry" &&
      results[1] === "cherry" &&
      results[2] === "cherry"
    ) {
      reward = game.rewards.three_cherries;
      message += `Three cherries! You win ${reward} gold!`;
    } else if (
      results[0] === "bar" &&
      results[1] === "bar" &&
      results[2] === "bar"
    ) {
      reward = game.rewards.three_bars;
      message += `Three bars! You win ${reward} gold!`;
    } else if (cherryCount === 2) {
      reward = game.rewards.any_two_cherries;
      message += `Two cherries! You win ${reward} gold!`;
    } else if (cherryCount === 1) {
      reward = game.rewards.any_one_cherry;
      message += `One cherry! You win ${reward} gold!`;
    } else {
      message += "No win. Better luck next time!";
    }

    if (reward > 0) {
      st.gold += reward;
      notify(message, "#ffd56a");
      updateCurrencies();
    } else {
      notify(message, "#a8b7ce");
    }
  }

  // Placeholder for more betting games
  function higherOrLower() {
    notify("Higher or Lower is coming soon!", "#6aa8ff");
  }

  window.ShopMinigames = {
    rockPaperScissors,
    slotMachine,
    higherOrLower,
  };

  console.log("🎲 Shop Minigames module loaded.");
})();

</script>

  <!-- Native Skills UI -->


  <!-- Unified Skill Codex & Systems -->
  <!-- Inlined: src/codex/registry.js -->
<script>
(function buildA1KCodex() {
  "use strict";

  // Updated to match current_skills.json skill system
  const overlayMeta = {
    // A1 Skills
    A1_S1: { school: "Blade", rank: "C", name: "Crimson Slash" },
    A1_S2: { school: "Shadow", rank: "B", name: "Shadow Clone Army" },
    A1_S3: { school: "Arcane", rank: "S", name: "Boss Destroyer" },
    A1_ATK: { school: "Blade", rank: "C", name: "Basic Attack" },

    // UNIQUE Skills
    UQ_S1: { school: "Time", rank: "C", name: "Time Freeze" },
    UQ_S2: { school: "Tech", rank: "B", name: "Drone Strike" },
    UQ_S3: { school: "Arcane", rank: "A", name: "Time Reversal" },
    UQ_ATK: { school: "Time", rank: "C", name: "Basic Attack" },

    // MISSY Skills
    MS_S1: { school: "Shadow", rank: "C", name: "Shadow Bolt" },
    MS_S2: { school: "Time", rank: "B", name: "Haste Boost" },
    MS_S3: { school: "Arcane", rank: "A", name: "Dark Matter" },
    MS_ATK: { school: "Shadow", rank: "C", name: "Basic Attack" },

    // Legacy/Unused (kept for backward compatibility)
    mini_clone: { school: "Summon", rank: "S" },
    v_bike: { school: "Vehicle", rank: "A" },
    v_gyro: { school: "Vehicle", rank: "A" },
    v_tank: { school: "Vehicle", rank: "S" },
  };

  const codex = new Map();

  const toMilliseconds = (value) => {
    if (value == null) return 0;
    if (value === 0) return 0;
    if (value > 1200) return value;
    return value * 1000;
  };

  const unionTags = (a, b) => {
    const set = new Set();
    if (Array.isArray(a)) a.forEach((tag) => set.add(tag));
    if (Array.isArray(b)) b.forEach((tag) => set.add(tag));
    return Array.from(set);
  };

  const mergeConfig = (target, source) => {
    if (!source) return target;
    if (!target) return { ...source };
    return { ...target, ...source };
  };

  const ensureCastFn = (entry) => {
    if (entry.castFn && typeof entry.castFn === "function") return entry.castFn;
    return function defaultCastFn(ctx) {
      console.log(`[A1K_Codex] castFn missing for ${entry.id}`, ctx);
      if (window.EnhancedSkillWrapper && ctx?.actor && ctx.slotKey) {
        return window.EnhancedSkillWrapper.useSkill(ctx.actor, ctx.slotKey);
      }
      return false;
    };
  };

  const normalizeEntry = (id, partial) => {
    if (!partial) return null;
    const meta = overlayMeta[id] || {};
    const entry = {
      id,
      codexKey: partial.codexKey || id,
      hero: partial.hero || partial.origin || partial.heroId || null,
      name: partial.name || id,
      icon: partial.icon || "◇",
      rarity: partial.rarity || meta.rank || partial.rank || "C",
      school: partial.school || meta.school || partial.setId || null,
      setId: partial.setId || partial.school || null,
      tags: unionTags(partial.tags, partial.tagList),
      cd: toMilliseconds(partial.cooldown ?? partial.cd),
      power: partial.power ?? null,
      multiplier: partial.multiplier ?? null,
      config: partial.config ? { ...partial.config } : {},
      source: partial.source || null,
      description: partial.description || partial.desc || "",
      castFn: ensureCastFn(partial),
    };
    if (!entry.hero && partial.kind === "weapon") entry.hero = "ANY";
    if (!entry.hero && partial.kind === "veh") entry.hero = "ANY";
    if (!entry.tags.length && partial.kind) entry.tags = [partial.kind];
    return entry;
  };

  const mergeEntry = (id, data) => {
    const normalized = normalizeEntry(id, data);
    if (!normalized) return;
    if (codex.has(id)) {
      const existing = codex.get(id);
      existing.tags = unionTags(existing.tags, normalized.tags);
      existing.config = mergeConfig(existing.config, normalized.config);
      existing.cd = normalized.cd || existing.cd;
      existing.power = normalized.power ?? existing.power;
      existing.multiplier = normalized.multiplier ?? existing.multiplier;
      existing.icon = normalized.icon || existing.icon;
      existing.school = normalized.school || existing.school;
      existing.setId = normalized.setId || existing.setId;
      existing.rarity = normalized.rarity || existing.rarity;
      existing.hero = normalized.hero || existing.hero;
      existing.description = normalized.description || existing.description;
      existing.castFn = ensureCastFn(existing);
    } else {
      codex.set(id, normalized);
    }
  };

  const mergeFromSkillsLib = () => {
    const lib = window.SKILLS_LIB;
    if (!lib) return;
    Object.keys(lib).forEach((id) => {
      const skill = lib[id];
      if (!skill || typeof skill !== "object") return;
      mergeEntry(id, { ...skill, source: "skills-data" });
    });
  };

  const mergeFromEnhanced = () => {
    const enhanced = window.ENHANCED_SKILLS;
    if (!enhanced) return;
    Object.values(enhanced).forEach((group) => {
      if (!group) return;
      Object.keys(group).forEach((slot) => {
        const payload = group[slot];
        if (!payload || !payload.id) return;
        mergeEntry(payload.id, { ...payload, source: `enhanced:${slot}` });
      });
    });
  };

  const mergeOverlayMeta = () => {
    Object.entries(overlayMeta).forEach(([id, meta]) => {
      if (!codex.has(id)) {
        mergeEntry(id, {
          id,
          name: id,
          rarity: meta.rank,
          school: meta.school,
          tags: [],
          cooldown: 0,
          source: "overlay-meta",
        });
      } else {
        const entry = codex.get(id);
        entry.school = entry.school || meta.school || entry.setId || null;
        entry.rarity = entry.rarity || meta.rank || "C";
      }
    });
  };

  mergeFromSkillsLib();
  mergeFromEnhanced();
  mergeOverlayMeta();

  window.A1K_Codex = codex;
  window.A1K_CodexMeta = overlayMeta;
  window.A1K_getCodexSkill = function getCodexSkill(id) {
    return codex.get(id) || null;
  };
  window.A1K_listSkills = function listCodexSkills() {
    return Array.from(codex.values());
  };

  console.log(`[A1K Codex] registry built with ${codex.size} entries`);
})();

</script>
  <!-- OLD skill system files removed (merge, loadouts, cooldowns, bridge_cast, wrapper_bridge) -->

  <!-- Skill Economy & Automation -->
  <!-- Inlined: src/economy/upgrade_fuse.js -->
<script>
(function defineEconomy() {
  'use strict';

  const getState = () => window.st || (window.state ?? {});

  const getSkillInv = (id) => {
    window.SKILLS_INV = window.SKILLS_INV || {};
    if (!window.SKILLS_INV[id]) {
      window.SKILLS_INV[id] = { id, lvl: 1, count: 0, xp: 0 };
    }
    return window.SKILLS_INV[id];
  };

  const upgradeCost = (id) => {
    const inv = getSkillInv(id);
    const base = 100;
    return base * (inv.lvl + 1);
  };

  window.Economy = {
    init(options = {}) {
      if (options.inv) window.SKILLS_INV = options.inv;
      if (options.cores) window.CORE_INV = options.cores;
      console.log('[Economy] initialised');
    },

    fuse(id) {
      const inv = getSkillInv(id);
      if (inv.count < 2) {
        console.warn('[Economy] not enough dupes to fuse', id);
        return false;
      }
      inv.count -= 2;
      inv.lvl = (inv.lvl || 1) + 2;
      inv.xp = inv.xp || 0;
      if (window.notify) window.notify(`Fused ${id} to Lv${inv.lvl}`, '#9fd7ff');
      return true;
    },

    upgrade(id) {
      const inv = getSkillInv(id);
      const cost = upgradeCost(id);
      const st = getState();
      if ((st.gold || 0) < cost) {
        console.warn('[Economy] not enough gold for upgrade', id);
        return false;
      }
      st.gold -= cost;
      inv.lvl = (inv.lvl || 1) + 1;
      inv.xp = inv.xp || 0;
      if (window.notify) window.notify(`Upgraded ${id} to Lv${inv.lvl}`, '#6de38e');
      return true;
    },

    upgradeCost,

    autoEnhanceAll() {
      const ids = Object.keys(window.SKILLS_INV || {});
      const st = getState();
      ids.forEach((id) => {
        while (this.fuse(id)) { /* fuse until insufficient dupes */ }
        let cost = upgradeCost(id);
        while ((st.gold || 0) >= cost) {
          if (!this.upgrade(id)) break;
          cost = upgradeCost(id);
        }
      });
    }
  };
})();

</script>
  <!-- Inlined: src/ai/auto_pager.js -->
<script>
/**
 * AUTO PAGER - HIGH GRADE
 * Intelligent auto-play system for A1K Runner
 *
 * Features:
 * - Auto-advance through game content
 * - Smart difficulty scaling
 * - Boss detection and handling
 * - Performance-based pacing
 * - Skill rotation with priorities
 * - Movement AI with pathfinding
 * - Combat AI with targeting
 * - Integration with skill system
 */

(function () {
  "use strict";

  // ============================================================================
  // CONFIGURATION
  // ============================================================================

  const CONFIG = {
    // Auto-play settings
    enabled: false,
    speed: 1.0, // Playback speed multiplier (0.5 = slow, 2.0 = fast)

    // Movement settings
    movement: {
      baseSpeed: 200,
      dodgeDistance: 100,
      minEnemyDistance: 80,
      maxEnemyDistance: 300,
      orbitalRadius: 150,
      pathUpdateInterval: 0.1, // seconds
    },

    // Combat settings
    combat: {
      engagementRange: 400,
      meleeRange: 100,
      rangedRange: 300,
      prioritizeBosses: true,
      prioritizeWeakTargets: false,
      fleeHealthPercent: 0.2,
      usePotionsAt: 0.5, // Use potions when HP < 50%
    },

    // Skill rotation
    skillRotation: {
      useBasicAttack: true,
      useSkills: true,
      skillCooldownThreshold: 0.5, // Only use skills if cooldown < 50%

      skill1Priority: 3, // S1 priority (lower = higher priority)
      skill2Priority: 2, // S2 priority
      skill3Priority: 1, // S3 (Ultimate) has highest priority
    },

    // Pacing settings
    pacing: {
      waitForEnemies: true,
      waitTime: 2.0, // Seconds to wait when no enemies
      progressWhenClear: true,
      bossDetectionDistance: 800,
    },

    // Safety settings
    safety: {
      dodgeProjectiles: true,
      dodgeAOE: true,
      maintainDistance: true,
      useDefensiveSkills: true,
    },
  };

  // ============================================================================
  // UTILITY FUNCTIONS
  // ============================================================================

  const MathUtils = {
    distance(x1, y1, x2, y2) {
      const dx = x2 - x1;
      const dy = y2 - y1;
      return Math.sqrt(dx * dx + dy * dy);
    },

    angle(x1, y1, x2, y2) {
      return Math.atan2(y2 - y1, x2 - x1);
    },

    clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    },

    lerp(a, b, t) {
      return a + (b - a) * t;
    },
  };

  // ============================================================================
  // TARGETING SYSTEM
  // ============================================================================

  class TargetingSystem {
    constructor() {
      this.currentTarget = null;
      this.targetLockDuration = 2000; // ms
      this.lastTargetTime = 0;
    }

    selectTarget(character, enemies) {
      const now = Date.now();

      // Keep current target if still valid and lock duration not expired
      if (
        this.currentTarget &&
        this.currentTarget.hp > 0 &&
        now - this.lastTargetTime < this.targetLockDuration
      ) {
        return this.currentTarget;
      }

      // Filter valid enemies
      const validEnemies = enemies.filter(
        (e) =>
          e.hp > 0 &&
          MathUtils.distance(character.x, character.y, e.x, e.y) <
            CONFIG.combat.engagementRange
      );

      if (validEnemies.length === 0) {
        this.currentTarget = null;
        return null;
      }

      // Prioritize bosses
      if (CONFIG.combat.prioritizeBosses) {
        const bosses = validEnemies.filter(
          (e) => e.isBoss || e.type === "boss"
        );
        if (bosses.length > 0) {
          this.currentTarget = this.selectClosest(character, bosses);
          this.lastTargetTime = now;
          return this.currentTarget;
        }
      }

      // Prioritize weak targets (low HP)
      if (CONFIG.combat.prioritizeWeakTargets) {
        validEnemies.sort((a, b) => a.hp / a.maxHp - b.hp / b.maxHp);
        this.currentTarget = validEnemies[0];
        this.lastTargetTime = now;
        return this.currentTarget;
      }

      // Default: closest enemy
      this.currentTarget = this.selectClosest(character, validEnemies);
      this.lastTargetTime = now;
      return this.currentTarget;
    }

    selectClosest(character, enemies) {
      let closest = null;
      let minDist = Infinity;

      for (const enemy of enemies) {
        const dist = MathUtils.distance(
          character.x,
          character.y,
          enemy.x,
          enemy.y
        );
        if (dist < minDist) {
          minDist = dist;
          closest = enemy;
        }
      }

      return closest;
    }

    clearTarget() {
      this.currentTarget = null;
    }
  }

  // ============================================================================
  // MOVEMENT AI
  // ============================================================================

  class MovementAI {
    constructor() {
      this.currentPath = [];
      this.pathUpdateTimer = 0;
      this.orbitalAngle = 0;
      this.dodging = false;
      this.dodgeTimer = 0;
    }

    update(dt, character, target, threats) {
      this.pathUpdateTimer -= dt;

      // Update dodge timer
      if (this.dodging) {
        this.dodgeTimer -= dt;
        if (this.dodgeTimer <= 0) {
          this.dodging = false;
        }
      }

      // Check for immediate threats (projectiles, AOE)
      if (CONFIG.safety.dodgeProjectiles || CONFIG.safety.dodgeAOE) {
        const threat = this.detectThreats(character, threats);
        if (threat) {
          return this.dodge(character, threat);
        }
      }

      // No target: stay in place or move forward
      if (!target) {
        if (CONFIG.pacing.progressWhenClear) {
          return {
            x: character.x + CONFIG.movement.baseSpeed * dt,
            y: character.y,
          };
        }
        return { x: character.x, y: character.y };
      }

      // Calculate distance to target
      const distance = MathUtils.distance(
        character.x,
        character.y,
        target.x,
        target.y
      );

      // Too close: back away
      if (distance < CONFIG.movement.minEnemyDistance) {
        const angle = MathUtils.angle(
          target.x,
          target.y,
          character.x,
          character.y
        );
        return {
          x: character.x + Math.cos(angle) * CONFIG.movement.baseSpeed * dt,
          y: character.y + Math.sin(angle) * CONFIG.movement.baseSpeed * dt,
        };
      }

      // Too far: move closer
      if (distance > CONFIG.movement.maxEnemyDistance) {
        const angle = MathUtils.angle(
          character.x,
          character.y,
          target.x,
          target.y
        );
        return {
          x: character.x + Math.cos(angle) * CONFIG.movement.baseSpeed * dt,
          y: character.y + Math.sin(angle) * CONFIG.movement.baseSpeed * dt,
        };
      }

      // Optimal distance: orbital movement (strafe)
      this.orbitalAngle += dt * 0.5;
      const targetAngle = MathUtils.angle(
        character.x,
        character.y,
        target.x,
        target.y
      );
      const orbitalAngle =
        targetAngle + Math.PI / 2 + Math.sin(this.orbitalAngle) * 0.5;

      return {
        x:
          character.x +
          Math.cos(orbitalAngle) * CONFIG.movement.baseSpeed * 0.7 * dt,
        y:
          character.y +
          Math.sin(orbitalAngle) * CONFIG.movement.baseSpeed * 0.7 * dt,
      };
    }

    detectThreats(character, threats) {
      if (!threats || threats.length === 0) return null;

      for (const threat of threats) {
        const dist = MathUtils.distance(
          character.x,
          character.y,
          threat.x,
          threat.y
        );

        // Projectile threat
        if (
          threat.type === "projectile" &&
          dist < CONFIG.movement.dodgeDistance
        ) {
          return threat;
        }

        // AOE threat
        if (
          threat.type === "aoe" &&
          dist < threat.radius + CONFIG.movement.dodgeDistance
        ) {
          return threat;
        }
      }

      return null;
    }

    dodge(character, threat) {
      if (this.dodging) return { x: character.x, y: character.y };

      this.dodging = true;
      this.dodgeTimer = 0.3;

      // Dodge perpendicular to threat direction
      const angle = MathUtils.angle(
        threat.x,
        threat.y,
        character.x,
        character.y
      );
      const dodgeAngle =
        angle + (Math.random() > 0.5 ? Math.PI / 2 : -Math.PI / 2);

      return {
        x: character.x + Math.cos(dodgeAngle) * CONFIG.movement.baseSpeed * 2,
        y: character.y + Math.sin(dodgeAngle) * CONFIG.movement.baseSpeed * 2,
      };
    }
  }

  // ============================================================================
  // COMBAT AI
  // ============================================================================

  class CombatAI {
    constructor(skillManager) {
      this.skillManager = skillManager;
      this.lastAttackTime = 0;
      this.attackCooldown = 0.5; // seconds between basic attacks
    }

    update(dt, character, target) {
      if (!target || target.hp <= 0) return null;

      const now = Date.now() / 1000;
      const distance = MathUtils.distance(
        character.x,
        character.y,
        target.x,
        target.y
      );

      // Try to use skills
      if (CONFIG.skillRotation.useSkills) {
        const skill = this.selectSkill(character, target, distance);
        if (skill) {
          return {
            type: "skill",
            skillId: skill.id,
            target,
          };
        }
      }

      // Use basic attack
      if (
        CONFIG.skillRotation.useBasicAttack &&
        now - this.lastAttackTime >= this.attackCooldown
      ) {
        this.lastAttackTime = now;

        // Check range
        const inRange = character.ranged
          ? distance < CONFIG.combat.rangedRange
          : distance < CONFIG.combat.meleeRange;

        if (inRange) {
          return {
            type: "attack",
            target,
          };
        }
      }

      return null;
    }

    selectSkill(character, target, distance) {
      if (!this.skillManager) return null;

      // Get available skills for character
      const characterId = character.id || character.name || "a1";
      const skills = this.getCharacterSkills(characterId);

      // Filter usable skills - check cooldowns with new skill system
      const usableSkills = skills.filter((skill) => {
        // Check if skill is on cooldown using A1K skill system
        if (window.SKILLS && window.SKILLS.isOnCooldown) {
          if (window.SKILLS.isOnCooldown(skill.id)) return false;
        }

        // Check with legacy skill manager
        if (this.skillManager?.skillRegistry?.getCooldownRemaining) {
          const cdRemaining =
            this.skillManager.skillRegistry.getCooldownRemaining(skill.id);
          if (cdRemaining > CONFIG.skillRotation.skillCooldownThreshold)
            return false;
        }

        // Check range
        if (skill.range && distance > skill.range) return false;

        return true;
      });

      if (usableSkills.length === 0) return null;

      // Sort by priority (lower = higher priority)
      usableSkills.sort((a, b) => a.priority - b.priority);

      return usableSkills[0];
    }

    getCharacterSkills(characterId) {
      // Map character IDs to skill naming conventions
      const skillMapping = {
        a1: { prefix: "A1", name: "A1" },
        unique: { prefix: "UQ", name: "UNIQUE" },
        uq: { prefix: "UQ", name: "UNIQUE" },
        missy: { prefix: "MS", name: "MISSY" },
        ms: { prefix: "MS", name: "MISSY" },
      };

      const char =
        skillMapping[characterId.toLowerCase()] || skillMapping["a1"];
      const prefix = char.prefix;

      // Map skill slots to priorities (S3 is ultimate, S4 removed)
      const skillPriorities = {
        S1: CONFIG.skillRotation.skill1Priority,
        S2: CONFIG.skillRotation.skill2Priority,
        S3: CONFIG.skillRotation.skill3Priority,
        ATK: 10, // Basic attack has lowest priority
      };

      const skills = [];

      // S1, S2, S3 skills
      for (let i = 1; i <= 3; i++) {
        const skillSlot = `S${i}`;
        const skillId = `${prefix}_${skillSlot}`;
        const priority = skillPriorities[skillSlot] || 5;

        skills.push({
          id: skillId,
          priority,
          range: i === 1 ? CONFIG.combat.meleeRange : CONFIG.combat.rangedRange,
          castTime: i === 3 ? 1.0 : 0.2, // Ultimate has cast time
        });
      }

      // Basic attack
      skills.push({
        id: `${prefix}_ATK`,
        priority: skillPriorities["ATK"],
        range: CONFIG.combat.meleeRange,
        castTime: 0,
      });

      return skills;
    }
  }

  // ============================================================================
  // PACING SYSTEM
  // ============================================================================

  class PacingSystem {
    constructor() {
      this.waitTimer = 0;
      this.waiting = false;
      this.lastEnemyCount = 0;
    }

    update(dt, enemies) {
      const currentEnemyCount = enemies.filter((e) => e.hp > 0).length;

      // Check if area is clear
      if (currentEnemyCount === 0) {
        if (CONFIG.pacing.waitForEnemies) {
          if (!this.waiting) {
            this.waiting = true;
            this.waitTimer = CONFIG.pacing.waitTime;
          } else {
            this.waitTimer -= dt;

            if (this.waitTimer <= 0) {
              this.waiting = false;
              return "progress"; // Area clear, move forward
            }

            return "waiting"; // Still waiting
          }
        } else {
          return "progress"; // Don't wait, just move forward
        }
      } else {
        this.waiting = false;
        this.waitTimer = 0;
      }

      this.lastEnemyCount = currentEnemyCount;

      // Check for boss
      const hasBoss = enemies.some(
        (e) => e.hp > 0 && (e.isBoss || e.type === "boss")
      );
      if (hasBoss) {
        return "boss_fight";
      }

      return "combat"; // Enemies present
    }

    shouldProgress() {
      return !this.waiting && CONFIG.pacing.progressWhenClear;
    }
  }

  // ============================================================================
  // AUTO PAGER MANAGER
  // ============================================================================

  class AutoPager {
    constructor() {
      this.enabled = CONFIG.enabled;
      this.targetingSystem = new TargetingSystem();
      this.movementAI = new MovementAI();
      this.combatAI = new CombatAI(window.SkillEffectsManager);
      this.pacingSystem = new PacingSystem();

      this.character = null;
      this.currentState = "idle"; // idle, combat, waiting, boss_fight
      this.debug = false;
    }

    // ========================================================================
    // CORE UPDATE
    // ========================================================================

    update(dt, gameState) {
      if (!this.enabled) return null;

      // Get game state
      const character = this.getCharacter(gameState);
      const enemies = this.getEnemies(gameState);
      const threats = this.getThreats(gameState);

      if (!character) return null;

      this.character = character;

      // Update pacing
      this.currentState = this.pacingSystem.update(dt, enemies);

      // Select target
      const target = this.targetingSystem.selectTarget(character, enemies);

      // Get movement command
      const movement = this.movementAI.update(dt, character, target, threats);

      // Get combat command
      const combat = this.combatAI.update(dt, character, target);

      return {
        movement,
        combat,
        target,
        state: this.currentState,
      };
    }

    // ========================================================================
    // GAME STATE EXTRACTION
    // ========================================================================

    getCharacter(gameState) {
      // Try multiple ways to get character
      if (gameState.player) return gameState.player;
      if (gameState.character) return gameState.character;
      if (window.player) return window.player;
      if (window.L) return window.L; // A1K Runner uses 'L' for player
      return null;
    }

    getEnemies(gameState) {
      // Try multiple ways to get enemies
      if (gameState.enemies) return gameState.enemies;
      if (gameState.mobs) return gameState.mobs;
      if (window.enemies) return window.enemies;
      if (window.GAME?.enemies) return window.GAME.enemies;
      return [];
    }

    getThreats(gameState) {
      // Get projectiles and AOE effects
      const threats = [];

      // Projectiles
      if (gameState.projectiles) {
        threats.push(
          ...gameState.projectiles.map((p) => ({ ...p, type: "projectile" }))
        );
      }
      if (window.projectiles) {
        threats.push(
          ...window.projectiles.map((p) => ({ ...p, type: "projectile" }))
        );
      }

      // AOE effects
      if (gameState.aoeEffects) {
        threats.push(
          ...gameState.aoeEffects.map((a) => ({ ...a, type: "aoe" }))
        );
      }

      return threats;
    }

    // ========================================================================
    // CONTROL API
    // ========================================================================

    start() {
      this.enabled = true;
      console.log("🤖 Auto Pager started");
    }

    stop() {
      this.enabled = false;
      console.log("🛑 Auto Pager stopped");
    }

    toggle() {
      if (this.enabled) {
        this.stop();
      } else {
        this.start();
      }
    }

    setSpeed(speed) {
      CONFIG.speed = MathUtils.clamp(speed, 0.1, 5.0);
      console.log(`⚡ Auto Pager speed: ${CONFIG.speed}x`);
    }

    setConfig(key, value) {
      const keys = key.split(".");
      let target = CONFIG;

      for (let i = 0; i < keys.length - 1; i++) {
        if (!target[keys[i]]) target[keys[i]] = {};
        target = target[keys[i]];
      }

      target[keys[keys.length - 1]] = value;
    }

    getConfig() {
      return { ...CONFIG };
    }

    // ========================================================================
    // DEBUG
    // ========================================================================

    render(ctx) {
      if (!this.debug || !this.character) return;

      const x = 10;
      let y = 450;
      const lineHeight = 18;

      // Background
      ctx.fillStyle = "rgba(0, 0, 0, 0.8)";
      ctx.fillRect(x, y, 250, 180);

      y += 10;

      // Title
      ctx.fillStyle = "#00ff00";
      ctx.font = "bold 14px monospace";
      ctx.fillText("AUTO PAGER", x + 10, y + lineHeight);
      y += lineHeight * 1.5;

      // Status
      ctx.fillStyle = "#ffffff";
      ctx.font = "12px monospace";

      const target = this.targetingSystem.currentTarget;

      const info = [
        `State: ${this.currentState}`,
        `Enabled: ${this.enabled ? "YES" : "NO"}`,
        `Speed: ${CONFIG.speed}x`,
        `Target: ${target ? target.name || "Enemy" : "None"}`,
        `Dodging: ${this.movementAI.dodging ? "YES" : "NO"}`,
        `Position: ${Math.floor(this.character.x)}, ${Math.floor(
          this.character.y
        )}`,
      ];

      for (const line of info) {
        ctx.fillText(line, x + 10, y + lineHeight);
        y += lineHeight;
      }

      // Draw target line
      if (target) {
        ctx.strokeStyle = "rgba(255, 0, 0, 0.5)";
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 5]);
        ctx.beginPath();
        ctx.moveTo(this.character.x, this.character.y);
        ctx.lineTo(target.x, target.y);
        ctx.stroke();
        ctx.setLineDash([]);
      }
    }

    toggleDebug() {
      this.debug = !this.debug;
    }

    setDebug(enabled) {
      this.debug = enabled;
    }
  }

  // ============================================================================
  // EXPORT TO GLOBAL
  // ============================================================================

  window.AutoPager = new AutoPager();

  console.log("✅ Auto Pager initialized - HIGH GRADE");
})();

</script>

  <!-- OLD Skills Window UI removed -->

  <!-- Boot sequence -->
  <!-- Inlined: src/boot/wireup.js -->
<script>
(function bootUnifiedSkillSystem() {
  'use strict';

  const ready = (condition, cb, attempts = 0) => {
    if (condition()) return cb();
    if (attempts > 40) return;
    setTimeout(() => ready(condition, cb, attempts + 1), 100);
  };

  const initialise = () => {
    try {
      if (window.A1K_Codex?.size && typeof window.mergeCodexIntoSkillsLib === 'function') {
        window.mergeCodexIntoSkillsLib(window.A1K_Codex);
      }

      window.Loadouts?.init?.({ hero: 'A1' });
      window.Cooldowns?.init?.({
        getActive: () => window.Loadouts?.getActive(),
        getActor: (hero) => window.SlotHelpers?.getActor?.(hero)
      });
      window.BridgeCast?.init?.({
        codex: window.A1K_Codex,
        loadouts: window.Loadouts,
        cooldowns: window.Cooldowns
      });
      window.Economy?.init?.({ inv: window.SKILLS_INV, cores: window.CORE_INV || {} });
      window.AutoPager?.init?.({ loadouts: window.Loadouts, codex: window.A1K_Codex, cooldowns: window.Cooldowns });
      window.SkillsWindow?.mount?.({
        codex: window.A1K_Codex,
        library: window.SKILLS_LIB,
        inv: window.SKILLS_INV,
        onAssign: (slot, skillId) => {
          window.Loadouts?.assign(slot, skillId);
        }
      });
    } catch (err) {
      console.error('[A1K boot] init error', err);
    }
  };

  document.addEventListener('DOMContentLoaded', () => {
    ready(
      () => window.A1K_Codex?.size && window.SKILLS_LIB,
      initialise
    );
  });
})();

</script>

  <!-- Cinematics Engine + Content -->
  <!-- Inlined: src/cinematics/engine.js -->
<script>
// src/cinematics/engine.js
// Lightweight, self-contained cinematic runner with sub-phase support.
// Plays authored action timelines on an overlay canvas and can optionally
// freeze the world while the sequence runs. Integrates with VFX and the
// existing notify() helper when available.

(function defineCinematicsEngine() {
  "use strict";

  if (window.Cinematics) return;

  const raf = (fn) => requestAnimationFrame(fn);
  const now = () => (performance.now ? performance.now() : Date.now());

  function clamp01(x) {
    return x < 0 ? 0 : x > 1 ? 1 : x;
  }

  // Overlay canvas management
  let overlayCanvas = null;
  let overlayCtx = null;

  function ensureOverlayCanvas() {
    if (overlayCanvas) return overlayCanvas;
    const cv = document.createElement("canvas");
    cv.id = "cinematicOverlay";
    cv.style.position = "absolute";
    cv.style.left = "0";
    cv.style.top = "0";
    cv.style.right = "0";
    cv.style.bottom = "0";
    cv.style.width = "100%";
    cv.style.height = "100%";
    cv.style.pointerEvents = "none";
    cv.style.zIndex = "20000";
    document.body.appendChild(cv);
    overlayCanvas = cv;
    overlayCtx = cv.getContext("2d");
    resize();
    window.addEventListener("resize", resize);
    return cv;
  }

  function resize() {
    if (!overlayCanvas) return;
    const bounds = overlayCanvas.getBoundingClientRect();
    const dpr = Math.min(window.devicePixelRatio || 1, 2);
    overlayCanvas.width = Math.max(1, Math.floor(bounds.width * dpr));
    overlayCanvas.height = Math.max(1, Math.floor(bounds.height * dpr));
  }

  // Subtitles UI
  let subtitleEl = null;
  function showSubtitle(text, color = "#e9f4ff") {
    if (!subtitleEl) {
      subtitleEl = document.createElement("div");
      subtitleEl.id = "cinematicSubtitle";
      subtitleEl.style.cssText = [
        "position:fixed",
        "left:50%",
        "bottom:10%",
        "transform:translateX(-50%)",
        "color:#e9f4ff",
        "font-weight:600",
        "letter-spacing:.2px",
        "text-shadow:0 2px 0 rgba(0,0,0,.35)",
        "z-index:20001",
        "font-size:18px",
        "opacity:0",
        "transition:opacity .25s",
      ].join(";");
      document.body.appendChild(subtitleEl);
    }
    subtitleEl.textContent = text;
    subtitleEl.style.color = color;
    subtitleEl.style.opacity = "1";
    clearTimeout(showSubtitle._tid);
    showSubtitle._tid = setTimeout(() => {
      if (subtitleEl) subtitleEl.style.opacity = "0";
    }, 2000);
  }

  // Registry and state
  const registry = new Map();

  const defaultCamera = {
    x: 0,
    y: 0,
    zoom: 1,
  };

  const state = {
    playing: false,
    id: null,
    startAt: 0,
    stepIndex: 0,
    tInStep: 0,
    timeline: null,
    worldWasFrozen: false,
    camera: { ...defaultCamera },
    bgAlpha: 0,
  };

  // Helpers
  function freezeWorld(enable) {
    try {
      if (!window.WorldFreeze) return;
      if (enable && !window.WorldFreeze.active) window.WorldFreeze.enable?.();
      if (!enable && window.WorldFreeze.active) window.WorldFreeze.disable?.();
    } catch (_) {}
  }

  function withNotify(msg, color) {
    try {
      window.notify && window.notify(msg, color);
    } catch (_) {}
  }

  function lerp(a, b, t) {
    return a + (b - a) * t;
  }

  function drawBars(ctx, alpha) {
    if (!ctx || !alpha) return;
    const w = ctx.canvas.width;
    const h = ctx.canvas.height;
    const barH = Math.floor(h * 0.12);
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.fillStyle = "#0b1222";
    ctx.fillRect(0, 0, w, barH);
    ctx.fillRect(0, h - barH, w, barH);
    ctx.restore();
  }

  // Core runner
  function tick(dt) {
    if (!state.playing) return;
    state.tInStep += dt;
    // Try to advance step
    const step = state.timeline[state.stepIndex];
    if (!step) {
      Cinematics.stop();
      return;
    }
    if (!step._started) {
      step._started = true;
      try {
        step.onStart && step.onStart(Cinematics);
      } catch (e) {
        console.error("[Cinematics] step onStart", e);
      }
    }
    try {
      step.onTick && step.onTick(Cinematics, dt, state.tInStep);
    } catch (e) {
      console.error("[Cinematics] step onTick", e);
    }
    if (state.tInStep >= (step.dur || 0)) {
      try {
        step.onEnd && step.onEnd(Cinematics);
      } catch (e) {
        console.error("[Cinematics] step onEnd", e);
      }
      state.stepIndex++;
      state.tInStep = 0;
    }
  }

  function draw() {
    if (!state.playing) return;
    const ctx = overlayCtx;
    if (!ctx) return;
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

    // background darkening and cinematic bars
    drawBars(ctx, state.bgAlpha);

    // Allow step custom draw
    const step = state.timeline[state.stepIndex];
    try {
      step && step.onDraw && step.onDraw(Cinematics, ctx);
    } catch (e) {
      console.error("[Cinematics] step onDraw", e);
    }
  }

  let last = 0;
  function loop(ts) {
    if (!state.playing) return;
    if (!last) last = ts;
    const dt = Math.min(0.1, Math.max(0.0, (ts - last) / 1000));
    last = ts;
    try {
      tick(dt);
    } catch (e) {
      console.error("[Cinematics] tick error", e);
      Cinematics.stop();
    }
    try {
      draw();
    } catch (e) {
      console.error("[Cinematics] draw error", e);
      Cinematics.stop();
    }
    raf(loop);
  }

  function reset() {
    state.playing = false;
    state.id = null;
    state.startAt = 0;
    state.stepIndex = 0;
    state.tInStep = 0;
    state.timeline = null;
    state.camera = { ...defaultCamera };
    state.bgAlpha = 0;
    last = 0;
    if (subtitleEl) subtitleEl.style.opacity = "0";
  }

  // Public API
  const Cinematics = {
    register(id, factory) {
      registry.set(String(id), factory);
    },
    play(id, opts = {}) {
      try {
        ensureOverlayCanvas();
      } catch (_) {}
      const create = registry.get(String(id));
      if (typeof create !== "function") {
        withNotify("Cinematic not found: " + id, "#ff7a6a");
        return false;
      }
      if (state.playing) Cinematics.stop();
      const timeline = create(
        {
          notify: withNotify,
          subtitle: showSubtitle,
          setBars: (v) => (state.bgAlpha = clamp01(v)),
          setCamera: (x, y, zoom) => {
            state.camera.x = x ?? 0;
            state.camera.y = y ?? 0;
            state.camera.zoom = zoom ?? 1;
          },
          lerp,
          vfx: window.VFX,
          playSkillVFX: window.playSkillVFX,
          st: window.st,
        },
        opts || {}
      );
      if (!Array.isArray(timeline) || !timeline.length) {
        console.warn("[Cinematics] empty timeline for", id);
        return false;
      }
      state.timeline = timeline;
      state.id = String(id);
      state.playing = true;
      state.startAt = now();
      state.stepIndex = 0;
      state.tInStep = 0;
      state.bgAlpha = 0;
      if (opts.freeze !== false) {
        const was = !!(window.WorldFreeze && window.WorldFreeze.active);
        state.worldWasFrozen = was;
        freezeWorld(true);
      }
      withNotify("Cinematic · " + state.id, "#9fd7ff");
      raf(loop);
      return true;
    },
    stop() {
      const unfreeze = () => {
        if (!state.worldWasFrozen) {
          try {
            freezeWorld(false);
          } catch (_) {}
        }
      };
      unfreeze();
      reset();
      withNotify("Cinematic · End", "#9fd7ff");
    },
    isPlaying() {
      return !!state.playing;
    },
  };

  window.Cinematics = Cinematics;
})();

</script>
  <!-- OLD cinematics removed (a1_s2, a1_s3, a1_s1, missy_unique) -->
  <!-- OLD SLOT_SYSTEM_CORE_INTEGRATION removed -->

  <!-- Game API - unified control interface -->
  <!-- Inlined: src/utils/game_api.js -->
<script>
// src/game_api.js (Non-module version)
(function () {
  "use strict";

  function createGameAPI(opts = {}) {
    const q = (s) => (typeof s === "string" ? document.querySelector(s) : s);
    const cv = q(opts.canvas || "#cv");
    const state = () => window.st || {};
    const byId = (id) =>
      (state().players || []).find(
        (p) => (p.id || "").toUpperCase() === ("" + id).toUpperCase()
      );
    const leader = () => (state().players || [])[state().leader || 0];

    // Light event emitter (API-scoped)
    const bus = (() => {
      const m = new Map();
      return {
        on(evt, fn) {
          if (!m.has(evt)) m.set(evt, new Set());
          m.get(evt).add(fn);
          return () => m.get(evt)?.delete(fn);
        },
        emit(evt, payload) {
          m.get(evt)?.forEach((fn) => {
            try {
              fn(payload);
            } catch (_) {}
          });
        },
      };
    })();

    // Helpers to drive existing bindings safely
    const click = (sel) =>
      q(sel)?.dispatchEvent(new MouseEvent("click", { bubbles: true }));
    const ptr = (sel, type) =>
      q(sel)?.dispatchEvent(new PointerEvent(type, { bubbles: true }));

    // Core controls
    function start() {
      const st = state();
      if (!st.started) {
        st.running = true;
        bus.emit("game:start");
      }
    }
    function pause() {
      state().running = false;
      bus.emit("game:pause");
    }
    function resume() {
      state().running = true;
      bus.emit("game:resume");
    }
    function setSpeed(mult = 1) {
      state().speed = Math.max(0.25, Math.min(10, mult));
      const b = q("#btnSpeed");
      if (b) b.textContent = "×" + state().speed;
    }

    // Auto play
    function setAuto(on = true) {
      state().auto = !!on;
      const b = q("#btnAuto");
      if (b) b.textContent = "Auto: " + (on ? "ON" : "OFF");
    }
    function toggleAuto() {
      setAuto(!state().auto);
    }

    // Leader and movement/action
    function switchLeader(nextId) {
      const st = state();
      if (!st.players?.length) return;
      if (!nextId) {
        // next alive
        let i = st.leader || 0,
          tries = st.players.length;
        while (tries--) {
          i = (i + 1) % st.players.length;
          if (!st.players[i].isDefeated) {
            st.leader = i;
            break;
          }
        }
      } else {
        const idx = st.players.findIndex(
          (p) => (p.id || "").toUpperCase() === ("" + nextId).toUpperCase()
        );
        if (idx >= 0 && !st.players[idx].isDefeated) st.leader = idx;
      }
      bus.emit("leader:change", st.players[st.leader]);
    }
    // Attack (tap/hold) routed through existing DOM
    const attack = {
      down() {
        ptr("#btnShoot", "pointerdown");
      },
      up() {
        ptr("#btnShoot", "pointerup");
        ptr("#btnShoot", "pointerleave");
      },
    };
    function jump() {
      click("#btnJump");
    }

    // Skills and gauges
    function cast(heroId, key /* 'S1'|'S2'|'S3' */) {
      const st = state();
      const p = heroId ? byId(heroId) : leader();
      if (!p || !window.useSimpleSkill) return;
      window.useSimpleSkill(p, key);
      bus.emit("skill:cast", { hero: p.id, key });
    }
    function holdStart(heroId, which /* 'A1_S1'|'A1_S3'|'UQ_S2'|'MS_S3' */) {
      const p = heroId ? byId(heroId) : leader();
      if (!p || !window.startHold) return;
      window.startHold(p, which);
    }
    function holdEnd(heroId, which) {
      const p = heroId ? byId(heroId) : leader();
      if (!p || !window.releaseHold) return;
      window.releaseHold(p, which);
    }
    // Rage system removed - no longer needed with 3-skill system

    // Inventory/Bag/Shop
    function openBag(tab = "items") {
      if (window.openBag) window.openBag(tab);
      else click("#btnInventory");
    }
    function autoOpen() {
      click("#btnOpenAll");
    }
    function autoEquip() {
      click("#btnAutoEq");
    }
    function autoUpgrade() {
      click("#btnAutoUp");
    }
    function autoFuse() {
      click("#btnAutoFuse");
    }

    // Vehicles only (pets removed)
    function toggleVehicle() {
      click("#btnVeh");
    }

    // Spawning and flow
    function spawnWave() {
      if (window.spawnWave) window.spawnWave();
    }
    function spawnBoss() {
      if (window.spawnBossForStage) window.spawnBossForStage();
    }
    function nextWave() {
      // respectful skip: wave or stage skip from shop helpers
      const st = state();
      if (st.wave < (st.wavesPerStage || 10)) {
        st.enemies = [];
        st.wave++;
        // Prevent infinite recursion by using a different spawn function
        if (window.Game && window.Game.spawnWave) {
          window.Game.spawnWave();
        } else if (window.spawnWave && !window._spawnWaveRecursionGuard) {
          window._spawnWaveRecursionGuard = true;
          window.spawnWave();
          window._spawnWaveRecursionGuard = false;
        }
      }
    }

    // Currency helpers
    function addGold(n) {
      const st = state();
      st.gold = (st.gold || 0) + Math.max(0, n | 0);
      if (window.updateCurrencies) window.updateCurrencies();
    }

    // Unified Skills window (in-game, no iframe)
    function openSkills() {
      if (window.openSkillWindow) window.openSkillWindow();
      else click("#btnScrolls");
    }
    function closeSkills() {
      if (window.closeSkillWindow) window.closeSkillWindow();
    }

    // Canvas resize hook (optional)
    function resizeCanvas() {
      if (!cv) return;
      const DESIGN_W = 1280,
        DESIGN_H = 720;
      const scale = Math.min(innerWidth / DESIGN_W, innerHeight / DESIGN_H);
      const cssW = DESIGN_W * scale,
        cssH = DESIGN_H * scale;
      Object.assign(cv.style, {
        width: cssW + "px",
        height: cssH + "px",
        position: "absolute",
        left: (innerWidth - cssW) / 2 + "px",
        top: (innerHeight - cssH) / 2 + "px",
      });
    }
    window.addEventListener("resize", resizeCanvas);
    resizeCanvas();

    // Return full API
    const api = {
      // lifecycle
      start,
      pause,
      resume,
      setSpeed,
      // autoplay
      setAuto,
      toggleAuto,
      // leader / movement
      switchLeader,
      attack,
      jump,
      // skills/gauges
      cast,
      holdStart,
      holdEnd,
      // bag/shop
      openBag,
      autoOpen,
      autoEquip,
      autoUpgrade,
      autoFuse,
      // vehicles only
      toggleVehicle,
      // spawning/flow
      spawnWave,
      spawnBoss,
      nextWave,
      // currency
      addGold,
      // skills overlay (native)
      openSkills,
      closeSkills,
      // state/events
      getState: state,
      on: bus.on,
      // destroy (detach listeners)
      destroy() {
        window.removeEventListener("resize", resizeCanvas);
      },
    };
    // Optional global attach
    if (opts.attachGlobal !== false) window.GameAPI = api;
    return api;
  }

  // Expose to window
  window.createGameAPI = createGameAPI;
})();

</script>
  <script>
    // Initialize Game API after loading
    if (window.createGameAPI) {
      window.createGameAPI({ attachGlobal: true });
    }
  </script>

  <!-- Procedural Button Generator -->
  <!-- Inlined: src/procedural-buttons.js -->
<script>
// src/procedural-buttons.js - Procedural Button Generator
// Generate SVG buttons with three art styles: Candy, Pixel, Chili

(function () {
  "use strict";

  class ProceduralButton {
    // Theme definitions
    static themes = {
      candy: {
        colors: ["#FFB6D9", "#D4A5FF", "#B4E7FF", "#FFF5BA", "#C4FAF8"],
        style: "rounded",
        glow: "soft",
        animation: "bounce",
      },
      pixel: {
        colors: ["#FF6B9D", "#F7B731", "#5F27CD", "#00D2D3", "#FD79A8"],
        style: "pixelated",
        glow: "sharp",
        animation: "pulse",
      },
      chili: {
        colors: ["#FF4757", "#FF6348", "#FF7F50", "#FFA502", "#FFD93D"],
        style: "angular",
        glow: "intense",
        animation: "shake",
      },
    };

    /**
     * Generate a procedural button SVG
     * @param {string} theme - 'candy', 'pixel', or 'chili'
     * @param {number} size - button size in pixels
     * @param {string} label - button text or emoji
     * @returns {SVGElement} - generated button
     */
    static generate(theme = "pixel", size = 48, label = "📜") {
      const themeData = this.themes[theme] || this.themes.pixel;
      const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");

      svg.setAttribute("width", size);
      svg.setAttribute("height", size);
      svg.setAttribute("viewBox", `0 0 ${size} ${size}`);
      svg.style.cursor = "pointer";

      // Create gradient
      const defs = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "defs"
      );
      const gradient = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "linearGradient"
      );
      gradient.setAttribute("id", `btn-gradient-${theme}-${Date.now()}`);
      gradient.setAttribute("x1", "0%");
      gradient.setAttribute("y1", "0%");
      gradient.setAttribute("x2", "100%");
      gradient.setAttribute("y2", "100%");

      // Add color stops
      const colors = themeData.colors;
      const stop1 = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "stop"
      );
      stop1.setAttribute("offset", "0%");
      stop1.setAttribute("stop-color", colors[0]);
      gradient.appendChild(stop1);

      const stop2 = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "stop"
      );
      stop2.setAttribute("offset", "100%");
      stop2.setAttribute("stop-color", colors[1]);
      gradient.appendChild(stop2);

      defs.appendChild(gradient);
      svg.appendChild(defs);

      // Draw button based on style
      let button;
      if (themeData.style === "rounded") {
        button = this.createCandyButton(svg, size, gradient.id, colors);
      } else if (themeData.style === "pixelated") {
        button = this.createPixelButton(svg, size, gradient.id, colors);
      } else if (themeData.style === "angular") {
        button = this.createChiliButton(svg, size, gradient.id, colors);
      }

      // Add label
      const text = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "text"
      );
      text.setAttribute("x", size / 2);
      text.setAttribute("y", size / 2 + 4);
      text.setAttribute("text-anchor", "middle");
      text.setAttribute("font-size", size * 0.5);
      text.setAttribute("fill", "#fff");
      text.setAttribute("filter", "url(#text-shadow)");
      text.textContent = label;

      // Add text shadow
      const filter = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "filter"
      );
      filter.setAttribute("id", "text-shadow");
      const feGaussianBlur = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "feGaussianBlur"
      );
      feGaussianBlur.setAttribute("in", "SourceAlpha");
      feGaussianBlur.setAttribute("stdDeviation", "2");
      const feOffset = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "feOffset"
      );
      feOffset.setAttribute("dx", "0");
      feOffset.setAttribute("dy", "2");
      const feMerge = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "feMerge"
      );
      const feMergeNode1 = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "feMergeNode"
      );
      const feMergeNode2 = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "feMergeNode"
      );
      feMergeNode2.setAttribute("in", "SourceGraphic");
      feMerge.appendChild(feMergeNode1);
      feMerge.appendChild(feMergeNode2);
      filter.appendChild(feGaussianBlur);
      filter.appendChild(feOffset);
      filter.appendChild(feMerge);
      defs.appendChild(filter);

      svg.appendChild(text);

      // Add hover animation
      this.addAnimation(svg, themeData);

      return svg;
    }

    /**
     * Create candy-style button (rounded, soft)
     */
    static createCandyButton(svg, size, gradientId, colors) {
      // Main circle with gradient
      const circle = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "circle"
      );
      circle.setAttribute("cx", size / 2);
      circle.setAttribute("cy", size / 2);
      circle.setAttribute("r", size / 2 - 4);
      circle.setAttribute("fill", `url(#${gradientId})`);
      circle.setAttribute("filter", "url(#candy-glow)");
      svg.appendChild(circle);

      // Glow filter
      const filter = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "filter"
      );
      filter.setAttribute("id", "candy-glow");
      const feGaussianBlur = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "feGaussianBlur"
      );
      feGaussianBlur.setAttribute("stdDeviation", "3");
      filter.appendChild(feGaussianBlur);
      svg.querySelector("defs").appendChild(filter);

      // Highlight shine
      const shine = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "ellipse"
      );
      shine.setAttribute("cx", size / 2 - size * 0.1);
      shine.setAttribute("cy", size / 2 - size * 0.15);
      shine.setAttribute("rx", size * 0.2);
      shine.setAttribute("ry", size * 0.15);
      shine.setAttribute("fill", "rgba(255, 255, 255, 0.4)");
      svg.appendChild(shine);

      return circle;
    }

    /**
     * Create pixel-style button (sharp, retro)
     */
    static createPixelButton(svg, size, gradientId, colors) {
      // Pixelated border
      const borderSize = 2;
      const innerSize = size - borderSize * 2;

      // Outer rect (border)
      const border = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "rect"
      );
      border.setAttribute("x", 0);
      border.setAttribute("y", 0);
      border.setAttribute("width", size);
      border.setAttribute("height", size);
      border.setAttribute("fill", "#000");
      svg.appendChild(border);

      // Inner rect (main button)
      const inner = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "rect"
      );
      inner.setAttribute("x", borderSize);
      inner.setAttribute("y", borderSize);
      inner.setAttribute("width", innerSize);
      inner.setAttribute("height", innerSize);
      inner.setAttribute("fill", `url(#${gradientId})`);
      svg.appendChild(inner);

      // Pixel corners (top-left highlights)
      for (let i = 0; i < 3; i++) {
        const pixel = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "rect"
        );
        pixel.setAttribute("x", borderSize + i * 2);
        pixel.setAttribute("y", borderSize);
        pixel.setAttribute("width", 2);
        pixel.setAttribute("height", 2);
        pixel.setAttribute("fill", "rgba(255, 255, 255, 0.6)");
        svg.appendChild(pixel);
      }

      return inner;
    }

    /**
     * Create chili-style button (angular, hot)
     */
    static createChiliButton(svg, size, gradientId, colors) {
      // Angular diamond shape
      const points = [
        [size / 2, 4], // top
        [size - 4, size / 2], // right
        [size / 2, size - 4], // bottom
        [4, size / 2], // left
      ];

      const polygon = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "polygon"
      );
      polygon.setAttribute("points", points.map((p) => p.join(",")).join(" "));
      polygon.setAttribute("fill", `url(#${gradientId})`);
      polygon.setAttribute("filter", "url(#chili-glow)");
      svg.appendChild(polygon);

      // Intense glow
      const filter = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "filter"
      );
      filter.setAttribute("id", "chili-glow");
      const feGaussianBlur = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "feGaussianBlur"
      );
      feGaussianBlur.setAttribute("stdDeviation", "4");
      filter.appendChild(feGaussianBlur);
      svg.querySelector("defs").appendChild(filter);

      // Inner diamond (highlight)
      const innerPoints = points.map((p) => [
        (p[0] + size / 2) / 2,
        (p[1] + size / 2) / 2,
      ]);
      const innerPolygon = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "polygon"
      );
      innerPolygon.setAttribute(
        "points",
        innerPoints.map((p) => p.join(",")).join(" ")
      );
      innerPolygon.setAttribute("fill", "rgba(255, 255, 255, 0.3)");
      svg.appendChild(innerPolygon);

      return polygon;
    }

    /**
     * Add hover animations based on theme
     */
    static addAnimation(svg, themeData) {
      const animation = themeData.animation;

      svg.addEventListener("mouseenter", () => {
        if (animation === "bounce") {
          svg.style.transform = "scale(1.1)";
          svg.style.transition = "transform 0.2s ease-out";
        } else if (animation === "pulse") {
          svg.style.animation = "pixel-pulse 0.3s infinite";
        } else if (animation === "shake") {
          svg.style.animation = "chili-shake 0.3s";
        }
      });

      svg.addEventListener("mouseleave", () => {
        svg.style.transform = "";
        svg.style.animation = "";
      });
    }

    /**
     * Apply button to existing DOM element
     * @param {string} selector - CSS selector for element
     * @param {string} theme - button theme
     * @param {number} size - button size
     * @param {string} label - button label
     */
    static applyToElement(selector, theme = "pixel", size = 48, label = "📜") {
      const element = document.querySelector(selector);
      if (!element) {
        console.warn(`ProceduralButton: Element ${selector} not found`);
        return;
      }

      const svg = this.generate(theme, size, label);
      element.innerHTML = "";
      element.appendChild(svg);
      element.style.display = "inline-block";
      element.style.verticalAlign = "middle";
    }
  }

  // Add CSS animations
  const style = document.createElement("style");
  style.textContent = `
    @keyframes pixel-pulse {
      0%, 100% { filter: brightness(1); }
      50% { filter: brightness(1.3); }
    }

    @keyframes chili-shake {
      0%, 100% { transform: rotate(0deg); }
      25% { transform: rotate(-5deg); }
      75% { transform: rotate(5deg); }
    }
  `;
  document.head.appendChild(style);

  // Global export
  window.ProceduralButton = ProceduralButton;

  console.log("✅ Procedural Button Generator loaded");
})();

</script>

  <!-- OLD SCROLL BUTTON HANDLERS REMOVED - No longer needed -->

  <!-- Initialize procedural systems -->
  <script>
    (function () {
      console.log('🎨 Initializing procedural art systems...');

      // Create global sky system
      window.dynamicSky = null;

      // Initialize after a brief delay to ensure all systems are loaded
      setTimeout(() => {
        if (typeof DynamicSky !== 'undefined') {
          const DESIGN_W = window.DESIGN_W || 900;
          const DESIGN_H = window.DESIGN_H || 540;
          window.dynamicSky = new DynamicSky(DESIGN_W, DESIGN_H, 1);
          console.log('✅ Dynamic sky initialized');
        }
      }, 100);

      console.log('✅ All procedural art systems ready');
    })();
  </script>
  <style>
    /* Canvas positioning */
    #cv {
      width: 1548.44px;
      height: 871px;
      position: absolute;
      left: 65.7778px;
      top: 0px;
    }

    /* Currency positioning */
    #currency {
      top: 110px;
      left: 10px;
      gap: 8px;
      justify-content: flex-start;
      pointer-events: none;
    }

    .mini-map-wrap {
      flex-basis: 100%;
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: 6px;
      pointer-events: auto;
      margin-top: 4px;
    }

    .mini-map-canvas {
      width: 132px;
      height: 132px;
      border: 1px solid #28324b;
      background: rgba(5, 8, 16, 0.78);
      border-radius: 8px;
      pointer-events: none;
    }

    .mini-map-toggle {
      width: 132px;
      text-align: center;
      cursor: pointer;
    }

    /* Bag header layout */
    .bag-header-flex {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .bag-auto-actions-width {
      width: 100%;
      margin-top: 8px;
    }

    /* Player stats layout */
    .player-stats-flex {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    /* XP bar styling */
    .xp-bar {
      margin-top: 8px;
    }

    .xp-bar .fill {
      transform: scaleX(0);
    }

    /* Evolution section */
    .evolution-section {
      margin-top: 8px;
      display: flex;
      gap: 8px;
    }

    /* Gear section HR */
    .gear-hr {
      margin: 8px 0;
      border-color: var(--line);
    }

    /* Pet grid HR */
    .pet-hr {
      grid-column: 1 / -1;
      margin: 8px 0px;
      border: 1px solid var(--line);
    }

    /* Vehicle grid HR */
    .vehicle-hr {
      grid-column: 1 / -1;
      margin: 8px 0px;
      border: 1px solid var(--line);
    }

    /* Paper doll layout */
    .paper-doll-container {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      padding: 8px;
    }

    .paper-doll-hero {
      flex: 1;
      min-width: 160px;
    }

    .paper-doll-hero-title {
      text-align: center;
      font-size: 12px;
      color: #9baec8;
      margin-bottom: 4px;
    }

    .paper-doll-hero-display {
      width: 120px;
      height: 160px;
      border: 1px dashed var(--line);
      border-radius: 4px;
      margin: auto;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #3b4d71;
      background: rgba(255, 255, 255, 0.03);
    }

    .paper-doll-equipment {
      flex: 1;
      min-width: 160px;
    }

    .paper-doll-section-title {
      font-size: 12px;
      color: #9baec8;
      margin-bottom: 4px;
    }

    .paper-doll-slot {
      margin-bottom: 4px;
    }

    .paper-doll-pets-title {
      font-size: 12px;
      color: #9baec8;
      margin: 8px 0 4px;
    }

    .paper-doll-vehicle-title {
      font-size: 12px;
      color: #9baec8;
      margin: 8px 0 4px;
    }

    /* Quest content */
    .quest-content {
      padding: 8px;
      opacity: 1;
    }

    .quest-header-title {
      margin: 0 0 8px;
      color: #e9f4ff;
    }

    .quest-timer {
      font-size: 11px;
      margin-left: 8px;
      color: #ffd56a;
    }

    .quest-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .quest-progress-fill {
      transform: scaleX(1);
    }

    .quest-reward-claimed {
      color: #36c777;
      margin-left: 4px;
    }

    .quest-footer {
      margin-top: 12px;
      padding-top: 8px;
      border-top: 1px solid rgba(123, 97, 255, 0.3);
    }

    .quest-footer-text {
      margin: 0;
      font-size: 11px;
      color: #9baec8;
    }

    .endless-stats {
      margin-top: 8px;
      display: none;
    }

    .endless-title {
      margin: 0 0 4px;
      color: #ffaa00;
    }

    .endless-score {
      margin: 0;
      font-size: 12px;
      color: #cfe3ff;
    }

    .endless-time {
      margin: 0;
      font-size: 12px;
      color: #cfe3ff;
    }

    /* Settings card */
    .settings-card {
      background: rgba(255, 255, 255, 0.04);
      padding: 8px;
      border: 1px solid rgba(123, 97, 255, 0.2);
      border-radius: 6px;
    }

    .settings-title {
      margin: 0 0 6px;
      font-size: 14px;
    }

    .settings-label {
      display: block;
      margin-top: 6px;
    }

    .settings-qa-section {
      margin-top: 8px;
    }

    .settings-qa-button {
      padding: 6px 10px;
      border: 1px solid #3b4d71;
      background: #1a263a;
      color: #d7e9ff;
      border-radius: 6px;
      cursor: pointer;
    }

    .settings-qa-note {
      opacity: .7;
      margin-left: 8px;
    }

    .settings-theme-group {
      margin-top: 10px;
    }

    .settings-theme-row {
      display: flex;
      gap: 6px;
      flex-wrap: wrap;
      margin-top: 6px;
    }

    .settings-theme-button {
      padding: 6px 12px;
      border: 1px solid #456089;
      background: rgba(16, 32, 52, 0.9);
      color: #d7e9ff;
      border-radius: 6px;
      cursor: pointer;
      transition: background 0.2s ease, transform 0.2s ease;
    }

    .settings-theme-button:hover {
      background: rgba(68, 104, 155, 0.9);
      transform: translateY(-1px);
    }

    .qa-tools-flex {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .audio-volume-slider {
      width: 100%;
    }

    .hud-position-select {
      margin-left: 4px;
    }

    /* Shared gauge fill */
    .shared-gauge-fill {
      transform: scaleX(1);
    }

    /* Action button styling */
    .action-new-display {
      display: flex;
      background-color: var(--pastel-pet);
    }

    /* Joystick nub positioning */
    .nub-center {
      left: 50%;
      top: 50%;
    }

    /* Duration ring hidden */
    .duration-ring-hidden {
      display: none;
    }

    /* Secret button styling */
    .secret-btn-ready {
      opacity: 1;
      pointer-events: auto;
    }

    /* Hero styling */
    .hero-unique-cursor {
      cursor: pointer;
    }

    .hero-unique-hp-fill {
      transform: scaleX(0.88);
    }

    .hero-unique-secret-fill {
      transform: scaleX(1);
    }

    .hero-unique-rage-fill {
      transform: scaleX(0.82);
    }

    .hero-unique-skill-icons {
      display: flex;
    }

    .hero-missy-cursor {
      cursor: pointer;
    }

    .hero-missy-hp-fill {
      transform: scaleX(0.92);
    }

    .hero-missy-secret-fill {
      transform: scaleX(1);
    }

    .hero-missy-rage-fill {
      transform: scaleX(0.42);
    }

    .hero-missy-skill-icons {
      display: flex;
    }

    .btn-switch-char {
      pointer-events: auto;
      display: none;
    }

    .hp-fill {
      transform: scaleX(0.28);
    }

    .mp-fill {
      transform: scaleX(1);
    }

    .xp-bar-container {
      min-width: 260px;
      position: relative;
    }

    .xp-dom-fill {
      transform: scaleX(0.9375);
    }

    .boss-bar-container {
      min-width: 260px;
    }

    .boss-fill {
      transform: scaleX(0);
    }

    .gold-pill {
      pointer-events: auto;
    }

    .toggle-currencies {
      cursor: pointer;
      pointer-events: auto;
    }

    .extra-currencies {
      display: none;
      gap: 8px;
      pointer-events: auto;
      flex-wrap: wrap;
    }

    .drop-rate-display {
      pointer-events: auto;
    }
  </style>

  <script id="input-inline-v2">
    (function () {
      const RUN_MAX = 280;               // clamp player horizontal speed
      const SUPER_JUMP_HOLD_MS = 240;    // hold Up >= this for super jump
      const ATTACK_REPEAT_MS = 110;      // Space repeat cadence

      let spaceHeld = false;
      let lastAttackAt = 0;
      let upDownAt = 0;
      let attackPressed = false;

      const swallow = (ev) => { ev.preventDefault(); ev.stopPropagation(); ev.stopImmediatePropagation(); };
      const leader = () => {
        try {
          const st = window.st;
          if (!st) return null;
          const idx = st.leader || 0;
          return (st.players || [])[idx] || null;
        } catch (_) { return null; }
      };

      const attackOnce = () => {
        try {
          const L = leader();
          if (!L || L.isDefeated) return;
          if (typeof basicAttackAction === 'function') basicAttackAction(L);
          if (!attackPressed) {
            window.press?.('attack');
            attackPressed = true;
          }
        } catch (_) { }
      };

      const startJumpCharge = () => {
        try { window.chargeManager?.startJumpCharge?.(); } catch (_) { }
        window.press?.('jump');
      };

      const finishJump = () => {
        try {
          const L = leader();
          const held = performance.now() - (upDownAt || 0);
          upDownAt = 0;
          const charge = window.chargeManager?.releaseJumpCharge?.();
          const boost = charge?.progress ?? (held >= SUPER_JUMP_HOLD_MS ? 1 : 0);
          if (L) {
            L._jumpQueued = true;
            L._jumpPower = held >= SUPER_JUMP_HOLD_MS ? 2.0 : 1.0 + Math.min(1, boost);
            if (held >= SUPER_JUMP_HOLD_MS) {
              window.press?.('superjump');
              setTimeout(() => window.release?.('superjump'), 16);
            }
          }
        } catch (_) { }
        window.release?.('jump');
      };

      const attackLoop = (now) => {
        if (spaceHeld && !(window.WorldFreeze?.active)) {
          if (!lastAttackAt || now - lastAttackAt >= ATTACK_REPEAT_MS) {
            lastAttackAt = now;
            attackOnce();
          }
        } else if (!spaceHeld) {
          lastAttackAt = 0;
        }
        requestAnimationFrame(attackLoop);
      };
      requestAnimationFrame(attackLoop);

      addEventListener('keydown', (event) => {
        if (window.MissyArcadeGame?.active) {
          const key = (event.key || '').toLowerCase();
          if (key === 'escape') {
            try { window.MissyArcadeGame.requestExit(); } catch (_) { }
          }
          event.preventDefault();
          return;
        }
        const code = event.code;

        // Skip ArrowUp handling if inside house - let HouseInterior handle it
        if (code === 'ArrowUp' && window.HouseInterior?.active) {
          return;
        }

        if (event.repeat) {
          if (code === 'Space') swallow(event);
          return;
        }

        if (code === 'Space') {
          spaceHeld = true;
          lastAttackAt = 0;
          attackOnce();
          swallow(event);
          return;
        }

        if (code === 'ArrowUp') {
          upDownAt = performance.now();
          startJumpCharge();
          swallow(event);
          return;
        }

        if (code === 'ShiftLeft' || code === 'ShiftRight') {
          swallow(event);
          return;
        }

        if (code === 'KeyW') {
          // prevent legacy bindings from hijacking W for jump
          swallow(event);
          return;
        }

        const activeMap = window.keymap || window.A1K_KEYMAP || {};
        const primaryCode = activeMap.ACT_PRIMARY || 'KeyA';
        const secondaryCode = activeMap.ACT_SECONDARY || 'KeyE';
        if (code === primaryCode || code === secondaryCode) {
          try { if (window.enterNearestHouse && window.enterNearestHouse()) { swallow(event); return; } } catch (_) { }
          try { if (window.tryOpenChest) window.tryOpenChest(); } catch (_) { }
        }
      }, true);

      addEventListener('keyup', (event) => {
        if (window.MissyArcadeGame?.active) {
          event.preventDefault();
          return;
        }
        const code = event.code;

        // Skip ArrowUp handling if inside house - let HouseInterior handle it
        if (code === 'ArrowUp' && window.HouseInterior?.active) {
          return;
        }

        if (code === 'Space') {
          spaceHeld = false;
          window.release?.('attack');
          attackPressed = false;
          swallow(event);
          return;
        }

        if (code === 'ArrowUp') {
          finishJump();
          swallow(event);
          return;
        }

        if (code === 'ShiftLeft' || code === 'ShiftRight' || code === 'KeyW') {
          swallow(event);
        }
      }, true);

      const clampAndStripDash = () => {
        try {
          const players = (window.st && window.st.players) || [];
          for (const p of players) {
            if (!p) continue;
            if ('dash' in p) p.dash = 0;
            if ('isDashing' in p) p.isDashing = false;
            if ('dashT' in p) p.dashT = 0;
            if (Math.abs(p.vx || 0) > RUN_MAX) p.vx = Math.sign(p.vx) * RUN_MAX;
          }
        } catch (_) { }
        requestAnimationFrame(clampAndStripDash);
      };
      clampAndStripDash();

      const neuterExternalMappings = () => {
        try {
          if (window.INPUT) {
            if (window.INPUT.doubleTapToDash != null) window.INPUT.doubleTapToDash = false;
            if (window.INPUT.keymap) {
              window.INPUT.keymap.Space = null;
              window.INPUT.keymap.Spacebar = null;
              window.INPUT.keymap.KeyW = null;
            }
          }
          if (window.Config && 'dashEnabled' in window.Config) window.Config.dashEnabled = false;
        } catch (_) { }
      };
      setInterval(neuterExternalMappings, 250);
    })();
  </script>
  <script id="house-nearby-utils">
    (function () {
      window.nearHouseDoor = function (thX = 70, thY = 110) {
        try {
          const H = (window.Platform?.layers?.houses) || [];
          const L = (window.st?.players?.[window.st.leader || 0]);
          if (!L || !H.length) return null;
          for (const h of H) { const d = h?.door; if (!d) continue; if (Math.abs(L.x - d.x) < thX && Math.abs(L.y - d.y) < thY) return h; }
          return null;
        } catch (_) { return null; }
      };
    })();
  </script>
  <script id="house-interior-inline">
    (function () {
      if (window.HouseInterior) return;
      window.HouseInterior = {
        active: false,
        house: null,
        hero: { x: 0, y: 0, w: 18, h: 24, vx: 0, vy: 0, speed: 180 },
        followers: [],
        keys: { left: false, right: false, up: false, down: false },
        objs: { chests: [], npcs: [], counters: [], door: { x: 0, y: 0, w: 42, h: 36 } },
        indoorCombat: { active: false, enemies: [], spawnTimer: 0, wave: 0, notified: false, fx: [] },
        arcadeState: {
          machines: [],
          neonSigns: [],
          leaderboard: [],
          prizes: [],
          hiddenChest: null,
          visibleChest: null,
          counter: null,
          highlightMachineId: null,
          prompt: '',
          animation: {
            glowTimer: 0,
            glowSpeed: 2.4,
            leaderboardOffset: 0,
            prizeRotation: 0,
            glitchTimer: 0,
            glitchVisible: true
          }
        },
        hunters: [],
        pets: [],
        computerGames: {
          active: false,
          selectedGame: null,
          gameState: {},
          highScores: {},
          cooldown: 0,
          totalWinnings: 0
        },
        startIndoorCombat() {
          const ic = this.indoorCombat || (this.indoorCombat = {});
          ic.active = true;
          ic.enemies = [];
          ic.spawnTimer = 0.5;
          ic.wave = 0;
          if (!ic.notified) {
            try { notify('Indoor combat active! Press F to strike training targets.', '#6aa8ff'); } catch (_) { }
            ic.notified = true;
          }
        },
        stopIndoorCombat() {
          const ic = this.indoorCombat;
          if (!ic) return;
          ic.active = false;
          ic.enemies = [];
          ic.spawnTimer = 0;
          ic.wave = 0;
        },
        spawnIndoorEnemy() {
          const ic = this.indoorCombat;
          if (!ic || !ic.active) return;
          const W = (typeof DESIGN_W !== 'undefined' ? DESIGN_W : 1280);
          const H = (typeof DESIGN_H !== 'undefined' ? DESIGN_H : 720);
          const arenaMinX = Math.floor(W * 0.28);
          const arenaMaxX = Math.floor(W * 0.72);
          const spawnX = arenaMinX + Math.random() * (arenaMaxX - arenaMinX);
          const spawnY = H - 240 - Math.random() * 50;
          const hpBase = 180 + (ic.wave || 0) * 45;
          ic.enemies.push({
            id: `indoor_${Date.now()}_${Math.floor(Math.random() * 1000)}`,
            x: spawnX,
            y: spawnY,
            vx: (Math.random() < 0.5 ? -1 : 1) * (80 + (ic.wave || 0) * 6),
            hp: hpBase,
            hpMax: hpBase,
            color: '#ff93d3'
          });
        },
        updateIndoorCombat(dtSec) {
          const ic = this.indoorCombat;
          if (!ic || !ic.active) return;
          ic.spawnTimer -= dtSec;
          if (ic.spawnTimer <= 0 && ic.enemies.length < 3) {
            this.spawnIndoorEnemy();
            ic.wave = (ic.wave || 0) + 1;
            ic.spawnTimer = Math.max(1.2, 3.2 - (ic.wave * 0.12));
          }
          const W = (typeof DESIGN_W !== 'undefined' ? DESIGN_W : 1280);
          const arenaMinX = Math.floor(W * 0.25);
          const arenaMaxX = Math.floor(W * 0.75);
          ic.enemies.forEach((enemy) => {
            enemy.x += enemy.vx * dtSec;
            if (enemy.x < arenaMinX || enemy.x > arenaMaxX) {
              enemy.vx *= -1;
              enemy.x = Math.max(arenaMinX, Math.min(arenaMaxX, enemy.x));
            }
          });
          // Phase 2: Award gold and XP for indoor combat kills
          ic.enemies = ic.enemies.filter((enemy) => {
            if (enemy.hp <= 0) {
              const st = window.st || (window.st = {});
              const wave = ic.wave || 1;
              const goldReward = Math.floor(1000 + Math.random() * 9000 + (wave * 200));
              const xpReward = Math.floor(50 + Math.random() * 150 + (wave * 10));

              st.gold = (st.gold || 0) + goldReward;
              if (typeof grantXP === 'function') {
                grantXP(xpReward);
              } else {
                st.xp = (st.xp || 0) + xpReward;
              }

              if (typeof addFloater === 'function') {
                addFloater(enemy.x, enemy.y - 30, `+${Math.floor(goldReward / 100) / 10}k 💰`, '#ffd56a');
                addFloater(enemy.x, enemy.y - 50, `+${xpReward} XP`, '#00ff88');
              }

              try {
                window.QuestSystem?.trackProgress?.('indoor_kill', 1);
              } catch (_) { }

              return false;
            }
            return true;
          });
          // update fx
          ic.fx = (ic.fx || []).filter(f => {
            f.life -= dtSec * 1000;
            return f.life > 0;
          });
        },
        spawnIndoorFxBeam(x1, y1, x2, y2, color = '#9fd7ff', life = 280, thick = 4) {
          const ic = this.indoorCombat; if (!ic) return;
          ic.fx.push({ kind: 'beam', x1, y1, x2, y2, color, life, max: life, thick });
        },
        spawnIndoorFxBurst(x, y, color = '#ff6adf', life = 240) {
          const ic = this.indoorCombat; if (!ic) return;
          ic.fx.push({ kind: 'burst', x, y, color, life, max: life });
        },
        spawnIndoorFxSwordSwing(x, y, life = 300) {
          const ic = this.indoorCombat; if (!ic) return;
          ic.fx.push({ kind: 'sword_swing', x, y, life, max: life, frame: 0 });
        },
        spawnIndoorFxSlashWave(x, y, life = 600) {
          const ic = this.indoorCombat; if (!ic) return;
          ic.fx.push({ kind: 'slash_wave', x, y, life, max: life, frame: 0 });
        },
        spawnIndoorFxXSlash(x, y, life = 500) {
          const ic = this.indoorCombat; if (!ic) return;
          ic.fx.push({ kind: 'x_slash', x, y, life, max: life, frame: 0 });
        },
        spawnIndoorFxSummon(x, y, life = 800) {
          const ic = this.indoorCombat; if (!ic) return;
          ic.fx.push({ kind: 'summon', x, y, life, max: life, frame: 0 });
        },
        castIndoorSkillVfx(kind) {
          const ic = this.indoorCombat; if (!ic || !ic.active) return;
          const hero = this.hero;

          // Basic Attack - Sword Swing
          if (kind === 'ATTACK') {
            this.spawnIndoorFxSwordSwing(hero.x, hero.y - 14);
            this.spawnIndoorFxBurst(hero.x + 20, hero.y - 10, '#ff6b35', 200);
          }
          // S1 - Horizontal Slash Wave
          else if (kind === 'S1') {
            this.spawnIndoorFxSlashWave(hero.x, hero.y - 14);
            this.spawnIndoorFxBurst(hero.x + 20, hero.y - 10, '#51d7ff', 220);
          }
          // S2 - X-shaped Cross Slash
          else if (kind === 'S2') {
            this.spawnIndoorFxXSlash(hero.x, hero.y - 14);
            this.spawnIndoorFxBurst(hero.x, hero.y - 10, '#a78bfa', 240);
          }
          // S3 - Summoning Circle
          else if (kind === 'S3') {
            this.spawnIndoorFxSummon(hero.x, hero.y - 14);
            this.spawnIndoorFxBurst(hero.x, hero.y - 10, '#ffd56a', 280);
          }
          // S4, S5, SECRET - Original beam effect
          else {
            const tgt = (ic.enemies || []).reduce((best, e) => {
              const d = Math.hypot((e.x - hero.x), (e.y - hero.y));
              return d < (best?.d || 1e9) ? { e, d } : best;
            }, null)?.e;
            if (tgt) {
              const color = kind === 'S4' ? '#ff9aa8' : kind === 'S5' ? '#9aff9a' : '#b388ff';
              this.spawnIndoorFxBeam(hero.x, hero.y - 14, tgt.x, tgt.y - 12, color, 320, 5);
              this.spawnIndoorFxBurst(tgt.x, tgt.y - 10, color, 260);
            } else {
              this.spawnIndoorFxBurst(hero.x + 20, hero.y - 10, '#6aa8ff', 180);
            }
          }
        },
        drawIndoorCombat(ctx) {
          const ic = this.indoorCombat;
          if (!ic || !ic.active || !ic.enemies.length) return;
          ctx.save();
          ic.enemies.forEach((enemy) => {
            ctx.fillStyle = enemy.color || '#ff93d3';
            ctx.globalAlpha = 0.84;
            ctx.fillRect(enemy.x - 24, enemy.y - 24, 48, 48);
            ctx.globalAlpha = 1;
            const hpRatio = Math.max(0, Math.min(1, enemy.hp / (enemy.hpMax || 1)));
            ctx.fillStyle = 'rgba(16, 18, 28, 0.9)';
            ctx.fillRect(enemy.x - 28, enemy.y - 36, 56, 6);
            ctx.fillStyle = '#ff6adf';
            ctx.fillRect(enemy.x - 28, enemy.y - 36, 56 * hpRatio, 6);
            ctx.strokeStyle = 'rgba(255, 214, 106, 0.7)';
            ctx.strokeRect(enemy.x - 28 + 0.5, enemy.y - 36 + 0.5, 55, 5);
          });
          ctx.restore();
          // draw simple fx
          ctx.save();
          for (const fx of (ic.fx || [])) {
            fx.frame = (fx.frame || 0) + 1; // Animate frame counter
            const t = Math.max(0, Math.min(1, fx.life / (fx.max || 1)));
            ctx.globalAlpha = t;

            if (fx.kind === 'beam') {
              ctx.strokeStyle = fx.color;
              ctx.globalAlpha = 0.25 + 0.75 * t;
              ctx.lineWidth = (fx.thick || 4) * (0.6 + 0.4 * t);
              ctx.beginPath();
              ctx.moveTo(fx.x1, fx.y1);
              ctx.lineTo(fx.x2, fx.y2);
              ctx.stroke();
            } else if (fx.kind === 'burst') {
              ctx.fillStyle = fx.color;
              ctx.globalAlpha = 0.2 + 0.6 * t;
              ctx.beginPath();
              ctx.arc(fx.x, fx.y, 6 + 10 * (1 - t), 0, Math.PI * 2);
              ctx.fill();
            } else if (fx.kind === 'sword_swing') {
              // Sword Swing Arc
              const progress = fx.frame / 10;
              const angle = -Math.PI / 4 + progress * (Math.PI / 2);
              const radius = 50;
              ctx.strokeStyle = '#ff6b35';
              ctx.lineWidth = 6;
              ctx.lineCap = 'round';
              ctx.shadowBlur = 15;
              ctx.shadowColor = '#ff6b35';
              ctx.beginPath();
              const startX = fx.x + Math.cos(angle - 0.5) * radius;
              const startY = fx.y + Math.sin(angle - 0.5) * radius;
              const endX = fx.x + Math.cos(angle) * radius;
              const endY = fx.y + Math.sin(angle) * radius;
              ctx.moveTo(startX, startY);
              ctx.lineTo(endX, endY);
              ctx.stroke();
              ctx.shadowBlur = 0;
            } else if (fx.kind === 'slash_wave') {
              // Horizontal Slash Wave
              const progress = fx.frame / 20;
              const width = 80 + progress * 40;
              const height = 20;
              const offsetX = progress * 100;
              ctx.strokeStyle = '#51d7ff';
              ctx.fillStyle = 'rgba(81, 215, 255, 0.3)';
              ctx.lineWidth = 4;
              ctx.shadowBlur = 20;
              ctx.shadowColor = '#51d7ff';
              ctx.beginPath();
              ctx.moveTo(fx.x + offsetX - width / 2, fx.y - height / 2);
              ctx.quadraticCurveTo(fx.x + offsetX, fx.y, fx.x + offsetX + width / 2, fx.y + height / 2);
              ctx.lineTo(fx.x + offsetX + width / 2 - 10, fx.y + height / 2 - 5);
              ctx.quadraticCurveTo(fx.x + offsetX, fx.y, fx.x + offsetX - width / 2 + 10, fx.y - height / 2 + 5);
              ctx.closePath();
              ctx.fill();
              ctx.stroke();
              ctx.shadowBlur = 0;
            } else if (fx.kind === 'x_slash') {
              // X-shaped Cross Slash
              const progress = fx.frame / 15;
              const size = 60 + progress * 20;
              ctx.strokeStyle = '#a78bfa';
              ctx.lineWidth = 5;
              ctx.lineCap = 'round';
              ctx.shadowBlur = 18;
              ctx.shadowColor = '#a78bfa';
              ctx.beginPath();
              ctx.moveTo(fx.x - size / 2, fx.y - size / 2);
              ctx.lineTo(fx.x + size / 2, fx.y + size / 2);
              ctx.moveTo(fx.x + size / 2, fx.y - size / 2);
              ctx.lineTo(fx.x - size / 2, fx.y + size / 2);
              ctx.stroke();
              ctx.shadowBlur = 0;
            } else if (fx.kind === 'summon') {
              // Summoning Circle
              const progress = fx.frame / 24;
              const radius = 40 + progress * 30;
              const rotation = progress * Math.PI * 2;
              ctx.strokeStyle = '#ffd56a';
              ctx.lineWidth = 3;
              ctx.shadowBlur = 25;
              ctx.shadowColor = '#ffd56a';
              // Draw magic circle
              ctx.beginPath();
              ctx.arc(fx.x, fx.y, radius, 0, Math.PI * 2);
              ctx.stroke();
              // Draw rotating symbols
              for (let i = 0; i < 6; i++) {
                const angle = (i / 6) * Math.PI * 2 + rotation;
                const sx = fx.x + Math.cos(angle) * radius * 0.7;
                const sy = fx.y + Math.sin(angle) * radius * 0.7;
                ctx.fillStyle = '#ffd56a';
                ctx.beginPath();
                ctx.arc(sx, sy, 4, 0, Math.PI * 2);
                ctx.fill();
              }
              // Center glow
              const grd = ctx.createRadialGradient(fx.x, fx.y, 0, fx.x, fx.y, 25);
              grd.addColorStop(0, 'rgba(255, 213, 106, 0.6)');
              grd.addColorStop(1, 'rgba(255, 213, 106, 0)');
              ctx.fillStyle = grd;
              ctx.fillRect(fx.x - 25, fx.y - 25, 50, 50);
              ctx.shadowBlur = 0;
            }
          }
          ctx.restore();
        },
        strikeIndoorEnemy() {
          const ic = this.indoorCombat;
          if (!ic || !ic.active || !ic.enemies.length) return false;
          const hero = this.hero;
          let target = null;
          let bestDist = Infinity;
          for (const enemy of ic.enemies) {
            const dist = Math.hypot(enemy.x - hero.x, enemy.y - hero.y);
            if (dist < bestDist && dist <= 160) {
              target = enemy;
              bestDist = dist;
            }
          }
          if (!target) {
            try { notify('No training target nearby.', '#9fd7ff'); } catch (_) { }
            return false;
          }
          const dmg = Math.round(140 + Math.random() * 80);
          target.hp = Math.max(0, target.hp - dmg);
          addFloater(target.x, target.y - 34, `-${dmg}`, '#ff6aa8');
          try { addImpact && addImpact(target.x, target.y, '#ff6aa8'); } catch (_) { }
          this.spawnIndoorFxBeam(hero.x, hero.y - 14, target.x, target.y - 12, '#ff6aa8', 220, 4);
          if (target.hp <= 0) {
            ic.enemies = ic.enemies.filter((enemy) => enemy !== target);
            const goldReward = 500 + Math.floor(Math.random() * 4501); // 500-5000g
            const xpReward = 3;
            st.gold = (st.gold || 0) + goldReward;
            st.xp = (st.xp || 0) + xpReward;
            try { updateCurrencies(); } catch (_) { }
            try { updateXPBar && updateXPBar(); } catch (_) { }
            addFloater(target.x, target.y - 48, `+${goldReward}g`, '#ffd700');
            addFloater(target.x, target.y - 62, `+${xpReward} XP`, '#51d7ff');
            window.QuestSystem?.trackProgress?.('indoor_kill', 1, this.house?.type || 'house');
            try { notify(`Target defeated! +${goldReward}g +${xpReward} XP`, '#ffd700'); } catch (_) { }
            ic.spawnTimer = Math.min(ic.spawnTimer, 0.8);
          }
          return true;
        },
        interactWithHunter(hunter) {
          const st = window.st || (window.st = {});
          const msg = `${hunter.name} (Rank ${hunter.rank}) - ${hunter.service === 'shop' ? 'Shop' : hunter.service === 'training' ? 'Training' : 'Quests'}`;

          if (hunter.service === 'shop') {
            // Shop service
            let shopList = `\n=== ${hunter.name}'s Shop ===\n`;
            hunter.inventory.forEach((item, idx) => {
              shopList += `${idx + 1}. ${item.name} - ${item.cost}g\n`;
            });
            try { notify(msg + shopList, hunter.color); } catch (_) { }

            // Simple purchase (first item for demo)
            if (st.gold >= hunter.inventory[0].cost) {
              st.gold -= hunter.inventory[0].cost;
              try { updateCurrencies && updateCurrencies(); } catch (_) { }
              try { notify(`Purchased ${hunter.inventory[0].name}!`, '#ffd700'); } catch (_) { }
            }
          } else if (hunter.service === 'training') {
            // Training service
            try { notify(`${msg}\nAvailable training: Power Strike (+15 ATK) - 1000g`, hunter.color); } catch (_) { }
            if (st.gold >= 1000) {
              st.gold -= 1000;
              try { updateCurrencies && updateCurrencies(); } catch (_) { }
              try { notify('Training complete! +15 ATK boost!', '#51d7ff'); } catch (_) { }
            }
          } else if (hunter.service === 'quests') {
            // Quest service
            let questList = `\n=== ${hunter.name}'s Quests ===\n`;
            hunter.quests.forEach((q, idx) => {
              questList += `${idx + 1}. ${q.name} - ${q.target}\n   Reward: ${q.reward}g\n`;
            });
            try { notify(msg + questList, hunter.color); } catch (_) { }
          }
        },
        openComputerGames() {
          const st = window.st || (window.st = {});
          if (this.computerGames.cooldown > 0) {
            try { notify('Computer cooling down...', '#9fd7ff'); } catch (_) { }
            return;
          }

          const games = [
            'Coin Flip', 'Dice Roll', 'Number Guess',
            'Slots', 'Blackjack', 'Color Rush'
          ];
          const selectedGame = games[Math.floor(Math.random() * games.length)];
          this.computerGames.selectedGame = selectedGame;
          this.computerGames.cooldown = 1;

          this.playMiniGame(selectedGame, st);
        },
        playMiniGame(gameName, st) {
          const betAmount = 500 + Math.floor(Math.random() * 1000);

          if (st.gold < betAmount) {
            try { notify(`Need ${betAmount}g to play ${gameName}!`, '#ff6b35'); } catch (_) { }
            return;
          }

          let won = false;
          let winAmount = 0;

          switch (gameName) {
            case 'Coin Flip':
              won = Math.random() < 0.5;
              winAmount = won ? betAmount * 2 : 0;
              break;
            case 'Dice Roll':
              won = Math.random() < 0.166; // 1 in 6
              winAmount = won ? betAmount * 5 : 0;
              break;
            case 'Number Guess':
              const guess = Math.floor(Math.random() * 100);
              const target = Math.floor(Math.random() * 100);
              const diff = Math.abs(guess - target);
              won = diff < 10;
              winAmount = won ? betAmount * (3 - diff / 10) : 0;
              break;
            case 'Slots':
              const reels = [
                Math.floor(Math.random() * 5),
                Math.floor(Math.random() * 5),
                Math.floor(Math.random() * 5)
              ];
              if (reels[0] === reels[1] && reels[1] === reels[2]) {
                won = true;
                winAmount = betAmount * 10;
              } else if (reels[0] === reels[1] || reels[1] === reels[2]) {
                won = true;
                winAmount = betAmount * 2;
              }
              break;
            case 'Blackjack':
              const playerCard = Math.floor(Math.random() * 21) + 1;
              const dealerCard = Math.floor(Math.random() * 21) + 1;
              won = playerCard > dealerCard;
              winAmount = won ? betAmount * 2 : 0;
              break;
            case 'Color Rush':
              won = Math.random() < 0.3;
              winAmount = won ? betAmount * 4 : 0;
              break;
          }

          st.gold -= betAmount;

          if (won) {
            st.gold += winAmount;
            this.computerGames.totalWinnings += (winAmount - betAmount);
            this.computerGames.highScores[gameName] = Math.max(
              this.computerGames.highScores[gameName] || 0,
              winAmount
            );
            try { notify(`🎰 ${gameName} WON! +${winAmount}g`, '#ffd700'); } catch (_) { }
          } else {
            try { notify(`${gameName} Lost... -${betAmount}g`, '#ff6b35'); } catch (_) { }
          }

          try { updateCurrencies && updateCurrencies(); } catch (_) { }

          setTimeout(() => {
            this.computerGames.cooldown = 0;
          }, 1000);
        },
        getHouseDialog(type) {
          const map = {
            shop: "Welcome! Browse our finest wares. Gold accepted!",
            forge: "Need equipment upgraded? I can enhance your gear for a price.",
            apothecary: "Potions and elixirs! Healing, buffs, and more.",
            arcade: "Try your luck! Tokens get you prizes and mini-games.",
            blackmarket: "Psst... I have rare items. Don't ask where I got them.",
            library: "Knowledge is power. Check our skill books and lore.",
            kiosk: "Seek adventure? I have tasks for brave heroes.",
            shrine: "Blessings and buffs await those who offer tribute.",
            mail: "Messages and deliveries. Your mail hub.",
            workshop: "Crafting station open! Build tools and gadgets here.",
            arena: "Battle arena! Test your skills against waves of enemies.",
            photo: "Capture memories! Take screenshots with special filters."
          };
          return map[type] || "Welcome home! Rest, regroup, and prepare for the next adventure.";
        },
        getCounterKind(type) {
          switch (type) {
            case 'shop':
            case 'forge':
            case 'apothecary':
            case 'blackmarket':
              return 'shop';
            case 'kiosk':
              return 'quest';
            case 'arena':
              return 'arena';
            case 'workshop':
              return 'workshop';
            case 'library':
              return 'archives';
            case 'shrine':
              return 'shrine';
            case 'mail':
              return 'mail';
            case 'photo':
              return 'photo';
            default:
              return null;
          }
        },
        getCounterLabel(kind) {
          const labels = {
            shop: 'Shop Counter',
            quest: 'Quest Board',
            arena: 'Arena Desk',
            workshop: 'Workshop',
            archives: 'Archives',
            shrine: 'Shrine',
            mail: 'Mail Desk',
            photo: 'Photo Booth'
          };
          return labels[kind] || 'Counter';
        },
        getCounterColor(kind) {
          const colors = {
            shop: '#2a3b5a',
            quest: '#3b2a5a',
            arena: '#5a2a2a',
            workshop: '#2a5a46',
            archives: '#2a4a5a',
            shrine: '#4a2a5a',
            mail: '#2a4f5a',
            photo: '#5a2a45'
          };
          return colors[kind] || '#2e3b55';
        },
        enter(h) {
          this.active = true; this.house = h || null;
          this.stopIndoorCombat();
          window.MouseControls?.clearInteriorTarget?.();
          const houseType = this.house?.type || 'home';
          if (houseType === 'arcade') {
            this.setupArcadeHouse();
            return;
          }
          // position hero near door
          const W = (typeof DESIGN_W !== 'undefined' ? DESIGN_W : 1280);
          const H = (typeof DESIGN_H !== 'undefined' ? DESIGN_H : 720);
          this.hero.x = Math.floor(W / 2); this.hero.y = H - 190; this.hero.vx = this.hero.vy = 0;
          // spawn two followers trailing behind
          this.followers = [
            { x: this.hero.x - 30, y: this.hero.y + 8, w: 18, h: 24, color: '#6aa8ff' },
            { x: this.hero.x - 60, y: this.hero.y + 12, w: 18, h: 24, color: '#ff8c6a' },
          ];
          // place door at bottom center
          this.objs.door = { x: Math.floor(W / 2) - 21, y: H - 170, w: 42, h: 36 };
          // spawn one chest + one npc (universal), plus contextual counter
          this.objs.chests = [{ x: Math.floor(W * 0.28), y: H - 220, w: 28, h: 20, opened: false }];
          this.objs.npcs = [{ x: Math.floor(W * 0.68), y: H - 220, w: 20, h: 26, name: 'Roomie', talk: 'Welcome to the Candy House!' }];
          this.objs.counters = [];
          const t = (this.house?.type || 'home');
          const counterKind = this.getCounterKind(t);
          if (counterKind) {
            this.objs.counters.push({ x: Math.floor(W / 2), y: H - 250, w: 148, h: 24, kind: counterKind });
          }

          // Initialize Hunters (C, B, S rank)
          this.hunters = [
            {
              rank: 'C',
              name: 'Hunter Jake',
              x: Math.floor(W * 0.25),
              y: H - 220,
              w: 22,
              h: 28,
              service: 'shop',
              color: '#8bc34a',
              inventory: [
                { name: 'Health Potion', cost: 100, effect: 'heal', value: 50 },
                { name: 'Strength Elixir', cost: 250, effect: 'atkBoost', value: 10 },
                { name: 'Basic Gear', cost: 500, effect: 'defBoost', value: 5 }
              ]
            },
            {
              rank: 'B',
              name: 'Hunter Aria',
              x: Math.floor(W * 0.50),
              y: H - 220,
              w: 22,
              h: 28,
              service: 'training',
              color: '#2196f3',
              skills: [
                { name: 'Power Strike', cost: 1000, effect: 'atkBoost', value: 15 },
                { name: 'Iron Skin', cost: 1500, effect: 'defBoost', value: 20 },
                { name: 'Swift Dash', cost: 1200, effect: 'speedBoost', value: 25 }
              ]
            },
            {
              rank: 'S',
              name: 'Hunter Zephyr',
              x: Math.floor(W * 0.75),
              y: H - 220,
              w: 22,
              h: 28,
              service: 'quests',
              color: '#9c27b0',
              quests: [
                { name: 'Elite Hunt', reward: 5000, target: 'Defeat 10 indoor enemies', progress: 0, goal: 10 },
                { name: 'Speed Run', reward: 10000, target: 'Clear 5 waves in 2 minutes', completed: false },
                { name: 'Perfect Clear', reward: 20000, target: 'Take no damage', completed: false }
              ]
            }
          ];

          // Initialize Combat Pets
          this.pets = [
            {
              type: 'cat',
              name: 'Shadow',
              x: this.hero.x - 30,
              y: this.hero.y + 15,
              w: 16,
              h: 16,
              following: 'player',
              buff: { atkBoost: 10, critChance: 5 },
              offset: { x: -30, y: 10 },
              color: '#795548',
              switchTimer: 10 + Math.random() * 5
            },
            {
              type: 'dog',
              name: 'Spark',
              x: Math.floor(W * 0.25) + 30,
              y: H - 205,
              w: 18,
              h: 18,
              following: 'hunter_0',
              buff: { defBoost: 15, hpRegen: 2 },
              offset: { x: 30, y: 10 },
              color: '#ff9800',
              switchTimer: 10 + Math.random() * 5
            }
          ];

          this.startIndoorCombat();
          try { Platform.enabled = false; } catch (_) { }
          try { notify && notify('Entered House', '#6aa8ff'); } catch (_) { }
        },
        exit() {
          window.MouseControls?.clearInteriorTarget?.();
          this.active = false;
          this.house = null;
          this.objs.chests = [];
          this.objs.npcs = [];
          this.objs.counters = [];
          this.followers = [];
          this.hunters = [];
          this.pets = [];
          this.computerGames.active = false;
          this.computerGames.selectedGame = null;
          this.stopIndoorCombat();
          this.arcadeState.machines = [];
          this.arcadeState.neonSigns = [];
          this.arcadeState.leaderboard = [];
          this.arcadeState.prizes = [];
          this.arcadeState.hiddenChest = null;
          this.arcadeState.visibleChest = null;
          this.arcadeState.counter = null;
          this.arcadeState.animation.glowTimer = 0;
          this.arcadeState.animation.leaderboardOffset = 0;
          this.arcadeState.animation.prizeRotation = 0;
          this.arcadeState.animation.glitchTimer = 0;
          this.arcadeState.animation.glitchVisible = true;
          try { Platform.enabled = true; } catch (_) { }
          try { notify && notify('Exited House', '#6aa8ff'); } catch (_) { }
        },
        setupArcadeHouse() {
          const W = (typeof DESIGN_W !== 'undefined' ? DESIGN_W : 1280);
          const H = (typeof DESIGN_H !== 'undefined' ? DESIGN_H : 720);
          this.hero.x = Math.floor(W * 0.5);
          this.hero.y = H - 210;
          this.hero.vx = this.hero.vy = 0;
          this.followers = [
            { x: this.hero.x - 36, y: this.hero.y + 10, w: 18, h: 24, color: '#5f9bff' },
            { x: this.hero.x - 66, y: this.hero.y + 16, w: 18, h: 24, color: '#fd83b1' }
          ];
          this.objs.door = { x: Math.floor(W * 0.5) - 24, y: H - 175, w: 48, h: 44 };

          const arcade = this.arcadeState;
          arcade.animation.glowTimer = 0;
          arcade.animation.leaderboardOffset = 0;
          arcade.animation.prizeRotation = 0;
          arcade.animation.glitchTimer = 0;
          arcade.animation.glitchVisible = true;
          arcade.highlightMachineId = null;
          arcade.prompt = '';

          const baseChest = { x: Math.floor(W * 0.28), y: H - 255, w: 28, h: 22, opened: false, glow: '#ffdd73' };
          const secretChest = { x: Math.floor(W * 0.12), y: Math.floor(H * 0.36), w: 26, h: 20, opened: false, hidden: true, glow: '#a06bff' };
          arcade.visibleChest = baseChest;
          arcade.hiddenChest = secretChest;
          this.objs.chests = [baseChest, secretChest];

          const spawnGlitch = Math.random() < 0.3;
          const npcBaseY = H - 250;
          const npcs = [
            { x: Math.floor(W * 0.5), y: npcBaseY, w: 22, h: 28, name: 'Pixel', role: 'owner', talk: 'Welcome to Missy\'s Arcade!', color: '#ff6b9d' },
            { x: Math.floor(W * 0.21), y: npcBaseY + 20, w: 22, h: 28, name: 'Token', role: 'vendor', talk: 'Trade tickets for sweet prizes!', color: '#4dd0e1' },
            { x: Math.floor(W * 0.79), y: npcBaseY + 12, w: 22, h: 28, name: 'Combo', role: 'keeper', talk: 'Chasing the high score?', color: '#ffd54f' }
          ];
          if (spawnGlitch) {
            npcs.push({ x: Math.floor(W * 0.86), y: Math.floor(H * 0.35), w: 20, h: 26, name: 'Glitch', role: 'secret', talk: '...0101...', color: '#9c27b0', flicker: true });
          }
          this.objs.npcs = npcs;

          const machines = [
            {
              id: 'arc_rps',
              name: 'Rock Duel',
              gameType: 'rps',
              x: Math.floor(W * 0.16),
              y: H - 320,
              w: 90,
              h: 150,
              theme: '#ff8a65',
              accent: '#ffd180',
              screen: 'RPS DUEL',
              interactable: true
            },
            {
              id: 'arc_slots',
              name: 'Lucky Slots',
              gameType: 'slots',
              x: Math.floor(W * 0.32),
              y: H - 330,
              w: 92,
              h: 155,
              theme: '#26c6da',
              accent: '#80deea',
              screen: 'SLOTS',
              interactable: true
            },
            {
              id: 'arc_missy',
              name: 'Missy Prime',
              gameType: 'missy',
              x: Math.floor(W * 0.48),
              y: H - 340,
              w: 96,
              h: 160,
              theme: '#7e57c2',
              accent: '#b39ddb',
              screen: 'MISSY',
              interactable: true
            },
            {
              id: 'arc_platformer',
              name: 'Coin Climb',
              gameType: 'platformer',
              x: Math.floor(W * 0.64),
              y: H - 330,
              w: 92,
              h: 155,
              theme: '#ff6bb5',
              accent: '#ffb5e8',
              screen: 'COIN RUN',
              interactable: true
            },
            {
              id: 'arc_racing',
              name: 'Hyper Drift',
              gameType: 'racing',
              x: Math.floor(W * 0.80),
              y: H - 320,
              w: 90,
              h: 150,
              theme: '#4dd0e1',
              accent: '#b2ebf2',
              screen: 'RACER',
              interactable: true
            }
          ];

          arcade.machines = machines;
          arcade.neonSigns = [
            { text: 'HIGH SCORE', x: Math.floor(W * 0.73), y: Math.floor(H * 0.18), color: '#71c7ff', shadow: '#123f7b' },
            { text: 'GAME OVER', x: Math.floor(W * 0.27), y: Math.floor(H * 0.18), color: '#ff627b', shadow: '#4e1020' }
          ];
          arcade.leaderboard = [
            { name: 'MISSY', score: 99999, color: '#ff6b9d' },
            { name: 'A1K', score: 85000, color: '#6aa8ff' },
            { name: 'PLAYER', score: 64210, color: '#ffd54f' },
            { name: 'BOT-42', score: 51200, color: '#9c27b0' },
            { name: 'CANDY', score: 49880, color: '#4dd0e1' }
          ];
          arcade.prizes = [
            { name: 'Candy Comet', tickets: 50, color: '#ffb5e8' },
            { name: 'Cake Slice', tickets: 120, color: '#ffd3a5' },
            { name: 'Diamond Token', tickets: 250, color: '#b5f5ff' },
            { name: 'Starlight Plush', tickets: 400, color: '#ffe08a' },
            { name: 'Rainbow Pass', tickets: 650, color: '#a1ffce' }
          ];
          arcade.counter = { x: Math.floor(W * 0.5), y: npcBaseY - 18, w: 220, h: 40, kind: 'arcade', color: '#331f4a' };
          this.objs.counters = [{ x: arcade.counter.x, y: arcade.counter.y, w: arcade.counter.w, h: 32, kind: 'arcade' }];
          window.MouseControls?.clearInteriorTarget?.();

          try { Platform.enabled = false; } catch (_) { }
          try { notify && notify('Missy\'s Arcade unlocked!', '#ff6b9d'); } catch (_) { }
        },
        step(dt) {
          if (!this.active) return;
          const h = this.hero;
          const dtSec = dt || 0.016;
          const houseType = this.house?.type || 'home';

          let autoMove = false;
          if (window.MouseControls?.updateInteriorMovement) {
            autoMove = window.MouseControls.updateInteriorMovement(this, dtSec);
          }

          if (!autoMove) {
            // Read keyboard input
            let kbdMoveX = (this.keys.right ? 1 : 0) - (this.keys.left ? 1 : 0);
            let kbdMoveY = (this.keys.down ? 1 : 0) - (this.keys.up ? 1 : 0);

            // Read analog/joystick input
            const analogX = typeof window.joyX === 'number' ? window.joyX : 0;
            const analogY = typeof window.joyY === 'number' ? window.joyY : 0;

            // Prioritize keyboard input over analog - only use analog if keyboard is idle
            // This prevents stick drift from causing auto-movement when using keyboard
            let moveX = (kbdMoveX !== 0) ? kbdMoveX : (Math.abs(analogX) > 0.25 ? analogX : 0);
            let moveY = (kbdMoveY !== 0) ? kbdMoveY : (Math.abs(analogY) > 0.25 ? analogY : 0);

            if (moveX !== 0 || moveY !== 0) {
              window.MouseControls?.clearInteriorTarget?.();
            }
            h.vx = moveX;
            h.vy = moveY;
            const sp = h.speed * dtSec;
            h.x += h.vx * sp;
            h.y += h.vy * sp;
          }

          const W = (typeof DESIGN_W !== 'undefined' ? DESIGN_W : 1280), H = (typeof DESIGN_H !== 'undefined' ? DESIGN_H : 720);
          const minX = 60, maxX = W - 60;
          const minY = 120, maxY = H - 180;
          if (h.x < minX) h.x = minX;
          if (h.x > maxX) h.x = maxX;
          if (h.y < minY) h.y = minY;
          if (h.y > maxY) h.y = maxY;
          for (let i = 0; i < this.followers.length; i++) {
            const f = this.followers[i];
            const target = i === 0 ? h : this.followers[i - 1];
            f.x += (target.x - (i === 0 ? 30 : 24) - f.x) * 6 * dtSec;
            f.y += (target.y + (i === 0 ? 8 : 12) - f.y) * 6 * dtSec;
          }

          // Update pets AI
          for (const pet of this.pets) {
            pet.switchTimer -= dtSec;
            if (pet.switchTimer <= 0) {
              // Switch follow target randomly
              const targets = ['player', 'hunter_0', 'hunter_1', 'hunter_2'];
              pet.following = targets[Math.floor(Math.random() * targets.length)];
              pet.switchTimer = 10 + Math.random() * 5;
            }

            // Get follow target
            let targetEntity = null;
            if (pet.following === 'player') {
              targetEntity = h;
            } else if (pet.following.startsWith('hunter_')) {
              const idx = parseInt(pet.following.split('_')[1]);
              targetEntity = this.hunters[idx];
            }

            if (targetEntity) {
              const targetX = targetEntity.x + pet.offset.x;
              const targetY = targetEntity.y + pet.offset.y;
              const speed = 4;
              pet.x += (targetX - pet.x) * speed * dtSec;
              pet.y += (targetY - pet.y) * speed * dtSec;
            }
          }

          if (houseType === 'arcade') {
            this.updateArcadeAnimations(dtSec);
            this.updateArcadeInteractables();
          } else {
            this.updateIndoorCombat(dtSec);
          }
        },
        interact() {
          if (!this.active) return false;
          const h = this.hero;
          const houseType = this.house?.type || 'home';
          const D = this.objs.door;
          if (h.x > D.x && h.x < D.x + D.w && Math.abs(h.y - D.y) < 24) {
            this.exit();
            return true;
          }
          const st = window.st || (window.st = {});
          for (const c of this.objs.chests) {
            if (!c.opened && Math.abs(h.x - c.x) < 26 && Math.abs(h.y - c.y) < 26) {
              c.opened = true;
              const reward = c.hidden ? 500 : 200;
              st.gold = (st.gold || 0) + reward;
              try { window.updateCurrencies?.(); } catch (_) { }
              try { window.QuestSystem?.trackProgress?.('gold', reward); } catch (_) { }
              try {
                notify(c.hidden ? 'Secret Cache Found! +500g' : '+200g (House Chest)', c.hidden ? '#b388ff' : '#ffd56a');
              } catch (_) { }
              return true;
            }
          }
          for (const c of this.objs.counters) {
            if (Math.abs(h.x - c.x) < (c.w / 2 + 6) && Math.abs(h.y - c.y) < 26) {
              let handled = false;
              try {
                switch (c.kind) {
                  case 'shop': {
                    handled = true;
                    try { notify('Opening Shop...', '#9fd7ff'); } catch (_) { }
                    if (window.ShopSystem?.openShop) {
                      window.ShopSystem.openShop({ houseType });
                    } else {
                      const shopBtn = document.getElementById('shopBtn');
                      if (shopBtn) shopBtn.click();
                      else notify?.('Shop UI not available', '#ff7a6a');
                    }
                    break;
                  }
                  case 'quest': {
                    handled = true;
                    if (window.QuestSystem?.openQuestBoard) {
                      window.QuestSystem.openQuestBoard();
                    } else {
                      notify?.('Quest Board coming soon!', '#9fd7ff');
                    }
                    break;
                  }
                  case 'arena': {
                    handled = true;
                    try { notify('Arena challenge initiated!', '#ff6b35'); } catch (_) { }
                    if (window.ArenaSystem?.startArena) {
                      window.ArenaSystem.startArena();
                    } else {
                      notify?.('Arena system unavailable.', '#ff7a6a');
                    }
                    break;
                  }
                  case 'arcade': {
                    handled = true;
                    try {
                      window.MissyArcadeGame?.ensureOverlay?.();
                      window.MissyArcadeGame?.activate?.({ source: 'house-counter' });
                      if (!window.MissyArcadeGame?.active) {
                        try { window.open('Missy Arcade.html', '_blank'); } catch (_) { }
                      }
                    } catch (_) {
                      try { window.open('Missy Arcade.html', '_blank'); } catch (err) { notify?.('Arcade launch failed.', '#ff7a6a'); }
                    }
                    break;
                  }
                  case 'workshop': {
                    handled = true;
                    if (typeof window.openCraftingPanel === 'function') {
                      window.openCraftingPanel();
                    } else {
                      notify?.('Workshop tools are not set up yet.', '#9fd7ff');
                    }
                    break;
                  }
                  case 'archives': {
                    handled = true;
                    notify?.('Browse the archives for advanced skill books and lore entries.', '#9fd7ff');
                    break;
                  }
                  case 'shrine': {
                    handled = true;
                    notify?.('Offer tribute at the shrine to receive blessings.', '#caa6ff');
                    break;
                  }
                  case 'mail': {
                    handled = true;
                    notify?.('Mail services are preparing deliveries. Check back soon!', '#9fd7ff');
                    break;
                  }
                  case 'photo': {
                    handled = true;
                    notify?.('Pose for a snapshot! Fancy filters coming soon.', '#ff9aa8');
                    break;
                  }
                  default:
                    break;
                }
              } catch (err) {
                console.warn('[HouseInterior] counter interaction failed', err);
              }
              if (!handled) {
                notify?.('Nothing to interact with here yet.', '#9fd7ff');
              }
              return true;
            }
          }

          if (houseType === 'arcade') {
            const machine = this.getNearestArcadeMachine(h, 120);
            if (machine) {
              this.activateArcadeMachine(machine);
              return true;
            }
          }

          // Check hunter interactions
          for (const hunter of (this.hunters || [])) {
            if (Math.abs(h.x - hunter.x) < 30 && Math.abs(h.y - hunter.y) < 30) {
              this.interactWithHunter(hunter);
              return true;
            }
          }

          // Check computer interaction (near counter for computer games)
          if (houseType === 'home' && this.objs.counters.length > 0) {
            const counter = this.objs.counters[0];
            if (Math.abs(h.x - counter.x) < 80 && Math.abs(h.y - counter.y) < 50) {
              this.openComputerGames();
              return true;
            }
          }

          for (const n of this.objs.npcs) {
            if (Math.abs(h.x - n.x) < 26 && Math.abs(h.y - n.y) < 26) {
              if (houseType === 'arcade') {
                if (n.role === 'keeper') {
                  this.showLeaderboard && this.showLeaderboard();
                } else if (n.role === 'vendor') {
                  this.showPrizeInfo && this.showPrizeInfo();
                } else if (n.role === 'secret') {
                  const glitchLines = ['010100 Welcome...', 'Glitch sees all high scores.', 'Find the hidden chest.'];
                  try { notify(glitchLines[Math.floor(Math.random() * glitchLines.length)], n.color || '#cfa7ff'); } catch (_) { }
                }
              }
              const color = n.color || '#9fd7ff';
              if (houseType === 'arcade' && n.talk) {
                try { notify(n.talk, color); } catch (_) { }
              }
              const buildingLine = this.getHouseDialog(houseType);
              if (buildingLine) {
                try { notify(buildingLine, color); } catch (_) { }
              } else if (n.talk) {
                try { notify(n.talk, color); } catch (_) { }
              }
              return true;
            }
          }
          return false;
        },
        draw(ctx) {
          const houseType = this.house?.type || 'home';
          if (houseType === 'arcade') {
            this.drawArcadeInterior(ctx);
            return;
          }
          const W = (typeof DESIGN_W !== 'undefined' ? DESIGN_W : (ctx?.canvas?.width || 1280));
          const H = (typeof DESIGN_H !== 'undefined' ? DESIGN_H : (ctx?.canvas?.height || 720));
          ctx.clearRect(0, 0, W, H);
          ctx.fillStyle = '#21121b'; ctx.fillRect(0, 0, W, H);
          for (let y = 0; y < H; y += 24) { ctx.fillStyle = (Math.floor(y / 24) % 2 ? '#27131d' : '#22111a'); ctx.fillRect(0, y, W, 24); }
          ctx.fillStyle = '#161c26'; ctx.fillRect(0, H - 160, W, 160);
          const cx = Math.floor(W * 0.42), cy = H - 200;
          ctx.fillStyle = '#253247'; ctx.fillRect(cx - 40, cy, 140, 20);
          ctx.fillStyle = '#2e3b55'; ctx.fillRect(cx, cy - 28, 60, 28);
          ctx.fillStyle = '#0e141d'; ctx.fillRect(cx + 70, cy - 42, 48, 36);
          ctx.strokeStyle = '#00E5FF'; ctx.strokeRect(cx + 70.5, cy - 41.5, 47, 35);
          ctx.fillStyle = '#cde7ff'; ctx.textAlign = 'center'; ctx.font = 'bold 16px ui-monospace, monospace';
          ctx.fillText((this.house?.label || 'House'), W / 2, 60);
          ctx.font = '12px ui-monospace, monospace'; ctx.fillText('Press Esc/A near door to Exit', W / 2, 90);
          // draw props
          // door
          const D = this.objs.door; ctx.fillStyle = '#0e141d'; ctx.fillRect(D.x, D.y, D.w, D.h); ctx.strokeStyle = '#9fd7ff'; ctx.strokeRect(D.x + 0.5, D.y + 0.5, D.w - 1, D.h - 1);
          // chest
          for (const c of this.objs.chests) { ctx.fillStyle = c.opened ? '#999' : '#c0902b'; ctx.fillRect(c.x - 14, c.y - 10, 28, 20); ctx.strokeStyle = '#6a552e'; ctx.strokeRect(c.x - 14.5, c.y - 10.5, 29, 21); }
          // counters
          for (const c of this.objs.counters) {
            const color = this.getCounterColor(c.kind);
            const label = this.getCounterLabel(c.kind);
            ctx.fillStyle = color;
            ctx.fillRect(c.x - c.w / 2, c.y - 12, c.w, 24);
            ctx.strokeStyle = '#9fd7ff';
            ctx.strokeRect(c.x - c.w / 2 + 0.5, c.y - 11.5, c.w - 1, 23);
            ctx.fillStyle = '#cde7ff';
            ctx.font = '12px ui-monospace, monospace';
            ctx.textAlign = 'center';
            ctx.fillText(label, c.x, c.y - 18);
          }
          this.drawIndoorCombat(ctx);
          // npc
          for (const n of this.objs.npcs) { ctx.fillStyle = '#9a6bff'; ctx.fillRect(n.x - 10, n.y - 13, 20, 26); ctx.fillStyle = '#e6e6fa'; ctx.fillRect(n.x - 4, n.y - 9, 8, 8); }

          // hunters
          for (const hunter of (this.hunters || [])) {
            ctx.save();
            ctx.fillStyle = hunter.color || '#8bc34a';
            ctx.fillRect(hunter.x - 11, hunter.y - 14, 22, 28);
            // Draw rank badge
            ctx.fillStyle = 'rgba(0,0,0,0.7)';
            ctx.fillRect(hunter.x - 8, hunter.y - 22, 16, 12);
            ctx.fillStyle = '#ffd700';
            ctx.font = 'bold 10px monospace';
            ctx.textAlign = 'center';
            ctx.fillText(hunter.rank, hunter.x, hunter.y - 13);
            // Draw name
            ctx.fillStyle = '#cfe3ff';
            ctx.font = '8px monospace';
            ctx.fillText(hunter.name.split(' ')[1], hunter.x, hunter.y - 26);
            ctx.restore();
          }

          // pets
          for (const pet of (this.pets || [])) {
            ctx.save();
            ctx.fillStyle = pet.color || '#795548';
            ctx.fillRect(pet.x - pet.w / 2, pet.y - pet.h / 2, pet.w, pet.h);
            // Draw buff aura
            ctx.strokeStyle = pet.type === 'cat' ? '#ff6b35' : '#51d7ff';
            ctx.globalAlpha = 0.5 + 0.3 * Math.sin(Date.now() / 200);
            ctx.lineWidth = 2;
            ctx.strokeRect(pet.x - pet.w / 2 - 2, pet.y - pet.h / 2 - 2, pet.w + 4, pet.h + 4);
            ctx.restore();
          }

          // hero + followers (simple pixel avatars)
          for (const f of (this.followers || [])) { ctx.fillStyle = f.color || '#6aa8ff'; ctx.fillRect(f.x - 9, f.y - 12, 18, 24); }
          const h = this.hero; ctx.fillStyle = '#ff4d4f'; ctx.fillRect(h.x - 9, h.y - 12, 18, 24);
          window.MouseControls?.drawInteriorTarget?.(ctx);
        },
        drawArcadeInterior(ctx) {
          const W = (typeof DESIGN_W !== 'undefined' ? DESIGN_W : (ctx?.canvas?.width || 1280));
          const H = (typeof DESIGN_H !== 'undefined' ? DESIGN_H : (ctx?.canvas?.height || 720));
          const arcade = this.arcadeState || {};
          ctx.clearRect(0, 0, W, H);

          // Background gradient to establish neon arcade atmosphere
          const bgGrad = ctx.createLinearGradient(0, 0, 0, H);
          bgGrad.addColorStop(0, '#1b1040');
          bgGrad.addColorStop(0.35, '#2b1469');
          bgGrad.addColorStop(0.7, '#1d0f33');
          bgGrad.addColorStop(1, '#080414');
          ctx.fillStyle = bgGrad;
          ctx.fillRect(0, 0, W, H);

          // Ceiling glow strip
          const ceilingGrad = ctx.createLinearGradient(0, 0, 0, 120);
          ceilingGrad.addColorStop(0, 'rgba(255, 143, 255, 0.38)');
          ceilingGrad.addColorStop(1, 'rgba(0, 0, 0, 0)');
          ctx.fillStyle = ceilingGrad;
          ctx.fillRect(0, 0, W, 160);

          // Draw diagonal neon beams to add energy
          ctx.save();
          ctx.globalAlpha = 0.25;
          ctx.fillStyle = '#ff6b9d';
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.lineTo(W * 0.32, 0);
          ctx.lineTo(W * 0.08, H * 0.28);
          ctx.lineTo(0, H * 0.18);
          ctx.closePath();
          ctx.fill();
          ctx.fillStyle = '#4dd0e1';
          ctx.beginPath();
          ctx.moveTo(W, 0);
          ctx.lineTo(W, H * 0.22);
          ctx.lineTo(W * 0.72, 0);
          ctx.closePath();
          ctx.fill();
          ctx.restore();

          // Neon checkered floor
          const tile = 56;
          const rows = Math.ceil((H - 200) / tile);
          const cols = Math.ceil(W / tile);
          for (let y = 0; y < rows; y++) {
            for (let x = 0; x < cols; x++) {
              const isEven = (x + y) % 2 === 0;
              const baseY = H - rows * tile + y * tile;
              ctx.fillStyle = isEven ? 'rgba(39, 15, 73, 0.85)' : 'rgba(26, 12, 54, 0.9)';
              ctx.fillRect(x * tile, baseY, tile, tile);
              ctx.strokeStyle = 'rgba(129, 212, 250, 0.08)';
              ctx.strokeRect(x * tile + 0.5, baseY + 0.5, tile - 1, tile - 1);
            }
          }

          // Center glow rug
          ctx.save();
          const rugGrad = ctx.createRadialGradient(W / 2, H - 260, 10, W / 2, H - 220, 260);
          rugGrad.addColorStop(0, 'rgba(255, 107, 157, 0.36)');
          rugGrad.addColorStop(0.5, 'rgba(81, 45, 168, 0.15)');
          rugGrad.addColorStop(1, 'rgba(14, 8, 32, 0)');
          ctx.fillStyle = rugGrad;
          ctx.fillRect(0, H - 420, W, 320);
          ctx.restore();

          // Title banner
          ctx.save();
          const bannerGrad = ctx.createLinearGradient(W * 0.22, 120, W * 0.78, 120);
          bannerGrad.addColorStop(0, '#ff6b9d');
          bannerGrad.addColorStop(0.5, '#a566ff');
          bannerGrad.addColorStop(1, '#4dd0e1');
          ctx.fillStyle = bannerGrad;
          ctx.shadowColor = '#ff9de2';
          ctx.shadowBlur = 24;
          ctx.font = 'bold 48px "Audiowide", "Press Start 2P", ui-monospace';
          ctx.textAlign = 'center';
          ctx.fillText("MISSY'S ARCADE", W / 2, 140);
          ctx.restore();

          // Draw signage bars behind title
          ctx.fillStyle = 'rgba(255, 255, 255, 0.05)';
          ctx.fillRect(W * 0.2, 152, W * 0.6, 6);
          ctx.fillRect(W * 0.25, 164, W * 0.5, 4);

          // Neon signs (HIGH SCORE / GAME OVER)
          if (Array.isArray(arcade.neonSigns)) {
            ctx.save();
            ctx.font = '24px "Press Start 2P", ui-monospace';
            ctx.textAlign = 'center';
            for (const sign of arcade.neonSigns) {
              const pulse = 0.5 + 0.5 * Math.sin(arcade.animation.glowTimer * 1.6);
              ctx.shadowColor = sign.color;
              ctx.shadowBlur = 24 + pulse * 12;
              ctx.fillStyle = sign.color;
              ctx.fillText(sign.text, sign.x, sign.y);
            }
            ctx.restore();
          }

          // Helper to draw arcade machines
          const drawMachine = (machine, glowPhase) => {
            if (!machine) return;
            const { x, y, w, h, theme, accent, screen, name, id } = machine;
            const isHighlight = arcade.highlightMachineId && arcade.highlightMachineId === id;
            ctx.save();
            const bodyGradient = ctx.createLinearGradient(x, y, x, y + h);
            bodyGradient.addColorStop(0, theme);
            bodyGradient.addColorStop(1, '#1a0f2d');
            ctx.fillStyle = bodyGradient;
            ctx.shadowColor = theme;
            ctx.shadowBlur = isHighlight ? 42 : 18 + glowPhase * 20;
            ctx.fillRect(x - w / 2, y - h, w, h);
            ctx.shadowBlur = 0;

            // Screen
            const screenHeight = h * 0.38;
            ctx.fillStyle = '#000';
            ctx.fillRect(x - w / 2 + 12, y - h + 16, w - 24, screenHeight);
            ctx.fillStyle = accent || '#ffe082';
            ctx.font = '12px "Press Start 2P", ui-monospace';
            ctx.textAlign = 'center';
            ctx.fillText(screen || 'ARCADE', x, y - h + 16 + screenHeight / 2);

            // Controls
            ctx.fillStyle = accent || '#ffe082';
            ctx.fillRect(x - w / 2 + 14, y - h + screenHeight + 32, w - 28, 16);
            ctx.fillStyle = '#111';
            ctx.beginPath();
            ctx.arc(x - 12, y - h + screenHeight + 40, 6, 0, Math.PI * 2);
            ctx.arc(x + 12, y - h + screenHeight + 40, 6, 0, Math.PI * 2);
            ctx.fill();
            if (name) {
              ctx.fillStyle = '#ffe9ff';
              ctx.font = '10px "Press Start 2P", ui-monospace';
              ctx.fillText(name.toUpperCase(), x, y - 10);
            }
            if (isHighlight) {
              ctx.strokeStyle = accent || '#ffe082';
              ctx.lineWidth = 3;
              ctx.globalAlpha = 0.85;
              ctx.strokeRect(x - w / 2 + 4, y - h + 6, w - 8, h - 12);
              ctx.globalAlpha = 1;
            }
            ctx.restore();
          };

          const glowPhase = 0.4 + 0.6 * Math.sin(arcade.animation.glowTimer * 1.4);
          if (Array.isArray(arcade.machines)) {
            for (const machine of arcade.machines) drawMachine(machine, glowPhase);
          }

          // Arcade counter
          if (arcade.counter) {
            const c = arcade.counter;
            ctx.save();
            const counterGrad = ctx.createLinearGradient(c.x - c.w / 2, c.y - 24, c.x + c.w / 2, c.y + 24);
            counterGrad.addColorStop(0, '#2c1457');
            counterGrad.addColorStop(1, '#401f6b');
            ctx.fillStyle = counterGrad;
            ctx.shadowColor = '#9f79ff';
            ctx.shadowBlur = 22;
            ctx.fillRect(c.x - c.w / 2, c.y - 18, c.w, 44);
            ctx.shadowBlur = 0;
            ctx.strokeStyle = '#ffb5e8';
            ctx.strokeRect(c.x - c.w / 2 + 0.5, c.y - 18 + 0.5, c.w - 1, 44 - 1);
            ctx.fillStyle = '#ffe9ff';
            ctx.font = '14px "Press Start 2P", ui-monospace';
            ctx.textAlign = 'center';
            ctx.fillText('PIXEL COUNTER', c.x, c.y - 24);
            ctx.restore();
          }

          // Leaderboard panel
          const boardX = Math.floor(W * 0.82);
          const boardY = Math.floor(H * 0.32);
          const boardWidth = 240;
          const boardHeight = 260;
          ctx.save();
          ctx.fillStyle = 'rgba(18, 27, 55, 0.92)';
          ctx.fillRect(boardX - boardWidth / 2, boardY - 40, boardWidth, boardHeight);
          ctx.strokeStyle = '#4dd0e1';
          ctx.strokeRect(boardX - boardWidth / 2 + 0.5, boardY - 40 + 0.5, boardWidth - 1, boardHeight - 1);
          ctx.font = '16px "Press Start 2P", ui-monospace';
          ctx.textAlign = 'center';
          ctx.fillStyle = '#4dd0e1';
          ctx.fillText('LEADERBOARD', boardX, boardY - 12);
          ctx.font = '12px "Press Start 2P", ui-monospace';
          ctx.textAlign = 'left';
          const lb = arcade.leaderboard || [];
          const offset = arcade.animation.leaderboardOffset || 0;
          for (let i = 0; i < lb.length; i++) {
            const entry = lb[(i + Math.floor(offset)) % lb.length];
            const rowY = boardY + 20 + i * 28;
            ctx.fillStyle = entry?.color || '#fff';
            const displayScore = entry?.score != null ? entry.score.toString().padStart(5, '0') : '00000';
            ctx.fillText(`${i + 1}. ${entry?.name || '???'}`, boardX - boardWidth / 2 + 18, rowY);
            ctx.textAlign = 'right';
            ctx.fillText(displayScore, boardX + boardWidth / 2 - 18, rowY);
            ctx.textAlign = 'left';
          }
          ctx.restore();

          // Prize display
          const prizePanelX = Math.floor(W * 0.18);
          const prizePanelY = Math.floor(H * 0.34);
          const prizePanelWidth = 240;
          const prizePanelHeight = 240;
          ctx.save();
          ctx.fillStyle = 'rgba(34, 16, 46, 0.9)';
          ctx.fillRect(prizePanelX - prizePanelWidth / 2, prizePanelY - 40, prizePanelWidth, prizePanelHeight);
          ctx.strokeStyle = '#ff6b9d';
          ctx.strokeRect(prizePanelX - prizePanelWidth / 2 + 0.5, prizePanelY - 40 + 0.5, prizePanelWidth - 1, prizePanelHeight - 1);
          ctx.font = '16px "Press Start 2P", ui-monospace';
          ctx.textAlign = 'center';
          ctx.fillStyle = '#ff6b9d';
          ctx.fillText('PRIZE SHELF', prizePanelX, prizePanelY - 12);

          const prizes = arcade.prizes || [];
          ctx.font = '11px "Press Start 2P", ui-monospace';
          const rotation = arcade.animation.prizeRotation || 0;
          prizes.forEach((prize, index) => {
            const row = Math.floor(index / 2);
            const col = index % 2;
            const px = prizePanelX - prizePanelWidth / 2 + 40 + col * 110;
            const py = prizePanelY + 16 + row * 58;
            const pulse = 0.6 + 0.4 * Math.sin(rotation + index);
            ctx.fillStyle = prize?.color ? `${prize.color}cc` : '#ffffffcc';
            ctx.save();
            ctx.translate(px, py);
            ctx.rotate(Math.sin(rotation * 0.6 + index) * 0.08);
            ctx.fillRect(-32, -20, 64, 40);
            ctx.fillStyle = '#141226';
            ctx.fillRect(-24, -12, 48, 24);
            ctx.restore();
            ctx.fillStyle = '#ffdff8';
            ctx.textAlign = 'center';
            ctx.fillText(prize?.name || 'Prize', px, py + 34);
            ctx.fillStyle = '#9ad9ff';
            ctx.fillText(`${prize?.tickets || 0} tix`, px, py + 48);
            ctx.fillStyle = `rgba(255, 255, 255, ${0.25 * pulse})`;
            ctx.fillRect(px - 32, py - 22, 64, 4);
          });
          ctx.restore();

          // Door with neon outline
          const door = this.objs.door || { x: W / 2 - 30, y: H - 190, w: 60, h: 60 };
          ctx.save();
          ctx.fillStyle = '#05060d';
          ctx.fillRect(door.x, door.y, door.w, door.h);
          ctx.strokeStyle = '#71c7ff';
          ctx.lineWidth = 3;
          ctx.strokeRect(door.x + 1.5, door.y + 1.5, door.w - 3, door.h - 3);
          ctx.restore();

          // Chests (visible + hidden)
          for (const chest of this.objs.chests || []) {
            const nearHero = Math.hypot((this.hero.x - chest.x), (this.hero.y - chest.y)) < 46;
            const highlight = chest.hidden ? (nearHero ? 0.9 : 0.3) : 1;
            ctx.save();
            ctx.fillStyle = chest.opened ? 'rgba(120, 120, 120, 0.9)' : `rgba(204, 144, 43, ${0.85 * highlight})`;
            ctx.fillRect(chest.x - chest.w / 2, chest.y - chest.h / 2, chest.w, chest.h);
            ctx.strokeStyle = chest.hidden ? '#b388ff' : '#6a552e';
            ctx.lineWidth = 2;
            ctx.strokeRect(chest.x - chest.w / 2 + 0.5, chest.y - chest.h / 2 + 0.5, chest.w - 1, chest.h - 1);
            if (chest.hidden && !chest.opened) {
              ctx.globalAlpha = 0.35 + 0.25 * Math.sin(this.arcadeState.animation.glowTimer * 3);
              ctx.fillStyle = chest.glow || '#a06bff';
              ctx.beginPath();
              ctx.arc(chest.x, chest.y - chest.h / 2, 14, 0, Math.PI * 2);
              ctx.fill();
            }
            ctx.restore();
          }

          // NPCs
          ctx.save();
          ctx.textAlign = 'center';
          for (const npc of this.objs.npcs || []) {
            if (!npc) continue;
            const isGlitch = npc.role === 'secret';
            const flicker = isGlitch ? (this.arcadeState.animation.glitchVisible ? 1 : 0.2) : 1;
            const bodyColor = npc.color || '#ffffff';
            ctx.globalAlpha = flicker;
            const height = npc.h || 28;
            const width = npc.w || 22;
            ctx.fillStyle = bodyColor;
            ctx.fillRect(npc.x - width / 2, npc.y - height / 2, width, height);
            ctx.fillStyle = '#0e0820';
            ctx.fillRect(npc.x - width / 4, npc.y - height / 4, width / 2, height / 2);
            ctx.fillStyle = '#ffe9ff';
            ctx.font = '11px "Press Start 2P", ui-monospace';
            ctx.fillText(npc.name || 'NPC', npc.x, npc.y - height / 2 - 12);
            ctx.globalAlpha = 1;
          }
          ctx.restore();

          // Followers and hero stylized avatars
          const renderAvatar = (x, y, colorPrimary, colorSecondary, pulseValue = 0) => {
            ctx.save();
            ctx.fillStyle = colorPrimary;
            ctx.fillRect(x - 10, y - 14, 20, 28);
            ctx.fillStyle = colorSecondary;
            ctx.fillRect(x - 6, y - 10, 12, 12);
            if (pulseValue > 0) {
              ctx.globalAlpha = 0.4 + 0.4 * pulseValue;
              ctx.fillStyle = colorPrimary;
              ctx.beginPath();
              ctx.arc(x, y + 14, 10 + pulseValue * 8, 0, Math.PI);
              ctx.fill();
            }
            ctx.restore();
          };

          for (const follower of this.followers || []) {
            renderAvatar(follower.x, follower.y, follower.color || '#6aa8ff', '#fff', Math.max(glowPhase, 0));
          }
          renderAvatar(this.hero.x, this.hero.y, '#ff6b9d', '#ffe9ff', Math.abs(Math.sin(Math.max(glowPhase, 0) * Math.PI)));
          window.MouseControls?.drawInteriorTarget?.(ctx);

          // Tickets HUD (canvas overlay)
          const st = window.st || {};
          const tickets = st.tickets || 0;
          ctx.save();
          ctx.font = '18px "Press Start 2P", ui-monospace';
          ctx.textAlign = 'left';
          ctx.fillStyle = '#ffe9ff';
          ctx.shadowColor = 'rgba(255, 107, 157, 0.6)';
          ctx.shadowBlur = 12;
          ctx.fillText(`🎫 Tickets: ${tickets}`, 32, 64);
          ctx.restore();

          // Machine prompt near hero
          if (arcade.prompt) {
            const promptX = this.hero.x;
            const promptY = this.hero.y - 80;
            ctx.save();
            ctx.textAlign = 'center';
            ctx.font = '16px "Press Start 2P", ui-monospace';
            const metricsWidth = ctx.measureText(arcade.prompt).width + 40;
            ctx.fillStyle = 'rgba(14, 8, 32, 0.75)';
            ctx.strokeStyle = '#ffb5e8';
            ctx.lineWidth = 2;
            const rx = 12;
            const px = promptX - metricsWidth / 2;
            const py = promptY - 24;
            const pw = metricsWidth;
            const ph = 40;
            ctx.beginPath();
            ctx.moveTo(px + rx, py);
            ctx.lineTo(px + pw - rx, py);
            ctx.quadraticCurveTo(px + pw, py, px + pw, py + rx);
            ctx.lineTo(px + pw, py + ph - rx);
            ctx.quadraticCurveTo(px + pw, py + ph, px + pw - rx, py + ph);
            ctx.lineTo(px + rx, py + ph);
            ctx.quadraticCurveTo(px, py + ph, px, py + ph - rx);
            ctx.lineTo(px, py + rx);
            ctx.quadraticCurveTo(px, py, px + rx, py);
            ctx.fill();
            ctx.stroke();
            ctx.fillStyle = '#ffe9ff';
            ctx.fillText(arcade.prompt, promptX, promptY + 6);
            ctx.restore();
          }

          // HUD text
          ctx.save();
          ctx.font = '12px "Press Start 2P", ui-monospace';
          ctx.fillStyle = '#9ad9ff';
          ctx.textAlign = 'center';
          ctx.fillText('Use arrow keys / WASD to explore. Press A or Enter to interact.', W / 2, H - 36);
          ctx.restore();

          // Overlay subtle animated glows
          this.animateArcadeEffects(ctx);
        },
        animateArcadeEffects(ctx) {
          const W = (typeof DESIGN_W !== 'undefined' ? DESIGN_W : (ctx?.canvas?.width || 1280));
          const H = (typeof DESIGN_H !== 'undefined' ? DESIGN_H : (ctx?.canvas?.height || 720));
          const arcade = this.arcadeState;
          if (!arcade) return;
          const glowPhase = 0.5 + 0.5 * Math.sin(arcade.animation.glowTimer * 2.0);

          // Machine glow sweep
          ctx.save();
          ctx.globalCompositeOperation = 'lighter';
          for (const machine of arcade.machines || []) {
            const width = machine.w || 80;
            const height = machine.h || 140;
            const sweepX = machine.x - width / 2 + (width + 40) * glowPhase;
            const sweepGrad = ctx.createRadialGradient(sweepX, machine.y - height / 2, 10, sweepX, machine.y - height / 2, 80);
            sweepGrad.addColorStop(0, 'rgba(255,255,255,0.35)');
            sweepGrad.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = sweepGrad;
            ctx.fillRect(machine.x - width / 2 - 40, machine.y - height, width + 80, height + 40);
          }

          // Leaderboard glow pulse
          const boardX = Math.floor(W * 0.82);
          const boardY = Math.floor(H * 0.32);
          const boardWidth = 240;
          ctx.fillStyle = `rgba(77, 208, 225, ${0.1 + glowPhase * 0.1})`;
          ctx.fillRect(boardX - boardWidth / 2, boardY - 52, boardWidth, 12);

          // Prize spotlight rotation
          const rotation = arcade.animation.prizeRotation || 0;
          const spotGrad = ctx.createRadialGradient(W * 0.18, H * 0.36, 24, W * 0.18, H * 0.36, 220);
          spotGrad.addColorStop(0, `rgba(255, 107, 157, ${0.25 + 0.15 * Math.sin(rotation * 1.2)})`);
          spotGrad.addColorStop(1, 'rgba(255, 107, 157, 0)');
          ctx.fillStyle = spotGrad;
          ctx.fillRect(W * 0.18 - 180, H * 0.2, 360, 260);

          ctx.restore();
        },
        updateArcadeAnimations(dt) {
          const arcade = this.arcadeState;
          if (!arcade) return;
          const anim = arcade.animation;
          const delta = dt || 0.016;
          anim.glowTimer += anim.glowSpeed * delta;
          anim.prizeRotation += delta * 1.2;
          anim.leaderboardOffset = (anim.leaderboardOffset + delta * 1.25) % Math.max(arcade.leaderboard?.length || 1, 1);
          anim.glitchTimer += delta * 5.6;
          if (anim.glitchTimer >= 1) {
            anim.glitchTimer = 0;
            anim.glitchVisible = Math.random() > 0.35;
          }
        },
        getNearestArcadeMachine(hero, maxDistance = 110) {
          const machines = this.arcadeState?.machines || [];
          if (!machines.length) return null;
          const hx = hero?.x ?? 0;
          const hy = hero?.y ?? 0;
          let best = null;
          let bestDist = maxDistance;
          for (const m of machines) {
            if (!m?.interactable) continue;
            const mx = m.x;
            const my = m.y - m.h * 0.5;
            const dist = Math.hypot(hx - mx, hy - my);
            if (dist < bestDist) {
              bestDist = dist;
              best = m;
            }
          }
          return best;
        },
        updateArcadeInteractables() {
          if (!this.arcadeState) return;
          if (window.ArcadeMachineSystem?.isActive?.()) {
            this.arcadeState.highlightMachineId = null;
            this.arcadeState.prompt = '';
            return;
          }
          const machine = this.getNearestArcadeMachine(this.hero, 120);
          if (machine) {
            this.arcadeState.highlightMachineId = machine.id;
            const label = machine.name || machine.screen || machine.gameType?.toUpperCase?.() || 'Arcade Game';
            this.arcadeState.prompt = `Press A: Play ${label}`;
          } else {
            this.arcadeState.highlightMachineId = null;
            this.arcadeState.prompt = '';
          }
        },
        activateArcadeMachine(machine) {
          if (!machine) return false;
          if (this.arcadeState) {
            this.arcadeState.highlightMachineId = machine.id || null;
            this.arcadeState.prompt = '';
          }
          if (machine.gameType === 'missy') {
            try {
              if (window.MissyArcadeGame?.activate) {
                window.MissyArcadeGame.activate({ source: machine.id || 'arcade-machine' });
                return true;
              }
            } catch (err) {
              console.warn('[HouseInterior] Missy Arcade activation failed', err);
            }
            try { window.open('Missy Arcade.html', '_blank'); return true; } catch (_) { }
            notify?.('Missy Arcade system unavailable.', '#ff7a6a');
            return false;
          }
          if (window.ArcadeMachineSystem?.start) {
            window.ArcadeMachineSystem.start(machine);
            return true;
          }
          notify?.('Arcade machine is offline.', '#ff7a6a');
          return false;
        },
        showLeaderboard() {
          const lb = this.arcadeState?.leaderboard || [];
          if (!lb.length) { try { notify('No leaderboard data yet!', '#4dd0e1'); } catch (_) { } return; }
          const lines = lb.slice(0, 5).map((entry, idx) => `${idx + 1}. ${entry.name || '???'} — ${entry.score ?? 0}`);
          const message = `Arcade Leaderboard:\n${lines.join('\n')}`;
          try { notify(message, '#4dd0e1'); } catch (_) { console.log(message); }
        },
        showPrizeInfo() {
          const prizes = this.arcadeState?.prizes || [];
          if (!prizes.length) { try { notify('Prizes are being restocked. Come back soon!', '#ffd54f'); } catch (_) { } return; }
          const lines = prizes.map(prize => `${prize.name || 'Prize'} — ${prize.tickets || 0} tickets`);
          const message = `Available Prizes:\n${lines.join('\n')}`;
          try { notify(message, '#ffd54f'); } catch (_) { console.log(message); }
        }
      };
      if (!window.__bindHouseInteriorKeys) {
        window.__bindHouseInteriorKeys = true;
        const handleKeyDown = (e) => {
          const code = e.code || '';
          if (window.MissyArcadeGame?.active) {
            if (code === 'Escape') { try { window.MissyArcadeGame.requestExit(); } catch (_) { } }
            e.preventDefault();
            return;
          }
          if (!window.HouseInterior?.active) return;
          switch (code) {
            case 'Escape':
              window.HouseInterior.exit();
              e.preventDefault();
              break;
            case 'Space':
              if (window.HouseInterior?.strikeIndoorEnemy) {
                window.HouseInterior.strikeIndoorEnemy();
                window.HouseInterior.castIndoorSkillVfx?.('ATTACK');
                e.preventDefault();
                break;
              }
            case 'ArrowLeft':
              window.HouseInterior.keys.left = true;
              e.preventDefault();
              break;
            case 'ArrowRight':
              window.HouseInterior.keys.right = true;
              e.preventDefault();
              break;
            case 'ArrowUp':
              window.HouseInterior.keys.up = true;
              e.preventDefault();
              break;
            case 'ArrowDown':
              window.HouseInterior.keys.down = true;
              e.preventDefault();
              break;
            case 'Enter':
              try { window.HouseInterior.interact(); } catch (_) { }
              e.preventDefault();
              break;
            case 'KeyF':
              if (window.HouseInterior?.strikeIndoorEnemy) {
                window.HouseInterior.strikeIndoorEnemy();
                window.HouseInterior.castIndoorSkillVfx?.('ATTACK');
                e.preventDefault();
              }
              break;
            case 'KeyJ':
            case 'KeyK':
            case 'KeyL':
              if (window.HouseInterior?.strikeIndoorEnemy) {
                window.HouseInterior.strikeIndoorEnemy();
                window.HouseInterior.castIndoorSkillVfx?.('ATTACK');
                e.preventDefault();
              }
              break;
            case 'Digit1':
              if (window.HouseInterior?.strikeIndoorEnemy) {
                window.HouseInterior.strikeIndoorEnemy();
                window.HouseInterior.castIndoorSkillVfx?.('S1');
                e.preventDefault();
              }
              break;
            case 'Digit2':
              if (window.HouseInterior?.strikeIndoorEnemy) {
                window.HouseInterior.strikeIndoorEnemy();
                window.HouseInterior.castIndoorSkillVfx?.('S2');
                e.preventDefault();
              }
              break;
            case 'Digit3':
              if (window.HouseInterior?.strikeIndoorEnemy) {
                window.HouseInterior.strikeIndoorEnemy();
                window.HouseInterior.castIndoorSkillVfx?.('S3');
                e.preventDefault();
              }
              break;
            case 'Digit4':
            case 'Digit5':
              if (window.HouseInterior?.strikeIndoorEnemy) {
                window.HouseInterior.strikeIndoorEnemy();
                window.HouseInterior.castIndoorSkillVfx?.(code);
                e.preventDefault();
              }
              break;
            default:
              break;
          }
        };

        const handleKeyUp = (e) => {
          const code = e.code || '';
          if (window.MissyArcadeGame?.active) {
            e.preventDefault();
            return;
          }
          if (!window.HouseInterior?.active) return;
          switch (code) {
            case 'ArrowLeft':
              window.HouseInterior.keys.left = false;
              break;
            case 'ArrowRight':
              window.HouseInterior.keys.right = false;
              break;
            case 'ArrowUp':
              window.HouseInterior.keys.up = false;
              break;
            case 'ArrowDown':
              window.HouseInterior.keys.down = false;
              break;
            default:
              break;
          }
        };

        addEventListener('keydown', handleKeyDown, true);
        addEventListener('keyup', handleKeyUp, true);
      }
      // Self-test harness: Ctrl+Shift+H triggers an enter attempt; hash '#houseTest' runs once on load
      window.__HOUSE_TEST = {
        runOnce() { try { if (window.enterNearestHouse) { const ok = window.enterNearestHouse(); console.log('[HOUSE_TEST] enterNearestHouse =>', ok); if (!ok) setTimeout(() => window.enterNearestHouse && window.enterNearestHouse(), 300); } } catch (_) { } },
        runFull() { try { const list = (Platform.layers?.houses) || []; let idx = 0; const loop = () => { if (idx >= list.length) return; const h = list[idx++]; try { const L = (st.players?.[st.leader || 0]); if (L) { L.x = h.door.x; L.y = h.door.y - 16; } const ok = window.enterNearestHouse && window.enterNearestHouse(); setTimeout(() => { const H = window.HouseInterior; if (!H) { loop(); return; } const c = H.objs.chests[0]; if (c) { H.hero.x = c.x; H.hero.y = c.y; H.interact(); } setTimeout(() => { const n = H.objs.npcs[0]; if (n) { H.hero.x = n.x; H.hero.y = n.y; H.interact(); } setTimeout(() => { const D = H.objs.door; H.hero.x = D.x + 2; H.hero.y = D.y; H.interact(); setTimeout(loop, 300); }, 350); }, 350); }, 400); } catch (_) { setTimeout(loop, 300); } }; loop(); } catch (_) { console.log('[HOUSE_TEST] runFull error'); } }
      };
      addEventListener('keydown', (e) => { if (e.key === 'H' && e.ctrlKey && e.shiftKey) { e.preventDefault(); try { window.__HOUSE_TEST.runOnce(); } catch (_) { } } });
      try { if ((location.hash || '').includes('houseTest')) setTimeout(() => window.__HOUSE_TEST.runOnce(), 500); } catch (_) { }
    })();

    // ========================================
    // PHASE 1: TEAM MANAGEMENT SYSTEM
    // ========================================
    window.TeamManagementSystem = (function () {
      'use strict';

      const state = {
        roster: [], // Unified roster: players, tamed, summons, AI
        activeTeam: [], // Currently deployed team (max 6)
        maxTeamSize: 6,
        formations: {
          line: { name: 'Line Formation', positions: [0, 50, 100, 150, 200, 250] },
          arrow: { name: 'Arrow Formation', positions: [0, 40, 80, -40, -80, 120] },
          circle: { name: 'Circle Formation', positions: [0, 60, 120, 180, 240, 300] }
        },
        currentFormation: 'line',
        presets: [null, null, null], // 3 preset slots
        modalOpen: false,
        initialized: false
      };

      // === CORE TEAM MANAGEMENT ===

      function addToRoster(member, type = 'player') {
        if (!member || !member.id) {
          console.warn('[TeamMgmt] Invalid member, no ID');
          return false;
        }

        if (state.roster.find(m => m.id === member.id)) {
          return false;
        }

        const teamMember = {
          ...member,
          teamType: type,
          joinedAt: Date.now(),
          combatStats: {
            kills: 0,
            damage: 0,
            assists: 0,
            deaths: 0
          },
          active: false,
          formationIndex: -1
        };

        state.roster.push(teamMember);
        if (typeof notify === 'function') {
          notify(`${member.name || 'New Ally'} joined your roster!`, '#4CAF50');
        }
        saveRoster();
        return true;
      }

      function tameEnemy(enemy) {
        if (!enemy) return false;

        const tamedMember = {
          id: `tamed_${enemy.id || Date.now()}`,
          name: enemy.kind || 'Tamed Enemy',
          teamType: 'tamed',
          hp: enemy.max || enemy.hp || 100,
          hpMax: enemy.max || enemy.hp || 100,
          atk: enemy.atk || 20,
          def: enemy.def || 10,
          spd: Math.abs(enemy.vx || 2) * 30,
          x: enemy.x || 0,
          y: enemy.y || 0,
          sprite: enemy.sprite || null,
          color: enemy.color || '#ff6b6b',
          w: enemy.w || 32,
          h: enemy.h || 32,
          aiEnabled: true,
          behavior: 'follow',
          attackRange: 150,
          attackCooldown: 1000,
          lastAttack: 0,
          skills: enemy.skills || [],
          originalKind: enemy.kind,
          originalWave: enemy.wave || 0
        };

        return addToRoster(tamedMember, 'tamed');
      }

      function addSummonToTeam(summon) {
        if (!summon || !summon.id) return false;

        const summonMember = {
          id: summon.id,
          name: summon.name || 'Summon',
          teamType: 'summon',
          hp: summon.hp || summon.hpMax || 100,
          hpMax: summon.hpMax || 100,
          atk: summon.dmg || summon.atk || 15,
          def: summon.def || 5,
          spd: 5,
          x: summon.x,
          y: summon.y,
          color: summon.color || '#00E5FF',
          w: summon.w || 28,
          h: summon.h || 28,
          attackRange: summon.attackRadius || 200,
          attackCooldown: summon.attackCD || 1000,
          healAmount: summon.healAmount || 0,
          healCD: summon.healCD || 0,
          owner: summon.owner,
          duration: summon.duration || -1,
          summonRef: summon
        };

        return addToRoster(summonMember, 'summon');
      }

      function addAIToTeam(ai) {
        if (!ai || !ai.id) return false;

        const aiMember = {
          id: ai.id,
          name: ai.name || ai.kind || 'AI Companion',
          teamType: 'ai',
          hp: ai.hp || 150,
          hpMax: ai.hpMax || 150,
          atk: ai.atk || 25,
          def: ai.def || 8,
          spd: ai.speed || 4,
          x: ai.x,
          y: ai.y,
          color: '#5ba3ff',
          w: ai.w || 32,
          h: ai.h || 32,
          kind: ai.kind,
          mode: ai.mode || 'follow',
          targetMode: ai.targetMode || 'nearest',
          aiRef: ai
        };

        return addToRoster(aiMember, 'ai');
      }

      function deployMember(memberId) {
        const member = state.roster.find(m => m.id === memberId);
        if (!member) return false;

        if (state.activeTeam.length >= state.maxTeamSize) {
          if (typeof notify === 'function') {
            notify('Team is full! Remove a member first.', '#ff7043');
          }
          return false;
        }

        member.active = true;
        member.formationIndex = state.activeTeam.length;
        state.activeTeam.push(member);

        applyFormation();
        saveRoster();
        return true;
      }

      function removeMember(memberId) {
        const index = state.activeTeam.findIndex(m => m.id === memberId);
        if (index === -1) return false;

        const member = state.activeTeam[index];
        member.active = false;
        member.formationIndex = -1;

        state.activeTeam.splice(index, 1);

        state.activeTeam.forEach((m, i) => {
          m.formationIndex = i;
        });

        applyFormation();
        saveRoster();
        return true;
      }

      function applyFormation() {
        const st = window.st;
        if (!st) return;

        const leader = st.players?.[st.leader || 0];
        if (!leader) return;

        const formation = state.formations[state.currentFormation];
        if (!formation) return;

        state.activeTeam.forEach((member, index) => {
          const offset = formation.positions[index] || (index * 50);

          if (member.teamType === 'player') {
            const playerObj = st.players?.find(p => p.id === member.id);
            if (playerObj) {
              playerObj.followDistance = offset;
            }
          } else if (member.teamType === 'tamed' || member.teamType === 'ai') {
            member.followDistance = offset;
            member.targetX = leader.x - offset;
            member.targetY = leader.y;
          } else if (member.teamType === 'summon' && member.summonRef) {
            member.summonRef.followDistance = offset;
          }
        });
      }

      function setFormation(formationName) {
        if (!state.formations[formationName]) {
          console.warn('[TeamMgmt] Unknown formation:', formationName);
          return false;
        }

        state.currentFormation = formationName;
        applyFormation();
        if (typeof notify === 'function') {
          notify(`Formation: ${state.formations[formationName].name}`, '#2196F3');
        }
        return true;
      }

      function savePreset(name, slotIndex = 0) {
        if (slotIndex < 0 || slotIndex > 2) {
          console.warn('[TeamMgmt] Invalid preset slot:', slotIndex);
          return false;
        }

        const preset = {
          name: name || `Preset ${slotIndex + 1}`,
          formation: state.currentFormation,
          members: state.activeTeam.map(m => ({
            id: m.id,
            type: m.teamType,
            formationIndex: m.formationIndex
          })),
          createdAt: Date.now()
        };

        state.presets[slotIndex] = preset;
        saveRoster();
        if (typeof notify === 'function') {
          notify(`Team preset saved: ${preset.name}`, '#4CAF50');
        }
        return true;
      }

      function loadPreset(slotIndex) {
        const preset = state.presets[slotIndex];
        if (!preset) {
          if (typeof notify === 'function') {
            notify('No preset saved in this slot', '#ff7043');
          }
          return false;
        }

        state.activeTeam.forEach(m => {
          m.active = false;
          m.formationIndex = -1;
        });
        state.activeTeam = [];

        preset.members.forEach(pm => {
          const member = state.roster.find(m => m.id === pm.id);
          if (member) {
            deployMember(member.id);
          }
        });

        setFormation(preset.formation);

        if (typeof notify === 'function') {
          notify(`Loaded preset: ${preset.name}`, '#4CAF50');
        }
        return true;
      }

      // === PERSISTENCE ===

      function saveRoster() {
        try {
          const data = {
            roster: state.roster.map(m => ({
              ...m,
              summonRef: null,
              aiRef: null,
              owner: null
            })),
            activeTeam: state.activeTeam.map(m => m.id),
            currentFormation: state.currentFormation,
            presets: state.presets
          };
          localStorage.setItem('a1k_team_roster', JSON.stringify(data));
        } catch (error) {
          console.error('[TeamMgmt] Failed to save roster:', error);
        }
      }

      function loadRoster() {
        try {
          const saved = localStorage.getItem('a1k_team_roster');
          if (!saved) return;

          const data = JSON.parse(saved);

          state.roster = (data.roster || []).filter(m =>
            m.teamType === 'player' || m.teamType === 'tamed'
          );

          state.currentFormation = data.currentFormation || 'line';
          state.presets = data.presets || [null, null, null];

          console.log('[TeamMgmt] Loaded', state.roster.length, 'roster members');
        } catch (error) {
          console.error('[TeamMgmt] Failed to load roster:', error);
        }
      }

      // === UI MODAL ===

      function createModal() {
        const modal = document.createElement('div');
        modal.id = 'teamManagementModal';
        modal.style.cssText = `
          position: fixed;
          inset: 0;
          background: rgba(0,0,0,0.85);
          display: none;
          align-items: center;
          justify-content: center;
          z-index: 6000;
        `;

        const panel = document.createElement('div');
        panel.style.cssText = `
          background: linear-gradient(145deg, #1a2332, #0f1824);
          border: 2px solid #345d8a;
          border-radius: 16px;
          width: 800px;
          max-width: 95vw;
          max-height: 90vh;
          display: flex;
          flex-direction: column;
          box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        `;

        const header = document.createElement('div');
        header.style.cssText = `
          padding: 20px 24px;
          background: linear-gradient(90deg, #2a3f5f, #1e3049);
          border-bottom: 1px solid #345d8a;
          display: flex;
          justify-content: space-between;
          align-items: center;
        `;
        header.innerHTML = `
          <h2 style="margin:0;color:#e0f2ff;font-size:22px;">⚔️ Team Management</h2>
          <button id="closeTeamModal" style="background:#ff5252;border:none;color:#fff;padding:8px 16px;border-radius:6px;cursor:pointer;font-weight:600;">Close</button>
        `;

        const body = document.createElement('div');
        body.style.cssText = `
          flex: 1;
          overflow-y: auto;
          padding: 20px;
        `;

        const tabs = document.createElement('div');
        tabs.style.cssText = `
          display: flex;
          gap: 12px;
          margin-bottom: 20px;
          border-bottom: 2px solid #345d8a;
          padding-bottom: 8px;
        `;
        tabs.innerHTML = `
          <button class="team-tab active" data-tab="active" style="padding:10px 20px;border:none;background:#345d8a;color:#fff;border-radius:8px 8px 0 0;cursor:pointer;font-weight:600;">Active Team (${state.activeTeam.length}/${state.maxTeamSize})</button>
          <button class="team-tab" data-tab="roster" style="padding:10px 20px;border:none;background:#1e3049;color:#9baec8;border-radius:8px 8px 0 0;cursor:pointer;font-weight:600;">Full Roster (${state.roster.length})</button>
          <button class="team-tab" data-tab="presets" style="padding:10px 20px;border:none;background:#1e3049;color:#9baec8;border-radius:8px 8px 0 0;cursor:pointer;font-weight:600;">Presets</button>
        `;

        const content = document.createElement('div');
        content.id = 'teamModalContent';
        content.style.cssText = `
          display: flex;
          flex-direction: column;
          gap: 12px;
        `;

        body.appendChild(tabs);
        body.appendChild(content);

        const formationBar = document.createElement('div');
        formationBar.style.cssText = `
          padding: 12px 20px;
          background: #0f1824;
          border-top: 1px solid #345d8a;
          display: flex;
          gap: 12px;
          align-items: center;
        `;
        formationBar.innerHTML = `
          <span style="color:#9baec8;font-weight:600;">Formation:</span>
          <select id="formationSelect" style="padding:8px;background:#1e3049;color:#fff;border:1px solid #345d8a;border-radius:6px;cursor:pointer;">
            ${Object.keys(state.formations).map(key =>
          `<option value="${key}" ${state.currentFormation === key ? 'selected' : ''}>${state.formations[key].name}</option>`
        ).join('')}
          </select>
        `;

        panel.appendChild(header);
        panel.appendChild(body);
        panel.appendChild(formationBar);
        modal.appendChild(panel);
        document.body.appendChild(modal);

        modal.querySelector('#closeTeamModal').addEventListener('click', closeModal);
        modal.addEventListener('click', (e) => {
          if (e.target === modal) closeModal();
        });

        tabs.querySelectorAll('.team-tab').forEach(tab => {
          tab.addEventListener('click', () => {
            tabs.querySelectorAll('.team-tab').forEach(t => {
              t.classList.remove('active');
              t.style.background = '#1e3049';
              t.style.color = '#9baec8';
            });
            tab.classList.add('active');
            tab.style.background = '#345d8a';
            tab.style.color = '#fff';
            renderTab(tab.dataset.tab);
          });
        });

        formationBar.querySelector('#formationSelect').addEventListener('change', (e) => {
          setFormation(e.target.value);
        });

        return modal;
      }

      function renderTab(tabName) {
        const content = document.getElementById('teamModalContent');
        if (!content) return;

        content.innerHTML = '';

        if (tabName === 'active') {
          renderActiveTeam(content);
        } else if (tabName === 'roster') {
          renderFullRoster(content);
        } else if (tabName === 'presets') {
          renderPresets(content);
        }
      }

      function renderActiveTeam(container) {
        if (state.activeTeam.length === 0) {
          container.innerHTML = `
            <div style="text-align:center;padding:40px;color:#9baec8;">
              <p style="font-size:18px;">No active team members</p>
              <p style="font-size:14px;margin-top:8px;">Switch to Roster tab to deploy members</p>
            </div>
          `;
          return;
        }

        // Use enhanced status panels instead of basic cards
        container.innerHTML = `
          <div style="margin-bottom: 20px;">
            <h3 style="color: #e0f2ff; margin-bottom: 12px;">Active Team Members</h3>
            ${state.activeTeam.map(member => renderEnhancedStatusPanel(member)).join('')}
          </div>
          
          <!-- Quick Actions -->
          <div style="display: flex; gap: 8px; margin-top: 16px;">
            <button onclick="window.TeamManagementSystem.autoFormation()" style="
              padding: 8px 16px; background: #4CAF50; color: #fff; border: none; 
              border-radius: 6px; cursor: pointer; font-weight: 600;
            ">Auto Formation</button>
            <button onclick="window.TeamManagementSystem.healAll()" style="
              padding: 8px 16px; background: #2196F3; color: #fff; border: none; 
              border-radius: 6px; cursor: pointer; font-weight: 600;
            ">Heal All</button>
          </div>
        `;
      }

      function renderFullRoster(container) {
        if (state.roster.length === 0) {
          container.innerHTML = `
            <div style="text-align:center;padding:40px;color:#9baec8;">
              <p style="font-size:18px;">No team members yet</p>
              <p style="font-size:14px;margin-top:8px;">Tame enemies or summon allies to build your roster!</p>
            </div>
          `;
          return;
        }

        const groups = {
          player: state.roster.filter(m => m.teamType === 'player'),
          tamed: state.roster.filter(m => m.teamType === 'tamed'),
          summon: state.roster.filter(m => m.teamType === 'summon'),
          ai: state.roster.filter(m => m.teamType === 'ai')
        };

        Object.entries(groups).forEach(([type, members]) => {
          if (members.length === 0) return;

          const typeHeader = document.createElement('div');
          typeHeader.style.cssText = 'color:#5ba3ff;font-weight:600;margin:12px 0 8px 0;font-size:16px;text-transform:capitalize;';
          typeHeader.textContent = `${type} (${members.length})`;
          container.appendChild(typeHeader);

          members.forEach(member => {
            const card = createMemberCard(member, false);
            container.appendChild(card);
          });
        });
      }

      function renderEnhancedStatusPanel(member) {
        const hpPercent = Math.max(0, Math.min(1, (member.hp || 0) / (member.hpMax || 1)));
        const isAI = member.teamType === 'ai' || member.aiEnabled;

        return `
          <div class="enhanced-status-panel" data-member-id="${member.id}" style="
            background: linear-gradient(145deg, #1a2332, #0f1824);
            border: 2px solid ${isAI ? '#ffa726' : '#345d8a'};
            border-radius: 12px;
            padding: 16px;
            margin: 8px 0;
            position: relative;
            transition: all 0.3s ease;
          ">
            <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
              <div style="color: #e0f2ff; font-weight: 600; font-size: 16px;">${member.name || 'Unknown'}</div>
              ${isAI ? '<span style="background: #ffa726; color: #000; padding: 3px 8px; border-radius: 4px; font-size: 11px; font-weight: bold;">AI</span>' : ''}
            </div>
            
            <!-- HP Bar -->
            <div style="margin-bottom: 10px;">
              <div style="background: #0f1824; height: 12px; border-radius: 6px; overflow: hidden; border: 1px solid #345d8a;">
                <div style="
                  background: linear-gradient(90deg, #ff6b6b, #ff8a80);
                  height: 100%;
                  width: ${(hpPercent * 100).toFixed(1)}%;
                  transition: width 0.3s ease;
                  box-shadow: 0 0 8px rgba(255, 107, 107, 0.5);
                "></div>
              </div>
              <div style="color: #9baec8; font-size: 12px; margin-top: 4px; text-align: right;">
                ${Math.floor(member.hp || 0)} / ${Math.floor(member.hpMax || 1)}
              </div>
            </div>
            
            <!-- Stats Grid -->
            <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; font-size: 12px;">
              <div style="background: #1e3049; padding: 6px; border-radius: 6px; text-align: center;">
                <div style="color: #ff6b6b;">⚔️ ${member.atk || 0}</div>
                <div style="color: #7b8fa3; font-size: 10px;">ATK</div>
              </div>
              <div style="background: #1e3049; padding: 6px; border-radius: 6px; text-align: center;">
                <div style="color: #4CAF50;">🛡️ ${member.def || 0}</div>
                <div style="color: #7b8fa3; font-size: 10px;">DEF</div>
              </div>
              <div style="background: #1e3049; padding: 6px; border-radius: 6px; text-align: center;">
                <div style="color: #00E5FF;">⚡ ${member.spd || 0}</div>
                <div style="color: #7b8fa3; font-size: 10px;">SPD</div>
              </div>
            </div>
            
            <!-- Team Type Badge -->
            <div style="
              position: absolute;
              top: 8px;
              right: 8px;
              background: ${getTeamTypeColor(member.teamType)};
              color: #000;
              padding: 2px 6px;
              border-radius: 4px;
              font-size: 9px;
              font-weight: bold;
            ">${member.teamType.toUpperCase()}</div>
          </div>
        `;
      }

      function getTeamTypeColor(teamType) {
        const colors = {
          'player': '#4CAF50',
          'ai': '#ffa726',
          'tamed': '#ff6b6b',
          'summon': '#00E5FF'
        };
        return colors[teamType] || '#9baec8';
      }

      function createMemberCard(member, isActive) {
        const card = document.createElement('div');
        card.style.cssText = `
          background: ${isActive ? '#1e3049' : '#151f2e'};
          border: 1px solid #345d8a;
          border-radius: 10px;
          padding: 14px;
          display: flex;
          justify-content: space-between;
          align-items: center;
          transition: transform 0.2s;
        `;
        card.onmouseenter = () => card.style.transform = 'translateX(4px)';
        card.onmouseleave = () => card.style.transform = 'translateX(0)';

        const typeIcons = {
          player: '🛡️',
          tamed: '🐾',
          summon: '✨',
          ai: '🤖'
        };

        const info = document.createElement('div');
        info.style.cssText = 'flex:1;';
        info.innerHTML = `
          <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px;">
            <span style="font-size:20px;">${typeIcons[member.teamType]}</span>
            <span style="color:#e0f2ff;font-weight:600;font-size:16px;">${member.name || 'Unknown'}</span>
            ${isActive ? '<span style="color:#4CAF50;font-size:12px;background:#1b5e20;padding:2px 8px;border-radius:4px;">ACTIVE</span>' : ''}
          </div>
          <div style="display:flex;gap:16px;font-size:13px;color:#9baec8;">
            <span>💚 ${member.hp}/${member.hpMax}</span>
            <span>⚔️ ${member.atk}</span>
            <span>🛡️ ${member.def}</span>
            <span>⚡ ${member.spd}</span>
          </div>
          ${member.combatStats ? `
            <div style="font-size:11px;color:#7b8fa3;margin-top:4px;">
              Kills: ${member.combatStats.kills} | Damage: ${Math.floor(member.combatStats.damage)} | Assists: ${member.combatStats.assists}
            </div>
          ` : ''}
        `;

        const actions = document.createElement('div');
        actions.style.cssText = 'display:flex;gap:8px;';

        if (isActive && member.teamType !== 'player') {
          const removeBtn = document.createElement('button');
          removeBtn.textContent = 'Remove';
          removeBtn.style.cssText = 'padding:8px 14px;background:#ff5252;color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:600;';
          removeBtn.onclick = () => {
            removeMember(member.id);
            renderTab('active');
          };
          actions.appendChild(removeBtn);
        } else if (!isActive && member.teamType !== 'player') {
          const deployBtn = document.createElement('button');
          deployBtn.textContent = 'Deploy';
          deployBtn.style.cssText = 'padding:8px 14px;background:#4CAF50;color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:600;';
          deployBtn.onclick = () => {
            if (deployMember(member.id)) {
              renderTab('roster');
              const activeTab = document.querySelector('[data-tab="active"]');
              if (activeTab) {
                activeTab.textContent = `Active Team (${state.activeTeam.length}/${state.maxTeamSize})`;
              }
            }
          };
          actions.appendChild(deployBtn);
        }

        card.appendChild(info);
        card.appendChild(actions);
        return card;
      }

      function renderPresets(container) {
        container.innerHTML = `
          <div style="display:flex;flex-direction:column;gap:12px;">
            ${[0, 1, 2].map(i => {
          const preset = state.presets[i];
          return `
                <div style="background:#1e3049;border:1px solid #345d8a;border-radius:10px;padding:14px;">
                  <div style="display:flex;justify-content:space-between;align-items:center;">
                    <div>
                      <div style="color:#e0f2ff;font-weight:600;font-size:16px;">${preset ? preset.name : `Preset ${i + 1} (Empty)`}</div>
                      ${preset ? `
                        <div style="font-size:12px;color:#9baec8;margin-top:4px;">
                          Formation: ${state.formations[preset.formation]?.name} | Members: ${preset.members.length}
                        </div>
                      ` : ''}
                    </div>
                    <div style="display:flex;gap:8px;">
                      ${preset ? `
                        <button onclick="window.TeamManagementSystem.loadPreset(${i})" style="padding:8px 14px;background:#4CAF50;color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:600;">Load</button>
                      ` : ''}
                      <button onclick="window.TeamManagementSystem.savePreset('Preset ${i + 1}', ${i})" style="padding:8px 14px;background:#2196F3;color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:600;">Save Current</button>
                    </div>
                  </div>
                </div>
              `;
        }).join('')}
          </div>
        `;
      }

      function openModal() {
        let modal = document.getElementById('teamManagementModal');
        if (!modal) {
          modal = createModal();
        }

        modal.style.display = 'flex';
        state.modalOpen = true;
        renderTab('active');
      }

      function closeModal() {
        const modal = document.getElementById('teamManagementModal');
        if (modal) {
          modal.style.display = 'none';
          state.modalOpen = false;
        }
      }

      // === INTEGRATION HOOKS ===

      function hookSummonSystem() {
        const st = window.st;
        if (!st) return;

        setInterval(() => {
          if (!st.summons) return;

          st.summons.forEach(summon => {
            if (!summon._addedToRoster) {
              addSummonToTeam(summon);
              summon._addedToRoster = true;
            }
          });
        }, 1000);
      }

      function hookAISystem() {
        const st = window.st;
        if (!st) return;

        setInterval(() => {
          if (!st.aiCompanions) return;

          st.aiCompanions.forEach(ai => {
            if (!ai._addedToRoster) {
              addAIToTeam(ai);
              ai._addedToRoster = true;
            }
          });
        }, 1000);
      }

      function hookTamedBosses() {
        const st = window.st;
        if (!st) return;

        setInterval(() => {
          if (!st.tamedBosses) return;

          st.tamedBosses.forEach(tamed => {
            if (!tamed._addedToRoster) {
              const tamedMember = {
                id: tamed.id || `tamed_${Date.now()}`,
                name: tamed.name || 'Tamed Boss',
                hp: tamed.hp || tamed.hpMax || 100,
                hpMax: tamed.hpMax || 100,
                atk: tamed.atk || tamed.dmg || 20,
                def: tamed.def || 10,
                spd: 5,
                x: tamed.x,
                y: tamed.y,
                color: '#ffd56a',
                w: 32,
                h: 32
              };
              addToRoster(tamedMember, 'tamed');
              tamed._addedToRoster = true;
            }
          });
        }, 1000);
      }

      function syncActiveTeam() {
        const st = window.st;
        if (!st) return;

        state.activeTeam.forEach(member => {
          if (member.teamType === 'summon' && member.summonRef) {
            member.hp = member.summonRef.hp || member.hp;
            member.x = member.summonRef.x;
            member.y = member.summonRef.y;

            if (member.summonRef.dead) {
              removeMember(member.id);
            }
          }

          if (member.teamType === 'ai' && member.aiRef) {
            member.hp = member.aiRef.hp || member.hp;
            member.x = member.aiRef.x;
            member.y = member.aiRef.y;
          }

          if (member.teamType === 'player') {
            const playerObj = st.players?.find(p => p.id === member.id);
            if (playerObj) {
              member.hp = playerObj.hp;
              member.hpMax = playerObj.hpMax;
              member.x = playerObj.x;
              member.y = playerObj.y;
            }
          }
        });
      }

      // === INITIALIZATION ===

      function init() {
        if (state.initialized) return;
        state.initialized = true;

        loadRoster();
        hookSummonSystem();
        hookAISystem();
        hookTamedBosses();

        setInterval(syncActiveTeam, 1000);

        document.addEventListener('keydown', (e) => {
          if (e.key.toLowerCase() === 't' && !e.ctrlKey && !e.altKey) {
            const activeEl = document.activeElement;
            if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA')) {
              return;
            }
            if (state.modalOpen) {
              closeModal();
            } else {
              openModal();
            }
          }
        });

        const btnTeam = document.getElementById('btnTeam');
        if (btnTeam) {
          btnTeam.addEventListener('click', () => {
            if (state.modalOpen) {
              closeModal();
            } else {
              openModal();
            }
          });
        }

        console.log('[TeamMgmt] Initialized');
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', init);
      } else {
        setTimeout(init, 100);
      }

      // === NEW ENHANCED FUNCTIONS ===

      function updateStatusPanels() {
        if (!state.modalOpen) return;

        const panels = document.querySelectorAll('.enhanced-status-panel');
        state.activeTeam.forEach((member, index) => {
          const panel = panels[index];
          if (!panel) return;

          const hpPercent = Math.max(0, Math.min(1, (member.hp || 0) / (member.hpMax || 1)));
          const hpBar = panel.querySelector('[style*="linear-gradient(90deg, #ff6b6b"]');
          const hpText = panel.querySelector('[style*="text-align: right"]');

          if (hpBar) hpBar.style.width = `${(hpPercent * 100).toFixed(1)}%`;
          if (hpText) hpText.textContent = `${Math.floor(member.hp || 0)} / ${Math.floor(member.hpMax || 1)}`;
        });
      }

      function autoFormation() {
        // Auto-arrange team members in optimal formation
        state.activeTeam.forEach((member, index) => {
          member.formationIndex = index;
        });
        applyFormation();
        renderTab('active');
        if (typeof notify === 'function') {
          notify('Formation optimized!', '#4CAF50');
        }
      }

      function healAll() {
        state.activeTeam.forEach(member => {
          member.hp = member.hpMax;
        });
        renderTab('active');
        if (typeof notify === 'function') {
          notify('All team members healed!', '#4CAF50');
        }
      }

      function createMinimalTeamHUD() {
        const existing = document.getElementById('minimal-team-hud');
        if (existing) existing.remove();

        if (state.activeTeam.length === 0) return;

        const container = document.createElement('div');
        container.id = 'minimal-team-hud';
        container.style.cssText = `
          position: fixed;
          top: 80px;
          left: 10px;
          display: flex;
          flex-direction: column;
          gap: 6px;
          pointer-events: none;
          z-index: 100;
        `;

        state.activeTeam.forEach(member => {
          const indicator = document.createElement('div');
          const hpPercent = Math.max(0, Math.min(1, (member.hp || 0) / (member.hpMax || 1)));
          indicator.style.cssText = `
            width: 120px;
            background: rgba(26, 35, 50, 0.8);
            border: 1px solid #345d8a;
            border-radius: 6px;
            padding: 4px 8px;
            font-size: 11px;
            color: #e0f2ff;
          `;
          indicator.innerHTML = `
            <div style="margin-bottom: 2px;">${member.name.substring(0, 12)}...</div>
            <div style="background: #0f1824; height: 4px; border-radius: 2px; overflow: hidden;">
              <div style="background: #ff6b6b; height: 100%; width: ${(hpPercent * 100).toFixed(0)}%;"></div>
            </div>
          `;
          container.appendChild(indicator);
        });

        document.body.appendChild(container);
      }

      function updateMinimalHUD() {
        const existing = document.getElementById('minimal-team-hud');
        if (existing) existing.remove();
        if (state.activeTeam.length > 0) {
          createMinimalTeamHUD();
        }
      }

      // Start real-time updates every 500ms
      setInterval(updateStatusPanels, 500);
      setInterval(updateMinimalHUD, 1000);

      return {
        addToRoster,
        tameEnemy,
        addSummonToTeam,
        addAIToTeam,
        deployMember,
        removeMember,
        setFormation,
        applyFormation,
        savePreset,
        loadPreset,
        openModal,
        closeModal,
        autoFormation,
        healAll,
        createMinimalTeamHUD,
        updateMinimalHUD,
        get roster() { return state.roster; },
        get activeTeam() { return state.activeTeam; },
        get formations() { return state.formations; },
        get currentFormation() { return state.currentFormation; }
      };
    })();

    // ========================================
    // PHASE 5.3: PET ACTIVITY LOG SYSTEM
    // ========================================
    window.PetActivityLog = (function () {
      'use strict';

      const state = {
        logs: {}, // Key: memberId, Value: activity array
        maxLogsPerMember: 10
      };

      function logActivity(memberId, activityType, data = {}) {
        if (!memberId) return;

        if (!state.logs[memberId]) {
          state.logs[memberId] = [];
        }

        const activity = {
          type: activityType, // 'kill', 'assist', 'damage', 'heal'
          timestamp: Date.now(),
          ...data
        };

        state.logs[memberId].unshift(activity);

        // Keep only last 10 activities
        if (state.logs[memberId].length > state.maxLogsPerMember) {
          state.logs[memberId] = state.logs[memberId].slice(0, state.maxLogsPerMember);
        }

        saveActivityLogs();
      }

      function getActivities(memberId) {
        return state.logs[memberId] || [];
      }

      function getTotalStats(memberId) {
        const activities = getActivities(memberId);
        const stats = {
          kills: 0,
          assists: 0,
          totalDamage: 0,
          totalHealing: 0
        };

        activities.forEach(activity => {
          switch (activity.type) {
            case 'kill':
              stats.kills++;
              break;
            case 'assist':
              stats.assists++;
              break;
            case 'damage':
              stats.totalDamage += activity.amount || 0;
              break;
            case 'heal':
              stats.totalHealing += activity.amount || 0;
              break;
          }
        });

        return stats;
      }

      function showActivityLog(memberId, memberName) {
        const activities = getActivities(memberId);
        const stats = getTotalStats(memberId);

        const modal = document.createElement('div');
        modal.style.cssText = `
          position: fixed;
          inset: 0;
          background: rgba(0,0,0,0.85);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 7500;
        `;

        const panel = document.createElement('div');
        panel.style.cssText = `
          background: linear-gradient(145deg, #1a2332, #0f1824);
          border: 2px solid #5ba3ff;
          border-radius: 16px;
          width: 600px;
          max-width: 95vw;
          max-height: 80vh;
          display: flex;
          flex-direction: column;
          box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        `;

        panel.innerHTML = `
          <div style="padding:20px 24px;background:linear-gradient(90deg,#2a3f5f,#1e3049);border-bottom:1px solid #5ba3ff;">
            <h2 style="margin:0;color:#e0f2ff;font-size:20px;">📊 ${memberName} - Activity Log</h2>
          </div>
          <div style="padding:16px 24px;background:#151f2e;border-bottom:1px solid #345d8a;">
            <div style="display:flex;justify-content:space-around;text-align:center;">
              <div>
                <div style="color:#ff6b6b;font-size:24px;font-weight:700;">${stats.kills}</div>
                <div style="color:#9baec8;font-size:12px;">Kills</div>
              </div>
              <div>
                <div style="color:#ffd56a;font-size:24px;font-weight:700;">${Math.floor(stats.totalDamage)}</div>
                <div style="color:#9baec8;font-size:12px;">Damage</div>
              </div>
              <div>
                <div style="color:#4CAF50;font-size:24px;font-weight:700;">${Math.floor(stats.totalHealing)}</div>
                <div style="color:#9baec8;font-size:12px;">Healing</div>
              </div>
              <div>
                <div style="color:#5ba3ff;font-size:24px;font-weight:700;">${stats.assists}</div>
                <div style="color:#9baec8;font-size:12px;">Assists</div>
              </div>
            </div>
          </div>
          <div style="flex:1;overflow-y:auto;padding:20px;">
            ${activities.length === 0 ? `
              <div style="text-align:center;padding:40px;color:#9baec8;">
                <p>No activity recorded yet</p>
              </div>
            ` : `
              <div style="display:flex;flex-direction:column;gap:8px;">
                ${activities.map(activity => {
          const time = new Date(activity.timestamp);
          const timeStr = time.toLocaleTimeString();
          const icons = { kill: '💀', assist: '🤝', damage: '⚔️', heal: '💚' };
          const colors = { kill: '#ff6b6b', assist: '#5ba3ff', damage: '#ffd56a', heal: '#4CAF50' };
          return `
                    <div style="background:#1e3049;border-left:3px solid ${colors[activity.type]};border-radius:6px;padding:10px 12px;display:flex;justify-content:space-between;align-items:center;">
                      <div style="display:flex;align-items:center;gap:10px;">
                        <span style="font-size:18px;">${icons[activity.type]}</span>
                        <div>
                          <div style="color:#e0f2ff;font-size:13px;font-weight:600;text-transform:capitalize;">${activity.type}</div>
                          <div style="color:#7b8fa3;font-size:11px;">${timeStr}</div>
                        </div>
                      </div>
                      ${activity.amount ? `<div style="color:${colors[activity.type]};font-weight:600;">${activity.amount}</div>` : ''}
                    </div>
                  `;
        }).join('')}
              </div>
            `}
          </div>
          <div style="padding:14px 24px;background:#0f1824;display:flex;justify-content:space-between;">
            <button id="clearActivityLog" style="padding:8px 16px;background:#ff5252;color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:600;">Clear Log</button>
            <button id="closeActivityLog" style="padding:8px 16px;background:#2196F3;color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:600;">Close</button>
          </div>
        `;

        modal.appendChild(panel);
        document.body.appendChild(modal);

        panel.querySelector('#closeActivityLog').onclick = () => modal.remove();
        modal.onclick = (e) => { if (e.target === modal) modal.remove(); };
        panel.querySelector('#clearActivityLog').onclick = () => {
          if (confirm('Clear activity log for this member?')) {
            state.logs[memberId] = [];
            saveActivityLogs();
            modal.remove();
            notify?.('Activity log cleared', '#ff5252');
          }
        };
      }

      function saveActivityLogs() {
        try {
          localStorage.setItem('a1k_pet_activity_logs', JSON.stringify(state.logs));
        } catch (error) {
          console.error('[PetLog] Failed to save activity logs:', error);
        }
      }

      function loadActivityLogs() {
        try {
          const saved = localStorage.getItem('a1k_pet_activity_logs');
          if (saved) {
            state.logs = JSON.parse(saved);
          }
        } catch (error) {
          console.error('[PetLog] Failed to load activity logs:', error);
        }
      }

      loadActivityLogs();

      return {
        logActivity,
        getActivities,
        getTotalStats,
        showActivityLog
      };
    })();

    window.ShopSystem = (function () {
      const inventory = [
        {
          id: 'potion_hp',
          name: 'Health Potion',
          price: 120,
          description: 'Restores 200 HP to the active leader.',
          effect: { type: 'restore', stat: 'hp', amount: 200 }
        },
        {
          id: 'potion_mp',
          name: 'Mana Potion',
          price: 140,
          description: 'Restores 120 MP for ability casting.',
          effect: { type: 'restore', stat: 'mp', amount: 120 }
        },
        {
          id: 'stamina_tonic',
          name: 'Stamina Drink',
          price: 160,
          description: 'Restores 50 team stamina (shared energy).',
          effect: { type: 'resource', stat: 'energy', amount: 50 }
        },
        {
          id: 'atk_tonic',
          name: 'Power Tonic',
          price: 220,
          description: '+15% attack for 2 minutes.',
          effect: { type: 'buff', stat: 'atk', amount: 0.15, duration: 120000 }
        },
        {
          id: 'def_elixir',
          name: 'Guard Elixir',
          price: 220,
          description: '+20% damage reduction for 2 minutes.',
          effect: { type: 'buff', stat: 'def', amount: 0.2, duration: 120000 }
        },
        {
          id: 'speed_serum',
          name: 'Speed Serum',
          price: 200,
          description: '+20% movement speed for 2 minutes.',
          effect: { type: 'buff', stat: 'speed', amount: 0.2, duration: 120000 }
        }
      ];
      let modal = null;
      let listEl = null;
      let goldEl = null;
      let headerEl = null;
      let lastContext = null;

      function closeShop() {
        if (!modal) return;
        modal.style.display = 'none';
        modal.setAttribute('aria-hidden', 'true');
      }

      function ensureModal() {
        if (modal) return modal;
        modal = document.createElement('div');
        modal.id = 'shopModal';
        modal.style.cssText = 'position:fixed;inset:0;background:rgba(8,14,24,0.76);display:none;align-items:center;justify-content:center;z-index:5000;';
        const panel = document.createElement('div');
        panel.style.cssText = 'background:#101a29;border:1px solid #2f4f74;border-radius:14px;width:420px;max-width:92vw;max-height:85vh;display:flex;flex-direction:column;box-shadow:0 18px 48px rgba(0,0,0,0.35);';
        headerEl = document.createElement('div');
        headerEl.style.cssText = 'padding:18px 22px;background:linear-gradient(90deg,#1a2a40,#253a5a);color:#cde7ff;font-weight:600;font-size:18px;letter-spacing:0.5px;';
        headerEl.textContent = 'Adventurer Shop';
        const body = document.createElement('div');
        body.style.cssText = 'padding:18px 22px;flex:1;overflow-y:auto;display:flex;flex-direction:column;gap:12px;';
        listEl = body;
        const footer = document.createElement('div');
        footer.style.cssText = 'padding:14px 22px;background:#0d1623;display:flex;align-items:center;justify-content:space-between;';
        goldEl = document.createElement('div');
        goldEl.style.cssText = 'color:#ffd56a;font-weight:600;';
        const closeBtn = document.createElement('button');
        closeBtn.textContent = 'Close';
        closeBtn.style.cssText = 'padding:8px 18px;border:none;border-radius:8px;background:#1c4d80;color:#fff;font-weight:600;cursor:pointer;';
        closeBtn.addEventListener('click', closeShop);
        footer.appendChild(goldEl);
        footer.appendChild(closeBtn);
        panel.appendChild(headerEl);
        panel.appendChild(body);
        panel.appendChild(footer);
        modal.appendChild(panel);
        modal.addEventListener('click', (evt) => {
          if (evt.target === modal) closeShop();
        });
        document.body.appendChild(modal);
        return modal;
      }

      function shopTitleFor(houseType) {
        switch (houseType) {
          case 'forge': return 'Forge Upgrades';
          case 'apothecary': return 'Apothecary';
          case 'blackmarket': return 'Black Market';
          case 'shop': return 'Town Shop';
          default: return 'Adventurer Shop';
        }
      }

      function updateGoldDisplay() {
        if (!goldEl) return;
        const st = window.st || (window.st = {});
        goldEl.textContent = `Gold: ${st.gold | 0}g`;
      }

      function renderItems(ctx) {
        ensureModal();
        if (!listEl) return;
        listEl.innerHTML = '';
        const st = window.st || (window.st = {});
        inventory.forEach(item => {
          const card = document.createElement('div');
          card.style.cssText = 'background:#132234;border:1px solid rgba(82,130,170,0.35);border-radius:10px;padding:12px 14px;display:flex;flex-direction:column;gap:6px;';
          const titleRow = document.createElement('div');
          titleRow.style.cssText = 'display:flex;justify-content:space-between;align-items:center;';
          const nameEl = document.createElement('div');
          nameEl.style.cssText = 'color:#cde7ff;font-weight:600;';
          nameEl.textContent = item.name;
          const priceEl = document.createElement('div');
          priceEl.style.cssText = 'color:#ffd56a;font-weight:600;';
          priceEl.textContent = `${item.price}g`;
          titleRow.appendChild(nameEl);
          titleRow.appendChild(priceEl);
          const descEl = document.createElement('div');
          descEl.style.cssText = 'color:#9abacc;font-size:13px;line-height:1.4;';
          descEl.textContent = item.description;
          const actions = document.createElement('div');
          actions.style.cssText = 'display:flex;justify-content:flex-end;';
          const btn = document.createElement('button');
          btn.textContent = 'Buy';
          btn.style.cssText = 'padding:6px 16px;border-radius:6px;border:none;background:#1f5a9c;color:#fff;font-weight:600;cursor:pointer;';
          if ((st.gold | 0) < item.price) {
            btn.disabled = true;
            btn.style.opacity = '0.6';
            btn.style.cursor = 'not-allowed';
          }
          btn.addEventListener('click', () => buyItem(item.id));
          actions.appendChild(btn);
          card.appendChild(titleRow);
          card.appendChild(descEl);
          card.appendChild(actions);
          listEl.appendChild(card);
        });
      }

      function openShop(ctx = {}) {
        lastContext = ctx;
        ensureModal();
        if (headerEl) headerEl.textContent = shopTitleFor(ctx.houseType);
        renderItems(ctx);
        updateGoldDisplay();
        if (modal) {
          modal.style.display = 'flex';
          modal.setAttribute('aria-hidden', 'false');
        }
      }

      function getLeader() {
        const st = window.st || (window.st = {});
        const leaderIndex = typeof st.leader === 'number' ? st.leader : 0;
        return (st.players || [])[leaderIndex] || null;
      }

      function applyBuff(effect) {
        const st = window.st || (window.st = {});
        const duration = effect.duration || 120000;
        const now = performance.now ? performance.now() : Date.now();
        const eff = st.npcSkillEffects = st.npcSkillEffects || {};
        if (effect.stat === 'atk') {
          const mul = 1 + (effect.amount || 0);
          eff.atkMul = (eff.atkMul || 1) * mul;
          recalcStats?.();
          setTimeout(() => {
            eff.atkMul = Math.max(0.1, (eff.atkMul || 1) / mul);
            recalcStats?.();
          }, duration);
          return true;
        }
        if (effect.stat === 'def') {
          const amt = effect.amount || 0;
          const currentBuff = eff.tempDefBuff;
          if (currentBuff && now < (currentBuff.expires || 0)) {
            eff.tempDefBuff = {
              value: Math.min(0.8, (currentBuff.value || 0) + amt),
              expires: Math.max(currentBuff.expires || 0, now + duration)
            };
          } else {
            eff.tempDefBuff = { value: Math.min(0.8, amt), expires: now + duration };
          }
          setTimeout(() => {
            const buff = eff.tempDefBuff;
            if (!buff) return;
            const newValue = Math.max(0, (buff.value || 0) - amt);
            if (newValue <= 0.001) {
              eff.tempDefBuff = null;
            } else {
              eff.tempDefBuff = { value: newValue, expires: buff.expires };
            }
          }, duration);
          return true;
        }
        if (effect.stat === 'speed') {
          const players = st.players || [];
          players.forEach(p => {
            if (typeof p.speedBase !== 'number') return;
            if (typeof p._shopBaseSpeed !== 'number') p._shopBaseSpeed = p.speedBase;
            p._shopSpeedBoost = (p._shopSpeedBoost || 0) + (effect.amount || 0);
            p.speedBase = p._shopBaseSpeed * (1 + p._shopSpeedBoost);
          });
          setTimeout(() => {
            const playersInner = st.players || [];
            playersInner.forEach(p => {
              if (typeof p._shopSpeedBoost !== 'number') return;
              p._shopSpeedBoost = Math.max(0, p._shopSpeedBoost - (effect.amount || 0));
              p.speedBase = p._shopBaseSpeed * (1 + p._shopSpeedBoost);
              if (p._shopSpeedBoost <= 0) delete p._shopSpeedBoost;
            });
          }, duration);
          return true;
        }
        return false;
      }

      function applyItem(item) {
        const effect = item.effect || {};
        const st = window.st || (window.st = {});
        const leaderUnit = getLeader();
        switch (effect.type) {
          case 'restore': {
            if (!leaderUnit) return false;
            const stat = effect.stat || 'hp';
            const maxKey = stat === 'hp' ? 'hpMax' : stat === 'mp' ? 'mpMax' : `${stat}Max`;
            const max = leaderUnit[maxKey] || leaderUnit[stat] || 0;
            const current = leaderUnit[stat] || 0;
            const newValue = Math.min(max || current + effect.amount, current + effect.amount);
            leaderUnit[stat] = newValue;
            if (stat === 'hp') mirrorLeaderHP?.();
            if (stat === 'mp' && typeof st.mp === 'number' && typeof st.mpMax === 'number') {
              st.mp = Math.min(st.mpMax, st.mp + effect.amount);
            }
            window.updateTeamStatusUI?.();
            return true;
          }
          case 'resource': {
            if (effect.stat === 'energy') {
              st.sharedEnergy = st.sharedEnergy || { current: 0, max: 100 };
              const max = st.sharedEnergy.max || 100;
              st.sharedEnergy.current = Math.min(max, (st.sharedEnergy.current || 0) + (effect.amount || 0));
              window.updateTeamStatusUI?.();
              return true;
            }
            return false;
          }
          case 'buff':
            return applyBuff(effect);
          default:
            return false;
        }
      }

      function buyItem(itemId) {
        const item = inventory.find(it => it.id === itemId);
        if (!item) return false;
        const st = window.st || (window.st = {});
        const currentGold = st.gold | 0;
        if (currentGold < item.price) {
          notify?.('Not enough gold!', '#ff7a6a');
          return false;
        }
        st.gold = currentGold - item.price;
        window.updateCurrencies?.();

        // Phase 2.3: Add consumable to inventory instead of immediate use
        st.inv = st.inv || [];
        const consumableItem = {
          id: `${item.id}_${Date.now()}`,
          baseId: item.id,
          name: item.name,
          description: item.description,
          effect: item.effect,
          type: 'consumable',
          category: 'consumable',
          purchasedAt: Date.now()
        };
        st.inv.push(consumableItem);

        notify?.(`Purchased ${item.name}! Check your inventory.`, '#6aa8ff');

        // Track quest progress
        try {
          window.QuestSystem?.trackProgress?.('shop_purchase', 1);
        } catch (_) { }

        // Save purchase history
        savePurchaseHistory(item.id);

        updateGoldDisplay();
        if (modal && modal.style.display !== 'none') {
          renderItems(lastContext || {});
        }
        return true;
      }

      // Phase 2.3: Use consumable from inventory
      function useConsumable(itemId) {
        const st = window.st || (window.st = {});
        st.inv = st.inv || [];

        const itemIndex = st.inv.findIndex(it => it.id === itemId);
        if (itemIndex === -1) {
          notify?.('Item not found in inventory!', '#ff7a6a');
          return false;
        }

        const item = st.inv[itemIndex];
        const applied = applyItem(item);

        if (applied) {
          // Remove consumed item from inventory
          st.inv.splice(itemIndex, 1);
          notify?.(`Used ${item.name}!`, '#6aa8ff');
          return true;
        } else {
          notify?.('Unable to use the item right now.', '#ff7a6a');
          return false;
        }
      }

      // Phase 2.3: Purchase history tracking
      function savePurchaseHistory(itemId) {
        try {
          const history = JSON.parse(localStorage.getItem('a1k_shop_history') || '{}');
          history[itemId] = (history[itemId] || 0) + 1;
          localStorage.setItem('a1k_shop_history', JSON.stringify(history));
        } catch (error) {
          console.error('[Shop] Failed to save purchase history:', error);
        }
      }

      // Phase 5.2: Shop Bundle System
      const bundles = [
        {
          id: 'starter_pack',
          name: 'Starter Pack',
          description: '3 Health Potions + 1 Mana Potion',
          items: ['potion_hp', 'potion_hp', 'potion_hp', 'potion_mp'],
          regularPrice: 660,
          bundlePrice: 500,
          discount: 24,
          stock: 3,
          refreshInterval: 600000 // 10 minutes
        },
        {
          id: 'combat_pack',
          name: 'Combat Pack',
          description: '2 Rage Pills + 1 Revive Token + 1 Power Tonic',
          items: ['rage_pill', 'rage_pill', 'revive_token', 'atk_tonic'],
          regularPrice: 610,
          bundlePrice: 450,
          discount: 26,
          stock: 2,
          refreshInterval: 600000
        },
        {
          id: 'speed_bundle',
          name: 'Speed Bundle',
          description: '2 Speed Serums + 1 Stamina Drink',
          items: ['speed_serum', 'speed_serum', 'stamina_tonic'],
          regularPrice: 560,
          bundlePrice: 420,
          discount: 25,
          stock: 2,
          refreshInterval: 600000
        }
      ];

      let bundleState = {
        lastRefresh: Date.now(),
        purchases: {}
      };

      function loadBundleState() {
        try {
          const saved = localStorage.getItem('a1k_shop_bundles');
          if (saved) {
            bundleState = JSON.parse(saved);
            // Check if refresh needed
            const now = Date.now();
            if (now - bundleState.lastRefresh > 600000) {
              resetBundles();
            }
          }
        } catch (error) {
          console.error('[Shop] Failed to load bundle state:', error);
        }
      }

      function saveBundleState() {
        try {
          localStorage.setItem('a1k_shop_bundles', JSON.stringify(bundleState));
        } catch (error) {
          console.error('[Shop] Failed to save bundle state:', error);
        }
      }

      function resetBundles() {
        bundleState.lastRefresh = Date.now();
        bundleState.purchases = {};
        saveBundleState();
      }

      function buyBundle(bundleId) {
        const bundle = bundles.find(b => b.id === bundleId);
        if (!bundle) return false;

        const st = window.st || (window.st = {});
        const purchased = bundleState.purchases[bundleId] || 0;

        if (purchased >= bundle.stock) {
          notify?.('Bundle sold out! Check back after refresh.', '#ff7a6a');
          return false;
        }

        if (st.gold < bundle.bundlePrice) {
          notify?.('Not enough gold!', '#ff7a6a');
          return false;
        }

        st.gold -= bundle.bundlePrice;
        st.inv = st.inv || [];

        // Add all items to inventory
        bundle.items.forEach(itemId => {
          const item = inventory.find(it => it.id === itemId);
          if (item) {
            const consumableItem = {
              id: `${item.id}_${Date.now()}_${Math.random()}`,
              baseId: item.id,
              name: item.name,
              description: item.description,
              effect: item.effect,
              type: 'consumable',
              category: 'consumable',
              purchasedAt: Date.now()
            };
            st.inv.push(consumableItem);
          }
        });

        bundleState.purchases[bundleId] = (bundleState.purchases[bundleId] || 0) + 1;
        saveBundleState();

        notify?.(`Purchased ${bundle.name}! Items added to inventory.`, '#6aa8ff');
        return true;
      }

      function getTimeUntilRefresh() {
        const elapsed = Date.now() - bundleState.lastRefresh;
        const remaining = 600000 - elapsed;
        if (remaining <= 0) return 'Available now';

        const minutes = Math.floor(remaining / 60000);
        const seconds = Math.floor((remaining % 60000) / 1000);
        return `${minutes}:${seconds.toString().padStart(2, '0')}`;
      }

      loadBundleState();

      return {
        inventory,
        openShop,
        closeShop,
        useConsumable,
        buyItem,
        applyItem,
        bundles,
        buyBundle,
        getTimeUntilRefresh,
        resetBundles
      };
    })();

    window.QuestSystem = (function () {
      const quests = [];
      let modal = null;
      let listEl = null;
      let headerEl = null;
      let initialized = false;
      let zoneHandle = null;
      let lastZone = null;

      function closeQuestBoard() {
        if (!modal) return;
        modal.style.display = 'none';
        modal.setAttribute('aria-hidden', 'true');
      }

      function ensureModal() {
        if (modal) return modal;
        modal = document.createElement('div');
        modal.id = 'questBoardModal';
        modal.style.cssText = 'position:fixed;inset:0;background:rgba(6,10,18,0.78);display:none;align-items:center;justify-content:center;z-index:5000;';
        const panel = document.createElement('div');
        panel.style.cssText = 'background:#111b2b;border:1px solid #345d8a;border-radius:14px;width:480px;max-width:94vw;max-height:86vh;display:flex;flex-direction:column;box-shadow:0 18px 48px rgba(0,0,0,0.35);';
        headerEl = document.createElement('div');
        headerEl.style.cssText = 'padding:18px 24px;background:linear-gradient(90deg,#1e2d46,#283c5f);color:#cfe8ff;font-weight:600;font-size:18px;';
        headerEl.textContent = 'Quest Board';
        const body = document.createElement('div');
        body.style.cssText = 'padding:18px 24px;flex:1;overflow-y:auto;display:flex;flex-direction:column;gap:14px;';
        listEl = body;
        const footer = document.createElement('div');
        footer.style.cssText = 'padding:14px 24px;background:#0d1522;display:flex;justify-content:flex-end;';
        const closeBtn = document.createElement('button');
        closeBtn.textContent = 'Close';
        closeBtn.style.cssText = 'padding:8px 18px;border:none;border-radius:8px;background:#204e87;color:#fff;font-weight:600;cursor:pointer;';
        closeBtn.addEventListener('click', closeQuestBoard);
        footer.appendChild(closeBtn);
        panel.appendChild(headerEl);
        panel.appendChild(body);
        panel.appendChild(footer);
        modal.appendChild(panel);
        modal.addEventListener('click', (evt) => {
          if (evt.target === modal) closeQuestBoard();
        });
        document.body.appendChild(modal);
        return modal;
      }

      function addQuest(spec) {
        if (!spec || !spec.id || quests.find(q => q.id === spec.id)) return null;
        const quest = Object.assign({
          progress: 0,
          completed: false,
          reward: {}
        }, spec);
        if (quest.type === 'explore') quest._zones = new Set();
        quests.push(quest);
        updateModal();
        return quest;
      }

      function seedDefaults() {
        if (initialized) return;
        initialized = true;
        addQuest({
          id: 'quest_kill_30',
          name: 'Clear the Streets',
          type: 'kill',
          target: 30,
          description: 'Defeat 30 enemies anywhere in the city.',
          reward: { gold: 300, xp: 400 }
        });
        addQuest({
          id: 'quest_explore_5',
          name: 'Tour the Districts',
          type: 'explore',
          target: 5,
          description: 'Discover 5 unique city zones.',
          reward: { gold: 250, tickets: 2 }
        });
        addQuest({
          id: 'quest_collect_gold',
          name: "Merchant's Favor",
          type: 'gold',
          target: 1000,
          description: 'Collect 1000 gold from any source.',
          reward: { gold: 200, gems: 3 }
        });
        addQuest({
          id: 'quest_boss_slayer',
          name: 'Boss Slayer',
          type: 'boss',
          target: 2,
          description: 'Defeat 2 boss-level enemies.',
          reward: { gold: 600, xp: 800 }
        });
        addQuest({
          id: 'quest_craft_master',
          name: 'Master Crafter',
          type: 'craft',
          target: 3,
          description: 'Craft 3 items at any workshop.',
          reward: { gold: 350, tickets: 1 }
        });
        addQuest({
          id: 'quest_arena_challenge',
          name: 'Arena Challenger',
          type: 'arena',
          target: 5,
          description: 'Clear 5 arena waves in a single session.',
          reward: { gold: 500, xp: 600 }
        });
        addQuest({
          id: 'quest_tame_companion',
          name: 'Make New Friends',
          type: 'tame',
          target: 1,
          description: 'Successfully tame an enemy and add them to your team.',
          reward: { gold: 250, xp: 300 }
        });
        addQuest({
          id: 'quest_indoor_training',
          name: 'Room Brawler',
          type: 'indoor_kill',
          target: 5,
          description: 'Defeat 5 indoor training targets while visiting houses.',
          reward: { gold: 280, tickets: 1 }
        });

        // Phase 3: New Quests (Priority Content)
        addQuest({
          id: 'quest_zombie_exterminator',
          name: 'Zombie Exterminator',
          type: 'zombie_hunt',
          target: 10,
          description: 'Kill 10 zombies in the haunted house. Accept to spawn them!',
          reward: { gold: 500, xp: 300 },
          onAccept: () => {
            try {
              window.ZombieHuntSystem?.startZombieHunt?.('quest_zombie_exterminator');
            } catch (err) {
              console.error('[Quest] Failed to start zombie hunt:', err);
            }
          }
        });

        addQuest({
          id: 'quest_monster_nest',
          name: 'Monster Nest Cleanup',
          type: 'monster_hunt',
          target: 15,
          description: 'Kill 15 monsters in the designated hunt zone.',
          reward: { gold: 800, xp: 500 },
          onAccept: () => {
            try {
              window.MonsterHuntSystem?.startMonsterHunt?.('quest_monster_nest');
            } catch (err) {
              console.error('[Quest] Failed to start monster hunt:', err);
            }
          }
        });

        addQuest({
          id: 'quest_arena_champion',
          name: 'Arena Champion',
          type: 'arena',
          target: 10,
          description: 'Clear 10 arena waves to prove your might.',
          reward: { gold: 1200, xp: 800 }
        });

        addQuest({
          id: 'quest_gold_collector',
          name: 'Gold Collector',
          type: 'gold',
          target: 5000,
          description: 'Accumulate 5000 gold through any means.',
          reward: { gold: 600, xp: 400 }
        });

        addQuest({
          id: 'quest_team_builder',
          name: 'Team Builder',
          type: 'tame',
          target: 3,
          description: 'Recruit 3 team members (tamed enemies, summons, or AI).',
          reward: { gold: 400, xp: 300 }
        });

        addQuest({
          id: 'quest_shopping_spree',
          name: 'Shopping Spree',
          type: 'shop_purchase',
          target: 5,
          description: 'Purchase 5 items from any shop.',
          reward: { gold: 300, xp: 200 }
        });

        addQuest({
          id: 'quest_boss_hunter',
          name: 'Boss Hunter',
          type: 'tame',
          target: 2,
          description: 'Tame 2 powerful bosses and add them to your roster.',
          reward: { gold: 700, xp: 600 }
        });

        addQuest({
          id: 'quest_indoor_warrior',
          name: 'Indoor Warrior',
          type: 'indoor_kill',
          target: 10,
          description: 'Win 10 indoor combat encounters.',
          reward: { gold: 500, xp: 400 }
        });

        startZoneWatcher();
      }

      function grantRewards(reward = {}) {
        const st = window.st || (window.st = {});
        if (reward.gold) st.gold = (st.gold || 0) + reward.gold;
        if (reward.xp) {
          if (typeof grantXP === 'function') grantXP(reward.xp);
          else st.xp = (st.xp || 0) + reward.xp;
        }
        if (reward.gems) st.gems = (st.gems || 0) + reward.gems;
        if (reward.tickets) st.tickets = (st.tickets || 0) + reward.tickets;
        if (Array.isArray(reward.items)) {
          reward.items.forEach(it => { try { addItemToBag?.(it); } catch (_) { } });
        }
        window.updateCurrencies?.();
      }

      function completeQuest(questOrId) {
        const quest = typeof questOrId === 'string' ? quests.find(q => q.id === questOrId) : questOrId;
        if (!quest || quest.completed) return;
        quest.completed = true;
        quest.progress = quest.target;
        quest.completedAt = Date.now();
        grantRewards(quest.reward);
        notify?.(`Quest Complete: ${quest.name}!`, '#ffaa00');
        updateModal();
      }

      function renderQuests() {
        if (!listEl) return;
        listEl.innerHTML = '';
        quests.forEach(quest => {
          const card = document.createElement('div');
          card.style.cssText = 'background:#141f32;border:1px solid rgba(90,140,200,0.35);border-radius:10px;padding:14px 16px;display:flex;flex-direction:column;gap:8px;';
          const titleRow = document.createElement('div');
          titleRow.style.cssText = 'display:flex;justify-content:space-between;align-items:center;';
          const title = document.createElement('div');
          title.style.cssText = 'color:#cfe8ff;font-weight:600;';
          title.textContent = quest.name;
          const status = document.createElement('div');
          status.style.cssText = quest.completed ? 'color:#8be88b;font-weight:600;' : 'color:#9abacc;font-size:13px;';
          status.textContent = quest.completed ? 'Completed' : `${quest.progress}/${quest.target}`;

          // Phase 3: Add Accept button for quests with onAccept
          if (!quest.completed && !quest.accepted && quest.onAccept) {
            const acceptBtn = document.createElement('button');
            acceptBtn.textContent = 'Accept';
            acceptBtn.style.cssText = 'padding:4px 12px;background:#4CAF50;color:#fff;border:none;border-radius:4px;cursor:pointer;font-weight:600;margin-left:8px;';
            acceptBtn.onclick = () => {
              quest.accepted = true;
              if (typeof quest.onAccept === 'function') {
                quest.onAccept();
              }
              renderQuests();
            };
            titleRow.appendChild(acceptBtn);
          }
          titleRow.appendChild(title);
          titleRow.appendChild(status);
          const desc = document.createElement('div');
          desc.style.cssText = 'color:#9abacc;font-size:13px;';
          desc.textContent = quest.description || '';
          const barWrap = document.createElement('div');
          barWrap.style.cssText = 'position:relative;width:100%;height:8px;border-radius:4px;background:#0d1522;overflow:hidden;';
          const fill = document.createElement('div');
          const percent = quest.target ? Math.min(100, Math.round((quest.progress / quest.target) * 100)) : 0;
          fill.style.cssText = `height:100%;background:linear-gradient(90deg,#37b4ff,#51d7ff);width:${percent}%;transition:width 0.3s;`;
          barWrap.appendChild(fill);
          card.appendChild(titleRow);
          card.appendChild(desc);
          card.appendChild(barWrap);
          listEl.appendChild(card);
        });
      }

      function updateHeader() {
        if (!headerEl) return;
        const total = quests.length;
        const completed = quests.filter(q => q.completed).length;
        headerEl.textContent = `Quest Board — ${completed}/${total} completed`;
      }

      function updateModal() {
        if (!modal || modal.style.display === 'none') return;
        renderQuests();
        updateHeader();
      }

      function startZoneWatcher() {
        if (zoneHandle) return;
        const watch = () => {
          try {
            const leader = (window.st?.players || [])[window.st?.leader || 0];
            if (leader && typeof window.getZoneAt === 'function') {
              const zone = window.getZoneAt(leader.x || 0);
              if (zone && zone.name && zone.name !== lastZone) {
                lastZone = zone.name;
                trackProgress('explore', 1, zone.name);
              }
            }
          } catch (_) { }
          zoneHandle = requestAnimationFrame(watch);
        };
        zoneHandle = requestAnimationFrame(watch);
      }

      function openQuestBoard() {
        seedDefaults();
        ensureModal();
        renderQuests();
        updateHeader();
        modal.style.display = 'flex';
        modal.setAttribute('aria-hidden', 'false');
      }

      function trackProgress(type, amount = 1, detail = null) {
        seedDefaults();
        let updated = false;
        quests.forEach(quest => {
          if (quest.type !== type || quest.completed) return;
          switch (type) {
            case 'kill':
            case 'boss':
            case 'gold':
            case 'craft':
            case 'arena':
            case 'tame':
            case 'indoor_kill': {
              quest.progress = Math.min(quest.target, quest.progress + amount);
              updated = true;
              break;
            }
            case 'explore': {
              if (typeof detail === 'string') {
                quest._zones = quest._zones || new Set();
                const prev = quest._zones.size;
                quest._zones.add(detail);
                quest.progress = Math.min(quest.target, quest._zones.size);
                if (quest._zones.size !== prev) updated = true;
              }
              break;
            }
            default:
              break;
          }
          if (quest.progress >= quest.target && !quest.completed) {
            completeQuest(quest);
          }
        });
        if (updated) {
          updateModal();
          // Phase 3: Auto-save progress
          saveQuestProgress();
        }
      }

      // Phase 3: Add getQuest function
      function getQuest(questId) {
        return quests.find(q => q.id === questId) || null;
      }

      // Phase 3: Save quest progress
      function saveQuestProgress() {
        try {
          const questData = quests.map(q => ({
            id: q.id,
            progress: q.progress,
            completed: q.completed,
            accepted: q.accepted || false
          }));
          localStorage.setItem('a1k_quest_progress', JSON.stringify(questData));
        } catch (error) {
          console.error('[Quest] Failed to save progress:', error);
        }
      }

      // Phase 3: Load quest progress
      function loadQuestProgress() {
        try {
          const saved = localStorage.getItem('a1k_quest_progress');
          if (saved) {
            const questData = JSON.parse(saved);
            questData.forEach(saved => {
              const quest = quests.find(q => q.id === saved.id);
              if (quest) {
                quest.progress = saved.progress || 0;
                quest.completed = saved.completed || false;
                quest.accepted = saved.accepted || false;
              }
            });
          }
        } catch (error) {
          console.error('[Quest] Failed to load progress:', error);
        }
      }

      // Load progress after seeding
      setTimeout(loadQuestProgress, 100);

      return {
        quests,
        openQuestBoard,
        closeQuestBoard,
        trackProgress,
        completeQuest,
        addQuest,
        getQuest,
        startZoneWatcher,
        saveQuestProgress,
        loadQuestProgress
      };
    })();

    // ========================================
    // PHASE 3: ZOMBIE HUNT SYSTEM (PRIORITY)
    // ========================================
    window.ZombieHuntSystem = (function () {
      'use strict';

      const state = {
        active: false,
        zombies: [],
        totalKills: 0,
        targetKills: 10,
        questId: null
      };

      function startZombieHunt(questId) {
        if (state.active) {
          if (typeof notify === 'function') {
            notify('Zombie hunt already active!', '#ff7043');
          }
          return;
        }

        state.active = true;
        state.zombies = [];
        state.totalKills = 0;
        state.questId = questId;

        spawnZombies();

        if (typeof notify === 'function') {
          notify('Zombie hunt started! Kill 10 zombies inside the house!', '#9d4edd');
        }
      }

      function spawnZombies() {
        const W = (typeof DESIGN_W !== 'undefined' ? DESIGN_W : 1280);
        const H = (typeof DESIGN_H !== 'undefined' ? DESIGN_H : 720);

        for (let i = 0; i < state.targetKills; i++) {
          const zombie = {
            id: `zombie_${Date.now()}_${i}`,
            type: 'zombie',
            x: 200 + Math.random() * 800,
            y: H - 300 - Math.random() * 100,
            vx: (Math.random() < 0.5 ? -1 : 1) * (30 + Math.random() * 20),
            hp: 150,
            hpMax: 150,
            color: i % 2 === 0 ? '#9d4edd' : '#5aff6a',
            w: 36,
            h: 42,
            isZombie: true
          };
          state.zombies.push(zombie);
        }
      }

      function updateZombieHunt(dtSec) {
        if (!state.active) return;

        const W = (typeof DESIGN_W !== 'undefined' ? DESIGN_W : 1280);
        const minX = 150;
        const maxX = W - 150;

        state.zombies = state.zombies.filter(zombie => {
          if (zombie.hp <= 0) {
            state.totalKills++;

            // Award rewards
            const st = window.st || (window.st = {});
            const goldReward = Math.floor(100 + Math.random() * 150);
            st.gold = (st.gold || 0) + goldReward;

            if (typeof addFloater === 'function') {
              addFloater(zombie.x, zombie.y - 30, `+${goldReward}g 🧟`, '#9d4edd');
            }

            // Track quest progress
            try {
              window.QuestSystem?.trackProgress?.('zombie_hunt', 1);
            } catch (_) { }

            // Check if hunt complete
            if (state.totalKills >= state.targetKills) {
              completeZombieHunt();
            }

            return false;
          }

          // Zombie movement
          zombie.x += zombie.vx * dtSec;
          if (zombie.x < minX || zombie.x > maxX) {
            zombie.vx *= -1;
            zombie.x = Math.max(minX, Math.min(maxX, zombie.x));
          }

          return true;
        });
      }

      function completeZombieHunt() {
        state.active = false;
        state.zombies = [];

        // Award completion bonus
        const st = window.st || (window.st = {});
        st.gold = (st.gold || 0) + 500;

        if (typeof grantXP === 'function') {
          grantXP(300);
        }

        if (typeof notify === 'function') {
          notify('Zombie hunt complete! +500g, +300 XP', '#9d4edd');
        }

        // Complete quest
        if (state.questId && window.QuestSystem) {
          try {
            const quest = window.QuestSystem.getQuest(state.questId);
            if (quest) {
              quest.completed = true;
              quest.progress = quest.target;
            }
          } catch (_) { }
        }
      }

      function drawZombies(ctx) {
        if (!state.active || !ctx) return;

        ctx.save();
        state.zombies.forEach(zombie => {
          ctx.fillStyle = zombie.color;
          ctx.globalAlpha = 0.9;
          ctx.fillRect(zombie.x - zombie.w / 2, zombie.y - zombie.h / 2, zombie.w, zombie.h);
          ctx.globalAlpha = 1;

          // HP bar
          const hpRatio = Math.max(0, Math.min(1, zombie.hp / zombie.hpMax));
          ctx.fillStyle = 'rgba(20, 20, 30, 0.9)';
          ctx.fillRect(zombie.x - 20, zombie.y - zombie.h / 2 - 8, 40, 4);
          ctx.fillStyle = '#9d4edd';
          ctx.fillRect(zombie.x - 20, zombie.y - zombie.h / 2 - 8, 40 * hpRatio, 4);
        });
        ctx.restore();
      }

      function damageZombie(zombieId, damage) {
        const zombie = state.zombies.find(z => z.id === zombieId);
        if (zombie) {
          zombie.hp -= damage;
          if (zombie.hp <= 0) {
            zombie.hp = 0;
          }
          return true;
        }
        return false;
      }

      return {
        startZombieHunt,
        updateZombieHunt,
        drawZombies,
        damageZombie,
        get active() { return state.active; },
        get zombies() { return state.zombies; },
        get progress() { return `${state.totalKills}/${state.targetKills}`; }
      };
    })();

    // ========================================
    // PHASE 3: MONSTER HUNT SYSTEM (PRIORITY)
    // ========================================
    window.MonsterHuntSystem = (function () {
      'use strict';

      const state = {
        active: false,
        monsters: [],
        totalKills: 0,
        targetKills: 15,
        questId: null,
        huntZone: { x: 640, y: 360, w: 400, h: 300 }
      };

      function startMonsterHunt(questId) {
        if (state.active) {
          if (typeof notify === 'function') {
            notify('Monster hunt already active!', '#ff7043');
          }
          return;
        }

        state.active = true;
        state.monsters = [];
        state.totalKills = 0;
        state.questId = questId;

        // Set hunt zone based on current area
        const st = window.st || (window.st = {});
        const area = st.area || 1;
        const worldWidth = window.WORLD_WIDTH || window.DESIGN_W || 1280;
        state.huntZone = {
          x: worldWidth * 0.6,
          y: 300,
          w: 400,
          h: 250
        };

        spawnMonsters();

        if (typeof notify === 'function') {
          notify('Monster hunt started! Hunt area marked on screen!', '#ff6b35');
        }
      }

      function spawnMonsters() {
        const types = ['melee', 'ranged', 'flying'];

        for (let i = 0; i < state.targetKills; i++) {
          const type = types[i % types.length];
          const st = window.st || (window.st = {});
          const playerLevel = st.level || 1;

          const monster = {
            id: `monster_${Date.now()}_${i}`,
            type: type,
            kind: `hunt_${type}`,
            x: state.huntZone.x + (Math.random() - 0.5) * state.huntZone.w,
            y: state.huntZone.y + (Math.random() - 0.5) * state.huntZone.h,
            vx: (Math.random() < 0.5 ? -1 : 1) * (40 + Math.random() * 30),
            vy: type === 'flying' ? (Math.random() - 0.5) * 20 : 0,
            hp: 200 + playerLevel * 20,
            hpMax: 200 + playerLevel * 20,
            atk: 25 + playerLevel * 3,
            color: type === 'melee' ? '#ff6b35' : type === 'ranged' ? '#f72585' : '#4cc9f0',
            w: 40,
            h: 44,
            isMonster: true,
            huntType: type
          };
          state.monsters.push(monster);
        }
      }

      function updateMonsterHunt(dtSec) {
        if (!state.active) return;

        const zone = state.huntZone;

        state.monsters = state.monsters.filter(monster => {
          if (monster.hp <= 0) {
            state.totalKills++;

            // Award rewards
            const st = window.st || (window.st = {});
            const goldReward = Math.floor(150 + Math.random() * 200);
            st.gold = (st.gold || 0) + goldReward;

            if (typeof addFloater === 'function') {
              addFloater(monster.x, monster.y - 30, `+${goldReward}g 👹`, '#ff6b35');
            }

            // Track quest progress
            try {
              window.QuestSystem?.trackProgress?.('monster_hunt', 1);
            } catch (_) { }

            // Check if hunt complete
            if (state.totalKills >= state.targetKills) {
              completeMonsterHunt();
            }

            return false;
          }

          // Monster movement
          monster.x += monster.vx * dtSec;
          monster.y += monster.vy * dtSec;

          // Keep in zone
          if (monster.x < zone.x - zone.w / 2 || monster.x > zone.x + zone.w / 2) {
            monster.vx *= -1;
            monster.x = Math.max(zone.x - zone.w / 2, Math.min(zone.x + zone.w / 2, monster.x));
          }
          if (monster.huntType === 'flying') {
            if (monster.y < zone.y - zone.h / 2 || monster.y > zone.y + zone.h / 2) {
              monster.vy *= -1;
              monster.y = Math.max(zone.y - zone.h / 2, Math.min(zone.y + zone.h / 2, monster.y));
            }
          }

          return true;
        });
      }

      function completeMonsterHunt() {
        state.active = false;
        state.monsters = [];

        // Award completion bonus
        const st = window.st || (window.st = {});
        st.gold = (st.gold || 0) + 800;

        if (typeof grantXP === 'function') {
          grantXP(500);
        }

        if (typeof notify === 'function') {
          notify('Monster hunt complete! +800g, +500 XP', '#ff6b35');
        }

        // Complete quest
        if (state.questId && window.QuestSystem) {
          try {
            const quest = window.QuestSystem.getQuest(state.questId);
            if (quest) {
              quest.completed = true;
              quest.progress = quest.target;
            }
          } catch (_) { }
        }
      }

      function drawMonsters(ctx) {
        if (!state.active || !ctx) return;

        ctx.save();
        state.monsters.forEach(monster => {
          ctx.fillStyle = monster.color;
          ctx.globalAlpha = 0.85;
          ctx.fillRect(monster.x - monster.w / 2, monster.y - monster.h / 2, monster.w, monster.h);
          ctx.globalAlpha = 1;

          // HP bar
          const hpRatio = Math.max(0, Math.min(1, monster.hp / monster.hpMax));
          ctx.fillStyle = 'rgba(20, 20, 30, 0.9)';
          ctx.fillRect(monster.x - 22, monster.y - monster.h / 2 - 10, 44, 5);
          ctx.fillStyle = monster.color;
          ctx.fillRect(monster.x - 22, monster.y - monster.h / 2 - 10, 44 * hpRatio, 5);
        });
        ctx.restore();
      }

      function drawHuntZone(ctx) {
        if (!state.active || !ctx) return;

        const zone = state.huntZone;
        ctx.save();

        // Pulsing zone border
        const pulseAlpha = 0.3 + 0.2 * Math.sin(Date.now() / 300);
        ctx.strokeStyle = `rgba(255, 107, 53, ${pulseAlpha})`;
        ctx.lineWidth = 3;
        ctx.setLineDash([10, 5]);
        ctx.strokeRect(zone.x - zone.w / 2, zone.y - zone.h / 2, zone.w, zone.h);

        // Zone fill
        ctx.fillStyle = `rgba(255, 107, 53, 0.1)`;
        ctx.fillRect(zone.x - zone.w / 2, zone.y - zone.h / 2, zone.w, zone.h);

        ctx.restore();
      }

      function damageMonster(monsterId, damage) {
        const monster = state.monsters.find(m => m.id === monsterId);
        if (monster) {
          monster.hp -= damage;
          if (monster.hp <= 0) {
            monster.hp = 0;
          }
          return true;
        }
        return false;
      }

      return {
        startMonsterHunt,
        updateMonsterHunt,
        drawMonsters,
        drawHuntZone,
        damageMonster,
        get active() { return state.active; },
        get monsters() { return state.monsters; },
        get progress() { return `${state.totalKills}/${state.targetKills}`; }
      };
    })();

    window.ArenaSystem = (function () {
      const state = {
        active: false,
        currentWave: 0,
        maxWaves: 10,
        awaitingClear: false,
        rewardBank: 0,
        // Phase 2: Enhanced tracking
        totalWaves: 0,
        totalGold: 0,
        highestWave: 0,
        consecutiveWaves: 0
      };

      function clearArenaEnemies() {
        const st = window.st || (window.st = {});
        if (Array.isArray(st.enemies)) {
          st.enemies = st.enemies.filter(e => !e || !e.arenaEnemy);
        }
      }

      function spawnWave() {
        const st = window.st || (window.st = {});
        st.enemies = st.enemies || [];
        state.currentWave += 1;
        const count = Math.min(15, 3 + Math.floor(state.currentWave * 1.7));
        const baseHp = 240 + state.currentWave * 90;
        const baseAtk = 15 + state.currentWave * 7;
        const baseDef = 8 + state.currentWave * 2;
        const width = window.WORLD_WIDTH || window.DESIGN_W || 1280;
        for (let i = 0; i < count; i++) {
          const lane = i % 3;
          const hpBase = Math.round(baseHp + Math.random() * 80);
          const enemy = {
            id: `arena_${state.currentWave}_${i}_${Date.now()}`,
            kind: 'arena_minion',
            arenaEnemy: true,
            wave: state.currentWave,
            x: width + 120 + i * 32,
            y: typeof laneY === 'function' ? laneY(lane) : ((window.DESIGN_H || 720) - 140 + (lane - 1) * 40),
            lane,
            w: 42,
            h: 48,
            hp: hpBase,
            max: hpBase,
            atk: baseAtk,
            def: baseDef,
            vx: -0.22 - state.currentWave * 0.02,
            vy: 0,
            behavior: 'relentless',
            role: 'melee'
          };
          st.enemies.push(enemy);
        }
        state.awaitingClear = true;
        notify?.(`Arena Wave ${state.currentWave}/${state.maxWaves} has begun!`, '#ff9aa8');
      }

      function startArena() {
        if (state.active) {
          notify?.('Arena battle already active!', '#ffd56a');
          return;
        }
        state.active = true;
        state.currentWave = 0;
        state.rewardBank = 0;
        state.awaitingClear = false;
        state.consecutiveWaves = 0;
        clearArenaEnemies();
        // Phase 2: Preview rewards
        const projectedReward = Math.floor(1000 + (1 * 800) + 1000);
        notify?.(`Arena battle initiated! Wave 1 reward: ~${projectedReward}g`, '#ff6b35');
        spawnWave();
      }

      function onWaveComplete() {
        if (!state.active || !state.awaitingClear) return;
        state.awaitingClear = false;

        // Phase 2: Enhanced gold rewards (1k-10k range)
        const baseGold = 1000 + (state.currentWave * 800);
        const randomBonus = Math.floor(500 + Math.random() * 1000);
        state.consecutiveWaves += 1;
        const streakMultiplier = 1 + (state.consecutiveWaves * 0.05); // 5% per consecutive wave
        const waveReward = Math.floor((baseGold + randomBonus) * streakMultiplier);

        state.rewardBank += waveReward;
        state.totalWaves += 1;
        state.totalGold += waveReward;
        if (state.currentWave > state.highestWave) {
          state.highestWave = state.currentWave;
        }

        const st = window.st || (window.st = {});
        st.gold = (st.gold || 0) + waveReward;
        window.updateCurrencies?.();

        const streakText = state.consecutiveWaves > 1 ? ` (x${streakMultiplier.toFixed(2)} streak)` : '';
        notify?.(`Wave ${state.currentWave} cleared! +${waveReward}g${streakText}`, '#ffd56a');

        // Phase 2: Add XP reward
        if (typeof addFloater === 'function') {
          addFloater(640, 300, `+${Math.floor(waveReward / 100) / 10}k 💰`, '#ffd56a');
        }

        window.QuestSystem?.trackProgress?.('arena', 1, state.currentWave);

        if (state.currentWave >= state.maxWaves) {
          complete();
        } else {
          // Preview next wave reward
          const nextReward = Math.floor((1000 + ((state.currentWave + 1) * 800) + 1000) * (1 + ((state.consecutiveWaves + 1) * 0.05)));
          setTimeout(() => {
            notify?.(`Next wave reward: ~${nextReward}g`, '#9fd7ff');
            spawnWave();
          }, 800);
        }

        saveArenaStats();
      }

      function complete() {
        if (!state.active) return;
        state.active = false;
        notify?.(`Arena complete! Waves cleared: ${state.currentWave}`, '#6aa8ff');
        window.QuestSystem?.trackProgress?.('boss', 1, 'arena');

        // Phase 5: Add to leaderboard
        addToLeaderboard({
          waves: state.currentWave,
          gold: state.rewardBank,
          date: Date.now()
        });
      }

      // Phase 5.1: Arena Leaderboard
      function addToLeaderboard(entry) {
        try {
          const saved = localStorage.getItem('a1k_arena_leaderboard');
          let leaderboard = saved ? JSON.parse(saved) : [];

          leaderboard.push(entry);
          leaderboard.sort((a, b) => b.waves - a.waves);
          leaderboard = leaderboard.slice(0, 10); // Keep top 10

          localStorage.setItem('a1k_arena_leaderboard', JSON.stringify(leaderboard));

          // Check if current run is in top 10
          const rank = leaderboard.findIndex(e => e.date === entry.date) + 1;
          if (rank > 0 && rank <= 10) {
            notify?.(`New leaderboard entry! Rank #${rank}`, '#ffd700');
          }
        } catch (error) {
          console.error('[Arena] Failed to save leaderboard:', error);
        }
      }

      function getLeaderboard() {
        try {
          const saved = localStorage.getItem('a1k_arena_leaderboard');
          return saved ? JSON.parse(saved) : [];
        } catch (error) {
          console.error('[Arena] Failed to load leaderboard:', error);
          return [];
        }
      }

      function showLeaderboard() {
        const leaderboard = getLeaderboard();
        const modal = document.createElement('div');
        modal.style.cssText = `
          position: fixed;
          inset: 0;
          background: rgba(0,0,0,0.85);
          display: flex;
          align-items: center;
          justify-content: center;
          z-index: 7000;
        `;

        const panel = document.createElement('div');
        panel.style.cssText = `
          background: linear-gradient(145deg, #1a2332, #0f1824);
          border: 2px solid #ffd56a;
          border-radius: 16px;
          width: 500px;
          max-width: 95vw;
          max-height: 80vh;
          display: flex;
          flex-direction: column;
          box-shadow: 0 20px 60px rgba(0,0,0,0.5);
        `;

        panel.innerHTML = `
          <div style="padding:20px 24px;background:linear-gradient(90deg,#2a3f5f,#1e3049);border-bottom:1px solid #ffd56a;">
            <h2 style="margin:0;color:#ffd700;font-size:22px;text-align:center;">🏆 Arena Leaderboard</h2>
          </div>
          <div style="flex:1;overflow-y:auto;padding:20px;">
            ${leaderboard.length === 0 ? `
              <div style="text-align:center;padding:40px;color:#9baec8;">
                <p>No arena completions yet!</p>
                <p style="font-size:14px;margin-top:8px;">Complete an arena run to appear here.</p>
              </div>
            ` : `
              <div style="display:flex;flex-direction:column;gap:10px;">
                ${leaderboard.map((entry, index) => {
          const date = new Date(entry.date);
          const dateStr = date.toLocaleDateString();
          const rankColors = ['#ffd700', '#c0c0c0', '#cd7f32'];
          const rankColor = rankColors[index] || '#5ba3ff';
          return `
                    <div style="background:#1e3049;border:1px solid ${rankColor};border-radius:8px;padding:12px;display:flex;justify-content:space-between;align-items:center;">
                      <div style="display:flex;align-items:center;gap:12px;">
                        <span style="color:${rankColor};font-size:20px;font-weight:700;">#{${index + 1}}</span>
                        <div>
                          <div style="color:#e0f2ff;font-weight:600;">Wave ${entry.waves}</div>
                          <div style="color:#9baec8;font-size:12px;">${dateStr}</div>
                        </div>
                      </div>
                      <div style="color:#ffd56a;font-weight:600;">${entry.gold}g</div>
                    </div>
                  `;
        }).join('')}
              </div>
            `}
          </div>
          <div style="padding:14px 24px;background:#0f1824;display:flex;justify-content:space-between;">
            <button id="resetLeaderboard" style="padding:8px 16px;background:#ff5252;color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:600;">Reset</button>
            <button id="closeLeaderboard" style="padding:8px 16px;background:#2196F3;color:#fff;border:none;border-radius:6px;cursor:pointer;font-weight:600;">Close</button>
          </div>
        `;

        modal.appendChild(panel);
        document.body.appendChild(modal);

        panel.querySelector('#closeLeaderboard').onclick = () => modal.remove();
        modal.onclick = (e) => { if (e.target === modal) modal.remove(); };
        panel.querySelector('#resetLeaderboard').onclick = () => {
          if (confirm('Reset leaderboard? This cannot be undone.')) {
            localStorage.removeItem('a1k_arena_leaderboard');
            modal.remove();
            notify?.('Leaderboard reset', '#ff5252');
          }
        };
      }

      function exitArena() {
        if (!state.active) return;
        state.active = false;
        state.awaitingClear = false;
        state.consecutiveWaves = 0;
        clearArenaEnemies();
        notify?.('Arena run cancelled.', '#9fd7ff');
      }

      // Phase 2: Persistence for arena stats
      function saveArenaStats() {
        try {
          const stats = {
            totalWaves: state.totalWaves,
            totalGold: state.totalGold,
            highestWave: state.highestWave
          };
          localStorage.setItem('a1k_arena_stats', JSON.stringify(stats));
        } catch (error) {
          console.error('[Arena] Failed to save stats:', error);
        }
      }

      function loadArenaStats() {
        try {
          const saved = localStorage.getItem('a1k_arena_stats');
          if (saved) {
            const stats = JSON.parse(saved);
            state.totalWaves = stats.totalWaves || 0;
            state.totalGold = stats.totalGold || 0;
            state.highestWave = stats.highestWave || 0;
          }
        } catch (error) {
          console.error('[Arena] Failed to load stats:', error);
        }
      }

      loadArenaStats();

      return {
        get active() { return state.active; },
        get currentWave() { return state.currentWave; },
        get awaitingClear() { return state.awaitingClear; },
        maxWaves: state.maxWaves,
        startArena,
        spawnWave,
        onWaveComplete,
        complete,
        exitArena,
        showLeaderboard,
        getLeaderboard
      };
    })();
  </script>
  <script id="world-freeze-inline">
    (function () {
      if (window.WorldFreeze) return;

      const ENEMY_KEY = '__wf';
      const SHOT_KEY = '__wfShot';
      const VEHICLE_KEY = '__wfVeh';

      const safeState = () => window.st || null;

      const storeEnemy = (enemy) => {
        if (!enemy || enemy[ENEMY_KEY]) return;
        enemy[ENEMY_KEY] = {
          x: enemy.x,
          y: enemy.y,
          vx: enemy.vx,
          vy: enemy.vy,
          pfDir: enemy.pf?.dir,
          aiPaused: enemy.ai?.paused,
          anim: enemy.animFrame
        };
      };

      const applyEnemyFreeze = (enemy) => {
        const stored = enemy && enemy[ENEMY_KEY];
        if (!enemy || !stored) return;
        enemy.x = stored.x;
        enemy.y = stored.y;
        enemy.vx = 0;
        enemy.vy = 0;
        enemy.frozen = true;
        if (enemy.pf) enemy.pf.dir = 0;
        if (enemy.ai) enemy.ai.paused = true;
        if (typeof stored.anim === 'number') enemy.animFrame = stored.anim;
      };

      const releaseEnemy = (enemy) => {
        const stored = enemy && enemy[ENEMY_KEY];
        if (!enemy || !stored) return;
        enemy.x = stored.x;
        enemy.y = stored.y;
        if (typeof stored.vx === 'number') enemy.vx = stored.vx;
        if (typeof stored.vy === 'number') enemy.vy = stored.vy;
        if (enemy.pf && typeof stored.pfDir === 'number') enemy.pf.dir = stored.pfDir;
        if (enemy.ai && stored.aiPaused != null) enemy.ai.paused = stored.aiPaused;
        delete enemy[ENEMY_KEY];
        enemy.frozen = false;
      };

      const storeShot = (shot) => {
        if (!shot || shot[SHOT_KEY]) return;
        shot[SHOT_KEY] = { x: shot.x, y: shot.y, vx: shot.vx, vy: shot.vy, life: shot.life, timer: shot.timer };
      };

      const applyShotFreeze = (shot) => {
        const stored = shot && shot[SHOT_KEY];
        if (!shot || !stored) return;
        shot.x = stored.x;
        shot.y = stored.y;
        shot.vx = 0;
        shot.vy = 0;
        if ('ax' in shot) shot.ax = 0;
        if ('ay' in shot) shot.ay = 0;
        if (stored.life != null && 'life' in shot) shot.life = stored.life;
        if (stored.timer != null && 'timer' in shot) shot.timer = stored.timer;
      };

      const releaseShot = (shot) => {
        const stored = shot && shot[SHOT_KEY];
        if (!shot || !stored) return;
        shot.x = stored.x;
        shot.y = stored.y;
        if (stored.vx != null) shot.vx = stored.vx;
        if (stored.vy != null) shot.vy = stored.vy;
        if (stored.life != null && 'life' in shot) shot.life = stored.life;
        if (stored.timer != null && 'timer' in shot) shot.timer = stored.timer;
        delete shot[SHOT_KEY];
      };

      const storeVehicle = (veh) => {
        if (!veh || veh[VEHICLE_KEY]) return;
        veh[VEHICLE_KEY] = { x: veh.x, y: veh.y, vx: veh.vx, vy: veh.vy };
      };

      const applyVehicleFreeze = (veh) => {
        const stored = veh && veh[VEHICLE_KEY];
        if (!veh || !stored) return;
        veh.x = stored.x;
        veh.y = stored.y;
        veh.vx = 0;
        veh.vy = 0;
      };

      const releaseVehicle = (veh) => {
        const stored = veh && veh[VEHICLE_KEY];
        if (!veh || !stored) return;
        veh.x = stored.x;
        veh.y = stored.y;
        if (stored.vx != null) veh.vx = stored.vx;
        if (stored.vy != null) veh.vy = stored.vy;
        delete veh[VEHICLE_KEY];
      };

      const freezeShots = (st) => {
        const shots = st.shots || [];
        for (const shot of shots) {
          storeShot(shot);
          applyShotFreeze(shot);
        }
        const beams = st.beams || [];
        for (const beam of beams) {
          storeShot(beam);
          applyShotFreeze(beam);
        }
      };

      const releaseShots = (st) => {
        const shots = st.shots || [];
        for (const shot of shots) releaseShot(shot);
        const beams = st.beams || [];
        for (const beam of beams) releaseShot(beam);
      };

      window.WorldFreeze = {
        active: false,
        _prevSpawnPaused: null,
        freeze() {
          const st = safeState();
          this.active = true;
          if (!st) return;
          ensureHooks();

          if (this._prevSpawnPaused === null) this._prevSpawnPaused = !!st.spawnPaused;
          st.spawnPaused = true;

          if (typeof st.clock === 'number' && st._wfClock == null) st._wfClock = st.clock;
          if (typeof st.time === 'number' && st._wfTime == null) st._wfTime = st.time;

          const enemies = st.enemies || [];
          for (const enemy of enemies) {
            if (!enemy) continue;
            storeEnemy(enemy);
            applyEnemyFreeze(enemy);
          }

          const vehicles = st.vehicles || [];
          for (const veh of vehicles) {
            storeVehicle(veh);
            applyVehicleFreeze(veh);
          }

          freezeShots(st);

          if (st.boss && typeof st.boss === 'object') {
            st.boss._freeze = st.boss._freeze || {};
            if (st.boss._freeze.paused == null) st.boss._freeze.paused = st.boss.paused;
            st.boss._freeze.x = st.boss.x;
            st.boss._freeze.y = st.boss.y;
            st.boss.paused = true;
          }
        },
        resume() {
          const st = safeState();
          this.active = false;
          if (!st) return;

          st.spawnPaused = this._prevSpawnPaused === null ? false : this._prevSpawnPaused;
          this._prevSpawnPaused = null;

          const enemies = st.enemies || [];
          for (const enemy of enemies) releaseEnemy(enemy);

          const vehicles = st.vehicles || [];
          for (const veh of vehicles) releaseVehicle(veh);

          releaseShots(st);

          if (st._wfClock != null) delete st._wfClock;
          if (st._wfTime != null) delete st._wfTime;

          if (st.boss && st.boss._freeze) {
            if (st.boss._freeze.paused != null) st.boss.paused = st.boss._freeze.paused;
            if (st.boss._freeze.x != null) st.boss.x = st.boss._freeze.x;
            if (st.boss._freeze.y != null) st.boss.y = st.boss._freeze.y;
            delete st.boss._freeze;
          }
        }
      };

      const enforceFreeze = () => {
        if (!window.WorldFreeze?.active) return;
        const st = safeState();
        if (!st) return;

        if (st._wfClock != null) st.clock = st._wfClock;
        if (st._wfTime != null) st.time = st._wfTime;

        const enemies = st.enemies || [];
        for (const enemy of enemies) {
          if (!enemy) continue;
          storeEnemy(enemy);
          applyEnemyFreeze(enemy);
        }

        const vehicles = st.vehicles || [];
        for (const veh of vehicles) {
          storeVehicle(veh);
          applyVehicleFreeze(veh);
        }

        freezeShots(st);
      };

      const wrapUpdate = () => {
        const original = window.update;
        if (typeof original !== 'function' || original.__wfWrapped) return;
        const wrapped = function () {
          const result = original.apply(this, arguments);
          enforceFreeze();
          return result;
        };
        wrapped.__wfWrapped = true;
        window.update = wrapped;
      };

      const hookRAF = () => {
        const base = window.requestAnimationFrame;
        if (!base || base.__wfHooked) return;
        const wrapped = function (cb) {
          return base.call(this, function (time) {
            const out = cb(time);
            enforceFreeze();
            return out;
          });
        };
        wrapped.__wfHooked = true;
        window.requestAnimationFrame = wrapped;
      };

      const patchHouseInterior = () => {
        const H = window.HouseInterior;
        if (!H || H._freezePatched) return;
        const enterOrig = H.enter ? H.enter.bind(H) : null;
        const exitOrig = H.exit ? H.exit.bind(H) : null;
        if (enterOrig) {
          H.enter = function wrappedEnter(house) {
            const result = enterOrig(house);
            try { window.WorldFreeze?.freeze(); } catch (_) { }
            return result;
          };
        }
        if (exitOrig) {
          H.exit = function wrappedExit() {
            try { window.WorldFreeze?.resume(); } catch (_) { }
            return exitOrig();
          };
        }
        H._freezePatched = true;
      };

      const ensureHooks = () => {
        wrapUpdate();
        hookRAF();
        patchHouseInterior();
      };

      ensureHooks();
      document.addEventListener('DOMContentLoaded', ensureHooks);
      setTimeout(ensureHooks, 0);
      setInterval(() => {
        ensureHooks();
        if (window.WorldFreeze?.active) enforceFreeze();
      }, 250);
    })();
  </script>
  <script id="missy-arcade-system">
    (function () {
      if (window.MissyArcadeGame) return;

      const decodeArcadeBase64 = (input) => {
        if (!input) return "";
        try { return atob(input); } catch (err) {
          if (typeof Buffer !== "undefined") {
            try { return Buffer.from(input, "base64").toString("utf-8"); } catch (_) { return ""; }
          }
          return "";
        }
      };

      const MISSY_ARCADE_B64 =
        'ICAgIDxkaXYgaWQ9ImdhbWVDb250YWluZXIiPgogICAgICAgIDwhLS0gVG9wIEJhciAtLT4KICAgICAgICA8ZGl2IGlkPSJ0'
      'b3BCYXIiPgogICAgICAgICAgICA8ZGl2IGNsYXNzPSJzdGF0LWJveCI+CiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJz'
      'dGF0LWljb24iIHN0eWxlPSJiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoMTM1ZGVnLCAjZjA5M2ZiLCAjZjU1NzZjKTsi'
      'PvCfjq88L2Rpdj4KICAgICAgICAgICAgICAgIDxkaXYgaWQ9ImxldmVsRGlzcGxheSI+TGV2ZWwgMTwvZGl2PgogICAgICAg'
      'ICAgICA8L2Rpdj4KICAgICAgICAgICAgPGRpdiBjbGFzcz0ic3RhdC1ib3giPgogICAgICAgICAgICAgICAgPGRpdiBjbGFz'
      'cz0ic3RhdC1pY29uIiBzdHlsZT0iYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KDEzNWRlZywgI2ZmZWFhNywgI2ZkY2I2'
      'ZSk7Ij7irZA8L2Rpdj4KICAgICAgICAgICAgICAgIDxkaXYgaWQ9InNjb3JlRGlzcGxheSI+MDwvZGl2PgogICAgICAgICAg'
      'ICA8L2Rpdj4KICAgICAgICAgICAgPGRpdiBjbGFzcz0ic3RhdC1ib3giPgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0i'
      'c3RhdC1pY29uIiBzdHlsZT0iYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KDEzNWRlZywgIzc0YjlmZiwgIzA5ODRlMyk7'
      'Ij7wn46qPC9kaXY+CiAgICAgICAgICAgICAgICA8ZGl2IGlkPSJtb3Zlc0Rpc3BsYXkiPjMwIG1vdmVzPC9kaXY+CiAgICAg'
      'ICAgICAgIDwvZGl2PgogICAgICAgICAgICA8ZGl2IGNsYXNzPSJzdGF0LWJveCI+CiAgICAgICAgICAgICAgICA8ZGl2IGNs'
      'YXNzPSJzdGF0LWljb24iIHN0eWxlPSJiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoMTM1ZGVnLCAjNTVlZmM0LCAjMDBi'
      'ODk0KTsiPvCfjrI8L2Rpdj4KICAgICAgICAgICAgICAgIDxkaXYgaWQ9InRhcmdldERpc3BsYXkiPlNjb3JlOiA1MDAwPC9k'
      'aXY+CiAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICA8ZGl2IGNsYXNzPSJzdGF0LWJveCBtZW51LWJ1dHRvbiIgb25j'
      'bGljaz0idG9nZ2xlU2tpbGxzTWVudSgpIj4KICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9InN0YXQtaWNvbiIgc3R5bGU9'
      'ImJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCgxMzVkZWcsICNmZDc5YTgsICNlODQzOTMpOyI+4pqZ77iPPC9kaXY+CiAg'
      'ICAgICAgICAgICAgICA8ZGl2PlNraWxsczwvZGl2PgogICAgICAgICAgICA8L2Rpdj4KICAgICAgICA8L2Rpdj4KCiAgICAg'
      'ICAgPCEtLSBDaGFyYWN0ZXIgUGFuZWwgKE1pc3N5KSAtLT4KICAgICAgICA8ZGl2IGlkPSJjaGFyYWN0ZXJQYW5lbCI+CiAg'
      'ICAgICAgICAgIDxkaXYgY2xhc3M9ImNoYXJhY3RlciI+CiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJjaGFyYWN0ZXIt'
      'YXZhdGFyIj4KICAgICAgICAgICAgICAgICAgICA8aW1nIHNyYz0icGxheWVyX21pc3N5LnBuZyIgYWx0PSJNaXNzeSIgc3R5'
      'bGU9IndpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7IG9iamVjdC1maXQ6IGNvdmVyOyBib3JkZXItcmFkaXVzOiA1MCU7Ij4K'
      'ICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iY2hhcmFjdGVyLW5hbWUiPk1pc3N5'
      'PC9kaXY+CiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPSJmb250LXNpemU6IDEycHg7IGNvbG9yOiAjNjY2OyBtYXJnaW4t'
      'dG9wOiA1cHg7Ij5SYWluYm93IFByaW5jZXNzPC9kaXY+CiAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICA8ZGl2IGNs'
      'YXNzPSJjaGFyYWN0ZXItcG93ZXIiIG9uY2xpY2s9InVzZU1pc3N5UG93ZXIoKSI+CiAgICAgICAgICAgICAgICA8ZGl2PuKc'
      'qCBSYWluYm93IEJsYXN0PC9kaXY+CiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPSJmb250LXNpemU6IDEwcHg7IG1hcmdp'
      'bi10b3A6IDVweDsiPkNsZWFycyBhIGNvbG9yPC9kaXY+CiAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICA8ZGl2IGNs'
      'YXNzPSJjaGFyYWN0ZXItcG93ZXIiIG9uY2xpY2s9InN1bW1vbk1pc3N5SGVscGVyKCkiPgogICAgICAgICAgICAgICAgPGRp'
      'dj7wn5GKIEF1dG8gQXR0YWNrPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBzdHlsZT0iZm9udC1zaXplOiAxMHB4'
      'OyBtYXJnaW4tdG9wOiA1cHg7Ij5EZXN0cm95cyAzIG9ic3RhY2xlczwvZGl2PgogICAgICAgICAgICA8L2Rpdj4KICAgICAg'
      'ICAgICAgPGRpdiBzdHlsZT0ibWFyZ2luLXRvcDogMjBweDsgcGFkZGluZzogMTBweDsgYmFja2dyb3VuZDogcmdiYSgxMDIs'
      'MTI2LDIzNCwwLjIpOyBib3JkZXItcmFkaXVzOiAxMHB4OyI+CiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPSJmb250LXNp'
      'emU6IDEycHg7IGNvbG9yOiAjNzY0YmEyOyBmb250LXdlaWdodDogYm9sZDsiPlBvd2VyOjwvZGl2PgogICAgICAgICAgICAg'
      'ICAgPGRpdiBzdHlsZT0iZm9udC1zaXplOiAyNHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IGNvbG9yOiAjZjU1NzZjOyI+4pqh'
      'IDxzcGFuIGlkPSJtaXNzeVBvd2VyIj4zPC9zcGFuPjwvZGl2PgogICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgPGRp'
      'diBzdHlsZT0ibWFyZ2luLXRvcDogMTBweDsgcGFkZGluZzogMTBweDsgYmFja2dyb3VuZDogcmdiYSgxMDIsMTI2LDIzNCww'
      'LjIpOyBib3JkZXItcmFkaXVzOiAxMHB4OyI+CiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPSJmb250LXNpemU6IDEycHg7'
      'IGNvbG9yOiAjNzY0YmEyOyBmb250LXdlaWdodDogYm9sZDsiPkhlbHBlciBDaGFyZ2VzOjwvZGl2PgogICAgICAgICAgICAg'
      'ICAgPGRpdiBzdHlsZT0iZm9udC1zaXplOiAyNHB4OyB0ZXh0LWFsaWduOiBjZW50ZXI7IGNvbG9yOiAjZjU1NzZjOyI+CiAg'
      'ICAgICAgICAgICAgICAgICAg8J+RiiA8c3BhbiBpZD0ibWlzc3lIZWxwZXJDaGFyZ2VzIj4zPC9zcGFuPgogICAgICAgICAg'
      'ICAgICAgPC9kaXY+CiAgICAgICAgICAgIDwvZGl2PgogICAgICAgIDwvZGl2PgoKICAgICAgICA8IS0tIE1ldGEgTGF5ZXIg'
      'LS0+CiAgICAgICAgPGRpdiBpZD0ibWV0YUxheWVyIj4KICAgICAgICAgICAgPGRpdiBjbGFzcz0ibWV0YS1pdGVtIiBvbmNs'
      'aWNrPSJvcGVuQ2FzdGxlKCkiPgogICAgICAgICAgICAgICAgPGRpdiBzdHlsZT0iZm9udC1zaXplOiAzMnB4OyI+8J+PsDwv'
      'ZGl2PgogICAgICAgICAgICAgICAgPGRpdiBzdHlsZT0iZm9udC1zaXplOiAxNHB4OyBmb250LXdlaWdodDogYm9sZDsiPlJv'
      'eWFsIENhc3RsZTwvZGl2PgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ibWV0YS1wcm9ncmVzcyI+CiAgICAgICAgICAg'
      'ICAgICAgICAgPGRpdiBjbGFzcz0ibWV0YS1wcm9ncmVzcy1maWxsIiBpZD0iY2FzdGxlUHJvZ3Jlc3MiIHN0eWxlPSJ3aWR0'
      'aDogMCU7Ij48L2Rpdj4KICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgPGRp'
      'diBjbGFzcz0ibWV0YS1pdGVtIiBvbmNsaWNrPSJvcGVuR2FyZGVuKCkiPgogICAgICAgICAgICAgICAgPGRpdiBzdHlsZT0i'
      'Zm9udC1zaXplOiAzMnB4OyI+8J+MuDwvZGl2PgogICAgICAgICAgICAgICAgPGRpdiBzdHlsZT0iZm9udC1zaXplOiAxNHB4'
      'OyBmb250LXdlaWdodDogYm9sZDsiPk1hZ2ljIEdhcmRlbjwvZGl2PgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ibWV0'
      'YS1wcm9ncmVzcyI+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ibWV0YS1wcm9ncmVzcy1maWxsIiBpZD0iZ2Fy'
      'ZGVuUHJvZ3Jlc3MiIHN0eWxlPSJ3aWR0aDogMCU7Ij48L2Rpdj4KICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAg'
      'ICA8L2Rpdj4KICAgICAgICAgICAgPGRpdiBjbGFzcz0ibWV0YS1pdGVtIiBvbmNsaWNrPSJvcGVuQXF1YXJpdW0oKSI+CiAg'
      'ICAgICAgICAgICAgICA8ZGl2IHN0eWxlPSJmb250LXNpemU6IDMycHg7Ij7wn5CgPC9kaXY+CiAgICAgICAgICAgICAgICA8'
      'ZGl2IHN0eWxlPSJmb250LXNpemU6IDE0cHg7IGZvbnQtd2VpZ2h0OiBib2xkOyI+Q3J5c3RhbCBBcXVhcml1bTwvZGl2Pgog'
      'ICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0ibWV0YS1wcm9ncmVzcyI+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFz'
      'cz0ibWV0YS1wcm9ncmVzcy1maWxsIiBpZD0iYXF1YXJpdW1Qcm9ncmVzcyIgc3R5bGU9IndpZHRoOiAwJTsiPjwvZGl2Pgog'
      'ICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgIDwvZGl2PgogICAgICAgIDwvZGl2PgoKICAgICAgICA8IS0tIEdh'
      'bWUgQm9hcmQgLS0+CiAgICAgICAgPGRpdiBpZD0iZ2FtZUJvYXJkIj4KICAgICAgICAgICAgPGRpdiBpZD0iZ3JpZCI+PC9k'
      'aXY+CiAgICAgICAgICAgIDwhLS0gTWlzc3kgSGVscGVyIFNwcml0ZSAtLT4KICAgICAgICAgICAgPGRpdiBpZD0ibWlzc3lI'
      'ZWxwZXIiIGNsYXNzPSJtaXNzeS1oZWxwZXIiIHN0eWxlPSJkaXNwbGF5OiBub25lOyI+CiAgICAgICAgICAgICAgICA8aW1n'
      'IHNyYz0icGxheWVyX21pc3N5LnBuZyIgYWx0PSJNaXNzeSI+CiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJtaXNzeS1h'
      'dHRhY2staW5kaWNhdG9yIj7imqE8L2Rpdj4KICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9Im1pc3N5LXR1cm5zLWluZGlj'
      'YXRvciIgaWQ9Im1pc3N5VHVybnNEaXNwbGF5Ij4zIG9ic3RhY2xlczwvZGl2PgogICAgICAgICAgICA8L2Rpdj4KICAgICAg'
      'ICA8L2Rpdj4KCgogICAgICAgIDwhLS0gTGV2ZWwgU2VsZWN0IFNjcmVlbiAtLT4KICAgICAgICA8ZGl2IGlkPSJsZXZlbFNl'
      'bGVjdCI+CiAgICAgICAgICAgIDxoMSBzdHlsZT0idGV4dC1hbGlnbjogY2VudGVyOyBjb2xvcjogd2hpdGU7IGZvbnQtc2l6'
      'ZTogNDhweDsgbWFyZ2luLWJvdHRvbTogNDBweDsgdGV4dC1zaGFkb3c6IDAgNHB4IDEwcHggcmdiYSgwLDAsMCwwLjMpOyI+'
      'CiAgICAgICAgICAgICAgICDwn4yfIFN3ZWV0IEtpbmdkb20gSm91cm5leSDwn4yfCiAgICAgICAgICAgIDwvaDE+CiAgICAg'
      'ICAgICAgIDxkaXYgY2xhc3M9ImxldmVsLWdyaWQiIGlkPSJsZXZlbEdyaWQiPjwvZGl2PgogICAgICAgIDwvZGl2PgoKICAg'
      'ICAgICA8IS0tIFZpY3RvcnkgU2NyZWVuIC0tPgogICAgICAgIDxkaXYgaWQ9InZpY3RvcnlTY3JlZW4iPgogICAgICAgICAg'
      'ICA8ZGl2IGNsYXNzPSJyZXN1bHQtcGFuZWwiPgogICAgICAgICAgICAgICAgPGgxPvCfjokgVmljdG9yeSEg8J+OiTwvaDE+'
      'CiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJzdGFycy1kaXNwbGF5IiBpZD0ic3RhcnNFYXJuZWQiPuKtkOKtkOKtkDwv'
      'ZGl2PgogICAgICAgICAgICAgICAgPGRpdiBzdHlsZT0iZm9udC1zaXplOiAyNHB4OyBtYXJnaW46IDIwcHggMDsiPgogICAg'
      'ICAgICAgICAgICAgICAgIFNjb3JlOiA8c3BhbiBpZD0iZmluYWxTY29yZSI+MDwvc3Bhbj4KICAgICAgICAgICAgICAgIDwv'
      'ZGl2PgogICAgICAgICAgICAgICAgPGRpdj4KICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIG9uY2xpY2s9Im5leHRMZXZl'
      'bCgpIj5OZXh0IExldmVsIOKeoe+4jzwvYnV0dG9uPgogICAgICAgICAgICAgICAgICAgIDxidXR0b24gb25jbGljaz0icmV0'
      'cnlMZXZlbCgpIj5SZXRyeSDwn5SEPC9idXR0b24+CiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBvbmNsaWNrPSJiYWNr'
      'VG9NZW51KCkiPk1lbnUg8J+PoDwvYnV0dG9uPgogICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgIDwvZGl2Pgog'
      'ICAgICAgIDwvZGl2PgoKICAgICAgICA8IS0tIERlZmVhdCBTY3JlZW4gLS0+CiAgICAgICAgPGRpdiBpZD0iZGVmZWF0U2Ny'
      'ZWVuIj4KICAgICAgICAgICAgPGRpdiBjbGFzcz0icmVzdWx0LXBhbmVsIiBzdHlsZT0iYmFja2dyb3VuZDogbGluZWFyLWdy'
      'YWRpZW50KDEzNWRlZywgI2ZmNzY3NSwgI2Q2MzAzMSk7Ij4KICAgICAgICAgICAgICAgIDxoMT7wn5iiIExldmVsIEZhaWxl'
      'ZDwvaDE+CiAgICAgICAgICAgICAgICA8ZGl2IHN0eWxlPSJmb250LXNpemU6IDI0cHg7IG1hcmdpbjogMjBweCAwOyI+CiAg'
      'ICAgICAgICAgICAgICAgICAgU2NvcmU6IDxzcGFuIGlkPSJmYWlsU2NvcmUiPjA8L3NwYW4+CiAgICAgICAgICAgICAgICA8'
      'L2Rpdj4KICAgICAgICAgICAgICAgIDxkaXYgc3R5bGU9ImZvbnQtc2l6ZTogMTZweDsgbWFyZ2luOiAyMHB4IDA7Ij4KICAg'
      'ICAgICAgICAgICAgICAgICBEb24ndCBnaXZlIHVwISBUcnkgYWdhaW4hCiAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAg'
      'ICAgICAgICAgIDxkaXY+CiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBvbmNsaWNrPSJyZXRyeUxldmVsKCkiPlJldHJ5'
      'IPCflIQ8L2J1dHRvbj4KICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIG9uY2xpY2s9ImJhY2tUb01lbnUoKSI+TWVudSDw'
      'n4+gPC9idXR0b24+CiAgICAgICAgICAgICAgICA8L2Rpdj4KICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgPC9kaXY+Cgog'
      'ICAgICAgIDwhLS0gQ29tYm8gRGlzcGxheSAtLT4KICAgICAgICA8ZGl2IGlkPSJjb21ib0Rpc3BsYXkiPjwvZGl2PgogICAg'
      'PC9kaXY+CgogICAgPCEtLSBTa2lsbHMgT3ZlcmxheSAtLT4KICAgIDxkaXYgaWQ9InNraWxsc092ZXJsYXkiPgogICAgICAg'
      'IDxkaXYgY2xhc3M9InNraWxscy1jb250ZW50Ij4KICAgICAgICAgICAgPGRpdiBjbGFzcz0ic2tpbGxzLWhlYWRlciI+CiAg'
      'ICAgICAgICAgICAgICA8aDM+U2tpbGxzICYgQm9vc3RlcnM8L2gzPgogICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz0i'
      'Y2xvc2UtYnV0dG9uIiBvbmNsaWNrPSJjbG9zZVNraWxsc01lbnUoKSI+4pyVPC9idXR0b24+CiAgICAgICAgICAgIDwvZGl2'
      'PgogICAgICAgICAgICA8ZGl2IGlkPSJza2lsbHNCb3R0b21CYXIiPgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iYm9v'
      'c3Rlci1idG4iIG9uY2xpY2s9InVzZUJvb3N0ZXIoJ2hhbW1lcicpIiB0aXRsZT0iSGFtbWVyIC0gU21hc2ggb25lIGNhbmR5'
      'Ij4KICAgICAgICAgICAgICAgICAgICA8ZGl2PvCflKg8L2Rpdj4KICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJi'
      'b29zdGVyLWNvdW50IiBpZD0iaGFtbWVyQ291bnQiPjU8L2Rpdj4KICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAg'
      'ICAgICAgPGRpdiBjbGFzcz0iYm9vc3Rlci1idG4iIG9uY2xpY2s9InVzZUJvb3N0ZXIoJ3N3YXAnKSIgdGl0bGU9IlN3YXAg'
      'LSBTd2FwIGFueSB0d28gY2FuZGllcyI+CiAgICAgICAgICAgICAgICAgICAgPGRpdj7wn5SEPC9kaXY+CiAgICAgICAgICAg'
      'ICAgICAgICAgPGRpdiBjbGFzcz0iYm9vc3Rlci1jb3VudCIgaWQ9InN3YXBDb3VudCI+MzwvZGl2PgogICAgICAgICAgICAg'
      'ICAgPC9kaXY+CiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPSJib29zdGVyLWJ0biIgb25jbGljaz0idXNlQm9vc3Rlcign'
      'cmFpbmJvdycpIiB0aXRsZT0iUmFpbmJvdyAtIENsZWFyIGFsbCBvZiBvbmUgY29sb3IiPgogICAgICAgICAgICAgICAgICAg'
      'IDxkaXY+8J+MiDwvZGl2PgogICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9ImJvb3N0ZXItY291bnQiIGlkPSJyYWlu'
      'Ym93Q291bnQiPjI8L2Rpdj4KICAgICAgICAgICAgICAgIDwvZGl2PgogICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iYm9v'
      'c3Rlci1idG4iIG9uY2xpY2s9InVzZUJvb3N0ZXIoJ2JvbWInKSIgdGl0bGU9IkJvbWIgLSBDbGVhciAzeDMgYXJlYSI+CiAg'
      'ICAgICAgICAgICAgICAgICAgPGRpdj7wn5KjPC9kaXY+CiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz0iYm9vc3Rl'
      'ci1jb3VudCIgaWQ9ImJvbWJDb3VudCI+MzwvZGl2PgogICAgICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgICAgICAgICA8'
      'ZGl2IGNsYXNzPSJib29zdGVyLWJ0biIgb25jbGljaz0idXNlQm9vc3Rlcignc2h1ZmZsZScpIiB0aXRsZT0iU2h1ZmZsZSAt'
      'IFJlbWl4IGFsbCBjYW5kaWVzIj4KICAgICAgICAgICAgICAgICAgICA8ZGl2PvCfjrI8L2Rpdj4KICAgICAgICAgICAgICAg'
      'ICAgICA8ZGl2IGNsYXNzPSJib29zdGVyLWNvdW50IiBpZD0ic2h1ZmZsZUNvdW50Ij4yPC9kaXY+CiAgICAgICAgICAgICAg'
      'ICA8L2Rpdj4KICAgICAgICAgICAgPC9kaXY+CiAgICAgICAgPC9kaXY+CiAgICA8L2Rpdj4KCiAgICA8c2NyaXB0PgogICAg'
      'ICAgIC8vIEdhbWUgU3RhdGUKICAgICAgICBjb25zdCBHUklEX1NJWkUgPSA4OwogICAgICAgIGNvbnN0IENBTkRZX1RZUEVT'
      'ID0gWyfwn42tJywgJ/CfjawnLCAn8J+NqycsICfwn42pJywgJ/CfjoInLCAn8J+NsCddOwogICAgICAgIGNvbnN0IFNQRUNJ'
      'QUxfQ0FORElFUyA9IHsKICAgICAgICAgICAgc3RyaXBlZF9oOiB7ZW1vamk6ICfinKgnLCBjbGFzc05hbWU6ICdzcGVjaWFs'
      'LXN0cmlwZWQtaCd9LAogICAgICAgICAgICBzdHJpcGVkX3Y6IHtlbW9qaTogJ+KaoScsIGNsYXNzTmFtZTogJ3NwZWNpYWwt'
      'c3RyaXBlZC12J30sCiAgICAgICAgICAgIHdyYXBwZWQ6IHtlbW9qaTogJ/Cfko4nLCBjbGFzc05hbWU6ICdzcGVjaWFsLXdy'
      'YXBwZWQnfSwKICAgICAgICAgICAgY29sb3JfYm9tYjoge2Vtb2ppOiAn8J+MnycsIGNsYXNzTmFtZTogJ3NwZWNpYWwtY29s'
      'b3ItYm9tYid9CiAgICAgICAgfTsKCiAgICAgICAgY29uc3QgT0JTVEFDTEVTID0gewogICAgICAgICAgICBDQU5EWV9IUDog'
      'eyBlbW9qaTogJ/Cfja0nLCBocDogMywgcG9pbnRzOiAxNTAgfSwKICAgICAgICAgICAgQ0FLRV9IUDogeyBlbW9qaTogJ/Cf'
      'joInLCBocDogNSwgcG9pbnRzOiAyNTAgfSwKICAgICAgICAgICAgQ0hPQ09MQVRFX0hQOiB7IGVtb2ppOiAn8J+NqycsIGhw'
      'OiA0LCBwb2ludHM6IDIwMCB9LAogICAgICAgICAgICBET05VVF9IUDogeyBlbW9qaTogJ/CfjaknLCBocDogMiwgcG9pbnRz'
      'OiAxMDAgfQogICAgICAgIH07CgogICAgICAgIGxldCBnYW1lU3RhdGUgPSB7CiAgICAgICAgICAgIGN1cnJlbnRMZXZlbDog'
      'MSwKICAgICAgICAgICAgc2NvcmU6IDAsCiAgICAgICAgICAgIG1vdmVzOiAzMCwKICAgICAgICAgICAgZ3JpZDogW10sCiAg'
      'ICAgICAgICAgIHNlbGVjdGVkQ2VsbDogbnVsbCwKICAgICAgICAgICAgaXNQcm9jZXNzaW5nOiBmYWxzZSwKICAgICAgICAg'
      'ICAgY29tYm86IDAsCiAgICAgICAgICAgIGJvb3N0ZXJzOiB7CiAgICAgICAgICAgICAgICBoYW1tZXI6IDUsCiAgICAgICAg'
      'ICAgICAgICBzd2FwOiAzLAogICAgICAgICAgICAgICAgcmFpbmJvdzogMiwKICAgICAgICAgICAgICAgIGJvbWI6IDMsCiAg'
      'ICAgICAgICAgICAgICBzaHVmZmxlOiAyCiAgICAgICAgICAgIH0sCiAgICAgICAgICAgIG1pc3N5UG93ZXI6IDMsCiAgICAg'
      'ICAgICAgIG1pc3N5SGVscGVyOiB7CiAgICAgICAgICAgICAgICBhY3RpdmU6IGZhbHNlLAogICAgICAgICAgICAgICAgY2hh'
      'cmdlczogMywKICAgICAgICAgICAgICAgIG9ic3RhY2xlc0Rlc3Ryb3llZDogMCwKICAgICAgICAgICAgICAgIG9ic3RhY2xl'
      'c1JlbWFpbmluZzogMywKICAgICAgICAgICAgICAgIGF0dGFja0ludGVydmFsOiA0MDAwLAogICAgICAgICAgICAgICAgYXR0'
      'YWNrSW50ZXJ2YWxJZDogbnVsbCwKICAgICAgICAgICAgICAgIGxhc3RBdHRhY2tUaW1lOiAwLAogICAgICAgICAgICAgICAg'
      'cG9zaXRpb246IHt4OiAwLCB5OiAwfSwKICAgICAgICAgICAgICAgIGhhc1NwZWNpZmljVGFyZ2V0OiBmYWxzZSwKICAgICAg'
      'ICAgICAgICAgIHRhcmdldFJvdzogbnVsbCwKICAgICAgICAgICAgICAgIHRhcmdldENvbDogbnVsbAogICAgICAgICAgICB9'
      'LAogICAgICAgICAgICBvYnN0YWNsZUhlYWx0aDoge30sCiAgICAgICAgICAgIHNwZWNpYWxzOiB7fSwKICAgICAgICAgICAg'
      'Y29sbGVjdFByb2dyZXNzOiB7fSwKICAgICAgICAgICAgb2JzdGFjbGVzQ2xlYXJlZDogMCwKICAgICAgICAgICAgbWF4Q29t'
      'Ym86IDAsCiAgICAgICAgICAgIGFjdGl2ZUJvb3N0ZXI6IG51bGwsCiAgICAgICAgICAgIGJvb3N0ZXJUYXJnZXRzOiBbXSwK'
      'ICAgICAgICAgICAgcHJvZ3Jlc3M6IHsKICAgICAgICAgICAgICAgIGNhc3RsZTogMCwKICAgICAgICAgICAgICAgIGdhcmRl'
      'bjogMCwKICAgICAgICAgICAgICAgIGFxdWFyaXVtOiAwLAogICAgICAgICAgICAgICAgc3RhcnM6IDAKICAgICAgICAgICAg'
      'fSwKICAgICAgICAgICAgbGV2ZWxzOiBBcnJheS5mcm9tKHtsZW5ndGg6IDEyMH0sIChfLCBpKSA9PiAoewogICAgICAgICAg'
      'ICAgICAgbnVtYmVyOiBpICsgMSwKICAgICAgICAgICAgICAgIHVubG9ja2VkOiBpID09PSAwLAogICAgICAgICAgICAgICAg'
      'c3RhcnM6IDAsCiAgICAgICAgICAgICAgICBjb21wbGV0ZWQ6IGZhbHNlLAogICAgICAgICAgICAgICAgb2JqZWN0aXZlOiBn'
      'ZW5lcmF0ZUxldmVsT2JqZWN0aXZlKGkgKyAxKSwKICAgICAgICAgICAgICAgIGRpZmZpY3VsdHk6IE1hdGguZmxvb3IoaSAv'
      'IDEwKSArIDEKICAgICAgICAgICAgfSkpCiAgICAgICAgfTsKCiAgICAgICAgLy8gTG9hZCBzYXZlZCBwcm9ncmVzcwogICAg'
      'ICAgIGZ1bmN0aW9uIGxvYWRQcm9ncmVzcygpIHsKICAgICAgICAgICAgY29uc3Qgc2F2ZWQgPSBsb2NhbFN0b3JhZ2UuZ2V0'
      'SXRlbSgnc3dlZXRLaW5nZG9tUHJvZ3Jlc3MnKTsKICAgICAgICAgICAgaWYgKHNhdmVkKSB7CiAgICAgICAgICAgICAgICB0'
      'cnkgewogICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBKU09OLnBhcnNlKHNhdmVkKTsKICAgICAgICAgICAgICAg'
      'ICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhLmxldmVscykpIHsKICAgICAgICAgICAgICAgICAgICAgICAgZ2FtZVN0YXRl'
      'LmxldmVscyA9IGRhdGEubGV2ZWxzLm1hcCgobGV2ZWwsIGluZGV4KSA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAgICAg'
      'ICBjb25zdCBudW1iZXIgPSBsZXZlbD8ubnVtYmVyID8/IGluZGV4ICsgMTsKICAgICAgICAgICAgICAgICAgICAgICAgICAg'
      'IGNvbnN0IGRlZmF1bHRPYmplY3RpdmUgPSBnZW5lcmF0ZUxldmVsT2JqZWN0aXZlKG51bWJlcik7CiAgICAgICAgICAgICAg'
      'ICAgICAgICAgICAgICBjb25zdCByYXdPYmplY3RpdmUgPSB0eXBlb2YgbGV2ZWw/Lm9iamVjdGl2ZSA9PT0gJ29iamVjdCcg'
      'PyBsZXZlbC5vYmplY3RpdmUgOiBudWxsOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2JqZWN0aXZlID0g'
      'cmF3T2JqZWN0aXZlCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7CiAgICAgICAgICAgICAgICAgICAgICAg'
      'ICAgICAgICAgICAgIHR5cGU6IHJhd09iamVjdGl2ZS50eXBlID8/IGRlZmF1bHRPYmplY3RpdmUudHlwZSwKICAgICAgICAg'
      'ICAgICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0OiByYXdPYmplY3RpdmUudGFyZ2V0ID8/IGRlZmF1bHRPYmplY3Rp'
      'dmUudGFyZ2V0LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3ZlczogcmF3T2JqZWN0aXZlLm1vdmVz'
      'ID8/IGRlZmF1bHRPYmplY3RpdmUubW92ZXMsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlc2NyaXB0'
      'aW9uOiByYXdPYmplY3RpdmUuZGVzY3JpcHRpb24gPz8gZGVmYXVsdE9iamVjdGl2ZS5kZXNjcmlwdGlvbgogICAgICAgICAg'
      'ICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGRlZmF1bHRPYmplY3Rp'
      'dmU7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7CiAg'
      'ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbnVtYmVyLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVu'
      'bG9ja2VkOiBsZXZlbD8udW5sb2NrZWQgPz8gaW5kZXggPT09IDAsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAg'
      'c3RhcnM6IGxldmVsPy5zdGFycyA/PyAwLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlZDogbGV2'
      'ZWw/LmNvbXBsZXRlZCA/PyBmYWxzZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmplY3RpdmUsCiAgICAg'
      'ICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlmZmljdWx0eTogbGV2ZWw/LmRpZmZpY3VsdHkgPz8gKE1hdGguZmxvb3Io'
      'KG51bWJlciAtIDEpIC8gMTApICsgMSkKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgICAg'
      'ICAgICAgIH0pOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YS5wcm9ncmVzcykg'
      'ewogICAgICAgICAgICAgICAgICAgICAgICBnYW1lU3RhdGUucHJvZ3Jlc3MgPSB7CiAgICAgICAgICAgICAgICAgICAgICAg'
      'ICAgICBjYXN0bGU6IGRhdGEucHJvZ3Jlc3MuY2FzdGxlID8/IGdhbWVTdGF0ZS5wcm9ncmVzcy5jYXN0bGUsCiAgICAgICAg'
      'ICAgICAgICAgICAgICAgICAgICBnYXJkZW46IGRhdGEucHJvZ3Jlc3MuZ2FyZGVuID8/IGdhbWVTdGF0ZS5wcm9ncmVzcy5n'
      'YXJkZW4sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcXVhcml1bTogZGF0YS5wcm9ncmVzcy5hcXVhcml1bSA/PyBn'
      'YW1lU3RhdGUucHJvZ3Jlc3MuYXF1YXJpdW0sCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFyczogZGF0YS5wcm9n'
      'cmVzcy5zdGFycyA/PyBnYW1lU3RhdGUucHJvZ3Jlc3Muc3RhcnMKICAgICAgICAgICAgICAgICAgICAgICAgfTsKICAgICAg'
      'ICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEuYm9vc3RlcnMpIHsKICAgICAgICAgICAgICAg'
      'ICAgICAgICAgZ2FtZVN0YXRlLmJvb3N0ZXJzID0gewogICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFtbWVyOiBkYXRh'
      'LmJvb3N0ZXJzLmhhbW1lciA/PyBnYW1lU3RhdGUuYm9vc3RlcnMuaGFtbWVyLAogICAgICAgICAgICAgICAgICAgICAgICAg'
      'ICAgc3dhcDogZGF0YS5ib29zdGVycy5zd2FwID8/IGdhbWVTdGF0ZS5ib29zdGVycy5zd2FwLAogICAgICAgICAgICAgICAg'
      'ICAgICAgICAgICAgcmFpbmJvdzogZGF0YS5ib29zdGVycy5yYWluYm93ID8/IGdhbWVTdGF0ZS5ib29zdGVycy5yYWluYm93'
      'LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9tYjogZGF0YS5ib29zdGVycy5ib21iID8/IGdhbWVTdGF0ZS5ib29z'
      'dGVycy5ib21iLAogICAgICAgICAgICAgICAgICAgICAgICAgICAgc2h1ZmZsZTogZGF0YS5ib29zdGVycy5zaHVmZmxlID8/'
      'IGdhbWVTdGF0ZS5ib29zdGVycy5zaHVmZmxlCiAgICAgICAgICAgICAgICAgICAgICAgIH07CiAgICAgICAgICAgICAgICAg'
      'ICAgfQogICAgICAgICAgICAgICAgICAgIGdhbWVTdGF0ZS5taXNzeVBvd2VyID0gZGF0YS5taXNzeVBvd2VyID8/IGdhbWVT'
      'dGF0ZS5taXNzeVBvd2VyOwogICAgICAgICAgICAgICAgICAgIGdhbWVTdGF0ZS5taXNzeUhlbHBlci5jaGFyZ2VzID0gZGF0'
      'YS5taXNzeUhlbHBlckNoYXJnZXMgPz8gZ2FtZVN0YXRlLm1pc3N5SGVscGVyLmNoYXJnZXM7CiAgICAgICAgICAgICAgICB9'
      'IGNhdGNoIChlKSB7CiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIGxvYWQgcHJvZ3Jlc3M6'
      'JywgZSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIC8vIFNhdmUgcHJvZ3Jl'
      'c3MKICAgICAgICBmdW5jdGlvbiBzYXZlUHJvZ3Jlc3MoKSB7CiAgICAgICAgICAgIHRyeSB7CiAgICAgICAgICAgICAgICBs'
      'b2NhbFN0b3JhZ2Uuc2V0SXRlbSgnc3dlZXRLaW5nZG9tUHJvZ3Jlc3MnLCBKU09OLnN0cmluZ2lmeSh7CiAgICAgICAgICAg'
      'ICAgICAgICAgbGV2ZWxzOiBnYW1lU3RhdGUubGV2ZWxzLAogICAgICAgICAgICAgICAgICAgIHByb2dyZXNzOiBnYW1lU3Rh'
      'dGUucHJvZ3Jlc3MsCiAgICAgICAgICAgICAgICAgICAgYm9vc3RlcnM6IGdhbWVTdGF0ZS5ib29zdGVycywKICAgICAgICAg'
      'ICAgICAgICAgICBtaXNzeVBvd2VyOiBnYW1lU3RhdGUubWlzc3lQb3dlciwKICAgICAgICAgICAgICAgICAgICBtaXNzeUhl'
      'bHBlckNoYXJnZXM6IGdhbWVTdGF0ZS5taXNzeUhlbHBlci5jaGFyZ2VzCiAgICAgICAgICAgICAgICB9KSk7CiAgICAgICAg'
      'ICAgIH0gY2F0Y2ggKGUpIHsKICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBzYXZlIHByb2dyZXNz'
      'OicsIGUpOwogICAgICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICAvLyBHZW5lcmF0ZSBsZXZlbCBvYmplY3RpdmVzCiAg'
      'ICAgICAgZnVuY3Rpb24gZ2VuZXJhdGVMZXZlbE9iamVjdGl2ZShsZXZlbCkgewogICAgICAgICAgICBjb25zdCB0eXBlcyA9'
      'IFsKICAgICAgICAgICAgICAgIHt0eXBlOiAnc2NvcmUnLCB0YXJnZXQ6IDUwMDAgKyBsZXZlbCAqIDUwMCwgZGVzY3JpcHRp'
      'b246ICdSZWFjaCBzY29yZSd9LAogICAgICAgICAgICAgICAge3R5cGU6ICdjb2xsZWN0JywgdGFyZ2V0OiB7Y2FuZHk6ICfw'
      'n42tJywgYW1vdW50OiAyMCArIGxldmVsICogMn0sIGRlc2NyaXB0aW9uOiAnQ29sbGVjdCBjYW5kaWVzJ30sCiAgICAgICAg'
      'ICAgICAgICB7dHlwZTogJ2NsZWFyJywgdGFyZ2V0OiAzMCArIGxldmVsLCBkZXNjcmlwdGlvbjogJ0NsZWFyIG9ic3RhY2xl'
      'cyd9LAogICAgICAgICAgICAgICAge3R5cGU6ICdjb21ibycsIHRhcmdldDogMyArIE1hdGguZmxvb3IobGV2ZWwgLyAxMCks'
      'IGRlc2NyaXB0aW9uOiAnTWFrZSBjb21ib3MnfQogICAgICAgICAgICBdOwogICAgICAgICAgICBjb25zdCBzZWxlY3RlZCA9'
      'IHR5cGVzW2xldmVsICUgdHlwZXMubGVuZ3RoXTsKICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICAgIC4uLnNl'
      'bGVjdGVkLAogICAgICAgICAgICAgICAgbW92ZXM6IE1hdGgubWF4KDE1LCAzNSAtIE1hdGguZmxvb3IobGV2ZWwgLyAxMCkp'
      'CiAgICAgICAgICAgIH07CiAgICAgICAgfQoKICAgICAgICAvLyBJbml0aWFsaXplIGdhbWUKICAgICAgICBmdW5jdGlvbiBp'
      'bml0R2FtZShsZXZlbCkgewogICAgICAgICAgICBnYW1lU3RhdGUuY3VycmVudExldmVsID0gbGV2ZWw7CiAgICAgICAgICAg'
      'IGNvbnN0IGxldmVsRGF0YSA9IGdhbWVTdGF0ZS5sZXZlbHNbbGV2ZWwgLSAxXTsKICAgICAgICAgICAgY2xlYXJBY3RpdmVC'
      'b29zdGVyKCk7CiAgICAgICAgICAgIGdhbWVTdGF0ZS5tb3ZlcyA9IGxldmVsRGF0YS5vYmplY3RpdmUubW92ZXM7CiAgICAg'
      'ICAgICAgIGdhbWVTdGF0ZS5zY29yZSA9IDA7CiAgICAgICAgICAgIGdhbWVTdGF0ZS5jb21ibyA9IDA7CiAgICAgICAgICAg'
      'IGdhbWVTdGF0ZS5jb2xsZWN0UHJvZ3Jlc3MgPSB7fTsKICAgICAgICAgICAgZ2FtZVN0YXRlLm9ic3RhY2xlc0NsZWFyZWQg'
      'PSAwOwogICAgICAgICAgICBnYW1lU3RhdGUubWF4Q29tYm8gPSAwOwogICAgICAgICAgICBnYW1lU3RhdGUuc3BlY2lhbHMg'
      'PSB7fTsKICAgICAgICAgICAgCiAgICAgICAgICAgIC8vIFVwZGF0ZSBVSQogICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVt'
      'ZW50QnlJZCgnbGV2ZWxEaXNwbGF5JykudGV4dENvbnRlbnQgPSBgTGV2ZWwgJHtsZXZlbH1gOwogICAgICAgICAgICBkb2N1'
      'bWVudC5nZXRFbGVtZW50QnlJZCgnc2NvcmVEaXNwbGF5JykudGV4dENvbnRlbnQgPSAnMCc7CiAgICAgICAgICAgIGRvY3Vt'
      'ZW50LmdldEVsZW1lbnRCeUlkKCdtb3Zlc0Rpc3BsYXknKS50ZXh0Q29udGVudCA9IGAke2dhbWVTdGF0ZS5tb3Zlc30gbW92'
      'ZXNgOwogICAgICAgICAgICAKICAgICAgICAgICAgY29uc3Qgb2JqID0gbGV2ZWxEYXRhLm9iamVjdGl2ZTsKICAgICAgICAg'
      'ICAgaWYgKG9iai50eXBlID09PSAnY29sbGVjdCcpIHsKICAgICAgICAgICAgICAgIGdhbWVTdGF0ZS5jb2xsZWN0UHJvZ3Jl'
      'c3Nbb2JqLnRhcmdldC5jYW5keV0gPSAwOwogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgICB1cGRhdGVU'
      'YXJnZXREaXNwbGF5KCk7CiAgICAgICAgICAgIAogICAgICAgICAgICAvLyBVcGRhdGUgYm9vc3RlciBjb3VudHMKICAgICAg'
      'ICAgICAgdXBkYXRlQm9vc3RlckNvdW50cygpOwogICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWlzc3lQ'
      'b3dlcicpLnRleHRDb250ZW50ID0gZ2FtZVN0YXRlLm1pc3N5UG93ZXI7CiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1l'
      'bnRCeUlkKCdtaXNzeUhlbHBlckNoYXJnZXMnKS50ZXh0Q29udGVudCA9IGdhbWVTdGF0ZS5taXNzeUhlbHBlci5jaGFyZ2Vz'
      'OwogICAgICAgICAgICAKICAgICAgICAgICAgLy8gQ3JlYXRlIGdyaWQKICAgICAgICAgICAgY3JlYXRlR3JpZCgpOwogICAg'
      'ICAgICAgICAKICAgICAgICAgICAgLy8gSGlkZSBsZXZlbCBzZWxlY3QKICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVu'
      'dEJ5SWQoJ2xldmVsU2VsZWN0Jykuc3R5bGUuZGlzcGxheSA9ICdub25lJzsKICAgICAgICB9CgogICAgICAgIC8vIENyZWF0'
      'ZSBncmlkCiAgICAgICAgZnVuY3Rpb24gY3JlYXRlR3JpZCgpIHsKICAgICAgICAgICAgY29uc3QgZ3JpZCA9IGRvY3VtZW50'
      'LmdldEVsZW1lbnRCeUlkKCdncmlkJyk7CiAgICAgICAgICAgIGdyaWQuaW5uZXJIVE1MID0gJyc7CiAgICAgICAgICAgIGdh'
      'bWVTdGF0ZS5ncmlkID0gW107CiAgICAgICAgICAgIGdhbWVTdGF0ZS5vYnN0YWNsZUhlYWx0aCA9IHt9OwogICAgICAgICAg'
      'ICBnYW1lU3RhdGUuc3BlY2lhbHMgPSB7fTsKICAgICAgICAgICAgCiAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJv'
      'dyA8IEdSSURfU0laRTsgcm93KyspIHsKICAgICAgICAgICAgICAgIGdhbWVTdGF0ZS5ncmlkW3Jvd10gPSBbXTsKICAgICAg'
      'ICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IEdSSURfU0laRTsgY29sKyspIHsKICAgICAgICAgICAgICAgICAg'
      'ICBjb25zdCBjZWxsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7CiAgICAgICAgICAgICAgICAgICAgY2VsbC5j'
      'bGFzc05hbWUgPSAnY2VsbCc7CiAgICAgICAgICAgICAgICAgICAgY2VsbC5kYXRhc2V0LnJvdyA9IHJvdzsKICAgICAgICAg'
      'ICAgICAgICAgICBjZWxsLmRhdGFzZXQuY29sID0gY29sOwogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAg'
      'ICAgIGxldCBjYW5keTsKICAgICAgICAgICAgICAgICAgICBpZiAoc2hvdWxkU3Bhd25PYnN0YWNsZSgpKSB7CiAgICAgICAg'
      'ICAgICAgICAgICAgICAgIGNvbnN0IG9ic3RhY2xlID0gZ2V0UmFuZG9tT2JzdGFjbGUoKTsKICAgICAgICAgICAgICAgICAg'
      'ICAgICAgY2FuZHkgPSBvYnN0YWNsZS5lbW9qaTsKICAgICAgICAgICAgICAgICAgICAgICAgZ2FtZVN0YXRlLm9ic3RhY2xl'
      'SGVhbHRoW2Ake3Jvd30sJHtjb2x9YF0gPSBvYnN0YWNsZS5ocDsKICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5kYXRh'
      'c2V0Lm9ic3RhY2xlID0gJ3RydWUnOwogICAgICAgICAgICAgICAgICAgICAgICBjZWxsLmRhdGFzZXQub2JzdGFjbGVUeXBl'
      'ID0gb2JzdGFjbGUudHlwZTsKICAgICAgICAgICAgICAgICAgICAgICAgY2VsbC5kYXRhc2V0LmhwID0gb2JzdGFjbGUuaHA7'
      'CiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgICAgICAgICAgY2FuZHkgPSBnZXRSYW5kb21D'
      'YW5keSgpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICBj'
      'ZWxsLnRleHRDb250ZW50ID0gY2FuZHk7CiAgICAgICAgICAgICAgICAgICAgY2VsbC5kYXRhc2V0LmNhbmR5ID0gY2FuZHk7'
      'CiAgICAgICAgICAgICAgICAgICAgZ2FtZVN0YXRlLmdyaWRbcm93XVtjb2xdID0gY2FuZHk7CiAgICAgICAgICAgICAgICAg'
      'ICAgCiAgICAgICAgICAgICAgICAgICAgY2VsbC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IGhhbmRsZUNlbGxD'
      'bGljayhyb3csIGNvbCkpOwogICAgICAgICAgICAgICAgICAgIGdyaWQuYXBwZW5kQ2hpbGQoY2VsbCk7CiAgICAgICAgICAg'
      'ICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgCiAgICAgICAgICAgIC8vIEVuc3VyZSBubyBpbml0aWFsIG1hdGNo'
      'ZXMKICAgICAgICAgICAgd2hpbGUgKGhhc01hdGNoZXMoKSkgewogICAgICAgICAgICAgICAgcmVtb3ZlSW5pdGlhbE1hdGNo'
      'ZXMoKTsKICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgZnVuY3Rpb24gZ2V0UmFuZG9tQ2FuZHkoKSB7CiAgICAg'
      'ICAgICAgIHJldHVybiBDQU5EWV9UWVBFU1tNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBDQU5EWV9UWVBFUy5sZW5ndGgp'
      'XTsKICAgICAgICB9CgogICAgICAgIGZ1bmN0aW9uIGdldFJhbmRvbU9ic3RhY2xlKCkgewogICAgICAgICAgICBjb25zdCBv'
      'YnN0YWNsZUtleXMgPSBPYmplY3Qua2V5cyhPQlNUQUNMRVMpOwogICAgICAgICAgICBjb25zdCByYW5kb21LZXkgPSBvYnN0'
      'YWNsZUtleXNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogb2JzdGFjbGVLZXlzLmxlbmd0aCldOwogICAgICAgICAgICBy'
      'ZXR1cm4gewogICAgICAgICAgICAgICAgdHlwZTogcmFuZG9tS2V5LAogICAgICAgICAgICAgICAgZW1vamk6IE9CU1RBQ0xF'
      'U1tyYW5kb21LZXldLmVtb2ppLAogICAgICAgICAgICAgICAgaHA6IE9CU1RBQ0xFU1tyYW5kb21LZXldLmhwLAogICAgICAg'
      'ICAgICAgICAgcG9pbnRzOiBPQlNUQUNMRVNbcmFuZG9tS2V5XS5wb2ludHMKICAgICAgICAgICAgfTsKICAgICAgICB9Cgog'
      'ICAgICAgIGZ1bmN0aW9uIHNob3VsZFNwYXduT2JzdGFjbGUoKSB7CiAgICAgICAgICAgIC8vIDIwJSBjaGFuY2UgdG8gc3Bh'
      'd24gb2JzdGFjbGUKICAgICAgICAgICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgPCAwLjI7CiAgICAgICAgfQoKICAgICAgICBm'
      'dW5jdGlvbiByZW1vdmVJbml0aWFsTWF0Y2hlcygpIHsKICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgR1JJ'
      'RF9TSVpFOyByb3crKykgewogICAgICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgR1JJRF9TSVpFOyBjb2wr'
      'KykgewogICAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoZXMgPSBmaW5kTWF0Y2hlcyhyb3csIGNvbCk7CiAgICAgICAg'
      'ICAgICAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID49IDMpIHsKICAgICAgICAgICAgICAgICAgICAgICAgZ2FtZVN0YXRl'
      'LmdyaWRbcm93XVtjb2xdID0gZ2V0UmFuZG9tQ2FuZHkoKTsKICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ2VsbERp'
      'c3BsYXkocm93LCBjb2wpOwogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQog'
      'ICAgICAgIH0KCiAgICAgICAgZnVuY3Rpb24gdXBkYXRlQ2VsbERpc3BsYXkocm93LCBjb2wpIHsKICAgICAgICAgICAgY29u'
      'c3QgY2VsbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLXJvdz0iJHtyb3d9Il1bZGF0YS1jb2w9IiR7Y29sfSJd'
      'YCk7CiAgICAgICAgICAgIGlmICghY2VsbCkgcmV0dXJuOwogICAgICAgICAgICAKICAgICAgICAgICAgY29uc3Qga2V5ID0g'
      'YCR7cm93fSwke2NvbH1gOwogICAgICAgICAgICBjb25zdCBzcGVjaWFsSW5mbyA9IGdhbWVTdGF0ZS5zcGVjaWFsc1trZXld'
      'OwogICAgICAgICAgICBjb25zdCBiYXNlVmFsdWUgPSBnYW1lU3RhdGUuZ3JpZFtyb3ddW2NvbF0gfHwgJyc7CiAgICAgICAg'
      'ICAgIGNvbnN0IGRpc3BsYXlWYWx1ZSA9IHNwZWNpYWxJbmZvICYmIFNQRUNJQUxfQ0FORElFU1tzcGVjaWFsSW5mby50eXBl'
      'XQogICAgICAgICAgICAgICAgPyBTUEVDSUFMX0NBTkRJRVNbc3BlY2lhbEluZm8udHlwZV0uZW1vamkKICAgICAgICAgICAg'
      'ICAgIDogYmFzZVZhbHVlOwogICAgICAgICAgICAKICAgICAgICAgICAgY2VsbC50ZXh0Q29udGVudCA9IGRpc3BsYXlWYWx1'
      'ZTsKICAgICAgICAgICAgY2VsbC5kYXRhc2V0LmNhbmR5ID0gYmFzZVZhbHVlOwogICAgICAgICAgICAKICAgICAgICAgICAg'
      'Ly8gUmVzZXQgc3BlY2lhbCBzdHlsaW5nCiAgICAgICAgICAgIGNlbGwuY2xhc3NMaXN0LnJlbW92ZSgnc3BlY2lhbC1jYW5k'
      'eScsICdzcGVjaWFsLWNyZWF0ZWQnKTsKICAgICAgICAgICAgT2JqZWN0LnZhbHVlcyhTUEVDSUFMX0NBTkRJRVMpLmZvckVh'
      'Y2goKHtjbGFzc05hbWV9KSA9PiBjZWxsLmNsYXNzTGlzdC5yZW1vdmUoY2xhc3NOYW1lKSk7CiAgICAgICAgICAgIGRlbGV0'
      'ZSBjZWxsLmRhdGFzZXQuc3BlY2lhbDsKICAgICAgICAgICAgZGVsZXRlIGNlbGwuZGF0YXNldC5zcGVjaWFsQmFzZTsKICAg'
      'ICAgICAgICAgCiAgICAgICAgICAgIGlmIChzcGVjaWFsSW5mbyAmJiBTUEVDSUFMX0NBTkRJRVNbc3BlY2lhbEluZm8udHlw'
      'ZV0pIHsKICAgICAgICAgICAgICAgIGNlbGwuZGF0YXNldC5zcGVjaWFsID0gc3BlY2lhbEluZm8udHlwZTsKICAgICAgICAg'
      'ICAgICAgIGlmIChzcGVjaWFsSW5mby5iYXNlKSB7CiAgICAgICAgICAgICAgICAgICAgY2VsbC5kYXRhc2V0LnNwZWNpYWxC'
      'YXNlID0gc3BlY2lhbEluZm8uYmFzZTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGNlbGwuY2xhc3NMaXN0'
      'LmFkZCgnc3BlY2lhbC1jYW5keScsIFNQRUNJQUxfQ0FORElFU1tzcGVjaWFsSW5mby50eXBlXS5jbGFzc05hbWUpOwogICAg'
      'ICAgICAgICB9CiAgICAgICAgfQoKICAgICAgICAvLyBIYW5kbGUgY2VsbCBjbGljawogICAgICAgIGZ1bmN0aW9uIGhhbmRs'
      'ZUNlbGxDbGljayhyb3csIGNvbCkgewogICAgICAgICAgICBpZiAoZ2FtZVN0YXRlLmlzUHJvY2Vzc2luZyB8fCBnYW1lU3Rh'
      'dGUubW92ZXMgPD0gMCkgcmV0dXJuOwogICAgICAgICAgICAKICAgICAgICAgICAgY29uc3QgY2VsbCA9IGRvY3VtZW50LnF1'
      'ZXJ5U2VsZWN0b3IoYFtkYXRhLXJvdz0iJHtyb3d9Il1bZGF0YS1jb2w9IiR7Y29sfSJdYCk7CiAgICAgICAgICAgIGlmICgh'
      'Y2VsbCkgcmV0dXJuOwogICAgICAgICAgICAKICAgICAgICAgICAgaWYgKGdhbWVTdGF0ZS5hY3RpdmVCb29zdGVyKSB7CiAg'
      'ICAgICAgICAgICAgICBpZiAoZ2FtZVN0YXRlLmFjdGl2ZUJvb3N0ZXIgPT09ICdoYW1tZXInKSB7CiAgICAgICAgICAgICAg'
      'ICAgICAgYXBwbHlIYW1tZXIocm93LCBjb2wpOwogICAgICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICAg'
      'IH0KICAgICAgICAgICAgICAgIGlmIChnYW1lU3RhdGUuYWN0aXZlQm9vc3RlciA9PT0gJ2JvbWInKSB7CiAgICAgICAgICAg'
      'ICAgICAgICAgcGxhY2VCb21iKHJvdywgY29sKTsKICAgICAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgICAg'
      'ICB9CiAgICAgICAgICAgICAgICBpZiAoZ2FtZVN0YXRlLmFjdGl2ZUJvb3N0ZXIgPT09ICdzd2FwJykgewogICAgICAgICAg'
      'ICAgICAgICAgIGhhbmRsZVN3YXBCb29zdGVyKHJvdywgY29sKTsKICAgICAgICAgICAgICAgICAgICByZXR1cm47CiAgICAg'
      'ICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgCiAgICAgICAgICAgIC8vIElmIE1pc3N5IGlzIGFjdGl2'
      'ZSBhbmQgY2VsbCBpcyBhbiBvYnN0YWNsZSwgc2V0IGFzIHRhcmdldAogICAgICAgICAgICBpZiAoZ2FtZVN0YXRlLm1pc3N5'
      'SGVscGVyLmFjdGl2ZSAmJiBjZWxsPy5kYXRhc2V0Lm9ic3RhY2xlID09PSAndHJ1ZScpIHsKICAgICAgICAgICAgICAgIHNl'
      'dE1pc3N5VGFyZ2V0KHJvdywgY29sKTsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQogICAgICAgICAg'
      'ICAKICAgICAgICAgICAgaWYgKCFnYW1lU3RhdGUuc2VsZWN0ZWRDZWxsKSB7CiAgICAgICAgICAgICAgICBnYW1lU3RhdGUu'
      'c2VsZWN0ZWRDZWxsID0ge3JvdywgY29sfTsKICAgICAgICAgICAgICAgIGNlbGwuY2xhc3NMaXN0LmFkZCgnc2VsZWN0ZWQn'
      'KTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGNvbnN0IHByZXZDZWxsID0gZG9jdW1lbnQucXVlcnlT'
      'ZWxlY3RvcihgW2RhdGEtcm93PSIke2dhbWVTdGF0ZS5zZWxlY3RlZENlbGwucm93fSJdW2RhdGEtY29sPSIke2dhbWVTdGF0'
      'ZS5zZWxlY3RlZENlbGwuY29sfSJdYCk7CiAgICAgICAgICAgICAgICBwcmV2Q2VsbC5jbGFzc0xpc3QucmVtb3ZlKCdzZWxl'
      'Y3RlZCcpOwogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBpZiAoaXNBZGphY2VudChnYW1lU3RhdGUuc2VsZWN0'
      'ZWRDZWxsLCB7cm93LCBjb2x9KSkgewogICAgICAgICAgICAgICAgICAgIHN3YXBDYW5kaWVzKGdhbWVTdGF0ZS5zZWxlY3Rl'
      'ZENlbGwucm93LCBnYW1lU3RhdGUuc2VsZWN0ZWRDZWxsLmNvbCwgcm93LCBjb2wpOwogICAgICAgICAgICAgICAgfSBlbHNl'
      'IHsKICAgICAgICAgICAgICAgICAgICBnYW1lU3RhdGUuc2VsZWN0ZWRDZWxsID0ge3JvdywgY29sfTsKICAgICAgICAgICAg'
      'ICAgICAgICBjZWxsLmNsYXNzTGlzdC5hZGQoJ3NlbGVjdGVkJyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0K'
      'ICAgICAgICB9CgogICAgICAgIGZ1bmN0aW9uIHNldE1pc3N5VGFyZ2V0KHJvdywgY29sKSB7CiAgICAgICAgICAgIC8vIENs'
      'ZWFyIHByZXZpb3VzIHRhcmdldCBpbmRpY2F0b3IKICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLm1p'
      'c3N5LXRhcmdldCcpLmZvckVhY2goZWwgPT4KICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ21pc3N5LXRh'
      'cmdldCcpKTsKICAgICAgICAgICAgCiAgICAgICAgICAgIC8vIENsZWFyIGFueSBzZWxlY3RlZCBjYW5keSBjZWxsCiAgICAg'
      'ICAgICAgIGlmIChnYW1lU3RhdGUuc2VsZWN0ZWRDZWxsKSB7CiAgICAgICAgICAgICAgICBjb25zdCBwcmV2ID0gZG9jdW1l'
      'bnQucXVlcnlTZWxlY3RvcihgW2RhdGEtcm93PSIke2dhbWVTdGF0ZS5zZWxlY3RlZENlbGwucm93fSJdW2RhdGEtY29sPSIk'
      'e2dhbWVTdGF0ZS5zZWxlY3RlZENlbGwuY29sfSJdYCk7CiAgICAgICAgICAgICAgICBwcmV2Py5jbGFzc0xpc3QucmVtb3Zl'
      'KCdzZWxlY3RlZCcpOwogICAgICAgICAgICAgICAgZ2FtZVN0YXRlLnNlbGVjdGVkQ2VsbCA9IG51bGw7CiAgICAgICAgICAg'
      'IH0KICAgICAgICAgICAgCiAgICAgICAgICAgIC8vIFNldCBuZXcgdGFyZ2V0CiAgICAgICAgICAgIGdhbWVTdGF0ZS5taXNz'
      'eUhlbHBlci50YXJnZXRSb3cgPSByb3c7CiAgICAgICAgICAgIGdhbWVTdGF0ZS5taXNzeUhlbHBlci50YXJnZXRDb2wgPSBj'
      'b2w7CiAgICAgICAgICAgIGdhbWVTdGF0ZS5taXNzeUhlbHBlci5oYXNTcGVjaWZpY1RhcmdldCA9IHRydWU7CiAgICAgICAg'
      'ICAgIAogICAgICAgICAgICAvLyBWaXN1YWwgZmVlZGJhY2sKICAgICAgICAgICAgY29uc3QgdGFyZ2V0Q2VsbCA9IGRvY3Vt'
      'ZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLXJvdz0iJHtyb3d9Il1bZGF0YS1jb2w9IiR7Y29sfSJdYCk7CiAgICAgICAgICAg'
      'IGlmICh0YXJnZXRDZWxsKSB7CiAgICAgICAgICAgICAgICB0YXJnZXRDZWxsLmNsYXNzTGlzdC5hZGQoJ21pc3N5LXRhcmdl'
      'dCcpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgICBzaG93Q29tYm8oJ1RhcmdldCBMb2NrZWQhJyk7'
      'CiAgICAgICAgfQoKICAgICAgICBmdW5jdGlvbiBpc0FkamFjZW50KGNlbGwxLCBjZWxsMikgewogICAgICAgICAgICByZXR1'
      'cm4gKE1hdGguYWJzKGNlbGwxLnJvdyAtIGNlbGwyLnJvdykgPT09IDEgJiYgY2VsbDEuY29sID09PSBjZWxsMi5jb2wpIHx8'
      'CiAgICAgICAgICAgICAgICAgICAoTWF0aC5hYnMoY2VsbDEuY29sIC0gY2VsbDIuY29sKSA9PT0gMSAmJiBjZWxsMS5yb3cg'
      'PT09IGNlbGwyLnJvdyk7CiAgICAgICAgfQoKICAgICAgICBhc3luYyBmdW5jdGlvbiBzd2FwQ2FuZGllcyhyb3cxLCBjb2wx'
      'LCByb3cyLCBjb2wyKSB7CiAgICAgICAgICAgIGdhbWVTdGF0ZS5pc1Byb2Nlc3NpbmcgPSB0cnVlOwogICAgICAgICAgICAK'
      'ICAgICAgICAgICAgLy8gU3dhcCBpbiBncmlkCiAgICAgICAgICAgIGNvbnN0IHRlbXAgPSBnYW1lU3RhdGUuZ3JpZFtyb3cx'
      'XVtjb2wxXTsKICAgICAgICAgICAgZ2FtZVN0YXRlLmdyaWRbcm93MV1bY29sMV0gPSBnYW1lU3RhdGUuZ3JpZFtyb3cyXVtj'
      'b2wyXTsKICAgICAgICAgICAgZ2FtZVN0YXRlLmdyaWRbcm93Ml1bY29sMl0gPSB0ZW1wOwogICAgICAgICAgICBzd2FwU3Bl'
      'Y2lhbHMocm93MSwgY29sMSwgcm93MiwgY29sMik7CiAgICAgICAgICAgIAogICAgICAgICAgICAvLyBVcGRhdGUgZGlzcGxh'
      'eQogICAgICAgICAgICB1cGRhdGVDZWxsRGlzcGxheShyb3cxLCBjb2wxKTsKICAgICAgICAgICAgdXBkYXRlQ2VsbERpc3Bs'
      'YXkocm93MiwgY29sMik7CiAgICAgICAgICAgIAogICAgICAgICAgICAvLyBDaGVjayBmb3IgbWF0Y2hlcwogICAgICAgICAg'
      'ICBjb25zdCBtYXRjaGVzMSA9IGZpbmRNYXRjaGVzKHJvdzEsIGNvbDEpOwogICAgICAgICAgICBjb25zdCBtYXRjaGVzMiA9'
      'IGZpbmRNYXRjaGVzKHJvdzIsIGNvbDIpOwogICAgICAgICAgICAKICAgICAgICAgICAgaWYgKG1hdGNoZXMxLmxlbmd0aCA+'
      'PSAzIHx8IG1hdGNoZXMyLmxlbmd0aCA+PSAzKSB7CiAgICAgICAgICAgICAgICBnYW1lU3RhdGUubW92ZXMtLTsKICAgICAg'
      'ICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb3Zlc0Rpc3BsYXknKS50ZXh0Q29udGVudCA9IGAke2dhbWVT'
      'dGF0ZS5tb3Zlc30gbW92ZXNgOwogICAgICAgICAgICAgICAgZ2FtZVN0YXRlLnNlbGVjdGVkQ2VsbCA9IG51bGw7CiAgICAg'
      'ICAgICAgICAgICAKICAgICAgICAgICAgICAgIGF3YWl0IHByb2Nlc3NNYXRjaGVzKCk7CiAgICAgICAgICAgICAgICBjaGVj'
      'a0xldmVsQ29tcGxldGUoKTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIC8vIFN3YXAgYmFjawogICAg'
      'ICAgICAgICAgICAgY29uc3QgdGVtcCA9IGdhbWVTdGF0ZS5ncmlkW3JvdzFdW2NvbDFdOwogICAgICAgICAgICAgICAgZ2Ft'
      'ZVN0YXRlLmdyaWRbcm93MV1bY29sMV0gPSBnYW1lU3RhdGUuZ3JpZFtyb3cyXVtjb2wyXTsKICAgICAgICAgICAgICAgIGdh'
      'bWVTdGF0ZS5ncmlkW3JvdzJdW2NvbDJdID0gdGVtcDsKICAgICAgICAgICAgICAgIHN3YXBTcGVjaWFscyhyb3cxLCBjb2wx'
      'LCByb3cyLCBjb2wyKTsKICAgICAgICAgICAgICAgIHVwZGF0ZUNlbGxEaXNwbGF5KHJvdzEsIGNvbDEpOwogICAgICAgICAg'
      'ICAgICAgdXBkYXRlQ2VsbERpc3BsYXkocm93MiwgY29sMik7CiAgICAgICAgICAgICAgICBnYW1lU3RhdGUuc2VsZWN0ZWRD'
      'ZWxsID0gbnVsbDsKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgZ2FtZVN0YXRlLmlzUHJvY2Vzc2lu'
      'ZyA9IGZhbHNlOwogICAgICAgIH0KCiAgICAgICAgZnVuY3Rpb24gc3dhcFNwZWNpYWxzKHJvdzEsIGNvbDEsIHJvdzIsIGNv'
      'bDIpIHsKICAgICAgICAgICAgY29uc3Qga2V5MSA9IGAke3JvdzF9LCR7Y29sMX1gOwogICAgICAgICAgICBjb25zdCBrZXky'
      'ID0gYCR7cm93Mn0sJHtjb2wyfWA7CiAgICAgICAgICAgIGNvbnN0IHNwZWNpYWwxID0gZ2FtZVN0YXRlLnNwZWNpYWxzW2tl'
      'eTFdOwogICAgICAgICAgICBjb25zdCBzcGVjaWFsMiA9IGdhbWVTdGF0ZS5zcGVjaWFsc1trZXkyXTsKICAgICAgICAgICAg'
      'CiAgICAgICAgICAgIGlmIChzcGVjaWFsMSAhPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICBnYW1lU3RhdGUuc3Bl'
      'Y2lhbHNba2V5Ml0gPSBzcGVjaWFsMTsKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGRlbGV0ZSBnYW1l'
      'U3RhdGUuc3BlY2lhbHNba2V5Ml07CiAgICAgICAgICAgIH0KICAgICAgICAgICAgCiAgICAgICAgICAgIGlmIChzcGVjaWFs'
      'MiAhPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgICAgICAgICBnYW1lU3RhdGUuc3BlY2lhbHNba2V5MV0gPSBzcGVjaWFsMjsK'
      'ICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGRlbGV0ZSBnYW1lU3RhdGUuc3BlY2lhbHNba2V5MV07CiAg'
      'ICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIGZ1bmN0aW9uIGZpbmRNYXRjaGVzKHJvdywgY29sKSB7CiAgICAgICAg'
      'ICAgIGNvbnN0IGNhbmR5ID0gZ2FtZVN0YXRlLmdyaWRbcm93XVtjb2xdOwogICAgICAgICAgICBjb25zdCBtYXRjaGVzID0g'
      'W3tyb3csIGNvbH1dOwogICAgICAgICAgICAKICAgICAgICAgICAgLy8gQ2hlY2sgaG9yaXpvbnRhbAogICAgICAgICAgICBs'
      'ZXQgbGVmdCA9IGNvbCAtIDE7CiAgICAgICAgICAgIHdoaWxlIChsZWZ0ID49IDAgJiYgZ2FtZVN0YXRlLmdyaWRbcm93XVts'
      'ZWZ0XSA9PT0gY2FuZHkpIHsKICAgICAgICAgICAgICAgIG1hdGNoZXMucHVzaCh7cm93LCBjb2w6IGxlZnR9KTsKICAgICAg'
      'ICAgICAgICAgIGxlZnQtLTsKICAgICAgICAgICAgfQogICAgICAgICAgICBsZXQgcmlnaHQgPSBjb2wgKyAxOwogICAgICAg'
      'ICAgICB3aGlsZSAocmlnaHQgPCBHUklEX1NJWkUgJiYgZ2FtZVN0YXRlLmdyaWRbcm93XVtyaWdodF0gPT09IGNhbmR5KSB7'
      'CiAgICAgICAgICAgICAgICBtYXRjaGVzLnB1c2goe3JvdywgY29sOiByaWdodH0pOwogICAgICAgICAgICAgICAgcmlnaHQr'
      'KzsKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID49IDMpIHJldHVy'
      'biBtYXRjaGVzOwogICAgICAgICAgICAKICAgICAgICAgICAgLy8gQ2hlY2sgdmVydGljYWwKICAgICAgICAgICAgY29uc3Qg'
      'dmVydGljYWxNYXRjaGVzID0gW3tyb3csIGNvbH1dOwogICAgICAgICAgICBsZXQgdXAgPSByb3cgLSAxOwogICAgICAgICAg'
      'ICB3aGlsZSAodXAgPj0gMCAmJiBnYW1lU3RhdGUuZ3JpZFt1cF1bY29sXSA9PT0gY2FuZHkpIHsKICAgICAgICAgICAgICAg'
      'IHZlcnRpY2FsTWF0Y2hlcy5wdXNoKHtyb3c6IHVwLCBjb2x9KTsKICAgICAgICAgICAgICAgIHVwLS07CiAgICAgICAgICAg'
      'IH0KICAgICAgICAgICAgbGV0IGRvd24gPSByb3cgKyAxOwogICAgICAgICAgICB3aGlsZSAoZG93biA8IEdSSURfU0laRSAm'
      'JiBnYW1lU3RhdGUuZ3JpZFtkb3duXVtjb2xdID09PSBjYW5keSkgewogICAgICAgICAgICAgICAgdmVydGljYWxNYXRjaGVz'
      'LnB1c2goe3JvdzogZG93biwgY29sfSk7CiAgICAgICAgICAgICAgICBkb3duKys7CiAgICAgICAgICAgIH0KICAgICAgICAg'
      'ICAgCiAgICAgICAgICAgIGlmICh2ZXJ0aWNhbE1hdGNoZXMubGVuZ3RoID49IDMpIHJldHVybiB2ZXJ0aWNhbE1hdGNoZXM7'
      'CiAgICAgICAgICAgIAogICAgICAgICAgICByZXR1cm4gW107CiAgICAgICAgfQoKICAgICAgICBmdW5jdGlvbiBoYXNNYXRj'
      'aGVzKCkgewogICAgICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCBHUklEX1NJWkU7IHJvdysrKSB7CiAgICAgICAg'
      'ICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBHUklEX1NJWkU7IGNvbCsrKSB7CiAgICAgICAgICAgICAgICAgICAg'
      'aWYgKGZpbmRNYXRjaGVzKHJvdywgY29sKS5sZW5ndGggPj0gMykgewogICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4g'
      'dHJ1ZTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAg'
      'cmV0dXJuIGZhbHNlOwogICAgICAgIH0KCiAgICAgICAgYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc01hdGNoZXMoKSB7CiAgICAg'
      'ICAgICAgIGxldCBoYXNNYXRjaCA9IHRydWU7CiAgICAgICAgICAgIAogICAgICAgICAgICB3aGlsZSAoaGFzTWF0Y2gpIHsK'
      'ICAgICAgICAgICAgICAgIGhhc01hdGNoID0gZmFsc2U7CiAgICAgICAgICAgICAgICBjb25zdCBtYXRjaFNldCA9IG5ldyBT'
      'ZXQoKTsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgR1JJRF9TSVpF'
      'OyByb3crKykgewogICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IEdSSURfU0laRTsgY29sKysp'
      'IHsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGZpbmRNYXRjaGVzKHJvdywgY29sKTsKICAgICAg'
      'ICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoZXMubGVuZ3RoID49IDMpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAg'
      'IGhhc01hdGNoID0gdHJ1ZTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZXMuZm9yRWFjaChtID0+IG1hdGNo'
      'U2V0LmFkZChjZWxsS2V5KG0ucm93LCBtLmNvbCkpKTsKICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAg'
      'ICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgaWYgKGhhc01hdGNo'
      'ICYmIG1hdGNoU2V0LnNpemUgPiAwKSB7CiAgICAgICAgICAgICAgICAgICAgZ2FtZVN0YXRlLmNvbWJvKys7CiAgICAgICAg'
      'ICAgICAgICAgICAgZ2FtZVN0YXRlLm1heENvbWJvID0gTWF0aC5tYXgoZ2FtZVN0YXRlLm1heENvbWJvLCBnYW1lU3RhdGUu'
      'Y29tYm8pOwogICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgIGlmIChnYW1lU3RhdGUuY29tYm8gPiAx'
      'KSB7CiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dDb21ibyhnYW1lU3RhdGUuY29tYm8pOwogICAgICAgICAgICAgICAg'
      'ICAgIH0KICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICBhd2FpdCByZXNvbHZlTWF0Y2hDbHVzdGVy'
      'cyhtYXRjaFNldCk7CiAgICAgICAgICAgICAgICAgICAgYXdhaXQgZHJvcENhbmRpZXMoKTsKICAgICAgICAgICAgICAgICAg'
      'ICBhd2FpdCBmaWxsRW1wdHkoKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAg'
      'ICAgICAgZ2FtZVN0YXRlLmNvbWJvID0gMDsKICAgICAgICB9CgogICAgICAgIGFzeW5jIGZ1bmN0aW9uIHJlc29sdmVNYXRj'
      'aENsdXN0ZXJzKG1hdGNoU2V0KSB7CiAgICAgICAgICAgIGNvbnN0IG1hdGNoQXJyYXkgPSBBcnJheS5mcm9tKG1hdGNoU2V0'
      'KS5tYXAoa2V5ID0+IHsKICAgICAgICAgICAgICAgIGNvbnN0IFtyb3csIGNvbF0gPSBrZXkuc3BsaXQoJywnKS5tYXAoTnVt'
      'YmVyKTsKICAgICAgICAgICAgICAgIHJldHVybiB7cm93LCBjb2x9OwogICAgICAgICAgICB9KTsKICAgICAgICAgICAgaWYg'
      'KG1hdGNoQXJyYXkubGVuZ3RoID09PSAwKSByZXR1cm47CiAgICAgICAgICAgIAogICAgICAgICAgICBjb25zdCBjbHVzdGVy'
      'cyA9IGJ1aWxkTWF0Y2hDbHVzdGVycyhtYXRjaEFycmF5KTsKICAgICAgICAgICAgY29uc3QgY2VsbHNUb0NsZWFyID0gbmV3'
      'IFNldCgpOwogICAgICAgICAgICBjb25zdCBtYXRjaGVkQ2FuZGllcyA9IFtdOwogICAgICAgICAgICBjb25zdCBzcGVjaWFs'
      'Q3JlYXRpb25zID0gW107CiAgICAgICAgICAgIGNvbnN0IGFjdGl2YXRpb25RdWV1ZSA9IFtdOwogICAgICAgICAgICAKICAg'
      'ICAgICAgICAgY2x1c3RlcnMuZm9yRWFjaChjbHVzdGVyID0+IHsKICAgICAgICAgICAgICAgIGNsdXN0ZXIuZm9yRWFjaCgo'
      'e3JvdywgY29sfSkgPT4gewogICAgICAgICAgICAgICAgICAgIG1hdGNoZWRDYW5kaWVzLnB1c2goe3JvdywgY29sLCBjYW5k'
      'eTogZ2FtZVN0YXRlLmdyaWRbcm93XVtjb2xdfSk7CiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIAogICAg'
      'ICAgICAgICAgICAgY29uc3Qgc3BlY2lhbENlbGxzID0gY2x1c3Rlci5maWx0ZXIoKHtyb3csIGNvbH0pID0+IHsKICAgICAg'
      'ICAgICAgICAgICAgICBjb25zdCBpbmZvID0gZ2FtZVN0YXRlLnNwZWNpYWxzW2NlbGxLZXkocm93LCBjb2wpXTsKICAgICAg'
      'ICAgICAgICAgICAgICByZXR1cm4gaW5mbyAmJiBTUEVDSUFMX0NBTkRJRVNbaW5mby50eXBlXTsKICAgICAgICAgICAgICAg'
      'IH0pOwogICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBpZiAoc3BlY2lhbENlbGxzLmxlbmd0aCA+IDApIHsKICAg'
      'ICAgICAgICAgICAgICAgICBjbHVzdGVyLmZvckVhY2goKHtyb3csIGNvbH0pID0+IGNlbGxzVG9DbGVhci5hZGQoY2VsbEtl'
      'eShyb3csIGNvbCkpKTsKICAgICAgICAgICAgICAgICAgICBzcGVjaWFsQ2VsbHMuZm9yRWFjaCgoe3JvdywgY29sfSkgPT4g'
      'ewogICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmF0aW9uUXVldWUucHVzaCh7CiAgICAgICAgICAgICAgICAgICAgICAg'
      'ICAgICByb3csCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2wsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICBp'
      'bmZvOiBnYW1lU3RhdGUuc3BlY2lhbHNbY2VsbEtleShyb3csIGNvbCldLAogICAgICAgICAgICAgICAgICAgICAgICAgICAg'
      'Y2x1c3RlcgogICAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAg'
      'ICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgY29uc3QgcGF0dGVybkluZm8gPSBhbmFseXplQ2x1c3RlcihjbHVz'
      'dGVyKTsKICAgICAgICAgICAgICAgICAgICBpZiAocGF0dGVybkluZm8uc3BlY2lhbFR5cGUpIHsKICAgICAgICAgICAgICAg'
      'ICAgICAgICAgY29uc3QgcGl2b3RLZXkgPSBjZWxsS2V5KHBhdHRlcm5JbmZvLnBpdm90LnJvdywgcGF0dGVybkluZm8ucGl2'
      'b3QuY29sKTsKICAgICAgICAgICAgICAgICAgICAgICAgc3BlY2lhbENyZWF0aW9ucy5wdXNoKHsKICAgICAgICAgICAgICAg'
      'ICAgICAgICAgICAgIHJvdzogcGF0dGVybkluZm8ucGl2b3Qucm93LAogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29s'
      'OiBwYXR0ZXJuSW5mby5waXZvdC5jb2wsCiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBwYXR0ZXJuSW5mby5z'
      'cGVjaWFsVHlwZSwKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhc2U6IGdhbWVTdGF0ZS5ncmlkW3BhdHRlcm5JbmZv'
      'LnBpdm90LnJvd11bcGF0dGVybkluZm8ucGl2b3QuY29sXQogICAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAg'
      'ICAgICAgICAgICAgICAgY2x1c3Rlci5mb3JFYWNoKCh7cm93LCBjb2x9KSA9PiB7CiAgICAgICAgICAgICAgICAgICAgICAg'
      'ICAgICBjb25zdCBrZXkgPSBjZWxsS2V5KHJvdywgY29sKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXkg'
      'IT09IHBpdm90S2V5KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VsbHNUb0NsZWFyLmFkZChrZXkpOwog'
      'ICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAg'
      'ICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICBjbHVzdGVyLmZvckVhY2goKHtyb3csIGNvbH0pID0+IGNl'
      'bGxzVG9DbGVhci5hZGQoY2VsbEtleShyb3csIGNvbCkpKTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAg'
      'ICB9CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICAKICAgICAgICAgICAgLy8gQWN0aXZhdGUgc3BlY2lhbHMgdGhhdCB3'
      'ZXJlIHBhcnQgb2YgdGhlIG1hdGNoCiAgICAgICAgICAgIGFjdGl2YXRpb25RdWV1ZS5mb3JFYWNoKCh7cm93LCBjb2wsIGlu'
      'Zm8sIGNsdXN0ZXJ9KSA9PiB7CiAgICAgICAgICAgICAgICBpZiAoIWluZm8pIHJldHVybjsKICAgICAgICAgICAgICAgIGNv'
      'bnN0IGtleSA9IGNlbGxLZXkocm93LCBjb2wpOwogICAgICAgICAgICAgICAgc3dpdGNoIChpbmZvLnR5cGUpIHsKICAgICAg'
      'ICAgICAgICAgICAgICBjYXNlICdzdHJpcGVkX2gnOgogICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmF0ZVN0cmlwZWRI'
      'KHJvdywgY2VsbHNUb0NsZWFyKTsKICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAg'
      'Y2FzZSAnc3RyaXBlZF92JzoKICAgICAgICAgICAgICAgICAgICAgICAgYWN0aXZhdGVTdHJpcGVkVihjb2wsIGNlbGxzVG9D'
      'bGVhcik7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIGNhc2UgJ3dyYXBwZWQn'
      'OgogICAgICAgICAgICAgICAgICAgICAgICBhY3RpdmF0ZVdyYXBwZWQocm93LCBjb2wsIGNlbGxzVG9DbGVhcik7CiAgICAg'
      'ICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAgICAgICAgIGNhc2UgJ2NvbG9yX2JvbWInOiB7CiAgICAg'
      'ICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IGNsdXN0ZXIuZmluZChpdGVtID0+IGNlbGxLZXkoaXRlbS5yb3cs'
      'IGl0ZW0uY29sKSAhPT0ga2V5ICYmIGdhbWVTdGF0ZS5ncmlkW2l0ZW0ucm93XVtpdGVtLmNvbF0pOwogICAgICAgICAgICAg'
      'ICAgICAgICAgICBhY3RpdmF0ZUNvbG9yQm9tYih0YXJnZXQgPyBnYW1lU3RhdGUuZ3JpZFt0YXJnZXQucm93XVt0YXJnZXQu'
      'Y29sXSA6IG51bGwsIGNlbGxzVG9DbGVhcik7CiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrOwogICAgICAgICAgICAg'
      'ICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIGRlbGV0ZSBnYW1lU3RhdGUuc3BlY2lhbHNba2V5'
      'XTsKICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIAogICAgICAgICAgICAvLyBVcGRhdGUgY29sbGVjdCBvYmplY3RpdmUg'
      'cHJvZ3Jlc3MKICAgICAgICAgICAgbWF0Y2hlZENhbmRpZXMuZm9yRWFjaCgoe2NhbmR5fSkgPT4gewogICAgICAgICAgICAg'
      'ICAgaWYgKCFjYW5keSkgcmV0dXJuOwogICAgICAgICAgICAgICAgZ2FtZVN0YXRlLmNvbGxlY3RQcm9ncmVzc1tjYW5keV0g'
      'PSAoZ2FtZVN0YXRlLmNvbGxlY3RQcm9ncmVzc1tjYW5keV0gfHwgMCkgKyAxOwogICAgICAgICAgICB9KTsKICAgICAgICAg'
      'ICAgCiAgICAgICAgICAgIGNvbnN0IGJhc2VNYXRjaGVkQ291bnQgPSBtYXRjaFNldC5zaXplOwogICAgICAgICAgICBjb25z'
      'dCB0b3RhbENsZWFycyA9IE1hdGgubWF4KGJhc2VNYXRjaGVkQ291bnQsIGNlbGxzVG9DbGVhci5zaXplKTsKICAgICAgICAg'
      'ICAgY29uc3QgcG9pbnRzID0gdG90YWxDbGVhcnMgKiAxMDAgKiBnYW1lU3RhdGUuY29tYm87CiAgICAgICAgICAgIGlmIChw'
      'b2ludHMgPiAwKSB7CiAgICAgICAgICAgICAgICBhZGRTY29yZShwb2ludHMpOwogICAgICAgICAgICB9CiAgICAgICAgICAg'
      'IAogICAgICAgICAgICAvLyBWaXN1YWwgZWZmZWN0cwogICAgICAgICAgICBjb25zdCBjbGVhcmVkQ2VsbHMgPSBBcnJheS5m'
      'cm9tKGNlbGxzVG9DbGVhcikubWFwKGtleSA9PiB7CiAgICAgICAgICAgICAgICBjb25zdCBbcm93LCBjb2xdID0ga2V5LnNw'
      'bGl0KCcsJykubWFwKE51bWJlcik7CiAgICAgICAgICAgICAgICByZXR1cm4ge3JvdywgY29sfTsKICAgICAgICAgICAgfSk7'
      'CiAgICAgICAgICAgIAogICAgICAgICAgICBjbGVhcmVkQ2VsbHMuZm9yRWFjaCgoe3JvdywgY29sfSkgPT4gewogICAgICAg'
      'ICAgICAgICAgY29uc3QgY2VsbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLXJvdz0iJHtyb3d9Il1bZGF0YS1j'
      'b2w9IiR7Y29sfSJdYCk7CiAgICAgICAgICAgICAgICBpZiAoY2VsbCkgewogICAgICAgICAgICAgICAgICAgIGNlbGwuY2xh'
      'c3NMaXN0LmFkZCgnZXhwbG9kaW5nJyk7CiAgICAgICAgICAgICAgICAgICAgY3JlYXRlUGFydGljbGVzKGNlbGwpOwogICAg'
      'ICAgICAgICAgICAgfQogICAgICAgICAgICB9KTsKICAgICAgICAgICAgCiAgICAgICAgICAgIHNwZWNpYWxDcmVhdGlvbnMu'
      'Zm9yRWFjaCgoe3JvdywgY29sfSkgPT4gewogICAgICAgICAgICAgICAgY29uc3QgY2VsbCA9IGRvY3VtZW50LnF1ZXJ5U2Vs'
      'ZWN0b3IoYFtkYXRhLXJvdz0iJHtyb3d9Il1bZGF0YS1jb2w9IiR7Y29sfSJdYCk7CiAgICAgICAgICAgICAgICBpZiAoY2Vs'
      'bCkgewogICAgICAgICAgICAgICAgICAgIGNlbGwuY2xhc3NMaXN0LmFkZCgnc3BlY2lhbC1jcmVhdGVkJyk7CiAgICAgICAg'
      'ICAgICAgICB9CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICAKICAgICAgICAgICAgYXdhaXQgZGVsYXkoNDAwKTsKICAg'
      'ICAgICAgICAgCiAgICAgICAgICAgIC8vIENsZWFyIG1hdGNoZWQgY2VsbHMKICAgICAgICAgICAgY2xlYXJlZENlbGxzLmZv'
      'ckVhY2goKHtyb3csIGNvbH0pID0+IHsKICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGNlbGxLZXkocm93LCBjb2wpOwog'
      'ICAgICAgICAgICAgICAgZ2FtZVN0YXRlLmdyaWRbcm93XVtjb2xdID0gbnVsbDsKICAgICAgICAgICAgICAgIGRlbGV0ZSBn'
      'YW1lU3RhdGUuc3BlY2lhbHNba2V5XTsKICAgICAgICAgICAgICAgIGRlbGV0ZSBnYW1lU3RhdGUub2JzdGFjbGVIZWFsdGhb'
      'a2V5XTsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgY29uc3QgY2VsbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0'
      'b3IoYFtkYXRhLXJvdz0iJHtyb3d9Il1bZGF0YS1jb2w9IiR7Y29sfSJdYCk7CiAgICAgICAgICAgICAgICBpZiAoY2VsbCkg'
      'ewogICAgICAgICAgICAgICAgICAgIGNlbGwuY2xhc3NMaXN0LnJlbW92ZSgnZXhwbG9kaW5nJyk7CiAgICAgICAgICAgICAg'
      'ICAgICAgY2VsbC5kYXRhc2V0Lm9ic3RhY2xlID0gJ2ZhbHNlJzsKICAgICAgICAgICAgICAgICAgICBjZWxsLmRhdGFzZXQu'
      'b2JzdGFjbGVUeXBlID0gJyc7CiAgICAgICAgICAgICAgICAgICAgY2VsbC5kYXRhc2V0LmhwID0gJzAnOwogICAgICAgICAg'
      'ICAgICAgICAgIHVwZGF0ZU9ic3RhY2xlSHBEaXNwbGF5KHJvdywgY29sLCAwKTsKICAgICAgICAgICAgICAgIH0KICAgICAg'
      'ICAgICAgICAgIAogICAgICAgICAgICAgICAgdXBkYXRlQ2VsbERpc3BsYXkocm93LCBjb2wpOwogICAgICAgICAgICB9KTsK'
      'ICAgICAgICAgICAgCiAgICAgICAgICAgIC8vIEFwcGx5IG5ldyBzcGVjaWFsIGNhbmRpZXMKICAgICAgICAgICAgc3BlY2lh'
      'bENyZWF0aW9ucy5mb3JFYWNoKCh7cm93LCBjb2wsIHR5cGUsIGJhc2V9KSA9PiB7CiAgICAgICAgICAgICAgICBjb25zdCBr'
      'ZXkgPSBjZWxsS2V5KHJvdywgY29sKTsKICAgICAgICAgICAgICAgIGdhbWVTdGF0ZS5zcGVjaWFsc1trZXldID0ge3R5cGUs'
      'IGJhc2V9OwogICAgICAgICAgICAgICAgY29uc3QgY2VsbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLXJvdz0i'
      'JHtyb3d9Il1bZGF0YS1jb2w9IiR7Y29sfSJdYCk7CiAgICAgICAgICAgICAgICBpZiAoY2VsbCkgewogICAgICAgICAgICAg'
      'ICAgICAgIHNldFRpbWVvdXQoKCkgPT4gY2VsbC5jbGFzc0xpc3QucmVtb3ZlKCdzcGVjaWFsLWNyZWF0ZWQnKSwgNjAwKTsK'
      'ICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIHVwZGF0ZUNlbGxEaXNwbGF5KHJvdywgY29sKTsKICAgICAgICAg'
      'ICAgfSk7CiAgICAgICAgICAgIAogICAgICAgICAgICB1cGRhdGVUYXJnZXREaXNwbGF5KCk7CiAgICAgICAgfQoKICAgICAg'
      'ICBmdW5jdGlvbiBidWlsZE1hdGNoQ2x1c3RlcnMobWF0Y2hBcnJheSkgewogICAgICAgICAgICBjb25zdCBtYXRjaFNldCA9'
      'IG5ldyBTZXQobWF0Y2hBcnJheS5tYXAoKHtyb3csIGNvbH0pID0+IGNlbGxLZXkocm93LCBjb2wpKSk7CiAgICAgICAgICAg'
      'IGNvbnN0IHZpc2l0ZWQgPSBuZXcgU2V0KCk7CiAgICAgICAgICAgIGNvbnN0IGNsdXN0ZXJzID0gW107CiAgICAgICAgICAg'
      'IAogICAgICAgICAgICBtYXRjaEFycmF5LmZvckVhY2goKHtyb3csIGNvbH0pID0+IHsKICAgICAgICAgICAgICAgIGNvbnN0'
      'IHN0YXJ0S2V5ID0gY2VsbEtleShyb3csIGNvbCk7CiAgICAgICAgICAgICAgICBpZiAodmlzaXRlZC5oYXMoc3RhcnRLZXkp'
      'KSByZXR1cm47CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIGNvbnN0IHF1ZXVlID0gW3N0YXJ0S2V5XTsKICAg'
      'ICAgICAgICAgICAgIGNvbnN0IGNsdXN0ZXIgPSBbXTsKICAgICAgICAgICAgICAgIHZpc2l0ZWQuYWRkKHN0YXJ0S2V5KTsK'
      'ICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgd2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHsKICAgICAgICAgICAg'
      'ICAgICAgICBjb25zdCBrZXkgPSBxdWV1ZS5wb3AoKTsKICAgICAgICAgICAgICAgICAgICBjb25zdCBbciwgY10gPSBrZXku'
      'c3BsaXQoJywnKS5tYXAoTnVtYmVyKTsKICAgICAgICAgICAgICAgICAgICBjbHVzdGVyLnB1c2goe3JvdzogciwgY29sOiBj'
      'fSk7CiAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmVpZ2hib3JzID0gWwogICAgICAg'
      'ICAgICAgICAgICAgICAgICBbciAtIDEsIGNdLAogICAgICAgICAgICAgICAgICAgICAgICBbciArIDEsIGNdLAogICAgICAg'
      'ICAgICAgICAgICAgICAgICBbciwgYyAtIDFdLAogICAgICAgICAgICAgICAgICAgICAgICBbciwgYyArIDFdCiAgICAgICAg'
      'ICAgICAgICAgICAgXTsKICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICBuZWlnaGJvcnMuZm9yRWFj'
      'aCgoW25yLCBuY10pID0+IHsKICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5yID49IDAgJiYgbnIgPCBHUklEX1NJWkUg'
      'JiYgbmMgPj0gMCAmJiBuYyA8IEdSSURfU0laRSkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmVpZ2hi'
      'b3JLZXkgPSBjZWxsS2V5KG5yLCBuYyk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hTZXQuaGFzKG5l'
      'aWdoYm9yS2V5KSAmJiAhdmlzaXRlZC5oYXMobmVpZ2hib3JLZXkpKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg'
      'ICAgdmlzaXRlZC5hZGQobmVpZ2hib3JLZXkpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2go'
      'bmVpZ2hib3JLZXkpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICB9CiAg'
      'ICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAg'
      'IGNsdXN0ZXJzLnB1c2goY2x1c3Rlcik7CiAgICAgICAgICAgIH0pOwogICAgICAgICAgICAKICAgICAgICAgICAgcmV0dXJu'
      'IGNsdXN0ZXJzOwogICAgICAgIH0KCiAgICAgICAgZnVuY3Rpb24gYW5hbHl6ZUNsdXN0ZXIoY2x1c3RlcikgewogICAgICAg'
      'ICAgICBjb25zdCByb3dzID0gbmV3IFNldChjbHVzdGVyLm1hcChjID0+IGMucm93KSk7CiAgICAgICAgICAgIGNvbnN0IGNv'
      'bHMgPSBuZXcgU2V0KGNsdXN0ZXIubWFwKGMgPT4gYy5jb2wpKTsKICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IGNsdXN0ZXIu'
      'bGVuZ3RoOwogICAgICAgICAgICBjb25zdCBpc0hvcml6b250YWwgPSByb3dzLnNpemUgPT09IDE7CiAgICAgICAgICAgIGNv'
      'bnN0IGlzVmVydGljYWwgPSBjb2xzLnNpemUgPT09IDE7CiAgICAgICAgICAgIGNvbnN0IGlzTGluZSA9IGlzSG9yaXpvbnRh'
      'bCB8fCBpc1ZlcnRpY2FsOwogICAgICAgICAgICAKICAgICAgICAgICAgaWYgKGlzTGluZSAmJiBzaXplID49IDUpIHsKICAg'
      'ICAgICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgICAgICAgICAgc3BlY2lhbFR5cGU6ICdjb2xvcl9ib21iJywKICAg'
      'ICAgICAgICAgICAgICAgICBvcmllbnRhdGlvbjogaXNIb3Jpem9udGFsID8gJ2hvcml6b250YWwnIDogJ3ZlcnRpY2FsJywK'
      'ICAgICAgICAgICAgICAgICAgICBwaXZvdDogZ2V0TGluZVBpdm90KGNsdXN0ZXIsIGlzSG9yaXpvbnRhbCA/ICdob3Jpem9u'
      'dGFsJyA6ICd2ZXJ0aWNhbCcpCiAgICAgICAgICAgICAgICB9OwogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAg'
      'ICAgICBpZiAoaXNMaW5lICYmIHNpemUgPT09IDQpIHsKICAgICAgICAgICAgICAgIHJldHVybiB7CiAgICAgICAgICAgICAg'
      'ICAgICAgc3BlY2lhbFR5cGU6IGlzSG9yaXpvbnRhbCA/ICdzdHJpcGVkX2gnIDogJ3N0cmlwZWRfdicsCiAgICAgICAgICAg'
      'ICAgICAgICAgb3JpZW50YXRpb246IGlzSG9yaXpvbnRhbCA/ICdob3Jpem9udGFsJyA6ICd2ZXJ0aWNhbCcsCiAgICAgICAg'
      'ICAgICAgICAgICAgcGl2b3Q6IGdldExpbmVQaXZvdChjbHVzdGVyLCBpc0hvcml6b250YWwgPyAnaG9yaXpvbnRhbCcgOiAn'
      'dmVydGljYWwnKQogICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgaWYg'
      'KCFpc0xpbmUgJiYgc2l6ZSA+PSA1KSB7CiAgICAgICAgICAgICAgICByZXR1cm4gewogICAgICAgICAgICAgICAgICAgIHNw'
      'ZWNpYWxUeXBlOiAnd3JhcHBlZCcsCiAgICAgICAgICAgICAgICAgICAgb3JpZW50YXRpb246IG51bGwsCiAgICAgICAgICAg'
      'ICAgICAgICAgcGl2b3Q6IGdldENsdXN0ZXJQaXZvdChjbHVzdGVyKQogICAgICAgICAgICAgICAgfTsKICAgICAgICAgICAg'
      'fQogICAgICAgICAgICAKICAgICAgICAgICAgcmV0dXJuIHsKICAgICAgICAgICAgICAgIHNwZWNpYWxUeXBlOiBudWxsLAog'
      'ICAgICAgICAgICAgICAgb3JpZW50YXRpb246IG51bGwsCiAgICAgICAgICAgICAgICBwaXZvdDogbnVsbAogICAgICAgICAg'
      'ICB9OwogICAgICAgIH0KCiAgICAgICAgZnVuY3Rpb24gZ2V0TGluZVBpdm90KGNsdXN0ZXIsIG9yaWVudGF0aW9uKSB7CiAg'
      'ICAgICAgICAgIGNvbnN0IHNvcnRlZCA9IFsuLi5jbHVzdGVyXS5zb3J0KChhLCBiKSA9PiB7CiAgICAgICAgICAgICAgICBy'
      'ZXR1cm4gb3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyA/IGEuY29sIC0gYi5jb2wgOiBhLnJvdyAtIGIucm93OwogICAg'
      'ICAgICAgICB9KTsKICAgICAgICAgICAgcmV0dXJuIHNvcnRlZFtNYXRoLmZsb29yKHNvcnRlZC5sZW5ndGggLyAyKV07CiAg'
      'ICAgICAgfQoKICAgICAgICBmdW5jdGlvbiBnZXRDbHVzdGVyUGl2b3QoY2x1c3RlcikgewogICAgICAgICAgICBjb25zdCBj'
      'bHVzdGVyU2V0ID0gbmV3IFNldChjbHVzdGVyLm1hcCgoe3JvdywgY29sfSkgPT4gY2VsbEtleShyb3csIGNvbCkpKTsKICAg'
      'ICAgICAgICAgbGV0IGJlc3RDZWxsID0gY2x1c3RlclswXTsKICAgICAgICAgICAgbGV0IGJlc3RTY29yZSA9IC0xOwogICAg'
      'ICAgICAgICAKICAgICAgICAgICAgY2x1c3Rlci5mb3JFYWNoKGNlbGwgPT4gewogICAgICAgICAgICAgICAgY29uc3Qge3Jv'
      'dywgY29sfSA9IGNlbGw7CiAgICAgICAgICAgICAgICBjb25zdCBuZWlnaGJvcnMgPSBbCiAgICAgICAgICAgICAgICAgICAg'
      'Y2VsbEtleShyb3cgLSAxLCBjb2wpLAogICAgICAgICAgICAgICAgICAgIGNlbGxLZXkocm93ICsgMSwgY29sKSwKICAgICAg'
      'ICAgICAgICAgICAgICBjZWxsS2V5KHJvdywgY29sIC0gMSksCiAgICAgICAgICAgICAgICAgICAgY2VsbEtleShyb3csIGNv'
      'bCArIDEpCiAgICAgICAgICAgICAgICBdOwogICAgICAgICAgICAgICAgY29uc3Qgc2NvcmUgPSBuZWlnaGJvcnMucmVkdWNl'
      'KChhY2MsIGtleSkgPT4gYWNjICsgKGNsdXN0ZXJTZXQuaGFzKGtleSkgPyAxIDogMCksIDApOwogICAgICAgICAgICAgICAg'
      'aWYgKHNjb3JlID4gYmVzdFNjb3JlKSB7CiAgICAgICAgICAgICAgICAgICAgYmVzdFNjb3JlID0gc2NvcmU7CiAgICAgICAg'
      'ICAgICAgICAgICAgYmVzdENlbGwgPSBjZWxsOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KTsKICAgICAgICAg'
      'ICAgCiAgICAgICAgICAgIHJldHVybiBiZXN0Q2VsbDsKICAgICAgICB9CgogICAgICAgIGZ1bmN0aW9uIGFjdGl2YXRlU3Ry'
      'aXBlZEgocm93LCBjZWxsc1RvQ2xlYXIpIHsKICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgR1JJRF9TSVpF'
      'OyBjb2wrKykgewogICAgICAgICAgICAgICAgY2VsbHNUb0NsZWFyLmFkZChjZWxsS2V5KHJvdywgY29sKSk7CiAgICAgICAg'
      'ICAgICAgICBjb25zdCBjZWxsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtcm93PSIke3Jvd30iXVtkYXRhLWNv'
      'bD0iJHtjb2x9Il1gKTsKICAgICAgICAgICAgICAgIGlmIChjZWxsKSB7CiAgICAgICAgICAgICAgICAgICAgY2VsbC5jbGFz'
      'c0xpc3QuYWRkKCdyb3ctc3dlZXAnKTsKICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGNlbGwuY2xhc3NM'
      'aXN0LnJlbW92ZSgncm93LXN3ZWVwJyksIDQ1MCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9'
      'CgogICAgICAgIGZ1bmN0aW9uIGFjdGl2YXRlU3RyaXBlZFYoY29sLCBjZWxsc1RvQ2xlYXIpIHsKICAgICAgICAgICAgZm9y'
      'IChsZXQgcm93ID0gMDsgcm93IDwgR1JJRF9TSVpFOyByb3crKykgewogICAgICAgICAgICAgICAgY2VsbHNUb0NsZWFyLmFk'
      'ZChjZWxsS2V5KHJvdywgY29sKSk7CiAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rv'
      'cihgW2RhdGEtcm93PSIke3Jvd30iXVtkYXRhLWNvbD0iJHtjb2x9Il1gKTsKICAgICAgICAgICAgICAgIGlmIChjZWxsKSB7'
      'CiAgICAgICAgICAgICAgICAgICAgY2VsbC5jbGFzc0xpc3QuYWRkKCdjb2wtc3dlZXAnKTsKICAgICAgICAgICAgICAgICAg'
      'ICBzZXRUaW1lb3V0KCgpID0+IGNlbGwuY2xhc3NMaXN0LnJlbW92ZSgnY29sLXN3ZWVwJyksIDQ1MCk7CiAgICAgICAgICAg'
      'ICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIGZ1bmN0aW9uIGFjdGl2YXRlV3JhcHBlZChyb3csIGNv'
      'bCwgY2VsbHNUb0NsZWFyKSB7CiAgICAgICAgICAgIGZvciAobGV0IHIgPSByb3cgLSAxOyByIDw9IHJvdyArIDE7IHIrKykg'
      'ewogICAgICAgICAgICAgICAgZm9yIChsZXQgYyA9IGNvbCAtIDE7IGMgPD0gY29sICsgMTsgYysrKSB7CiAgICAgICAgICAg'
      'ICAgICAgICAgaWYgKHIgPj0gMCAmJiByIDwgR1JJRF9TSVpFICYmIGMgPj0gMCAmJiBjIDwgR1JJRF9TSVpFKSB7CiAgICAg'
      'ICAgICAgICAgICAgICAgICAgIGNlbGxzVG9DbGVhci5hZGQoY2VsbEtleShyLCBjKSk7CiAgICAgICAgICAgICAgICAgICAg'
      'ICAgIGNvbnN0IGNlbGwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1yb3c9IiR7cn0iXVtkYXRhLWNvbD0iJHtj'
      'fSJdYCk7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBj'
      'ZWxsLmNsYXNzTGlzdC5hZGQoJ2FyZWEtYnVyc3QnKTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQo'
      'KCkgPT4gY2VsbC5jbGFzc0xpc3QucmVtb3ZlKCdhcmVhLWJ1cnN0JyksIDYwMCk7CiAgICAgICAgICAgICAgICAgICAgICAg'
      'IH0KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9CgogICAg'
      'ICAgIGZ1bmN0aW9uIGFjdGl2YXRlQ29sb3JCb21iKGNhbmR5LCBjZWxsc1RvQ2xlYXIpIHsKICAgICAgICAgICAgaWYgKCFj'
      'YW5keSkgewogICAgICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgR1JJRF9TSVpFOyByb3crKykgewogICAg'
      'ICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IEdSSURfU0laRTsgY29sKyspIHsKICAgICAgICAgICAg'
      'ICAgICAgICAgICAgY2VsbHNUb0NsZWFyLmFkZChjZWxsS2V5KHJvdywgY29sKSk7CiAgICAgICAgICAgICAgICAgICAgICAg'
      'IGNvbnN0IGNlbGwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1yb3c9IiR7cm93fSJdW2RhdGEtY29sPSIke2Nv'
      'bH0iXWApOwogICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2VsbCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAg'
      'Y2VsbC5jbGFzc0xpc3QuYWRkKCdjb2xvci1ibGFzdCcpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91'
      'dCgoKSA9PiBjZWxsLmNsYXNzTGlzdC5yZW1vdmUoJ2NvbG9yLWJsYXN0JyksIDcwMCk7CiAgICAgICAgICAgICAgICAgICAg'
      'ICAgIH0KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICByZXR1cm47CiAg'
      'ICAgICAgICAgIH0KICAgICAgICAgICAgCiAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IEdSSURfU0laRTsg'
      'cm93KyspIHsKICAgICAgICAgICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IEdSSURfU0laRTsgY29sKyspIHsKICAg'
      'ICAgICAgICAgICAgICAgICBpZiAoZ2FtZVN0YXRlLmdyaWRbcm93XVtjb2xdID09PSBjYW5keSkgewogICAgICAgICAgICAg'
      'ICAgICAgICAgICBjZWxsc1RvQ2xlYXIuYWRkKGNlbGxLZXkocm93LCBjb2wpKTsKICAgICAgICAgICAgICAgICAgICAgICAg'
      'Y29uc3QgY2VsbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLXJvdz0iJHtyb3d9Il1bZGF0YS1jb2w9IiR7Y29s'
      'fSJdYCk7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsKSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBj'
      'ZWxsLmNsYXNzTGlzdC5hZGQoJ2NvbG9yLWJsYXN0Jyk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0'
      'KCgpID0+IGNlbGwuY2xhc3NMaXN0LnJlbW92ZSgnY29sb3ItYmxhc3QnKSwgNzAwKTsKICAgICAgICAgICAgICAgICAgICAg'
      'ICAgfQogICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgIH0KCiAg'
      'ICAgICAgZnVuY3Rpb24gY2VsbEtleShyb3csIGNvbCkgewogICAgICAgICAgICByZXR1cm4gYCR7cm93fSwke2NvbH1gOwog'
      'ICAgICAgIH0KCiAgICAgICAgYXN5bmMgZnVuY3Rpb24gZHJvcENhbmRpZXMoKSB7CiAgICAgICAgICAgIGZvciAobGV0IGNv'
      'bCA9IDA7IGNvbCA8IEdSSURfU0laRTsgY29sKyspIHsKICAgICAgICAgICAgICAgIGxldCBlbXB0eVJvdyA9IEdSSURfU0la'
      'RSAtIDE7CiAgICAgICAgICAgICAgICBmb3IgKGxldCByb3cgPSBHUklEX1NJWkUgLSAxOyByb3cgPj0gMDsgcm93LS0pIHsK'
      'ICAgICAgICAgICAgICAgICAgICBpZiAoZ2FtZVN0YXRlLmdyaWRbcm93XVtjb2xdICE9PSBudWxsKSB7CiAgICAgICAgICAg'
      'ICAgICAgICAgICAgIGlmIChyb3cgIT09IGVtcHR5Um93KSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYW1lU3Rh'
      'dGUuZ3JpZFtlbXB0eVJvd11bY29sXSA9IGdhbWVTdGF0ZS5ncmlkW3Jvd11bY29sXTsKICAgICAgICAgICAgICAgICAgICAg'
      'ICAgICAgIGdhbWVTdGF0ZS5ncmlkW3Jvd11bY29sXSA9IG51bGw7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25z'
      'dCBmcm9tS2V5ID0gYCR7cm93fSwke2NvbH1gOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9LZXkgPSBg'
      'JHtlbXB0eVJvd30sJHtjb2x9YDsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChnYW1lU3RhdGUuc3BlY2lhbHNb'
      'ZnJvbUtleV0gIT09IHVuZGVmaW5lZCkgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhbWVTdGF0ZS5zcGVj'
      'aWFsc1t0b0tleV0gPSBnYW1lU3RhdGUuc3BlY2lhbHNbZnJvbUtleV07CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAg'
      'ICAgZGVsZXRlIGdhbWVTdGF0ZS5zcGVjaWFsc1tmcm9tS2V5XTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxz'
      'ZSB7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGdhbWVTdGF0ZS5zcGVjaWFsc1t0b0tleV07CiAg'
      'ICAgICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVDZWxsRGlzcGxh'
      'eShyb3csIGNvbCk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVDZWxsRGlzcGxheShlbXB0eVJvdywgY29s'
      'KTsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VsbCA9'
      'IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLXJvdz0iJHtlbXB0eVJvd30iXVtkYXRhLWNvbD0iJHtjb2x9Il1gKTsK'
      'ICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjZWxsKSBjZWxsLmNsYXNzTGlzdC5hZGQoJ2ZhbGxpbmcnKTsKICAg'
      'ICAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgICAgICAgICBlbXB0eVJvdy0tOwogICAgICAgICAgICAg'
      'ICAgICAgIH0KICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAgICAgICAgICBhd2FpdCBkZWxheSgzMDApOwog'
      'ICAgICAgIH0KCiAgICAgICAgYXN5bmMgZnVuY3Rpb24gZmlsbEVtcHR5KCkgewogICAgICAgICAgICBmb3IgKGxldCBjb2wg'
      'PSAwOyBjb2wgPCBHUklEX1NJWkU7IGNvbCsrKSB7CiAgICAgICAgICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCBH'
      'UklEX1NJWkU7IHJvdysrKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGdhbWVTdGF0ZS5ncmlkW3Jvd11bY29sXSA9PT0g'
      'bnVsbCkgewogICAgICAgICAgICAgICAgICAgICAgICBsZXQgY2FuZHk7CiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBv'
      'YnN0YWNsZSA9IG51bGw7CiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRTcGF3bk9ic3RhY2xlKCkpIHsKICAg'
      'ICAgICAgICAgICAgICAgICAgICAgICAgIG9ic3RhY2xlID0gZ2V0UmFuZG9tT2JzdGFjbGUoKTsKICAgICAgICAgICAgICAg'
      'ICAgICAgICAgICAgIGNhbmR5ID0gb2JzdGFjbGUuZW1vamk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBnYW1lU3Rh'
      'dGUub2JzdGFjbGVIZWFsdGhbYCR7cm93fSwke2NvbH1gXSA9IG9ic3RhY2xlLmhwOwogICAgICAgICAgICAgICAgICAgICAg'
      'ICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FuZHkgPSBnZXRSYW5kb21DYW5keSgpOwogICAgICAg'
      'ICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICBnYW1l'
      'U3RhdGUuZ3JpZFtyb3ddW2NvbF0gPSBjYW5keTsKICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGdhbWVTdGF0ZS5z'
      'cGVjaWFsc1tgJHtyb3d9LCR7Y29sfWBdOwogICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVDZWxsRGlzcGxheShyb3cs'
      'IGNvbCk7CiAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gZG9j'
      'dW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtcm93PSIke3Jvd30iXVtkYXRhLWNvbD0iJHtjb2x9Il1gKTsKICAgICAgICAg'
      'ICAgICAgICAgICAgICAgaWYgKGNlbGwpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuY2xhc3NMaXN0LmFk'
      'ZCgnZmFsbGluZycpOwogICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9ic3RhY2xlKSB7CiAgICAgICAgICAgICAg'
      'ICAgICAgICAgICAgICAgICAgY2VsbC5kYXRhc2V0Lm9ic3RhY2xlID0gJ3RydWUnOwogICAgICAgICAgICAgICAgICAgICAg'
      'ICAgICAgICAgIGNlbGwuZGF0YXNldC5vYnN0YWNsZVR5cGUgPSBvYnN0YWNsZS50eXBlOwogICAgICAgICAgICAgICAgICAg'
      'ICAgICAgICAgICAgIGNlbGwuZGF0YXNldC5ocCA9IG9ic3RhY2xlLmhwOwogICAgICAgICAgICAgICAgICAgICAgICAgICAg'
      'ICAgIHVwZGF0ZU9ic3RhY2xlSHBEaXNwbGF5KHJvdywgY29sLCBvYnN0YWNsZS5ocCk7CiAgICAgICAgICAgICAgICAgICAg'
      'ICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAg'
      'ICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgYXdhaXQgZGVsYXkoMzAwKTsKICAgICAgICB9CgogICAgICAgIGZ1bmN0'
      'aW9uIGFkZFNjb3JlKHBvaW50cykgewogICAgICAgICAgICBnYW1lU3RhdGUuc2NvcmUgKz0gcG9pbnRzOwogICAgICAgICAg'
      'ICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2NvcmVEaXNwbGF5JykudGV4dENvbnRlbnQgPSBnYW1lU3RhdGUuc2NvcmU7'
      'CiAgICAgICAgICAgIHVwZGF0ZVRhcmdldERpc3BsYXkoKTsKICAgICAgICAgICAgCiAgICAgICAgICAgIC8vIFVwZGF0ZSBt'
      'ZXRhIHByb2dyZXNzCiAgICAgICAgICAgIGNvbnN0IHByb2dyZXNzR2FpbiA9IE1hdGguZmxvb3IocG9pbnRzIC8gMTAwMCk7'
      'CiAgICAgICAgICAgIGdhbWVTdGF0ZS5wcm9ncmVzcy5jYXN0bGUgPSBNYXRoLm1pbigxMDAsIGdhbWVTdGF0ZS5wcm9ncmVz'
      'cy5jYXN0bGUgKyBwcm9ncmVzc0dhaW4gKiAwLjMpOwogICAgICAgICAgICBnYW1lU3RhdGUucHJvZ3Jlc3MuZ2FyZGVuID0g'
      'TWF0aC5taW4oMTAwLCBnYW1lU3RhdGUucHJvZ3Jlc3MuZ2FyZGVuICsgcHJvZ3Jlc3NHYWluICogMC4yKTsKICAgICAgICAg'
      'ICAgZ2FtZVN0YXRlLnByb2dyZXNzLmFxdWFyaXVtID0gTWF0aC5taW4oMTAwLCBnYW1lU3RhdGUucHJvZ3Jlc3MuYXF1YXJp'
      'dW0gKyBwcm9ncmVzc0dhaW4gKiAwLjI1KTsKICAgICAgICAgICAgCiAgICAgICAgICAgIHVwZGF0ZU1ldGFQcm9ncmVzcygp'
      'OwogICAgICAgIH0KCiAgICAgICAgZnVuY3Rpb24gdXBkYXRlTWV0YVByb2dyZXNzKCkgewogICAgICAgICAgICBkb2N1bWVu'
      'dC5nZXRFbGVtZW50QnlJZCgnY2FzdGxlUHJvZ3Jlc3MnKS5zdHlsZS53aWR0aCA9IGdhbWVTdGF0ZS5wcm9ncmVzcy5jYXN0'
      'bGUgKyAnJSc7CiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdnYXJkZW5Qcm9ncmVzcycpLnN0eWxlLndp'
      'ZHRoID0gZ2FtZVN0YXRlLnByb2dyZXNzLmdhcmRlbiArICclJzsKICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5'
      'SWQoJ2FxdWFyaXVtUHJvZ3Jlc3MnKS5zdHlsZS53aWR0aCA9IGdhbWVTdGF0ZS5wcm9ncmVzcy5hcXVhcml1bSArICclJzsK'
      'ICAgICAgICAgICAgc2F2ZVByb2dyZXNzKCk7CiAgICAgICAgfQoKICAgICAgICBmdW5jdGlvbiBzaG93Q29tYm8oY29tYm8p'
      'IHsKICAgICAgICAgICAgY29uc3QgZGlzcGxheSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb21ib0Rpc3BsYXknKTsK'
      'ICAgICAgICAgICAgaWYgKHR5cGVvZiBjb21ibyA9PT0gJ251bWJlcicpIHsKICAgICAgICAgICAgICAgIGRpc3BsYXkudGV4'
      'dENvbnRlbnQgPSBgJHtjb21ib314IENPTUJPIWA7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICBkaXNw'
      'bGF5LnRleHRDb250ZW50ID0gY29tYm87CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZGlzcGxheS5zdHlsZS5kaXNwbGF5'
      'ID0gJ2Jsb2NrJzsKICAgICAgICAgICAgCiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gewogICAgICAgICAgICAgICAg'
      'ZGlzcGxheS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOwogICAgICAgICAgICB9LCAxMDAwKTsKICAgICAgICB9CgogICAgICAg'
      'IGZ1bmN0aW9uIGNyZWF0ZVBhcnRpY2xlcyhjZWxsKSB7CiAgICAgICAgICAgIGNvbnN0IHJlY3QgPSBjZWxsLmdldEJvdW5k'
      'aW5nQ2xpZW50UmVjdCgpOwogICAgICAgICAgICBjb25zdCBjZW50ZXJYID0gcmVjdC5sZWZ0ICsgcmVjdC53aWR0aCAvIDI7'
      'CiAgICAgICAgICAgIGNvbnN0IGNlbnRlclkgPSByZWN0LnRvcCArIHJlY3QuaGVpZ2h0IC8gMjsKICAgICAgICAgICAgCiAg'
      'ICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTsgaSsrKSB7CiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWNsZSA9'
      'IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpOwogICAgICAgICAgICAgICAgcGFydGljbGUuY2xhc3NOYW1lID0gJ3Bh'
      'cnRpY2xlJzsKICAgICAgICAgICAgICAgIHBhcnRpY2xlLnRleHRDb250ZW50ID0gWyfinKgnLCAn4q2QJywgJ/CfkqsnLCAn'
      '8J+MnyddW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDQpXTsKICAgICAgICAgICAgICAgIHBhcnRpY2xlLnN0eWxlLmxl'
      'ZnQgPSBjZW50ZXJYICsgJ3B4JzsKICAgICAgICAgICAgICAgIHBhcnRpY2xlLnN0eWxlLnRvcCA9IGNlbnRlclkgKyAncHgn'
      'OwogICAgICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwYXJ0aWNsZSk7CiAgICAgICAgICAgICAgICAK'
      'ICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcGFydGljbGUucmVtb3ZlKCksIDEwMDApOwogICAgICAgICAgICB9'
      'CiAgICAgICAgfQoKICAgICAgICBmdW5jdGlvbiBjcmVhdGVBdHRhY2tCdXJzdChjZWxsKSB7CiAgICAgICAgICAgIGNvbnN0'
      'IGJ1cnN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7CiAgICAgICAgICAgIGJ1cnN0LmNsYXNzTmFtZSA9ICdh'
      'dHRhY2stYnVyc3QnOwogICAgICAgICAgICBjZWxsLmFwcGVuZENoaWxkKGJ1cnN0KTsKICAgICAgICAgICAgc2V0VGltZW91'
      'dCgoKSA9PiBidXJzdC5yZW1vdmUoKSwgNjAwKTsKICAgICAgICB9CgogICAgICAgIGZ1bmN0aW9uIGNyZWF0ZVNob2Nrd2F2'
      'ZShjZWxsKSB7CiAgICAgICAgICAgIGNvbnN0IHNob2Nrd2F2ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpOwog'
      'ICAgICAgICAgICBzaG9ja3dhdmUuY2xhc3NOYW1lID0gJ3Nob2Nrd2F2ZSc7CiAgICAgICAgICAgIGNlbGwuYXBwZW5kQ2hp'
      'bGQoc2hvY2t3YXZlKTsKICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzaG9ja3dhdmUucmVtb3ZlKCksIDgwMCk7CiAg'
      'ICAgICAgfQoKICAgICAgICBmdW5jdGlvbiBjcmVhdGVFeHBsb3Npb25FZmZlY3QoY2VsbCkgewogICAgICAgICAgICBjb25z'
      'dCBleHBsb3Npb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTsKICAgICAgICAgICAgZXhwbG9zaW9uLmNsYXNz'
      'TmFtZSA9ICdleHBsb3Npb24tZWZmZWN0JzsKICAgICAgICAgICAgY2VsbC5hcHBlbmRDaGlsZChleHBsb3Npb24pOwogICAg'
      'ICAgICAgICAKICAgICAgICAgICAgLy8gRW5oYW5jZWQgcGFydGljbGVzIGZvciBleHBsb3Npb24KICAgICAgICAgICAgZm9y'
      'IChsZXQgaSA9IDA7IGkgPCAxMDsgaSsrKSB7CiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGNyZWF0ZVBhcnRp'
      'Y2xlcyhjZWxsKSwgaSAqIDUwKTsKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgc2V0VGltZW91dCgo'
      'KSA9PiBleHBsb3Npb24ucmVtb3ZlKCksIDgwMCk7CiAgICAgICAgfQoKICAgICAgICBmdW5jdGlvbiBkZWxheShtcykgewog'
      'ICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7CiAgICAg'
      'ICAgfQoKICAgICAgICAvLyBNaXNzeSBIZWxwZXIgQUkgTG9naWMKICAgICAgICBmdW5jdGlvbiBmaW5kTWlzc3lUYXJnZXQo'
      'KSB7CiAgICAgICAgICAgIGNvbnN0IG9ic3RhY2xlcyA9IFtdOwogICAgICAgICAgICAKICAgICAgICAgICAgLy8gRmluZCBh'
      'bGwgb2JzdGFjbGVzIG9uIHRoZSBib2FyZAogICAgICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCBHUklEX1NJWkU7'
      'IHJvdysrKSB7CiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBHUklEX1NJWkU7IGNvbCsrKSB7CiAg'
      'ICAgICAgICAgICAgICAgICAgY29uc3QgY2VsbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLXJvdz0iJHtyb3d9'
      'Il1bZGF0YS1jb2w9IiR7Y29sfSJdYCk7CiAgICAgICAgICAgICAgICAgICAgaWYgKGNlbGwgJiYgY2VsbC5kYXRhc2V0Lm9i'
      'c3RhY2xlID09PSAndHJ1ZScpIHsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaHAgPSBwYXJzZUludChjZWxsLmRh'
      'dGFzZXQuaHApIHx8IDA7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9ic3RhY2xlVHlwZSA9IGNlbGwuZGF0YXNl'
      'dC5vYnN0YWNsZVR5cGU7CiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGRpc3RhbmNlRnJvbUNlbnRlciA9IE1hdGgu'
      'YWJzKHJvdyAtIDMuNSkgKyBNYXRoLmFicyhjb2wgLSAzLjUpOwogICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAg'
      'ICAgICAgICAgICAgICAgb2JzdGFjbGVzLnB1c2goewogICAgICAgICAgICAgICAgICAgICAgICAgICAgcm93LCBjb2wsIGhw'
      'LCBvYnN0YWNsZVR5cGUsIGRpc3RhbmNlRnJvbUNlbnRlciwKICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW9yaXR5'
      'OiBnZXRPYnN0YWNsZVByaW9yaXR5KG9ic3RhY2xlVHlwZSkKICAgICAgICAgICAgICAgICAgICAgICAgfSk7CiAgICAgICAg'
      'ICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgICBp'
      'ZiAob2JzdGFjbGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7CiAgICAgICAgICAgIAogICAgICAgICAgICAvLyBTb3J0'
      'IGJ5IHByaW9yaXR5OiBibG9ja2luZyBtYXRjaGVzID4gaGlnaCBIUCA+IGNlbnRlciBwb3NpdGlvbgogICAgICAgICAgICBv'
      'YnN0YWNsZXMuc29ydCgoYSwgYikgPT4gewogICAgICAgICAgICAgICAgLy8gRmlyc3Q6IG9ic3RhY2xlcyBibG9ja2luZyBw'
      'b3RlbnRpYWwgbWF0Y2hlcwogICAgICAgICAgICAgICAgY29uc3QgYUJsb2NraW5nID0gaXNCbG9ja2luZ01hdGNoKGEucm93'
      'LCBhLmNvbCk7CiAgICAgICAgICAgICAgICBjb25zdCBiQmxvY2tpbmcgPSBpc0Jsb2NraW5nTWF0Y2goYi5yb3csIGIuY29s'
      'KTsKICAgICAgICAgICAgICAgIGlmIChhQmxvY2tpbmcgIT09IGJCbG9ja2luZykgcmV0dXJuIGJCbG9ja2luZyAtIGFCbG9j'
      'a2luZzsKICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgLy8gU2Vjb25kOiBoaWdoZXIgcHJpb3JpdHkgb2JzdGFj'
      'bGUgdHlwZXMKICAgICAgICAgICAgICAgIGlmIChhLnByaW9yaXR5ICE9PSBiLnByaW9yaXR5KSByZXR1cm4gYi5wcmlvcml0'
      'eSAtIGEucHJpb3JpdHk7CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIC8vIFRoaXJkOiBjbG9zZXIgdG8gY2Vu'
      'dGVyCiAgICAgICAgICAgICAgICByZXR1cm4gYS5kaXN0YW5jZUZyb21DZW50ZXIgLSBiLmRpc3RhbmNlRnJvbUNlbnRlcjsK'
      'ICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIAogICAgICAgICAgICByZXR1cm4gb2JzdGFjbGVzWzBdOwogICAgICAgIH0K'
      'CiAgICAgICAgZnVuY3Rpb24gZ2V0T2JzdGFjbGVQcmlvcml0eShvYnN0YWNsZVR5cGUpIHsKICAgICAgICAgICAgY29uc3Qg'
      'cHJpb3JpdGllcyA9IHsKICAgICAgICAgICAgICAgICdDQUtFX0hQJzogNCwKICAgICAgICAgICAgICAgICdDSE9DT0xBVEVf'
      'SFAnOiAzLAogICAgICAgICAgICAgICAgJ0NBTkRZX0hQJzogMiwKICAgICAgICAgICAgICAgICdET05VVF9IUCc6IDEKICAg'
      'ICAgICAgICAgfTsKICAgICAgICAgICAgcmV0dXJuIHByaW9yaXRpZXNbb2JzdGFjbGVUeXBlXSB8fCAwOwogICAgICAgIH0K'
      'CiAgICAgICAgZnVuY3Rpb24gaXNCbG9ja2luZ01hdGNoKHJvdywgY29sKSB7CiAgICAgICAgICAgIC8vIENoZWNrIGlmIG9i'
      'c3RhY2xlIGlzIGluIGEgcG9zaXRpb24gdGhhdCBjb3VsZCBibG9jayBtYXRjaGVzCiAgICAgICAgICAgIC8vIFNpbXBsZSBo'
      'ZXVyaXN0aWM6IGNoZWNrIGlmIHJlbW92aW5nIHRoaXMgb2JzdGFjbGUgd291bGQgY3JlYXRlIGEgbWF0Y2gKICAgICAgICAg'
      'ICAgY29uc3Qgb3JpZ2luYWxDYW5keSA9IGdhbWVTdGF0ZS5ncmlkW3Jvd11bY29sXTsKICAgICAgICAgICAgZ2FtZVN0YXRl'
      'LmdyaWRbcm93XVtjb2xdID0gbnVsbDsKICAgICAgICAgICAgCiAgICAgICAgICAgIC8vIENoZWNrIGZvciBwb3RlbnRpYWwg'
      'bWF0Y2hlcyBhcm91bmQgdGhpcyBwb3NpdGlvbgogICAgICAgICAgICBsZXQgaGFzUG90ZW50aWFsTWF0Y2ggPSBmYWxzZTsK'
      'ICAgICAgICAgICAgZm9yIChsZXQgciA9IE1hdGgubWF4KDAsIHJvdy0yKTsgciA8PSBNYXRoLm1pbihHUklEX1NJWkUtMSwg'
      'cm93KzIpOyByKyspIHsKICAgICAgICAgICAgICAgIGZvciAobGV0IGMgPSBNYXRoLm1heCgwLCBjb2wtMik7IGMgPD0gTWF0'
      'aC5taW4oR1JJRF9TSVpFLTEsIGNvbCsyKTsgYysrKSB7CiAgICAgICAgICAgICAgICAgICAgaWYgKGZpbmRNYXRjaGVzKHIs'
      'IGMpLmxlbmd0aCA+PSAzKSB7CiAgICAgICAgICAgICAgICAgICAgICAgIGhhc1BvdGVudGlhbE1hdGNoID0gdHJ1ZTsKICAg'
      'ICAgICAgICAgICAgICAgICAgICAgYnJlYWs7CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgfQogICAg'
      'ICAgICAgICAgICAgaWYgKGhhc1BvdGVudGlhbE1hdGNoKSBicmVhazsKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAg'
      'ICAgICAgICAgZ2FtZVN0YXRlLmdyaWRbcm93XVtjb2xdID0gb3JpZ2luYWxDYW5keTsKICAgICAgICAgICAgcmV0dXJuIGhh'
      'c1BvdGVudGlhbE1hdGNoOwogICAgICAgIH0KCiAgICAgICAgZnVuY3Rpb24gbW92ZU1pc3N5VG9UYXJnZXQodGFyZ2V0Um93'
      'LCB0YXJnZXRDb2wpIHsKICAgICAgICAgICAgY29uc3QgbWlzc3lIZWxwZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgn'
      'bWlzc3lIZWxwZXInKTsKICAgICAgICAgICAgY29uc3QgZ3JpZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdncmlkJyk7'
      'CiAgICAgICAgICAgIGlmICghbWlzc3lIZWxwZXIgfHwgIWdyaWQpIHJldHVybjsKICAgICAgICAgICAgY29uc3QgZ3JpZFJl'
      'Y3QgPSBncmlkLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpOwogICAgICAgICAgICAKICAgICAgICAgICAgLy8gQ2FsY3VsYXRl'
      'IHRhcmdldCBwb3NpdGlvbgogICAgICAgICAgICBjb25zdCBjZWxsU2l6ZSA9IGdyaWRSZWN0LndpZHRoIC8gR1JJRF9TSVpF'
      'OwogICAgICAgICAgICBjb25zdCB0YXJnZXRYID0gMjAgKyAodGFyZ2V0Q29sICogY2VsbFNpemUpICsgKGNlbGxTaXplIC8g'
      'Mik7CiAgICAgICAgICAgIGNvbnN0IHRhcmdldFkgPSAyMCArICh0YXJnZXRSb3cgKiBjZWxsU2l6ZSkgKyAoY2VsbFNpemUg'
      'LyAyKTsKICAgICAgICAgICAgCiAgICAgICAgICAgIC8vIFN0b3JlIGN1cnJlbnQgcG9zaXRpb24KICAgICAgICAgICAgZ2Ft'
      'ZVN0YXRlLm1pc3N5SGVscGVyLnBvc2l0aW9uLnggPSB0YXJnZXRYOwogICAgICAgICAgICBnYW1lU3RhdGUubWlzc3lIZWxw'
      'ZXIucG9zaXRpb24ueSA9IHRhcmdldFk7CiAgICAgICAgICAgIAogICAgICAgICAgICAvLyBBbmltYXRlIG1vdmVtZW50CiAg'
      'ICAgICAgICAgIG1pc3N5SGVscGVyLnN0eWxlLnRyYW5zaXRpb24gPSAnYWxsIDAuOHMgY3ViaWMtYmV6aWVyKDAuNCwgMCwg'
      'MC4yLCAxKSc7CiAgICAgICAgICAgIG1pc3N5SGVscGVyLnN0eWxlLmxlZnQgPSB0YXJnZXRYICsgJ3B4JzsKICAgICAgICAg'
      'ICAgbWlzc3lIZWxwZXIuc3R5bGUudG9wID0gdGFyZ2V0WSArICdweCc7CiAgICAgICAgICAgIG1pc3N5SGVscGVyLmNsYXNz'
      'TGlzdC5hZGQoJ21vdmluZycpOwogICAgICAgIH0KCiAgICAgICAgZnVuY3Rpb24gcmV0dXJuTWlzc3lUb0NlbnRlcigpIHsK'
      'ICAgICAgICAgICAgY29uc3QgbWlzc3lIZWxwZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWlzc3lIZWxwZXInKTsK'
      'ICAgICAgICAgICAgY29uc3QgZ3JpZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdncmlkJyk7CiAgICAgICAgICAgIGlm'
      'ICghbWlzc3lIZWxwZXIgfHwgIWdyaWQpIHJldHVybjsKICAgICAgICAgICAgY29uc3QgZ3JpZFJlY3QgPSBncmlkLmdldEJv'
      'dW5kaW5nQ2xpZW50UmVjdCgpOwogICAgICAgICAgICAKICAgICAgICAgICAgLy8gUmV0dXJuIHRvIGNlbnRlciBvZiBncmlk'
      'CiAgICAgICAgICAgIGNvbnN0IGNlbnRlclggPSBncmlkUmVjdC53aWR0aCAvIDIgKyAyMDsKICAgICAgICAgICAgY29uc3Qg'
      'Y2VudGVyWSA9IGdyaWRSZWN0LmhlaWdodCAvIDIgKyAyMDsKICAgICAgICAgICAgCiAgICAgICAgICAgIG1pc3N5SGVscGVy'
      'LnN0eWxlLnRyYW5zaXRpb24gPSAnYWxsIDFzIGN1YmljLWJlemllcigwLjQsIDAsIDAuMiwgMSknOwogICAgICAgICAgICBt'
      'aXNzeUhlbHBlci5zdHlsZS5sZWZ0ID0gY2VudGVyWCArICdweCc7CiAgICAgICAgICAgIG1pc3N5SGVscGVyLnN0eWxlLnRv'
      'cCA9IGNlbnRlclkgKyAncHgnOwogICAgICAgICAgICBnYW1lU3RhdGUubWlzc3lIZWxwZXIucG9zaXRpb24ueCA9IGNlbnRl'
      'clg7CiAgICAgICAgICAgIGdhbWVTdGF0ZS5taXNzeUhlbHBlci5wb3NpdGlvbi55ID0gY2VudGVyWTsKICAgICAgICAgICAg'
      'CiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4gewogICAgICAgICAgICAgICAgbWlzc3lIZWxwZXIuY2xhc3NMaXN0LnJl'
      'bW92ZSgnbW92aW5nJyk7CiAgICAgICAgICAgIH0sIDEwMDApOwogICAgICAgIH0KCiAgICAgICAgZnVuY3Rpb24gbWlzc3lB'
      'dXRvQXR0YWNrKCkgewogICAgICAgICAgICBpZiAoIWdhbWVTdGF0ZS5taXNzeUhlbHBlci5hY3RpdmUgfHwgZ2FtZVN0YXRl'
      'LmlzUHJvY2Vzc2luZykgcmV0dXJuOwogICAgICAgICAgICAKICAgICAgICAgICAgbGV0IHRhcmdldDsKICAgICAgICAgICAg'
      'CiAgICAgICAgICAgIC8vIFByaW9yaXR5IDE6IFNwZWNpZmljIGNsaWNrZWQgdGFyZ2V0CiAgICAgICAgICAgIGlmIChnYW1l'
      'U3RhdGUubWlzc3lIZWxwZXIuaGFzU3BlY2lmaWNUYXJnZXQpIHsKICAgICAgICAgICAgICAgIGNvbnN0IHt0YXJnZXRSb3cs'
      'IHRhcmdldENvbH0gPSBnYW1lU3RhdGUubWlzc3lIZWxwZXI7CiAgICAgICAgICAgICAgICBjb25zdCBjZWxsID0gZG9jdW1l'
      'bnQucXVlcnlTZWxlY3RvcihgW2RhdGEtcm93PSIke3RhcmdldFJvd30iXVtkYXRhLWNvbD0iJHt0YXJnZXRDb2x9Il1gKTsK'
      'ICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgaWYgKGNlbGwgJiYgY2VsbC5kYXRhc2V0Lm9ic3RhY2xlID09PSAn'
      'dHJ1ZScpIHsKICAgICAgICAgICAgICAgICAgICB0YXJnZXQgPSB7cm93OiB0YXJnZXRSb3csIGNvbDogdGFyZ2V0Q29sfTsK'
      'ICAgICAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgICAgICAgLy8gVGFyZ2V0IGRlc3Ryb3llZC9pbnZhbGlk'
      'LCBjbGVhciBhbmQgdXNlIEFJCiAgICAgICAgICAgICAgICAgICAgZ2FtZVN0YXRlLm1pc3N5SGVscGVyLmhhc1NwZWNpZmlj'
      'VGFyZ2V0ID0gZmFsc2U7CiAgICAgICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLm1pc3N5LXRh'
      'cmdldCcpLmZvckVhY2goZWwgPT4KICAgICAgICAgICAgICAgICAgICAgICAgZWwuY2xhc3NMaXN0LnJlbW92ZSgnbWlzc3kt'
      'dGFyZ2V0JykpOwogICAgICAgICAgICAgICAgICAgIHRhcmdldCA9IGZpbmRNaXNzeVRhcmdldCgpOwogICAgICAgICAgICAg'
      'ICAgfQogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgLy8gUHJpb3JpdHkgMjogU21hcnQgQUkgdGFyZ2V0'
      'aW5nCiAgICAgICAgICAgICAgICB0YXJnZXQgPSBmaW5kTWlzc3lUYXJnZXQoKTsKICAgICAgICAgICAgfQogICAgICAgICAg'
      'ICAKICAgICAgICAgICAgaWYgKCF0YXJnZXQpIHJldHVybjsKICAgICAgICAgICAgCiAgICAgICAgICAgIGNvbnN0IHtyb3cs'
      'IGNvbH0gPSB0YXJnZXQ7CiAgICAgICAgICAgIAogICAgICAgICAgICAvLyBNb3ZlIHRvIHRhcmdldAogICAgICAgICAgICBt'
      'b3ZlTWlzc3lUb1RhcmdldChyb3csIGNvbCk7CiAgICAgICAgICAgIAogICAgICAgICAgICAvLyBXYWl0IGZvciBtb3ZlbWVu'
      'dCwgdGhlbiBhdHRhY2sKICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7CiAgICAgICAgICAgICAgICBwZXJmb3JtTWlz'
      'c3lBdHRhY2socm93LCBjb2wsICgpID0+IHsKICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gc2hvcnRseSBhZnRlciBh'
      'dHRhY2sgcmVzb2x2ZXMKICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICAgICAgICAgICAg'
      'ICAgICAgcmV0dXJuTWlzc3lUb0NlbnRlcigpOwogICAgICAgICAgICAgICAgICAgIH0sIDIwMCk7CiAgICAgICAgICAgICAg'
      'ICB9KTsKICAgICAgICAgICAgfSwgNTAwKTsKICAgICAgICB9CgogICAgICAgIGZ1bmN0aW9uIHBlcmZvcm1NaXNzeUF0dGFj'
      'ayhyb3csIGNvbCwgb25Db21wbGV0ZSkgewogICAgICAgICAgICBjb25zdCBjZWxsID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rv'
      'cihgW2RhdGEtcm93PSIke3Jvd30iXVtkYXRhLWNvbD0iJHtjb2x9Il1gKTsKICAgICAgICAgICAgaWYgKCFjZWxsKSByZXR1'
      'cm47CiAgICAgICAgICAgIAogICAgICAgICAgICAvLyBBdHRhY2sgYW5pbWF0aW9uCiAgICAgICAgICAgIGNvbnN0IG1pc3N5'
      'SGVscGVyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21pc3N5SGVscGVyJyk7CiAgICAgICAgICAgIG1pc3N5SGVscGVy'
      'LmNsYXNzTGlzdC5hZGQoJ2F0dGFja2luZycpOwogICAgICAgICAgICAKICAgICAgICAgICAgLy8gRW5oYW5jZWQgYXR0YWNr'
      'IGVmZmVjdHMKICAgICAgICAgICAgY3JlYXRlQXR0YWNrQnVyc3QoY2VsbCk7CiAgICAgICAgICAgIGNyZWF0ZVNob2Nrd2F2'
      'ZShjZWxsKTsKICAgICAgICAgICAgCiAgICAgICAgICAgIC8vIFJlZHVjZSBIUAogICAgICAgICAgICBjb25zdCBjdXJyZW50'
      'SHAgPSBwYXJzZUludChjZWxsLmRhdGFzZXQuaHApIHx8IDA7CiAgICAgICAgICAgIGNvbnN0IG5ld0hwID0gTWF0aC5tYXgo'
      'MCwgY3VycmVudEhwIC0gMSk7CiAgICAgICAgICAgIGNlbGwuZGF0YXNldC5ocCA9IG5ld0hwOwogICAgICAgICAgICBnYW1l'
      'U3RhdGUub2JzdGFjbGVIZWFsdGhbYCR7cm93fSwke2NvbH1gXSA9IG5ld0hwOwogICAgICAgICAgICAKICAgICAgICAgICAg'
      'Ly8gVmlzdWFsIGZlZWRiYWNrCiAgICAgICAgICAgIGNlbGwuY2xhc3NMaXN0LmFkZCgnbWF0Y2hpbmcnLCAnbWlzc3ktYXR0'
      'YWNraW5nJyk7CiAgICAgICAgICAgIGNyZWF0ZVBhcnRpY2xlcyhjZWxsKTsKICAgICAgICAgICAgCiAgICAgICAgICAgIC8v'
      'IFVwZGF0ZSBIUCBkaXNwbGF5CiAgICAgICAgICAgIHVwZGF0ZU9ic3RhY2xlSHBEaXNwbGF5KHJvdywgY29sLCBuZXdIcCk7'
      'CiAgICAgICAgICAgIAogICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHsKICAgICAgICAgICAgICAgIG1pc3N5SGVscGVy'
      'LmNsYXNzTGlzdC5yZW1vdmUoJ2F0dGFja2luZycpOwogICAgICAgICAgICAgICAgY2VsbC5jbGFzc0xpc3QucmVtb3ZlKCdt'
      'aXNzeS1hdHRhY2tpbmcnKTsKICAgICAgICAgICAgICAgIGNlbGwuY2xhc3NMaXN0LnJlbW92ZSgnbWF0Y2hpbmcnKTsKICAg'
      'ICAgICAgICAgICAgIG9uQ29tcGxldGU/LigpOwogICAgICAgICAgICB9LCA1MDApOwogICAgICAgICAgICAKICAgICAgICAg'
      'ICAgaWYgKG5ld0hwIDw9IDApIHsKICAgICAgICAgICAgICAgIC8vIE9ic3RhY2xlIGRlc3Ryb3llZAogICAgICAgICAgICAg'
      'ICAgaGFuZGxlT2JzdGFjbGVEZXN0cnVjdGlvbihyb3csIGNvbCk7CiAgICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAg'
      'IGZ1bmN0aW9uIGhhbmRsZU9ic3RhY2xlRGVzdHJ1Y3Rpb24ocm93LCBjb2wsIHNvdXJjZSA9ICdtaXNzeScpIHsKICAgICAg'
      'ICAgICAgY29uc3QgY2VsbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLXJvdz0iJHtyb3d9Il1bZGF0YS1jb2w9'
      'IiR7Y29sfSJdYCk7CiAgICAgICAgICAgIGlmICghY2VsbCkgcmV0dXJuOwogICAgICAgICAgICAKICAgICAgICAgICAgLy8g'
      'VXBkYXRlIHRyYWNraW5nCiAgICAgICAgICAgIGlmIChzb3VyY2UgPT09ICdtaXNzeScgJiYgZ2FtZVN0YXRlLm1pc3N5SGVs'
      'cGVyLmFjdGl2ZSkgewogICAgICAgICAgICAgICAgZ2FtZVN0YXRlLm1pc3N5SGVscGVyLm9ic3RhY2xlc0Rlc3Ryb3llZCsr'
      'OwogICAgICAgICAgICAgICAgZ2FtZVN0YXRlLm1pc3N5SGVscGVyLm9ic3RhY2xlc1JlbWFpbmluZyA9IE1hdGgubWF4KDAs'
      'IGdhbWVTdGF0ZS5taXNzeUhlbHBlci5vYnN0YWNsZXNSZW1haW5pbmcgLSAxKTsKICAgICAgICAgICAgfQogICAgICAgICAg'
      'ICBnYW1lU3RhdGUub2JzdGFjbGVzQ2xlYXJlZCsrOwogICAgICAgICAgICB1cGRhdGVUYXJnZXREaXNwbGF5KCk7CiAgICAg'
      'ICAgICAgIAogICAgICAgICAgICAvLyBDbGVhciB0YXJnZXQgaWYgdGhpcyB3YXMgaXQKICAgICAgICAgICAgaWYgKGdhbWVT'
      'dGF0ZS5taXNzeUhlbHBlci5oYXNTcGVjaWZpY1RhcmdldCAmJgogICAgICAgICAgICAgICAgZ2FtZVN0YXRlLm1pc3N5SGVs'
      'cGVyLnRhcmdldFJvdyA9PT0gcm93ICYmCiAgICAgICAgICAgICAgICBnYW1lU3RhdGUubWlzc3lIZWxwZXIudGFyZ2V0Q29s'
      'ID09PSBjb2wpIHsKICAgICAgICAgICAgICAgIGdhbWVTdGF0ZS5taXNzeUhlbHBlci5oYXNTcGVjaWZpY1RhcmdldCA9IGZh'
      'bHNlOwogICAgICAgICAgICAgICAgZ2FtZVN0YXRlLm1pc3N5SGVscGVyLnRhcmdldFJvdyA9IG51bGw7CiAgICAgICAgICAg'
      'ICAgICBnYW1lU3RhdGUubWlzc3lIZWxwZXIudGFyZ2V0Q29sID0gbnVsbDsKICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1'
      'ZXJ5U2VsZWN0b3JBbGwoJy5taXNzeS10YXJnZXQnKS5mb3JFYWNoKGVsID0+CiAgICAgICAgICAgICAgICAgICAgZWwuY2xh'
      'c3NMaXN0LnJlbW92ZSgnbWlzc3ktdGFyZ2V0JykpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgICAv'
      'LyBBd2FyZCBwb2ludHMKICAgICAgICAgICAgY29uc3Qgb2JzdGFjbGVUeXBlID0gY2VsbC5kYXRhc2V0Lm9ic3RhY2xlVHlw'
      'ZTsKICAgICAgICAgICAgY29uc3QgcG9pbnRzID0gT0JTVEFDTEVTW29ic3RhY2xlVHlwZV0/LnBvaW50cyB8fCAxMDA7CiAg'
      'ICAgICAgICAgIGFkZFNjb3JlKHBvaW50cyk7CiAgICAgICAgICAgIAogICAgICAgICAgICAvLyBEZXN0cnVjdGlvbiBlZmZl'
      'Y3RzCiAgICAgICAgICAgIGNyZWF0ZUV4cGxvc2lvbkVmZmVjdChjZWxsKTsKICAgICAgICAgICAgaWYgKHNvdXJjZSA9PT0g'
      'J21pc3N5JyAmJiBnYW1lU3RhdGUubWlzc3lIZWxwZXIuYWN0aXZlKSB7CiAgICAgICAgICAgICAgICBzaG93Q29tYm8oYERl'
      'c3Ryb3llZCEgKCR7Z2FtZVN0YXRlLm1pc3N5SGVscGVyLm9ic3RhY2xlc1JlbWFpbmluZ30gbGVmdClgKTsKICAgICAgICAg'
      'ICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIHNob3dDb21ibygnT2JzdGFjbGUgRGVzdHJveWVkIScpOwogICAgICAgICAg'
      'ICB9CiAgICAgICAgICAgIAogICAgICAgICAgICAvLyBVcGRhdGUgVUkKICAgICAgICAgICAgdXBkYXRlTWlzc3lPYnN0YWNs'
      'ZXNEaXNwbGF5KCk7CiAgICAgICAgICAgIAogICAgICAgICAgICAvLyBSZW1vdmUgb2JzdGFjbGUKICAgICAgICAgICAgZ2Ft'
      'ZVN0YXRlLmdyaWRbcm93XVtjb2xdID0gbnVsbDsKICAgICAgICAgICAgZGVsZXRlIGdhbWVTdGF0ZS5vYnN0YWNsZUhlYWx0'
      'aFtgJHtyb3d9LCR7Y29sfWBdOwogICAgICAgICAgICBkZWxldGUgZ2FtZVN0YXRlLnNwZWNpYWxzW2Ake3Jvd30sJHtjb2x9'
      'YF07CiAgICAgICAgICAgIGNlbGwuZGF0YXNldC5vYnN0YWNsZSA9ICdmYWxzZSc7CiAgICAgICAgICAgIGNlbGwuZGF0YXNl'
      'dC5vYnN0YWNsZVR5cGUgPSAnJzsKICAgICAgICAgICAgY2VsbC5kYXRhc2V0LmhwID0gJzAnOwogICAgICAgICAgICBjZWxs'
      'LmRhdGFzZXQuY2FuZHkgPSAnJzsKICAgICAgICAgICAgY2VsbC50ZXh0Q29udGVudCA9ICcnOwogICAgICAgICAgICAKICAg'
      'ICAgICAgICAgLy8gQ2hlY2sgaWYgTWlzc3kgc2hvdWxkIGRlYWN0aXZhdGUKICAgICAgICAgICAgaWYgKHNvdXJjZSA9PT0g'
      'J21pc3N5JyAmJiBnYW1lU3RhdGUubWlzc3lIZWxwZXIuYWN0aXZlICYmIGdhbWVTdGF0ZS5taXNzeUhlbHBlci5vYnN0YWNs'
      'ZXNSZW1haW5pbmcgPD0gMCkgewogICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7CiAgICAgICAgICAgICAgICAg'
      'ICAgZGVhY3RpdmF0ZU1pc3N5SGVscGVyKCk7CiAgICAgICAgICAgICAgICB9LCAxNTAwKTsKICAgICAgICAgICAgfQogICAg'
      'ICAgICAgICAKICAgICAgICAgICAgLy8gVHJpZ2dlciBjYXNjYWRlCiAgICAgICAgICAgIHNldFRpbWVvdXQoYXN5bmMgKCkg'
      'PT4gewogICAgICAgICAgICAgICAgYXdhaXQgZHJvcENhbmRpZXMoKTsKICAgICAgICAgICAgICAgIGF3YWl0IGZpbGxFbXB0'
      'eSgpOwogICAgICAgICAgICAgICAgYXdhaXQgcHJvY2Vzc01hdGNoZXMoKTsKICAgICAgICAgICAgfSwgNTAwKTsKICAgICAg'
      'ICB9CgogICAgICAgIGZ1bmN0aW9uIHVwZGF0ZU9ic3RhY2xlSHBEaXNwbGF5KHJvdywgY29sLCBocCkgewogICAgICAgICAg'
      'ICBjb25zdCBjZWxsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtcm93PSIke3Jvd30iXVtkYXRhLWNvbD0iJHtj'
      'b2x9Il1gKTsKICAgICAgICAgICAgaWYgKCFjZWxsKSByZXR1cm47CiAgICAgICAgICAgIAogICAgICAgICAgICAvLyBSZW1v'
      'dmUgZXhpc3RpbmcgSFAgYmFkZ2UKICAgICAgICAgICAgY29uc3QgZXhpc3RpbmdCYWRnZSA9IGNlbGwucXVlcnlTZWxlY3Rv'
      'cignLm9ic3RhY2xlLWhwLWJhZGdlJyk7CiAgICAgICAgICAgIGlmIChleGlzdGluZ0JhZGdlKSBleGlzdGluZ0JhZGdlLnJl'
      'bW92ZSgpOwogICAgICAgICAgICAKICAgICAgICAgICAgaWYgKGhwID4gMCkgewogICAgICAgICAgICAgICAgLy8gQWRkIG5l'
      'dyBIUCBiYWRnZQogICAgICAgICAgICAgICAgY29uc3QgYmFkZ2UgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTsK'
      'ICAgICAgICAgICAgICAgIGJhZGdlLmNsYXNzTmFtZSA9ICdvYnN0YWNsZS1ocC1iYWRnZSc7CiAgICAgICAgICAgICAgICBi'
      'YWRnZS50ZXh0Q29udGVudCA9IGhwOwogICAgICAgICAgICAgICAgY2VsbC5hcHBlbmRDaGlsZChiYWRnZSk7CiAgICAgICAg'
      'ICAgIH0KICAgICAgICB9CgogICAgICAgIC8vIENoZWNrIGxldmVsIGNvbXBsZXRlCiAgICAgICAgZnVuY3Rpb24gY2hlY2tM'
      'ZXZlbENvbXBsZXRlKCkgewogICAgICAgICAgICB1cGRhdGVUYXJnZXREaXNwbGF5KCk7CiAgICAgICAgICAgIGNvbnN0IGxl'
      'dmVsRGF0YSA9IGdhbWVTdGF0ZS5sZXZlbHNbZ2FtZVN0YXRlLmN1cnJlbnRMZXZlbCAtIDFdOwogICAgICAgICAgICBjb25z'
      'dCBvYmogPSBsZXZlbERhdGEub2JqZWN0aXZlOwogICAgICAgICAgICBsZXQgY29tcGxldGVkID0gZmFsc2U7CiAgICAgICAg'
      'ICAgIGxldCBzdGFycyA9IDA7CiAgICAgICAgICAgIGxldCBwcm9ncmVzc1ZhbHVlID0gMDsKICAgICAgICAgICAgbGV0IHRh'
      'cmdldFZhbHVlID0gMDsKICAgICAgICAgICAgCiAgICAgICAgICAgIGlmIChvYmoudHlwZSA9PT0gJ3Njb3JlJykgewogICAg'
      'ICAgICAgICAgICAgcHJvZ3Jlc3NWYWx1ZSA9IGdhbWVTdGF0ZS5zY29yZTsKICAgICAgICAgICAgICAgIHRhcmdldFZhbHVl'
      'ID0gb2JqLnRhcmdldDsKICAgICAgICAgICAgfSBlbHNlIGlmIChvYmoudHlwZSA9PT0gJ2NvbGxlY3QnKSB7CiAgICAgICAg'
      'ICAgICAgICBwcm9ncmVzc1ZhbHVlID0gZ2FtZVN0YXRlLmNvbGxlY3RQcm9ncmVzc1tvYmoudGFyZ2V0LmNhbmR5XSB8fCAw'
      'OwogICAgICAgICAgICAgICAgdGFyZ2V0VmFsdWUgPSBvYmoudGFyZ2V0LmFtb3VudDsKICAgICAgICAgICAgfSBlbHNlIGlm'
      'IChvYmoudHlwZSA9PT0gJ2NsZWFyJykgewogICAgICAgICAgICAgICAgcHJvZ3Jlc3NWYWx1ZSA9IGdhbWVTdGF0ZS5vYnN0'
      'YWNsZXNDbGVhcmVkOwogICAgICAgICAgICAgICAgdGFyZ2V0VmFsdWUgPSBvYmoudGFyZ2V0OwogICAgICAgICAgICB9IGVs'
      'c2UgaWYgKG9iai50eXBlID09PSAnY29tYm8nKSB7CiAgICAgICAgICAgICAgICBwcm9ncmVzc1ZhbHVlID0gZ2FtZVN0YXRl'
      'Lm1heENvbWJvOwogICAgICAgICAgICAgICAgdGFyZ2V0VmFsdWUgPSBvYmoudGFyZ2V0OwogICAgICAgICAgICB9CiAgICAg'
      'ICAgICAgIAogICAgICAgICAgICBpZiAodGFyZ2V0VmFsdWUgPiAwICYmIHByb2dyZXNzVmFsdWUgPj0gdGFyZ2V0VmFsdWUp'
      'IHsKICAgICAgICAgICAgICAgIGNvbXBsZXRlZCA9IHRydWU7CiAgICAgICAgICAgICAgICBjb25zdCByYXRpbyA9IHByb2dy'
      'ZXNzVmFsdWUgLyB0YXJnZXRWYWx1ZTsKICAgICAgICAgICAgICAgIGlmIChyYXRpbyA+PSAxLjUpIHN0YXJzID0gMzsKICAg'
      'ICAgICAgICAgICAgIGVsc2UgaWYgKHJhdGlvID49IDEuMikgc3RhcnMgPSAyOwogICAgICAgICAgICAgICAgZWxzZSBzdGFy'
      'cyA9IDE7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgCiAgICAgICAgICAgIGlmIChnYW1lU3RhdGUubW92ZXMgPD0gMCAm'
      'JiAhY29tcGxldGVkKSB7CiAgICAgICAgICAgICAgICBzaG93RGVmZWF0KCk7CiAgICAgICAgICAgIH0gZWxzZSBpZiAoY29t'
      'cGxldGVkKSB7CiAgICAgICAgICAgICAgICBzdGFycyA9IE1hdGgubWF4KHN0YXJzLCAxKTsKICAgICAgICAgICAgICAgIHNo'
      'b3dWaWN0b3J5KHN0YXJzKTsKICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgZnVuY3Rpb24gc2hvd1ZpY3Rvcnko'
      'c3RhcnMpIHsKICAgICAgICAgICAgLy8gVXBkYXRlIGxldmVsIGRhdGEKICAgICAgICAgICAgY29uc3QgbGV2ZWxEYXRhID0g'
      'Z2FtZVN0YXRlLmxldmVsc1tnYW1lU3RhdGUuY3VycmVudExldmVsIC0gMV07CiAgICAgICAgICAgIGxldmVsRGF0YS5jb21w'
      'bGV0ZWQgPSB0cnVlOwogICAgICAgICAgICBsZXZlbERhdGEuc3RhcnMgPSBNYXRoLm1heChsZXZlbERhdGEuc3RhcnMsIHN0'
      'YXJzKTsKICAgICAgICAgICAgCiAgICAgICAgICAgIC8vIFVubG9jayBuZXh0IGxldmVsCiAgICAgICAgICAgIGlmIChnYW1l'
      'U3RhdGUuY3VycmVudExldmVsIDwgMTIwKSB7CiAgICAgICAgICAgICAgICBnYW1lU3RhdGUubGV2ZWxzW2dhbWVTdGF0ZS5j'
      'dXJyZW50TGV2ZWxdLnVubG9ja2VkID0gdHJ1ZTsKICAgICAgICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgLy8g'
      'VXBkYXRlIHByb2dyZXNzCiAgICAgICAgICAgIGdhbWVTdGF0ZS5wcm9ncmVzcy5zdGFycyArPSBzdGFyczsKICAgICAgICAg'
      'ICAgZ2FtZVN0YXRlLm1pc3N5UG93ZXIgPSBNYXRoLm1pbig1LCBnYW1lU3RhdGUubWlzc3lQb3dlciArIDEpOwogICAgICAg'
      'ICAgICBnYW1lU3RhdGUubWlzc3lIZWxwZXIuY2hhcmdlcyA9IE1hdGgubWluKDUsIGdhbWVTdGF0ZS5taXNzeUhlbHBlci5j'
      'aGFyZ2VzICsgMSk7CiAgICAgICAgICAgIAogICAgICAgICAgICAvLyBTaG93IHZpY3Rvcnkgc2NyZWVuCiAgICAgICAgICAg'
      'IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdmaW5hbFNjb3JlJykudGV4dENvbnRlbnQgPSBnYW1lU3RhdGUuc2NvcmU7CiAg'
      'ICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdzdGFyc0Vhcm5lZCcpLnRleHRDb250ZW50ID0gJ+KtkCcucmVw'
      'ZWF0KHN0YXJzKTsKICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3ZpY3RvcnlTY3JlZW4nKS5zdHlsZS5k'
      'aXNwbGF5ID0gJ2ZsZXgnOwogICAgICAgICAgICAKICAgICAgICAgICAgc2F2ZVByb2dyZXNzKCk7CiAgICAgICAgfQoKICAg'
      'ICAgICBmdW5jdGlvbiBzaG93RGVmZWF0KCkgewogICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnZmFpbFNj'
      'b3JlJykudGV4dENvbnRlbnQgPSBnYW1lU3RhdGUuc2NvcmU7CiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlk'
      'KCdkZWZlYXRTY3JlZW4nKS5zdHlsZS5kaXNwbGF5ID0gJ2ZsZXgnOwogICAgICAgIH0KCiAgICAgICAgZnVuY3Rpb24gbmV4'
      'dExldmVsKCkgewogICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndmljdG9yeVNjcmVlbicpLnN0eWxlLmRp'
      'c3BsYXkgPSAnbm9uZSc7CiAgICAgICAgICAgIGlmIChnYW1lU3RhdGUuY3VycmVudExldmVsIDwgMTIwKSB7CiAgICAgICAg'
      'ICAgICAgICBpbml0R2FtZShnYW1lU3RhdGUuY3VycmVudExldmVsICsgMSk7CiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAg'
      'ICAgICAgICAgICBiYWNrVG9NZW51KCk7CiAgICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIGZ1bmN0aW9uIHJldHJ5'
      'TGV2ZWwoKSB7CiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd2aWN0b3J5U2NyZWVuJykuc3R5bGUuZGlz'
      'cGxheSA9ICdub25lJzsKICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2RlZmVhdFNjcmVlbicpLnN0eWxl'
      'LmRpc3BsYXkgPSAnbm9uZSc7CiAgICAgICAgICAgIGRlYWN0aXZhdGVNaXNzeUhlbHBlcigpOyAvLyBEZWFjdGl2YXRlIGhl'
      'bHBlciBvbiByZXRyeQogICAgICAgICAgICBpbml0R2FtZShnYW1lU3RhdGUuY3VycmVudExldmVsKTsKICAgICAgICB9Cgog'
      'ICAgICAgIGZ1bmN0aW9uIGJhY2tUb01lbnUoKSB7CiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd2aWN0'
      'b3J5U2NyZWVuJykuc3R5bGUuZGlzcGxheSA9ICdub25lJzsKICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQo'
      'J2RlZmVhdFNjcmVlbicpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7CiAgICAgICAgICAgIGRlYWN0aXZhdGVNaXNzeUhlbHBl'
      'cigpOyAvLyBEZWFjdGl2YXRlIGhlbHBlciB3aGVuIHJldHVybmluZyB0byBtZW51CiAgICAgICAgICAgIHNob3dMZXZlbFNl'
      'bGVjdCgpOwogICAgICAgIH0KCiAgICAgICAgLy8gTGV2ZWwgU2VsZWN0CiAgICAgICAgZnVuY3Rpb24gc2hvd0xldmVsU2Vs'
      'ZWN0KCkgewogICAgICAgICAgICBjb25zdCBncmlkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xldmVsR3JpZCcpOwog'
      'ICAgICAgICAgICBncmlkLmlubmVySFRNTCA9ICcnOwogICAgICAgICAgICAKICAgICAgICAgICAgZ2FtZVN0YXRlLmxldmVs'
      'cy5mb3JFYWNoKGxldmVsID0+IHsKICAgICAgICAgICAgICAgIGNvbnN0IGJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQo'
      'J2RpdicpOwogICAgICAgICAgICAgICAgYnRuLmNsYXNzTmFtZSA9ICdsZXZlbC1idG4nOwogICAgICAgICAgICAgICAgaWYg'
      'KCFsZXZlbC51bmxvY2tlZCkgYnRuLmNsYXNzTGlzdC5hZGQoJ2xvY2tlZCcpOwogICAgICAgICAgICAgICAgaWYgKGxldmVs'
      'LmNvbXBsZXRlZCkgYnRuLmNsYXNzTGlzdC5hZGQoJ2NvbXBsZXRlZCcpOwogICAgICAgICAgICAgICAgCiAgICAgICAgICAg'
      'ICAgICBidG4udGV4dENvbnRlbnQgPSBsZXZlbC5udW1iZXI7CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIGlm'
      'IChsZXZlbC5jb21wbGV0ZWQpIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBzdGFycyA9IGRvY3VtZW50LmNyZWF0ZUVs'
      'ZW1lbnQoJ2RpdicpOwogICAgICAgICAgICAgICAgICAgIHN0YXJzLmNsYXNzTmFtZSA9ICdzdGFycyc7CiAgICAgICAgICAg'
      'ICAgICAgICAgc3RhcnMuaW5uZXJIVE1MID0gJ+KtkCcucmVwZWF0KGxldmVsLnN0YXJzKTsKICAgICAgICAgICAgICAgICAg'
      'ICBidG4uYXBwZW5kQ2hpbGQoc3RhcnMpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAgICAgCiAgICAgICAgICAg'
      'ICAgICBpZiAobGV2ZWwudW5sb2NrZWQpIHsKICAgICAgICAgICAgICAgICAgICBidG4ub25jbGljayA9ICgpID0+IGluaXRH'
      'YW1lKGxldmVsLm51bWJlcik7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgICAgIGJ0bi5pbm5l'
      'ckhUTUwgKz0gJzxkaXYgc3R5bGU9ImZvbnQtc2l6ZTogMTZweDsgbWFyZ2luLXRvcDogNXB4OyI+8J+UkjwvZGl2Pic7CiAg'
      'ICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgIGdyaWQuYXBwZW5kQ2hpbGQoYnRuKTsK'
      'ICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIAogICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbGV2ZWxT'
      'ZWxlY3QnKS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJzsKICAgICAgICB9CgogICAgICAgIC8vIEJvb3N0ZXJzCiAgICAgICAg'
      'ZnVuY3Rpb24gdXNlQm9vc3Rlcih0eXBlKSB7CiAgICAgICAgICAgIGlmIChnYW1lU3RhdGUuaXNQcm9jZXNzaW5nKSB7CiAg'
      'ICAgICAgICAgICAgICBhbGVydCgnUGxlYXNlIHdhaXQgZm9yIHRoZSBjdXJyZW50IGFjdGlvbiB0byBmaW5pc2ghJyk7CiAg'
      'ICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIH0KICAgICAgICAgICAgCiAgICAgICAgICAgIGlmIChbJ2hhbW1l'
      'cicsICdib21iJywgJ3N3YXAnXS5pbmNsdWRlcyh0eXBlKSkgewogICAgICAgICAgICAgICAgaWYgKGdhbWVTdGF0ZS5ib29z'
      'dGVyc1t0eXBlXSA8PSAwKSB7CiAgICAgICAgICAgICAgICAgICAgYWxlcnQoJ05vIG1vcmUgJyArIHR5cGUgKyAnIGJvb3N0'
      'ZXJzIScpOwogICAgICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIAog'
      'ICAgICAgICAgICAgICAgaWYgKGdhbWVTdGF0ZS5zZWxlY3RlZENlbGwpIHsKICAgICAgICAgICAgICAgICAgICBjb25zdCBw'
      'cmV2ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtcm93PSIke2dhbWVTdGF0ZS5zZWxlY3RlZENlbGwucm93fSJd'
      'W2RhdGEtY29sPSIke2dhbWVTdGF0ZS5zZWxlY3RlZENlbGwuY29sfSJdYCk7CiAgICAgICAgICAgICAgICAgICAgcHJldj8u'
      'Y2xhc3NMaXN0LnJlbW92ZSgnc2VsZWN0ZWQnKTsKICAgICAgICAgICAgICAgICAgICBnYW1lU3RhdGUuc2VsZWN0ZWRDZWxs'
      'ID0gbnVsbDsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgY2xlYXJBY3RpdmVC'
      'b29zdGVyKCk7CiAgICAgICAgICAgICAgICBnYW1lU3RhdGUuYWN0aXZlQm9vc3RlciA9IHR5cGU7CiAgICAgICAgICAgICAg'
      'ICAKICAgICAgICAgICAgICAgIGlmICh0eXBlID09PSAnaGFtbWVyJykgewogICAgICAgICAgICAgICAgICAgIGRvY3VtZW50'
      'LmJvZHkuY2xhc3NMaXN0LmFkZCgnaGFtbWVyLWFjdGl2ZScpOwogICAgICAgICAgICAgICAgICAgIHNob3dDb21ibygnQ2xp'
      'Y2sgdG8gc21hc2ghJyk7CiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdib21iJykgewogICAgICAgICAg'
      'ICAgICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgnYm9tYi1hY3RpdmUnKTsKICAgICAgICAgICAgICAgICAg'
      'ICBzaG93Q29tYm8oJ1BsYWNlIHRoZSBib21iIScpOwogICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnc3dh'
      'cCcpIHsKICAgICAgICAgICAgICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ3N3YXAtYWN0aXZlJyk7CiAg'
      'ICAgICAgICAgICAgICAgICAgZ2FtZVN0YXRlLmJvb3N0ZXJUYXJnZXRzID0gW107CiAgICAgICAgICAgICAgICAgICAgc2hv'
      'd0NvbWJvKCdTZWxlY3QgdHdvIGNhbmRpZXMhJyk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAKICAgICAg'
      'ICAgICAgICAgIGNsb3NlU2tpbGxzTWVudSgpOwogICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAg'
      'ICAgICAgIAogICAgICAgICAgICBpZiAodHlwZSA9PT0gJ3JhaW5ib3cnKSB7CiAgICAgICAgICAgICAgICBpZiAoZ2FtZVN0'
      'YXRlLmJvb3N0ZXJzLnJhaW5ib3cgPD0gMCkgewogICAgICAgICAgICAgICAgICAgIGFsZXJ0KCdObyBtb3JlIHJhaW5ib3cg'
      'Ym9vc3RlcnMhJyk7CiAgICAgICAgICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICAg'
      'ICAgZ2FtZVN0YXRlLmJvb3N0ZXJzLnJhaW5ib3ctLTsKICAgICAgICAgICAgICAgIHVwZGF0ZUJvb3N0ZXJDb3VudHMoKTsK'
      'ICAgICAgICAgICAgICAgIGNvbnN1bWVNb3ZlKCk7CiAgICAgICAgICAgICAgICBjb25zdCByYW5kb21DYW5keSA9IENBTkRZ'
      'X1RZUEVTW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIENBTkRZX1RZUEVTLmxlbmd0aCldOwogICAgICAgICAgICAgICAg'
      'Y2xlYXJDb2xvclR5cGUocmFuZG9tQ2FuZHkpOwogICAgICAgICAgICAgICAgc2F2ZVByb2dyZXNzKCk7CiAgICAgICAgICAg'
      'ICAgICByZXR1cm47CiAgICAgICAgICAgIH0KICAgICAgICAgICAgCiAgICAgICAgICAgIGlmICh0eXBlID09PSAnc2h1ZmZs'
      'ZScpIHsKICAgICAgICAgICAgICAgIGlmIChnYW1lU3RhdGUuYm9vc3RlcnMuc2h1ZmZsZSA8PSAwKSB7CiAgICAgICAgICAg'
      'ICAgICAgICAgYWxlcnQoJ05vIG1vcmUgc2h1ZmZsZSBib29zdGVycyEnKTsKICAgICAgICAgICAgICAgICAgICByZXR1cm47'
      'CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICBnYW1lU3RhdGUuYm9vc3RlcnMuc2h1ZmZsZS0tOwogICAgICAg'
      'ICAgICAgICAgdXBkYXRlQm9vc3RlckNvdW50cygpOwogICAgICAgICAgICAgICAgY29uc3VtZU1vdmUoKTsKICAgICAgICAg'
      'ICAgICAgIHNodWZmbGVHcmlkKCk7CiAgICAgICAgICAgICAgICBzYXZlUHJvZ3Jlc3MoKTsKICAgICAgICAgICAgICAgIHJl'
      'dHVybjsKICAgICAgICAgICAgfQogICAgICAgIH0KCiAgICAgICAgZnVuY3Rpb24gY2xlYXJBY3RpdmVCb29zdGVyKCkgewog'
      'ICAgICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ2hhbW1lci1hY3RpdmUnLCAnYm9tYi1hY3RpdmUn'
      'LCAnc3dhcC1hY3RpdmUnKTsKICAgICAgICAgICAgZ2FtZVN0YXRlLmFjdGl2ZUJvb3N0ZXIgPSBudWxsOwogICAgICAgICAg'
      'ICBnYW1lU3RhdGUuYm9vc3RlclRhcmdldHMgPSBbXTsKICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgn'
      'LmJvb3N0ZXItc2VsZWN0aW9uJykuZm9yRWFjaChlbCA9PiBlbC5jbGFzc0xpc3QucmVtb3ZlKCdib29zdGVyLXNlbGVjdGlv'
      'bicpKTsKICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmJvbWItcHJldmlldycpLmZvckVhY2goZWwg'
      'PT4gZWwuY2xhc3NMaXN0LnJlbW92ZSgnYm9tYi1wcmV2aWV3JykpOwogICAgICAgIH0KCiAgICAgICAgZnVuY3Rpb24gY29u'
      'c3VtZU1vdmUoKSB7CiAgICAgICAgICAgIGdhbWVTdGF0ZS5tb3ZlcyA9IE1hdGgubWF4KDAsIGdhbWVTdGF0ZS5tb3ZlcyAt'
      'IDEpOwogICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW92ZXNEaXNwbGF5JykudGV4dENvbnRlbnQgPSBg'
      'JHtnYW1lU3RhdGUubW92ZXN9IG1vdmVzYDsKICAgICAgICB9CgogICAgICAgIGFzeW5jIGZ1bmN0aW9uIGFwcGx5SGFtbWVy'
      'KHJvdywgY29sKSB7CiAgICAgICAgICAgIGlmIChnYW1lU3RhdGUuYWN0aXZlQm9vc3RlciAhPT0gJ2hhbW1lcicgfHwgZ2Ft'
      'ZVN0YXRlLmlzUHJvY2Vzc2luZykgcmV0dXJuOwogICAgICAgICAgICBjb25zdCBjZWxsID0gZG9jdW1lbnQucXVlcnlTZWxl'
      'Y3RvcihgW2RhdGEtcm93PSIke3Jvd30iXVtkYXRhLWNvbD0iJHtjb2x9Il1gKTsKICAgICAgICAgICAgaWYgKCFjZWxsKSBy'
      'ZXR1cm47CiAgICAgICAgICAgIAogICAgICAgICAgICBnYW1lU3RhdGUuaXNQcm9jZXNzaW5nID0gdHJ1ZTsKICAgICAgICAg'
      'ICAgZ2FtZVN0YXRlLmJvb3N0ZXJzLmhhbW1lci0tOwogICAgICAgICAgICB1cGRhdGVCb29zdGVyQ291bnRzKCk7CiAgICAg'
      'ICAgICAgIGNvbnN1bWVNb3ZlKCk7CiAgICAgICAgICAgIHNob3dDb21ibygnSGFtbWVyIFNtYXNoIScpOwogICAgICAgICAg'
      'ICAKICAgICAgICAgICAgY29uc3Qga2V5ID0gY2VsbEtleShyb3csIGNvbCk7CiAgICAgICAgICAgIGNvbnN0IGlzT2JzdGFj'
      'bGUgPSBjZWxsLmRhdGFzZXQub2JzdGFjbGUgPT09ICd0cnVlJzsKICAgICAgICAgICAgCiAgICAgICAgICAgIGNyZWF0ZUV4'
      'cGxvc2lvbkVmZmVjdChjZWxsKTsKICAgICAgICAgICAgY2VsbC5jbGFzc0xpc3QuYWRkKCdleHBsb2RpbmcnKTsKICAgICAg'
      'ICAgICAgCiAgICAgICAgICAgIGlmIChpc09ic3RhY2xlKSB7CiAgICAgICAgICAgICAgICBoYW5kbGVPYnN0YWNsZURlc3Ry'
      'dWN0aW9uKHJvdywgY29sLCAnYm9vc3RlcicpOwogICAgICAgICAgICAgICAgYXdhaXQgZGVsYXkoODAwKTsKICAgICAgICAg'
      'ICAgfSBlbHNlIHsKICAgICAgICAgICAgICAgIGdhbWVTdGF0ZS5ncmlkW3Jvd11bY29sXSA9IG51bGw7CiAgICAgICAgICAg'
      'ICAgICBkZWxldGUgZ2FtZVN0YXRlLnNwZWNpYWxzW2tleV07CiAgICAgICAgICAgICAgICBkZWxldGUgZ2FtZVN0YXRlLm9i'
      'c3RhY2xlSGVhbHRoW2tleV07CiAgICAgICAgICAgICAgICBjZWxsLmRhdGFzZXQub2JzdGFjbGUgPSAnZmFsc2UnOwogICAg'
      'ICAgICAgICAgICAgY2VsbC5kYXRhc2V0Lm9ic3RhY2xlVHlwZSA9ICcnOwogICAgICAgICAgICAgICAgY2VsbC5kYXRhc2V0'
      'LmhwID0gJzAnOwogICAgICAgICAgICAgICAgdXBkYXRlQ2VsbERpc3BsYXkocm93LCBjb2wpOwogICAgICAgICAgICAgICAg'
      'CiAgICAgICAgICAgICAgICBhd2FpdCBkcm9wQ2FuZGllcygpOwogICAgICAgICAgICAgICAgYXdhaXQgZmlsbEVtcHR5KCk7'
      'CiAgICAgICAgICAgICAgICBhd2FpdCBwcm9jZXNzTWF0Y2hlcygpOwogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAg'
      'ICAgICAgICBjZWxsLmNsYXNzTGlzdC5yZW1vdmUoJ2V4cGxvZGluZycpOwogICAgICAgICAgICBjbGVhckFjdGl2ZUJvb3N0'
      'ZXIoKTsKICAgICAgICAgICAgZ2FtZVN0YXRlLmlzUHJvY2Vzc2luZyA9IGZhbHNlOwogICAgICAgICAgICB1cGRhdGVUYXJn'
      'ZXREaXNwbGF5KCk7CiAgICAgICAgICAgIGNoZWNrTGV2ZWxDb21wbGV0ZSgpOwogICAgICAgICAgICBzYXZlUHJvZ3Jlc3Mo'
      'KTsKICAgICAgICB9CgogICAgICAgIGFzeW5jIGZ1bmN0aW9uIHBsYWNlQm9tYihyb3csIGNvbCkgewogICAgICAgICAgICBp'
      'ZiAoZ2FtZVN0YXRlLmFjdGl2ZUJvb3N0ZXIgIT09ICdib21iJyB8fCBnYW1lU3RhdGUuaXNQcm9jZXNzaW5nKSByZXR1cm47'
      'CiAgICAgICAgICAgIAogICAgICAgICAgICBnYW1lU3RhdGUuaXNQcm9jZXNzaW5nID0gdHJ1ZTsKICAgICAgICAgICAgZ2Ft'
      'ZVN0YXRlLmJvb3N0ZXJzLmJvbWItLTsKICAgICAgICAgICAgdXBkYXRlQm9vc3RlckNvdW50cygpOwogICAgICAgICAgICBj'
      'b25zdW1lTW92ZSgpOwogICAgICAgICAgICAKICAgICAgICAgICAgY29uc3QgYWZmZWN0ZWQgPSBbXTsKICAgICAgICAgICAg'
      'Zm9yIChsZXQgciA9IHJvdyAtIDE7IHIgPD0gcm93ICsgMTsgcisrKSB7CiAgICAgICAgICAgICAgICBmb3IgKGxldCBjID0g'
      'Y29sIC0gMTsgYyA8PSBjb2wgKyAxOyBjKyspIHsKICAgICAgICAgICAgICAgICAgICBpZiAociA+PSAwICYmIHIgPCBHUklE'
      'X1NJWkUgJiYgYyA+PSAwICYmIGMgPCBHUklEX1NJWkUpIHsKICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2VsbCA9'
      'IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLXJvdz0iJHtyfSJdW2RhdGEtY29sPSIke2N9Il1gKTsKICAgICAgICAg'
      'ICAgICAgICAgICAgICAgaWYgKGNlbGwpIHsKICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNlbGwuY2xhc3NMaXN0LmFk'
      'ZCgnYm9tYi1wcmV2aWV3Jyk7CiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZmZlY3RlZC5wdXNoKHtyb3c6IHIsIGNv'
      'bDogYywgY2VsbH0pOwogICAgICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgICAgICAgICAgfQogICAgICAgICAg'
      'ICAgICAgfQogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgICBzaG93Q29tYm8oJ0thYm9vbSEnKTsKICAg'
      'ICAgICAgICAgYXdhaXQgZGVsYXkoMjUwKTsKICAgICAgICAgICAgYWZmZWN0ZWQuZm9yRWFjaCgoe2NlbGx9KSA9PiBjZWxs'
      'LmNsYXNzTGlzdC5yZW1vdmUoJ2JvbWItcHJldmlldycpKTsKICAgICAgICAgICAgCiAgICAgICAgICAgIGxldCB0cmlnZ2Vy'
      'ZWRDYXNjYWRlID0gZmFsc2U7CiAgICAgICAgICAgIGFmZmVjdGVkLmZvckVhY2goKHtyb3c6IHIsIGNvbDogYywgY2VsbH0p'
      'ID0+IHsKICAgICAgICAgICAgICAgIGNyZWF0ZUV4cGxvc2lvbkVmZmVjdChjZWxsKTsKICAgICAgICAgICAgICAgIGNlbGwu'
      'Y2xhc3NMaXN0LmFkZCgnZXhwbG9kaW5nJyk7CiAgICAgICAgICAgICAgICBjb25zdCBrZXkgPSBjZWxsS2V5KHIsIGMpOwog'
      'ICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICBpZiAoY2VsbC5kYXRhc2V0Lm9ic3RhY2xlID09PSAndHJ1ZScpIHsK'
      'ICAgICAgICAgICAgICAgICAgICBoYW5kbGVPYnN0YWNsZURlc3RydWN0aW9uKHIsIGMsICdib29zdGVyJyk7CiAgICAgICAg'
      'ICAgICAgICAgICAgdHJpZ2dlcmVkQ2FzY2FkZSA9IHRydWU7CiAgICAgICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAg'
      'ICAgICAgICAgIGdhbWVTdGF0ZS5ncmlkW3JdW2NdID0gbnVsbDsKICAgICAgICAgICAgICAgICAgICBkZWxldGUgZ2FtZVN0'
      'YXRlLnNwZWNpYWxzW2tleV07CiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGdhbWVTdGF0ZS5vYnN0YWNsZUhlYWx0aFtr'
      'ZXldOwogICAgICAgICAgICAgICAgICAgIGNlbGwuZGF0YXNldC5vYnN0YWNsZSA9ICdmYWxzZSc7CiAgICAgICAgICAgICAg'
      'ICAgICAgY2VsbC5kYXRhc2V0Lm9ic3RhY2xlVHlwZSA9ICcnOwogICAgICAgICAgICAgICAgICAgIGNlbGwuZGF0YXNldC5o'
      'cCA9ICcwJzsKICAgICAgICAgICAgICAgICAgICB1cGRhdGVDZWxsRGlzcGxheShyLCBjKTsKICAgICAgICAgICAgICAgIH0K'
      'ICAgICAgICAgICAgfSk7CiAgICAgICAgICAgIAogICAgICAgICAgICBhd2FpdCBkZWxheSgzNTApOwogICAgICAgICAgICBh'
      'ZmZlY3RlZC5mb3JFYWNoKCh7Y2VsbH0pID0+IGNlbGwuY2xhc3NMaXN0LnJlbW92ZSgnZXhwbG9kaW5nJykpOwogICAgICAg'
      'ICAgICAKICAgICAgICAgICAgaWYgKCF0cmlnZ2VyZWRDYXNjYWRlKSB7CiAgICAgICAgICAgICAgICBhd2FpdCBkcm9wQ2Fu'
      'ZGllcygpOwogICAgICAgICAgICAgICAgYXdhaXQgZmlsbEVtcHR5KCk7CiAgICAgICAgICAgICAgICBhd2FpdCBwcm9jZXNz'
      'TWF0Y2hlcygpOwogICAgICAgICAgICB9IGVsc2UgewogICAgICAgICAgICAgICAgYXdhaXQgZGVsYXkoODAwKTsKICAgICAg'
      'ICAgICAgfQogICAgICAgICAgICAKICAgICAgICAgICAgY2xlYXJBY3RpdmVCb29zdGVyKCk7CiAgICAgICAgICAgIGdhbWVT'
      'dGF0ZS5pc1Byb2Nlc3NpbmcgPSBmYWxzZTsKICAgICAgICAgICAgdXBkYXRlVGFyZ2V0RGlzcGxheSgpOwogICAgICAgICAg'
      'ICBjaGVja0xldmVsQ29tcGxldGUoKTsKICAgICAgICAgICAgc2F2ZVByb2dyZXNzKCk7CiAgICAgICAgfQoKICAgICAgICBm'
      'dW5jdGlvbiBoYW5kbGVTd2FwQm9vc3Rlcihyb3csIGNvbCkgewogICAgICAgICAgICBpZiAoZ2FtZVN0YXRlLmFjdGl2ZUJv'
      'b3N0ZXIgIT09ICdzd2FwJyB8fCBnYW1lU3RhdGUuaXNQcm9jZXNzaW5nKSByZXR1cm47CiAgICAgICAgICAgIGNvbnN0IGNl'
      'bGwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGBbZGF0YS1yb3c9IiR7cm93fSJdW2RhdGEtY29sPSIke2NvbH0iXWApOwog'
      'ICAgICAgICAgICBpZiAoIWNlbGwpIHJldHVybjsKICAgICAgICAgICAgCiAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nSW5k'
      'ZXggPSBnYW1lU3RhdGUuYm9vc3RlclRhcmdldHMuZmluZEluZGV4KHBvcyA9PiBwb3Mucm93ID09PSByb3cgJiYgcG9zLmNv'
      'bCA9PT0gY29sKTsKICAgICAgICAgICAgaWYgKGV4aXN0aW5nSW5kZXggPj0gMCkgewogICAgICAgICAgICAgICAgY2VsbC5j'
      'bGFzc0xpc3QucmVtb3ZlKCdib29zdGVyLXNlbGVjdGlvbicpOwogICAgICAgICAgICAgICAgZ2FtZVN0YXRlLmJvb3N0ZXJU'
      'YXJnZXRzLnNwbGljZShleGlzdGluZ0luZGV4LCAxKTsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQog'
      'ICAgICAgICAgICAKICAgICAgICAgICAgaWYgKGdhbWVTdGF0ZS5ib29zdGVyVGFyZ2V0cy5sZW5ndGggPj0gMikgewogICAg'
      'ICAgICAgICAgICAgcmV0dXJuOwogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgICBjZWxsLmNsYXNzTGlz'
      'dC5hZGQoJ2Jvb3N0ZXItc2VsZWN0aW9uJyk7CiAgICAgICAgICAgIGdhbWVTdGF0ZS5ib29zdGVyVGFyZ2V0cy5wdXNoKHty'
      'b3csIGNvbH0pOwogICAgICAgICAgICAKICAgICAgICAgICAgaWYgKGdhbWVTdGF0ZS5ib29zdGVyVGFyZ2V0cy5sZW5ndGgg'
      'PT09IDIpIHsKICAgICAgICAgICAgICAgIGZpbmFsaXplU3dhcEJvb3N0ZXIoKTsKICAgICAgICAgICAgfQogICAgICAgIH0K'
      'CiAgICAgICAgYXN5bmMgZnVuY3Rpb24gZmluYWxpemVTd2FwQm9vc3RlcigpIHsKICAgICAgICAgICAgaWYgKGdhbWVTdGF0'
      'ZS5ib29zdGVyVGFyZ2V0cy5sZW5ndGggPCAyKSByZXR1cm47CiAgICAgICAgICAgIGNvbnN0IFtmaXJzdCwgc2Vjb25kXSA9'
      'IGdhbWVTdGF0ZS5ib29zdGVyVGFyZ2V0czsKICAgICAgICAgICAgY29uc3QgY2VsbDEgPSBkb2N1bWVudC5xdWVyeVNlbGVj'
      'dG9yKGBbZGF0YS1yb3c9IiR7Zmlyc3Qucm93fSJdW2RhdGEtY29sPSIke2ZpcnN0LmNvbH0iXWApOwogICAgICAgICAgICBj'
      'b25zdCBjZWxsMiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLXJvdz0iJHtzZWNvbmQucm93fSJdW2RhdGEtY29s'
      'PSIke3NlY29uZC5jb2x9Il1gKTsKICAgICAgICAgICAgCiAgICAgICAgICAgIGlmICghY2VsbDEgfHwgIWNlbGwyKSB7CiAg'
      'ICAgICAgICAgICAgICBjbGVhckFjdGl2ZUJvb3N0ZXIoKTsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAg'
      'fQogICAgICAgICAgICAKICAgICAgICAgICAgY2VsbDEuY2xhc3NMaXN0LnJlbW92ZSgnYm9vc3Rlci1zZWxlY3Rpb24nKTsK'
      'ICAgICAgICAgICAgY2VsbDIuY2xhc3NMaXN0LnJlbW92ZSgnYm9vc3Rlci1zZWxlY3Rpb24nKTsKICAgICAgICAgICAgZ2Ft'
      'ZVN0YXRlLmJvb3N0ZXJUYXJnZXRzID0gW107CiAgICAgICAgICAgIGdhbWVTdGF0ZS5zZWxlY3RlZENlbGwgPSBudWxsOwog'
      'ICAgICAgICAgICAKICAgICAgICAgICAgZ2FtZVN0YXRlLmlzUHJvY2Vzc2luZyA9IHRydWU7CiAgICAgICAgICAgIGdhbWVT'
      'dGF0ZS5ib29zdGVycy5zd2FwLS07CiAgICAgICAgICAgIHVwZGF0ZUJvb3N0ZXJDb3VudHMoKTsKICAgICAgICAgICAgY29u'
      'c3VtZU1vdmUoKTsKICAgICAgICAgICAgc2hvd0NvbWJvKCdNZWdhIFN3YXAhJyk7CiAgICAgICAgICAgIAogICAgICAgICAg'
      'ICBjb25zdCB0ZW1wID0gZ2FtZVN0YXRlLmdyaWRbZmlyc3Qucm93XVtmaXJzdC5jb2xdOwogICAgICAgICAgICBnYW1lU3Rh'
      'dGUuZ3JpZFtmaXJzdC5yb3ddW2ZpcnN0LmNvbF0gPSBnYW1lU3RhdGUuZ3JpZFtzZWNvbmQucm93XVtzZWNvbmQuY29sXTsK'
      'ICAgICAgICAgICAgZ2FtZVN0YXRlLmdyaWRbc2Vjb25kLnJvd11bc2Vjb25kLmNvbF0gPSB0ZW1wOwogICAgICAgICAgICBz'
      'd2FwU3BlY2lhbHMoZmlyc3Qucm93LCBmaXJzdC5jb2wsIHNlY29uZC5yb3csIHNlY29uZC5jb2wpOwogICAgICAgICAgICB1'
      'cGRhdGVDZWxsRGlzcGxheShmaXJzdC5yb3csIGZpcnN0LmNvbCk7CiAgICAgICAgICAgIHVwZGF0ZUNlbGxEaXNwbGF5KHNl'
      'Y29uZC5yb3csIHNlY29uZC5jb2wpOwogICAgICAgICAgICAKICAgICAgICAgICAgYXdhaXQgcHJvY2Vzc01hdGNoZXMoKTsK'
      'ICAgICAgICAgICAgCiAgICAgICAgICAgIGNsZWFyQWN0aXZlQm9vc3RlcigpOwogICAgICAgICAgICBnYW1lU3RhdGUuaXNQ'
      'cm9jZXNzaW5nID0gZmFsc2U7CiAgICAgICAgICAgIHVwZGF0ZVRhcmdldERpc3BsYXkoKTsKICAgICAgICAgICAgY2hlY2tM'
      'ZXZlbENvbXBsZXRlKCk7CiAgICAgICAgICAgIHNhdmVQcm9ncmVzcygpOwogICAgICAgIH0KCiAgICAgICAgZnVuY3Rpb24g'
      'Y2xlYXJDb2xvclR5cGUoY2FuZHkpIHsKICAgICAgICAgICAgZ2FtZVN0YXRlLmlzUHJvY2Vzc2luZyA9IHRydWU7CiAgICAg'
      'ICAgICAgIGNvbnN0IG1hdGNoZXMgPSBbXTsKICAgICAgICAgICAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgR1JJRF9TSVpF'
      'OyByb3crKykgewogICAgICAgICAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgR1JJRF9TSVpFOyBjb2wrKykgewog'
      'ICAgICAgICAgICAgICAgICAgIGlmIChnYW1lU3RhdGUuZ3JpZFtyb3ddW2NvbF0gPT09IGNhbmR5KSB7CiAgICAgICAgICAg'
      'ICAgICAgICAgICAgIG1hdGNoZXMucHVzaCh7cm93LCBjb2x9KTsKICAgICAgICAgICAgICAgICAgICB9CiAgICAgICAgICAg'
      'ICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICAgICAgCiAgICAgICAgICAgIG1hdGNoZXMuZm9yRWFjaCgoe3JvdywgY29s'
      'fSkgPT4gewogICAgICAgICAgICAgICAgY29uc3QgY2VsbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLXJvdz0i'
      'JHtyb3d9Il1bZGF0YS1jb2w9IiR7Y29sfSJdYCk7CiAgICAgICAgICAgICAgICBpZiAoY2VsbCkgewogICAgICAgICAgICAg'
      'ICAgICAgIGNlbGwuY2xhc3NMaXN0LmFkZCgnZXhwbG9kaW5nJyk7CiAgICAgICAgICAgICAgICAgICAgY3JlYXRlUGFydGlj'
      'bGVzKGNlbGwpOwogICAgICAgICAgICAgICAgfQogICAgICAgICAgICB9KTsKICAgICAgICAgICAgCiAgICAgICAgICAgIHNl'
      'dFRpbWVvdXQoYXN5bmMgKCkgPT4gewogICAgICAgICAgICAgICAgbWF0Y2hlcy5mb3JFYWNoKCh7cm93LCBjb2x9KSA9PiB7'
      'CiAgICAgICAgICAgICAgICAgICAgZ2FtZVN0YXRlLmdyaWRbcm93XVtjb2xdID0gbnVsbDsKICAgICAgICAgICAgICAgICAg'
      'ICB1cGRhdGVDZWxsRGlzcGxheShyb3csIGNvbCk7CiAgICAgICAgICAgICAgICB9KTsKICAgICAgICAgICAgICAgIAogICAg'
      'ICAgICAgICAgICAgYXdhaXQgZHJvcENhbmRpZXMoKTsKICAgICAgICAgICAgICAgIGF3YWl0IGZpbGxFbXB0eSgpOwogICAg'
      'ICAgICAgICAgICAgYXdhaXQgcHJvY2Vzc01hdGNoZXMoKTsKICAgICAgICAgICAgICAgIGdhbWVTdGF0ZS5pc1Byb2Nlc3Np'
      'bmcgPSBmYWxzZTsKICAgICAgICAgICAgICAgIHVwZGF0ZVRhcmdldERpc3BsYXkoKTsKICAgICAgICAgICAgICAgIGNoZWNr'
      'TGV2ZWxDb21wbGV0ZSgpOwogICAgICAgICAgICB9LCA0MDApOwogICAgICAgICAgICAKICAgICAgICAgICAgYWRkU2NvcmUo'
      'bWF0Y2hlcy5sZW5ndGggKiAyMDApOwogICAgICAgIH0KCiAgICAgICAgZnVuY3Rpb24gc2h1ZmZsZUdyaWQoKSB7CiAgICAg'
      'ICAgICAgIGdhbWVTdGF0ZS5pc1Byb2Nlc3NpbmcgPSB0cnVlOwogICAgICAgICAgICBjb25zdCBhbGxDYW5kaWVzID0gW107'
      'CiAgICAgICAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IEdSSURfU0laRTsgcm93KyspIHsKICAgICAgICAgICAgICAg'
      'IGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IEdSSURfU0laRTsgY29sKyspIHsKICAgICAgICAgICAgICAgICAgICBhbGxDYW5k'
      'aWVzLnB1c2goZ2FtZVN0YXRlLmdyaWRbcm93XVtjb2xdKTsKICAgICAgICAgICAgICAgIH0KICAgICAgICAgICAgfQogICAg'
      'ICAgICAgICAKICAgICAgICAgICAgLy8gRmlzaGVyLVlhdGVzIHNodWZmbGUKICAgICAgICAgICAgZm9yIChsZXQgaSA9IGFs'
      'bENhbmRpZXMubGVuZ3RoIC0gMTsgaSA+IDA7IGktLSkgewogICAgICAgICAgICAgICAgY29uc3QgaiA9IE1hdGguZmxvb3Io'
      'TWF0aC5yYW5kb20oKSAqIChpICsgMSkpOwogICAgICAgICAgICAgICAgW2FsbENhbmRpZXNbaV0sIGFsbENhbmRpZXNbal1d'
      'ID0gW2FsbENhbmRpZXNbal0sIGFsbENhbmRpZXNbaV1dOwogICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAg'
      'ICBsZXQgaW5kZXggPSAwOwogICAgICAgICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCBHUklEX1NJWkU7IHJvdysrKSB7'
      'CiAgICAgICAgICAgICAgICBmb3IgKGxldCBjb2wgPSAwOyBjb2wgPCBHUklEX1NJWkU7IGNvbCsrKSB7CiAgICAgICAgICAg'
      'ICAgICAgICAgZ2FtZVN0YXRlLmdyaWRbcm93XVtjb2xdID0gYWxsQ2FuZGllc1tpbmRleCsrXTsKICAgICAgICAgICAgICAg'
      'ICAgICB1cGRhdGVDZWxsRGlzcGxheShyb3csIGNvbCk7CiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAg'
      'ICAgICAgZ2FtZVN0YXRlLmlzUHJvY2Vzc2luZyA9IGZhbHNlOwogICAgICAgICAgICB1cGRhdGVUYXJnZXREaXNwbGF5KCk7'
      'CiAgICAgICAgICAgIGNoZWNrTGV2ZWxDb21wbGV0ZSgpOwogICAgICAgIH0KCiAgICAgICAgZnVuY3Rpb24gdXBkYXRlQm9v'
      'c3RlckNvdW50cygpIHsKICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2hhbW1lckNvdW50JykudGV4dENv'
      'bnRlbnQgPSBnYW1lU3RhdGUuYm9vc3RlcnMuaGFtbWVyOwogICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgn'
      'c3dhcENvdW50JykudGV4dENvbnRlbnQgPSBnYW1lU3RhdGUuYm9vc3RlcnMuc3dhcDsKICAgICAgICAgICAgZG9jdW1lbnQu'
      'Z2V0RWxlbWVudEJ5SWQoJ3JhaW5ib3dDb3VudCcpLnRleHRDb250ZW50ID0gZ2FtZVN0YXRlLmJvb3N0ZXJzLnJhaW5ib3c7'
      'CiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdib21iQ291bnQnKS50ZXh0Q29udGVudCA9IGdhbWVTdGF0'
      'ZS5ib29zdGVycy5ib21iOwogICAgICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc2h1ZmZsZUNvdW50JykudGV4'
      'dENvbnRlbnQgPSBnYW1lU3RhdGUuYm9vc3RlcnMuc2h1ZmZsZTsKICAgICAgICB9CgogICAgICAgIC8vIE1pc3N5IFBvd2Vy'
      'CiAgICAgICAgZnVuY3Rpb24gdXNlTWlzc3lQb3dlcigpIHsKICAgICAgICAgICAgaWYgKGdhbWVTdGF0ZS5taXNzeVBvd2Vy'
      'IDw9IDApIHsKICAgICAgICAgICAgICAgIGFsZXJ0KCdNaXNzeSBuZWVkcyBtb3JlIHBvd2VyISBDb21wbGV0ZSBsZXZlbHMg'
      'dG8gcmVjaGFyZ2UhJyk7CiAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIH0KICAgICAgICAgICAgCiAgICAg'
      'ICAgICAgIGdhbWVTdGF0ZS5taXNzeVBvd2VyLS07CiAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtaXNz'
      'eVBvd2VyJykudGV4dENvbnRlbnQgPSBnYW1lU3RhdGUubWlzc3lQb3dlcjsKICAgICAgICAgICAgCiAgICAgICAgICAgIC8v'
      'IFJhaW5ib3cgYmxhc3QgZWZmZWN0IC0gY2xlYXIgcmFuZG9tIGNvbG9yCiAgICAgICAgICAgIGNvbnN0IHJhbmRvbUNhbmR5'
      'ID0gQ0FORFlfVFlQRVNbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogQ0FORFlfVFlQRVMubGVuZ3RoKV07CiAgICAgICAg'
      'ICAgIGNsZWFyQ29sb3JUeXBlKHJhbmRvbUNhbmR5KTsKICAgICAgICAgICAgCiAgICAgICAgICAgIHNhdmVQcm9ncmVzcygp'
      'OwogICAgICAgIH0KCiAgICAgICAgLy8gTWlzc3kgSGVscGVyIEZ1bmN0aW9ucwogICAgICAgIGZ1bmN0aW9uIHN1bW1vbk1p'
      'c3N5SGVscGVyKCkgewogICAgICAgICAgICBpZiAoZ2FtZVN0YXRlLm1pc3N5SGVscGVyLmNoYXJnZXMgPD0gMCkgewogICAg'
      'ICAgICAgICAgICAgYWxlcnQoJ05vIG1vcmUgaGVscGVyIGNoYXJnZXMhIENvbXBsZXRlIGxldmVscyB0byBlYXJuIG1vcmUh'
      'Jyk7CiAgICAgICAgICAgICAgICByZXR1cm47CiAgICAgICAgICAgIH0KICAgICAgICAgICAgCiAgICAgICAgICAgIGlmIChn'
      'YW1lU3RhdGUubWlzc3lIZWxwZXIuYWN0aXZlKSB7CiAgICAgICAgICAgICAgICBhbGVydCgnTWlzc3kgaXMgYWxyZWFkeSBo'
      'ZWxwaW5nIG9uIHRoZSBib2FyZCEnKTsKICAgICAgICAgICAgICAgIHJldHVybjsKICAgICAgICAgICAgfQogICAgICAgICAg'
      'ICAKICAgICAgICAgICAgaWYgKGdhbWVTdGF0ZS5pc1Byb2Nlc3NpbmcpIHsKICAgICAgICAgICAgICAgIGFsZXJ0KCdQbGVh'
      'c2Ugd2FpdCBmb3IgdGhlIGN1cnJlbnQgYWN0aW9uIHRvIGNvbXBsZXRlIScpOwogICAgICAgICAgICAgICAgcmV0dXJuOwog'
      'ICAgICAgICAgICB9CiAgICAgICAgICAgIAogICAgICAgICAgICAvLyBEZWR1Y3QgY2hhcmdlIGFuZCBhY3RpdmF0ZQogICAg'
      'ICAgICAgICBnYW1lU3RhdGUubWlzc3lIZWxwZXIuY2hhcmdlcy0tOwogICAgICAgICAgICBnYW1lU3RhdGUubWlzc3lIZWxw'
      'ZXIuYWN0aXZlID0gdHJ1ZTsKICAgICAgICAgICAgZ2FtZVN0YXRlLm1pc3N5SGVscGVyLm9ic3RhY2xlc0Rlc3Ryb3llZCA9'
      'IDA7CiAgICAgICAgICAgIGdhbWVTdGF0ZS5taXNzeUhlbHBlci5vYnN0YWNsZXNSZW1haW5pbmcgPSAzOwogICAgICAgICAg'
      'ICBnYW1lU3RhdGUubWlzc3lIZWxwZXIuaGFzU3BlY2lmaWNUYXJnZXQgPSBmYWxzZTsKICAgICAgICAgICAgZ2FtZVN0YXRl'
      'Lm1pc3N5SGVscGVyLnRhcmdldFJvdyA9IG51bGw7CiAgICAgICAgICAgIGdhbWVTdGF0ZS5taXNzeUhlbHBlci50YXJnZXRD'
      'b2wgPSBudWxsOwogICAgICAgICAgICAKICAgICAgICAgICAgLy8gQ2xlYXIgb2xkIHRhcmdldGluZyBpbmRpY2F0b3JzCiAg'
      'ICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5taXNzeS10YXJnZXQnKS5mb3JFYWNoKGVsID0+CiAgICAg'
      'ICAgICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKCdtaXNzeS10YXJnZXQnKSk7CiAgICAgICAgICAgIAogICAgICAgICAg'
      'ICAvLyBTaG93IE1pc3N5IHNwcml0ZQogICAgICAgICAgICBjb25zdCBtaXNzeUhlbHBlciA9IGRvY3VtZW50LmdldEVsZW1l'
      'bnRCeUlkKCdtaXNzeUhlbHBlcicpOwogICAgICAgICAgICBtaXNzeUhlbHBlci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJzsK'
      'ICAgICAgICAgICAgbWlzc3lIZWxwZXIuc3R5bGUudHJhbnNmb3JtID0gJ3RyYW5zbGF0ZSgtNTAlLCAtNTAlKSc7CiAgICAg'
      'ICAgICAgIG1pc3N5SGVscGVyLmNsYXNzTGlzdC5yZW1vdmUoJ21vdmluZycsICdhdHRhY2tpbmcnKTsKICAgICAgICAgICAg'
      'CiAgICAgICAgICAgIC8vIFJlc2V0IHRvIGNlbnRlciBwb3NpdGlvbgogICAgICAgICAgICByZXR1cm5NaXNzeVRvQ2VudGVy'
      'KCk7CiAgICAgICAgICAgIAogICAgICAgICAgICAvLyBVcGRhdGUgVUkKICAgICAgICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVu'
      'dEJ5SWQoJ21pc3N5SGVscGVyQ2hhcmdlcycpLnRleHRDb250ZW50ID0gZ2FtZVN0YXRlLm1pc3N5SGVscGVyLmNoYXJnZXM7'
      'CiAgICAgICAgICAgIHVwZGF0ZU1pc3N5T2JzdGFjbGVzRGlzcGxheSgpOwogICAgICAgICAgICAKICAgICAgICAgICAgLy8g'
      'U3RhcnQgYXR0YWNrIGludGVydmFsCiAgICAgICAgICAgIGlmIChnYW1lU3RhdGUubWlzc3lIZWxwZXIuYXR0YWNrSW50ZXJ2'
      'YWxJZCkgewogICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChnYW1lU3RhdGUubWlzc3lIZWxwZXIuYXR0YWNrSW50ZXJ2'
      'YWxJZCk7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgZ2FtZVN0YXRlLm1pc3N5SGVscGVyLmF0dGFja0ludGVydmFsSWQg'
      'PSBzZXRJbnRlcnZhbChtaXNzeUF1dG9BdHRhY2ssIGdhbWVTdGF0ZS5taXNzeUhlbHBlci5hdHRhY2tJbnRlcnZhbCk7CiAg'
      'ICAgICAgICAgIAogICAgICAgICAgICAvLyBTaG93IGFjdGl2YXRpb24gbWVzc2FnZQogICAgICAgICAgICBzaG93Q29tYm8o'
      'J01pc3N5IEFjdGl2YXRlZCEgKDMgb2JzdGFjbGVzKScpOwogICAgICAgICAgICAKICAgICAgICAgICAgc2F2ZVByb2dyZXNz'
      'KCk7CiAgICAgICAgfQoKICAgICAgICBmdW5jdGlvbiBkZWFjdGl2YXRlTWlzc3lIZWxwZXIoKSB7CiAgICAgICAgICAgIGlm'
      'ICghZ2FtZVN0YXRlLm1pc3N5SGVscGVyLmFjdGl2ZSkgcmV0dXJuOwogICAgICAgICAgICAKICAgICAgICAgICAgLy8gSGlk'
      'ZSBzcHJpdGUKICAgICAgICAgICAgY29uc3QgbWlzc3lIZWxwZXIgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWlzc3lI'
      'ZWxwZXInKTsKICAgICAgICAgICAgbWlzc3lIZWxwZXIuc3R5bGUuZGlzcGxheSA9ICdub25lJzsKICAgICAgICAgICAgbWlz'
      'c3lIZWxwZXIuY2xhc3NMaXN0LnJlbW92ZSgnbW92aW5nJywgJ2F0dGFja2luZycpOwogICAgICAgICAgICAKICAgICAgICAg'
      'ICAgLy8gQ2xlYXIgYXR0YWNrIGludGVydmFsCiAgICAgICAgICAgIGlmIChnYW1lU3RhdGUubWlzc3lIZWxwZXIuYXR0YWNr'
      'SW50ZXJ2YWxJZCkgewogICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChnYW1lU3RhdGUubWlzc3lIZWxwZXIuYXR0YWNr'
      'SW50ZXJ2YWxJZCk7CiAgICAgICAgICAgICAgICBnYW1lU3RhdGUubWlzc3lIZWxwZXIuYXR0YWNrSW50ZXJ2YWxJZCA9IG51'
      'bGw7CiAgICAgICAgICAgIH0KICAgICAgICAgICAgCiAgICAgICAgICAgIC8vIFJlc2V0IHN0YXRlCiAgICAgICAgICAgIGNv'
      'bnN0IGRlc3Ryb3llZCA9IGdhbWVTdGF0ZS5taXNzeUhlbHBlci5vYnN0YWNsZXNEZXN0cm95ZWQ7CiAgICAgICAgICAgIGdh'
      'bWVTdGF0ZS5taXNzeUhlbHBlci5hY3RpdmUgPSBmYWxzZTsKICAgICAgICAgICAgZ2FtZVN0YXRlLm1pc3N5SGVscGVyLm9i'
      'c3RhY2xlc1JlbWFpbmluZyA9IDA7CiAgICAgICAgICAgIGdhbWVTdGF0ZS5taXNzeUhlbHBlci5oYXNTcGVjaWZpY1Rhcmdl'
      'dCA9IGZhbHNlOwogICAgICAgICAgICBnYW1lU3RhdGUubWlzc3lIZWxwZXIudGFyZ2V0Um93ID0gbnVsbDsKICAgICAgICAg'
      'ICAgZ2FtZVN0YXRlLm1pc3N5SGVscGVyLnRhcmdldENvbCA9IG51bGw7CiAgICAgICAgICAgIAogICAgICAgICAgICAvLyBD'
      'bGVhciBhbnkgdGFyZ2V0IGluZGljYXRvcnMKICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLm1pc3N5'
      'LXRhcmdldCcpLmZvckVhY2goZWwgPT4KICAgICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoJ21pc3N5LXRhcmdl'
      'dCcpKTsKICAgICAgICAgICAgCiAgICAgICAgICAgIHVwZGF0ZU1pc3N5T2JzdGFjbGVzRGlzcGxheSgpOwogICAgICAgICAg'
      'ICAKICAgICAgICAgICAgLy8gU2hvdyBkZWFjdGl2YXRpb24gbWVzc2FnZQogICAgICAgICAgICBzaG93Q29tYm8oYE1pc3N5'
      'IERvbmUhIERlc3Ryb3llZCAke2Rlc3Ryb3llZH0gb2JzdGFjbGVzIWApOwogICAgICAgIH0KCiAgICAgICAgZnVuY3Rpb24g'
      'dXBkYXRlTWlzc3lPYnN0YWNsZXNEaXNwbGF5KCkgewogICAgICAgICAgICBjb25zdCBkaXNwbGF5ID0gZG9jdW1lbnQuZ2V0'
      'RWxlbWVudEJ5SWQoJ21pc3N5VHVybnNEaXNwbGF5Jyk7CiAgICAgICAgICAgIGlmIChkaXNwbGF5KSB7CiAgICAgICAgICAg'
      'ICAgICBjb25zdCByZW1haW5pbmcgPSBnYW1lU3RhdGUubWlzc3lIZWxwZXIub2JzdGFjbGVzUmVtYWluaW5nOwogICAgICAg'
      'ICAgICAgICAgZGlzcGxheS50ZXh0Q29udGVudCA9IGAke3JlbWFpbmluZ30gb2JzdGFjbGUke3JlbWFpbmluZyAhPT0gMSA/'
      'ICdzJyA6ICcnfWA7CiAgICAgICAgICAgIH0KICAgICAgICB9CgogICAgICAgIC8vIE1ldGEgTGF5ZXIgRnVuY3Rpb25zCiAg'
      'ICAgICAgZnVuY3Rpb24gb3BlbkNhc3RsZSgpIHsKICAgICAgICAgICAgYWxlcnQoJ/Cfj7AgUm95YWwgQ2FzdGxlXG5cblBy'
      'b2dyZXNzOiAnICsgTWF0aC5mbG9vcihnYW1lU3RhdGUucHJvZ3Jlc3MuY2FzdGxlKSArICclXG5cbkRlY29yYXRlIHlvdXIg'
      'Y2FzdGxlIGJ5IHdpbm5pbmcgbGV2ZWxzIVxuVW5sb2NrIG5ldyByb29tcyBhbmQgdHJlYXN1cmVzIScpOwogICAgICAgIH0K'
      'CiAgICAgICAgZnVuY3Rpb24gb3BlbkdhcmRlbigpIHsKICAgICAgICAgICAgYWxlcnQoJ/CfjLggTWFnaWMgR2FyZGVuXG5c'
      'blByb2dyZXNzOiAnICsgTWF0aC5mbG9vcihnYW1lU3RhdGUucHJvZ3Jlc3MuZ2FyZGVuKSArICclXG5cblJlc3RvcmUgdGhl'
      'IGJlYXV0aWZ1bCBnYXJkZW4hXG5QbGFudCBmbG93ZXJzIGFuZCBncm93IG1hZ2ljYWwgcGxhbnRzIScpOwogICAgICAgIH0K'
      'CiAgICAgICAgZnVuY3Rpb24gb3BlbkFxdWFyaXVtKCkgewogICAgICAgICAgICBhbGVydCgn8J+QoCBDcnlzdGFsIEFxdWFy'
      'aXVtXG5cblByb2dyZXNzOiAnICsgTWF0aC5mbG9vcihnYW1lU3RhdGUucHJvZ3Jlc3MuYXF1YXJpdW0pICsgJyVcblxuQ29s'
      'bGVjdCBleG90aWMgZmlzaCFcbkNyZWF0ZSB0aGUgbW9zdCBiZWF1dGlmdWwgYXF1YXJpdW0hJyk7CiAgICAgICAgfQoKICAg'
      'ICAgICAvLyBTa2lsbHMgTWVudSBUb2dnbGUKICAgICAgICBmdW5jdGlvbiB0b2dnbGVTa2lsbHNNZW51KCkgewogICAgICAg'
      'ICAgICBjb25zdCBvdmVybGF5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NraWxsc092ZXJsYXknKTsKICAgICAgICAg'
      'ICAgY29uc3QgaXNIaWRkZW4gPSBvdmVybGF5LnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyB8fCAhb3ZlcmxheS5zdHlsZS5k'
      'aXNwbGF5OwogICAgICAgICAgICBvdmVybGF5LnN0eWxlLmRpc3BsYXkgPSBpc0hpZGRlbiA/ICdmbGV4JyA6ICdub25lJzsK'
      'ICAgICAgICB9CgogICAgICAgIC8vIENsb3NlIHNraWxscyBtZW51IGZ1bmN0aW9uCiAgICAgICAgZnVuY3Rpb24gY2xvc2VT'
      'a2lsbHNNZW51KCkgewogICAgICAgICAgICBjb25zdCBvdmVybGF5ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3NraWxs'
      'c092ZXJsYXknKTsKICAgICAgICAgICAgb3ZlcmxheS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnOwogICAgICAgIH0KCiAgICAg'
      'ICAgLy8gQ2xvc2Ugc2tpbGxzIG1lbnUgd2hlbiBjbGlja2luZyBvdXRzaWRlCiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRM'
      'aXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldmVudCkgewogICAgICAgICAgICBjb25zdCBvdmVybGF5ID0gZG9jdW1lbnQu'
      'Z2V0RWxlbWVudEJ5SWQoJ3NraWxsc092ZXJsYXknKTsKICAgICAgICAgICAgY29uc3QgbWVudUJ1dHRvbiA9IGRvY3VtZW50'
      'LnF1ZXJ5U2VsZWN0b3IoJy5tZW51LWJ1dHRvbicpOwogICAgICAgICAgICAKICAgICAgICAgICAgaWYgKG92ZXJsYXkuc3R5'
      'bGUuZGlzcGxheSA9PT0gJ2ZsZXgnICYmIAogICAgICAgICAgICAgICAgIW92ZXJsYXkuY29udGFpbnMoZXZlbnQudGFyZ2V0'
      'KSAmJiAKICAgICAgICAgICAgICAgICFtZW51QnV0dG9uLmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHsKICAgICAgICAgICAg'
      'ICAgIG92ZXJsYXkuc3R5bGUuZGlzcGxheSA9ICdub25lJzsKICAgICAgICAgICAgfQogICAgICAgIH0pOwoKICAgICAgICAv'
      'LyBJbml0aWFsaXplIG9uIGxvYWQKICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHsKICAg'
      'ICAgICAgICAgbG9hZFByb2dyZXNzKCk7CiAgICAgICAgICAgIHNob3dMZXZlbFNlbGVjdCgpOwogICAgICAgIH0pOwoKICAg'
      'ICAgICAvLyBQcmV2ZW50IGFjY2lkZW50YWwgbmF2aWdhdGlvbiBhd2F5CiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVu'
      'ZXIoJ2JlZm9yZXVubG9hZCcsIChlKSA9PiB7CiAgICAgICAgICAgIGlmICghZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2xl'
      'dmVsU2VsZWN0Jykuc3R5bGUuZGlzcGxheSB8fCAKICAgICAgICAgICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCds'
      'ZXZlbFNlbGVjdCcpLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJykgewogICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVs'
      'dCgpOwogICAgICAgICAgICAgICAgZS5yZXR1cm5WYWx1ZSA9ICcnOwogICAgICAgICAgICB9CiAgICAgICAgfSk7CiAgICA8'
      'L3NjcmlwdD4=';

      const MOVES_BLOCK = [
        '            <div class="stat-box">',
        '                <div class="stat-icon stat-icon-blue">🎪</div>',
        '                <div id="movesDisplay">30 moves</div>',
        '            </div>',
        '            <div class="stat-box">',
        '                <div class="stat-icon stat-icon-green">🎲</div>'
      ].join('\n');

      const MOVES_WITH_EXIT = [
        '            <div class="stat-box">',
        '                <div class="stat-icon stat-icon-blue">🎪</div>',
        '                <div id="movesDisplay">30 moves</div>',
        '            </div>',
        '            <div class="stat-box exit-button" onclick="requestArcadeExit()">',
        '                <div class="stat-icon stat-icon-pink">🏠</div>',
        '                <div>Exit Arcade</div>',
        '            </div>',
        '            <div class="stat-box">',
        '                <div class="stat-icon stat-icon-green">🎲</div>'
      ].join('\n');

      const TOPBAR_CLOSE = '        </div>\n\n        <!-- Character Panel (Missy) -->';
      const TOPBAR_WITH_TOAST = '        </div>\n        <div id="arcadeRewardToast">+0 Gold!</div>\n\n        <!-- Character Panel (Missy) -->';

      const EXTRA_CSS = [
        '        .exit-button {',
        '            cursor: pointer;',
        '            background: rgba(255,255,255,0.22);',
        '            transition: transform 0.18s ease, box-shadow 0.25s ease, background 0.25s ease;',
        '        }',
        '',
        '        .exit-button:hover {',
        '            transform: translateY(-3px);',
        '            background: rgba(255,255,255,0.32);',
        '            box-shadow: 0 6px 20px rgba(255, 255, 255, 0.25);',
        '        }',
        '',
        '        #arcadeRewardToast {',
        '            position: fixed;',
        '            top: 96px;',
        '            left: 50%;',
        '            transform: translateX(-50%) translateY(-24px);',
        '            background: linear-gradient(135deg, rgba(255,215,0,0.95), rgba(255,168,0,0.92));',
        '            color: #4a3067;',
        '            padding: 12px 28px;',
        '            border-radius: 24px;',
        '            font-weight: bold;',
        '            font-size: 18px;',
        '            box-shadow: 0 12px 30px rgba(0,0,0,0.35);',
        '            opacity: 0;',
        '            pointer-events: none;',
        '            transition: opacity 0.25s ease, transform 0.25s ease;',
        '            z-index: 220;',
        '        }',
        '',
        '        #arcadeRewardToast.visible {',
        '            opacity: 1;',
        '            transform: translateX(-50%) translateY(0);',
        '        }'
      ].join('\n');

      const LOAD_PROGRESS_MARKER = '        // Load saved progress';
      const HELPER_FUNCTIONS = [
        '        function postToParent(type, payload) {',
        "            try {",
        "                window.top?.postMessage({ from: 'MissyArcade', type, payload }, '*');",
        "            } catch (_) { }",
        '        }',
        '',
        '        function requestArcadeExit() {',
        "            postToParent('exit-request', {",
        "                level: gameState.currentLevel,",
        "                inMenu: document.getElementById('levelSelect')?.style.display !== 'none'",
        '            });',
        '        }',
        '',
        '        function showRewardToast(message) {',
        '            const toast = document.getElementById(\'arcadeRewardToast\');',
        '            if (!toast) return;',
        '            toast.textContent = message;',
        '            toast.classList.add(\'visible\');',
        '            clearTimeout(showRewardToast._t);',
        '            showRewardToast._t = setTimeout(() => toast.classList.remove(\'visible\'), 2600);',
        '        }',
        '',
        '        const arcadeSession = {',
        '            enteredAt: Date.now(),',
        '            lastGoldNotify: Date.now(),',
        '            lastRewardMinute: 0',
        '        };',
        '',
        "        postToParent('session-start', { timestamp: arcadeSession.enteredAt });",
        '',
        LOAD_PROGRESS_MARKER
      ].join('\n');

      const INIT_SIGNATURE = '        function initGame(level) {\n            gameState.currentLevel = level;';
      const INIT_WITH_TIME = '        function initGame(level) {\n            gameState.currentLevel = level;\n            gameState._levelStartTime = performance.now();\n            postToParent(\'level-start\', { level, moves: (gameState.levels[level - 1]?.objective?.moves) || 0 });';

      const VICTORY_MARKER = "            document.getElementById('victoryScreen').style.display = 'flex';\n\n            saveProgress();";
      const VICTORY_WITH_REWARD = [
        "            document.getElementById('victoryScreen').style.display = 'flex';",
        '',
        '            const timeSpent = Math.max(0, Math.round(performance.now() - (gameState._levelStartTime || performance.now())));',
        "            postToParent('level-complete', {",
        '                level: gameState.currentLevel,',
        '                stars,',
        '                score: gameState.score,',
        '                movesRemaining: gameState.moves,',
        '                maxCombo: gameState.maxCombo,',
        '                timeSpent',
        '            });',
        '',
        '            saveProgress();'
      ].join('\n');

      const DEFEAT_MARKER = "        function showDefeat() {\n            document.getElementById('failScore').textContent = gameState.score;";
      const DEFEAT_WITH_REPORT = [
        '        function showDefeat() {',
        "            document.getElementById('failScore').textContent = gameState.score;",
        '            const timeSpent = Math.max(0, Math.round(performance.now() - (gameState._levelStartTime || performance.now())));',
        "            postToParent('level-failed', {",
        '                level: gameState.currentLevel,',
        '                score: gameState.score,',
        '                movesRemaining: gameState.moves,',
        '                maxCombo: gameState.maxCombo,',
        '                timeSpent',
        '            });'
      ].join('\n');

      const MESSAGE_LISTENER_MARKER = '        // Initialize on load\n        window.addEventListener(\'load\', () => {';
      const MESSAGE_LISTENER_BLOCK = [
        '        window.addEventListener(\'message\', (event) => {',
        '            const data = event.data;',
        "            if (!data || data.from !== 'RunnerArcade') return;",
        "            if (data.type === 'reward-notice') {",
        "                showRewardToast(data.payload?.text || '+0 Gold');",
        '            }',
        "            if (data.type === 'session-summary') {",
        "                showRewardToast(data.payload?.headline || 'Session Complete!');",
        '            }',
        '        });',
        '',
        '        setInterval(() => {',
        '            const now = Date.now();',
        '            const minutesElapsed = Math.floor((now - arcadeSession.enteredAt) / 60000);',
        '            if (minutesElapsed <= 0) return;',
        '            if (minutesElapsed <= arcadeSession.lastRewardMinute) return;',
        '',
        '            const minutesSinceLast = minutesElapsed - arcadeSession.lastRewardMinute;',
        '            const goldEarned = minutesSinceLast * 1000;',
        '            if (goldEarned <= 0) return;',
        '',
        '            arcadeSession.lastRewardMinute = minutesElapsed;',
        '            arcadeSession.lastGoldNotify = now;',
        '',
        "            postToParent('time-reward', {",
        '                minutesElapsed,',
        '                goldEarned,',
        '                sessionStart: arcadeSession.enteredAt',
        '            });',
        '        }, 10000);',
        '',
        MESSAGE_LISTENER_MARKER
      ].join('\n');

      const LOAD_READY_MARKER = "        window.addEventListener('load', () => {\n            loadProgress();\n            showLevelSelect();\n        });";
      const LOAD_READY_PATCH = "        window.addEventListener('load', () => {\n            loadProgress();\n            showLevelSelect();\n            postToParent('ready', { levels: gameState.levels.length });\n        });";

      function buildSrcdoc() {
        let html = decodeArcadeBase64(MISSY_ARCADE_B64);
        if (!html) return '';
        const replacements = [
          [MOVES_BLOCK, MOVES_WITH_EXIT],
          [TOPBAR_CLOSE, TOPBAR_WITH_TOAST],
          ['    </style>', EXTRA_CSS + '\n    </style>'],
          [LOAD_PROGRESS_MARKER, HELPER_FUNCTIONS],
          [INIT_SIGNATURE, INIT_WITH_TIME],
          [VICTORY_MARKER, VICTORY_WITH_REWARD],
          [DEFEAT_MARKER, DEFEAT_WITH_REPORT],
          [MESSAGE_LISTENER_MARKER, MESSAGE_LISTENER_BLOCK],
          [LOAD_READY_MARKER, LOAD_READY_PATCH]
        ];
        for (const [find, replace] of replacements) {
          if (!find || html.indexOf(find) === -1) {
            console.warn('[MissyArcadeGame] Missing replacement marker:', find?.slice?.(0, 80));
            continue;
          }
          html = html.replace(find, replace);
        }
        return html;
      }

      const OVERLAY_STYLE_ID = 'missy-arcade-style';
      function ensureArcadeStyles() {
        if (document.getElementById(OVERLAY_STYLE_ID)) return;
        const style = document.createElement('style');
        style.id = OVERLAY_STYLE_ID;
        style.textContent = [
          '.missy-arcade-overlay { position: fixed; inset: 0; background: rgba(10, 4, 20, 0.85); backdrop-filter: blur(12px); display: none; align-items: center; justify-content: center; z-index: 10050; opacity: 0; transition: opacity 0.3s ease; padding: 32px; box-sizing: border-box; }',
          '.missy-arcade-overlay.active { display: flex; opacity: 1; }',
          '.missy-arcade-overlay.fade-out { opacity: 0; pointer-events: none; }',
          '.missy-arcade-frame { width: min(1200px, 94vw); height: min(760px, 90vh); border: 0; border-radius: 26px; box-shadow: 0 24px 60px rgba(0,0,0,0.45); overflow: hidden; background: #130c1c; }',
          '.missy-arcade-transition { position: absolute; inset: 0; display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 18px; color: #ffe8ff; font: 18px/1.4 \"Segoe UI\", sans-serif; pointer-events: none; transition: opacity 0.3s ease; }',
          '.missy-arcade-transition.hidden { opacity: 0; }',
          '.missy-arcade-loading { padding: 14px 28px; border-radius: 20px; background: linear-gradient(135deg, rgba(147,51,234,0.9), rgba(255,147,211,0.85)); box-shadow: 0 18px 40px rgba(0,0,0,0.45); font-weight: 600; letter-spacing: 0.03em; }',
          'body.missy-arcade-active #cv { opacity: 0; transition: opacity 0.3s ease; }',
          'body.missy-arcade-active .main-hud { opacity: 0; pointer-events: none; }',
          '.missy-arcade-summary { width: min(600px, 88vw); background: linear-gradient(160deg, rgba(15,10,30,0.96), rgba(35,16,52,0.96)); border-radius: 26px; padding: 36px 42px; color: #f7e9ff; box-shadow: 0 28px 60px rgba(0,0,0,0.55); display: flex; flex-direction: column; gap: 18px; align-items: stretch; }',
          '.missy-arcade-summary h2 { margin: 0; font-size: 28px; letter-spacing: 0.04em; text-align: center; }',
          '.missy-arcade-summary p { margin: 0; color: rgba(255,255,255,0.75); text-align: center; font-size: 15px; }',
          '.missy-arcade-summary .summary-grid { display: grid; grid-template-columns: repeat(2, minmax(0, 1fr)); gap: 14px; }',
          '.missy-arcade-summary .metric { background: rgba(255,255,255,0.08); border-radius: 16px; padding: 14px 16px; display: flex; flex-direction: column; gap: 4px; }',
          '.missy-arcade-summary .metric span { font-size: 12px; color: rgba(255,255,255,0.6); text-transform: uppercase; letter-spacing: 0.08em; }',
          '.missy-arcade-summary .metric strong { font-size: 20px; letter-spacing: 0.02em; color: #ffe3ff; }',
          '.missy-arcade-summary .missy-arcade-button { align-self: center; padding: 12px 32px; border-radius: 999px; border: 1px solid rgba(255,214,250,0.6); background: linear-gradient(135deg, #ff85d8, #a855f7); color: #fff; font-weight: 600; cursor: pointer; box-shadow: 0 14px 30px rgba(168,85,247,0.35); transition: transform 0.2s ease, box-shadow 0.2s ease; }',
          '.missy-arcade-summary .missy-arcade-button:hover { transform: translateY(-2px); box-shadow: 0 18px 36px rgba(168,85,247,0.5); }',
          '.missy-arcade-confirm { width: min(420px, 90vw); background: linear-gradient(150deg, rgba(20,12,38,0.98), rgba(60,26,80,0.95)); border-radius: 22px; padding: 28px 32px; box-shadow: 0 24px 54px rgba(0,0,0,0.55); color: #fbeaff; display: flex; flex-direction: column; gap: 18px; text-align: center; }',
          '.missy-arcade-confirm h3 { margin: 0; font-size: 24px; letter-spacing: 0.03em; }',
          '.missy-arcade-confirm p { margin: 0; color: rgba(255,255,255,0.72); font-size: 15px; }',
          '.missy-arcade-confirm-actions { display: flex; justify-content: center; gap: 12px; }',
          '.missy-arcade-button-secondary, .missy-arcade-button-primary { padding: 10px 24px; border-radius: 14px; border: none; font-weight: 600; cursor: pointer; }',
          '.missy-arcade-button-secondary { background: rgba(255,255,255,0.12); color: #ffe9ff; }',
          '.missy-arcade-button-primary { background: linear-gradient(135deg, #ff85d8, #a855f7); color: #fff; box-shadow: 0 12px 28px rgba(168,85,247,0.35); }',
          '.missy-arcade-button-primary:hover { box-shadow: 0 16px 40px rgba(168,85,247,0.45); }',
          '.missy-arcade-overlay .missy-arcade-confirm, .missy-arcade-overlay .missy-arcade-summary { animation: missyOverlayPop 0.35s ease; }',
          '@keyframes missyOverlayPop { 0% { transform: scale(0.92); opacity: 0; } 60% { transform: scale(1.02); opacity: 1; } 100% { transform: scale(1); } }'
        ].join('\n');
        document.head.appendChild(style);
      }

      const RunnerStateControl = {
        state: null,
        freeze() {
          if (this.state) return;
          const st = window.st || (window.st = {});
          this.state = {
            platformEnabled: window.Platform ? window.Platform.enabled : null,
            spawnPaused: st.spawnPaused,
            paused: st.paused,
            timeScale: st.timeScale
          };
          try { window.WorldFreeze?.freeze?.(); } catch (_) { }
          try { if (window.Platform) window.Platform.enabled = false; } catch (_) { }
          st.spawnPaused = true;
          st.paused = true;
          st.timeScale = 0;
        },
        resume() {
          const st = window.st || (window.st = {});
          const prev = this.state || {};
          if (prev.platformEnabled != null && window.Platform) window.Platform.enabled = prev.platformEnabled;
          st.spawnPaused = prev.spawnPaused != null ? prev.spawnPaused : false;
          st.paused = prev.paused != null ? prev.paused : false;
          st.timeScale = prev.timeScale != null ? prev.timeScale : 1;
          try { window.WorldFreeze?.resume?.(); } catch (_) { }
          this.state = null;
        }
      };

      function giveArcadeRewards(tickets = 0, gold = 0, exp = 0, options = {}) {
        const st = window.st || (window.st = {});
        const progress = (st.arcadeProgress = st.arcadeProgress || { tickets: 0, highScores: {} });
        let messageParts = [];

        if (tickets) {
          st.tickets = (st.tickets || 0) + tickets;
          progress.tickets = (progress.tickets || 0) + tickets;
          messageParts.push(`🎫 +${tickets}`);
        }

        if (gold) {
          st.gold = (st.gold || 0) + gold;
          messageParts.push(`💰 +${gold}`);
        }

        if (exp) {
          const leaderIndex = Number.isInteger(st.leader) ? st.leader : 0;
          const leader = Array.isArray(st.players) ? st.players[leaderIndex] : null;
          if (leader) {
            leader.exp = (leader.exp || 0) + exp;
          }
          messageParts.push(`⭐ +${exp} EXP`);
        }

        if (options.highScoreKey) {
          const key = options.highScoreKey;
          const value = options.highScoreValue ?? 0;
          const previous = progress.highScores[key];
          if (previous == null || value > previous) {
            progress.highScores[key] = value;
            options.onNewHighScore?.(value);
          }
        }

        try { window.refreshCurrencies?.(); } catch (_) { }
        if (messageParts.length) {
          const summary = messageParts.join('  ');
          try { notify?.(`Arcade Rewards: ${summary}`, '#ff9de2'); } catch (_) { console.log('Arcade Rewards:', summary); }
        }
        return { tickets, gold, exp };
      }
      window.giveArcadeRewards = giveArcadeRewards;

      const ArcadeGames = (() => {
        const clamp = (value, min, max) => Math.max(min, Math.min(max, value));

        function createRpsGame(ctx) {
          const { container, manager } = ctx;
          const choices = [
            { id: "rock", label: "🪨 Rock" },
            { id: "paper", label: "📄 Paper" },
            { id: "scissors", label: "✂️ Scissors" },
          ];
          const beats = { rock: "scissors", paper: "rock", scissors: "paper" };
          const root = document.createElement("div");
          root.className = "arcade-game rps-game";
          root.innerHTML = [
            '<h2 class="arcade-game-heading">Rock Paper Scissors</h2>',
            '<p class="arcade-game-intro">Best of 3 rounds versus the CPU. Choose wisely!</p>',
            '<div class="arcade-inline-score">',
            '  <div>Player <span data-player-score>0</span></div>',
            '  <div>CPU <span data-cpu-score>0</span></div>',
            '  <div>Round <span data-round>1</span>/3</div>',
            "</div>",
            '<div class="rps-choices">',
            choices
              .map(
                (c) =>
                  `<button class="arcade-btn" data-choice="${c.id}">${c.label}</button>`
              )
              .join(""),
            "</div>",
            '<div class="rps-status" data-status>Make your selection.</div>',
            '<div class="rps-history" data-history></div>',
          ].join("");
          const footer = document.createElement("div");
          footer.className = "arcade-result-panel hidden";
          root.appendChild(footer);
          container.appendChild(root);
          manager.setSubtitle?.(
            "Best of 3 — victory earns 10 tickets, 25 gold, 1 EXP"
          );

          const playerScoreEl = root.querySelector("[data-player-score]");
          const cpuScoreEl = root.querySelector("[data-cpu-score]");
          const roundEl = root.querySelector("[data-round]");
          const statusEl = root.querySelector("[data-status]");
          const historyEl = root.querySelector("[data-history]");
          const buttons = Array.from(root.querySelectorAll("button[data-choice]"));

          let round = 1;
          let playerWins = 0;
          let cpuWins = 0;
          let locked = false;
          const listeners = [];

          function resetGame() {
            round = 1;
            playerWins = 0;
            cpuWins = 0;
            locked = false;
            playerScoreEl.textContent = "0";
            cpuScoreEl.textContent = "0";
            roundEl.textContent = "1";
            statusEl.textContent = "Make your selection.";
            historyEl.innerHTML = "";
            footer.classList.add("hidden");
          }

          function addHistoryEntry(text) {
            const entry = document.createElement("div");
            entry.textContent = text;
            historyEl.prepend(entry);
          }

          function conclude(result) {
            locked = true;
            footer.innerHTML = "";
            footer.classList.remove("hidden");
            let message = "";
            let color = "#9ad9ff";
            if (result === "player") {
              message = "Victory! You outsmarted the CPU.";
              color = "#4dd0e1";
              manager.reward?.({
                tickets: 10,
                gold: 25,
                exp: 1,
                message: "Rock Duel Victory! +10 tickets, +25 gold, +1 EXP",
                color: "#4dd0e1",
                highScoreKey: "rps_wins",
                highScoreValue:
                  (window.st?.arcadeProgress?.highScores?.rps_wins || 0) + 1,
              });
            } else if (result === "cpu") {
              message = "CPU wins this time. Try again!";
              color = "#ff7a6a";
            } else {
              message = "It's a tie! No rewards this round.";
            }
            const summary = document.createElement("p");
            summary.className = "arcade-result-text";
            summary.style.color = color;
            summary.textContent = message;
            footer.appendChild(summary);

            const buttonRow = document.createElement("div");
            buttonRow.className = "arcade-button-row";
            const replay = document.createElement("button");
            replay.className = "arcade-btn";
            replay.textContent = "Play Again";
            const leave = document.createElement("button");
            leave.className = "arcade-btn secondary";
            leave.textContent = "Leave Machine";
            buttonRow.appendChild(replay);
            buttonRow.appendChild(leave);
            footer.appendChild(buttonRow);

            replay.addEventListener("click", () => {
              resetGame();
            });
            leave.addEventListener("click", () => manager.close?.({ reason: "user" }));
          }

          function playRound(choice) {
            if (locked) return;
            const cpuChoice =
              choices[Math.floor(Math.random() * choices.length)].id;
            let result = "tie";
            if (choice === cpuChoice) {
              statusEl.textContent = `Both chose ${choice}. Tie round.`;
              addHistoryEntry(`Round ${round}: Tie (${choice})`);
            } else if (beats[choice] === cpuChoice) {
              result = "player";
              playerWins += 1;
              playerScoreEl.textContent = String(playerWins);
              statusEl.textContent = `You chose ${choice}. CPU chose ${cpuChoice}. You win!`;
              addHistoryEntry(
                `Round ${round}: Player (${choice} beats ${cpuChoice})`
              );
            } else {
              result = "cpu";
              cpuWins += 1;
              cpuScoreEl.textContent = String(cpuWins);
              statusEl.textContent = `You chose ${choice}. CPU chose ${cpuChoice}. CPU wins.`;
              addHistoryEntry(
                `Round ${round}: CPU (${cpuChoice} beats ${choice})`
              );
            }

            if (playerWins >= 2 || cpuWins >= 2 || round >= 3) {
              conclude(
                playerWins > cpuWins
                  ? "player"
                  : cpuWins > playerWins
                    ? "cpu"
                    : "tie"
              );
            } else {
              round += 1;
              roundEl.textContent = String(round);
            }
          }

          for (const btn of buttons) {
            const handler = () => playRound(btn.dataset.choice);
            btn.addEventListener("click", handler);
            listeners.push({ btn, handler });
          }

          return {
            stop() {
              for (const { btn, handler } of listeners) {
                btn.removeEventListener("click", handler);
              }
              root.remove();
            },
          };
        }

        function createSlotsGame(ctx) {
          const { container, manager } = ctx;
          const root = document.createElement("div");
          root.className = "arcade-game slots-game";
          root.innerHTML = [
            '<h2 class="arcade-game-heading">Lucky Slots</h2>',
            '<p class="arcade-game-intro">Each spin costs 5 gold. Match symbols for rewards — triple 7s hit the jackpot!</p>',
            '<div class="slots-reels">',
            '  <div class="slots-reel" data-reel="0">🍒</div>',
            '  <div class="slots-reel" data-reel="1">💎</div>',
            '  <div class="slots-reel" data-reel="2">🔔</div>',
            "</div>",
            '<div class="slots-status" data-status>Try your luck!</div>',
            '<div class="slots-wallet" data-wallet></div>',
            '<div class="slots-controls">',
            '  <button class="arcade-btn" data-spin>Spin</button>',
            '  <button class="arcade-btn secondary" data-leave>Leave Machine</button>',
            "</div>",
          ].join("");
          container.appendChild(root);
          manager.setSubtitle?.(
            "Spin for prizes — jackpot awards 50 tickets, 100 gold, 1 EXP"
          );

          const reelEls = Array.from(root.querySelectorAll(".slots-reel"));
          const statusEl = root.querySelector("[data-status]");
          const walletEl = root.querySelector("[data-wallet]");
          const spinBtn = root.querySelector("[data-spin]");
          const leaveBtn = root.querySelector("[data-leave]");

          const symbols = [
            {
              id: "cherry",
              glyph: "🍒",
              color: "#ff6b9d",
              payouts: {
                three: { tickets: 25, gold: 70 },
                two: { tickets: 10, gold: 25 },
                one: { tickets: 3, gold: 10 },
              },
            },
            {
              id: "diamond",
              glyph: "💎",
              color: "#4dd0e1",
              payouts: {
                three: { tickets: 35, gold: 90 },
                two: { tickets: 14, gold: 35 },
              },
            },
            {
              id: "seven",
              glyph: "7️⃣",
              color: "#ffd54f",
              payouts: {
                three: { tickets: 50, gold: 100, exp: 1 },
                two: { tickets: 18, gold: 45 },
              },
            },
            {
              id: "bar",
              glyph: "BAR",
              color: "#ffe082",
              payouts: {
                three: { tickets: 28, gold: 80 },
                two: { tickets: 12, gold: 30 },
              },
            },
            {
              id: "bell",
              glyph: "🔔",
              color: "#ffa726",
              payouts: {
                three: { tickets: 22, gold: 65 },
                two: { tickets: 8, gold: 20 },
              },
            },
          ];

          const spinnerTimers = [];

          function updateWallet() {
            const st = window.st || {};
            walletEl.textContent = `Gold: ${st.gold || 0} | Tickets: ${st.tickets || 0
              }`;
          }

          function pickSymbol() {
            return symbols[Math.floor(Math.random() * symbols.length)];
          }

          function clearTimers() {
            while (spinnerTimers.length) {
              clearInterval(spinnerTimers.pop());
            }
          }

          function resolve(results) {
            const counts = {};
            results.forEach((s) => {
              counts[s.id] = (counts[s.id] || 0) + 1;
            });
            let rewarded = false;
            let message = "No matches this time. Better luck next spin!";
            let color = "#cfe3ff";

            const jackpot = Object.keys(counts).find((id) => counts[id] === 3);
            if (jackpot) {
              const symbol = symbols.find((s) => s.id === jackpot);
              const payout = symbol.payouts.three || {};
              manager.reward?.({
                tickets: payout.tickets || 0,
                gold: payout.gold || 0,
                exp: payout.exp || 0,
                message:
                  jackpot === "seven"
                    ? "JACKPOT! Triple 7s! +50 tickets, +100 gold, +1 EXP"
                    : `Triple ${symbol.glyph}! +${payout.tickets || 0} tickets, +${payout.gold || 0
                    } gold`,
                color: "#ffd54f",
                highScoreKey: "slots_jackpot",
                highScoreValue:
                  (window.st?.arcadeProgress?.highScores?.slots_jackpot || 0) + 1,
              });
              rewarded = true;
              color = "#ffd54f";
              message =
                jackpot === "seven"
                  ? "JACKPOT! Triple sevens!"
                  : `Triple ${symbol.glyph}!`;
            } else {
              const pair = Object.keys(counts).find((id) => counts[id] === 2);
              if (pair) {
                const symbol = symbols.find((s) => s.id === pair);
                const payout = symbol.payouts.two || {};
                if (payout.tickets || payout.gold) {
                  manager.reward?.({
                    tickets: payout.tickets || 0,
                    gold: payout.gold || 0,
                    message: `Two ${symbol.glyph}! +${payout.tickets || 0} tickets, +${payout.gold || 0
                      } gold`,
                    color: "#4dd0e1",
                  });
                  rewarded = true;
                  color = "#4dd0e1";
                  message = `Two ${symbol.glyph}!`;
                }
              } else {
                const cherry = counts.cherry || 0;
                if (cherry === 1) {
                  manager.reward?.({
                    tickets: 3,
                    gold: 10,
                    message: "Lucky cherry! +3 tickets, +10 gold",
                    color: "#ff6b9d",
                  });
                  rewarded = true;
                  color = "#ff6b9d";
                  message = "Lucky cherry!";
                }
              }
            }

            statusEl.style.color = color;
            statusEl.textContent = message;
            if (!rewarded && Math.random() < 0.05) {
              manager.showNotification?.(
                "Mystery consolation prize! +5 gold",
                "#9ad9ff"
              );
              const st = window.st || (window.st = {});
              st.gold = (st.gold || 0) + 5;
              try {
                window.refreshCurrencies?.();
              } catch (_) { }
            }
            updateWallet();
          }

          function spin() {
            const st = window.st || (window.st = {});
            if ((st.gold || 0) < 5) {
              statusEl.style.color = "#ff7a6a";
              statusEl.textContent = "You need 5 gold to spin.";
              return;
            }
            st.gold -= 5;
            try {
              window.refreshCurrencies?.();
            } catch (_) { }
            updateWallet();
            statusEl.style.color = "#cfe3ff";
            statusEl.textContent = "Spinning...";
            spinBtn.disabled = true;

            const finalResults = [pickSymbol(), pickSymbol(), pickSymbol()];
            reelEls.forEach((reelEl, idx) => {
              let tick = 0;
              const timer = setInterval(() => {
                const symbol = symbols[tick % symbols.length];
                reelEl.textContent = symbol.glyph;
                reelEl.style.color = symbol.color;
                tick += 1;
              }, 80 + idx * 20);
              spinnerTimers.push(timer);
              setTimeout(() => {
                clearInterval(timer);
                reelEl.textContent = finalResults[idx].glyph;
                reelEl.style.color = finalResults[idx].color;
                if (idx === reelEls.length - 1) {
                  spinBtn.disabled = false;
                  resolve(finalResults);
                }
              }, 900 + idx * 180);
            });
          }

          spinBtn.addEventListener("click", spin);
          leaveBtn.addEventListener("click", () =>
            manager.close?.({ reason: "user" })
          );
          updateWallet();

          return {
            stop() {
              clearTimers();
              spinBtn.removeEventListener("click", spin);
              leaveBtn.onclick = null;
              root.remove();
            },
          };
        }

        function createPlatformerGame(ctx) {
          const { container, manager } = ctx;
          const root = document.createElement("div");
          root.className = "arcade-game platformer-game";
          root.innerHTML = [
            '<h2 class="arcade-game-heading">Coin Climb</h2>',
            '<p class="arcade-game-intro">Collect 10 coins before the timer hits zero. Arrow keys move, Space jumps.</p>',
          ].join("");
          const canvasWrap = document.createElement("div");
          canvasWrap.className = "arcade-canvas-wrap";
          const canvas = document.createElement("canvas");
          canvas.width = 720;
          canvas.height = 420;
          canvasWrap.appendChild(canvas);
          const overlay = document.createElement("div");
          overlay.className = "arcade-overlay-panel hidden";
          canvasWrap.appendChild(overlay);
          root.appendChild(canvasWrap);
          container.appendChild(root);
          manager.setSubtitle?.(
            "Collect 10 coins in 30s — reward: 15 tickets, 30 gold, 1 EXP"
          );

          const ctx2d = canvas.getContext("2d");
          const keys = { left: false, right: false, jump: false };
          const gravity = 900;
          const moveSpeed = 260;
          const jumpVelocity = 420;
          const groundY = canvas.height - 60;
          const coinTotal = 10;

          let coins = [];
          let platforms = [];
          let player = null;
          let lastTime = 0;
          let timer = 30;
          let collected = 0;
          let rafId = null;
          let running = false;

          const placements = [
            { x: 100, y: groundY - 16 },
            { x: 220, y: groundY - 16 },
            { x: 320, y: groundY - 196 },
            { x: 380, y: groundY - 196 },
            { x: 440, y: groundY - 196 },
            { x: 560, y: groundY - 136 },
            { x: 620, y: groundY - 136 },
            { x: 160, y: groundY - 116 },
            { x: 280, y: groundY - 116 },
            { x: 480, y: groundY - 16 },
          ];

          function spawnPlatforms() {
            platforms = [
              { x: 100, y: groundY - 100, w: 160, h: 14 },
              { x: 320, y: groundY - 180, w: 200, h: 14 },
              { x: 560, y: groundY - 120, w: 150, h: 14 },
            ];
          }

          function spawnCoins() {
            coins = [];
            for (let i = 0; i < coinTotal; i++) {
              const spot = placements[i % placements.length];
              coins.push({
                x: spot.x,
                y: spot.y,
                collected: false,
                pulse: Math.random() * Math.PI * 2,
              });
            }
          }

          function resetPlayer() {
            player = {
              x: canvas.width * 0.15,
              y: groundY - 30,
              vx: 0,
              vy: 0,
              w: 26,
              h: 34,
              onGround: false,
            };
          }

          function resetGame() {
            spawnPlatforms();
            spawnCoins();
            resetPlayer();
            timer = 30;
            collected = 0;
            overlay.classList.add("hidden");
            running = true;
            lastTime = performance.now();
            cancelAnimationFrame(rafId);
            rafId = requestAnimationFrame(loop);
          }

          function finish(success) {
            running = false;
            cancelAnimationFrame(rafId);
            const resultCard = document.createElement("div");
            resultCard.className = `arcade-overlay-card ${success ? "success" : "failure"
              }`;
            resultCard.innerHTML = [
              `<h3>${success ? "Victory!" : "Time Up"}</h3>`,
              `<p>${success ? "You collected every coin!" : "You ran out of time."}</p>`,
              `<p>Coins collected: ${collected}/${coinTotal}</p>`,
              '<div class="arcade-button-row">',
              '  <button class="arcade-btn" data-retry>Play Again</button>',
              '  <button class="arcade-btn secondary" data-leave>Leave Machine</button>',
              "</div>",
            ].join("");
            overlay.innerHTML = "";
            overlay.appendChild(resultCard);
            overlay.classList.remove("hidden");

            const retryBtn = resultCard.querySelector("[data-retry]");
            const leaveBtn = resultCard.querySelector("[data-leave]");
            retryBtn.addEventListener("click", () => resetGame());
            leaveBtn.addEventListener("click", () =>
              manager.close?.({ reason: "user" })
            );

            if (success) {
              manager.reward?.({
                tickets: 15,
                gold: 30,
                exp: 1,
                message: "Coin Climb cleared! +15 tickets, +30 gold, +1 EXP",
                color: "#ffd54f",
                highScoreKey: "platformer_best_time",
                highScoreValue: Math.max(0, 30 - timer),
              });
            } else {
              manager.showNotification?.(
                "So close! Try again for the reward.",
                "#9ad9ff"
              );
            }
          }

          function handleKeyDown(e) {
            if (["ArrowLeft", "KeyA"].includes(e.code)) {
              keys.left = true;
              e.preventDefault();
            }
            if (["ArrowRight", "KeyD"].includes(e.code)) {
              keys.right = true;
              e.preventDefault();
            }
            if (["Space", "ArrowUp", "KeyW"].includes(e.code)) {
              if (!keys.jump && player?.onGround) {
                player.vy = -jumpVelocity;
                player.onGround = false;
              }
              keys.jump = true;
              e.preventDefault();
            }
          }

          function handleKeyUp(e) {
            if (["ArrowLeft", "KeyA"].includes(e.code)) {
              keys.left = false;
              e.preventDefault();
            }
            if (["ArrowRight", "KeyD"].includes(e.code)) {
              keys.right = false;
              e.preventDefault();
            }
            if (["Space", "ArrowUp", "KeyW"].includes(e.code)) {
              keys.jump = false;
              e.preventDefault();
            }
          }

          function update(dt) {
            if (!player) return;
            const prevY = player.y;
            player.vx = 0;
            if (keys.left) player.vx -= moveSpeed;
            if (keys.right) player.vx += moveSpeed;

            player.vy += gravity * dt;
            player.x += player.vx * dt;
            player.y += player.vy * dt;

            player.x = clamp(player.x, player.w / 2, canvas.width - player.w / 2);
            player.onGround = false;

            if (player.y + player.h / 2 >= groundY) {
              player.y = groundY - player.h / 2;
              player.vy = 0;
              player.onGround = true;
            } else {
              for (const plat of platforms) {
                const top = plat.y;
                if (
                  prevY + player.h / 2 <= top &&
                  player.y + player.h / 2 >= top &&
                  player.x + player.w / 2 > plat.x &&
                  player.x - player.w / 2 < plat.x + plat.w
                ) {
                  player.y = top - player.h / 2;
                  player.vy = 0;
                  player.onGround = true;
                  break;
                }
              }
            }

            coins.forEach((coin) => {
              if (coin.collected) return;
              const dist = Math.hypot(player.x - coin.x, player.y - coin.y);
              if (dist < 26) {
                coin.collected = true;
                collected += 1;
                manager.showNotification?.(
                  `Coin collected! ${collected}/${coinTotal}`,
                  "#ffb5e8"
                );
              }
              coin.pulse += dt * 4;
            });

            if (collected >= coinTotal) {
              finish(true);
            }

            timer -= dt;
            if (timer <= 0) {
              finish(false);
            }
          }

          function draw() {
            ctx2d.clearRect(0, 0, canvas.width, canvas.height);
            const bgGrad = ctx2d.createLinearGradient(0, 0, 0, canvas.height);
            bgGrad.addColorStop(0, "#0f172a");
            bgGrad.addColorStop(1, "#111827");
            ctx2d.fillStyle = bgGrad;
            ctx2d.fillRect(0, 0, canvas.width, canvas.height);

            ctx2d.fillStyle = "#1f2937";
            ctx2d.fillRect(0, groundY, canvas.width, canvas.height - groundY);
            ctx2d.fillStyle = "#374151";
            ctx2d.fillRect(0, groundY, canvas.width, 12);

            ctx2d.fillStyle = "#4c1d95";
            platforms.forEach((p) => {
              ctx2d.fillRect(p.x, p.y, p.w, p.h);
            });

            coins.forEach((coin) => {
              if (coin.collected) return;
              ctx2d.save();
              ctx2d.translate(coin.x, coin.y);
              ctx2d.scale(1, 1 + Math.sin(coin.pulse) * 0.1);
              ctx2d.fillStyle = "#ffd54f";
              ctx2d.beginPath();
              ctx2d.ellipse(0, 0, 10, 14, 0, 0, Math.PI * 2);
              ctx2d.fill();
              ctx2d.fillStyle = "#ffb72b";
              ctx2d.fillRect(-2, -12, 4, 24);
              ctx2d.restore();
            });

            if (player) {
              ctx2d.fillStyle = "#ff6b9d";
              ctx2d.fillRect(
                player.x - player.w / 2,
                player.y - player.h / 2,
                player.w,
                player.h
              );
              ctx2d.fillStyle = "#ffe9ff";
              ctx2d.fillRect(
                player.x - 6,
                player.y - player.h / 2 + 6,
                12,
                12
              );
            }

            ctx2d.fillStyle = "#cfe3ff";
            ctx2d.font = '16px "Press Start 2P", ui-monospace';
            ctx2d.fillText(`Coins: ${collected}/${coinTotal}`, 20, 32);
            ctx2d.fillText(`Time: ${Math.max(0, Math.ceil(timer))}s`, 20, 56);
          }

          function loop(now) {
            if (!running) return;
            const dt = Math.min(0.05, (now - lastTime) / 1000);
            lastTime = now;
            update(dt);
            draw();
            rafId = requestAnimationFrame(loop);
          }

          window.addEventListener("keydown", handleKeyDown, true);
          window.addEventListener("keyup", handleKeyUp, true);
          resetGame();

          return {
            stop() {
              running = false;
              cancelAnimationFrame(rafId);
              window.removeEventListener("keydown", handleKeyDown, true);
              window.removeEventListener("keyup", handleKeyUp, true);
              root.remove();
            },
          };
        }

        function createRacingGame(ctx) {
          const { container, manager } = ctx;
          const root = document.createElement("div");
          root.className = "arcade-game racing-game";
          root.innerHTML = [
            '<h2 class="arcade-game-heading">Hyper Drift</h2>',
            '<p class="arcade-game-intro">Complete 3 laps first! Arrow keys steer/accelerate. Avoid obstacles.</p>',
          ].join("");
          const canvasWrap = document.createElement("div");
          canvasWrap.className = "arcade-canvas-wrap";
          const canvas = document.createElement("canvas");
          canvas.width = 760;
          canvas.height = 420;
          canvasWrap.appendChild(canvas);
          const overlay = document.createElement("div");
          overlay.className = "arcade-overlay-panel hidden";
          canvasWrap.appendChild(overlay);
          root.appendChild(canvasWrap);
          container.appendChild(root);
          manager.setSubtitle?.(
            "Win the race — 1st: 20 tickets/40 gold/1 EXP, 2nd: 12/25, 3rd: 6/15"
          );

          const ctx2d = canvas.getContext("2d");
          const lanes = [canvas.width * 0.25, canvas.width * 0.5, canvas.width * 0.75];
          const keys = { left: false, right: false, up: false, down: false };
          const trackLength = 1200;
          const totalLaps = 3;

          let player;
          let opponents;
          let obstacles;
          let raceTime = 0;
          let running = false;
          let lastTime = null;
          let rafId = null;
          let laneCooldown = 0;

          function createOpponent(name, laneIdx, baseSpeed) {
            return {
              name,
              laneIdx,
              targetLane: laneIdx,
              x: lanes[laneIdx],
              y: canvas.height * 0.4,
              width: 36,
              height: 60,
              speed: baseSpeed,
              baseSpeed,
              distance: 0,
              laps: 0,
              finished: false,
              finishTime: 0,
              color: "#9ad9ff",
            };
          }

          function resetRace() {
            player = {
              laneIdx: 1,
              targetLane: 1,
              x: lanes[1],
              y: canvas.height - 70,
              width: 40,
              height: 70,
              speed: 0,
              maxSpeed: 360,
              acceleration: 260,
              decel: 280,
              distance: 0,
              laps: 0,
              finished: false,
              finishTime: 0,
              color: "#ff6b9d",
            };
            opponents = [
              createOpponent("Ryker", 0, 280),
              createOpponent("Nova", 1, 300),
              createOpponent("Flux", 2, 290),
            ];
            obstacles = [];
            raceTime = 0;
            laneCooldown = 0;
            overlay.classList.add("hidden");
            running = true;
            lastTime = performance.now();
            cancelAnimationFrame(rafId);
            rafId = requestAnimationFrame(loop);
          }

          function spawnObstacle() {
            obstacles.push({
              laneIdx: Math.floor(Math.random() * lanes.length),
              y: -80,
              width: 46,
              height: 46,
              hit: false,
            });
          }

          function playerProgress() {
            return player.laps * trackLength + player.distance;
          }

          function opponentProgress(op) {
            return op.laps * trackLength + op.distance;
          }

          function computePosition() {
            const standings = opponents
              .map((op) => ({ name: op.name, value: opponentProgress(op) }))
              .concat({ name: "You", value: playerProgress() })
              .sort((a, b) => b.value - a.value);
            return standings.findIndex((entry) => entry.name === "You") + 1;
          }

          function finishRace() {
            running = false;
            cancelAnimationFrame(rafId);
            const results = opponents
              .map((op) => ({
                name: op.name,
                time: op.finishTime || raceTime,
                finished: op.finished,
              }))
              .concat({
                name: "You",
                time: player.finishTime || raceTime,
                finished: player.finished,
              })
              .sort((a, b) => (a.time || Infinity) - (b.time || Infinity));

            const place = results.findIndex((r) => r.name === "You") + 1;
            const resultCard = document.createElement("div");
            resultCard.className = `arcade-overlay-card ${place === 1 ? "success" : place === 2 ? "neutral" : "failure"
              }`;
            resultCard.innerHTML = [
              `<h3>${place === 1
                ? "First Place!"
                : place === 2
                  ? "Second Place"
                  : place === 3
                    ? "Third Place"
                    : "Finished"
              }</h3>`,
              '<ol class="race-results">',
              results
                .map(
                  (r, idx) =>
                    `<li>${idx + 1}. ${r.name} — ${r.finished ? (r.time / 1000).toFixed(2) : "DNF"
                    }</li>`
                )
                .join(""),
              "</ol>",
              '<div class="arcade-button-row">',
              '  <button class="arcade-btn" data-retry>Race Again</button>',
              '  <button class="arcade-btn secondary" data-leave>Leave Machine</button>',
              "</div>",
            ].join("");
            overlay.innerHTML = "";
            overlay.appendChild(resultCard);
            overlay.classList.remove("hidden");

            const retryBtn = resultCard.querySelector("[data-retry]");
            const leaveBtn = resultCard.querySelector("[data-leave]");
            retryBtn.addEventListener("click", () => resetRace());
            leaveBtn.addEventListener("click", () =>
              manager.close?.({ reason: "user" })
            );

            if (place === 1) {
              manager.reward?.({
                tickets: 20,
                gold: 40,
                exp: 1,
                message: "Hyper Drift Champion! +20 tickets, +40 gold, +1 EXP",
                color: "#ffd54f",
                highScoreKey: "racing_best_time",
                highScoreValue: raceTime,
              });
            } else if (place === 2) {
              manager.reward?.({
                tickets: 12,
                gold: 25,
                message: "Second place bonus! +12 tickets, +25 gold",
                color: "#4dd0e1",
              });
            } else if (place === 3) {
              manager.reward?.({
                tickets: 6,
                gold: 15,
                message: "Third place prize! +6 tickets, +15 gold",
                color: "#9ad9ff",
              });
            } else {
              manager.showNotification?.(
                "Finish in the top 3 for rewards!",
                "#9ad9ff"
              );
            }
          }

          function handleKeyDown(e) {
            switch (e.code) {
              case "ArrowLeft":
              case "KeyA":
                keys.left = true;
                e.preventDefault();
                break;
              case "ArrowRight":
              case "KeyD":
                keys.right = true;
                e.preventDefault();
                break;
              case "ArrowUp":
              case "KeyW":
                keys.up = true;
                e.preventDefault();
                break;
              case "ArrowDown":
              case "KeyS":
                keys.down = true;
                e.preventDefault();
                break;
              default:
                break;
            }
          }

          function handleKeyUp(e) {
            switch (e.code) {
              case "ArrowLeft":
              case "KeyA":
                keys.left = false;
                e.preventDefault();
                break;
              case "ArrowRight":
              case "KeyD":
                keys.right = false;
                e.preventDefault();
                break;
              case "ArrowUp":
              case "KeyW":
                keys.up = false;
                e.preventDefault();
                break;
              case "ArrowDown":
              case "KeyS":
                keys.down = false;
                e.preventDefault();
                break;
              default:
                break;
            }
          }

          function update(dt) {
            if (laneCooldown > 0) laneCooldown -= dt;

            if (keys.up) {
              player.speed = Math.min(
                player.maxSpeed,
                player.speed + player.acceleration * dt
              );
            } else {
              player.speed = Math.max(0, player.speed - player.decel * dt);
            }
            if (keys.down) {
              player.speed = Math.max(
                0,
                player.speed - player.decel * dt * 2
              );
            }

            if (keys.left && laneCooldown <= 0 && player.targetLane > 0) {
              player.targetLane -= 1;
              laneCooldown = 0.25;
            }
            if (
              keys.right &&
              laneCooldown <= 0 &&
              player.targetLane < lanes.length - 1
            ) {
              player.targetLane += 1;
              laneCooldown = 0.25;
            }

            player.x += (lanes[player.targetLane] - player.x) * Math.min(1, dt * 10);
            player.distance += player.speed * dt;
            if (player.distance >= trackLength) {
              player.distance -= trackLength;
              player.laps += 1;
              if (player.laps >= totalLaps && !player.finished) {
                player.finished = true;
                player.finishTime = raceTime;
              }
            }

            obstacles.forEach((obs) => {
              obs.y += (player.speed + 200) * dt;
              if (
                !obs.hit &&
                obs.laneIdx === player.targetLane &&
                player.y - player.height / 2 < obs.y + obs.height &&
                player.y + player.height / 2 > obs.y
              ) {
                obs.hit = true;
                player.speed *= 0.5;
                manager.showNotification?.(
                  "Obstacle hit! Speed reduced.",
                  "#ffa726"
                );
              }
            });
            obstacles = obstacles.filter((obs) => obs.y < canvas.height + 80);

            opponents.forEach((op) => {
              if (op.finished) return;
              const variance =
                Math.sin((raceTime / 1000) + op.baseSpeed) * 20;
              op.speed = clamp(
                op.speed + ((op.baseSpeed + variance) - op.speed) * dt * 0.8,
                220,
                340
              );
              op.distance += op.speed * dt;
              if (op.distance >= trackLength) {
                op.distance -= trackLength;
                op.laps += 1;
                if (op.laps >= totalLaps) {
                  op.finished = true;
                  op.finishTime = raceTime;
                }
              }
              if (Math.random() < 0.01) {
                op.targetLane = clamp(
                  op.targetLane + (Math.random() < 0.5 ? -1 : 1),
                  0,
                  lanes.length - 1
                );
              }
              op.x += (lanes[op.targetLane] - op.x) * Math.min(1, dt * 6);
            });

            if (Math.random() < 0.015) {
              spawnObstacle();
            }

            if (player.finished && opponents.every((op) => op.finished)) {
              finishRace();
            }
          }

          function draw() {
            ctx2d.fillStyle = "#0f172a";
            ctx2d.fillRect(0, 0, canvas.width, canvas.height);

            ctx2d.fillStyle = "#1f2937";
            ctx2d.fillRect(canvas.width * 0.18, 0, canvas.width * 0.64, canvas.height);

            ctx2d.setLineDash([20, 20]);
            ctx2d.lineWidth = 4;
            ctx2d.strokeStyle = "rgba(207,227,255,0.35)";
            ctx2d.beginPath();
            for (const lane of lanes) {
              ctx2d.moveTo(lane, 0);
              ctx2d.lineTo(lane, canvas.height);
            }
            ctx2d.stroke();
            ctx2d.setLineDash([]);

            obstacles.forEach((obs) => {
              ctx2d.fillStyle = obs.hit
                ? "rgba(255,107,107,0.8)"
                : "rgba(255,214,102,0.9)";
              ctx2d.fillRect(
                lanes[obs.laneIdx] - obs.width / 2,
                obs.y,
                obs.width,
                obs.height
              );
              ctx2d.fillStyle = "#111827";
              ctx2d.fillRect(
                lanes[obs.laneIdx] - obs.width / 4,
                obs.y + 8,
                obs.width / 2,
                obs.height - 16
              );
            });

            opponents.forEach((op) => {
              ctx2d.fillStyle = op.color;
              const ypos = (op.distance / trackLength) * canvas.height * 0.8;
              ctx2d.fillRect(
                op.x - op.width / 2,
                canvas.height * 0.15 + ypos,
                op.width,
                op.height
              );
              ctx2d.fillStyle = "#0f172a";
              ctx2d.fillRect(
                op.x - op.width / 4,
                canvas.height * 0.15 + ypos + 10,
                op.width / 2,
                op.height / 2
              );
            });

            ctx2d.fillStyle = player.color;
            ctx2d.fillRect(
              player.x - player.width / 2,
              player.y - player.height / 2,
              player.width,
              player.height
            );
            ctx2d.fillStyle = "#0f172a";
            ctx2d.fillRect(
              player.x - player.width / 3,
              player.y - player.height / 4,
              (player.width / 3) * 2,
              player.height / 2
            );

            ctx2d.fillStyle = "#cfe3ff";
            ctx2d.font = '16px "Press Start 2P", ui-monospace';
            ctx2d.textAlign = "left";
            ctx2d.fillText(`Lap: ${Math.min(player.laps + 1, totalLaps)}/${totalLaps}`, 20, 32);
            ctx2d.fillText(`Speed: ${Math.round(player.speed)} km/h`, 20, 58);
            ctx2d.fillText(`Position: ${computePosition()}/${opponents.length + 1}`, 20, 84);
            ctx2d.textAlign = "right";
            ctx2d.fillText(`Time: ${(raceTime / 1000).toFixed(2)}s`, canvas.width - 20, 32);
          }

          function loop(now) {
            if (!running) return;
            if (lastTime == null) lastTime = now;
            const dt = Math.min(0.05, (now - lastTime) / 1000);
            lastTime = now;
            raceTime += dt * 1000;
            update(dt);
            draw();
            rafId = requestAnimationFrame(loop);
          }

          window.addEventListener("keydown", handleKeyDown, true);
          window.addEventListener("keyup", handleKeyUp, true);
          resetRace();

          return {
            stop() {
              running = false;
              cancelAnimationFrame(rafId);
              window.removeEventListener("keydown", handleKeyDown, true);
              window.removeEventListener("keyup", handleKeyUp, true);
              root.remove();
            },
          };
        }

        return {
          rps: (ctx) => createRpsGame(ctx),
          slots: (ctx) => createSlotsGame(ctx),
          platformer: (ctx) => createPlatformerGame(ctx),
          racing: (ctx) => createRacingGame(ctx),
        };
      })();

      const ArcadeMachineSystem = (() => {
        let overlay = null;
        let frame = null;
        let content = null;
        let titleEl = null;
        let subtitleEl = null;
        let closeBtn = null;
        let backdrop = null;
        let currentGame = null;
        let currentMachine = null;
        let stylesApplied = false;
        let escHandler = null;

        function ensureStyles() {
          if (stylesApplied) return;
          stylesApplied = true;
          const style = document.createElement("style");
          style.textContent = [
            ".arcade-mini-overlay{position:fixed;inset:0;background:rgba(2,6,23,0.82);display:none;align-items:center;justify-content:center;z-index:12000;}",
            ".arcade-mini-overlay.active{display:flex;}",
            ".arcade-mini-backdrop{position:absolute;inset:0;background:radial-gradient(circle at center,rgba(45,80,210,0.22),rgba(2,6,23,0.92));}",
            ".arcade-mini-frame{position:relative;display:flex;flex-direction:column;width:min(940px,92vw);height:min(92vh,680px);background:linear-gradient(160deg,rgba(14,24,44,0.95),rgba(38,20,68,0.92));border:1px solid rgba(148,163,184,0.35);border-radius:24px;box-shadow:0 28px 60px rgba(0,0,0,0.55);overflow:hidden;padding:18px 20px;gap:14px;outline:none;}",
            ".arcade-mini-header{display:flex;align-items:center;justify-content:space-between;gap:12px;}",
            '.arcade-mini-machine-name{font:600 22px "Press Start 2P",ui-monospace;color:#ffe9ff;}',
            '.arcade-mini-machine-subtitle{font:500 13px "Press Start 2P",ui-monospace;color:rgba(207,227,255,0.82);}',
            ".arcade-mini-close{background:rgba(15,23,42,0.65);color:#d1dcff;border:1px solid rgba(148,163,184,0.4);border-radius:12px;padding:6px 12px;font:600 12px 'Press Start 2P',ui-monospace;cursor:pointer;transition:background 160ms ease;}",
            ".arcade-mini-close:hover{background:rgba(59,130,246,0.35);}",
            ".arcade-mini-content{position:relative;flex:1;overflow:auto;padding:6px 4px 6px 0;}",
            ".arcade-game{display:flex;flex-direction:column;gap:12px;color:#f0f6ff;}",
            '.arcade-game-heading{margin:0;font:600 20px "Press Start 2P",ui-monospace;color:#ffe9ff;text-align:center;}',
            '.arcade-game-intro{margin:0;font:500 13px "Press Start 2P",ui-monospace;color:rgba(207,227,255,0.82);text-align:center;}',
            '.arcade-inline-score{display:flex;justify-content:center;gap:18px;font:600 14px "Press Start 2P",ui-monospace;color:#9ad9ff;}',
            ".arcade-btn{background:linear-gradient(135deg,#4f46e5,#8b5cf6);color:#fff;border:none;border-radius:12px;padding:10px 18px;font:600 12px 'Press Start 2P',ui-monospace;cursor:pointer;box-shadow:0 10px 22px rgba(91,70,255,0.35);transition:transform 140ms ease,box-shadow 140ms ease;}",
            ".arcade-btn:hover{transform:translateY(-2px);box-shadow:0 14px 28px rgba(91,70,255,0.45);}",
            ".arcade-btn.secondary{background:rgba(15,23,42,0.65);color:#d1dcff;border:1px solid rgba(148,163,184,0.45);box-shadow:none;}",
            ".arcade-btn.secondary:hover{background:rgba(30,41,59,0.9);box-shadow:0 10px 18px rgba(30,41,59,0.4);}",
            ".arcade-button-row{display:flex;justify-content:center;gap:12px;margin-top:12px;}",
            ".arcade-result-panel{margin-top:8px;text-align:center;}",
            ".arcade-result-panel.hidden{display:none;}",
            ".arcade-result-text{font:600 14px 'Press Start 2P',ui-monospace;margin:8px 0;}",
            ".rps-choices{display:flex;justify-content:center;gap:12px;}",
            ".rps-status{font:600 14px 'Press Start 2P',ui-monospace;color:#cfe3ff;text-align:center;}",
            ".rps-history{display:flex;flex-direction:column;gap:4px;max-height:140px;overflow:auto;font:500 11px 'Press Start 2P',ui-monospace;color:rgba(148,202,255,0.82);background:rgba(15,23,42,0.55);padding:10px;border-radius:12px;}",
            ".slots-reels{display:flex;justify-content:center;gap:16px;margin-top:8px;}",
            ".slots-reel{width:110px;height:140px;border-radius:20px;background:rgba(15,23,42,0.6);display:flex;align-items:center;justify-content:center;font:600 42px 'Press Start 2P',ui-monospace;color:#ffd54f;box-shadow:0 12px 26px rgba(15,23,42,0.35);}",
            ".slots-status{text-align:center;font:600 15px 'Press Start 2P',ui-monospace;margin-top:12px;}",
            ".slots-wallet{text-align:center;font:500 13px 'Press Start 2P',ui-monospace;color:rgba(207,227,255,0.75);}",
            ".slots-controls{display:flex;justify-content:center;gap:12px;margin-top:8px;}",
            ".arcade-canvas-wrap{position:relative;display:flex;justify-content:center;}",
            ".arcade-canvas-wrap canvas{border-radius:18px;border:1px solid rgba(148,163,184,0.3);background:#0f172a;}",
            ".arcade-overlay-panel{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(2,6,23,0.65);}",
            ".arcade-overlay-panel.hidden{display:none;}",
            ".arcade-overlay-card{background:linear-gradient(180deg,rgba(30,64,175,0.95),rgba(17,24,39,0.95));border:1px solid rgba(148,163,184,0.45);border-radius:18px;padding:26px;display:flex;flex-direction:column;gap:12px;width:min(380px,90%);text-align:center;box-shadow:0 24px 40px rgba(15,23,42,0.55);}",
            ".arcade-overlay-card.success{background:linear-gradient(180deg,rgba(2,132,199,0.95),rgba(17,24,39,0.95));}",
            ".arcade-overlay-card.failure{background:linear-gradient(180deg,rgba(185,28,28,0.92),rgba(17,24,39,0.95));}",
            ".arcade-overlay-card.neutral{background:linear-gradient(180deg,rgba(59,130,246,0.92),rgba(17,24,39,0.92));}",
            ".race-results{list-style:none;padding:0;margin:4px 0 0 0;font:500 12px 'Press Start 2P',ui-monospace;color:rgba(207,227,255,0.9);display:flex;flex-direction:column;gap:4px;}",
            ".race-results li{background:rgba(15,23,42,0.55);padding:6px;border-radius:10px;}",
          ].join("");
          document.head.appendChild(style);
        }

        function ensureOverlay() {
          if (overlay) return overlay;
          ensureStyles();
          overlay = document.createElement("div");
          overlay.className = "arcade-mini-overlay";
          overlay.setAttribute("role", "dialog");
          overlay.setAttribute("aria-hidden", "true");

          backdrop = document.createElement("div");
          backdrop.className = "arcade-mini-backdrop";
          overlay.appendChild(backdrop);

          frame = document.createElement("div");
          frame.className = "arcade-mini-frame";
          frame.setAttribute("tabindex", "-1");
          overlay.appendChild(frame);

          const header = document.createElement("header");
          header.className = "arcade-mini-header";
          frame.appendChild(header);

          const titleWrap = document.createElement("div");
          header.appendChild(titleWrap);

          titleEl = document.createElement("div");
          titleEl.className = "arcade-mini-machine-name";
          titleWrap.appendChild(titleEl);

          subtitleEl = document.createElement("div");
          subtitleEl.className = "arcade-mini-machine-subtitle";
          titleWrap.appendChild(subtitleEl);

          closeBtn = document.createElement("button");
          closeBtn.className = "arcade-mini-close";
          closeBtn.type = "button";
          closeBtn.textContent = "ESC";
          header.appendChild(closeBtn);

          content = document.createElement("div");
          content.className = "arcade-mini-content";
          frame.appendChild(content);

          document.body.appendChild(overlay);
          return overlay;
        }

        function focusFrame() {
          try {
            frame?.focus();
          } catch (_) { }
        }

        function showOverlay(machine) {
          ensureOverlay();
          overlay.classList.add("active");
          overlay.setAttribute("aria-hidden", "false");
          titleEl.textContent = machine?.name || "Arcade Machine";
          subtitleEl.textContent = machine?.gameType
            ? machine.gameType.toUpperCase()
            : "";
          content.innerHTML = "";
          focusFrame();
        }

        function hideOverlay() {
          if (!overlay) return;
          overlay.classList.remove("active");
          overlay.setAttribute("aria-hidden", "true");
          content.innerHTML = "";
        }

        function attachEsc() {
          if (escHandler) return;
          escHandler = (e) => {
            if (e.key === "Escape") {
              e.preventDefault();
              close({ reason: "escape" });
            }
          };
          window.addEventListener("keydown", escHandler, true);
        }

        function detachEsc() {
          if (escHandler) {
            window.removeEventListener("keydown", escHandler, true);
            escHandler = null;
          }
        }

        function showNotification(text, color) {
          try {
            notify?.(text, color || "#9ad9ff");
          } catch (_) {
            console.log(text);
          }
        }

        function setSubtitle(text) {
          if (subtitleEl) subtitleEl.textContent = text || "";
        }

        function reward(payload) {
          if (!payload) return;
          if (typeof payload === "number") {
            giveArcadeRewards(payload || 0, 0, 0);
            return;
          }
          const {
            tickets = 0,
            gold = 0,
            exp = 0,
            message,
            color,
            highScoreKey,
            highScoreValue,
          } = payload;
          giveArcadeRewards(tickets, gold, exp, { highScoreKey, highScoreValue });
          if (message) {
            showNotification(message, color || "#ffd54f");
          }
        }

        function close(reason) {
          if (currentGame?.stop) {
            try {
              currentGame.stop();
            } catch (err) {
              console.warn("[ArcadeMachineSystem] stop error", err);
            }
          }
          currentGame = null;
          currentMachine = null;
          hideOverlay();
          detachEsc();
          try {
            RunnerStateControl.resume();
          } catch (_) { }
          try {
            if (window.HouseInterior?.arcadeState) {
              window.HouseInterior.arcadeState.highlightMachineId = null;
              window.HouseInterior.arcadeState.prompt = "";
            }
          } catch (_) { }
          if (reason?.reason !== "switch") {
            showNotification?.("Exited arcade machine.", "#9ad9ff");
          }
        }

        function start(machine) {
          if (!machine) {
            showNotification("Machine offline.", "#ff7a6a");
            return;
          }
          if (currentMachine && currentMachine.id === machine.id) {
            return;
          }

          if (currentGame) {
            close({ reason: "switch" });
          }

          currentMachine = machine;
          showOverlay(machine);

          try {
            RunnerStateControl.freeze();
          } catch (_) { }
          attachEsc();

          const managerProxy = {
            machine,
            reward,
            showNotification,
            setSubtitle,
            close: (info) => close(info || { reason: "game" }),
          };

          if (machine.gameType && !ArcadeGames[machine.gameType]) {
            showNotification("This machine is under maintenance.", "#ff7a6a");
            close({ reason: "maintenance" });
            return;
          }

          if (machine.gameType === "missy") {
            close({ reason: "switch" });
            try {
              window.MissyArcadeGame?.activate({
                source: machine.id || "arcade-machine",
              });
            } catch (err) {
              console.warn("Missy arcade launch failed", err);
            }
            return;
          }

          content.scrollTop = 0;
          const gameFactory = ArcadeGames[machine.gameType];
          if (!gameFactory) {
            showNotification("Unknown machine type.", "#ff7a6a");
            close({ reason: "unknown" });
            return;
          }
          try {
            currentGame = gameFactory({
              container: content,
              manager: managerProxy,
              machine,
            });
          } catch (err) {
            console.error("[ArcadeMachineSystem] Failed to start game", err);
            showNotification("Machine failed to start.", "#ff7a6a");
            close({ reason: "error" });
            return;
          }

          if (!currentGame || typeof currentGame.stop !== "function") {
            console.warn(
              "[ArcadeMachineSystem] Game did not return cleanup handler."
            );
          }

          backdrop.onclick = () => close({ reason: "backdrop" });
          closeBtn.onclick = () => close({ reason: "user" });
          frame.addEventListener("keydown", (e) => e.stopPropagation(), true);
        }

        return {
          start,
          close,
          isActive() {
            return !!currentMachine;
          },
          reward,
          showNotification,
          setSubtitle,
        };
      })();
      window.ArcadeMachineSystem = ArcadeMachineSystem;

      const ArcadeSessionRewards = {
        historyKey: 'missyArcadeRewardHistory',
        sessionKey: 'missyArcadeCurrent',
        session: null,
        history: [],
        loadHistory() {
          try {
            const raw = localStorage.getItem(this.historyKey);
            if (raw) this.history = JSON.parse(raw) || [];
          } catch (_) {
            this.history = [];
          }
        },
        saveHistory() {
          try { localStorage.setItem(this.historyKey, JSON.stringify(this.history || [])); } catch (_) { }
        },
        saveSession() {
          if (!this.session) { this.clearSession(); return; }
          try { localStorage.setItem(this.sessionKey, JSON.stringify(this.session)); } catch (_) { }
        },
        clearSession() {
          try { localStorage.removeItem(this.sessionKey); } catch (_) { }
        },
        startSession() {
          this.session = {
            startedAt: Date.now(),
            levels: [],
            totalGold: 0,
            totalStars: 0,
            totalTimeMs: 0,
            totalScore: 0,
            totalMovesRemaining: 0,
            totalMaxCombo: 0
          };
          this.saveSession();
          return this.session;
        },
        computeBase(level) {
          const lv = Math.max(1, Math.min(120, Math.floor(level || 1)));
          if (lv <= 10) return 1000 + lv * 100;
          if (lv <= 30) return 2500 + lv * 200;
          if (lv <= 60) return 10000 + lv * 500;
          if (lv <= 90) return 50000 + lv * 1000;
          return 200000 + lv * 5000;
        },
        computeReward(info) {
          const base = this.computeBase(info?.level);
          const stars = info?.stars || 1;
          const starMult = stars >= 3 ? 2 : stars === 2 ? 1.5 : 1;
          const score = Math.max(0, Math.floor(info?.score || 0));
          const movesRemaining = Math.max(0, Math.floor(info?.movesRemaining || 0));
          const maxCombo = Math.max(0, Math.floor(info?.maxCombo || 0));
          const scoreBonus = Math.round((score / 1000) * 50);
          const timeBonus = movesRemaining * 100;
          const comboBonus = maxCombo * 250;
          const total = Math.max(0, Math.round(base * starMult + scoreBonus + timeBonus + comboBonus));
          return { base, starMult, scoreBonus, timeBonus, comboBonus, total };
        },
        recordLevel(info) {
          if (!this.session) this.startSession();
          const entry = Object.assign({ timeSpent: 0 }, info || {});
          const reward = this.computeReward(entry);
          entry.reward = reward;
          this.session.levels.push(entry);
          this.session.totalGold += reward.total;
          this.session.totalStars += entry.stars || 0;
          this.session.totalTimeMs += entry.timeSpent || 0;
          this.session.totalScore += entry.score || 0;
          this.session.totalMovesRemaining += entry.movesRemaining || 0;
          this.session.totalMaxCombo += entry.maxCombo || 0;
          this.saveSession();
          return entry;
        },
        finalize() {
          if (!this.session) return null;
          const summary = {
            startedAt: this.session.startedAt,
            endedAt: Date.now(),
            totalGold: this.session.totalGold,
            totalStars: this.session.totalStars,
            totalTimeMs: this.session.totalTimeMs,
            totalScore: this.session.totalScore,
            totalMovesRemaining: this.session.totalMovesRemaining,
            totalMaxCombo: this.session.totalMaxCombo,
            levelsCompleted: this.session.levels.filter(l => (l?.reward?.total || 0) > 0).length,
            levels: this.session.levels.slice()
          };
          this.history = this.history || [];
          this.history.push(summary);
          if (this.history.length > 25) this.history.shift();
          this.saveHistory();
          this.session = null;
          this.clearSession();
          return summary;
        }
      };
      ArcadeSessionRewards.loadHistory();

      const MissyArcadeGame = {
        active: false,
        overlay: null,
        iframe: null,
        transitionLayer: null,
        loadingEl: null,
        summaryPanel: null,
        confirmPanel: null,
        ready: false,
        queue: [],
        ensureStyles: ensureArcadeStyles,
        ensureOverlay() {
          if (this.overlay) return this.overlay;
          const overlay = document.createElement('div');
          overlay.id = 'missyArcadeOverlay';
          overlay.className = 'missy-arcade-overlay';
          overlay.innerHTML = '<div class="missy-arcade-transition"><div class="missy-arcade-loading">Loading Arcade...</div></div>';
          document.body.appendChild(overlay);
          this.overlay = overlay;
          this.transitionLayer = overlay.querySelector('.missy-arcade-transition');
          this.loadingEl = overlay.querySelector('.missy-arcade-loading');
          return overlay;
        },
        buildSrcdoc,
        activate(options) {
          if (this.active) {
            if (this.overlay) this.overlay.classList.add('active');
            return;
          }
          this.ensureStyles();
          ArcadeSessionRewards.startSession();
          RunnerStateControl.freeze();
          document.body.classList.add('missy-arcade-active');
          this.active = true;
          this.ready = false;
          this.queue = [];
          this.ensureOverlay();
          if (this.overlay) {
            this.overlay.classList.add('active');
            this.overlay.classList.remove('fade-out');
          }
          if (this.transitionLayer) {
            this.transitionLayer.classList.remove('hidden');
          }
          if (this.loadingEl) this.loadingEl.textContent = 'Loading Arcade...';
          if (typeof notify === 'function') {
            try { notify('Entering Missy Arcade...', '#ff93d3'); } catch (_) { }
          }
          this.mountIframe();
        },
        mountIframe() {
          if (!this.overlay) this.ensureOverlay();
          if (this.iframe) {
            try { this.iframe.remove(); } catch (_) { }
          }
          const iframe = document.createElement('iframe');
          iframe.className = 'missy-arcade-frame';
          iframe.setAttribute('sandbox', 'allow-scripts allow-same-origin allow-modals');
          iframe.src = 'Missy Arcade.html';
          this.iframe = iframe;
          this.overlay?.appendChild(iframe);
          iframe.addEventListener('load', () => {
            if (this.loadingEl) this.loadingEl.textContent = 'Starting Missy Arcade...';
            // Fallback: if child never posts 'ready', auto-continue
            try { clearTimeout(this._readyFallbackT); } catch (_) { }
            this._readyFallbackT = setTimeout(() => {
              if (!this.ready) {
                console.warn('[MissyArcade] No ready message received, using fallback.');
                this.onChildReady();
              }
            }, 1500);
          });
        },
        postToChild(type, payload) {
          const message = { from: 'RunnerArcade', type, payload };
          if (this.ready && this.iframe?.contentWindow) {
            try { this.iframe.contentWindow.postMessage(message, '*'); return; } catch (err) { }
          }
          this.queue.push(message);
        },
        flushQueue() {
          if (!this.ready || !this.iframe?.contentWindow) return;
          const pending = this.queue.splice(0);
          for (const msg of pending) {
            try { this.iframe.contentWindow.postMessage(msg, '*'); } catch (_) { }
          }
        },
        handleMessage(event) {
          const data = event?.data;
          if (!data || data.from !== 'MissyArcade') return;
          if (!this.active && data.type !== 'ready') return;
          switch (data.type) {
            case 'ready':
              this.onChildReady(data.payload);
              break;
            case 'level-start':
              this.handleLevelStart(data.payload);
              break;
            case 'level-complete':
              this.handleLevelComplete(data.payload);
              break;
            case 'level-failed':
              this.handleLevelFailed(data.payload);
              break;
            case 'exit-request':
              this.handleExitRequest(data.payload);
              break;
            default:
              break;
          }
        },
        onChildReady() {
          try { clearTimeout(this._readyFallbackT); } catch (_) { }
          this.ready = true;
          this.flushQueue();
          if (this.transitionLayer) {
            requestAnimationFrame(() => this.transitionLayer?.classList.add('hidden'));
          }
          if (this.loadingEl) this.loadingEl.textContent = 'Arcade Ready!';
          this.postToChild('session-start', { startedAt: Date.now() });
        },
        handleLevelStart(payload) {
          this.currentLevel = payload?.level || null;
        },
        formatGold(value) {
          try { return value.toLocaleString(); } catch (_) { return String(value); }
        },
        handleLevelComplete(payload) {
          const entry = ArcadeSessionRewards.recordLevel(payload || {});
          const gold = entry?.reward?.total || 0;
          if (gold > 0) {
            this.postToChild('reward-notice', { text: `+${this.formatGold(gold)} Gold!` });
            if (typeof notify === 'function') {
              try { notify(`+${this.formatGold(gold)} Gold! (Arcade)`, '#ffd56a'); } catch (_) { }
            }
          }
        },
        handleLevelFailed(payload) {
          if (!payload) return;
          // still track time spent in session totals if desired later
        },
        requestExit() {
          this.handleExitRequest({ manual: true });
        },
        handleExitRequest(payload) {
          if (!this.active) return;
          if (this.confirmPanel) return;
          const hasProgress = (ArcadeSessionRewards.session?.levels?.length || 0) > 0;
          const overlay = this.ensureOverlay();
          const confirm = document.createElement('div');
          confirm.className = 'missy-arcade-confirm';
          confirm.innerHTML = [
            '<h3>Exit Missy Arcade?</h3>',
            `<p>${hasProgress ? 'You have uncollected session rewards.' : 'Return to the runner world?'}</p>`,
            '<div class="missy-arcade-confirm-actions">',
            '  <button class="missy-arcade-button-secondary">Cancel</button>',
            '  <button class="missy-arcade-button-primary">Exit</button>',
            '</div>'
          ].join('');
          const [cancelBtn, exitBtn] = confirm.querySelectorAll('button');
          cancelBtn.onclick = () => {
            confirm.remove();
            this.confirmPanel = null;
            this.postToChild('session-summary', { headline: 'Exit cancelled' });
          };
          exitBtn.onclick = () => {
            confirm.remove();
            this.confirmPanel = null;
            this.finalizeAndSummarize('player');
          };
          overlay.appendChild(confirm);
          this.confirmPanel = confirm;
        },
        finalizeAndSummarize(source) {
          const summary = ArcadeSessionRewards.finalize();
          const totalGold = summary?.totalGold || 0;
          if (totalGold > 0) {
            const st = window.st || (window.st = {});
            st.gold = (st.gold || 0) + totalGold;
            try { updateCurrencies?.(); } catch (_) { }
            if (typeof notify === 'function') {
              try { notify(`+${this.formatGold(totalGold)} Gold added to Runner!`, '#ffd56a'); } catch (_) { }
            }
          }
          if (typeof notify === 'function') {
            try { notify('Arcade Session Complete!', '#ff93d3'); } catch (_) { }
          }
          this.postToChild('session-summary', { headline: 'Session Complete!' });
          this.showSummary(summary, source);
        },
        showSummary(summary, source) {
          if (this.iframe) {
            try { this.iframe.remove(); } catch (_) { }
            this.iframe = null;
          }
          const overlay = this.ensureOverlay();
          const totalGold = summary?.totalGold || 0;
          const levelsCompleted = summary?.levels?.length || 0;
          const totalStars = summary?.totalStars || 0;
          const totalTime = summary?.totalTimeMs || 0;
          const avgGold = levelsCompleted ? Math.round(totalGold / levelsCompleted) : 0;
          const minutes = Math.floor(totalTime / 60000);
          const seconds = Math.floor((totalTime % 60000) / 1000);
          const timeLabel = `${minutes}m ${seconds.toString().padStart(2, '0')}s`;
          const summaryPanel = document.createElement('div');
          summaryPanel.className = 'missy-arcade-summary';
          summaryPanel.innerHTML = [
            '<h2>Arcade Session Summary</h2>',
            `<p>${source === 'player' ? 'Hope you had fun!' : 'Arcade session ended.'}</p>`,
            '<div class="summary-grid">',
            `<div class="metric"><span>Levels Completed</span><strong>${levelsCompleted}</strong></div>`,
            `<div class="metric"><span>Total Stars</span><strong>${totalStars}</strong></div>`,
            `<div class="metric"><span>Total Gold</span><strong>${this.formatGold(totalGold)}</strong></div>`,
            `<div class="metric"><span>Avg Gold / Level</span><strong>${this.formatGold(avgGold)}</strong></div>`,
            `<div class="metric"><span>Time in Arcade</span><strong>${timeLabel}</strong></div>`,
            `<div class="metric"><span>Total Score</span><strong>${this.formatGold(summary?.totalScore || 0)}</strong></div>`,
            '</div>',
            '<button class="missy-arcade-button">Return to Runner</button>'
          ].join('');
          const returnBtn = summaryPanel.querySelector('button');
          returnBtn.onclick = () => this.completeReturn();
          overlay.appendChild(summaryPanel);
          this.summaryPanel = summaryPanel;
        },
        completeReturn() {
          if (this.summaryPanel) {
            try { this.summaryPanel.remove(); } catch (_) { }
            this.summaryPanel = null;
          }
          if (this.overlay) {
            this.overlay.classList.add('fade-out');
          }
          setTimeout(() => {
            try { this.overlay?.remove(); } catch (_) { }
            this.overlay = null;
          }, 320);
          document.body.classList.remove('missy-arcade-active');
          RunnerStateControl.resume();
          this.active = false;
          this.ready = false;
          this.queue = [];
        },
        deactivate() {
          if (!this.active) return;
          this.finalizeAndSummarize('forced');
        },
        cleanup() {
          if (this.overlay) {
            try { this.overlay.remove(); } catch (_) { }
          }
          this.overlay = null;
          this.iframe = null;
          this.transitionLayer = null;
          this.loadingEl = null;
          this.summaryPanel = null;
          this.confirmPanel = null;
          this.queue = [];
          this.active = false;
          this.ready = false;
          document.body.classList.remove('missy-arcade-active');
          RunnerStateControl.resume();
        },
        render() {
          this.ensureOverlay();
          this.overlay?.classList.add('active');
        }
      };

      window.ArcadeSessionRewards = ArcadeSessionRewards;
      window.MissyArcadeGame = MissyArcadeGame;
      window.ArcadeGameState = {
        pause: () => RunnerStateControl.freeze(),
        resume: () => RunnerStateControl.resume()
      };

      function applyBufferedMissyArcadeGold() {
        try {
          const key = 'missyArcadeBufferedGold';
          const stored = parseInt(localStorage.getItem(key) || '0', 10) || 0;
          if (stored > 0) {
            localStorage.removeItem(key);
            const st = window.st || (window.st = {});
            st.gold = (st.gold || 0) + stored;
            try { updateCurrencies?.(); } catch (_) { }
            if (typeof notify === 'function') {
              try { notify(`+${stored} Gold from Arcade time!`, '#FF69B4'); } catch (_) { }
            }
          }
        } catch (_) { }
      }

      applyBufferedMissyArcadeGold();

      window.addEventListener('message', (event) => {
        const data = event?.data;
        if (data && data.from === 'MissyArcade') {
          if (data.type === 'time-reward') {
            const payload = data.payload || {};
            const goldEarned = payload.goldEarned || 0;
            if (goldEarned > 0) {
              const st = window.st || (window.st = {});
              st.gold = (st.gold || 0) + goldEarned;
              try { updateCurrencies?.(); } catch (_) { }
              if (typeof notify === 'function') {
                try { notify(`+${goldEarned} Gold from Arcade time!`, '#FF69B4'); } catch (_) { }
              }
            }
          }
        }
        try { MissyArcadeGame?.handleMessage?.(event); } catch (_) { }
      });
    })();
  </script>

  <script id="house-ui-inline">
    (function () {
      if (window.HouseUI) return;
      function ensureDialog() { let el = document.getElementById('enterDialog'); if (el) return el; el = document.createElement('div'); el.id = 'enterDialog'; el.className = 'enter-dialog'; el.innerHTML = '<div id="enterBox" class="enter-dialog-box"><div class="enter-dialog-title">Enter House?</div><div class="enter-dialog-buttons"><button id="enterYes" class="enter-dialog-btn-yes">Yes</button><button id="enterNo" class="enter-dialog-btn-no">No</button></div></div>'; document.body.appendChild(el); return el; }
      window.HouseUI = {
        confirmEnter(onYes) { const el = ensureDialog(); el.style.display = 'flex'; el.querySelector('#enterYes').onclick = () => { el.style.display = 'none'; try { onYes && onYes(); } catch (_) { } }; el.querySelector('#enterNo').onclick = () => { el.style.display = 'none'; }; }
      };
    })();
  </script>

  <!-- Legacy scroll system fully removed -->
  <style>
    :root {
      --bg: #0d131c;
      --ink: #e9f4ff;
      --muted: #a8b7ce;
      --line: #293854;
      --panel: #121b20;
      --panel2: #0f1826;
      --panel3: #0b1421;
      --hp: #36c777;
      --hp2: #6de38e;
      --mp: #3ec5ff;
      --mp2: #6aa8ff;
      --boss: #ff8c6a;
      --boss2: #ffbb9a;
      --rage: #f9cc2b;
      --rage2: #ff7a31;
      --pastel-pet: #c1ffc1;
      --pastel-action: #add8e6;
      --pastel-veh: #e6e6fa;
      --pastel-attack: #ff6666;
      /* A nice red color */
    }

    /* New Pixel Art Button Cluster Styles */
    .rightDock {
      position: fixed;
      right: 14px;
      bottom: 14px;
      display: flex;
      flex-direction: column;
      gap: 6px;
      align-items: flex-end;
      z-index: 1000;
      pointer-events: auto;
    }

    .rightDock .row,
    .rightDock .sRow {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .rightDock .btn {
      cursor: pointer;
      border: 4px solid #000;
      background: rgba(42, 36, 54, 0.9);
      color: #dfe9ff;
      padding: 8px 10px;
      font-family: 'Press Start 2P', cursive;
      font-size: 10px;
      image-rendering: pixelated;
      box-shadow: inset -2px -2px 0 0 rgba(0, 0, 0, .3);
    }

    .rightDock .btn:active {
      box-shadow: inset 2px 2px 0 0 rgba(0, 0, 0, .3);
      transform: translate(1px, 1px);
    }

    /* Glow state for Act button when near house/exit */
    #btnActionNew.glow {
      box-shadow: 0 0 12px rgba(159, 215, 255, .9), 0 0 6px rgba(159, 215, 255, .6) inset;
      border-color: #9fd7ff !important;
      outline: 1px solid rgba(159, 215, 255, .65);
      filter: saturate(1.25);
    }

    .rightDock .btn.small {
      padding: 5px 8px;
      font-size: 10px;
    }

    .rightDock .btn.big {
      width: 96px;
      height: 96px;
      font-weight: 800;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .rightDock .btn.border-ink {
      border-color: #ffc800;
    }

    .rightDock .btn.ready {
      animation: ready-glow 1s infinite alternate;
    }

    @keyframes ready-glow {
      from {
        box-shadow: 0 0 5px #ffc800;
      }

      to {
        box-shadow: 0 0 15px #ffc800;
      }
    }
  </style>

  <script>
    // Draw an anime-style X slash for a shot 's'
    function drawAnimeX(ctx, s) {
      const len = Math.max(20, ((s.size || s.r || s.aoe || 32)) * 3.25);
      // draw ribbon trail (back-to-front)
      if (s.trail && s.trail.length > 1) {
        ctx.save();
        ctx.globalCompositeOperation = 'lighter';
        for (let i = s.trail.length - 1; i >= 1; i--) {
          const a = (i / s.trail.length) * 0.6; // alpha falloff
          const p1 = s.trail[i];
          const p2 = s.trail[i - 1];
          if (!p1 || !p2) continue;
          ctx.strokeStyle = s.colorEdge || 'rgba(255,220,180,0.7)';
          ctx.lineWidth = (1 + (i / s.trail.length) * 6) * ((s.aoe || 32) / 32);
          ctx.globalAlpha = a * 0.9;
          ctx.beginPath();
          ctx.moveTo(p1.x, p1.y);
          ctx.lineTo(p2.x, p2.y);
          ctx.stroke();
        }
        ctx.restore();
      }

      // main X strokes with rim and core
      ctx.save();
      ctx.lineCap = 'round';
      // additive bloom rim
      ctx.globalCompositeOperation = 'lighter';
      ctx.strokeStyle = s.color2 || '#000000';
      ctx.lineWidth = 7 * ((s.size || s.aoe || 32) / 32);
      ctx.globalAlpha = 0.9;
      ctx.beginPath(); ctx.moveTo(s.x - len * 0.5, s.y - len * 0.5); ctx.lineTo(s.x + len * 0.5, s.y + len * 0.5); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(s.x - len * 0.5, s.y + len * 0.5); ctx.lineTo(s.x + len * 0.5, s.y - len * 0.5); ctx.stroke();

      // core
      ctx.strokeStyle = s.color || '#ff2d2d';
      ctx.lineWidth = 4 * ((s.size || s.aoe || 32) / 32);
      ctx.globalAlpha = 1.0;
      ctx.beginPath(); ctx.moveTo(s.x - len * 0.5, s.y - len * 0.5); ctx.lineTo(s.x + len * 0.5, s.y + len * 0.5); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(s.x - len * 0.5, s.y + len * 0.5); ctx.lineTo(s.x + len * 0.5, s.y - len * 0.5); ctx.stroke();

      // soft bloom (draw a translucent larger stroke)
      if (s.bloom && s.bloom > 0) {
        ctx.strokeStyle = s.color || 'rgba(255,45,45,0.6)';
        ctx.lineWidth = (10 + (s.bloom * 20)) * ((s.size || s.aoe || 32) / 32);
        ctx.globalAlpha = 0.12 * s.bloom;
        ctx.beginPath(); ctx.moveTo(s.x - len * 0.5, s.y - len * 0.5); ctx.lineTo(s.x + len * 0.5, s.y + len * 0.5); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(s.x - len * 0.5, s.y + len * 0.5); ctx.lineTo(s.x + len * 0.5, s.y - len * 0.5); ctx.stroke();
      }

      ctx.restore();
    }
  </script>

  <style>
    html,
    body {
      margin: 0;
      height: 100%;
      background: var(--bg);
      color: var(--ink);
      font: 14px/1.4 system-ui, Segoe UI, Roboto, Arial, sans-serif
    }

    * {
      box-sizing: border-box
    }

    #wrap {
      position: relative;
      margin: 0 auto;
      max-width: 1280px;
      height: 100vh;
      overflow: hidden;
      border-left: 1px solid var(--line);
      border-right: 1px solid var(--line)
    }

    canvas {
      display: block;
      image-rendering: -webkit-optimize-contrast;
      image-rendering: pixelated;
      background: linear-gradient(#0c1420, #0a1018)
    }

    .hud {
      position: absolute;
      left: 10px;
      right: 10px;
      top: 8px;
      display: flex;
      gap: 10px;
      align-items: center;
      pointer-events: none;
      flex-wrap: wrap
    }

    .pill {
      pointer-events: auto;
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 6px 10px;
      font-size: 12px;
      color: var(--muted)
    }

    .bar {
      position: relative;
      height: 12px;
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 999px;
      overflow: hidden;
      min-width: 200px
    }

    .fill {
      position: absolute;
      inset: 0;
      transform-origin: left center
    }

    .hp {
      background: linear-gradient(90deg, var(--hp), var(--hp2))
    }

    .mp {
      background: linear-gradient(90deg, var(--mp), var(--mp2))
    }

    .boss {
      background: linear-gradient(90deg, var(--boss), var(--boss2))
    }

    .xp {
      background: linear-gradient(90deg, #2EA8FF, #7B61FF)
    }

    .xpText {
      position: absolute;
      left: 0;
      right: 0;
      top: -16px;
      text-align: center;
      font-weight: 700;
      font-size: 12px;
      color: #a8b7ce;
      text-shadow: 0 1px 2px #000
    }

    /* Quest tier tags */
    .quest-tier {
      font-size: 10px;
      padding: 2px 4px;
      border-radius: 3px;
      margin-left: 4px;
      display: inline-block;
    }

    .quest-tier.bronze {
      background: #8d5524;
      color: #ffe6b3;
    }

    .quest-tier.silver {
      background: #8a8a8a;
      color: #f5f5f5;
    }

    .quest-tier.gold {
      background: #d4af37;
      color: #fff8d4;
    }

    #xpDomFill.pulse {
      animation: xpGlow .6s ease-out
    }

    @keyframes xpGlow {
      0% {
        box-shadow: 0 0 0 rgba(123, 97, 255, 0)
      }

      50% {
        box-shadow: 0 0 10px rgba(123, 97, 255, .9)
      }

      100% {
        box-shadow: 0 0 0 rgba(123, 97, 255, 0)
      }
    }

    .subdock {
      position: absolute;
      left: 10px;
      top: 70px;
      display: flex;
      gap: 8px;
      pointer-events: auto;
      flex-wrap: wrap
    }

    .companion-panel {
      position: fixed;
      display: none;
      flex-direction: column;
      gap: 6px;
      padding: 0;
      border-radius: 12px;
      background: transparent;
      /* remove overlay */
      border: 0;
      box-shadow: none;
      color: #f5f3ff;
      z-index: 4200;
      pointer-events: none;
      min-width: 160px;
      max-width: 320px;
      align-items: stretch;
    }

    .companion-panel.visible {
      display: flex;
    }

    #companionHUD {
      right: 24px;
      top: 178px;
    }

    #teamCompanionPanel {
      top: 0;
      left: 0;
    }

    .companion-panel-card {
      position: relative;
      border: 1px solid rgba(255, 214, 106, 0.55);
      border-radius: 10px;
      background: rgba(22, 24, 38, 0.9);
      padding: 6px 8px 8px;
      box-shadow: inset 0 0 0 1px rgba(255, 214, 106, 0.12);
    }

    .companion-panel-top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 6px;
      font-size: 12px;
      letter-spacing: 0.3px;
    }

    .companion-panel-name {
      font-weight: 600;
      color: #ffeab5;
      max-width: 110px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .companion-panel-role {
      font-size: 11px;
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid rgba(255, 214, 106, 0.4);
      background: rgba(255, 214, 106, 0.15);
      color: #ffeab5;
    }

    .companion-panel-bar {
      position: relative;
      height: 6px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      overflow: hidden;
    }

    .companion-panel-bar-fill {
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      border-radius: 999px;
      background: linear-gradient(90deg, #ff6adf, #ff94f0);
      box-shadow: 0 0 6px rgba(255, 106, 223, 0.6);
    }

    .companion-panel-hp {
      margin-top: 4px;
      font-size: 11px;
      text-align: right;
      color: #f5f3ff;
    }

    .btn {
      background: var(--panel2);
      border: 1px solid var(--line);
      color: var(--ink);
      border-radius: 10px;
      padding: 6px 10px;
      cursor: pointer
    }

    .btn:active {
      transform: translateY(1px)
    }

    .controls {
      position: absolute;
      left: 10px;
      right: 10px;
      bottom: 10px;
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
      pointer-events: none
    }

    #btnAISummon {
      position: fixed;
      left: 16px;
      bottom: 186px;
      z-index: 50;
      pointer-events: auto
    }

    .stick {
      position: relative;
      width: 140px;
      height: 140px;
      border-radius: 50%;
      background: radial-gradient(circle at 50% 50%, #111b2a 0%, #0c1420 60%, #0c1420 100%);
      border: 1px solid var(--line);
      box-shadow: inset 0 0 18px rgba(0, 0, 0, .55);
      pointer-events: auto
    }

    .stick .nub {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 64px;
      height: 64px;
      margin: -32px 0 0 -32px;
      border-radius: 50%;
      background: radial-gradient(circle at 35% 35%, #29384f, #1b2639);
      border: 1px solid #3b4d71;
      box-shadow: 0 2px 6px rgba(0, 0, 0, .35)
    }

    .actions {
      position: relative;
      display: flex;
      gap: 22px;
      pointer-events: auto;
      align-items: flex-end
    }

    .col {
      display: flex;
      flex-direction: column;
      gap: 16px;
      align-items: flex-end
    }

    .btn-round {
      width: 64px;
      height: 64px;
      border-radius: 50%;
      background: radial-gradient(circle at 40% 35%, #2a384f, #182235);
      border: 1px solid var(--line);
      box-shadow: 0 3px 12px rgba(0, 0, 0, .35);
      color: #dfe9ff;
      display: flex;
      align-items: center;
      justify-content: center;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      cursor: pointer
    }

    .btn-round.small {
      width: 56px;
      height: 56px;
      font-size: 11px
    }

    .btn-round.big {
      width: 86px;
      height: 86px;
      font-weight: 700
    }

    .btn-round:active {
      transform: translateY(1px)
    }

    #itemMenu {
      position: fixed;
      z-index: 10000;
      background: #0f1826;
      border: 1px solid var(--line);
      border-radius: 8px;
      display: none;
      box-shadow: 0 8px 24px rgba(0, 0, 0, .45)
    }

    #itemMenu button {
      display: block;
      width: 100%;
      padding: 6px 10px;
      background: transparent;
      border: 0;
      color: #cfe3ff;
      text-align: left
    }

    #itemMenu button:hover {
      background: #15243a
    }

    #notificationWrap {
      position: fixed;
      right: 14px;
      top: 14px;
      z-index: 12000;
      display: flex;
      flex-direction: column;
      gap: 6px;
      pointer-events: none
    }

    .toast {
      background: #0f1826;
      border: 1px solid var(--line);
      border-radius: 8px;
      color: #cfe3ff;
      padding: 6px 10px;
      box-shadow: 0 8px 18px rgba(0, 0, 0, .35);
      opacity: .95
    }

    /* ===== A1K Team Menu ===== */
    .a1k-ui.hud-panel {
      position: absolute;
      inset: auto;
      top: 18%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(8, 10, 18, .92);
      border: 2px solid #00e5ff;
      border-radius: 12px;
      padding: 16px;
      z-index: 9999;
      min-width: 320px;
      max-width: 560px;
      box-shadow: 0 10px 28px rgba(0, 0, 0, .35)
    }

    .a1k-ui.hidden {
      display: none
    }

    .a1k-ui .panel-title {
      font-weight: 700;
      margin-bottom: 8px;
      color: #00e5ff
    }

    .a1k-ui .panel-body {
      display: flex;
      flex-direction: column;
      gap: 8px
    }

    .a1k-ui .ui-line {
      padding: 10px 12px;
      border-radius: 10px;
      border: 1px solid rgba(0, 229, 255, .35);
      background: rgba(255, 255, 255, .03)
    }

    .a1k-ui .clone-label {
      margin-left: 6px;
      font-size: 12px;
      color: #9fd7ff;
      letter-spacing: .04em;
      text-transform: uppercase
    }

    .a1k-ui .panel-footer {
      margin-top: 10px;
      text-align: right
    }

    .hud-btn.a1k-ui {
      border: 2px solid #00e5ff;
      border-radius: 12px;
      padding: 8px 12px;
      background: rgba(8, 10, 18, .8)
    }

    .bag-overlay {
      position: fixed;
      top: 0;
      right: 0;
      bottom: 0;
      width: 60%;
      max-width: 600px;
      background: linear-gradient(rgba(3, 7, 15, .95), rgba(3, 7, 15, .95));
      box-shadow: 0 0 32px rgba(123, 97, 255, .55);
      border-left: 2px solid rgba(123, 97, 255, .5);
      padding: 12px;
      display: none;
      flex-direction: column;
      z-index: 1000;
      overflow-y: auto
    }

    .bag-overlay.open {
      display: flex
    }

    .bag-header {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      align-items: center;
      padding-bottom: 4px;
      border-bottom: 1px solid rgba(123, 97, 255, .3);
      color: #e9f4ff
    }

    .bag-nav {
      display: flex;
      flex-direction: column;
      gap: 6px;
      padding-right: 8px;
      border-right: 1px solid rgba(123, 97, 255, .3)
    }

    .bag-nav-item {
      background: rgba(255, 255, 255, 0.05);
      color: #a8b7ce;
      padding: 6px 10px;
      text-align: left;
      cursor: pointer;
      font-weight: 600;
      border-radius: 4px;
      border: 1px solid rgba(123, 97, 255, .2)
    }

    .bag-nav-item:hover {
      background: rgba(123, 97, 255, .2);
      color: #e9f4ff;
      border-color: rgba(123, 97, 255, .4)
    }

    .bag-nav-item.active {
      background: linear-gradient(90deg, #2EA8FF, #7B61FF);
      color: #fff;
      border-color: rgba(123, 97, 255, .6)
    }

    /* Skins UI Styles - Enhanced */
    .skins-container {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
      margin-bottom: 20px;
      min-height: 400px;
      /* Make it bigger */
    }

    .character-skins {
      flex: 1;
      min-width: 250px;
      /* Increased from 200px */
      background: rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      padding: 15px;
    }

    .character-skins h3 {
      color: #e9f4ff;
      margin-bottom: 15px;
      font-size: 18px;
      text-align: center;
      border-bottom: 2px solid rgba(123, 97, 255, 0.3);
      padding-bottom: 8px;
    }

    .skins-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
      /* Increased from 80px */
      gap: 12px;
      /* Increased from 8px */
      min-height: 200px;
      /* Ensure minimum height */
    }

    .skin-box {
      aspect-ratio: 1;
      background: rgba(255, 255, 255, 0.05);
      border: 2px solid rgba(123, 97, 255, 0.3);
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      position: relative;
      overflow: hidden;
      min-height: 100px;
      /* Ensure minimum size */
    }

    .skin-box:hover {
      background: rgba(123, 97, 255, 0.2);
      border-color: #7B61FF;
      transform: scale(1.05);
    }

    .skin-box.equipped {
      border-color: #2EA8FF;
      box-shadow: 0 0 12px rgba(46, 168, 255, 0.5);
    }

    .skin-box.locked {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .skin-box.locked:hover {
      transform: none;
    }

    .skin-preview {
      margin-top: 20px;
      padding: 20px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 8px;
      display: flex;
      gap: 20px;
      align-items: center;
      min-height: 250px;
      /* Make preview bigger */
    }

    .skin-preview canvas {
      border: 2px solid rgba(123, 97, 255, 0.3);
      border-radius: 8px;
      background: rgba(0, 0, 0, 0.5);
      width: 200px;
      height: 200px;
    }

    .skin-info h4 {
      color: #e9f4ff;
      margin: 0 0 10px 0;
      font-size: 20px;
    }

    .skin-info p {
      color: #a8b7ce;
      margin: 0 0 15px 0;
      font-size: 16px;
    }

    .btn-primary {
      background: linear-gradient(90deg, #2EA8FF, #7B61FF);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.2s;
    }

    .btn-primary:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(46, 168, 255, 0.3);
    }

    .btn-primary:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .bag-body {
      flex: 1;
      display: flex;
      margin-top: 8px
    }

    .bag-content {
      flex: 3;
      padding-right: 8px;
      overflow-y: auto
    }

    .bag-detail {
      flex: 2;
      border-left: 1px solid rgba(58, 226, 255, .2);
      padding-left: 8px;
      color: #cfe3ff;
      overflow-y: auto
    }

    .bag-grid {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 6px
    }

    .gear-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 6px
    }

    .pets-grid {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 6px
    }

    .vehicles-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(64px, 1fr));
      gap: 6px;
      padding: 8px
    }

    .shop-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(120px, 1fr));
      gap: 8px;
      padding: 8px
    }

    .shop-item {
      background: rgba(255, 255, 255, .04);
      border: 1px solid rgba(123, 97, 255, .2);
      border-radius: 6px;
      padding: 8px;
      text-align: center;
      font-size: 12px
    }

    .shop-item h5 {
      margin: 0 0 4px;
      font-size: 13px;
      color: #cfe3ff
    }

    .shop-item p {
      margin: 0 0 8px;
      color: #9baec8;
      font-size: 11px
    }

    .shop-item button {
      background: rgba(123, 97, 255, .2);
      border: 1px solid rgba(123, 97, 255, .4);
      color: #e9f4ff;
      padding: 4px 8px;
      border-radius: 4px;
      cursor: pointer;
      width: 100%
    }

    .shop-item button:hover {
      background: rgba(123, 97, 255, .4)
    }

    .shop-tabs-container {
      display: flex;
      gap: 6px;
      margin-bottom: 8px;
      flex-wrap: wrap
    }

    .shop-tab {
      padding: 4px 8px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      background: #1f2e47;
      color: #cfe3ff
    }

    .shop-tab-active {
      background: #2ea8ff;
      color: #fff
    }

    .self-tests {
      position: fixed;
      right: 8px;
      bottom: 8px;
      background: rgba(11, 18, 32, 0.8);
      padding: 8px 10px;
      border-radius: 8px;
      border: 1px solid rgb(27, 42, 70);
      font: 12px ui-monospace;
      color: rgb(205, 231, 255);
      max-width: 420px;
      z-index: 99999;
      pointer-events: auto
    }

    .test-run-btn {
      margin-left: 8px;
      background: #14233a;
      color: #cde7ff;
      border: 1px solid #22314e;
      border-radius: 6px;
      padding: 2px 6px;
      cursor: pointer
    }

    .test-log {
      margin-top: 6px
    }

    .test-fail {
      color: rgb(255, 182, 182)
    }

    .test-pass {
      color: rgb(159, 255, 168)
    }

    .skill-btn-overlay {
      position: absolute;
      inset: 0px;
      z-index: 10000;
      pointer-events: none
    }

    .skill-btn {
      display: flex
    }

    .toast-warning {
      color: rgb(255, 213, 106)
    }

    .toast-fading {
      color: rgb(255, 213, 106);
      transition: opacity 0.4s;
      opacity: 0
    }

    .bag-panel {
      display: none
    }

    .bag-panel.active {
      display: block
    }


    /* Spirit Panel Styles */
    .spirit-interface {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .aura-display {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .aura-item {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(123, 97, 255, 0.3);
      border-radius: 8px;
      padding: 15px;
      text-align: center;
    }

    .aura-item .aura-icon {
      font-size: 24px;
      margin-bottom: 8px;
    }

    .aura-item .aura-name {
      font-weight: bold;
      color: #cfe3ff;
      margin-bottom: 5px;
    }

    .aura-item .aura-type {
      font-size: 12px;
      color: #a0b8d0;
      margin-bottom: 5px;
    }

    .aura-item .aura-level {
      font-size: 11px;
      color: #7b61ff;
      margin-bottom: 10px;
    }

    .aura-preview {
      height: 20px;
      border-radius: 10px;
      margin-top: 5px;
    }

    .aura-gold {
      background: linear-gradient(90deg, #ffd700, #ffed4e);
      box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
    }

    .aura-dual {
      background: linear-gradient(90deg, #000, #fff);
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
    }

    .aura-pink {
      background: linear-gradient(90deg, #ff69b4, #dda0dd);
      box-shadow: 0 0 10px rgba(255, 105, 180, 0.5);
    }

    .spirit-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
      gap: 10px;
    }

    .spirit-item {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(123, 97, 255, 0.3);
      border-radius: 8px;
      padding: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .spirit-item:hover {
      background: rgba(123, 97, 255, 0.2);
      border-color: rgba(123, 97, 255, 0.6);
    }

    .spirit-item .spirit-icon {
      font-size: 20px;
      margin-bottom: 5px;
    }

    .spirit-item .spirit-name {
      font-weight: bold;
      color: #cfe3ff;
      margin-bottom: 3px;
    }

    .spirit-item .spirit-type {
      font-size: 11px;
      color: #a0b8d0;
      margin-bottom: 3px;
    }

    .spirit-item .spirit-power,
    .spirit-item .spirit-level {
      font-size: 10px;
      color: #7b61ff;
    }

    .spirit-slot {
      background: rgba(255, 255, 255, 0.05);
      border: 2px dashed rgba(123, 97, 255, 0.3);
      border-radius: 8px;
      padding: 20px;
      text-align: center;
    }

    .spirit-slot .spirit-icon {
      font-size: 32px;
      margin-bottom: 10px;
    }

    .spirit-slot .spirit-name {
      font-weight: bold;
      color: #cfe3ff;
      margin-bottom: 5px;
    }

    .spirit-slot .spirit-desc {
      font-size: 12px;
      color: #a0b8d0;
    }

    .spirit-actions {
      display: flex;
      gap: 10px;
      margin-top: 20px;
    }

    .bag-storage-info {
      background: rgba(123, 97, 255, 0.1);
      border: 1px solid rgba(123, 97, 255, 0.3);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 20px;
      text-align: center;
    }

    .bag-storage-info h4 {
      color: #7b61ff;
      margin: 0 0 8px 0;
    }

    .bag-storage-info p {
      color: #a0b8d0;
      margin: 0;
      font-size: 14px;
    }

    /* Supernatural Panel Styles */
    .supernatural-interface {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }

    .system-notice {
      background: rgba(255, 165, 0, 0.1);
      border: 1px solid rgba(255, 165, 0, 0.3);
      border-radius: 8px;
      padding: 15px;
      text-align: center;
    }

    .system-notice h5 {
      color: #ffa500;
      margin: 0 0 10px 0;
    }

    .system-notice p {
      color: #a0b8d0;
      margin: 0 0 10px 0;
    }

    .system-notice ul {
      text-align: left;
      color: #cfe3ff;
      margin: 0;
      padding-left: 20px;
    }

    .system-notice li {
      margin-bottom: 5px;
    }

    .supernatural-profiles {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .profile-item {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(123, 97, 255, 0.3);
      border-radius: 8px;
      padding: 15px;
      text-align: center;
    }

    .profile-item .profile-icon {
      font-size: 24px;
      margin-bottom: 8px;
    }

    .profile-item .profile-name {
      font-weight: bold;
      color: #cfe3ff;
      margin-bottom: 5px;
    }

    .profile-item .profile-type {
      font-size: 12px;
      color: #a0b8d0;
      margin-bottom: 5px;
    }

    .profile-item .profile-status {
      font-size: 11px;
      color: #ffa500;
      font-style: italic;
    }

    .development-timeline {
      background: rgba(123, 97, 255, 0.05);
      border: 1px solid rgba(123, 97, 255, 0.2);
      border-radius: 8px;
      padding: 15px;
    }

    .development-timeline h5 {
      color: #7b61ff;
      margin: 0 0 10px 0;
    }

    .timeline-item {
      color: #cfe3ff;
      margin-bottom: 8px;
      font-size: 14px;
    }

    .timeline-phase {
      color: #7b61ff;
      font-weight: bold;
    }

    .slot-box {
      height: 44px;
      border: 1px dashed rgba(123, 97, 255, .4);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      color: #cfe3ff;
      cursor: pointer;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      background: rgba(255, 255, 255, .04)
    }

    .slot-box.item {
      background: rgba(46, 168, 255, .08)
    }

    .slot-box.equip {
      background: rgba(255, 165, 0, .08)
    }

    .slot-box.pet {
      background: rgba(255, 192, 203, .08)
    }

    .bag-detail-content h4 {
      margin: 0 0 4px 0;
      font-size: 14px;
      color: #cfe3ff
    }

    .bag-detail-content p {
      font-size: 12px;
      margin: 0 0 8px 0;
      color: #9baec8
    }

    .bag-actions button {
      display: inline-block;
      margin-right: 6px;
      margin-bottom: 6px;
      padding: 4px 8px;
      font-size: 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      background: #0f1826;
      color: #cfe3ff
    }

    .bag-actions button:hover {
      background: #1a263a
    }

    .drawer-close {
      position: absolute;
      top: 6px;
      right: 8px;
      width: 20px;
      height: 20px;
      border: 0;
      background: transparent;
      color: var(--muted);
      font-size: 16px;
      line-height: 20px;
      cursor: pointer;
      pointer-events: auto
    }

    .drawer-close:hover {
      color: var(--ink)
    }

    /* Talent Lanes */
    .lane-wrap {
      display: flex;
      gap: 12px;
      flex-wrap: wrap
    }

    .lane-col {
      flex: 1 1 160px;
      background: rgba(255, 255, 255, 0.03);
      border: 1px solid rgba(123, 97, 255, 0.25);
      padding: 6px;
      border-radius: 6px
    }

    .lane-col h4 {
      margin: 2px 0 6px;
      font-size: 12px;
      letter-spacing: .5px;
      color: #cfe3ff
    }

    .lane-node {
      display: flex;
      flex-direction: column;
      gap: 2px;
      margin-bottom: 6px;
      padding: 6px;
      background: #0f1826;
      border: 1px solid rgba(123, 97, 255, 0.25);
      border-radius: 4px;
      font-size: 11px;
      cursor: pointer;
      position: relative
    }

    .lane-node.owned {
      background: #1d2c48;
      border-color: #63e6ff;
      color: #bfe9ff
    }

    .lane-node.locked {
      opacity: .45;
      cursor: not-allowed
    }

    .lane-node span.cost {
      position: absolute;
      right: 6px;
      top: 4px;
      font-size: 10px;
      color: #ffd56a
    }

    .lane-node small {
      color: #8ea5c4;
      font-size: 10px
    }

    .lane-node button {
      margin-top: 4px;
      font-size: 10px;
      padding: 3px 6px;
      background: #2d3a54;
      border: 1px solid #4b638b;
      border-radius: 3px;
      color: #d7e9ff;
      cursor: pointer
    }

    .lane-node button:disabled {
      opacity: .4;
      cursor: not-allowed
    }

    #talentSummary {
      margin-top: 6px;
      font-size: 11px;
      color: #9baec8;
      line-height: 1.4;
      white-space: pre-wrap
    }

    .upgrade-btn[disabled] {
      opacity: .4;
      cursor: not-allowed
    }

    /* Team Status UI */
    .team-status {
      display: flex;
      gap: 8px;
      pointer-events: auto;
      flex-wrap: nowrap
    }

    .hero-portrait {
      position: relative;
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 6px;
      padding: 4px;
      min-width: 48px;
      text-align: center
    }

    .hero-portrait.leader {
      border-color: var(--hp);
      box-shadow: 0 0 8px rgba(54, 199, 119, .3)
    }

    .hero-portrait.defeated {
      opacity: .5;
      border-color: #ff4d4f
    }

    .hero-portrait.secret-ready {
      box-shadow: 0 0 12px rgba(255, 106, 168, .9);
      border-color: #ff6aa8;
      animation: secretGlow 1.2s infinite alternate
    }

    @keyframes secretGlow {
      from {
        box-shadow: 0 0 8px rgba(255, 106, 168, .7)
      }

      to {
        box-shadow: 0 0 20px rgba(255, 106, 168, 1)
      }
    }

    .hero-icon {
      font-size: 11px;
      font-weight: 700;
      color: var(--ink);
      margin-bottom: 2px
    }

    .hero-hp-bar {
      position: relative;
      height: 4px;
      background: var(--panel2);
      border-radius: 2px;
      overflow: hidden;
      margin-bottom: 2px
    }

    .hero-hp-fill {
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, var(--hp), var(--hp2));
      transform-origin: left center
    }

    .hero-status {
      font-size: 8px;
      color: var(--muted);
      min-height: 10px
    }

    .hero-portrait.defeated .hero-status {
      color: #ff4d4f
    }

    .hero-portrait {
      cursor: pointer;
    }

    .hero-skill-icons {
      display: none;
      justify-content: center;
      gap: 2px;
      margin-top: 2px;
      height: 8px;
    }

    .skill-icon {
      width: 8px;
      height: 8px;
      border-radius: 2px;
      background-color: var(--panel2);
      border: 1px solid var(--line);
    }

    .skill-icon.ready {
      background-color: var(--mp);
      border-color: var(--mp2);
      box-shadow: 0 0 4px var(--mp);
    }

    /* Secret Gauge */
    .secret-gauge {
      position: relative;
      width: 40px;
      height: 8px;
      background: var(--panel2);
      border: 1px solid var(--line);
      border-radius: 4px;
      overflow: hidden;
      margin: 0 auto 4px
    }

    .secret-fill {
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, #ff6aa8, #ffaa00);
      transform-origin: left center
    }

    /* Rage Gauge */
    .rage-gauge {
      position: relative;
      width: 40px;
      height: 8px;
      background: var(--panel2);
      border: 1px solid var(--line);
      border-radius: 4px;
      overflow: hidden;
      margin: 0 auto 4px
    }

    .rage-fill {
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, var(--rage), var(--rage2));
      transform-origin: left center
    }

    .hero-portrait.rage-ready {
      box-shadow: 0 0 10px rgba(249, 204, 43, .6);
      border-color: #ffb84d
    }

    .btn-round.ready {
      box-shadow: 0 0 10px rgba(255, 218, 120, .8), 0 0 2px rgba(255, 255, 255, .4) inset;
      border-color: #ffd56a
    }

    /* S2 recall cooldown ring */
    #btnS2.coolring {
      position: relative;
      --p: 0deg;
      background: conic-gradient(#6aa8ff var(--p), #182235 0deg);
    }

    #btnS2.coolring::after {
      content: '';
      position: absolute;
      inset: 5px;
      border-radius: 50%;
      background: radial-gradient(circle at 40% 35%, #2a384f, #182235);
      border: 1px solid var(--line);
    }

    /* Quest UI */
    .quest-item {
      background: rgba(255, 255, 255, 0.04);
      border: 1px solid rgba(123, 97, 255, 0.3);
      border-radius: 6px;
      padding: 8px;
      margin-bottom: 6px
    }

    .quest-item.completed {
      border-color: #36c777;
      background: rgba(54, 199, 119, 0.1)
    }

    .quest-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 4px
    }

    .quest-name {
      font-size: 13px;
      color: #cfe3ff;
      font-weight: 600
    }

    .quest-progress {
      font-size: 11px;
      color: #9baec8
    }

    .quest-description {
      font-size: 11px;
      color: #a8b7ce;
      margin-bottom: 6px
    }

    .quest-progress-bar {
      position: relative;
      height: 4px;
      background: var(--panel2);
      border-radius: 2px;
      overflow: hidden;
      margin-bottom: 4px
    }

    .quest-progress-fill {
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, #2EA8FF, #7B61FF);
      transform-origin: left center
    }

    .quest-reward {
      font-size: 10px;
      color: #ffd56a
    }

    /* Universal Action Button & Shared Gauge */
    .shared-gauge {
      position: absolute;
      top: -12px;
      left: 0;
      right: 0;
      height: 4px;
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 2px;
      overflow: hidden;
      width: 140px;
      /* Match joyWrap width */
      margin: 0 auto;
    }

    .shared-gauge .fill {
      background: linear-gradient(90deg, var(--mp), var(--mp2));
      transform: scaleX(0);
      /* Default empty */
    }

    .action-container {
      position: relative;
      width: 86px;
      height: 86px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .duration-ring {
      position: absolute;
      top: -2px;
      left: -2px;
      width: 90px;
      height: 90px;
      transform: rotate(-90deg);
      pointer-events: none;
      display: none;
      /* hide the duration ring (yellow circle) */
    }

    /* Hide old universal action container and chest interact overlay */
    #universal-action-container {
      display: none !important;
    }

    #apxInteract {
      display: none !important;
    }

    .duration-ring circle {
      fill: transparent;
      stroke-width: 4px;
    }

    .duration-ring .duration-ring-bg {
      stroke: rgba(0, 0, 0, 0.3);
    }

    .duration-ring .duration-ring-fg {
      stroke: var(--rage);
      stroke-linecap: round;
      transition: stroke-dashoffset 0.1s linear;
    }

    /* Hide legacy big ACTION circle; we use the compact Act btn next to Pet/Veh */
    #btnUniversalAction {
      display: none !important;
    }

    /* hide the yellow duration ring and chest prompt as requested */
    .duration-ring {
      display: none !important;
    }

    #apxInteract {
      display: none !important;
    }

    /* hide the old pet ready gauge so only canvas pets show */
    #petReady {
      display: none !important;
    }

    /* Chibi HUD Refresh */
    .joyWrap {
      position: relative;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    .micro-top {
      display: flex;
      gap: 8px;
      align-self: flex-start;
      pointer-events: auto;
    }

    .micro-actions {
      display: flex;
      gap: 8px;
      pointer-events: auto;
      align-self: flex-start;
    }

    .btn-micro {
      background: var(--panel2);
      border: 1px solid var(--line);
      color: var(--ink);
      border-radius: 8px;
      padding: 4px 8px;
      font-size: 10px;
      cursor: pointer;
      font-weight: 600;
    }

    .btn-micro:active {
      transform: translateY(1px)
    }

    .btn-micro.micro-bag {
      align-self: flex-start;
      background: var(--panel3);
      color: #dfe9ff;
      min-width: 54px;
      text-align: center;
      pointer-events: auto;
    }

    .btn-micro.micro-ai {
      padding: 3px 6px;
      font-size: 8px;
      min-width: 32px;
      text-align: center;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: #fff;
      border-color: #a78bfa;
    }

    #btnPet {
      background-color: var(--pastel-pet);
      color: #333;
    }

    #btnActionNew {
      background-color: var(--pastel-action);
      color: #333;
    }

    #btnVeh {
      background-color: var(--pastel-veh);
      color: #333;
    }


    #btnShoot {
      width: 119px;
      height: 119px;
      border-radius: 50%;
      background: var(--pastel-attack);
      color: #333;
      font-weight: 700;
    }

    .actions-secondary {
      display: flex;
      gap: 16px;
      pointer-events: auto;
      align-items: flex-end;
    }

    .action-buttons-wrapper {
      display: flex;
      align-items: flex-end;
      gap: 22px;
    }

    /* Bag Auto Buttons */
    .bag-auto-actions {
      display: flex;
      gap: 8px;
      margin-bottom: 10px;
      pointer-events: auto;
    }

    .btn-auto {
      background: var(--panel2);
      border: 1px solid var(--line);
      color: var(--ink);
      border-radius: 8px;
      padding: 4px 8px;
      font-size: 10px;
      cursor: pointer;
      font-weight: 600;
    }

    .btn-auto:active {
      transform: translateY(1px)
    }

    #btnOpenAll {
      background-color: var(--pastel-pet);
    }

    #btnAutoUp {
      background-color: var(--pastel-attack);
    }

    #btnAutoEq {
      background-color: var(--pastel-action);
    }

    #btnAutoFuse {
      background-color: #fffacd;
    }

    #btnAlchemy {
      background-color: #ffb6c1;
    }

    /* Alchemy Panel */
    .alchemy-body {
      padding: 10px;
    }

    .alchemy-bag-strip {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      gap: 6px;
      margin-bottom: 10px;
      background-color: var(--panel);
      padding: 10px;
      border-radius: 8px;
      min-height: 100px;
      /* Placeholder for two rows */
    }

    .alchemy-info-boxes,
    .alchemy-rules-boxes {
      display: flex;
      gap: 10px;
      margin-bottom: 10px;
    }

    .info-box {
      background-color: var(--panel);
      padding: 10px;
      border-radius: 8px;
      flex: 1;
      font-size: 12px;
      text-align: center;
    }

    .alchemy-crafting-area {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 20px;
      margin-bottom: 10px;
    }

    .alchemy-slots {
      display: flex;
      gap: 10px;
    }

    .alchemy-arrow {
      font-size: 24px;
    }

    /* Canvas positioning */
    #cv {
      width: 1548.44px;
      height: 871px;
      position: absolute;
      left: 65.7778px;
      top: 0px;
    }

    /* Currency positioning */
    #currency {
      top: 110px;
      left: 10px;
      gap: 8px;
      justify-content: flex-start;
      pointer-events: none;
    }

    /* Bag header layout */
    .bag-header-content {
      width: 100%;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .bag-auto-actions-full {
      width: 100%;
      margin-top: 8px;
    }

    /* Player stats layout */
    .player-stats-flex {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
    }

    /* XP bar styling */
    .xp-bar {
      margin-top: 8px;
    }

    .xp-bar .fill {
      transform: scaleX(0);
    }

    /* Evolution section */
    .evolution-section {
      margin-top: 8px;
      display: flex;
      gap: 8px;
    }

    /* Gear section HR */
    .gear-hr {
      margin: 8px 0;
      border-color: var(--line);
    }

    /* Pet grid HR */
    .pet-hr {
      grid-column: 1 / -1;
      margin: 8px 0px;
      border: 1px solid var(--line);
    }

    /* Vehicle grid HR */
    .vehicle-hr {
      grid-column: 1 / -1;
      margin: 8px 0px;
      border: 1px solid var(--line);
    }

    /* Paper doll layout */
    .paper-doll-container {
      display: flex;
      gap: 12px;
      flex-wrap: wrap;
      padding: 8px;
    }

    .paper-doll-hero {
      flex: 1;
      min-width: 160px;
    }

    .paper-doll-hero-title {
      text-align: center;
      font-size: 12px;
      color: #9baec8;
      margin-bottom: 4px;
    }

    .paper-doll-hero-display {
      width: 120px;
      height: 160px;
      border: 1px dashed var(--line);
      border-radius: 4px;
      margin: auto;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #3b4d71;
      background: rgba(255, 255, 255, 0.03);
    }

    .paper-doll-equipment {
      flex: 1;
      min-width: 160px;
    }

    .paper-doll-section-title {
      font-size: 12px;
      color: #9baec8;
      margin-bottom: 4px;
    }

    .paper-doll-slot {
      margin-bottom: 4px;
    }

    .paper-doll-pets-title {
      font-size: 12px;
      color: #9baec8;
      margin: 8px 0 4px;
    }

    .paper-doll-vehicle-title {
      font-size: 12px;
      color: #9baec8;
      margin: 8px 0 4px;
    }

    /* Quest content */
    .quest-content {
      padding: 8px;
      opacity: 1;
    }

    .quest-header-title {
      margin: 0 0 8px;
      color: #e9f4ff;
    }

    .quest-timer {
      font-size: 11px;
      margin-left: 8px;
      color: #ffd56a;
    }

    .quest-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .quest-progress-fill {
      transform: scaleX(1);
    }

    .quest-reward-claimed {
      color: #36c777;
      margin-left: 4px;
    }

    .quest-footer {
      margin-top: 12px;
      padding-top: 8px;
      border-top: 1px solid rgba(123, 97, 255, 0.3);
    }

    .quest-footer-text {
      margin: 0;
      font-size: 11px;
      color: #9baec8;
    }

    .endless-stats {
      margin-top: 8px;
      display: none;
    }

    .endless-title {
      margin: 0 0 4px;
      color: #ffaa00;
    }

    .endless-score {
      margin: 0;
      font-size: 12px;
      color: #cfe3ff;
    }

    .endless-time {
      margin: 0;
      font-size: 12px;
      color: #cfe3ff;
    }

    /* Settings card */
    .settings-card {
      background: rgba(255, 255, 255, 0.04);
      padding: 8px;
      border: 1px solid rgba(123, 97, 255, 0.2);
      border-radius: 6px;
    }

    .settings-title {
      margin: 0 0 6px;
      font-size: 14px;
    }

    .settings-label {
      display: block;
      margin-top: 6px;
    }

    .settings-qa-section {
      margin-top: 8px;
    }

    .settings-qa-button {
      padding: 6px 10px;
      border: 1px solid #3b4d71;
      background: #1a263a;
      color: #d7e9ff;
      border-radius: 6px;
      cursor: pointer;
    }

    .settings-qa-note {
      opacity: .7;
      margin-left: 8px;
    }

    .qa-tools-flex {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .audio-volume-slider {
      width: 100%;
    }

    .hud-position-select {
      margin-left: 4px;
    }

    /* Shared gauge fill */
    .shared-gauge-fill {
      transform: scaleX(1);
    }

    /* Action button styling */
    .action-button-flex {
      display: flex;
      background-color: var(--pastel-pet);
    }

    /* Joystick nub positioning */
    .nub-center {
      left: 50%;
      top: 50%;
    }

    /* Duration ring hidden */
    .duration-ring-hidden {
      display: none;
    }

    /* Secret button styling */
    .secret-button-ready {
      opacity: 1;
      pointer-events: auto;
    }

    /* Compact stats positioning */
    .compact-stats {
      position: absolute;
      top: 8px;
      right: 8px;
      background: rgba(13, 19, 28, 0.85);
      border: 1px solid rgb(41, 56, 84);
      border-radius: 6px;
      padding: 3px 5px;
      font-size: 10px;
      color: rgb(168, 183, 206);
      width: 110px;
      box-shadow: rgba(0, 0, 0, 0.3) 0px 2px 4px;
      pointer-events: none;
      display: flex;
      flex-direction: column;
      gap: 2px;
      z-index: 100;
    }

    .compact-stats-row {
      display: flex;
      justify-content: space-between;
    }

    /* DOM sprites positioning */
    .dom-sprites {
      position: absolute;
      left: 0;
      top: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
    }
  </style>
  <script>
    (function () {
      try { const q = new URLSearchParams(location.search); const w = Number(q.get('world')); if (Number.isFinite(w) && w > 0) window.WORLD_WIDTH = w; } catch (_) { }
      window.WORLD_WIDTH = window.WORLD_WIDTH || 6400;
    })();
  </script>
  <style id="cleanup-bottom-panels">
    /* Hide the hero stats bars at the bottom */
    #heroHud {
      display: none !important;
    }

    /* Hide the compact stats panel */
    #compactStats {
      display: none !important;
    }

    /* Hide the self-test panel on the bottom-right */
    #selfTests {
      display: none !important;
    }

    /* Hide the debug checkbox panel on the bottom-left */
    #debugHud {
      display: none !important;
    }
  </style>
  <style id="hud-transparent-v8">
    #vj-wrap {
      position: fixed;
      inset: auto 0 0 0;
      padding: 10px;
      display: grid;
      grid-template-columns: 1fr 1fr;
      pointer-events: none;
      z-index: 55;
    }

    /* Move joystick cluster 95% right and make 30% smaller */
    #vj-left {
      transform: translateX(85%) scale(0.7);
    }

    /* Hide AI button in joystick cluster */
    #btnAISummon {
      display: none !important;
    }

    /* Move attack cluster 95% left and make 30% smaller */
    #vj-right {
      transform: translateX(-95%) scale(0.7);
    }

    #vj-left {
      pointer-events: auto;
      justify-self: start;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 18px;
      margin-left: 40px;
      position: relative;
    }

    #vj-right {
      pointer-events: auto;
      justify-self: end;
      display: grid;
      grid-template-rows: auto auto;
      gap: 12px;
      align-content: end;
      margin-right: 147px;
      margin-bottom: 40px;
    }

    #vj-root {
      width: 130px;
      height: 130px;
      position: relative;
      -webkit-user-select: none;
      user-select: none;
      touch-action: none;
    }

    #vj-base {
      position: absolute;
      inset: 0;
      margin: auto;
      width: 118px;
      height: 118px;
      border-radius: 999px;
      background: radial-gradient(circle at 50% 50%, rgba(0, 0, 0, .55), rgba(0, 0, 0, .2));
      border: 2px solid rgba(255, 255, 255, .22);
      box-shadow: inset 0 0 12px rgba(122, 213, 255, .28), 0 0 18px rgba(122, 213, 255, .25);
    }

    #vj-knob {
      position: absolute;
      left: 50%;
      top: 50%;
      width: 52px;
      height: 52px;
      margin-left: -26px;
      margin-top: -26px;
      border-radius: 999px;
      background: linear-gradient(180deg, rgba(255, 255, 255, .18), rgba(255, 255, 255, .06));
      border: 2px solid rgba(122, 213, 255, .9);
      box-shadow: 0 0 22px rgba(122, 213, 255, .55), inset 0 0 10px rgba(122, 213, 255, .35);
      transform: translate(0, 0);
    }

    @keyframes readyPulse {

      0%,
      100% {
        box-shadow: 0 0 20px rgba(122, 213, 255, .55), 0 0 40px rgba(167, 139, 250, .35)
      }

      50% {
        box-shadow: 0 0 30px rgba(122, 213, 255, .8), 0 0 60px rgba(167, 139, 250, .55)
      }
    }

    #vj-root.ready #vj-base {
      border-color: rgba(122, 213, 255, .85);
      box-shadow: inset 0 0 16px rgba(122, 213, 255, .45), 0 0 24px rgba(122, 213, 255, .35);
    }

    #vj-root.ready #vj-knob {
      animation: readyPulse 1.6s ease-in-out infinite;
    }

    #vj-root.ready::after {
      content: "";
      position: absolute;
      inset: -6px;
      border-radius: 999px;
      border: 2px solid rgba(122, 213, 255, .45);
      box-shadow: 0 0 24px rgba(122, 213, 255, .4), 0 0 48px rgba(167, 139, 250, .35);
      pointer-events: none;
    }

    /* Visual Feedback Animations */
    @keyframes buttonPulse {

      0%,
      100% {
        transform: scale(1);
        box-shadow: 0 0 20px rgba(122, 213, 255, .55), 0 0 40px rgba(167, 139, 250, .35);
      }

      50% {
        transform: scale(1.1);
        box-shadow: 0 0 30px rgba(122, 213, 255, .8), 0 0 60px rgba(167, 139, 250, .55);
      }
    }

    @keyframes buttonGlow {

      0%,
      100% {
        box-shadow: 0 0 20px rgba(122, 213, 255, .55), 0 0 40px rgba(167, 139, 250, .35);
      }

      50% {
        box-shadow: 0 0 30px rgba(122, 213, 255, .8), 0 0 60px rgba(167, 139, 250, .55);
      }
    }

    @keyframes buttonPress {
      0% {
        transform: scale(1);
      }

      50% {
        transform: scale(0.95);
      }

      100% {
        transform: scale(1);
      }
    }

    .btn-active {
      animation: buttonPulse 0.3s ease-in-out;
    }

    .btn-glow {
      animation: buttonGlow 1.6s ease-in-out infinite;
    }

    .btn-press {
      animation: buttonPress 0.15s ease-in-out;
    }

    .big-btn:active,
    .rage-shield-btn:active,
    .skill-pill:active {
      animation: buttonPress 0.15s ease-in-out;
    }

    .utility-stack {
      display: flex;
      flex-direction: column;
      gap: 8px;
      justify-content: center;
      align-items: center;
    }

    .utility-row {
      display: flex;
      gap: 12px;
    }

    .utility-btn {
      touch-action: manipulation;
      -webkit-user-select: none;
      user-select: none;
      min-width: 56px;
      padding: 8px 12px;
      border-radius: 12px;
      border: 2px solid rgba(255, 255, 255, .22);
      background: radial-gradient(120% 160% at 30% 20%, rgba(255, 255, 255, .18), rgba(255, 255, 255, .04));
      color: #fff;
      font-weight: 700;
      letter-spacing: .04em;
      font-size: 13px;
      text-transform: uppercase;
      box-shadow: 0 4px 18px rgba(0, 0, 0, .35), inset 0 0 20px rgba(122, 213, 255, .22);
    }

    .skill-row {
      display: flex;
      gap: 12px;
      justify-content: flex-end;
    }

    .skill-pill {
      position: relative;
      width: 52px;
      height: 52px;
      border-radius: 16px;
      border: 2px solid rgba(255, 255, 255, .22);
      background: linear-gradient(180deg, rgba(0, 0, 0, .65), rgba(0, 0, 0, .25));
      box-shadow: 0 6px 24px rgba(0, 0, 0, .3), inset 0 0 22px rgba(122, 213, 255, .24);
      pointer-events: auto;
    }

    .skill-pill::after {
      content: attr(data-skill);
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      font-weight: 900;
      letter-spacing: .08em;
      font-size: 16px;
      color: #fff;
    }

    .skill-pill.ready {
      border-color: rgba(255, 208, 0, .9);
      box-shadow: 0 0 16px rgba(255, 208, 0, .55), 0 0 32px rgba(255, 208, 0, .4);
    }

    .skill-pill::before {
      content: "";
      position: absolute;
      inset: -6px;
      border-radius: 20px;
      opacity: 0;
      transition: opacity .2s ease, transform .2s ease;
      border: 1px solid rgba(255, 255, 255, .28);
      transform: scale(.9);
    }

    .skill-pill.ready::before {
      opacity: 1;
      transform: scale(1);
      box-shadow: 0 0 20px rgba(255, 208, 0, .35);
    }

    .big-btn {
      touch-action: manipulation;
      -webkit-user-select: none;
      user-select: none;
      padding: 16px 12px;
      border-radius: 16px;
      border: 2px solid rgba(255, 255, 255, .28);
      background: radial-gradient(120% 160% at 30% 20%, rgba(255, 255, 255, .14), rgba(255, 255, 255, .02));
      color: #fff;
      font-weight: 900;
      letter-spacing: .04em;
      font-size: 18px;
      box-shadow: 0 6px 26px rgba(0, 0, 0, .35), 0 0 30px rgba(255, 255, 255, .18) inset, 0 0 30px rgba(122, 213, 255, .28);
    }

    .big-btn.attack {
      border-color: rgba(255, 122, 217, .8);
      box-shadow: 0 6px 26px rgba(0, 0, 0, .35), 0 0 30px rgba(255, 122, 217, .35) inset, 0 0 30px rgba(255, 122, 217, .35)
    }

    .big-btn.jump {
      border-color: rgba(122, 213, 255, .85);
      box-shadow: 0 6px 26px rgba(0, 0, 0, .35), 0 0 30px rgba(122, 213, 255, .35) inset, 0 0 30px rgba(122, 213, 255, .35)
    }

    .btn-container {
      position: relative;
    }

    .rage-shield-container {
      position: absolute;
      right: -80px;
      top: 0%;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      gap: 15px;
    }

    .rage-shield-btn {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, .28);
      background: radial-gradient(120% 160% at 30% 20%, rgba(255, 255, 255, .14), rgba(255, 255, 255, .02));
      color: #fff;
      font-weight: 900;
      letter-spacing: .04em;
      font-size: 12px;
      box-shadow: 0 6px 26px rgba(0, 0, 0, .35), 0 0 30px rgba(255, 255, 255, .18) inset, 0 0 30px rgba(122, 213, 255, .28);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .rage-shield-btn.rage {
      border-color: rgba(255, 100, 100, .8);
      box-shadow: 0 6px 26px rgba(0, 0, 0, .35), 0 0 30px rgba(255, 100, 100, .35) inset, 0 0 30px rgba(255, 100, 100, .35)
    }

    .rage-shield-btn.shield {
      border-color: rgba(100, 200, 255, .8);
      box-shadow: 0 6px 26px rgba(0, 0, 0, .35), 0 0 30px rgba(100, 200, 255, .35) inset, 0 0 30px rgba(100, 200, 255, .35)
    }

    .rage-shield-btn.ai {
      border-color: rgba(150, 100, 255, .8);
      box-shadow: 0 6px 26px rgba(0, 0, 0, .35), 0 0 30px rgba(150, 100, 255, .35) inset, 0 0 30px rgba(150, 100, 255, .35);
      background: linear-gradient(135deg, rgba(150, 100, 255, .2), rgba(200, 150, 255, .3));
    }

    #vj-left .shared-gauge {
      position: absolute;
      top: -18px;
      left: 0;
      right: 0;
      height: 4px;
      pointer-events: none;
    }

    #vj-left .shared-gauge .fill {
      transform-origin: left center;
    }

    @media (max-width: 1024px) {
      #vj-wrap {
        padding: 8px;
        grid-template-columns: 1fr;
        gap: 28px;
      }

      #vj-right {
        justify-self: center;
        margin-right: 0;
        margin-bottom: 20px;
      }

      .rage-shield-container {
        right: -70px;
      }
    }
  </style>
</head>

<body>
  <div id="wrap">
    <canvas height="720" id="cv" width="1280"></canvas>
    <!-- Compact HUD -->
    <div id="compact-hud">
      <div>HP: 56/200</div>
      <div>ATK: 21</div>
      <div>DEF: 5</div>
    </div>
    <!-- HUD -->
    <div class="hud">
      <div class="pill" id="stagePill">Stage 1 • Wave 1/10 • Kills 0</div>
      <div class="team-status" id="teamStatus">
        <div class="hero-portrait leader secret-ready rage-ready" id="heroA1">
          <div class="hero-icon">A1</div>
          <div class="hero-hp-bar">
            <div class="hero-hp-fill"></div>
          </div>
          <div class="secret-gauge">
            <div class="secret-fill"></div>
          </div>
          <div class="rage-gauge">
            <div class="rage-fill"></div>
          </div>
          <div class="hero-skill-icons">
            <div class="skill-icon s1 ready"></div>
            <div class="skill-icon s2 ready"></div>
          </div>
          <div class="hero-status">OK</div>
        </div>
        <div class="hero-portrait hero-unique-cursor" id="heroUnique">
          <div class="hero-icon">U</div>
          <div class="hero-hp-bar">
            <div class="hero-hp-fill hero-unique-hp-fill"></div>
          </div>
          <div class="secret-gauge">
            <div class="secret-fill hero-unique-secret-fill"></div>
          </div>
          <div class="rage-gauge">
            <div class="rage-fill hero-unique-rage-fill"></div>
          </div>
          <div class="hero-skill-icons hero-unique-skill-icons">
            <div class="skill-icon s1 ready"></div>
            <div class="skill-icon s2 ready"></div>
          </div>
          <div class="hero-status">OK</div>
        </div>
        <div class="hero-portrait hero-missy-cursor" id="heroMissy">
          <div class="hero-icon">M</div>
          <div class="hero-hp-bar">
            <div class="hero-hp-fill hero-missy-hp-fill"></div>
          </div>
          <div class="secret-gauge">
            <div class="secret-fill hero-missy-secret-fill"></div>
          </div>
          <div class="rage-gauge">
            <div class="rage-fill hero-missy-rage-fill"></div>
          </div>
          <div class="hero-skill-icons hero-missy-skill-icons">
            <div class="skill-icon s1 ready"></div>
            <div class="skill-icon s2 ready"></div>
          </div>
          <div class="hero-status">OK</div>
        </div>
      </div>
      <button class="btn btn-switch-char" id="btnSwitchChar">Switch</button>
      <div class="bar">
        <div class="fill hp hp-fill" id="hpFill"></div>
      </div>
      <div class="bar">
        <div class="fill mp mp-fill" id="mpFill"></div>
      </div>
      <div class="bar xp-bar-container">
        <div class="fill xp xp-dom-fill" id="xpDomFill"></div>
        <div class="xpText" id="xpDomLabel">75/80 XP — Lv 1</div>
      </div>
      <div class="bar boss-bar-container">
        <div class="fill boss boss-fill" id="bossFill"></div>
      </div>
      <div class="pill" id="boostPill">Lv 1 • Booster: -</div>
    </div>
    <!-- Dock -->
    <div class="subdock">
      <button class="btn" id="btnSpeed">×1</button>
      <button class="btn" id="btnInventory">Items</button>
      <button class="btn" id="btnPets">Pets</button>
      <button class="btn" id="btnVehicles">Vehicles</button>
      <button class="btn" id="btnTalents">Talents</button>
      <button class="btn" id="btnAuto">Auto: ON</button>
      <button class="btn" id="btnStart">Pause</button>
      <button class="btn" id="btnShop">Shop</button>
      <button class="btn" id="btnSettings">Settings</button>
      <!-- A1K UI: Team button -->
      <button class="btn hud-btn a1k-ui" id="btnTeam">Team</button>
      <!-- Added UI toggle button to hide top HUD -->
      <button class="btn" id="btnHideUITop">UI</button>
    </div>
    <div id="teamCompanionPanel" class="companion-panel" aria-live="polite"></div>
    <div class="hud" id="currency">
      <span class="muted">??</span>
      <span class="muted">??</span>
      <div class="pill gold-pill">Gold: <b id="goldVal">7781</b></div>
      <div class="pill toggle-currencies" id="toggleCurrencies">+ More</div>
      <div class="extra-currencies" id="extra-currencies">
        <div class="pill">Silver: <b id="silverVal">0</b></div>
        <div class="pill">Tickets: <b id="ticketVal">0</b></div>
        <div class="pill">Gems: <b id="gemVal">0</b></div>
        <div class="pill">Boss Kills: <b id="bossKillsVal">2</b></div>
        <div class="pill" id="giftKeysPill">Gift Keys: <b id="giftKeyVal">4</b></div>
        <div class="pill" id="bossKeysPill">Boss Keys: <b id="bossKeyVal">0</b></div>
      </div>
      <div class="pill drop-rate-display" id="dropRateDisplay">Drop Rate: <b>10%</b></div>
      <div class="mini-map-wrap" id="miniMapWrap">
        <canvas id="mini" width="132" height="132" class="mini-map-canvas"></canvas>
        <button id="btnMap" class="pill mini-map-toggle">Hide Map</button>
      </div>
    </div>
    <!-- Tamed Companion HUD -->
    <div id="companionHUD" class="companion-panel" aria-live="polite"></div>
    <!-- Bag Overlay -->
    <aside class="bag-overlay" id="inventory">
      <div class="bag-header">
        <div class="bag-header-flex">
          <h3>Bag</h3>
          <div>
            <span>Gold: <span id="bagGoldVal">7781</span></span>
            <button aria-label="Close" class="drawer-close" id="btnCloseBag">×</button>
          </div>
        </div>
        <div class="bag-auto-actions bag-auto-actions-width">
          <button class="btn-auto" id="btnOpenAll">Open All</button>
          <button class="btn-auto" id="btnAutoUp">Auto Up</button>
          <button class="btn-auto" id="btnAutoEq">Auto Eq</button>
          <button class="btn-auto" id="btnAutoFuse">Auto Fuse</button>
          <button class="btn-auto" id="btnAutoSell">Auto Sell</button>
          <button class="btn-auto" id="btnAlchemy">Alchemy</button>
          <button class="btn-auto auto-ai-off" id="btnAutoAI" data-auto-ai-toggle="true">Auto AI: OFF</button>
        </div>
      </div>
      <div class="bag-body">
        <div class="bag-nav">
          <button class="bag-nav-item" data-tab="items">Items</button>
          <button class="bag-nav-item" data-tab="stats">Stats</button>
          <button class="bag-nav-item" data-tab="gear">Gear</button>
          <button class="bag-nav-item" data-tab="pets">Pets</button>
          <button class="bag-nav-item" data-tab="skins">Skins</button>
          <button class="bag-nav-item" data-tab="talent">Talents</button>
          <button class="bag-nav-item" data-tab="vehicles">Vehicles</button>
          <button class="bag-nav-item" data-tab="ai">AI</button>
          <button class="bag-nav-item" data-tab="alchemy">Alchemy</button>
          <button class="bag-nav-item" data-tab="buttons">Buttons</button>
          <button class="bag-nav-item" data-tab="spirit">Spirit</button>
          <button class="bag-nav-item" data-tab="supernatural">Supernatural</button>
          <button class="bag-nav-item" data-tab="quests">Quests</button>
          <button class="bag-nav-item" data-tab="shop">Shop</button>
          <button class="bag-nav-item" data-tab="settings">Settings</button>
          <button class="bag-nav-item" data-tab="paper">Paper Doll</button>
        </div>
        <div class="bag-content">
          <!-- NEW: Stats / Level / Evolution -->
          <div class="bag-panel" id="bag-stats">
            <div class="card">
              <h4>Player Stats</h4>
              <div class="player-stats-flex">
                <div>Level: <b id="statLevel">1</b></div>
                <div>XP: <b id="statXP">0</b> / <b id="statXPTo">80</b></div>
                <div>ATK: <b id="statATK">20</b></div>
                <div>DEF: <b id="statDEF">0</b></div>
                <div>HP: <b id="statHP">100</b></div>
              </div>
              <div class="xp-bar">
                <div class="fill" id="statsXpFill"></div>
              </div>
              <div class="evolution-section">
                <button class="btn" disabled="disabled" id="btnEvolve">Evolve (Lv10 + 2 Boss)</button>
                <small class="muted">Evolution demo rule. Grants +15 ATK, +80 HP.</small>
              </div>
            </div>
          </div>
          <div class="bag-panel" id="bag-items">
            <div class="bag-storage-info">
              <h4>Unlimited Storage</h4>
              <p>Your bag has unlimited capacity - collect as many items as you want!</p>
            </div>
            <div class="bag-grid" id="bagGrid">
              <div class="slot-box">+</div>
            </div>
          </div>
          <div class="bag-panel" id="bag-gear">
            <div class="gear-grid" id="gearSlots">
              <div class="slot-box equip">+ weapon</div>
              <div class="slot-box equip">+ armor</div>
              <div class="slot-box equip">+ acc1</div>
              <div class="slot-box equip">+ acc2</div>
            </div>
            <hr class="gear-hr" />
            <div class="bag-grid" id="gearGrid">
              <div class="slot-box item">Cracked Buckler</div>
              <div class="slot-box item">Rusty Blade</div>
              <div class="slot-box item">Cracked Buckler</div>
              <div class="slot-box item">Cracked Buckler</div>
              <div class="slot-box item">Cracked Buckler</div>
              <div class="slot-box item">Rusty Blade</div>
              <div class="slot-box item">Gleam Ring</div>
              <div class="slot-box item">Rusty Blade</div>
              <div class="slot-box item">Rusty Blade</div>
              <div class="slot-box item">Gleam Ring</div>
              <div class="slot-box item">Gleam Ring</div>
              <div class="slot-box item">Rusty Blade</div>
              <div class="slot-box item">Cracked Buckler</div>
              <div class="slot-box item">Cracked Buckler</div>
              <div class="slot-box item">Cracked Buckler</div>
              <div class="slot-box item">Cracked Buckler</div>
              <div class="slot-box item">Gleam Ring</div>
              <div class="slot-box item">Gleam Ring</div>
              <div class="slot-box item">Rusty Blade</div>
              <div class="slot-box item">Rusty Blade</div>
              <div class="slot-box item">Rusty Blade</div>
              <div class="slot-box item">Cracked Buckler</div>
              <div class="slot-box item">Gleam Ring</div>
              <div class="slot-box item">Cracked Buckler</div>
              <div class="slot-box item">Cracked Buckler</div>
              <div class="slot-box item">Gleam Ring</div>
              <div class="slot-box item">Gleam Ring</div>
              <div class="slot-box item">Cracked Buckler</div>
              <div class="slot-box item">Cracked Buckler</div>
              <div class="slot-box item">Cracked Buckler</div>
              <div class="slot-box item">Cracked Buckler</div>
            </div>
          </div>
          <div class="bag-panel" id="bag-pets">
            <div class="pets-grid" id="petsGrid">
              <div class="slot-box equip pet">Pet Slot 1</div>
              <hr class="pet-hr" />
            </div>
          </div>
          <div class="bag-panel" id="bag-skins">
            <div class="skins-container">
              <div class="character-skins">
                <h3>A1 Skins</h3>
                <div id="skinsA1Grid" class="skins-grid"></div>
              </div>
              <div class="character-skins">
                <h3>Unique Skins</h3>
                <div id="skinsUniqueGrid" class="skins-grid"></div>
              </div>
              <div class="character-skins">
                <h3>Missy Skins</h3>
                <div id="skinsMissyGrid" class="skins-grid"></div>
              </div>
            </div>
            <div id="skinPreview" class="skin-preview">
              <canvas id="skinPreviewCanvas" width="200" height="200"></canvas>
              <div class="skin-info">
                <h4 id="skinName">Select a skin</h4>
                <p id="skinDescription">Choose a skin to preview</p>
                <button id="btnEquipSkin" class="btn-primary">Equip</button>
              </div>
            </div>
          </div>
          <div class="bag-panel" id="bag-talent">
            <div class="lane-wrap" id="talentLaneWrap">
              <div class="lane-col">
                <h4>ATK</h4>
                <div class="lane-node locked"><span>+5% ATK</span><span class="cost">AP 1</span><button
                    disabled="disabled">Buy</button></div>
                <div class="lane-node locked"><span>+8% ATK</span><span class="cost">AP 2</span><small>Requires
                    atk_1</small><button disabled="disabled">Buy</button></div>
                <div class="lane-node locked"><span>+12% ATK</span><span class="cost">AP 3</span><small>Requires
                    atk_2</small><button disabled="disabled">Buy</button></div>
                <div class="lane-node locked"><span>+15% ATK + Crit Chance</span><span class="cost">AP
                    4</span><small>Requires atk_3</small><button disabled="disabled">Buy</button></div>
                <div class="lane-node locked"><span>Berserker: ATK scales with missing HP</span><span class="cost">AP
                    5</span><small>Requires atk_4</small><button disabled="disabled">Buy</button></div>
                <div class="lane-node locked"><span>APEX HUNTER: +50% ATK, kills grant rage</span><span class="cost">AP
                    8</span><small>Requires atk_5</small><button disabled="disabled">Buy</button></div>
              </div>
              <div class="lane-col">
                <h4>DEF</h4>
                <div class="lane-node locked"><span>+80 HP</span><span class="cost">AP 1</span><button
                    disabled="disabled">Buy</button></div>
                <div class="lane-node locked"><span>+120 HP</span><span class="cost">AP 2</span><small>Requires
                    def_1</small><button disabled="disabled">Buy</button></div>
                <div class="lane-node locked"><span>+160 HP</span><span class="cost">AP 3</span><small>Requires
                    def_2</small><button disabled="disabled">Buy</button></div>
                <div class="lane-node locked"><span>+200 HP + 10% Damage Reduction</span><span class="cost">AP
                    4</span><small>Requires def_3</small><button disabled="disabled">Buy</button></div>
                <div class="lane-node locked"><span>Guardian: Nearby allies take 20% less damage</span><span
                    class="cost">AP 5</span><small>Requires def_4</small><button disabled="disabled">Buy</button></div>
                <div class="lane-node locked"><span>FORTRESS: Team immunity when at low HP</span><span class="cost">AP
                    8</span><small>Requires def_5</small><button disabled="disabled">Buy</button></div>
              </div>
              <div class="lane-col">
                <h4>RECOVERY</h4>
                <div class="lane-node locked"><span>+6% Lifesteal</span><span class="cost">AP 1</span><button
                    disabled="disabled">Buy</button></div>
                <div class="lane-node locked"><span>+10% Lifesteal</span><span class="cost">AP 2</span><small>Requires
                    rec_1</small><button disabled="disabled">Buy</button></div>
                <div class="lane-node locked"><span>+15% Lifesteal + HP Regen</span><span class="cost">AP
                    3</span><small>Requires rec_2</small><button disabled="disabled">Buy</button></div>
                <div class="lane-node locked"><span>Vampiric: Killing blows fully heal</span><span class="cost">AP
                    4</span><small>Requires rec_3</small><button disabled="disabled">Buy</button></div>
                <div class="lane-node locked"><span>PHOENIX: Auto-revive on death (once per stage)</span><span
                    class="cost">AP 7</span><small>Requires rec_4</small><button disabled="disabled">Buy</button></div>
              </div>
              <div class="lane-col">
                <h4>COOLDOWN</h4>
                <div class="lane-node locked"><span>-8% Skill CD</span><span class="cost">AP 1</span><button
                    disabled="disabled">Buy</button></div>
                <div class="lane-node locked"><span>-12% Skill CD</span><span class="cost">AP 2</span><small>Requires
                    cd_1</small><button disabled="disabled">Buy</button></div>
                <div class="lane-node locked"><span>-15% Skill CD + Movement Speed</span><span class="cost">AP
                    3</span><small>Requires cd_2</small><button disabled="disabled">Buy</button></div>
                <div class="lane-node locked"><span>Cascade: Skills have 25% chance to reset CD</span><span
                    class="cost">AP 4</span><small>Requires cd_3</small><button disabled="disabled">Buy</button></div>
                <div class="lane-node locked"><span>TIME MASTER: All abilities cost 50% less CD</span><span
                    class="cost">AP 7</span><small>Requires cd_4</small><button disabled="disabled">Buy</button></div>
              </div>
              <div class="lane-col">
                <h4>LUCK</h4>
                <div class="lane-node locked"><span>+8 Luck</span><span class="cost">AP 1</span><button
                    disabled="disabled">Buy</button></div>
                <div class="lane-node locked"><span>+15 Luck</span><span class="cost">AP 2</span><small>Requires
                    luck_1</small><button disabled="disabled">Buy</button></div>
                <div class="lane-node locked"><span>+25 Luck + Gold Find</span><span class="cost">AP
                    3</span><small>Requires luck_2</small><button disabled="disabled">Buy</button></div>
                <div class="lane-node locked"><span>Fortune: 10% chance for double loot</span><span class="cost">AP
                    4</span><small>Requires luck_3</small><button disabled="disabled">Buy</button></div>
                <div class="lane-node locked"><span>Jackpot: Rare items can upgrade quality</span><span class="cost">AP
                    5</span><small>Requires luck_4</small><button disabled="disabled">Buy</button></div>
                <div class="lane-node locked"><span>GOLDEN TOUCH: Everything drops gold, permanent luck aura</span><span
                    class="cost">AP 8</span><small>Requires luck_5</small><button disabled="disabled">Buy</button></div>
              </div>
            </div>
            <div id="talentSummary">AP: 0/0
              Luck: 0
              ATK Mult: 1.00x</div>
          </div>
          <div class="bag-panel" id="bag-vehicles">
            <div class="vehicles-grid" id="vehiclesGrid">
              <div class="slot-box equip vehicle">Equip Vehicle</div>
              <hr class="vehicle-hr" />
            </div>
          </div>
          <!-- AI Panel -->
          <div class="bag-panel" id="bag-ai">
            <div class="card">
              <h4>AI Assistant</h4>
              <div class="ai-controls">
                <div class="ai-status">
                  <span>Status: <span id="aiStatus">Ready</span></span>
                </div>
                <div class="ai-actions">
                  <button class="btn" id="aiSummonBtn">Summon AI</button>
                  <button class="btn" id="aiRecallBtn">Recall AI</button>
                  <button class="btn" id="aiUpgradeBtn">Upgrade AI</button>
                </div>
                <div class="ai-info">
                  <p>AI Assistant helps with combat and exploration.</p>
                  <p>Current Level: <span id="aiLevel">1</span></p>
                  <p>Experience: <span id="aiExp">0</span> / <span id="aiExpMax">100</span></p>
                </div>
              </div>
            </div>
            <div class="card">
              <h4>AI Bag Features</h4>
              <div class="ai-bag-features">
                <button class="btn" id="btnAutoAISecondary" data-auto-ai-toggle="true">Auto AI: OFF</button>
                <button class="btn" id="btnAISummonPanel">AI Summon</button>
                <button class="btn" id="btnAIConfig">AI Config</button>
                <button class="btn" id="btnAIStats">AI Stats</button>
              </div>
            </div>
          </div>
          <!-- Alchemy Panel -->
          <div class="bag-panel" id="bag-alchemy">
            <div class="card">
              <h4>Alchemy Station</h4>
              <div class="alchemy-crafting-area">
                <div class="alchemy-slots">
                  <div class="slot-box" data-slot="1">?</div>
                  <div class="slot-box" data-slot="2">?</div>
                  <div class="slot-box" data-slot="3">?</div>
                </div>
                <div class="alchemy-arrow">→</div>
                <div class="alchemy-result">
                  <div class="slot-box">RESULT</div>
                </div>
              </div>
              <div class="bag-auto-actions">
                <button class="btn-auto" id="btnCombine">Combine</button>
              </div>
              <div class="alchemy-rules-boxes">
                <div class="info-box">Rules: • Grades: C,B • Exclude equipped • Keep A/S safe</div>
                <div class="info-box">Types: [✓] Gear [✓] Pet [ ] Vehicle [ ] Boxes</div>
                <div class="info-box">Special Recipe: C gear + B gear + C pet → Random (gear/pet/gift/box)</div>
              </div>
            </div>
          </div>
          <!-- Buttons Panel -->
          <div class="bag-panel" id="bag-buttons">
            <div class="card">
              <h4>Button Controls</h4>
              <div class="button-controls">
                <div class="control-group">
                  <h5>Show/Hide UI Elements</h5>
                  <button class="btn" id="btnHideAll">Hide All Buttons</button>
                  <button class="btn" id="btnShowAll">Show All Buttons</button>
                  <button class="btn" id="btnHideUI">Hide UI</button>
                  <button class="btn" id="btnShowUI">Show UI</button>
                </div>
                <div class="control-group">
                  <h5>Individual Controls</h5>
                  <label><input type="checkbox" id="toggleJoystick" checked> Joystick</label>
                  <label><input type="checkbox" id="toggleSkills" checked> Skills (S1-S3)</label>
                  <label><input type="checkbox" id="toggleActions" checked> Actions (Attack/Jump)</label>
                  <label><input type="checkbox" id="toggleRageShield" checked> Rage/Shield</label>
                  <label><input type="checkbox" id="toggleAI" checked> AI Button</label>
                </div>
                <div class="control-group">
                  <h5>Position Memory</h5>
                  <button class="btn" id="btnResetPositions">Reset to Defaults</button>
                  <button class="btn" id="btnSavePositions">Save Current Positions</button>
                </div>
                <div class="control-group">
                  <h5>Control Sizing</h5>
                  <label>Size Preset:
                    <select id="sizePreset">
                      <option value="0.6">Small (60%)</option>
                      <option value="0.7" selected>Medium (70%)</option>
                      <option value="0.85">Large (85%)</option>
                      <option value="1.0">XLarge (100%)</option>
                    </select>
                  </label>
                  <label>Custom Size:
                    <input type="range" id="sizeSlider" min="0.5" max="1.2" step="0.05" value="0.7">
                    <span id="sizeValue">70%</span>
                  </label>
                  <button class="btn" id="btnAutoSize">Auto-Detect Size</button>
                </div>
              </div>
            </div>
          </div>
          <div class="bag-panel" id="bag-spirit">
            <div class="card">
              <h4>Spirit Collection</h4>
              <div class="spirit-interface">
                <div class="character-aura">
                  <h5>Character Auras</h5>
                  <div class="aura-display">
                    <div class="aura-item" data-character="a1">
                      <div class="aura-icon">👼</div>
                      <div class="aura-name">A1 - Arch Angel</div>
                      <div class="aura-type">Dual Aura (Dark + Light)</div>
                      <div class="aura-level">Unlock: Level 50</div>
                      <div class="aura-preview aura-dual"></div>
                    </div>
                    <div class="aura-item" data-character="missy">
                      <div class="aura-icon">✨</div>
                      <div class="aura-name">Missy - Golden Guardian</div>
                      <div class="aura-type">Gold Aura</div>
                      <div class="aura-level">Unlock: Level 15</div>
                      <div class="aura-preview aura-gold"></div>
                    </div>
                    <div class="aura-item" data-character="unique">
                      <div class="aura-icon">💎</div>
                      <div class="aura-name">Unique - Tech Spirit</div>
                      <div class="aura-type">Pink Tech Aura</div>
                      <div class="aura-level">Unlock: Level 15</div>
                      <div class="aura-preview aura-pink"></div>
                    </div>
                  </div>
                </div>
                <div class="spirit-collection">
                  <h5>Spirit Collection</h5>
                  <div class="spirit-grid" id="spiritGrid">
                    <div class="spirit-item" data-spirit="dark-soul">
                      <div class="spirit-icon">🌑</div>
                      <div class="spirit-name">Dark Soul</div>
                      <div class="spirit-type">Dark Energy</div>
                      <div class="spirit-power">Power: 85</div>
                      <div class="spirit-level">Level: 1</div>
                    </div>
                    <div class="spirit-item" data-spirit="light-soul">
                      <div class="spirit-icon">☀️</div>
                      <div class="spirit-name">Light Soul</div>
                      <div class="spirit-type">Light Energy</div>
                      <div class="spirit-power">Power: 90</div>
                      <div class="spirit-level">Level: 1</div>
                    </div>
                    <div class="spirit-item" data-spirit="golden-spirit">
                      <div class="spirit-icon">🏆</div>
                      <div class="spirit-name">Golden Spirit</div>
                      <div class="spirit-type">Gold Energy</div>
                      <div class="spirit-power">Power: 75</div>
                      <div class="spirit-level">Level: 1</div>
                    </div>
                    <div class="spirit-item" data-spirit="tech-essence">
                      <div class="spirit-icon">⚡</div>
                      <div class="spirit-name">Tech Essence</div>
                      <div class="spirit-type">Tech Energy</div>
                      <div class="spirit-power">Power: 80</div>
                      <div class="spirit-level">Level: 1</div>
                    </div>
                  </div>
                </div>
                <div class="equipped-spirit">
                  <h5>Equipped Spirit</h5>
                  <div class="spirit-slot" id="equippedSpirit">
                    <div class="spirit-icon">❌</div>
                    <div class="spirit-name">No Spirit Equipped</div>
                    <div class="spirit-desc">Select a spirit to equip</div>
                  </div>
                </div>
                <div class="spirit-actions">
                  <button class="btn" id="equipSpirit" disabled>Equip Selected</button>
                  <button class="btn" id="unequipSpirit" disabled>Unequip</button>
                </div>
              </div>
            </div>
          </div>
          <div class="bag-panel" id="bag-supernatural">
            <div class="card">
              <h4>Supernatural Abilities</h4>
              <div class="supernatural-interface">
                <div class="system-notice">
                  <h5>🚧 System Under Development</h5>
                  <p>The Supernatural abilities system is currently being developed. This will include:</p>
                  <ul>
                    <li>Character-specific supernatural powers</li>
                    <li>Aura customization and progression</li>
                    <li>Ability trees and skill unlocks</li>
                    <li>Supernatural combat abilities</li>
                    <li>Mystical item crafting</li>
                  </ul>
                </div>
                <div class="character-supernatural">
                  <h5>Character Supernatural Profiles</h5>
                  <div class="supernatural-profiles">
                    <div class="profile-item" data-character="a1">
                      <div class="profile-icon">👼</div>
                      <div class="profile-name">A1 - Arch Angel</div>
                      <div class="profile-type">Dual Energy Master</div>
                      <div class="profile-status">Coming Soon</div>
                    </div>
                    <div class="profile-item" data-character="missy">
                      <div class="profile-icon">✨</div>
                      <div class="profile-name">Missy - Golden Guardian</div>
                      <div class="profile-type">Light Energy Specialist</div>
                      <div class="profile-status">Coming Soon</div>
                    </div>
                    <div class="profile-item" data-character="unique">
                      <div class="profile-icon">💎</div>
                      <div class="profile-name">Unique - Tech Spirit</div>
                      <div class="profile-type">Tech-Mystic Hybrid</div>
                      <div class="profile-status">Coming Soon</div>
                    </div>
                  </div>
                </div>
                <div class="development-timeline">
                  <h5>Development Roadmap</h5>
                  <div class="timeline-item">
                    <span class="timeline-phase">Phase 1:</span> Basic aura system integration
                  </div>
                  <div class="timeline-item">
                    <span class="timeline-phase">Phase 2:</span> Character-specific abilities
                  </div>
                  <div class="timeline-item">
                    <span class="timeline-phase">Phase 3:</span> Ability progression trees
                  </div>
                  <div class="timeline-item">
                    <span class="timeline-phase">Phase 4:</span> Supernatural combat integration
                  </div>
                </div>
              </div>
            </div>
          </div>
          <!-- Paper Doll preview panel -->
          <div class="bag-panel" id="bag-paper">
            <div class="paper-doll-container" id="paperDoll">
              <div class="paper-doll-hero">
                <div class="paper-doll-hero-title">Hero</div>
                <div class="paper-doll-hero-display">Hero</div>
              </div>
              <div class="paper-doll-equipment">
                <div class="paper-doll-section-title">Equipment</div>
                <div class="slot-box equip paper-doll-slot" id="paperWeapon">Weapon 1</div>
                <div class="slot-box equip paper-doll-slot" id="paperWeapon2">Weapon 2</div>
                <div class="slot-box equip paper-doll-slot" id="paperArmor">Armor</div>
                <div class="slot-box equip paper-doll-slot" id="paperAcc1">Accessory 1</div>
                <div class="slot-box equip paper-doll-slot" id="paperAcc2">Accessory 2</div>
                <div class="paper-doll-pets-title">Pets</div>
                <div class="slot-box pet paper-doll-slot" id="paperPet1">Pet 1</div>
                <div class="slot-box pet paper-doll-slot" id="paperPet2">Pet 2</div>
                <div class="paper-doll-vehicle-title">Vehicle</div>
                <div class="slot-box equip paper-doll-slot" id="paperVeh">Vehicle</div>
              </div>
            </div>
          </div>
          <div class="bag-panel" id="bag-quests">
            <div class="quest-content" id="questsContent">
              <h4 class="quest-header-title">Daily Quests <span class="quest-timer" id="questTimer">23h 57m 53s</span>
              </h4>
              <div class="quest-list" id="questsList">
                <div class="quest-item completed">
                  <div class="quest-header">
                    <div class="quest-name">Stage Clear <span class="quest-tier bronze">Bronze</span></div>
                    <div class="quest-progress">5/5</div>
                  </div>
                  <div class="quest-description">Reach Stage 5</div>
                  <div class="quest-progress-bar">
                    <div class="quest-progress-fill quest-progress-fill-complete"></div>
                  </div>
                  <div class="quest-reward">Reward: 300 gold, 5 tickets <span
                      class="quest-reward-claimed">(Claimed)</span></div>
                </div>
                <div class="quest-item completed">
                  <div class="quest-header">
                    <div class="quest-name">Stage Clear <span class="quest-tier bronze">Bronze</span></div>
                  </div>
                  <div class="quest-description">Reach Stage 5</div>
                  <div class="quest-progress-bar">
                    <div class="quest-progress-fill quest-progress-fill-complete"></div>
                  </div>
                  <div class="quest-reward">Reward: 300 gold, 5 tickets <span
                      class="quest-reward-claimed">(Claimed)</span></div>
                </div>
                <div class="quest-item">
                  <div class="quest-header">
                    <div class="quest-name">Skyfall <span class="quest-tier silver">Silver</span></div>
                    <div class="quest-progress">0/20</div>
                  </div>
                  <div class="quest-description">Defeat 20 flying enemies</div>
                  <div class="quest-progress-bar">
                    <div class="quest-progress-fill quest-progress-fill-partial"></div>
                  </div>
                  <div class="quest-reward">Reward: 400 gold, 5 gems</div>
                </div>
              </div>
              <div class="quest-footer">
                <p class="quest-footer-text">Quests refresh daily. Complete them for rewards!</p>
                <div class="endless-stats" id="endlessStats">
                  <h5 class="endless-title">Endless Mode</h5>
                  <p class="endless-score">Score: <span id="endlessScore">0</span></p>
                  <p class="endless-time">Time: <span id="endlessTime">0:00</span></p>
                </div>
              </div>
            </div>
          </div>
          <div class="bag-panel" id="bag-shop">
            <div class="shop-tabs-container" id="shopTabs"><button class="shop-tab" data-cat="all"
                type="button">All</button><button class="shop-tab shop-tab-active" data-cat="consumable"
                type="button">Consumables</button><button class="shop-tab" data-cat="gear"
                type="button">Gear</button><button class="shop-tab" data-cat="armor" type="button">Armor</button><button
                class="shop-tab" data-cat="scroll" type="button">Scrolls</button></div>
            <div class="shop-grid" id="shopGrid">
              <div class="shop-item">
                <h5>HP Potion</h5>
                <p>Heals 40% leader HP.</p>
                <p><b>Cost: 60 Gold</b></p><button data-id="hp_potion" type="button">Buy</button>
              </div>
              <div class="shop-item">
                <h5>Rage Pill</h5>
                <p>Grants +30 Rage to party.</p>
                <p><b>Cost: 90 Gold</b></p><button data-id="rage_pill" type="button">Buy</button>
              </div>
              <div class="shop-item">
                <h5>Revive Token</h5>
                <p>Instantly revives one defeated hero.</p>
                <p><b>Cost: 80 Gold</b></p><button data-id="revive_token" type="button">Buy</button>
              </div>
              <div class="shop-item">
                <h5>Wave Skip</h5>
                <p>Skips the current wave.</p>
                <p><b>Cost: 100 Gold</b></p><button data-id="wave_skip" type="button">Buy</button>
              </div>
              <div class="shop-item">
                <h5>Stage Skip</h5>
                <p>Skips the current stage.</p>
                <p><b>Cost: 500 Gold</b></p><button data-id="stage_skip" type="button">Buy</button>
              </div>
              <div class="shop-item">
                <h5>Boss Skip Pass</h5>
                <p>Skips to the next boss.</p>
                <p><b>Cost: 1000 Gold</b></p><button data-id="boss_skip_pass" type="button">Buy</button>
              </div>
              <div class="shop-item">
                <h5>Treasure Box Boss Pass</h5>
                <p>Unlocks a special treasure boss.</p>
                <p><b>Cost: 2000 Gold</b></p><button data-id="treasure_box_boss_pass" type="button">Buy</button>
              </div>
              <div class="shop-item">
                <h5>AP Reset</h5>
                <p>Refund all spent AP.</p>
                <p><b>Cost: 400 Gold</b></p><button data-id="ap_reset" type="button">Buy</button>
              </div>
              <div class="shop-item">
                <h5>Convert 1 Diamond</h5>
                <p>+1000 Gold</p><button id="cvGem">Convert</button>
              </div>
              <div class="shop-item">
                <h5>Convert 1 Ticket</h5>
                <p>+5000 Gold</p><button id="cvTix">Convert</button>
              </div>
            </div>
          </div>
          <div class="bag-panel active" id="bag-settings">
            <div class="card settings-card">
              <h4 class="settings-title">Game Settings</h4>
              <label class="settings-label"><input checked="checked" id="setting-auto-ai" type="checkbox" />
                Auto-AI</label>
              <label class="settings-label"><input checked="checked" id="setting-parallax" type="checkbox" /> Parallax
                Background</label>
              <label class="settings-label"><input checked="checked" id="setting-backtick" type="checkbox" /> Backtick
                toggles QA</label>
              <div class="settings-theme-group">
                <span class="settings-label">Visual Theme</span>
                <div class="settings-theme-row">
                  <button class="settings-theme-button" id="btnThemeCandy">Candy Mode</button>
                  <button class="settings-theme-button" id="btnThemeStory">Story Mode</button>
                </div>
                <small class="settings-qa-note">Candy Mode enables chibi renders and pastel palette; Story restores the classic look.</small>
              </div>
              <div class="settings-qa-section">
                <button class="settings-qa-button" id="btnOpenQA">Open QA Panel</button>
                <small class="settings-qa-note">(` also toggles)</small>
              </div>
            </div>
            <div class="card" id="qaTools">
              <h4>QA Tools</h4>
              <div class="qa-tools-flex">
                <button class="btn" id="qaMaxGold">Max Gold</button>
                <button class="btn" id="qaGems">+Gems</button>
                <button class="btn" id="qaStagePlus">Stage +</button>
                <button class="btn" id="qaStageMinus">Stage -</button>
                <button class="btn" id="qaSkipBoss">Skip to Boss</button>
                <button class="btn" id="qaKeys">Give Keys</button>
                <button class="btn" id="qaChestTrio">Chest Trio</button>
                <button class="btn" id="qaGodMode">God Mode</button>
              </div>
            </div>
            <div class="card">
              <h4>Sprite Loader Status:</h4>
              <div class="muted" id="loaderStatus">Loading…</div>
              <small class="muted">Put PNG/GIF in <code>assets/img/</code>. Falls back to proxies.</small>
            </div>
            <!-- Audio settings card -->
            <div class="card">
              <h4>Audio Settings</h4>
              <label class="settings-label-block">
                Music Volume
                <input class="audio-volume-slider audio-volume-slider-full" id="musicVolSlider" max="1" min="0"
                  step="0.01" type="range" value="1" />
              </label>
              <label class="settings-label-block">
                SFX Volume
                <input class="audio-volume-slider audio-volume-slider-full" id="sfxVolSlider" max="1" min="0"
                  step="0.01" type="range" value="1" />
              </label>
              <small class="muted">Use sliders to adjust music and sound effect volumes.</small>
            </div>
            <!-- HUD settings card -->
            <div class="card">
              <h4>HUD Settings</h4>
              <label class="settings-label-block-top">
                <input checked="checked" id="hudVisibleToggle" type="checkbox" /> Show Hero HUD
              </label>
              <label class="settings-label-block">
                Position
                <select class="hud-position-select hud-position-select-spaced" id="hudPositionSelect">
                  <option selected="selected" value="top-right">Top Right</option>
                  <option value="top-left">Top Left</option>
                  <option value="bottom-left">Bottom Left</option>
                  <option value="bottom-right">Bottom Right</option>
                </select>
              </label>
              <small class="muted">Toggle visibility and position of the stats HUD.</small>
            </div>
          </div>
        </div>
        <div class="bag-detail">
          <div class="bag-detail-content" id="detailContent">
            <h4 id="detailName">Select Item</h4>
            <p id="detailStats">-</p>
            <div class="bag-actions" id="detailActions"></div>
          </div>
        </div>
      </div>
    </aside>
    <!-- HUD Overlay -->
    <div id="vj-wrap">
      <div id="vj-left">
        <div class="shared-gauge">
          <div class="fill shared-gauge-fill" id="sharedGaugeFill"></div>
        </div>
        <div class="utility-stack">
          <div class="utility-row top">
            <button class="utility-btn" id="btnPet" data-btn="pet">Pet</button>
            <button class="utility-btn" id="btnVeh" data-btn="veh">Veh</button>
            <button class="utility-btn" id="btnActionNew" data-btn="act">Act</button>
            <button class="utility-btn" id="btnAct2" data-btn="act2">Act2</button>
          </div>
          <div class="utility-row bot">
            <button class="utility-btn" id="btnBagQuick" data-btn="bag">Bag</button>
            <button class="utility-btn" id="btnAISummon" data-btn="ai">AI</button>
            <button class="utility-btn" id="btnSwitchAlt" data-btn="switch">Switch</button>
          </div>
        </div>
        <div id="vj-root">
          <div id="vj-base"></div>
          <div id="vj-knob"></div>
        </div>
      </div>

      <div id="vj-right">
        <div class="skill-row">
          <button class="skill-pill s1" id="hudBtnS1" data-skill="S1" data-btn="s1" aria-label="Skill 1"></button>
          <button class="skill-pill s2" id="hudBtnS2" data-skill="S2" data-btn="s2" aria-label="Skill 2"></button>
          <button class="skill-pill s3" id="hudBtnS3" data-skill="S3" data-btn="s3" aria-label="Skill 3"></button>
        </div>
        <div class="btn-container">
          <button class="big-btn attack" id="hudBtnAttack" data-btn="attack">ATTACK</button>
          <button class="big-btn jump" id="hudBtnJump" data-btn="jump">JUMP</button>
          <div class="rage-shield-container">
            <button class="rage-shield-btn ai" id="hudBtnAI" data-btn="ai">AI</button>
            <button class="rage-shield-btn rage" id="hudBtnRage" data-btn="rage">RAGE</button>
            <button class="rage-shield-btn shield" id="hudBtnShield" data-btn="shield">SHIELD</button>
          </div>
        </div>
      </div>
    </div>

    <script>
      (function () {
        const HUD = window.HUD = window.HUD || {};
        const skillEl = (id) => document.querySelector('.skill-row [data-skill="' + id + '"]');
        HUD.setSkillReady = function (id, ready = true) {
          const el = skillEl(id);
          if (el) el.classList.toggle('ready', !!ready);
        };
        HUD.setJoystickReady = function (ready = true) {
          const root = document.getElementById('vj-root');
          if (root) root.classList.toggle('ready', !!ready);
        };
      })();
    </script>
    <!-- Alchemy Panel -->
    <aside class="bag-overlay" id="alchemy-panel">
      <div class="bag-header">
        <h3>Alchemy</h3>
        <button aria-label="Close" class="drawer-close" id="btnCloseAlchemy">×</button>
      </div>
      <div class="alchemy-body">
        <div class="alchemy-bag-strip">
          <!-- Double row of bag items will be populated by JS -->
        </div>
        <div class="alchemy-info-boxes">
          <div class="info-box">Fusion: same-type 3→1 tier up</div>
          <div class="info-box">Alchemy: any 3→loot (uses highest grade)</div>
        </div>
        <div class="alchemy-crafting-area">
          <div class="alchemy-slots">
            <div class="slot-box" data-slot="1">?</div>
            <div class="slot-box" data-slot="2">?</div>
            <div class="slot-box" data-slot="3">?</div>
          </div>
          <div class="alchemy-arrow">→</div>
          <div class="alchemy-result">
            <div class="slot-box">RESULT</div>
          </div>
        </div>
        <div class="bag-auto-actions">
          <button class="btn-auto" id="btnCombineOverlay">Combine</button>
        </div>
        <div class="alchemy-rules-boxes">
          <div class="info-box">Rules: • Grades: C,B • Exclude equipped • Keep A/S safe</div>
          <div class="info-box">Types: [✓] Gear [✓] Pet [ ] Vehicle [ ] Boxes</div>
          <div class="info-box">Special Recipe: C gear + B gear + C pet → Random (gear/pet/gift/box)</div>
        </div>
      </div>
    </aside>
    <div class="compact-stats" id="compactStats">
      <div class="compact-stats-row">
        <span>HP:</span><span>200/200</span>
      </div>
      <div class="compact-stats-row">
        <span>ATK:</span><span>20</span>
      </div>
      <div class="compact-stats-row">
        <span>DEF:</span><span>0</span>
      </div>
    </div>
  </div>
  <!-- ================= CORE SCRIPT ================= -->
  <!-- ===== NEW: Pet/Vehicle DOM sprites (positioned over canvas) ===== -->
  <div class="dom-sprites" id="domSprites"></div>
  <script>
    /* ================================================================
       HIGH-LEVEL ROADMAP / WHAT IS IMPLEMENTED HERE
       ----------------------------------------------------------------
       1. Team HP & Revival System
          - Per player: hp, hpMax, isDefeated, reviveT.
          - defeatPlayer / revivePlayer / checkGameOver.
          - HUD uses current leader's HP (legacy st.hp mirrors leader).
          - Revive Token instantly revives one defeated hero.
    
       2. Enemy AI & Formations
          - spawnWave assigns role (shooter/melee) & behavior (hitAndRun/relentless).
          - updateEnemyFormations() resolves horizontal overlap.
          - Shooter keeps distance; hitAndRun retreats briefly after first shot.
    
       3. Gear & Loot Rules
          - LOOT_TABLES with proper rank distributions.
          - Gold Bag item: open for 500–5000 gold.
          - Item upgrade system with +10 cap (Upgrade button disabled at +10).
          - Luck stat affects drop rolls.
    
       4. A1 Combat Kit v5
          - a1_basicAttack() 5‑hit combo with per-hit damage & parry windows.
          - a1_useSkill(): S1 multi-waves; S2 Fuse Bomb (armor shred + hitstop); S3 Combo Burst (echo tick + reset S2); S5 Finisher (multi-lane waves + Crescendo).
          - updateA1RageMode() drains rage, applies global 0.2s skill lock while active.
          - Aura trails during & shortly after Rage.
    
       5. Talent Lanes
          - Five lanes: ATK / DEF / Recovery / Cooldown / Luck.
          - lane-based purchase UI replaces old canvas.
          - tallyTalentStats integrates lane effects & recalculates hero stats.
    
       6. Crescendo Cooldown Reset
          - After any S5 or SECRET: S1 & S2 cooldown reset.
    
       NOTE: Many legacy systems trimmed/simplified to keep this single-file
             version focused on the requested tasks & finishing A1's kit.
    =================================================================== */

    /* =============== Constants / Canvas Setup ====================== */
    const DESIGN_W = 1280, DESIGN_H = 720;

    window.A1KShared = window.A1KShared || {
      key: 'A1K_SHARED_STATE_V1',
      pull() {
        try { return JSON.parse(localStorage.getItem(this.key) || '{}') || {}; }
        catch (_) { return {}; }
      },
      push(data) {
        if (!data) return;
        try { localStorage.setItem(this.key, JSON.stringify(data)); }
        catch (_) { /* no-op */ }
      },
      fromRunner() {
        const st = window.st || {};
        const players = Array.isArray(st.players) ? st.players : [];
        return {
          where: 'runner',
          timestamp: Date.now(),
          gold: st.gold || 0,
          leader: st.leader || 0,
          stage: st.stage || 1,
          wave: st.wave || 0,
          xp: st.xp || 0,
          lvl: st.lvl || 1,
          pets: st.pets || [],
          vehicles: st.vehicles || [],
          sharedEnergy: st.sharedEnergy || null,
          players: players.map((p) => ({
            id: p?.id,
            name: p?.name,
            hp: p?.hp,
            hpMax: p?.hpMax,
            mp: p?.mp,
            mpMax: p?.mpMax,
            dmg: p?.dmg,
            skills: p?.skills || null,
            buffs: p?.buffs || null
          }))
        };
      }
    };

    // World and Camera System
    const WORLD_WIDTH = (window.WORLD_WIDTH || 15000); // Walkable world width
    const SCENE_COUNT = 10;    // 10 scenes per stage
    let camera = { x: 0, y: 0, targetX: 0, smooth: 0.1 };
    let currentScene = 0;

    // Scene transition zones
    const SCENE_TRANSITION_ZONE = 200; // Pixels from edge to trigger transition

    // Enhanced boss and speed constants
    const BOSS_COUNT = 20;
    const SPEEDS = [1, 2, 3, 4, 6];
    function rng() { return Math.random(); }
    const $ = q => document.querySelector(q);

    const cv = document.getElementById('cv'); let ctx = cv.getContext('2d');

    // Expose canvas globally for rendering systems
    window.g = window.g || {};
    window.g.cv = cv;
    window.g.ctx = ctx;

    function resize() {
      const scale = Math.min(innerWidth / DESIGN_W, innerHeight / DESIGN_H);
      const cssW = DESIGN_W * scale, cssH = DESIGN_H * scale;
      Object.assign(cv.style, { width: cssW + 'px', height: cssH + 'px', position: 'absolute', left: ((innerWidth - cssW) / 2) + 'px', top: ((innerHeight - cssH) / 2) + 'px' });
      const dpr = Math.min(devicePixelRatio || 1, 2);
      cv.width = Math.round(DESIGN_W * dpr); cv.height = Math.round(DESIGN_H * dpr);
      ctx = cv.getContext('2d'); ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      // Update global canvas context reference
      window.g = window.g || {};
      window.g.cv = cv;
      window.g.ctx = ctx;
    }
    addEventListener('resize', resize); resize();

    /* =============== Camera System =============== */
    function updateCamera() {
      const leader = st.players[st.leader];
      if (!leader) return;

      // Calculate target camera position (follow player)
      camera.targetX = leader.x - DESIGN_W / 2;

      // Smooth camera movement
      camera.x += (camera.targetX - camera.x) * camera.smooth;

      // Keep camera within scene bounds
      const sceneStart = currentScene * WORLD_WIDTH;
      const sceneEnd = sceneStart + WORLD_WIDTH;
      camera.x = Math.max(sceneStart, Math.min(camera.x, sceneEnd - DESIGN_W));

      // Check for scene transitions
      checkSceneTransition(leader);
    }

    function checkSceneTransition(player) {
      const sceneStart = currentScene * WORLD_WIDTH;
      const sceneEnd = sceneStart + WORLD_WIDTH;

      // Moving right to next scene
      if (player.x > sceneEnd - SCENE_TRANSITION_ZONE && currentScene < SCENE_COUNT - 1) {
        if (!window.REQUIRE_CLEAR_FOR_TRANSITION || st.enemies.length === 0) {
          transitionToScene(currentScene + 1);
        } else {
          // Soft hint only — no push-back
          if (!st._transitionWarning) {
            notify('Defeat enemies to proceed', '#FF9800');
            st._transitionWarning = true;
          }
        }
      }

      // Moving left to previous scene
      if (player.x < sceneStart + SCENE_TRANSITION_ZONE && currentScene > 0) {
        transitionToScene(currentScene - 1);
      }
    }

    function transitionToScene(newScene) {
      if (newScene === currentScene) return;

      const oldScene = currentScene;
      currentScene = Math.max(0, Math.min(newScene, SCENE_COUNT - 1));

      // Clear transition warning
      st._transitionWarning = false;

      // Scene transition effects
      st.effects.push({
        kind: 'scene_transition',
        x: DESIGN_W / 2,
        y: DESIGN_H / 2,
        life: 1000,
        max: 1000,
        color: '#00ff88'
      });

      // Update camera immediately
      const leader = st.players[st.leader];
      if (newScene > oldScene) {
        // Moving right
        leader.x = currentScene * WORLD_WIDTH + 100;
        notify(`Entering Scene ${currentScene + 1}`, '#00ff88');
      } else {
        // Moving left
        leader.x = currentScene * WORLD_WIDTH + WORLD_WIDTH - 200;
        notify(`Returning to Scene ${currentScene + 1}`, '#00ff88');
      }

      camera.x = leader.x - DESIGN_W / 2;
      camera.targetX = camera.x;

      // Ensure houses exist in this scene (aligned to strips)
      try { if (window.Platform && Platform.layers) { spawnHousesForScene(currentScene); } } catch (_e) { }

      // Spawn new enemies for the scene
      spawnSceneEnemies();

      // Check if this completes the stage
      if (currentScene >= SCENE_COUNT - 1 && st.enemies.length === 0) {
        completeStage();
      }
    }

    function spawnSceneEnemies() {
      // Only bosses. Random 3–4 per scene spawn.
      st.enemies = [];
      const baseX = (currentScene * WORLD_WIDTH) + Math.max(200, Math.min(WORLD_WIDTH - 400, leader().x));
      const count = 3 + Math.floor(Math.random() * 2); // 3–4
      if (window.StageMgr) {
        for (let i = 0; i < count; i++) StageMgr.forceMiniboss();
        return;
      }
      if (window.BossPoolSystem) {
        for (let i = 0; i < count; i++) {
          const bosses = window.BossPoolSystem.getWaveBosses(st.wave || 1, { stage: st.stageInArea || 1 });
          const pick = bosses[Math.floor(Math.random() * bosses.length)];
          const boss = {
            id: Math.random(), kind: 'boss', isBoss: true,
            name: pick?.name || 'Boss',
            x: baseX + i * 120,
            y: (DESIGN_H - 300) - 40,
            hp: pick?.stats?.hpMax || (600 + st.stage * 120),
            max: pick?.stats?.hpMax || (600 + st.stage * 120),
            dmg: pick?.stats?.atk || (35 + st.stage * 6),
            vx: -(0.08 + Math.random() * 0.06),
            pool: pick?.pool || 'mix'
          };
          st.enemies.push(boss);
        }
        return;
      }
    }

    function completeStage() {
      st.stage++;
      currentScene = 0;

      // Move player to start of new stage
      const leader = st.players[st.leader];
      leader.x = 200;
      camera.x = 0;
      camera.targetX = 0;

      // Stage completion rewards
      const goldReward = st.stage * 100;
      const gemReward = Math.floor(st.stage / 3);

      st.gold += goldReward;
      if (gemReward > 0) st.gems += gemReward;

      notify(`🎉 Stage ${st.stage - 1} Complete! +${goldReward}g ${gemReward > 0 ? `+${gemReward} gems` : ''}`, '#FFD700');
      updateCurrencies();

      // Spawn first scene enemies
      spawnSceneEnemies();
    }

    function getWorldPosition(screenX, screenY) {
      return {
        x: screenX + camera.x,
        y: screenY + camera.y
      };
    }

    function getScreenPosition(worldX, worldY) {
      return {
        x: worldX - camera.x,
        y: worldY - camera.y
      };
    }

    // Combo timing window (ms)
    const COMBO_WINDOW = 3000;



    /* ================== Pet Skill System ================== */
    function handlePetSkillButtonClick(clickX, clickY) {
      if (!st.activePets) return false;

      for (const pet of st.activePets) {
        if (pet.hp <= 0 || !pet._skillButtons) continue;

        for (const btn of pet._skillButtons) {
          const dist = Math.hypot(clickX - btn.x, clickY - btn.y);
          if (dist < btn.size && btn.active) {
            usePetSkill(pet, btn.skill);
            return true;
          }
        }
      }
      return false;
    }

    function usePetSkill(pet, skillKey) {
      const nearestEnemy = findNearestEnemyToPet(pet);
      if (!nearestEnemy) return;
      pet._skillCDs = pet._skillCDs || {};
      const now = performance.now?.() || Date.now();
      const onCD = key => (pet._skillCDs[key] || 0) > now;
      const setCD = (key, ms) => pet._skillCDs[key] = now + ms;

      if (skillKey === 'P1' || skillKey === 'HUNT') { // Hunt: single-target lunge
        if (onCD('HUNT')) return;
        const damage = 40 + Math.floor(Math.random() * 20);
        // Lunge a bit towards target
        const ang = Math.atan2(nearestEnemy.y - pet.y, nearestEnemy.x - pet.x);
        pet.x += Math.cos(ang) * 30; pet.y += Math.sin(ang) * 18;
        nearestEnemy.hp -= damage;
        addFloater(nearestEnemy.x, nearestEnemy.y - 20, '-' + damage, '#ff6aa8');
        // VFX
        st.effects.push({ kind: 'impact', x: nearestEnemy.x, y: nearestEnemy.y, color: '#ff6aa8', life: 300, max: 300 });
        if (nearestEnemy.hp <= 0) onEnemyKilled(nearestEnemy);
        setCD('HUNT', 2500);
        notify('Pet Hunt!', '#ff6aa8');

      } else if (skillKey === 'P2' || skillKey === 'BERSERK') { // Berserk: buff window
        if (onCD('BERSERK')) return;
        pet._berserkT = 4000; // 4s buff
        pet._berserkMul = 1.5;
        st.effects.push({ kind: 'cast', x: pet.x, y: pet.y, color: '#00ff88', life: 500, max: 500 });
        setCD('BERSERK', 8000);
        notify('Pet Berserk!', '#00ff88');
      } else if (skillKey === 'RANGED' || skillKey === 'P3') { // Shot volley
        if (onCD('RANGED')) return;
        const n = 3 + Math.floor(Math.random() * 2); // 3–4 shots
        for (let i = 0; i < n; i++) {
          const spread = (i - (n - 1) / 2) * 0.10;
          const sp = 560;
          st.shots.push({
            x: pet.x + 10, y: pet.y - 12, vx: Math.cos(spread) * sp, vy: Math.sin(spread) * sp,
            speed: sp, dmg: Math.round(18 * (pet._berserkMul || 1)), life: 900, ownerId: pet.id, color: '#c1ffc1'
          });
        }
        st.effects.push({ kind: 'impact', x: pet.x + 10, y: pet.y - 12, color: '#c1ffc1', life: 300, max: 300 });
        setCD('RANGED', 5000);
        notify('Pet Volley!', '#c1ffc1');
      }
    }

    /* ================== Interior Mouse Controls ================== */
    (function () {
      const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
      const controls = window.MouseControls = window.MouseControls || {};
      if (!controls._interiorSetup) {
        controls._interiorSetup = true;
        controls.interiorTarget = null;
        controls.interiorAction = null;
        controls.interiorMarker = null;

        controls.clearInteriorTarget = function () {
          this.interiorTarget = null;
          this.interiorAction = null;
          this.interiorMarker = null;
        };

        controls.setInteriorTarget = function (x, y, action) {
          const HI = window.HouseInterior;
          if (!HI) return;
          const W = typeof DESIGN_W !== 'undefined' ? DESIGN_W : 1280;
          const H = typeof DESIGN_H !== 'undefined' ? DESIGN_H : 720;
          const minX = 60;
          const maxX = W - 60;
          const minY = 120;
          const maxY = H - 180;
          const targetX = clamp(x, minX, maxX);
          const targetY = clamp(y, minY, maxY);
          this.interiorTarget = { x: targetX, y: targetY };
          this.interiorAction = action || null;
          const now = performance.now?.() || Date.now();
          this.interiorMarker = { x: targetX, y: targetY, time: now };
        };

        controls.handleInteriorClick = function (screenX, screenY) {
          const HI = window.HouseInterior;
          if (!HI?.active) return false;
          const hero = HI.hero;
          const objs = HI.objs || {};
          const interactions = [];
          if (objs.door) {
            const door = objs.door;
            interactions.push({ kind: 'door', x: door.x + (door.w || 0) / 2, y: door.y + (door.h || 0) / 2, r: Math.max(door.w || 48, door.h || 48) * 0.6 });
          }
          (objs.chests || []).forEach((c) => interactions.push({ kind: 'chest', x: c.x, y: c.y, r: 40 }));
          (objs.counters || []).forEach((c) => interactions.push({ kind: 'counter', x: c.x, y: c.y, r: Math.max((c.w || 120) / 2 + 20, 50) }));
          (objs.npcs || []).forEach((n) => interactions.push({ kind: 'npc', x: n.x, y: n.y, r: 36 }));

          let chosen = null;
          let best = Infinity;
          for (const item of interactions) {
            const dist = Math.hypot(screenX - item.x, screenY - item.y);
            if (dist <= (item.r || 40) && dist < best) {
              best = dist;
              chosen = item;
            }
          }

          if (chosen) {
            const nearHero = hero ? Math.hypot((hero.x || 0) - chosen.x, (hero.y || 0) - chosen.y) : Infinity;
            if (nearHero < 22) {
              this.clearInteriorTarget();
              try { HI.interact(); } catch (_) { }
            } else {
              this.setInteriorTarget(chosen.x, chosen.y, 'interact');
            }
            return true;
          }

          this.setInteriorTarget(screenX, screenY, 'move');
          return true;
        };

        controls.updateInteriorMovement = function (interior, dt) {
          if (!interior?.active) {
            return false;
          }
          const hero = interior.hero;
          if (!hero || !this.interiorTarget) {
            return false;
          }
          const dtSec = typeof dt === 'number' ? dt : 0.016;
          const dx = this.interiorTarget.x - hero.x;
          const dy = this.interiorTarget.y - hero.y;
          const dist = Math.hypot(dx, dy);
          const speed = hero.speed || 180;
          if (dist < 8) {
            hero.x = this.interiorTarget.x;
            hero.y = this.interiorTarget.y;
            hero.vx = 0;
            hero.vy = 0;
            const action = this.interiorAction;
            this.clearInteriorTarget();
            if (action === 'interact') {
              try { interior.interact(); } catch (_) { }
            }
            return true;
          }
          const nx = dx / dist;
          const ny = dy / dist;
          hero.vx = nx;
          hero.vy = ny;
          hero.x += nx * speed * dtSec;
          hero.y += ny * speed * dtSec;
          return true;
        };

        controls.drawInteriorTarget = function (ctx) {
          const HI = window.HouseInterior;
          if (!HI?.active || !ctx || !this.interiorMarker) return;
          ctx.save();
          ctx.strokeStyle = 'rgba(159,215,255,0.8)';
          ctx.lineWidth = 2;
          ctx.setLineDash([6, 6]);
          const marker = this.interiorMarker;
          ctx.beginPath();
          ctx.arc(marker.x, marker.y, 18, 0, Math.PI * 2);
          ctx.stroke();
          ctx.setLineDash([]);
          ctx.restore();
        };
      }
    })();
    /* ================== Enhanced Canvas Click Handler ================== */
    cv.addEventListener('click', function (e) {
      const rect = cv.getBoundingClientRect();
      const scaleX = DESIGN_W / rect.width;
      const scaleY = DESIGN_H / rect.height;
      const screenX = (e.clientX - rect.left) * scaleX;
      const screenY = (e.clientY - rect.top) * scaleY;

      if (window.HouseInterior?.active) {
        if (window.MouseControls?.handleInteriorClick?.(screenX, screenY)) {
          return;
        }
      }

      // Convert to world coordinates
      const worldPos = getWorldPosition(screenX, screenY);
      const clickX = worldPos.x;
      const clickY = worldPos.y;

      // Check for clone skill button clicks
      if (window.handleCloneSkillButtonClick && window.handleCloneSkillButtonClick(clickX, clickY)) {
        return;
      }

      // Check for mini pet skill button clicks
      if (window.handleMiniPetSkillButtonClick && window.handleMiniPetSkillButtonClick(clickX, clickY)) {
        return;
      }

      // Check for skill button clicks on non-leader players
      for (let i = 0; i < st.players.length; i++) {
        const p = st.players[i];
        if (i === st.leader || p.isDefeated || !p._skillButtons) continue;

        for (const btn of p._skillButtons) {
          const dist = Math.hypot(clickX - btn.x, clickY - btn.y);
          if (dist < btn.size && btn.active) {
            // Use skill on this player
            useSkillWrapper(p, btn.skill);
            return;
          }
        }
      }

      // Check for vehicle boarding button clicks
      if (handleVehicleButtonClick(clickX, clickY)) {
        return;
      }

      // Check for pet skill button clicks
      if (handlePetSkillButtonClick(clickX, clickY)) {
        return;
      }
    });

    /* ================== Game State ================== */
    const st = {
      running: true, speed: 1, time: 0, dt: 0, started: false,
      stage: 1, wave: 1, wavesPerStage: 10, kills: 0,
      // Progression v9.5 fields
      area: 1, areaHalf: false,
      stageInArea: 1, stageHalf: false,
      waveStep: 1, loop: 0,
      _difficultyMul: 1,
      gold: 0, silver: 0, tickets: 0, gems: 0, bossKills: 0,
      giftKeys: 0, bossKeys: 0,
      waveLeaderWave: 2 + Math.floor(Math.random() * 8), // Random wave for leader spawn
      treasureWave: 3 + Math.floor(Math.random() * 7), // Random wave for treasure boss
      supplyPlaneWave: 2 + Math.floor(Math.random() * 8), // Random wave for supply plane
      revivalBossWave: 2 + Math.floor(Math.random() * 8), // Random wave for revival boss
      // Flag to track if the current wave contained special encounters (bosses, wave leaders, treasure bosses, mini-boss events)
      specialWave: false,
      xp: 0, level: 1, apTotal: 0, apSpent: 0,
      lootLuckBase: 0,
      players: [
        {
          id: 'A1', x: 200, y: DESIGN_H - 160, lane: 0, vx: 0, vy: 0,
          // Increase health pool and damage for easier early-game testing
          hpMax: 350, hp: 350, isDefeated: false, reviveT: 0,
          dmgBase: 60, rage: 0, rageMax: 100, rageOn: false, rageDur: 0, rageICD: 0,
          secretGauge: 0, secretMax: 100, secretActive: false, secretTimer: 0,
          exhaustionT: 0, _gcdT: 0, _atkMul: 1, _speedMul: 1,
          twinEclipseSustain: 0, atkBuffT: 0, speedBase: 0.5, defBase: 50, facingLeft: false,
          // New stats for future systems
          def: 50, aura: 0, luck: 0
        },
        {
          id: 'Unique', x: 240, y: DESIGN_H - 130, lane: 1, vx: 0, vy: 0,
          hpMax: 320, hp: 320, isDefeated: false, reviveT: 0,
          dmgBase: 55, rage: 0, rageMax: 100, rageOn: false, rageDur: 0, rageICD: 0,
          secretGauge: 0, secretMax: 100, secretActive: false, secretTimer: 0,
          exhaustionT: 0, _gcdT: 0, _atkMul: 1, _speedMul: 1,
          facingLeft: false,
          def: 50, aura: 0, luck: 0
        },
        {
          id: 'Missy', x: 220, y: DESIGN_H - 100, lane: 2, vx: 0, vy: 0,
          hpMax: 320, hp: 320, isDefeated: false, reviveT: 0,
          dmgBase: 50, rage: 0, rageMax: 100, rageOn: false, rageDur: 0, rageICD: 0,
          secretGauge: 0, secretMax: 100, secretActive: false, secretTimer: 0,
          exhaustionT: 0, _gcdT: 0, _atkMul: 1, _speedMul: 1,
          facingLeft: false,
          def: 50, aura: 0, luck: 0
        },
      ],
      aiCompanions: [],
      leader: 0,
      enemies: [], shots: [], eShots: [], pickups: [], effects: [],
      bossAlive: false, bossHP: 0, bossMax: 1,
      postBossCalmWaves: 0,
      tamedBosses: [],          // Array of tamed boss companions
      maxTamedBosses: 3,        // Maximum companions allowed
      tameChanceBase: 0.15,     // 15% base chance to trigger taming
      cds: { 'A1': { S1: 0, S2: 0, S3: 0, S4: 0, S5: 0, X1: 0 }, 'Unique': { S1: 0, S2: 0, S3: 0, S4: 0, S5: 0, X1: 0 }, 'Missy': { S1: 0, S2: 0, S3: 0, S4: 0, S5: 0, X1: 0 } },
      // Inventory / Gear
      inv: [], invRows: 4,
      equippedGear: { weapon: null, weapon2: null, armor: null, acc1: null, acc2: null },
      equippedPets: [null, null], petSlots: 2,
      equippedVehicle: null,
      // Active instances on battlefield
      activePets: [],
      vehicles: [],
      bagOpen: false, bagTab: 'items',
      // Talent Lanes
      talentLanes: {}, talentPicks: new Set(), _talentStats: {},
      luck: 0,
      sharedEnergy: { current: 0, max: 100 },
      barrier: 0,
      barrierMax: 0,
      _cloneStance: 'assault',
      // Game state flags
      isGameOver: false,
      // Misc
      _globalSkillLock: 0,
      reviveTokens: 0,
      // Track which spells the player has learned from scrolls. Keys map to true when learned.
      learnedSpells: {},
      // Stage start timestamp for time‑trial quests. Updated when a new stage begins.
      stageStartTime: null,
      // Flag to indicate when enemies can start moving and shooting. When a wave spawns we set this to false and re‑enable it after a short delay. This prevents mobs from attacking before the match actually starts.
      matchStarted: true,
      // Enable auto‑play by default so characters automatically attack.  The UI button toggles this.
      auto: true,
      // Currently selected shop category for the shop UI (all, consumable, gear, armor, etc.)
      shopCategory: 'all',
      parryT: 0,
      // Lightweight combo system (resets on timeout)
      comboSystem: { currentCombo: 0, maxCombo: 0, comboTimer: 0, comboMultiplier: 1.0 },
      // World NPCs + purchases
      npcs: [],
      npcSkills: {},
      npcSkillEffects: {
        atkMul: 1,
        gearMul: 1,
        combatAtkMul: 1,
        xpBonus: 0,
        dropBonus: 0,
        permanentDefBonus: 0,
        tempDefBuff: null,
        shopDiscount: 0,
        sellBonus: 0,
        autoReviveCharges: 0
      },
      npcPassiveTimers: {},
      npcBuffs: [],
      _npcNear: null,
      _npcMenuOpen: false
    };

    function hydrateRunnerFromShare() {
      if (!window.A1KShared) return;
      const share = A1KShared.pull() || {};
      if (!share || !share.players || share.where !== 'dungeon') return;
      if (Number.isFinite(share.gold)) st.gold = share.gold;
      if (Number.isFinite(share.xp)) st.xp = share.xp;
      if (Number.isFinite(share.lvl)) st.level = st.lvl = share.lvl;
      if (Array.isArray(share.pets)) st.pets = share.pets.slice();
      if (Array.isArray(share.vehicles)) st.vehicles = share.vehicles.slice();
      if (Array.isArray(share.players)) {
        share.players.forEach((src, idx) => {
          const dst = st.players[idx];
          if (!dst || !src) return;
          if (Number.isFinite(src.hpMax)) dst.hpMax = src.hpMax;
          if (Number.isFinite(src.hp)) dst.hp = Math.max(0, Math.min(dst.hpMax || src.hp, src.hp));
          if (Number.isFinite(src.mpMax)) dst.mpMax = src.mpMax;
          if (Number.isFinite(src.mp)) dst.mp = Math.max(0, Math.min(dst.mpMax || src.mp, src.mp));
          if (src.skills) dst.skills = Object.assign({}, dst.skills || {}, src.skills);
        });
      }
      if (typeof share.leader === 'number' && share.leader >= 0 && share.leader < st.players.length) {
        st.leader = share.leader;
      }
      try { notify && notify('Party returned from Candy Dungeon', '#ff93d3'); } catch (_) { }
      try { history.replaceState(null, '', location.pathname + location.search); } catch (_) { }
      A1KShared.push(Object.assign({}, share, { where: 'runner', timestamp: Date.now() }));
    }

    hydrateRunnerFromShare();
    setInterval(() => {
      if (!window.A1KShared) return;
      A1KShared.push(A1KShared.fromRunner());
    }, 10000);

    /* ================== Utility UI ================== */
    function notify(msg, color) {
      const wrap = notifWrap();
      const d = document.createElement('div');
      d.className = 'toast';
      if (color) d.style.color = color;
      d.textContent = msg;
      wrap.appendChild(d);
      // prune to last 6 toasts
      while (wrap.children.length > 6) wrap.firstChild.remove();
      setTimeout(() => {
        d.style.transition = 'opacity .35s';
        d.style.opacity = 0;
        setTimeout(() => d.remove(), 400);
      }, 1400);
    }
    let _notifEl = null; function notifWrap() { if (!_notifEl) { _notifEl = document.createElement('div'); _notifEl.id = 'notificationWrap'; document.body.appendChild(_notifEl); } return _notifEl; }
    function addFloater(x, y, txt, color) {
      st.effects.push({
        x, y, txt, color,
        vy: -0.25,
        life: 800,
        kind: 'floater',
        fontSize: 14,
        outline: true
      });
    }

    // Enhanced enemy kill tracking moved to unified handler below (onEnemyKilled)

    /* ================= Team Status UI ================= */
    function updateSharedGauge(dt) {
      // Regenerate energy over time
      st.sharedEnergy.current = Math.min(st.sharedEnergy.max, st.sharedEnergy.current + 10 * dt); // 10 energy per second

      // Update UI
      const fill = $('#sharedGaugeFill');
      if (fill) {
        const ratio = st.sharedEnergy.current / st.sharedEnergy.max;
        fill.style.transform = `scaleX(${ratio})`;
      }
    }

    function updateTeamStatusUI() {
      const teamStatus = document.getElementById('teamStatus');
      if (!teamStatus) return;

      st.players.forEach((p, i) => {
        const heroId = p.id.toLowerCase();
        const portrait = document.getElementById('hero' + p.id);
        if (!portrait) return;

        // Update leader indicator
        portrait.classList.toggle('leader', i === st.leader);

        // Update defeated state
        portrait.classList.toggle('defeated', p.isDefeated);

        // Update secret ready state
        portrait.classList.toggle('secret-ready', p.secretGauge >= p.secretMax);
        // Update rage ready state
        portrait.classList.toggle('rage-ready', p.rage >= p.rageMax && !p.rageOn && (p.exhaustionT || 0) <= 0);

        // Update HP bar
        const hpFill = portrait.querySelector('.hero-hp-fill');
        if (hpFill) {
          const ratio = p.hp / p.hpMax;
          hpFill.style.transform = `scaleX(${ratio})`;
        }
        const hpBar = portrait.querySelector('.hero-hp-bar');
        if (hpBar) {
          let barrierFill = hpBar.querySelector('.hero-barrier-fill');
          if (!barrierFill) {
            barrierFill = document.createElement('div');
            barrierFill.className = 'hero-barrier-fill';
            hpBar.insertBefore(barrierFill, hpBar.firstChild);
          }
          const barrierState = p._coreBarrier || { current: 0, max: 0 };
          const barrierRatio = barrierState.max > 0 ? Math.max(0, Math.min(1, barrierState.current / barrierState.max)) : 0;
          barrierFill.style.transform = `scaleX(${barrierRatio})`;
          barrierFill.style.opacity = barrierRatio > 0 ? 1 : 0;
        }
        // Update Secret bar
        const secFill = portrait.querySelector('.secret-fill');
        if (secFill) { const r = (p.secretMax > 0) ? (p.secretGauge / p.secretMax) : 0; secFill.style.transform = `scaleX(${Math.max(0, Math.min(1, r))})`; }
        // Update Rage bar
        const rgFill = portrait.querySelector('.rage-fill');
        if (rgFill) { const r = (p.rageMax > 0) ? (p.rage / p.rageMax) : 0; rgFill.style.transform = `scaleX(${Math.max(0, Math.min(1, r))})`; }

        // Update status text
        const statusEl = portrait.querySelector('.hero-status');
        if (statusEl) {
          if (p.isDefeated) {
            const reviveTime = Math.ceil(p.reviveT / 1000);
            statusEl.textContent = reviveTime > 0 ? `${reviveTime}s` : 'DOWN';
          } else if (p.rageOn) {
            statusEl.textContent = 'RAGE';
          } else {
            statusEl.textContent = 'OK';
          }
        }

        // Update skill icons for non-leaders
        const skillIconsContainer = portrait.querySelector('.hero-skill-icons');
        if (skillIconsContainer) {
          if (i === st.leader || p.isDefeated) {
            skillIconsContainer.style.display = 'none';
          } else {
            skillIconsContainer.style.display = 'flex';
            const s1_icon = skillIconsContainer.querySelector('.s1');
            const s2_icon = skillIconsContainer.querySelector('.s2');

            if (s1_icon) {
              s1_icon.classList.toggle('ready', cdReady(p.id, 'S1'));
            }
            if (s2_icon) {
              s2_icon.classList.toggle('ready', cdReady(p.id, 'S2'));
            }
          }
        }
      });
    }

    function updateSecretGaugeUI() {
      const L = leader();
      if (!L) return;
      const btnSecret = document.getElementById('btnSecret');
      const btnRage = document.getElementById('hudBtnRage') || document.getElementById('btnRage');
      if (btnSecret) {
        const ready = canUseSecret(L);
        btnSecret.style.opacity = ready ? '1' : '0.4';
        btnSecret.style.pointerEvents = ready ? 'auto' : 'none';
        btnSecret.classList.toggle('ready', ready);
      }
      if (btnRage) {
        const rdy = (L.rage >= L.rageMax) && !L.rageOn && (L.exhaustionT || 0) <= 0;
        btnRage.classList.toggle('ready', rdy);
      }
      // Portrait gauges + glows for all heroes
      try {
        (st.players || []).forEach(p => {
          const nid = 'hero' + p.id; const node = document.getElementById(nid); if (!node) return;
          const secReady = canUseSecret(p); const rageReady = (p.rage >= p.rageMax) && !p.rageOn && ((p.exhaustionT || 0) <= 0);
          node.classList.toggle('secret-ready', secReady);
          node.classList.toggle('rage-ready', rageReady);
          const sf = node.querySelector('.secret-fill'); if (sf) { const r = (p.secretGauge || 0) / (p.secretMax || 1); sf.style.transform = 'scaleX(' + Math.max(0, Math.min(1, r)) + ')'; }
          const rf = node.querySelector('.rage-fill'); if (rf) { const r = (p.rage || 0) / (p.rageMax || 1); rf.style.transform = 'scaleX(' + Math.max(0, Math.min(1, r)) + ')'; }
        });
      } catch (_e) { }
    }

    function updateCompactHUD() {
      const hud = document.getElementById('compact-hud');
      if (!hud) return;

      const p = leader();
      if (!p) return;

      const hp = p.hp;
      const hpMax = p.hpMax;
      const atk = p.dmg;
      const def = p.defBase || 0;

      hud.innerHTML = `
    <div>HP: ${hp}/${hpMax}</div>
    <div>ATK: ${atk}</div>
    <div>DEF: ${def}</div>
  `;
    }

    function fillSecretGauge(player, amount) {
      if (!player || player.isDefeated) return;
      player.secretGauge = Math.min(player.secretMax, player.secretGauge + amount);

      // Visual feedback when gauge fills
      if (player.secretGauge >= player.secretMax) {
        addFloater(player.x, player.y - 60, 'SECRET READY!', '#ffaa00');
      }
    }

    /* ================= Team HP Helpers ================= */
    function leader() { return st.players[st.leader]; }
    function mirrorLeaderHP() {
      const L = leader();
      st.hp = L.hp; st.hpMax = L.hpMax; // mirror for legacy HUD code
      st.barrier = L._coreBarrier?.current || 0;
      st.barrierMax = L._coreBarrier?.max || 0;
    }
    function defeatPlayer(p) {
      if (p.isDefeated) return;
      p.isDefeated = true; p.reviveT = (40 + Math.floor(Math.random() * 21)) * 1000;
      addFloater(p.x, p.y - 50, p.id + ' Down!', '#ff4d4f');
      // Reset gauges/flags on death
      p.rage = 0; p.rageOn = false; p.rageDur = 0; p.rageICD = 0; p.exhaustionT = 0; p._gcdT = 0; p._atkMul = 1; p._speedMul = 1; p.secretActive = false; p.secretTimer = 0;
      recalcStats();
      // Auto-switch if leader
      if (st.players[st.leader] === p) {
        const idx = st.players.findIndex(pl => !pl.isDefeated);
        if (idx >= 0) st.leader = idx;
      }
      const eff = st.npcSkillEffects || {};
      if (eff.autoReviveCharges > 0) {
        eff.autoReviveCharges--;
        setTimeout(() => {
          revivePlayer(p, true);
        }, 350);
      }
    }
    function revivePlayer(p, instant = false) {
      p.isDefeated = false; p.reviveT = 0; p.hp = p.hpMax;
      addFloater(p.x, p.y - 50, p.id + ' Revived', '#36c777');
      if (instant) notify(p.id + ' revived!');
    }
    function damagePlayer(p, dmg) {
      if (p.isDefeated) return;
      const eff = st.npcSkillEffects || {};
      const nowMs = performance.now ? performance.now() : Date.now();
      if (eff.invulnUntil && nowMs < eff.invulnUntil) {
        addFloater(p.x, p.y - 30, '0', '#9fd7ff');
        return;
      }
      // Apply shield: drastically reduce damage when active
      if (st._shieldOn) {
        dmg = Math.floor(dmg * 0.1);
      }
      dmg = applyCrystalMitigation(p, dmg);
      let dmgMul = 1;
      if (eff.permanentDefBonus) dmgMul *= (1 - Math.min(0.8, eff.permanentDefBonus));
      if (eff.tempDefBuff && eff.tempDefBuff.expires && nowMs < eff.tempDefBuff.expires) {
        dmgMul *= (1 - Math.min(0.8, eff.tempDefBuff.value || 0));
      }
      dmg = Math.round(dmg * Math.max(0.15, dmgMul));
      p.hp = Math.max(0, p.hp - dmg);
      addFloater(p.x, p.y - 30, '-' + dmg, '#ff7a6a');
      // Build rage on hit
      gainRage(p, Math.floor(dmg * 0.8));

      // A1's On-Hit Buff (FIXED: non-stacking)
      if (p.id === 'A1') {
        if (!p.atkBuffActive) {
          p.atkBuffActive = true;
          // Store original stats
          p._origDmgBase = p.dmgBase;
          p._origSpeedBase = p.speedBase;
          p._origDefBase = p.defBase;
          // Apply buff
          p.dmgBase *= 1.05;
          p.speedBase *= 1.05;
          p.defBase += 5;
          recalcStats();
          addFloater(p.x, p.y - 45, 'BUFF UP!', '#ffdd44');
        }
        p.atkBuffT = 10000; // Refresh timer regardless
      }

      if (p.hp <= 0) defeatPlayer(p);
      mirrorLeaderHP();
    }
    function checkPlayersRevive(dtMs) {
      for (const p of st.players) {
        if (p.isDefeated && p.reviveT > 0) {
          p.reviveT -= dtMs;
          if (p.reviveT <= 0) revivePlayer(p);
        }
      }
    }
    function checkGameOver() {
      if (!st.isGameOver && st.players.every(p => p.isDefeated)) {
        st.isGameOver = true;
        try {
          addFloater(DESIGN_W / 2, DESIGN_H / 2 - 40, 'GAME OVER', '#ff4f4f');
          // Automatically restart the game after a short delay to speed up testing.  Use a timeout so the player
          // has a moment to see the GAME OVER message.
          setTimeout(() => {
            try {
              if (typeof resetGame === 'function') {
                resetGame();
              } else {
                location.reload();
              }
            } catch (_err) {
              location.reload();
            }
          }, 3000);
        } catch (_e) { }
      }
    }

    /* ================ Enemy Formation & AI ================= */
    function updateEnemyFormations() {
      const R = 28;
      for (let i = 0; i < st.enemies.length; i++) {
        const a = st.enemies[i]; if (a.hp <= 0) continue;
        for (let j = i + 1; j < st.enemies.length; j++) {
          const b = st.enemies[j]; if (b.hp <= 0) continue;
          const dx = b.x - a.x;
          if (Math.abs(dx) < R) {
            const push = (R - Math.abs(dx)) * 0.5;
            const dir = dx >= 0 ? 1 : -1;
            a.x -= push * dir; b.x += push * dir;
          }
        }
      }
    }
    function applyEnemyBehavior(e, dt) {
      // Airdrop plane is handled by its own controller
      if (e.kind === 'plane') {
        return;
      }
      if (!e.role) return;
      const L = leader();

      /*
      // Flying enemy behaviors
      if (e.isFlying) {
        // Sine wave movement for flyers
        e.y = e.originalY + Math.sin(performance.now() * 0.003) * 50;

        if (e.behavior === 'aerial') {
          // Maintain distance and occasionally dive bomb
          if (e.diveBombCD) {
            e.diveBombCD -= dt * 1000;
            if (e.diveBombCD <= 0 && Math.abs(L.x - e.x) < 300) {
              // Initiate dive bomb
              e.vy = 300; // Dive down fast
              e.vx *= 2;  // Speed up horizontally
              e.diveBombCD = 5000 + Math.random() * 3000; // Reset CD
              e._diveBombing = true;
              setTimeout(() => {
                e._diveBombing = false;
                e.vy = Math.sin(performance.now() * 0.002) * 0.1; // Return to sine wave
                e.vx /= 2; // Return to normal speed
              }, 1500);
            }
          }
        }
        return; // Skip ground behaviors for flying enemies
      }

      // Ground enemy behaviors
      if (e.role === 'shooter') {
        if (e.fireCD == null) { e.fireCD = 800 + Math.random() * 600; }
        // Maintain distance ~240px
        const dist = L.x - e.x;
        const desired = -240;
        if (dist > desired + 40) e.x += Math.min(120 * dt, (dist - desired) * 0.5 * dt);
        if (dist < desired - 40) e.x -= Math.min(120 * dt, (desired - dist) * 0.5 * dt);
      }

      if (e.behavior === 'hitAndRun') {
        if (e._justFired && !e._retreating) {
          e._retreating = true; e._retreatT = 1200;
        }
        if (e._retreating) {
          e._retreatT -= dt * 1000;
          e.x += 160 * dt; // move right
          if (e._retreatT <= 0) { e._retreating = false; e._justFired = false; }
        }
      }
      */
      if (e.behavior === 'berserker') {
        // New berserker behavior: charge faster when low HP
        const hpRatio = e.hp / e.max;
        if (hpRatio < 0.5) {
          e.vx = Math.min(-0.8, e.vx * 1.5); // Speed up when damaged
        }
      } else if (e.behavior === 'boss_pattern') {
        // Simplified boss behavior (no abilities)
        if ((e.fireCD || 0) <= 0) { enemyShoot(e); e.fireCD = 1600; }
      } else if (e.behavior === 'treasure_boss_pattern') {
        // Flee after 7 seconds
        if (performance.now() - e.spawnTime > 7000) {
          // Flee animation
          addFloater(e.x, e.y - 50, 'FLEE!', '#ffd56a');
          const idx = st.enemies.indexOf(e);
          if (idx >= 0) st.enemies.splice(idx, 1);
          return;
        }

        // Boss skills
        if (e.skillCD) {
          e.skillCD -= dt * 1000;
          if (e.skillCD <= 0) {
            useBossSkill(e);
            e.skillCD = 2000;
          }
        }
      } else if (e.behavior === 'support') {
        // Support behaviors for healer/summoner
        if (e.role === 'healer' && e.healCD) {
          e.healCD -= dt * 1000;
          if (e.healCD <= 0 && e.boss && e.boss.hp < e.boss.max) {
            // Heal the boss
            const healAmount = Math.round(e.boss.max * 0.15);
            e.boss.hp = Math.min(e.boss.max, e.boss.hp + healAmount);
            addFloater(e.boss.x, e.boss.y - 50, '+' + healAmount + ' HP', '#36c777');
            addCast(e.x, e.y, '#36c777');
            e.healCD = 3000 + Math.random() * 2000;
          }
        } else if (e.role === 'summoner' && e.summonCD) {
          e.summonCD -= dt * 1000;
          if (e.summonCD <= 0) {
            // Summon minions
            for (let i = 0; i < 2; i++) {
              st.enemies.push({
                kind: 'summoned_minion',
                x: e.x + 50 + i * 40, y: laneY(i % 3),
                hp: 60, max: 60, vx: -0.3, fireCD: 1200,
                role: 'melee', behavior: 'relentless'
              });
            }
            addCast(e.x, e.y, '#ff9aa8');
            e.summonCD = 6000 + Math.random() * 3000;
          }
        }
      }
      // Occasional throwing for melee roles
      if (e.role === 'melee' && Math.random() < 0.003) { enemyShoot(e); }
    }

    /* ================ Loot Tables & Gold Bag ================= */
    const LOOT_TABLES = {
      mobChest: [
        { name: 'Rusty Blade', rank: 'C', slot: 'weapon', atk: 5 },
        { name: 'Cracked Buckler', rank: 'C', slot: 'armor', def: 5 },
        { name: 'Gleam Ring', rank: 'B', slot: 'acc1', atk: 8 }
      ],
      miniBossChest: [
        { name: 'Reinforced Edge', rank: 'B', slot: 'weapon', atk: 18 },
        { name: 'Composite Armor', rank: 'B', slot: 'armor', def: 22 },
        { name: 'Battle Loop', rank: 'B', slot: 'acc2', atk: 15 }
      ],
      bossChest: [
        { name: 'Aether Greatblade', rank: 'A', slot: 'weapon', atk: 40 },
        { name: 'Starlit Carapace', rank: 'A', slot: 'armor', def: 45 },
        { name: 'Celestial Loop', rank: 'S', slot: 'acc1', atk: 55 }
      ]
    };
    function rollLoot(type) {
      const pool = LOOT_TABLES[type] || [];
      if (!pool.length) return null;
      // Luck weighting: higher luck pushes index upward slightly
      const luck = (st.luck || 0) + (st._usLuck || 0);
      const bias = Math.min(0.6, luck * 0.01);
      let idx = Math.floor(Math.random() * pool.length + bias * (pool.length - 1));
      if (idx >= pool.length) idx = pool.length - 1;
      const base = JSON.parse(JSON.stringify(pool[idx]));
      base.id = Math.random();
      base.type = 'gear';
      base.level = 0;
      return base;
    }

    /* =============== Inventory / Bag UI =============== */
    function maxBagSlots() { return st.invRows * 8; }
    function addItemToBag(it) {
      // --- Start of New Stacking Logic ---
      if (it.stackable) {
        const existingStack = st.inv.find(i => i.name === it.name);
        if (existingStack) {
          existingStack.qty = (existingStack.qty || 1) + 1;
          if (st.bagOpen) renderBag(); // Refresh the bag to show new quantity
          return; // Stop the function here
        } else {
          it.qty = 1; // It's the first one, so start quantity at 1
        }
      }
      // --- End of New Stacking Logic ---

      if (st.inv.length >= maxBagSlots()) { notify('Bag Full!', '#ff7a6a'); return; }
      st.inv.push(it);
      if (st.bagOpen) renderBag();
    }
    function renderBag() {
      if (!st.bagOpen) return;
      // Items tab
      const grid = document.getElementById('bagGrid');
      if (grid) {
        grid.innerHTML = '';
        const items = st.inv.filter(i => i && i.type !== 'gear' && i.slot !== 'weapon' && i.slot !== 'armor' && !['acc1', 'acc2'].includes(i.slot) && i.slot !== 'pet' && i.slot !== 'vehicle');
        items.forEach(it => {
          const cell = document.createElement('div');
          cell.className = 'slot-box item';
          cell.textContent = it.qty ? `${it.name} (x${it.qty})` : it.name;
          cell.onclick = () => renderDetail(it, st.inv.findIndex(x => x && x.id === it.id));
          grid.appendChild(cell);
        });
        const empty = maxBagSlots() - st.inv.length;
        for (let i = 0; i < empty; i++) {
          const cell = document.createElement('div');
          cell.className = 'slot-box';
          cell.textContent = '+';
          grid.appendChild(cell);
        }
      }
      // Gear tab
      const gearSlotsEl = document.getElementById('gearSlots');
      const gearGrid = document.getElementById('gearGrid');
      if (gearSlotsEl && gearGrid) {
        gearSlotsEl.innerHTML = '';
        gearGrid.innerHTML = '';
        const slots = [
          { key: 'weapon', label: 'Weapon 1' },
          { key: 'weapon2', label: 'Weapon 2' },
          { key: 'armor', label: 'Armor' },
          { key: 'acc1', label: 'Accessory 1' },
          { key: 'acc2', label: 'Accessory 2' }
        ];
        slots.forEach(({ key, label }) => {
          const slotDiv = document.createElement('div');
          const item = (st.equippedGear || [])[key];
          slotDiv.className = 'slot-box equip';
          slotDiv.textContent = item ? item.name : label;
          slotDiv.onclick = () => { if (item) renderDetail(item, key, true); };
          gearSlotsEl.appendChild(slotDiv);
        });
        st.inv
          .filter(it => it && ['weapon', 'armor', 'acc1', 'acc2'].includes(it.slot))
          .forEach(it => {
            const cell = document.createElement('div');
            cell.className = 'slot-box item';
            cell.textContent = it.name + (it.level ? (' +' + it.level) : '');
            cell.onclick = () => renderDetail(it, st.inv.findIndex(x => x && x.id === it.id));
            gearGrid.appendChild(cell);
          });
      }
      // Pets tab
      const petsGrid = document.getElementById('petsGrid');
      if (petsGrid) {
        petsGrid.innerHTML = '';
        st.equippedPets = st.equippedPets || [];
        while (st.equippedPets.length < st.petSlots) st.equippedPets.push(null);
        for (let i = 0; i < st.petSlots; i++) {
          const pet = st.equippedPets[i];
          const cell = document.createElement('div');
          cell.className = 'slot-box equip pet';
          cell.textContent = pet ? pet.name : ('Pet Slot ' + (i + 1));
          cell.onclick = () => { if (pet) renderDetail(pet, 'petEquipped:' + i, true); };
          petsGrid.appendChild(cell);
        }
        const hr = document.createElement('hr');
        hr.style.gridColumn = '1 / -1'; hr.style.margin = '8px 0'; hr.style.border = '1px solid var(--line)';
        petsGrid.appendChild(hr);
        st.inv.filter(it => it && it.slot === 'pet').forEach(it => {
          const cell = document.createElement('div');
          cell.className = 'slot-box item pet';
          cell.textContent = it.name;
          cell.onclick = () => renderDetail(it, st.inv.findIndex(x => x && x.id === it.id));
          petsGrid.appendChild(cell);
        });
      }
      // Vehicles
      const vehiclesGrid = document.getElementById('vehiclesGrid');
      if (vehiclesGrid) {
        vehiclesGrid.innerHTML = '';
        const cell = document.createElement('div');
        cell.className = 'slot-box equip vehicle';
        cell.textContent = st.equippedVehicle ? st.equippedVehicle.name : 'Equip Vehicle';
        cell.onclick = () => { if (st.equippedVehicle) renderDetail(st.equippedVehicle, 'vehicleEquipped', true); };
        vehiclesGrid.appendChild(cell);
        const hr = document.createElement('hr');
        hr.style.gridColumn = '1 / -1'; hr.style.margin = '8px 0'; hr.style.border = '1px solid var(--line)';
        vehiclesGrid.appendChild(hr);
        st.inv.filter(it => it && it.slot === 'vehicle').forEach(it => {
          const c = document.createElement('div');
          c.className = 'slot-box item vehicle';
          c.textContent = it.name;
          c.onclick = () => renderDetail(it, st.inv.findIndex(x => x && x.id === it.id));
          vehiclesGrid.appendChild(c);
        });
      }
      // Quests
      renderQuests();
      // Shop
      renderShop();
      // Talents
      renderTalentLanes();
      document.getElementById('bagGoldVal').textContent = st.gold;

      // Update paper doll panel if it exists
      if (typeof updatePaperDoll === 'function') updatePaperDoll();

      // Skins tab
      renderSkinsTab();
    }

    // Render skins tab with character skin selection
    function renderSkinsTab() {
      console.log("🎨 Rendering skins tab...");
      console.log("Character skin system:", window.characterSkinSystem);
      console.log("Sprite loader:", window.spriteLoader);
      console.log("Animation handler:", window.animationHandler);

      // Wait for systems to load
      if (!window.characterSkinSystem) {
        console.log("⏳ Character skin system not loaded yet, retrying...");
        setTimeout(renderSkinsTab, 100);
        return;
      }

      const characters = ['A1', 'Unique', 'Missy'];
      characters.forEach(charId => {
        const grid = document.getElementById(`skins${charId}Grid`);
        if (!grid) {
          console.error(`❌ Grid not found for ${charId}`);
          return;
        }
        grid.innerHTML = '';

        const skins = window.characterSkinSystem.getAvailableSkins(charId);
        console.log(`📦 Loading ${skins.length} skins for ${charId}:`, skins);

        if (skins.length === 0) {
          // Show placeholder if no skins
          const placeholder = document.createElement('div');
          placeholder.className = 'skin-box';
          placeholder.innerHTML = '<div style="color: #666; text-align: center; padding: 20px;">No skins available</div>';
          grid.appendChild(placeholder);
          return;
        }

        skins.forEach(skin => {
          const box = document.createElement('div');
          box.className = 'skin-box';
          if (skin.equipped) box.classList.add('equipped');
          if (!skin.unlocked) box.classList.add('locked');

          // Create mini preview canvas
          const canvas = document.createElement('canvas');
          canvas.width = 100; // Increased size
          canvas.height = 100;
          const ctx = canvas.getContext('2d');

          // Draw skin preview
          if (skin.type === 'sprite' && skin.sprite) {
            const sprite = window.spriteLoader?.getSkinSprite(skin.sprite);
            if (sprite && window.animationHandler) {
              window.animationHandler.renderSprite(ctx, sprite, 50, 50, {
                animState: 'idle',
                animTime: performance.now(),
                scale: 0.8
              });
            } else {
              // Fallback if sprite not loaded
              ctx.fillStyle = '#333';
              ctx.fillRect(0, 0, 100, 100);
              ctx.fillStyle = '#fff';
              ctx.font = '12px Arial';
              ctx.textAlign = 'center';
              ctx.fillText('Loading...', 50, 50);
            }
          } else {
            // Draw procedural preview
            window.characterSkinSystem.renderSkinPreview(charId, skin.id, canvas, 100, 100);
          }

          box.appendChild(canvas);

          // Add skin name label
          const label = document.createElement('div');
          label.style.cssText = 'position: absolute; bottom: 0; left: 0; right: 0; background: rgba(0,0,0,0.7); color: white; font-size: 10px; text-align: center; padding: 2px;';
          label.textContent = skin.name;
          box.appendChild(label);

          box.addEventListener('click', () => {
            if (!skin.unlocked) return;

            // Auto-equip the skin immediately
            if (window.characterSkinSystem) {
              window.characterSkinSystem.equipSkin(charId, skin.id);
              console.log(`🎨 Auto-equipped ${skin.name} for ${charId}`);

              // Refresh the skins tab to show the new equipped state
              renderSkinsTab();

              // Update the preview to show the newly equipped skin
              previewSkin(charId, skin.id);
            }
          });

          grid.appendChild(box);
        });
      });
    }

    // Preview skin in the preview panel
    function previewSkin(characterId, skinId) {
      const canvas = document.getElementById('skinPreviewCanvas');
      const nameEl = document.getElementById('skinName');
      const descEl = document.getElementById('skinDescription');
      const equipBtn = document.getElementById('btnEquipSkin');

      if (!canvas || !nameEl || !descEl || !equipBtn) return;

      const skin = window.characterSkinSystem.getSkins(characterId)[skinId];
      if (!skin) return;

      // Update preview
      window.characterSkinSystem.renderSkinPreview(characterId, skinId, canvas, 200, 200);

      // Update info
      nameEl.textContent = skin.name;
      descEl.textContent = skin.description || 'No description available';

      // Update equip button
      const isEquipped = window.characterSkinSystem.equippedSkins[characterId] === skinId;
      equipBtn.textContent = isEquipped ? 'Equipped' : 'Equip';
      equipBtn.disabled = isEquipped;

      // Store current selection
      equipBtn.onclick = () => {
        if (isEquipped) return;
        window.characterSkinSystem.equipSkin(characterId, skinId);
        renderSkinsTab();
        previewSkin(characterId, skinId);
      };
    }

    // Update the Paper Doll preview panel. Displays equipped gear, pets, and vehicle.
    function updatePaperDoll() {
      try {
        const weaponEl = document.getElementById('paperWeapon');
        const weapon2El = document.getElementById('paperWeapon2');
        const armorEl = document.getElementById('paperArmor');
        const acc1El = document.getElementById('paperAcc1');
        const acc2El = document.getElementById('paperAcc2');
        const pet1El = document.getElementById('paperPet1');
        const pet2El = document.getElementById('paperPet2');
        const vehEl = document.getElementById('paperVeh');
        if (!weaponEl) return;
        const gear = st.equippedGear || {};
        weaponEl.textContent = gear.weapon ? gear.weapon.name : 'Weapon 1';
        if (weapon2El) weapon2El.textContent = gear.weapon2 ? gear.weapon2.name : 'Weapon 2';
        armorEl.textContent = gear.armor ? gear.armor.name : 'Armor';
        acc1El.textContent = gear.acc1 ? gear.acc1.name : 'Accessory 1';
        acc2El.textContent = gear.acc2 ? gear.acc2.name : 'Accessory 2';
        const pets = st.equippedPets || [];
        pet1El.textContent = pets[0] ? pets[0].name : 'Pet 1';
        pet2El.textContent = pets[1] ? pets[1].name : 'Pet 2';
        vehEl.textContent = st.equippedVehicle ? st.equippedVehicle.name : 'Vehicle';
        // Attach simple un-equip on click for each slot
        weaponEl.onclick = () => {
          if (gear.weapon) { addItemToBag(gear.weapon); gear.weapon = null; renderBag(); }
        };
        if (weapon2El) {
          weapon2El.onclick = () => {
            if (gear.weapon2) { addItemToBag(gear.weapon2); gear.weapon2 = null; renderBag(); }
          };
        }
        armorEl.onclick = () => {
          if (gear.armor) { addItemToBag(gear.armor); gear.armor = null; renderBag(); }
        };
        acc1El.onclick = () => {
          if (gear.acc1) { addItemToBag(gear.acc1); gear.acc1 = null; renderBag(); }
        };
        acc2El.onclick = () => {
          if (gear.acc2) { addItemToBag(gear.acc2); gear.acc2 = null; renderBag(); }
        };
        pet1El.onclick = () => {
          if (pets[0]) {
            addItemToBag(pets[0]);
            st.equippedPets[0] = null;
            if (Array.isArray(st.activePets)) {
              st.activePets = st.activePets.filter(p => p._slotIndex !== 0);
            }
            renderBag();
          }
        };
        pet2El.onclick = () => {
          if (pets[1]) {
            addItemToBag(pets[1]);
            st.equippedPets[1] = null;
            if (Array.isArray(st.activePets)) {
              st.activePets = st.activePets.filter(p => p._slotIndex !== 1);
            }
            renderBag();
          }
        };
        vehEl.onclick = () => {
          if (st.equippedVehicle) { addItemToBag(st.equippedVehicle); st.equippedVehicle = null; renderBag(); }
        };
        // Tooltip on hover: show stats and rank if available
        const showInfo = (el, item) => {
          if (!el) return;
          if (!item) { el.removeAttribute('title'); return; }
          const statParts = [];
          if (typeof item.hp !== 'undefined') statParts.push('HP: ' + item.hp);
          if (typeof item.atk !== 'undefined') statParts.push('ATK: ' + item.atk);
          if (typeof item.def !== 'undefined') statParts.push('DEF: ' + item.def);
          if (item.rank) statParts.push('Rank: ' + item.rank);
          if (item.level) statParts.push('Lv ' + item.level);
          if (item.passive) statParts.push('Passive: ' + item.passive);
          if (item.unique) statParts.push('Skill: ' + item.unique);
          el.title = statParts.join('\n');
        };
        showInfo(weaponEl, gear.weapon);
        if (weapon2El) showInfo(weapon2El, gear.weapon2);
        showInfo(armorEl, gear.armor);
        showInfo(acc1El, gear.acc1);
        showInfo(acc2El, gear.acc2);
        showInfo(pet1El, pets[0]);
        showInfo(pet2El, pets[1]);
        showInfo(vehEl, st.equippedVehicle);
      } catch (ex) { console.error(ex); }
    }

    function renderQuests() {
      const questsList = document.getElementById('questsList');
      if (!questsList) return;

      questsList.innerHTML = '';

      if (!st.dailyQuests || st.dailyQuests.length === 0) {
        const placeholder = document.createElement('div');
        placeholder.className = 'quest-item';
        placeholder.innerHTML = '<p class="quest-placeholder">No active quests</p>';
        questsList.appendChild(placeholder);
        return;
      }

      st.dailyQuests.forEach(quest => {
        const questDiv = document.createElement('div');
        questDiv.className = 'quest-item' + (quest.completed ? ' completed' : '');

        const progressPercent = Math.min(100, (quest.progress / quest.target) * 100);

        let rewardHtml = `Reward: ${Object.keys(quest.reward).map(key => `${quest.reward[key]} ${key}`).join(', ')}`;
        // Show claim button for completed but unclaimed quests
        if (quest.completed && !quest.claimed) {
          rewardHtml += ` <button class="claim-reward-btn quest-claim-btn" data-id="${quest.id}">Claim Reward</button>`;
        } else if (quest.claimed) {
          rewardHtml += ` <span class="quest-claimed-badge">(Claimed)</span>`;
        } else if (quest.completed) {
          rewardHtml += ` <span class="quest-completed-badge">(Completed)</span>`;
        }
        // Build tier tag HTML
        const tierTag = quest.tier ? `<span class="quest-tier ${quest.tier}">${quest.tier.charAt(0).toUpperCase() + quest.tier.slice(1)}</span>` : '';
        questDiv.innerHTML = `
      <div class="quest-header">
        <div class="quest-name">${quest.name} ${tierTag}</div>
        <div class="quest-progress">${quest.progress}/${quest.target}</div>
      </div>
      <div class="quest-description">${quest.description}</div>
      <div class="quest-progress-bar">
        <div class="quest-progress-fill" style="transform:scaleX(${progressPercent / 100})"></div>
      </div>
      <div class="quest-reward">${rewardHtml}</div>
    `;

        // Attach claim reward button handler if present
        const claimBtn = questDiv.querySelector('.claim-reward-btn');
        if (claimBtn) {
          claimBtn.addEventListener('click', (ev) => {
            ev.stopPropagation();
            claimQuestReward(quest);
          });
        }
        questsList.appendChild(questDiv);
      });

      // Grey out the quests panel if all quests have been claimed
      try {
        const questsContent = document.getElementById('questsContent');
        if (questsContent) {
          const allClaimed = (st.dailyQuests || []).length > 0 && st.dailyQuests.every(q => q.claimed);
          questsContent.style.opacity = allClaimed ? '0.4' : '1';
        }
      } catch (_ex) { }

      // Update endless mode stats if active
      const endlessStats = document.getElementById('endlessStats');
      if (endlessStats && st.endlessMode) {
        endlessStats.style.display = 'block';
        document.getElementById('endlessScore').textContent = st.endlessScore || 0;

        if (st.endlessStartTime) {
          const elapsed = (performance.now() - st.endlessStartTime) / 1000;
          const minutes = Math.floor(elapsed / 60);
          const seconds = Math.floor(elapsed % 60);
          document.getElementById('endlessTime').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }
      }
    }
    function openBag(tab = 'items') {
      st.bagOpen = true; st.bagTab = tab;
      document.getElementById('inventory').classList.add('open');
      document.querySelectorAll('.bag-nav-item').forEach(b => {
        const t = b.getAttribute('data-tab');
        b.classList.toggle('active', t === tab);
      });
      document.querySelectorAll('.bag-panel').forEach(p => p.classList.remove('active'));
      const panel = document.getElementById('bag-' + tab);
      if (panel) panel.classList.add('active');
      renderBag();
    }
    function closeBag() {
      st.bagOpen = false;
      document.getElementById('inventory').classList.remove('open');
    }
    document.getElementById('btnInventory').onclick = () => openBag('items');
    const quickBagBtn = document.getElementById('btnBagQuick');
    if (quickBagBtn) quickBagBtn.onclick = () => openBag('items');
    document.getElementById('btnPets').onclick = () => openBag('pets');
    document.getElementById('btnVehicles').onclick = () => openBag('vehicles');
    document.getElementById('btnTalents').onclick = () => openBag('talent');
    document.getElementById('btnShop').onclick = () => openBag('shop');
    document.getElementById('btnSettings').onclick = () => openBag('settings');
    document.getElementById('btnCloseBag').onclick = () => closeBag();
    // Vehicle skill button: default to V1 when leader is driving
    try {
      const _vehSkillBtn = document.getElementById('btnVehicleSkill');
      if (_vehSkillBtn) { _vehSkillBtn.addEventListener('click', () => { const v = getLeaderVehicle(); if (v) useVehicleSkill(v, 'V1'); }); }
    } catch (e) { }

    // Pet spawn/recall adapted to equipped pets using capture to override legacy bindings
    try {
      const btnPetEl = document.getElementById('btnPet');
      function summonEquippedPetForLeader() {
        const L = leader(); if (!L) return;
        const equipped = (st.equippedPets || []).map((pet, idx) => ({ pet, idx })).filter(entry => entry.pet);
        if (!equipped.length) { notify('Equip a pet first', '#ff7a6a'); return; }
        st.activePets = st.activePets || [];
        let summoned = 0;
        for (const { pet, idx } of equipped) {
          const already = st.activePets.some(p => p.owner === L.id && p._slotIndex === idx);
          if (already) continue;
          const baseHP = 80 + ((pet.level || 0) * 12);
          st.activePets.push({
            id: Math.floor(Math.random() * 1e9),
            name: pet.name || 'Companion',
            x: L.x + 42 + idx * 18,
            y: L.y - 28 - idx * 12,
            hp: baseHP,
            hpMax: baseHP,
            owner: L.id,
            ai: 'flank',
            fireCD: 0,
            _berserkT: 0,
            _berserkMul: 1,
            _slotIndex: idx
          });
          summoned++;
        }
        if (summoned > 0) {
          notify(`Pet${summoned > 1 ? 's' : ''} summoned`, '#c1ffc1');
        } else {
          notify('Pets already active', '#ffd56a');
        }
      }
      function recallLeaderPets() {
        const L = leader(); if (!L || !st.activePets) return;
        st.activePets = st.activePets.filter(p => p.owner !== L.id);
        notify('Pet recalled', '#c1ffc1');
      }
      if (btnPetEl) {
        btnPetEl.addEventListener('click', function (ev) {
          try { ev.stopImmediatePropagation(); ev.preventDefault(); } catch (_e) { }
          const L = leader();
          const equippedCount = (st.equippedPets || []).filter(Boolean).length;
          const leaderId = L ? L.id : null;
          const activeCount = leaderId == null ? 0 : (st.activePets || []).filter(p => p.owner === leaderId).length;
          if (activeCount && activeCount >= equippedCount) recallLeaderPets(); else summonEquippedPetForLeader();
        }, true);
      }
    } catch (e) { }

    // Vehicle board/disembark using equipped vehicle only (capture to override legacy handlers)
    try {
      function inferVehKindFromItem(it) {
        const t = (it?.vehType || it?.type || '').toLowerCase(); const n = (it?.name || '').toLowerCase();
        if (t) return t;
        if (n.includes('bike')) return 'bike';
        if (n.includes('chopper')) return 'chopper';
        if (n.includes('jetpack')) return 'jetpack';
        if (n.includes('car')) return 'car';
        return 'car';
      }
      function toggleLeaderVehicle() {
        const vNow = getLeaderVehicle();
        const L = st.players[st.leader || 0];
        if (vNow) { if (L) exitVehicle(L); return; }
        if (!st.equippedVehicle) { notify('Equip a vehicle first', '#ff7a6a'); return; }
        const kind = inferVehKindFromItem(st.equippedVehicle);
        const prev = (st.vehicles || []).length;
        spawnVehicle(kind);
        if ((st.vehicles || []).length > prev) {
          const v = st.vehicles[st.vehicles.length - 1];
          if (L) enterVehicleSeat(L, v, 0);
        }
      }
      const btnVehEl = document.getElementById('btnVeh');
      if (btnVehEl) {
        btnVehEl.addEventListener('click', function (ev) {
          try { ev.stopImmediatePropagation(); ev.preventDefault(); } catch (_e) { }
          toggleLeaderVehicle();
        }, true);
      }
    } catch (e) { }
    document.querySelectorAll('.bag-nav-item').forEach(btn => {
      btn.addEventListener('click', () => {
        openBag(btn.getAttribute('data-tab'));
      });
    });

    document.getElementById('btnAlchemy').onclick = () => openAlchemyPanel();
    document.getElementById('btnCloseAlchemy').onclick = () => closeAlchemyPanel();

    function openAlchemyPanel() {
      document.getElementById('alchemy-panel').classList.add('open');
      renderAlchemyBag();
    }
    function closeAlchemyPanel() {
      document.getElementById('alchemy-panel').classList.remove('open');
    }

    /* ================= Shop Items =================== */
    const SHOP_ITEMS = [
      // Consumables
      { id: 'hp_potion', name: 'HP Potion', description: 'Heals 40% leader HP.', cost: 60, type: 'consumable', category: 'consumable' },
      { id: 'rage_pill', name: 'Rage Pill', description: 'Grants +30 Rage to party.', cost: 90, type: 'consumable', category: 'consumable' },
      { id: 'revive_token', name: 'Revive Token', description: 'Instantly revives one defeated hero.', cost: 80, type: 'consumable', category: 'consumable' },
      { id: 'wave_skip', name: 'Wave Skip', description: 'Skips the current wave.', cost: 100, type: 'consumable', category: 'consumable' },
      { id: 'stage_skip', name: 'Stage Skip', description: 'Skips the current stage.', cost: 500, type: 'consumable', category: 'consumable' },
      { id: 'boss_skip_pass', name: 'Boss Skip Pass', description: 'Skips to the next boss.', cost: 1000, type: 'consumable', category: 'consumable' },
      { id: 'treasure_box_boss_pass', name: 'Treasure Box Boss Pass', description: 'Unlocks a special treasure boss.', cost: 2000, type: 'consumable', category: 'consumable' },
      { id: 'ap_reset', name: 'AP Reset', description: 'Refund all spent AP.', cost: 400, type: 'consumable', category: 'consumable' },
      // Containers & Misc
      { id: 'gold_bag', name: 'Gold Bag', description: 'Open for 500–5000 gold.', cost: 300, type: 'item', category: 'misc' },
      { id: 'big_gold_bag', name: 'Big Gold Bag', description: 'Open for 2000–10000 gold.', cost: 1200, type: 'item', category: 'misc' },
      { id: 'gear_kit', name: 'Random Gear Kit', description: 'Adds 3 random gear pieces.', cost: 250, type: 'item', category: 'gear' },
      { id: 'pet_box', name: 'Pet Box', description: 'Contains a random pet.', cost: 500, type: 'item', category: 'misc' },
      { id: 'vehicle_box', name: 'Vehicle Box', description: 'Contains a random vehicle.', cost: 750, type: 'item', category: 'misc' },
      { id: 'super_equipment_pack', name: 'Super Equipment Pack', description: 'Contains B-A rank gear.', cost: 1500, type: 'item', category: 'gear' },
      { id: 'big_box', name: 'Big Box', description: 'Contains 3 random items, 1 pet, 1 vehicle, and 1 set of A-C rank gear.', cost: 3000, type: 'item', category: 'misc' },
      // Armor items (provide defensive stats and potential set bonuses)
      { id: 'vanguard_armor', name: 'Vanguard Armor', description: 'Sturdy armor boosting DEF by 50.', cost: 500, type: 'gear', category: 'armor', slot: 'armor', def: 50, set: 'Vanguard' },
      { id: 'mystic_robes', name: 'Mystic Robes', description: 'Robes boosting DEF by 40 and MP.', cost: 600, type: 'gear', category: 'armor', slot: 'armor', def: 40, mp: 50, set: 'Mystic' },
      // Spell scrolls: teach new skills when consumed
      { id: 'spell_scroll_fireball', name: 'Spell Scroll: Fireball', description: 'Learn the Fireball skill.', cost: 400, type: 'scroll', category: 'scroll', use: 'learn_fireball' },
      { id: 'spell_scroll_heal', name: 'Spell Scroll: Heal', description: 'Learn the Heal skill.', cost: 500, type: 'scroll', category: 'scroll', use: 'learn_heal' },
      // S-Rank gear (premium items)
      { id: 'aether_greatblade', name: 'Aether Greatblade', description: 'Legendary blade imbued with cosmic power.', cost: 5000, type: 'gear', category: 'srank', slot: 'weapon', atk: 55, rank: 'S' },
      { id: 'starlit_carapace', name: 'Starlit Carapace', description: 'Radiant armor forged from starlight.', cost: 5000, type: 'gear', category: 'srank', slot: 'armor', def: 60, rank: 'S' },
      { id: 'celestial_loop', name: 'Celestial Loop', description: 'Exquisite ring channeling celestial energy.', cost: 5000, type: 'gear', category: 'srank', slot: 'accessory', atk: 65, rank: 'S' }
    ];
    function renderShop() {
      const grid = document.getElementById('shopGrid'); if (!grid) return;
      // Ensure shop tabs exist. Create them on first render.
      const parent = grid.parentElement;
      let tabs = document.getElementById('shopTabs');
      if (!tabs) {
        tabs = document.createElement('div');
        tabs.id = 'shopTabs';
        tabs.style.display = 'flex';
        tabs.style.gap = '6px';
        tabs.style.marginBottom = '8px';
        tabs.style.flexWrap = 'wrap';
        const categories = [
          { cat: 'all', label: 'All' },
          { cat: 'consumable', label: 'Consumables' },
          { cat: 'gear', label: 'Gear' },
          { cat: 'armor', label: 'Armor' },
          { cat: 'scroll', label: 'Scrolls' },
          { cat: 'srank', label: 'S Rank' }
        ];
        categories.forEach(cfg => {
          const btn = document.createElement('button');
          btn.className = 'shop-tab';
          btn.setAttribute('data-cat', cfg.cat);
          btn.textContent = cfg.label;
          btn.style.padding = '4px 8px';
          btn.style.border = 'none';
          btn.style.borderRadius = '4px';
          btn.style.cursor = 'pointer';
          btn.style.background = '#1f2e47';
          btn.style.color = '#cfe3ff';
          tabs.appendChild(btn);
        });
        parent.insertBefore(tabs, grid);
        // Attach listeners to category buttons
        tabs.addEventListener('click', (ev) => {
          const btn = ev.target.closest('button.shop-tab');
          if (!btn) return;
          const cat = btn.getAttribute('data-cat');
          st.shopCategory = cat || 'all';
          // Highlight active tab
          tabs.querySelectorAll('button.shop-tab').forEach(b => {
            if (b.getAttribute('data-cat') === st.shopCategory) {
              b.style.background = '#2EA8FF';
              b.style.color = '#fff';
            } else {
              b.style.background = '#1f2e47';
              b.style.color = '#cfe3ff';
            }
          });
          renderShop();
        });
        // Immediately highlight the default tab on first creation
        tabs.querySelectorAll('button.shop-tab').forEach(b => {
          if (b.getAttribute('data-cat') === st.shopCategory) {
            b.style.background = '#2EA8FF';
            b.style.color = '#fff';
          }
        });
      } else {
        // Ensure active tab styling matches current category
        const buttons = tabs.querySelectorAll('button.shop-tab');
        buttons.forEach(btn => {
          if (btn.getAttribute('data-cat') === st.shopCategory) {
            btn.style.background = '#2EA8FF';
            btn.style.color = '#fff';
          } else {
            btn.style.background = '#1f2e47';
            btn.style.color = '#cfe3ff';
          }
        });
      }
      // Filter items by category
      grid.innerHTML = '';
      const items = SHOP_ITEMS.filter(it => {
        if (!st.shopCategory || st.shopCategory === 'all') return true;
        return it.category === st.shopCategory;
      });
      items.forEach(it => {
        const d = document.createElement('div');
        d.className = 'shop-item';
        d.innerHTML = `<h5>${it.name}</h5><p>${it.description}</p><p><b>Cost: ${it.cost} Gold</b></p><button data-id="${it.id}">Buy</button>`;
        grid.appendChild(d);
      });
      grid.onclick = e => {
        if (e.target.matches('button[data-id]')) {
          buyShopItem(e.target.getAttribute('data-id'));
        }
      };
    }
    function buyShopItem(id) {
      const it = SHOP_ITEMS.find(i => i.id === id); if (!it) return;
      if (st.gold < it.cost) { notify('Not enough gold', '#ff7a6a'); return; }
      st.gold -= it.cost; updateCurrencies();
      notify('Purchased ' + it.name);
      // Dynamic handling for category-based items. Armor creates gear; spell scrolls teach skills.
      if (it.category === 'armor') {
        // Create an armor gear item using makeGear with provided stats
        const gear = makeGear(it.name, 'armor', { def: it.def || 0, mp: it.mp || 0, set: it.set || undefined });
        addItemToBag(gear);
        renderBag();
        return;
      }
      if (it.category === 'scroll') {
        // Add a consumable scroll item to inventory that will teach a skill when used
        addItemToBag({ name: it.name, type: 'consumable', use: it.use, description: it.description, stackable: false });
        renderBag();
        return;
      }
      // Fall back to existing id-based logic for core shop items
      switch (it.id) {
        case 'hp_potion':
          addItemToBag({
            name: 'Party Potion',
            type: 'consumable',
            use: 'heal_party',
            stackable: true
          });
          break;
        case 'rage_pill':
          st.players.forEach(p => p.rage = Math.min(p.rageMax, p.rage + 30));
          break;
        case 'revive_token':
          addItemToBag({
            name: 'Revive Token',
            type: 'consumable',
            use: 'revive_hero',
            stackable: true
          });
          break;
        case 'gold_bag':
          addItemToBag({
            name: 'Gold Bag',
            type: 'container',
            use: 'open_gold_bag',
            description: 'Open for 500-5000 gold.',
            stackable: true
          });
          break;
        case 'big_gold_bag':
          addItemToBag({
            name: 'Big Gold Bag',
            type: 'container',
            use: 'open_big_gold_bag',
            description: 'Open for 2000-10000 gold.',
            stackable: true
          });
          break;
        case 'gear_kit':
          addItemToBag({
            name: 'Random Gear Kit',
            type: 'container',
            use: 'open_gear_kit',
            description: 'Adds 3 random gear pieces.',
            stackable: true
          });
          break;
        case 'ap_reset':
          st.talentPicks.clear(); st.apSpent = 0; tallyTalentStats(); renderTalentLanes(); break;
        case 'pet_box':
          addItemToBag({
            name: 'Pet Box',
            type: 'container',
            use: 'open_pet_box',
            description: 'Contains a random pet.',
            stackable: true
          });
          break;
        case 'vehicle_box':
          addItemToBag({
            name: 'Vehicle Box',
            type: 'container',
            use: 'open_vehicle_box',
            description: 'Contains a random vehicle.',
            stackable: true
          });
          break;
        case 'wave_skip':
          st.enemies = [];
          if (window.__PROG95) {
            st.waveStep = Math.min(18, (st.waveStep || 1) + 1);
            st.wave = window.__PROG95.baseWave(st.waveStep);
          } else {
            st.wave++;
          }
          spawnWave();
          break;
        case 'stage_skip':
          st.enemies = [];
          // Jump to boss (9.5) of the current Stage(.5)
          if (window.__PROG95) {
            st.waveStep = 18;
          } else {
            st.stage++;
            st.wave = 1;
          }
          spawnWave();
          break;
        case 'boss_skip_pass':
          // Boss now = 9.5 always
          st.enemies = [];
          if (window.__PROG95) {
            st.waveStep = 18;
          } else {
            st.stage = 10;
            st.wave = st.wavesPerStage;
          }
          spawnWave();
          break;
        case 'treasure_box_boss_pass':
          // Force-boss: jump to boss wave (9.5), then spawn the standard boss
          st.enemies = [];
          if (window.__PROG95) {
            st.waveStep = 18;
          } else {
            st.stage = 10;
            st.wave = st.wavesPerStage;
          }
          spawnBossForStage();
          break;
        case 'super_equipment_pack':
          addItemToBag({
            name: 'Super Equipment Pack',
            type: 'container',
            use: 'open_super_equipment_pack',
            description: 'Contains B-A rank gear.',
            stackable: true
          });
          break;
        case 'big_box':
          addItemToBag({
            name: 'Big Box',
            type: 'container',
            use: 'open_big_box',
            description: 'Contains 3 random items, 1 pet, 1 vehicle, and 1 set of A-C rank gear.',
            stackable: true
          });
          break;
      }
      renderBag();
    }

    /* ================== Gear / Items =================== */
    function makeGear(name, slot, extra = {}) {
      return { id: Math.random(), name, slot, type: 'gear', level: 0, ...extra };
    }
    function renderDetail(item, indexOrSlot, equipped = false) {
      const nameEl = $('#detailName'), statEl = $('#detailStats'), actEl = $('#detailActions');
      if (!item) { nameEl.textContent = 'Select Item'; statEl.textContent = '-'; actEl.innerHTML = ''; return; }
      // Display item name and stats differently for pets/vehicles vs other gear/items
      if (item && (item.slot === 'pet' || item.slot === 'vehicle')) {
        nameEl.textContent = item.name;
        const parts = [];
        if (item.rank) parts.push('Rank: ' + item.rank);
        if (item.level != null) parts.push('Level: ' + item.level);
        if (item.hp) parts.push('HP:' + item.hp);
        if (item.atk) parts.push('ATK:' + item.atk);
        if (item.def) parts.push('DEF:' + item.def);
        statEl.textContent = parts.join('  ') || '-';
      } else {
        nameEl.textContent = item.name + (item.level ? (' +' + item.level) : '');
        let desc = '';
        if (item.type === 'gear') {
          if (item.atk) desc += 'ATK +' + item.atk + ' ';
          if (item.def) desc += 'DEF +' + item.def + ' ';
        } else if (item.type === 'gold_bag') {
          desc = 'Open to gain random gold (500-5000).';
        } else if (item.type === 'big_gold_bag') {
          desc = 'Open to gain random gold (2000-10000).';
        } else {
          desc = item.description || '-';
        }
        statEl.textContent = desc.trim() || '-';
      }
      actEl.innerHTML = '';
      // Actions
      if (item.type === 'gear') {
        // Pets and vehicles have unique equip/unequip logic
        if (item.slot === 'pet') {
          if (equipped) {
            const unequipBtn = document.createElement('button');
            unequipBtn.textContent = 'Unequip';
            unequipBtn.onclick = () => {
              try {
                if (typeof indexOrSlot === 'string') {
                  const parts = indexOrSlot.split(':');
                  const slotIdx = parseInt(parts[1] || '0', 10);
                  const removed = st.equippedPets[slotIdx];
                  if (removed) addItemToBag(removed);
                  st.equippedPets[slotIdx] = null;
                  if (Array.isArray(st.activePets)) {
                    st.activePets = st.activePets.filter(p => p._slotIndex !== slotIdx);
                  }
                  renderBag(); renderDetail(null);
                }
              } catch (ex) { console.error(ex); }
            };
            actEl.appendChild(unequipBtn);
          } else {
            const idx = indexOrSlot;
            const ensureSlots = () => {
              st.equippedPets = st.equippedPets || [];
              while (st.equippedPets.length < (st.petSlots || 0)) {
                st.equippedPets.push(null);
              }
            };
            ensureSlots();
            for (let slotIdx = 0; slotIdx < (st.petSlots || 0); slotIdx++) {
              const btn = document.createElement('button');
              btn.textContent = `Equip to Pet Slot ${slotIdx + 1}`;
              btn.onclick = () => {
                try {
                  ensureSlots();
                  const it = st.inv[idx];
                  if (!it) return;
                  if (st.equippedPets[slotIdx]) addItemToBag(st.equippedPets[slotIdx]);
                  st.equippedPets[slotIdx] = it;
                  st.inv.splice(idx, 1);
                  renderBag();
                  renderDetail(null);
                } catch (ex) { console.error(ex); }
              };
              actEl.appendChild(btn);
            }
          }
          // Evolve button for pets
          try {
            const order = ['C', 'B', 'A', 'S'];
            const thresholds = [10, 20, 30];
            const curRank = item.rank || 'C';
            const idxRank = order.indexOf(curRank);
            const dup = (st.inv || []).find(x => x && x.slot === 'pet' && x.name === item.name && x.rank === item.rank && x.id !== item.id);
            if (dup && idxRank >= 0 && idxRank < order.length - 1 && (item.level || 1) >= thresholds[idxRank]) {
              const evoBtn = document.createElement('button');
              evoBtn.textContent = 'Evolve';
              evoBtn.onclick = () => {
                evolvePet(item, indexOrSlot);
              };
              actEl.appendChild(evoBtn);
            }
          } catch (ex) { console.error(ex); }
        } else if (item.slot === 'vehicle') {
          if (equipped) {
            const unequipBtn = document.createElement('button');
            unequipBtn.textContent = 'Unequip';
            unequipBtn.onclick = () => {
              try {
                if (st.equippedVehicle) {
                  addItemToBag(st.equippedVehicle);
                  st.equippedVehicle = null;
                  renderBag(); renderDetail(null);
                }
              } catch (ex) { console.error(ex); }
            };
            actEl.appendChild(unequipBtn);
          } else {
            const equipBtn = document.createElement('button');
            equipBtn.textContent = 'Equip';
            equipBtn.onclick = () => {
              try {
                const idx = indexOrSlot;
                const it = st.inv[idx];
                if (!it) return;
                if (st.equippedVehicle) addItemToBag(st.equippedVehicle);
                st.equippedVehicle = it;
                st.inv.splice(idx, 1);
                renderBag(); renderDetail(null);
              } catch (ex) { console.error(ex); }
            };
            actEl.appendChild(equipBtn);
          }
          // Evolve button for vehicles
          try {
            const order = ['C', 'B', 'A', 'S'];
            const thresholds = [10, 20, 30];
            const curRank = item.rank || 'C';
            const idxRank = order.indexOf(curRank);
            const dup = (st.inv || []).find(x => x && x.slot === 'vehicle' && x.name === item.name && x.rank === item.rank && x.id !== item.id);
            if (dup && idxRank >= 0 && idxRank < order.length - 1 && (item.level || 1) >= thresholds[idxRank]) {
              const evoBtn = document.createElement('button');
              evoBtn.textContent = 'Evolve';
              evoBtn.onclick = () => {
                evolveVehicle(item, indexOrSlot);
              };
              actEl.appendChild(evoBtn);
            }
          } catch (ex) { console.error(ex); }
        } else {
          if (equipped) {
            const b = document.createElement('button');
            b.textContent = 'Unequip';
            b.onclick = () => {
              if (typeof indexOrSlot === 'string') {
                const slotKey = indexOrSlot;
                const existing = st.equippedGear[slotKey];
                if (existing) addItemToBag(existing);
                st.equippedGear[slotKey] = null;
                recalcStats();
                renderBag();
                renderDetail(null);
              }
            };
            actEl.appendChild(b);
          } else {
            const idx = indexOrSlot;
            const equipTargets = [];
            if (item.slot === 'weapon') {
              equipTargets.push({ key: 'weapon', label: 'Equip to Weapon 1' });
              equipTargets.push({ key: 'weapon2', label: 'Equip to Weapon 2' });
            } else if (item.slot === 'acc1' || item.slot === 'acc2' || item.slot === 'accessory') {
              equipTargets.push({ key: 'acc1', label: 'Equip to Accessory 1' });
              equipTargets.push({ key: 'acc2', label: 'Equip to Accessory 2' });
            } else {
              equipTargets.push({ key: item.slot, label: 'Equip' });
            }
            const equipToSlot = (slotKey) => {
              const it = st.inv[idx];
              if (!it) return;
              if (!st.equippedGear) st.equippedGear = {};
              if (st.equippedGear[slotKey]) addItemToBag(st.equippedGear[slotKey]);
              st.equippedGear[slotKey] = it;
              st.inv.splice(idx, 1);
              recalcStats();
              renderBag();
              renderDetail(null);
            };
            equipTargets.forEach(({ key, label }) => {
              const btn = document.createElement('button');
              btn.textContent = label;
              btn.onclick = () => equipToSlot(key);
              actEl.appendChild(btn);
            });
          }
          // Upgrade button for default gear
          const up = document.createElement('button');
          up.className = 'upgrade-btn';
          up.textContent = item.level >= 10 ? 'Max +10' : 'Upgrade';
          up.disabled = item.level >= 10 || st.gold < calcUpgradeCost(item);
          up.onclick = () => {
            if (item.level >= 10) return;
            const cost = calcUpgradeCost(item);
            if (st.gold < cost) { notify('Need ' + cost + ' Gold', '#ff7a6a'); return; }
            st.gold -= cost;
            item.level++;
            if (item.atk) item.atk = Math.round(item.atk * 1.12);
            if (item.def) item.def = Math.round(item.def * 1.12);
            updateCurrencies(); recalcStats(); renderBag(); renderDetail(item, indexOrSlot, equipped);
          };
          actEl.appendChild(up);
        }
      } else if (item.type === 'gold_bag') {
        const b = document.createElement('button'); b.textContent = 'Open';
        b.onclick = () => {
          const idx = st.inv.findIndex(x => x && x.id === item.id);
          if (idx >= 0) st.inv.splice(idx, 1);
          const amt = 500 + Math.floor(Math.random() * 4501);
          st.gold += amt; updateCurrencies();
          notify('+' + amt + ' Gold', '#ffd56a');
          renderBag(); renderDetail(null);
        };
        actEl.appendChild(b);
      } else if (item.type === 'big_gold_bag') {
        const b = document.createElement('button'); b.textContent = 'Open';
        b.onclick = () => {
          const idx = st.inv.findIndex(x => x && x.id === item.id);
          if (idx >= 0) st.inv.splice(idx, 1);
          const amt = 2000 + Math.floor(Math.random() * 8001);
          st.gold += amt; updateCurrencies();
          notify('+' + amt + ' Gold (Big Bag!)', '#ffaa00');
          renderBag(); renderDetail(null);
        };
        actEl.appendChild(b);
      } else if (item.type === 'pet_box') {
        const b = document.createElement('button'); b.textContent = 'Open';
        b.onclick = () => {
          const idx = st.inv.findIndex(x => x && x.id === item.id);
          if (idx >= 0) st.inv.splice(idx, 1);
          try {
            const speciesNames = Object.keys(window.PetData || {});
            const nameP = speciesNames[Math.floor(Math.random() * speciesNames.length)] || 'Pet';
            const dataP = window.PetData[nameP] || { baseHP: 100, baseATK: 10, baseDEF: 5 };
            const newPet3 = {
              id: Math.random(),
              name: nameP,
              type: 'gear',
              slot: 'pet',
              rank: 'C',
              level: 1,
              hp: dataP.baseHP,
              atk: dataP.baseATK,
              def: dataP.baseDEF,
              baseHP: dataP.baseHP,
              baseATK: dataP.baseATK,
              baseDEF: dataP.baseDEF,
              exp: 0,
              kills: 0
            };
            addItemToBag(newPet3);
            notify('You got a new Pet!', '#ffd56a');
          } catch (ex) { console.error(ex); }
          renderBag(); renderDetail(null);
        };
        actEl.appendChild(b);
      } else if (item.type === 'vehicle_box') {
        const b = document.createElement('button'); b.textContent = 'Open';
        b.onclick = () => {
          const idx = st.inv.findIndex(x => x && x.id === item.id);
          if (idx >= 0) st.inv.splice(idx, 1);
          try {
            const vehicles3 = [
              { name: 'HoverBike', baseHP: 200, baseATK: 8, baseDEF: 6 },
              { name: 'JetCart', baseHP: 210, baseATK: 10, baseDEF: 8 },
              { name: 'MechWalker', baseHP: 230, baseATK: 12, baseDEF: 9 },
              { name: 'DuneBuggy', baseHP: 190, baseATK: 9, baseDEF: 5 },
              { name: 'CyberCar', baseHP: 205, baseATK: 11, baseDEF: 7 }
            ];
            const pick3 = vehicles3[Math.floor(Math.random() * vehicles3.length)] || { name: 'Vehicle', baseHP: 200, baseATK: 8, baseDEF: 6 };
            const newVeh3 = {
              id: Math.random(),
              name: pick3.name,
              type: 'gear',
              slot: 'vehicle',
              rank: 'C',
              level: 1,
              hp: pick3.baseHP,
              atk: pick3.baseATK,
              def: pick3.baseDEF,
              baseHP: pick3.baseHP,
              baseATK: pick3.baseATK,
              baseDEF: pick3.baseDEF,
              exp: 0,
              kills: 0
            };
            addItemToBag(newVeh3);
            notify('You got a new Vehicle!', '#ffd56a');
          } catch (ex) { console.error(ex); }
          renderBag(); renderDetail(null);
        };
        actEl.appendChild(b);
      } else if (item.type === 'super_equipment_pack') {
        const b = document.createElement('button'); b.textContent = 'Open';
        b.onclick = () => {
          const idx = st.inv.findIndex(x => x && x.id === item.id);
          if (idx >= 0) st.inv.splice(idx, 1);
          for (let i = 0; i < 3; i++) {
            const rank = Math.random() < 0.5 ? 'B' : 'A';
            const pool = LOOT_TABLES.bossChest.filter(item => item.rank === rank);
            const item = pool[Math.floor(Math.random() * pool.length)];
            if (item) addItemToBag(JSON.parse(JSON.stringify(item)));
          }
          notify('You got new equipment!', '#ffd56a');
          renderBag(); renderDetail(null);
        };
        actEl.appendChild(b);
      } else if (item.type === 'big_box') {
        const b = document.createElement('button'); b.textContent = 'Open';
        b.onclick = () => {
          const idx = st.inv.findIndex(x => x && x.id === item.id);
          if (idx >= 0) st.inv.splice(idx, 1);
          // 3 random items
          for (let i = 0; i < 3; i++) {
            const it = rollLoot('mobChest');
            if (it) addItemToBag(it);
          }
          // 1 pet
          try {
            const speciesNames2 = Object.keys(window.PetData || {});
            const nameBP = speciesNames2[Math.floor(Math.random() * speciesNames2.length)] || 'Pet';
            const dataBP = window.PetData[nameBP] || { baseHP: 100, baseATK: 10, baseDEF: 5 };
            const newPetBox = {
              id: Math.random(),
              name: nameBP,
              type: 'gear',
              slot: 'pet',
              rank: 'C',
              level: 1,
              hp: dataBP.baseHP,
              atk: dataBP.baseATK,
              def: dataBP.baseDEF,
              baseHP: dataBP.baseHP,
              baseATK: dataBP.baseATK,
              baseDEF: dataBP.baseDEF,
              exp: 0,
              kills: 0
            };
            addItemToBag(newPetBox);
          } catch (ex) { console.error(ex); }
          // 1 vehicle
          try {
            const vehiclesB = [
              { name: 'HoverBike', baseHP: 200, baseATK: 8, baseDEF: 6 },
              { name: 'JetCart', baseHP: 210, baseATK: 10, baseDEF: 8 },
              { name: 'MechWalker', baseHP: 230, baseATK: 12, baseDEF: 9 },
              { name: 'DuneBuggy', baseHP: 190, baseATK: 9, baseDEF: 5 },
              { name: 'CyberCar', baseHP: 205, baseATK: 11, baseDEF: 7 }
            ];
            const pickB = vehiclesB[Math.floor(Math.random() * vehiclesB.length)] || { name: 'Vehicle', baseHP: 200, baseATK: 8, baseDEF: 6 };
            const newVehBox = {
              id: Math.random(),
              name: pickB.name,
              type: 'gear',
              slot: 'vehicle',
              rank: 'C',
              level: 1,
              hp: pickB.baseHP,
              atk: pickB.baseATK,
              def: pickB.baseDEF,
              baseHP: pickB.baseHP,
              baseATK: pickB.baseATK,
              baseDEF: pickB.baseDEF,
              exp: 0,
              kills: 0
            };
            addItemToBag(newVehBox);
          } catch (ex) { console.error(ex); }
          // 1 set of A-C rank gear
          const ranks = ['A', 'B', 'C'];
          const rank = ranks[Math.floor(Math.random() * ranks.length)];
          const pool = LOOT_TABLES.bossChest.filter(item => item.rank === rank);
          const gear = pool[Math.floor(Math.random() * pool.length)];
          if (gear) addItemToBag(JSON.parse(JSON.stringify(gear)));

          notify('You got a Big Box!', '#ffd56a');
          renderBag(); renderDetail(null);
        };
        actEl.appendChild(b);
      } else if (item.type === 'consumable') {
        const useBtn = document.createElement('button');
        useBtn.textContent = 'Use';
        useBtn.onclick = () => {
          // Perform the action based on the item's 'use' property
          if (item.use === 'heal_party') {
            st.players.forEach(p => {
              if (!p.isDefeated) {
                const heal = Math.round(p.hpMax * 0.4);
                p.hp = Math.min(p.hpMax, p.hp + heal);
                addFloater(p.x, p.y - 60, '+' + heal + ' HP', '#36c777');
              }
            });
            notify('Party Healed!', '#36c777');
          } else if (item.use === 'revive_hero') {
            const dead = st.players.find(p => p.isDefeated);
            if (dead) {
              revivePlayer(dead, true);
            } else {
              notify('No one to revive.', '#ff7a6a');
              return; // Don't use the item if no one is dead
            }
          }
          else if (item.use && item.use.startsWith('learn_')) {
            // Handle spell scrolls: learn new skills
            const spell = item.use.replace('learn_', '');
            if (!st.learnedSpells) st.learnedSpells = {};
            if (st.learnedSpells[spell]) {
              notify('Already learned ' + spell.charAt(0).toUpperCase() + spell.slice(1) + '!', '#6aa8ff');
            } else {
              st.learnedSpells[spell] = true;
              notify('Learned ' + spell.charAt(0).toUpperCase() + spell.slice(1) + '!', '#36c777');
            }
          }

          // Decrease quantity and remove if it's the last one
          if (item.qty == null) {
            // Non‑stackable consumable (e.g. scroll) – remove immediately
            const idx = st.inv.indexOf(item);
            if (idx >= 0) st.inv.splice(idx, 1);
            renderDetail(null);
          } else {
            item.qty--;
            if (item.qty <= 0) {
              st.inv.splice(st.inv.indexOf(item), 1);
              renderDetail(null);
            }
          }
          renderBag(); // Refresh the bag UI
        };
        actEl.appendChild(useBtn);
      } else if (item.type === 'container') {
        const openBtn = document.createElement('button');
        openBtn.textContent = 'Open';
        openBtn.onclick = () => {
          // Use the item
          switch (item.use) {
            case 'open_gold_bag': {
              const amt = 500 + Math.floor(Math.random() * 4501);
              st.gold += amt;
              updateCurrencies();
              notify('+' + amt + ' Gold', '#ffd56a');
              break;
            }
            case 'open_big_gold_bag': {
              const amt = 2000 + Math.floor(Math.random() * 8001);
              st.gold += amt;
              updateCurrencies();
              notify('+' + amt + ' Gold (Big Bag!)', '#ffaa00');
              break;
            }
            case 'open_gear_kit': {
              for (let i = 0; i < 3; i++) {
                const slot = ['weapon', 'armor', 'acc1', 'acc2'][Math.floor(Math.random() * 4)];
                addItemToBag(makeGear('Random ' + slot, slot, {
                  atk: 5 + Math.floor(Math.random() * 8)
                }));
              }
              notify('Opened Gear Kit!', '#6aa8ff');
              break;
            }
            case 'open_pet_box': {
              try {
                // Generate a random pet based on defined PetData. Assign base stats and starter rank/level.
                const speciesNames = Object.keys(window.PetData || {});
                const name = speciesNames[Math.floor(Math.random() * speciesNames.length)] || 'Pet';
                const data = window.PetData[name] || { baseHP: 100, baseATK: 10, baseDEF: 5 };
                const newPet = {
                  id: Math.random(),
                  name,
                  type: 'gear',
                  slot: 'pet',
                  rank: 'C',
                  level: 1,
                  hp: data.baseHP,
                  atk: data.baseATK,
                  def: data.baseDEF,
                  baseHP: data.baseHP,
                  baseATK: data.baseATK,
                  baseDEF: data.baseDEF,
                  exp: 0,
                  kills: 0
                };
                addItemToBag(newPet);
                notify('You got a new Pet!', '#ffd56a');
              } catch (ex) { console.error(ex); }
              break;
            }
            case 'open_vehicle_box': {
              try {
                // Generate a random vehicle from a small list. Vehicles also have rank and level similar to pets.
                const vehicles = [
                  { name: 'HoverBike', baseHP: 200, baseATK: 8, baseDEF: 6 },
                  { name: 'JetCart', baseHP: 210, baseATK: 10, baseDEF: 8 },
                  { name: 'MechWalker', baseHP: 230, baseATK: 12, baseDEF: 9 },
                  { name: 'DuneBuggy', baseHP: 190, baseATK: 9, baseDEF: 5 },
                  { name: 'CyberCar', baseHP: 205, baseATK: 11, baseDEF: 7 }
                ];
                const pick = vehicles[Math.floor(Math.random() * vehicles.length)] || { name: 'Vehicle', baseHP: 200, baseATK: 8, baseDEF: 6 };
                const newVeh = {
                  id: Math.random(),
                  name: pick.name,
                  type: 'gear',
                  slot: 'vehicle',
                  rank: 'C',
                  level: 1,
                  hp: pick.baseHP,
                  atk: pick.baseATK,
                  def: pick.baseDEF,
                  baseHP: pick.baseHP,
                  baseATK: pick.baseATK,
                  baseDEF: pick.baseDEF,
                  exp: 0,
                  kills: 0
                };
                addItemToBag(newVeh);
                notify('You got a new Vehicle!', '#ffd56a');
              } catch (ex) { console.error(ex); }
              break;
            }
            case 'open_super_equipment_pack': {
              for (let i = 0; i < 3; i++) {
                const rank = Math.random() < 0.5 ? 'B' : 'A';
                const pool = LOOT_TABLES.bossChest.filter(item => item.rank === rank);
                const loot = pool[Math.floor(Math.random() * pool.length)];
                if (loot) addItemToBag(JSON.parse(JSON.stringify(loot)));
              }
              notify('You got new equipment!', '#ffd56a');
              break;
            }
            case 'open_big_box': {
              for (let i = 0; i < 3; i++) {
                const it = rollLoot('mobChest');
                if (it) addItemToBag(it);
              }
              // Generate a random pet and vehicle with proper stats and rank/level
              try {
                const speciesNames = Object.keys(window.PetData || {});
                const nameP = speciesNames[Math.floor(Math.random() * speciesNames.length)] || 'Pet';
                const dataP = window.PetData[nameP] || { baseHP: 100, baseATK: 10, baseDEF: 5 };
                const newPet2 = {
                  id: Math.random(),
                  name: nameP,
                  type: 'gear',
                  slot: 'pet',
                  rank: 'C',
                  level: 1,
                  hp: dataP.baseHP,
                  atk: dataP.baseATK,
                  def: dataP.baseDEF,
                  baseHP: dataP.baseHP,
                  baseATK: dataP.baseATK,
                  baseDEF: dataP.baseDEF,
                  exp: 0,
                  kills: 0
                };
                addItemToBag(newPet2);
                const vehicles2 = [
                  { name: 'HoverBike', baseHP: 200, baseATK: 8, baseDEF: 6 },
                  { name: 'JetCart', baseHP: 210, baseATK: 10, baseDEF: 8 },
                  { name: 'MechWalker', baseHP: 230, baseATK: 12, baseDEF: 9 },
                  { name: 'DuneBuggy', baseHP: 190, baseATK: 9, baseDEF: 5 },
                  { name: 'CyberCar', baseHP: 205, baseATK: 11, baseDEF: 7 }
                ];
                const pick2 = vehicles2[Math.floor(Math.random() * vehicles2.length)] || { name: 'Vehicle', baseHP: 200, baseATK: 8, baseDEF: 6 };
                const newVeh2 = {
                  id: Math.random(),
                  name: pick2.name,
                  type: 'gear',
                  slot: 'vehicle',
                  rank: 'C',
                  level: 1,
                  hp: pick2.baseHP,
                  atk: pick2.baseATK,
                  def: pick2.baseDEF,
                  baseHP: pick2.baseHP,
                  baseATK: pick2.baseATK,
                  baseDEF: pick2.baseDEF,
                  exp: 0,
                  kills: 0
                };
                addItemToBag(newVeh2);
              } catch (ex) { console.error(ex); }
              const ranks = ['A', 'B', 'C'];
              const rank = ranks[Math.floor(Math.random() * ranks.length)];
              const pool = LOOT_TABLES.bossChest.filter(item => item.rank === rank);
              const gear = pool[Math.floor(Math.random() * pool.length)];
              if (gear) addItemToBag(JSON.parse(JSON.stringify(gear)));
              notify('You got a Big Box!', '#ffd56a');
              break;
            }
          }

          // Decrease quantity and remove if it's the last one
          item.qty--;
          if (item.qty <= 0) {
            st.inv.splice(st.inv.indexOf(item), 1);
            renderDetail(null); // Clear the detail pane
          }
          renderBag(); // Refresh the bag UI
        };
        actEl.appendChild(openBtn);
      } else {
        const b = document.createElement('button'); b.textContent = 'Close';
        b.onclick = () => renderDetail(null);
        actEl.appendChild(b);
      }
    }
    function calcUpgradeCost(item) {
      return 100 * (item.level + 1);
    }

    /* =================== Talents: Lane System =================== */
    st.talentLanes = {
      atk: [
        { id: 'atk_1', cost: 1, text: '+5% ATK', fx: s => s.atkMul += 0.05 },
        { id: 'atk_2', cost: 2, req: ['atk_1'], text: '+8% ATK', fx: s => s.atkMul += 0.08 },
        { id: 'atk_3', cost: 3, req: ['atk_2'], text: '+12% ATK', fx: s => s.atkMul += 0.12 },
        { id: 'atk_4', cost: 4, req: ['atk_3'], text: '+15% ATK + Crit Chance', fx: s => { s.atkMul += 0.15; s.crit = (s.crit || 0) + 0.10; } },
        { id: 'atk_5', cost: 5, req: ['atk_4'], text: 'Berserker: ATK scales with missing HP', fx: s => { s.berserker = true; } },
        { id: 'atk_ultimate', cost: 8, req: ['atk_5'], text: 'APEX HUNTER: +50% ATK, kills grant rage', fx: s => { s.atkMul += 0.50; s.killRage = true; } }
      ],
      def: [
        { id: 'def_1', cost: 1, text: '+80 HP', fx: s => { s.hpFlat = (s.hpFlat || 0) + 80; } },
        { id: 'def_2', cost: 2, req: ['def_1'], text: '+120 HP', fx: s => { s.hpFlat = (s.hpFlat || 0) + 120; } },
        { id: 'def_3', cost: 3, req: ['def_2'], text: '+160 HP', fx: s => { s.hpFlat = (s.hpFlat || 0) + 160; } },
        { id: 'def_4', cost: 4, req: ['def_3'], text: '+200 HP + 10% Damage Reduction', fx: s => { s.hpFlat = (s.hpFlat || 0) + 200; s.damageReduction = (s.damageReduction || 0) + 0.10; } },
        { id: 'def_5', cost: 5, req: ['def_4'], text: 'Guardian: Nearby allies take 20% less damage', fx: s => { s.guardian = true; } },
        { id: 'def_ultimate', cost: 8, req: ['def_5'], text: 'FORTRESS: Team immunity when at low HP', fx: s => { s.fortress = true; } }
      ],
      recovery: [
        { id: 'rec_1', cost: 1, text: '+6% Lifesteal', fx: s => { s.ls = (s.ls || 0) + 0.06; } },
        { id: 'rec_2', cost: 2, req: ['rec_1'], text: '+10% Lifesteal', fx: s => { s.ls = (s.ls || 0) + 0.10; } },
        { id: 'rec_3', cost: 3, req: ['rec_2'], text: '+15% Lifesteal + HP Regen', fx: s => { s.ls = (s.ls || 0) + 0.15; s.regen = (s.regen || 0) + 2; } },
        { id: 'rec_4', cost: 4, req: ['rec_3'], text: 'Vampiric: Killing blows fully heal', fx: s => { s.vampiric = true; } },
        { id: 'rec_ultimate', cost: 7, req: ['rec_4'], text: 'PHOENIX: Auto-revive on death (once per stage)', fx: s => { s.phoenix = true; } }
      ],
      cooldown: [
        { id: 'cd_1', cost: 1, text: '-8% Skill CD', fx: s => { s.haste = (s.haste || 0) + 8; } },
        { id: 'cd_2', cost: 2, req: ['cd_1'], text: '-12% Skill CD', fx: s => { s.haste = (s.haste || 0) + 12; } },
        { id: 'cd_3', cost: 3, req: ['cd_2'], text: '-15% Skill CD + Movement Speed', fx: s => { s.haste = (s.haste || 0) + 15; s.moveSpeed = (s.moveSpeed || 0) + 0.20; } },
        { id: 'cd_4', cost: 4, req: ['cd_3'], text: 'Cascade: Skills have 25% chance to reset CD', fx: s => { s.cascade = true; } },
        { id: 'cd_ultimate', cost: 7, req: ['cd_4'], text: 'TIME MASTER: All abilities cost 50% less CD', fx: s => { s.timeMaster = true; } }
      ],
      luck: [
        { id: 'luck_1', cost: 1, text: '+8 Luck', fx: s => { s.luck = (s.luck || 0) + 8; } },
        { id: 'luck_2', cost: 2, req: ['luck_1'], text: '+15 Luck', fx: s => { s.luck = (s.luck || 0) + 15; } },
        { id: 'luck_3', cost: 3, req: ['luck_2'], text: '+25 Luck + Gold Find', fx: s => { s.luck = (s.luck || 0) + 25; s.goldFind = (s.goldFind || 0) + 0.30; } },
        { id: 'luck_4', cost: 4, req: ['luck_3'], text: 'Fortune: 10% chance for double loot', fx: s => { s.fortune = true; } },
        { id: 'luck_5', cost: 5, req: ['luck_4'], text: 'Jackpot: Rare items can upgrade quality', fx: s => { s.jackpot = true; } },
        { id: 'luck_ultimate', cost: 8, req: ['luck_5'], text: 'GOLDEN TOUCH: Everything drops gold, permanent luck aura', fx: s => { s.goldenTouch = true; } }
      ]
    };
    function canBuyTalent(node) {
      if (st.apSpent >= st.apTotal) return false;
      if (st.talentPicks.has(node.id)) return false;
      if (node.req && !node.req.every(r => st.talentPicks.has(r))) return false;
      return true;
    }
    function buyTalent(node) {
      if (!canBuyTalent(node)) return;
      st.talentPicks.add(node.id);
      st.apSpent += node.cost || 1;
      tallyTalentStats();
      renderTalentLanes();
    }
    function tallyTalentStats() {
      const stats = { atkMul: 0 };
      st.luck = 0;
      for (const lane of Object.values(st.talentLanes)) {
        for (const n of lane) {
          if (st.talentPicks.has(n.id) && n.fx) n.fx(stats);
        }
      }
      st._talentStats = stats;
      if (stats.hpFlat) {
        for (const p of st.players) {
          const r = p.hp / p.hpMax;
          p.hpMax = 100 + stats.hpFlat;
          p.hp = Math.round(p.hpMax * r);
        }
      }
      if (stats.luck) st.luck = stats.luck;
      recalcStats();
      updateTalentSummary();
    }
    function renderTalentLanes() {
      const wrap = document.getElementById('talentLaneWrap'); if (!wrap) return;
      wrap.innerHTML = '';
      for (const [laneName, nodes] of Object.entries(st.talentLanes)) {
        const col = document.createElement('div');
        col.className = 'lane-col';
        col.innerHTML = `<h4>${laneName.toUpperCase()}</h4>`;
        nodes.forEach(node => {
          const owned = st.talentPicks.has(node.id);
          const can = canBuyTalent(node);
          const div = document.createElement('div');
          div.className = 'lane-node';
          if (owned) div.classList.add('owned');
          else if (!can) div.classList.add('locked');
          div.innerHTML = `<span>${node.text}</span><span class="cost">AP ${node.cost || 1}</span>${node.req ? ('<small>Requires ' + node.req.join(', ') + '</small>') : ''}`;
          const btn = document.createElement('button');
          btn.textContent = owned ? 'Owned' : 'Buy';
          btn.disabled = !can || owned;
          btn.onclick = () => buyTalent(node);
          div.appendChild(btn);
          col.appendChild(div);
        });
        wrap.appendChild(col);
      }
      updateTalentSummary();
    }
    function updateTalentSummary() {
      const el = document.getElementById('talentSummary');
      if (!el) return;
      el.textContent = `AP: ${st.apSpent}/${st.apTotal}\nLuck: ${st.luck}\nATK Mult: ${(1 + (st._talentStats.atkMul || 0)).toFixed(2)}x`;
    }

    /* =================== Stats Recalculation =================== */
    function recalcStats() {
      // Unified Skills system removed - using Simplified Skills only
      // Initialize default multipliers
      for (const p of st.players) {
        if (!p._usAtkMul) p._usAtkMul = 1;
        if (!p._usSpeedMul) p._usSpeedMul = 1;
      }
      if (!st._usCdr) st._usCdr = {};
      if (!st._usLuck) st._usLuck = 0;
      const crystalState = window.EQUIPPED_CORE === 'crystal' ? ensureCrystalState() : null;
      for (const p of st.players) {
        if (!p._beastHowlMul) p._beastHowlMul = 1;
        if (!p._beastHowlSpeedMul) p._beastHowlSpeedMul = 1;
        const coreMul = (p._coreAtkMul || 1) * (p._beastHowlMul || 1);
        const atkMul = (1 + (st._talentStats.atkMul || 0)) * (p._atkMul || 1) * (p._usAtkMul || 1) * coreMul;
        const npcEff = st.npcSkillEffects || {};
        const npcAtkMul = npcEff.atkMul || 1;
        const npcCombatMul = npcEff.combatAtkMul || 1;
        const gearMul = npcEff.gearMul || 1;
        let gearAtk = 0;
        for (const slot of Object.values(st.equippedGear)) {
          if (slot && slot.atk) gearAtk += slot.atk;
        }
        gearAtk *= gearMul;
        const totalBase = (p.dmgBase * npcAtkMul) + gearAtk;
        p.dmg = Math.round(totalBase * atkMul * npcCombatMul);
        p._coreDamageTakenMul = crystalState ? (Number(crystalState.damageReduction) || 0.88) : 1;
      }
    }

    /* ================= Experience / Level ================= */
    function xpToNext(lv) { return Math.round(50 + 25 * lv + 5 * lv * lv); }
    function grantXP(n) {
      const eff = st.npcSkillEffects || {};
      const bonus = 1 + (eff.xpBonus || 0);
      st.xp += Math.round(n * bonus);
      while (st.xp >= xpToNext(st.level)) {
        st.xp -= xpToNext(st.level);
        st.level++;
        st.apTotal = Math.min(200, st.apTotal + 2);
      }
    }

    /* =================== A1 Combat Kit v5 =================== */
    const A1_COMBO_WINDOW = 750;
    function a1_basicAttack(a) {
      const now = performance.now();
      if (!a.a1ComboIdx) a.a1ComboIdx = 0;
      if (!a.a1ComboTimer) a.a1ComboTimer = 0;
      if (now > a.a1ComboTimer) a.a1ComboIdx = 0; // chain reset
      a.a1ComboIdx = (a.a1ComboIdx % 5) + 1;
      a.a1ComboTimer = now + A1_COMBO_WINDOW;

      // Damage profile 5 hits: 100-220 damage range
      const baseDmg = 100 + (120 * ((a.a1ComboIdx - 1) / 4)); // scales from 100 to 220
      const finalDamage = Math.round(baseDmg + (a.dmg * 0.2)); // slight bonus from character dmg

      // Set sword timer for dual sword visual
      a._swordT = 300;

      // ENHANCED: 60% increased sword range and length with motion trails
      const reaches = [58, 64, 70, 77, 90]; // 60% increased from [36, 40, 44, 48, 56]
      const heights = [67, 72, 77, 83, 96]; // 60% increased from [42, 45, 48, 52, 60]
      performMelee(a, reaches[a.a1ComboIdx - 1], heights[a.a1ComboIdx - 1], finalDamage, a.a1ComboIdx === 5);
      melee(a, reaches[a.a1ComboIdx - 1], heights[a.a1ComboIdx - 1], 0); // A1K hook

      // ENHANCED: Motion trail VFX for DUAL RED/BLACK swords
      const colors = ['#ff4d4f', '#ff3333', '#cc0000', '#990000', '#660000']; // Red to dark red
      const arcIntensity = ['after', 'cast', 'impact', 'cast', 'impact'];

      // Motion trail effect
      for (let t = 0; t < 3; t++) {
        setTimeout(() => {
          addAfterImage(a.x + 10 + (t * 15), a.y - 10 - (t * 5), colors[a.a1ComboIdx - 1]);
          st.effects.push({
            kind: 'beam',
            x1: a.x + 10 + (t * 20),
            y1: a.y - 20,
            x2: a.x + 30 + reaches[a.a1ComboIdx - 1] - (t * 10),
            y2: a.y - 40 + (t * 5),
            color: colors[a.a1ComboIdx - 1],
            life: 200 + (a.a1ComboIdx * 30),
            max: 200 + (a.a1ComboIdx * 30),
            thick: 4 + a.a1ComboIdx
          });
        }, t * 50);
      }

      st.effects.push({
        kind: arcIntensity[a.a1ComboIdx - 1],
        x: a.x + 30,
        y: a.y - 30,
        color: colors[a.a1ComboIdx - 1],
        life: 400 + (a.a1ComboIdx * 60),
        max: 400 + (a.a1ComboIdx * 60)
      });

      // ENHANCED: Bullet deflection system with 7x larger reflected bullets
      const deflectCount = 1 + a.a1ComboIdx; // 2-6 bullets per hit
      let deflected = 0;
      for (let i = st.eShots.length - 1; i >= 0 && deflected < deflectCount; i--) {
        const shot = st.eShots[i];
        if (shot && Math.abs(shot.x - a.x) < 90 && Math.abs(shot.y - a.y) < 70) {
          // Remove original bullet
          st.eShots.splice(i, 1);

          // Create 7x larger reflected bullet with invulnerability frames
          st.shots.push({
            x: shot.x,
            y: shot.y,
            vx: -shot.vx * 1.5,
            vy: -shot.vy * 1.5,
            dmg: Math.round(finalDamage * 0.7),
            life: 3000,
            w: 35, // 7x larger
            h: 35,
            color: '#ffdd44',
            pierce: 3,
            ownerId: a.id,
            kind: 'reflected_bullet'
          });

          addImpact(shot.x, shot.y, '#ffdd44');
          // Short invulnerability on parry
          a._parryInvulnT = Math.max(a._parryInvulnT || 0, 300);
          deflected++;
        }
      }

      // Parry window: final strike longer
      st.parryT = Math.max(st.parryT, a.a1ComboIdx === 5 ? 900 : 550);

      // Finisher: Pure melee extended damage area with enhanced VFX
      if (a.a1ComboIdx === 5) {
        // Extended forward cleave with 60% increased range
        performMelee(a, 128, 128, Math.round(finalDamage * 1.5), true); // 80 * 1.6 = 128
        melee(a, 128, 128, 0); // A1K hook
        addImpact(a.x + 60, a.y - 20, '#4d79ff');
        addImpact(a.x + 90, a.y - 40, '#4d79ff');
        addImpact(a.x + 120, a.y - 30, '#4d79ff');

        // Enhanced finisher trail
        st.effects.push({
          kind: 'beam',
          x1: a.x,
          y1: a.y - 20,
          x2: a.x + 128,
          y2: a.y - 40,
          color: '#4d79ff',
          life: 600,
          max: 600,
          thick: 8
        });
      }

    }

    function missy_basicAttack(a) {
      if (!a || a.isDefeated) return;

      // ENHANCED: Twin purple sword slashes (SMALLER size)
      const missyColors = ['#b389ff', '#d4b3ff', '#c9a6ff', '#e8d4ff'];

      for (let swing = 0; swing < 2; swing++) {
        const delay = swing * 90;
        setTimeout(() => {
          if (a.isDefeated) return;

          // Set sword timer for rendering
          a._swordT = 280;

          // Smaller melee range for Missy (compact sword)
          const reach = 35;
          const height = 42;
          performMelee(a, reach, height, Math.round(a.dmg * 0.65), false);
          melee(a, reach, height, 0);

          // ENHANCED: Visible sword arc trail (PURPLE)
          const dir = a.facingLeft ? -1 : 1;
          const swingArc = swing % 2 === 0 ? 1 : -1; // Alternate high/low slashes

          // Create afterimages for motion trail (fewer, smaller)
          for (let t = 0; t < 3; t++) {
            setTimeout(() => {
              addAfterImage(
                a.x + dir * (6 + t * 8),
                a.y - 18 + (swingArc * t * 2),
                missyColors[t % missyColors.length]
              );
            }, t * 25);
          }

          // Sword beam effect - visible arc (SMALLER, PURPLE)
          st.effects.push({
            kind: 'beam',
            x1: a.x + dir * 10,
            y1: a.y - 14 - (swingArc * 6),
            x2: a.x + dir * (reach + 5),
            y2: a.y - 22 + (swingArc * 8),
            color: missyColors[swing],
            life: 250,
            max: 250,
            thick: 3
          });

          // Sword slash effect - crescent arc (SMALLER, PURPLE)
          st.effects.push({
            kind: 'slash_arc',
            x: a.x + dir * 18,
            y: a.y - 20,
            angle: swingArc * (Math.PI / 6),
            radius: reach,
            color: missyColors[swing],
            life: 280,
            max: 280,
            direction: dir
          });

          // MISSY SWORD PARRY: Deflect enemy bullets
          for (let i = st.eShots.length - 1; i >= 0; i--) {
            const shot = st.eShots[i];
            if (shot && Math.abs(shot.x - a.x) < reach && Math.abs(shot.y - a.y) < 30) {
              // Remove original bullet
              st.eShots.splice(i, 1);

              // Create deflected purple bullet
              st.shots.push({
                x: shot.x,
                y: shot.y,
                vx: -shot.vx * 1.2,
                vy: -shot.vy * 1.2,
                dmg: Math.round(a.dmg * 0.4),
                life: 2000,
                w: 16,
                h: 16,
                color: '#b389ff',
                pierce: 2,
                ownerId: a.id,
                kind: 'parried_bullet'
              });

              // Parry effect
              st.effects.push({
                kind: 'cast',
                x: shot.x,
                y: shot.y,
                color: '#e8d4ff',
                life: 150,
                max: 150
              });
            }
          }

          // Impact sparkles at sword tip (PURPLE)
          st.effects.push({
            kind: 'cast',
            x: a.x + dir * reach,
            y: a.y - 24,
            color: '#e8d4ff',
            life: 180,
            max: 180
          });

        }, delay);
      }

      // Gun shots: 2 purple-tinted shots after sword swings
      setTimeout(() => {
        if (a.isDefeated) return;
        for (let i = 0; i < 2; i++) {
          setTimeout(() => {
            if (a.isDefeated) return;
            const speed = 560;
            st.shots.push({
              x: a.x + 22,
              y: a.y - 28,
              vx: speed,
              vy: (Math.random() - 0.5) * 90,
              speed,
              dmg: Math.round(a.dmg * 0.55),
              life: 2200,
              pierce: 1,
              roaming: true,
              neverMiss: true,
              ownerId: a.id,
              color: '#c9a6ff'  // Purple gun shots
            });
            addAfterImage(a.x, a.y, '#d4b3ff');
          }, i * 70);
        }
      }, 180);
    }

    function unique_basicAttack(a) {
      if (!a || a.isDefeated) return;

      // Set gun timer for heavy purple gun visual
      a._swordT = 280;

      // HEAVY PURPLE GUN: 2 powerful bursts
      const bursts = 2;
      for (let i = 0; i < bursts; i++) {
        setTimeout(() => {
          if (a.isDefeated) return;

          // Muzzle flash effect
          addAfterImage(a.x + 24, a.y - 28, '#d4b3ff');
          st.effects.push({
            kind: 'cast',
            x: a.x + 40,
            y: a.y - 28,
            color: '#e8d4ff',
            life: 200,
            max: 200
          });

          const speed = 640;
          // Heavy purple gun shot with larger bullets
          st.shots.push({
            x: a.x + 18,
            y: a.y - 42 + i * 10,
            vx: speed,
            vy: (Math.random() - 0.5) * 30,
            speed,
            dmg: Math.round(a.dmg * 1.15),
            life: 2600,
            pierce: 4,
            w: 32,  // Larger bullets for heavy gun
            h: 22,
            ownerId: a.id,
            color: '#9b59ff',  // Purple gun shots
            highPierce: true
          });
        }, i * 120);
      }
    }

    function ensureFollowerCoordinator() {
      if (!st._followerCoordinator) {
        st._followerCoordinator = {
          queues: {},
          cooldowns: {},
          stamp: 0
        };
      }
      return st._followerCoordinator;
    }

    function followerListOrdered() {
      const L = leader();
      if (!L) return [];
      const leaderIdx = st.players.indexOf(L);
      return st.players
        .map((p, idx) => ({ p, idx }))
        .filter(({ p, idx }) => idx !== leaderIdx && p && !p.isDefeated)
        .sort((a, b) => a.idx - b.idx);
    }

    function scheduleFollowerActions(eventType, payload = {}) {
      const coord = ensureFollowerCoordinator();
      coord.stamp += 1;
      const stamp = coord.stamp;
      const ordered = followerListOrdered();
      ordered.forEach(({ p }, slotIdx) => {
        if (!p) return;
        if (payload.heroId && payload.heroId !== p.id) return;
        const key = p.id || slotIdx;
        coord.cooldowns[key] = coord.cooldowns[key] || {};
        if (coord.cooldowns[key][eventType] === stamp) return;
        coord.cooldowns[key][eventType] = stamp;
        const actions = buildFollowerPriority(eventType, p, slotIdx, payload);
        if (!actions || !actions.length) return;
        const q = coord.queues[key] = coord.queues[key] || [];
        actions.forEach(action => {
          if (!q.some(existing => existing.kind === action.kind && existing.eventStamp === stamp)) {
            q.push({ ...action, eventStamp: stamp, queuedAt: performance.now?.() || Date.now() });
          }
        });
      });
    }

    function buildFollowerPriority(eventType, follower, slotIdx, payload) {
      const hero = (follower.id || '').toUpperCase();
      const defaultSkillMaps = {
        attack: [
          { UNIQUE: ['S1', 'S3'], MISSY: ['S3', 'S1'] },
          { UNIQUE: ['S2', 'S1'], MISSY: ['S2', 'S3'] }
        ],
        skill: [
          { UNIQUE: ['S2', 'S1'], MISSY: ['S2', 'S1'] },
          { UNIQUE: ['S1', 'S3'], MISSY: ['S1', 'S3'] }
        ]
      };
      const mapSet = defaultSkillMaps[eventType] || [];
      const skillMap = mapSet[Math.min(slotIdx, mapSet.length - 1)] || {};
      const keys = skillMap[hero] || [];
      if (eventType === 'attack') {
        return [
          keys.length ? { kind: 'skill', keys } : null,
          { kind: 'basic' },
          { kind: 'loot' }
        ].filter(Boolean);
      }
      if (eventType === 'skill') {
        return [
          keys.length ? { kind: 'skill', keys } : null,
          { kind: 'basic' },
          { kind: 'loot' }
        ].filter(Boolean);
      }
      if (eventType === 'jump') {
        return [{ kind: 'jump', power: payload.power || 1 }];
      }
      return [];
    }

    function runFollowerAction(follower, action, dtMs) {
      if (!follower || follower.isDefeated || !action) return 'skip';
      switch (action.kind) {
        case 'skill':
          return performFollowerSkill(follower, action) ? 'consumed' : 'skip';
        case 'basic':
          return performFollowerBasic(follower) ? 'consumed' : 'skip';
        case 'loot':
          return performFollowerLootSweep(follower) ? 'consumed' : 'skip';
        case 'jump':
          return performFollowerJump(follower, action.power) ? 'consumed' : 'skip';
        default:
          return 'skip';
      }
    }

    function followerSkillInvoker(follower) {
      const hero = (follower.id || '').toUpperCase();
      if (hero === 'MISSY') return missy_useSkill;
      if (hero === 'UNIQUE') return unique_useSkill;
      return (actor, key) => {
        try { useSkillWrapper(actor, key); } catch (_e) { }
      };
    }

    function performFollowerSkill(follower, action) {
      const keys = Array.isArray(action.keys) ? action.keys : [];
      if (!keys.length) return false;
      const callSkill = followerSkillInvoker(follower);
      const cdFn = typeof cdReady === 'function' ? cdReady : null;
      for (const key of keys) {
        if (cdFn && !follower.rageOn && !cdFn(follower.id, key)) continue;
        const before = cdFn ? cdFn(follower.id, key) : false;
        const beforeShots = st.shots ? st.shots.length : 0;
        callSkill(follower, key);
        if (!cdFn) return true;
        const after = cdFn(follower.id, key);
        const shotDiff = (st.shots ? st.shots.length : 0) > beforeShots;
        if ((before && !after) || shotDiff || follower.lastSkill?.key === key) {
          return true;
        }
      }
      return false;
    }

    function performFollowerBasic(follower) {
      if (follower._basicCD && follower._basicCD > 0) return false;
      const hero = (follower.id || '').toUpperCase();
      if (hero === 'MISSY') {
        missy_basicAttack(follower);
        follower._basicCD = 420;
      } else if (hero === 'UNIQUE') {
        unique_basicAttack(follower);
        follower._basicCD = 2000;
      } else if (hero === 'A1') {
        a1_basicAttack(follower);
        follower._basicCD = 260;
      } else {
        basicAttackAction(follower);
        follower._basicCD = 420;
      }
      return true;
    }

    function performFollowerLootSweep(follower) {
      const now = performance.now?.() || Date.now();
      if (follower._lootSweepStamp && now - follower._lootSweepStamp < 600) return false;
      follower._lootSweepStamp = now;
      let acted = false;
      try {
        if (window.PP && typeof window.PP.autoloot === 'function') {
          window.PP.autoloot(follower);
          acted = true;
        }
      } catch (_e) { }
      if (!acted && Array.isArray(st.pickups)) {
        for (const it of st.pickups) {
          const dx = follower.x - it.x;
          const dy = follower.y - it.y;
          const dist = Math.hypot(dx, dy);
          if (dist > 1) {
            const pull = Math.min(240, 12000 / Math.max(60, dist));
            it.x += (dx / dist) * pull;
            it.y += (dy / dist) * pull;
          }
        }
        acted = true;
      }
      if (acted) {
        follower._aiState = 'lootSweep';
        follower._aiTimer = 0;
      }
      return acted;
    }

    function performFollowerJump(follower, power = 1) {
      if (!follower.grounded || follower._jumpLock) return false;
      const baseVy = -0.22;
      follower.vy = baseVy * Math.max(0.6, power);
      follower.grounded = false;
      follower._jumpLock = 180;
      follower._aiState = 'jump';
      follower._aiTimer = 0;
      return true;
    }

    function tickFollowerLocks(dtMs) {
      if (!st._followerCoordinator) return;
      for (const p of st.players) {
        if (p && p._jumpLock) {
          p._jumpLock = Math.max(0, p._jumpLock - dtMs);
        }
      }
    }
    window.scheduleFollowerActions = scheduleFollowerActions;

    // =================== CONFIG (ported from demo) ===================
    window.HERO_CFG = window.HERO_CFG || {
      A1: {
        bleed: { dps: 10, dur: 3000 }, xwave: { pierce: 6, speed: 420, life: 1600, homing: 0.06, r: 16, mult: 0.85 },
        s1: { waves_min: 2, waves_max: 6 }, s2: { armor_shred_ms: 3000 }, s3: { waves_min: 2, waves_max: 8 },
        s4: { big_waves: 6, mult: 1.2 }, s5: { lanes: 7 }, x1: { cleaves: 4, fissure_dps_mult: 0.3, fissure_ms: 5000 }
      },
      Unique: {
        atkBase: 20, shards: { count: 7, mult: 0.35, freeze_ms: 800 },
        drone: { max: 4, shot_ms: 600, mult: 0.45, start_hp: 20, levelCap: 50, upgPct: 0.05 },
        turret: { life_ms: 6000, shot_ms: 280, mult: 0.55 }, s2field: { life_ms: 6000, heal_per_sec: 10, team_dr: 0.20, team_as: 0.15 },
        overcharge: { life_ms: 3000, elite_tick: 0.09, micro_ms: 400, micro_mult: 0.25 },
        beam: { dur_min: 500, dur_max: 2500, dps_scale_min: 1.0, dps_scale_max: 5.0, life_min: 2000, life_max: 4000 },
        singularity: { life_ms: 6000, radius: 160, chip_per_sec_mult: 0.20 }, lattice: { life_ms: 7000, shot_ms: 110, mult: 0.40 },
        lootVac: { radius: 200 }
      },
      Missy: {
        gcdMs: 220,
        S1: {
          cdMs: 3500, chestVacuumRadius: 1400, pickupRadius: 120, teamRageGain: 20, stockGain: 1, stockCap: 4,
          bigChestLifeMs: 18000, spawnYOffset: -8, chargeMsMin: 250, chargeMsMax: 1500
        },
        S2: { cdMs: 6000, healPctMaxHp: 0.22, shieldMs: 1500, fallMs: 3000, freeBuyQty: 1 },
        S3: {
          cdMs: 8000, absorbRadius: 1600, blastRadiusBase: 220, blastRadiusMax: 520,
          dmgPerGold: 1.5, dmgPerGem: 12, dmgPerChest: 100, chargeMsMin: 250, chargeMsMax: 2500
        },
        S4: {
          cdMs: 12000, rainCountMin: 10, rainCountMax: 14, fallSpeed: 6,
          dmgPerChest: 140, dmgPerBag: 100, dmgPerGift: 160,
          teamFlatDRMin: 1, teamFlatDRMax: 5, rainDurMs: 3200
        },
        S5: { cdMs: 14000, megaVacuumRadius: 2000, rageRefund: 30, allowStageSkipIfNoBoss: true },
        X1: {
          cdMs: 24000, healPct: 0.85, invulnMs: 2000, giftRainCount: 10,
          lootHaloMult: 0.5, lootHaloDurMs: 8000, chargeMsMin: 250, chargeMsMax: 2500
        },
        bigChest: { baseHp: 600, dropFn: (chest) => { for (let i = 0; i < 25; i++) spawnDrop(chest.x, chest.y); } }
      },
      Gauges: { rage: { per_hit: 4, per_kill: 18, duration_ms: 8000, exhaustion_ms: 3000 }, secret: { per_hit: 2, per_kill: 12, hp_drain_ratio_per_sec: 0.03 } }
    };
    const CFG = window.HERO_CFG;
    // Feature flags for safe, togglable rollouts
    // Initialize feature flags.  Set autoPlus to false so auto AI respects the st.auto toggle.
    CFG.flags = CFG.flags || {
      uniqueS2: true,
      a1S3: true,
      uniqueBeam: true,
      missyS5: true,
      chargeFx: true,
      homingPlus: true,
      autoPlus: false,
      dragoonSwap: true
    };
    // Temporary compatibility for legacy Missy skill code paths
    if (CFG && CFG.Missy) {
      CFG.Missy.s1 = CFG.Missy.s1 || { count_min: 3, count_max: 6, mult: 0.35 };
      CFG.Missy.ward = CFG.Missy.ward || { life_ms: 2500, heal_ratio: 0.20 };
    }

    // Missy runtime state (stock + hold tracking)
    window._MissyRT = window._MissyRT || { stock: 0, holdStart: 0, holdKey: null };

    // Charge FX for hold skills
    function addChargeFx(owner, maxMs, color) { st.effects.push({ kind: 'charge', owner, t: 0, max: maxMs, color, life: maxMs + 200 }); }
    function clearChargeFx(owner) { for (const ef of st.effects) { if (ef.kind === 'charge' && ef.owner === owner) { ef.life = 0; } } }

    // Element tagging + palette helpers for projectiles and skills
    const PROJECTILE_ELEMENT_HINTS = {
      a1_xwave: ['water'],
      a1_energy_burst: ['fire'],
      a1_mega_explosion: ['fire'],
      a1_void_impale: ['shadow'],
      astral_sever_h: ['arcane'],
      astral_sever_v: ['arcane'],
      wave: ['water'],
      reflected_bullet: ['lightning'],
    };

    const DEFAULT_PROJECTILE_PALETTE = {
      primary: '#9ad1ff',
      secondary: '#ffb18b',
      accent: '#ffd56a',
      glow: '#cfe3ff',
      particles: ['#9ad1ff', '#cfe3ff', '#ffffff'],
      effects: { trail: 'glow', impact: 'burst', glow: 'soft' },
    };

    const STATUS_TAGS = new Set(['bleed', 'paralyze', 'freeze', 'gravity', 'pushback']);
    const STATUS_DEFAULTS = {
      bleed: { duration: CFG?.A1?.bleed?.dur ?? 3000, dps: CFG?.A1?.bleed?.dps ?? 10, tickMs: 400, maxStacks: 5 },
      paralyze: { duration: 900, speedMult: 0.25, stunMs: 150, maxStacks: 3 },
      freeze: { duration: 800, speedMult: 0.35, maxStacks: 2 },
      gravity: { duration: 1200, force: 0.0018, maxStacks: 6 },
      pushback: { duration: 220, power: 160, maxStacks: 4 },
    };

    const SKILL_ELEMENT_HINTS = {
      A1: { S1: 'water', S2: 'fire', S3: 'water', S4: 'arcane', S5: 'fire', X1: 'fire' },
      Unique: { S1: 'ice', S2: 'lightning', S3: 'lightning', S4: 'arcane', S5: 'gravity', X1: 'arcane' },
      Missy: { S1: 'wind', S2: 'light', S3: 'light', S4: 'shadow', S5: 'light', X1: 'light' },
      clone: { S1: 'water', S3: 'fire', S5: 'fire' }
    };

    function getSkillElement(actor, key, fallback = 'fire') {
      if (!actor || !key) return fallback;
      const id = String(actor.id || actor).toUpperCase();
      const map = SKILL_ELEMENT_HINTS[id] || SKILL_ELEMENT_HINTS[id.toLowerCase()];
      const hint = map?.[key];
      if (hint) {
        if (hint === 'ice') return 'water';
        if (hint === 'gravity') return 'shadow';
        return hint;
      }
      return fallback;
    }

    function toArray(value) {
      if (value == null) return [];
      return Array.isArray(value) ? value : [value];
    }

    function gatherProjectileTags(shot) {
      const result = new Set();
      if (shot) {
        toArray(shot.tags).forEach(tag => { if (tag) result.add(tag); });
        if (shot.element) result.add(shot.element);
        const hints = PROJECTILE_ELEMENT_HINTS[shot.kind];
        if (Array.isArray(hints)) { hints.forEach(tag => { if (tag) result.add(tag); }); }
        if (shot.freeze) result.add('water');
        if (shot.burn || shot.armorShred) result.add('fire');
        if (shot.shock || shot.electric || /lightning|shock|volt|spark/i.test(String(shot.kind || ''))) {
          result.add('lightning');
        }
      }
      return Array.from(result);
    }

    function getPaletteFromTags(tags = []) {
      const paletteSrc = (window.ColorLogicPalette && window.ColorLogicPalette.getPaletteForTags)
        ? window.ColorLogicPalette.getPaletteForTags(tags)
        : DEFAULT_PROJECTILE_PALETTE;
      const palette = paletteSrc || DEFAULT_PROJECTILE_PALETTE;
      return {
        primary: palette.primary || DEFAULT_PROJECTILE_PALETTE.primary,
        secondary: palette.secondary || DEFAULT_PROJECTILE_PALETTE.secondary,
        accent: palette.accent || DEFAULT_PROJECTILE_PALETTE.accent,
        glow: palette.glow || DEFAULT_PROJECTILE_PALETTE.glow,
        particles: Array.isArray(palette.particles) && palette.particles.length
          ? palette.particles.slice()
          : DEFAULT_PROJECTILE_PALETTE.particles.slice(),
        effects: palette.effects || DEFAULT_PROJECTILE_PALETTE.effects,
      };
    }

    function resolveProjectilePalette(shot) {
      if (!shot) return getPaletteFromTags();
      const tags = gatherProjectileTags(shot);
      if (tags.length) {
        shot.tags = [...new Set([...toArray(shot.tags), ...tags])];
        if (!shot.element) shot.element = tags[0];
      }
      const palette = getPaletteFromTags(tags);
      shot.palette = palette;
      if (!shot.color && palette.primary) {
        shot.color = palette.primary;
      }
      if (!shot.particleColors) {
        shot.particleColors = palette.particles.slice();
      }
      return palette;
    }

    function annotateProjectile(shot, extraTags = []) {
      if (!shot) return shot;
      const combined = new Set();
      toArray(shot.tags).forEach(tag => { if (tag) combined.add(tag); });
      toArray(extraTags).forEach(tag => { if (tag) combined.add(tag); });
      shot.tags = Array.from(combined);
      // Clear cached palette so it picks up new tags
      delete shot.palette;
      resolveProjectilePalette(shot);
      return shot;
    }

    function extractStatusDataFromProjectile(shot, statusId) {
      if (!shot) return {};
      const containers = [shot.statusData, shot.status, shot.statuses];
      for (const bucket of containers) {
        if (bucket && bucket[statusId]) {
          return { ...bucket[statusId] };
        }
      }
      const direct = shot[statusId];
      if (direct != null) {
        if (typeof direct === 'object') return { ...direct };
        if (typeof direct === 'number') {
          if (statusId === 'bleed') return { dps: direct };
          if (statusId === 'gravity') return { force: direct };
          if (statusId === 'pushback') return { power: direct };
          return { duration: direct };
        }
      }
      return {};
    }

    function applyStatus(target, statusId, data = {}) {
      if (!target) return null;
      const defaults = STATUS_DEFAULTS[statusId] || {};
      const store = target.statuses = target.statuses || {};
      const status = store[statusId] || { stacks: 0, tick: 0 };
      const mergedData = { ...defaults, ...(status.data || {}), ...(data || {}) };
      const durationCandidate = data.duration ?? data.dur ?? data.durationMs ?? data.ms;
      const baseDuration = Number.isFinite(durationCandidate) ? durationCandidate : (defaults.duration || 0);
      status.remaining = Math.max(status.remaining || 0, baseDuration);
      if (!status.remaining && defaults.duration) {
        status.remaining = defaults.duration;
      }
      const addStacks = data.addStacks ?? data.stacks ?? 1;
      const maxStacks = mergedData.maxStacks ?? defaults.maxStacks ?? 9;
      status.stacks = Math.min(maxStacks, Math.max(1, (status.stacks || 0) + Math.max(0, addStacks)));
      status.data = mergedData;
      status.sourceId = data.sourceId || status.sourceId;
      status.lastApplied = performance.now?.() || Date.now();
      store[statusId] = status;
      return status;
    }

    function tickStatuses(enemy, dtMs) {
      if (!enemy) return;
      const dtSec = dtMs / 1000;
      enemy._statusSpeedMult = 1;
      enemy._statusGravityForce = 0;
      enemy._statusPushDelta = 0;
      if (!enemy.statuses) return;
      const removals = [];
      for (const [statusId, status] of Object.entries(enemy.statuses)) {
        if (!status) { removals.push(statusId); continue; }
        status.remaining = (status.remaining ?? 0) - dtMs;
        if (status.remaining <= 0) { removals.push(statusId); continue; }
        const data = status.data || STATUS_DEFAULTS[statusId] || {};
        switch (statusId) {
          case 'bleed': {
            const tickMs = data.tickMs ?? STATUS_DEFAULTS.bleed.tickMs;
            status.tick = (status.tick || 0) + dtMs;
            const dps = (data.dps ?? STATUS_DEFAULTS.bleed.dps ?? 0) * Math.max(1, status.stacks || 0);
            while (status.tick >= tickMs && dps > 0 && enemy.hp > 0) {
              status.tick -= tickMs;
              const dmg = Math.max(1, Math.round((dps * tickMs) / 1000));
              enemy.hp -= dmg;

              if (typeof addFloater === 'function') addFloater(enemy.x, enemy.y - 16, '-' + dmg, '#b52a4a');
              if (enemy.hp <= 0) {
                onEnemyKilled(enemy);
                break;
              }
            }
            break;
          }
          case 'paralyze': {
            const slow = Math.max(0, Math.min(1, data.speedMult ?? STATUS_DEFAULTS.paralyze.speedMult));
            enemy._statusSpeedMult = Math.min(enemy._statusSpeedMult, slow);
            if (data.stunMs) {
              enemy._stunned = Math.max(enemy._stunned || 0, data.stunMs);
            }
            break;
          }
          case 'freeze': {
            const freezeSlow = Math.max(0, Math.min(1, data.speedMult ?? STATUS_DEFAULTS.freeze.speedMult));
            enemy._statusSpeedMult = Math.min(enemy._statusSpeedMult, freezeSlow);
            break;
          }
          case 'gravity': {
            const force = (data.force ?? STATUS_DEFAULTS.gravity.force) * Math.max(1, status.stacks || 0);
            enemy._statusGravityForce += force;
            break;
          }
          case 'pushback': {
            const direction = Math.sign(data.direction ?? 0) || 0;
            if (direction) {
              const power = (data.power ?? STATUS_DEFAULTS.pushback.power) * Math.max(1, status.stacks || 0);
              enemy._statusPushDelta += direction * power * dtSec;
            }
            break;
          }
        }
      }
      for (const statusId of removals) {
        delete enemy.statuses[statusId];
      }
      if (enemy.statuses && Object.keys(enemy.statuses).length === 0) {
        delete enemy.statuses;
      }
    }

    function projectileHasStatusTag(shot) {
      return toArray(shot?.tags).some(tag => STATUS_TAGS.has(String(tag).toLowerCase()));
    }

    function consumeProjectilePierce(shot) {
      if (!shot) return;
      if (shot.pierce === true || shot.pierce === Infinity) return;
      if (projectileHasStatusTag(shot)) {
        if (shot._statusPierce == null) {
          const initial =
            (typeof shot.pierce === 'number' ? shot.pierce : undefined) ??
            (typeof shot.pierceStacks === 'number' ? shot.pierceStacks : undefined) ??
            (typeof shot.statusPierce === 'number' ? shot.statusPierce : undefined) ??
            1;
          shot._statusPierce = Math.max(0, initial);
        }
        if (shot._statusPierce > 0) {
          shot._statusPierce -= 1;
          if (typeof shot.pierce === 'number') {
            shot.pierce = Math.max(0, Math.min(shot.pierce, shot._statusPierce));
          }
        }
        if (shot._statusPierce <= 0) {
          shot.life = 0;
        }
        return;
      }
      if (typeof shot.pierce === 'number') {
        if (shot.pierce > 0) {
          shot.pierce -= 1;
          if (shot.pierce <= 0) shot.life = 0;
        } else {
          shot.life = 0;
        }
      } else {
        shot.life = 0;
      }
    }

    window.applyStatus = applyStatus;
    window.tickStatuses = tickStatuses;

    // Helpers to spawn demo-style projectiles using runner's shot system
    function spawnXWave(owner, ang, speed, dmg, pierce, homingStr, life, radius) {
      const vx = Math.cos(ang) * speed, vy = Math.sin(ang) * speed;
      const r = radius ? Math.max(10, radius) : undefined;
      const shot = {
        kind: (owner.id === 'A1' || owner.isClone) ? 'a1_xwave' : undefined, x: owner.x + 10, y: owner.y - 40, vx, vy, speed,
        dmg: Math.round(dmg), life: life || 1600, ownerId: owner.id, pierce: pierce || 0, aoe: r, r,
      };
      annotateProjectile(shot, ['water']);
      st.shots.push(shot);
      if (window.CombatFX) {
        try {
          window.CombatFX.projectileLaunch(owner, 'S1', { element: 'water', offset: { x: 0, y: -36 } });
        } catch (_e) { }
      }
    }

    // Fallback loot drop spawner for chest explosions
    function spawnDrop(x, y) { try { st.pickups = st.pickups || []; st.pickups.push({ kind: 'pickup', x: x + (Math.random() * 40 - 20), y: y + (Math.random() * 20 - 10), life: 15000 }); } catch (_) { } }

    function spawnClone(owner) {
      st.clones = st.clones || [];
      const max = Math.round((owner.hpMax || 200) * 0.5);
      const c = {
        id: 'clone', isClone: true, ownerId: owner.id,
        x: owner.x + 22, y: owner.y, hpMax: max, hp: max, level: 1,
        atkMult: 1, dmg: Math.round((owner.dmg || 20) * 0.9), facingLeft: false,
        stance: (st._cloneStance || 'assault'),
        _autoNext: 4000 + Math.floor(Math.random() * 4000), // ms until next auto X-waves
        _meleeCD: 0, _swordT: 0, _skillButtons: []
      };
      st.clones.push(c);
      if (window.CombatFX) {
        try {
          window.CombatFX.attachProceduralSprite(c, { element: 'water' });
          window.CombatFX.aura(c, { element: 'water' });
        } catch (_e) { }
      }
      try { ensureCooldownRow('clone'); } catch (_e) { }
    }

    // Command the first alive clone to cast a random ready skill from S1/S3/S5
    function commandCloneRandomSkill() {
      const c = (st.clones || []).find(x => x && !x.isDefeated);
      if (!c) { try { notify('No clone to command', '#ff7a6a'); } catch (_e) { } return false; }
      ensureCooldownRow('clone');
      const pool = ['S1', 'S3', 'S5'];
      const ready = pool.filter(k => cdReady('clone', k));
      if (ready.length === 0) { try { notify('Clone skills cooling down', '#ffb6b6'); } catch (_e) { } return false; }
      const key = ready[Math.floor(Math.random() * ready.length)];
      // Fire using A1’s kit but with clone actor
      a1_useSkill(c, key);
      startCD('clone', key);
      try { notify('Clone: ' + key, '#b9e7ff'); } catch (_e) { }
      return true;
    }

    // Convenience helpers for external calls/snippets
    function getClone() { return (st.clones || []).find(c => c && !c.isDefeated); }
    function commandCloneUseRandomSkill(owner) {
      const c = getClone();
      if (!c) { return false; }
      return commandCloneRandomSkill();
    }

    // Recall + heal clone to leader, 20s CD, light VFX
    function recallCloneForLeader() {
      try {
        const L = leader(); if (!L) return;
        const now = performance.now?.() || Date.now();
        if (now < (st._cloneRecallCDUntil || 0)) { notify('Recall on cooldown', '#ff7a6a'); return; }
        const c = getClone(); if (!c) { notify('No clone to recall', '#ff7a6a'); return; }
        c.x = L.x + 30; c.y = L.y - 10;
        if (c.hpMax) { c.hp = Math.min(c.hpMax, Math.round((c.hp || 0) + c.hpMax * 0.5)); }
        st._cloneRecallCDUntil = now + 20000;
        st.effects.push({ kind: 'cast', x: L.x, y: L.y - 40, color: '#b9e7ff', life: 400, max: 400 });
        notify('Clone recalled', '#b9e7ff');
      } catch (_e) { }
    }

    // Fire a specific clone skill (S1/S3/S5) if ready
    function commandCloneSkill(key) {
      const c = (st.clones || []).find(x => x && !x.isDefeated);
      if (!c) { try { notify('No clone to command', '#ff7a6a'); } catch (_e) { } return false; }
      ensureCooldownRow('clone');
      if (!cdReady('clone', key)) { try { notify('Clone ' + key + ' cooling', '#ffb6b6'); } catch (_e) { } return false; }
      a1_useSkill(c, key);
      startCD('clone', key);
      try { notify('Clone: ' + key, '#b9e7ff'); } catch (_e) { }
      return true;
    }
    // A1 – Dual sabers (ported)
    function a1_useSkill(a, key) {
      if (!a || a.isDefeated) return;
      // Special-case: A1 S2 doubles as "command the clone" when a clone exists
      if (a && a.id === 'A1' && key === 'S2') {
        const hasClone = (st.clones || []).some(c => c && !c.isDefeated);
        if (hasClone) {
          if (commandCloneRandomSkill()) return;
          // If command failed (no ready skills), fall through to normal S2 if off CD
        }
      }
      if (!a.isClone && !cdReady(a.id, key) && !(a.rageOn && (key === 'S1' || key === 'S2' || key === 'S3'))) return;
      // Delegate to bound skill if provided (new S1/S2/S3 overrides)
      try {
        if (a && a.skills && typeof a.skills[key] === 'function') {
          a.skills[key](a);
          if (!a.rageOn) startCD(a.id, key);
          a.lastSkill = { key, time: (performance.now?.() || Date.now()) };
          return;
        }
      } catch (_) { }
      const b = a.dmg;
      const A = CFG.A1;
      const elementHint = getSkillElement(a, key, 'fire');
      if (key === 'S1') {
        // Unified Skills: allow scroll to tweak min/max waves
        let waves = Math.min(A.s1.waves_max, Math.max(A.s1.waves_min, (a._hold?.s1waves) || A.s1.waves_min));
        try { if (window.UnifiedSkills) { const it = window.UnifiedSkills.getItem(a.id, 1); const w = it?.stats?.waves; if (Array.isArray(w) && w.length >= 2) { const wmin = +w[0], wmax = +w[1]; if (isFinite(wmin) && isFinite(wmax)) { waves = Math.min(wmax, Math.max(wmin, waves)); } } } } catch (_e) { }
        const now = performance.now?.() || Date.now();
        const wasS2 = (a.lastSkill && a.lastSkill.key === 'S2' && (now - (a.lastSkill.time || 0) < COMBO_WINDOW));
        const waveElement = wasS2 ? 'fire' : elementHint;
        if (window.CombatFX) {
          try { window.CombatFX.castCharge(a, key, { element: waveElement }); } catch (_e) { }
        }
        if (wasS2) {
          // Combo: Explosive Waves
          for (let i = 0; i < waves; i++) {
            const ang = (i - (waves - 1) / 2) * 0.10; const sp = A.xwave.speed;
            const vx = Math.cos(ang) * sp, vy = Math.sin(ang) * sp;
            const baseR = A.xwave.r;
            const shot = { kind: 'a1_xwave', x: a.x + 10, y: a.y - 40, vx, vy, speed: sp, dmg: Math.round(b * A.xwave.mult), life: A.xwave.life, ownerId: a.id, pierce: A.xwave.pierce || 0, aoe: baseR * 2.5, r: baseR };
            annotateProjectile(shot, ['fire']);
            st.shots.push(shot);
          }
          try { notify('Combo: Explosive Wave!', '#ff8c6a'); } catch (_e) { }
        } else {
          for (let i = 0; i < waves; i++) { const ang = (i - (waves - 1) / 2) * 0.10; spawnXWave(a, ang, A.xwave.speed, b * A.xwave.mult, A.xwave.pierce, A.xwave.homing, A.xwave.life, A.xwave.r * 1.6); }
        }
        if (window.CombatFX) {
          try { window.CombatFX.castRelease(a, key, { element: waveElement }); } catch (_e) { }
        }
        if (!a.rageOn) startCD(a.id, 'S1'); return;
      }
      if (key === 'S2') {
        // NEW: Energy Burst - close-range explosion with knockback and armor shred
        const burstRadius = 90;
        const burstDamage = Math.round(b * 2.5);
        if (window.CombatFX) {
          try { window.CombatFX.castCharge(a, key, { element: elementHint, offset: { x: 0, y: -28 } }); } catch (_e) { }
        }

        // Create explosion effect
        const burstShot = {
          kind: 'a1_energy_burst',
          x: a.x,
          y: a.y,
          vx: 0,
          vy: 0,
          dmg: burstDamage,
          life: 60,
          aoe: burstRadius,
          ownerId: a.id,
          armorShred: 0.30,
          knockback: 80
        };
        annotateProjectile(burstShot, ['fire']);
        st.shots.push(burstShot);
        if (window.CombatFX) {
          try {
            window.CombatFX.castRelease(a, key, { element: 'fire', offset: { x: 0, y: -24 } });
            window.CombatFX.impact(a.x, a.y - 12, { element: 'fire', override: { burst: 80 } });
          } catch (_e) { }
        }

        // Visual effects
        if (window.globalParticles && window.ParticleSystem) {
          const burstPalette = getPaletteFromTags(['fire']);
          const emitter = window.globalParticles.createEmitter(a.x, a.y,
            window.ParticleSystem.Presets.shockwave(a.x, a.y, burstPalette.accent)
          );
          emitter.stop();
        }

        // Spell glyph effect
        if (window.spellGlyphs) {
          window.spellGlyphs.castEffect(a.x, a.y, 'A1_S2', 'fire', 600);
        }

        if (!a.rageOn) startCD(a.id, 'S2');
        return;
      }
      if (key === 'S3') {
        let waves = Math.min(A.s3.waves_max, Math.max(A.s3.waves_min, (a._hold?.s3waves) || A.s3.waves_min));
        try { if (window.UnifiedSkills) { const it = window.UnifiedSkills.getItem(a.id, 3); const w = it?.stats?.waves; if (Array.isArray(w) && w.length >= 2) { const wmin = +w[0], wmax = +w[1]; if (isFinite(wmin) && isFinite(wmax)) { waves = Math.min(wmax, Math.max(wmin, waves)); } } } } catch (_e) { }
        if (window.CombatFX) {
          try { window.CombatFX.castCharge(a, key, { element: elementHint, offset: { x: 0, y: -34 } }); } catch (_e) { }
        }
        let radius = A.xwave.r * 3;
        try {
          if (CFG?.flags?.a1S3 && window.SkillEngine) {
            const baseR = (CFG.A1?.xwave?.r) || 16;
            const def = window.SkillEngine.Skills?.A1_S3 || { baseRadius: baseR, minScale: 3.0, maxScale: 6.0 };
            const denom = Math.max(1, (A.s3?.waves_max || 8) - (A.s3?.waves_min || 2));
            const t = Math.max(0, Math.min(1, (waves - (A.s3?.waves_min || 2)) / denom));
            const scale = (def.minScale || 3) + ((def.maxScale || 6) - (def.minScale || 3)) * t;
            radius = (def.baseRadius || baseR) * scale;
          }
        } catch (_e) { }
        for (let i = 0; i < waves; i++) { spawnXWave(a, (i - (waves - 1) / 2) * 0.10, A.xwave.speed + 25, b * 0.80, A.xwave.pierce, A.xwave.homing, 1500, radius); }
        if (window.CombatFX) {
          try { window.CombatFX.castRelease(a, key, { element: elementHint }); } catch (_e) { }
        }
        if (st.cds[a.id]) st.cds[a.id].S2 = 0; // reset S2
        if (!a.rageOn) startCD(a.id, 'S3'); return;
      }
      if (key === 'S4') {
        // S4: Charged S1 - Bigger waves with chromatic distortion
        if (window.CombatFX) {
          try { window.CombatFX.castCharge(a, key, { element: elementHint, offset: { x: 0, y: -38 } }); } catch (_e) { }
        }
        const chargedWaves = 8;
        for (let i = 0; i < chargedWaves; i++) {
          const ang = (i - (chargedWaves - 1) / 2) * 0.12;
          spawnXWave(a, ang, 500, b * 1.2, 10, 0.05, 1800, A.xwave.r * 4);
        }

        // Visual effects
        if (window.globalParticles) {
          const arcanePalette = getPaletteFromTags(['arcane']);
          const emitter = window.globalParticles.createEmitter(a.x, a.y, {
            type: 'circle',
            radius: 80,
            burst: 60,
            rate: 0,
            duration: 0.25,
            speed: { min: 150, max: 300 },
            size: { min: 4, max: 10 },
            life: { min: 400, max: 800 },
            colors: arcanePalette.particles,
            spread: Math.PI * 2,
            endSize: 0,
            shape: 'circle'
          });
          emitter.stop();
        }

        // Spell glyph
        if (window.spellGlyphs) {
          window.spellGlyphs.castEffect(a.x, a.y, 'A1_S4', 'arcane', 800);
        }

        if (window.CombatFX) {
          try { window.CombatFX.castRelease(a, key, { element: elementHint }); } catch (_e) { }
        }
        if (!a.rageOn) startCD(a.id, 'S4');
        return;
      }
      if (key === 'S5') {
        // S5: Mega Charged S2 - Massive explosion with fractal patterns
        if (window.CombatFX) {
          try { window.CombatFX.castCharge(a, key, { element: elementHint, offset: { x: 0, y: -30 } }); } catch (_e) { }
        }
        const megaRadius = 150;
        const megaDamage = Math.round(b * 4.0);

        const megaShot = {
          kind: 'a1_mega_explosion',
          x: a.x,
          y: a.y,
          vx: 0,
          vy: 0,
          dmg: megaDamage,
          life: 100,
          aoe: megaRadius,
          ownerId: a.id,
          armorShred: 0.50,
          knockback: 150,
          stun: 800
        };
        annotateProjectile(megaShot, ['fire']);
        st.shots.push(megaShot);
        if (window.CombatFX) {
          try {
            window.CombatFX.castRelease(a, key, { element: 'fire' });
            window.CombatFX.impact(a.x, a.y - 12, { element: 'fire', override: { burst: 140 } });
          } catch (_e) { }
        }

        // Massive visual effects
        if (window.globalParticles) {
          const megaPalette = getPaletteFromTags(['fire']);
          const emitter = window.globalParticles.createEmitter(a.x, a.y, {
            type: 'point',
            burst: 100,
            rate: 0,
            duration: 0.25,
            speed: { min: 200, max: 400 },
            size: { min: 5, max: 12 },
            life: { min: 600, max: 1200 },
            colors: megaPalette.particles,
            spread: Math.PI * 2,
            endSize: 0,
            shape: 'circle'
          });
          emitter.stop();
        }

        // Spell glyph
        if (window.spellGlyphs) {
          window.spellGlyphs.castEffect(a.x, a.y, 'A1_S5', 'fire', 1200);
        }

        // Screen shake
        st._screenShake = { t: 800, mag: 12 };

        // Resets handled in wrapper for S5
        if (!a.rageOn) startCD(a.id, 'S5');
        return;
      }
      if (key === 'X1') {
        if (window.CombatFX) {
          try { window.CombatFX.castCharge(a, key, { element: elementHint, offset: { x: 0, y: -28 } }); } catch (_e) { }
        }
        for (const e of st.enemies) { if (e.hp > 0 && Math.abs(e.y - a.y) <= 260) { e.hp -= Math.round(b * 0.6); addFloater(e.x, e.y - 24, '-' + Math.round(b * 0.6), '#ff4a6f'); if (e.hp <= 0) onEnemyKilled(e); e._lastHitBy = a.id; } }
        for (let i = 0; i < 4; i++) { const ang = (i - 1.5) * 0.22; spawnXWave(a, ang, 560, b * 1.4, 20, 0.06, 1800, A.xwave.r * 6.2); }
        if (window.CombatFX) {
          try { window.CombatFX.castRelease(a, key, { element: elementHint }); } catch (_e) { }
        }
        if (st.cds[a.id]) { st.cds[a.id].S1 = 0; st.cds[a.id].S2 = 0; }
        if (!a.rageOn) startCD(a.id, 'X1'); return;
      }
    }

    // Enhanced melee with max HP damage and kill tracking
    function meleeWithTracking(a, reach, height, dmg, maxHPPercent = 0) {
      let kills = 0;
      for (const e of st.enemies) {
        if (e.hp > 0 && e.x > a.x && (e.x - a.x) <= reach && Math.abs(e.y - a.y) <= height / 2) {
          let real = dmg;

          // Add % max HP damage
          if (maxHPPercent > 0) {
            real += Math.round(e.max * maxHPPercent);
          }

          if (e.armorShredDebuff) real = Math.round(real * (1 + e.armorShredDebuff));
          if (e.def) real = Math.max(1, real - e.def);
          e.hp -= real;
          addFloater(e.x, e.y - 20, '-' + real, '#ff7a6a');
          if (e.hp <= 0) {
            onEnemyKilled(e);
            kills++;
          }
        }
      }
      if (kills > 0) addImpact(a.x + reach / 2, a.y - 40, '#ff7a6a');
      // Parry window synergy
      st.parryT = Math.max(st.parryT, 500);
      return kills;
    }

    /* =================== UNIQUE Combat Kit (MOB SLAYER) =================== */
    function unique_useSkill(a, key) {
      if (!a || a.isDefeated) return;
      if (!cdReady(a.id, key) && !(a.rageOn && (key === 'S1' || key === 'S2' || key === 'S3'))) return;
      // Delegate to bound skill if provided
      try {
        if (a && a.skills && typeof a.skills[key] === 'function') {
          a.skills[key](a);
          if (!a.rageOn) startCD(a.id, key);
          a.lastSkill = { key, time: (performance.now?.() || Date.now()) };
          return;
        }
      } catch (_) { }
      const b = a.dmg; const U = CFG.Unique;
      const elementHint = getSkillElement(a, key, 'lightning');
      if (key === 'S1') {
        let n = U.shards.count; try { if (window.UnifiedSkills) { const it = window.UnifiedSkills.getItem(a.id, 1); const sh = it?.stats?.shards; if (Number.isFinite(sh)) n = Math.max(3, Math.min(11, Math.round(sh))); } } catch (_e) { }
        if (window.CombatFX) {
          try { window.CombatFX.castCharge(a, key, { element: elementHint }); } catch (_e) { }
        }
        for (let i = 0; i < n; i++) { const ang = (i - (n - 1) / 2) * 0.1; const sp = 560; st.shots.push({ x: a.x + 10, y: a.y - 40, vx: Math.cos(ang) * sp, vy: Math.sin(ang) * sp, speed: sp, dmg: Math.round(b * U.shards.mult), life: 900, ownerId: a.id, freeze: true }); }
        // Combo: if S2 just used, drones fire mini volleys
        try {
          const now = performance.now?.() || Date.now();
          const wasS2 = (a.lastSkill && a.lastSkill.key === 'S2' && (now - (a.lastSkill.time || 0) < COMBO_WINDOW));
          if (wasS2) {
            const drones = (st.shots || []).filter(s => s && s.kind === 'unique_module' && s.ownerId === a.id);
            for (const d of drones) { const sp = 560; st.shots.push({ x: d.x, y: d.y, vx: sp, vy: 0, speed: sp, dmg: Math.round(b * 0.2), life: 700, ownerId: a.id, freeze: true }); }
            notify('Combo: Drone Barrage!', '#aaf7ff');
          }
        } catch (_e) { }
        if (window.CombatFX) {
          try { window.CombatFX.castRelease(a, key, { element: elementHint }); } catch (_e) { }
        }
        if (!a.rageOn) startCD(a.id, 'S1'); return;
      }
      if (key === 'S2') {
        // Optional: new spawn path via SkillEngine under flag
        if (window.CombatFX) {
          try { window.CombatFX.castCharge(a, key, { element: elementHint, offset: { x: 0, y: -26 } }); } catch (_e) { }
        }
        try {
          if (CFG?.flags?.uniqueS2 && window.SkillEngine) {
            const spec = window.SkillEngine.Skills?.UNIQUE_S2 || { id: 'UNIQUE_S2', cap: CFG.Unique?.drone?.max || 4, baseAtk: Math.round((a.dmg || 18) * CFG.Unique?.drone?.mult || 0.45), baseHp: CFG.Unique?.drone?.start_hp || 20, postUpgrades: ['level+1'] };
            const ent = window.SkillEngine.spawnAlly(a, spec);
            if (ent) {
              // Bridge to legacy expectations for self-tests (use unique_module entries)
              const hp = ent.hp ?? (CFG.Unique?.drone?.start_hp || 20);
              const assistCD = CFG.Unique?.drone?.shot_ms || 600;
              st.shots.push({ kind: 'unique_module', x: a.x + 20, y: a.y - 20, hpMax: hp, hp: hp, life: 999999, assistCD, ownerId: a.id, level: ent.level || 1 });
              if (!a.rageOn) startCD(a.id, 'S2');
              return;
            }
            // If at cap, emulate upgrade tick
            if ((window.SkillEngine.getOwnerList?.(a, 'UNIQUE_S2') || []).length >= (spec.cap || 0)) {
              try { upgradeDrones(a); } catch (_e) { }
              if (!a.rageOn) startCD(a.id, 'S2');
              return;
            }
          }
        } catch (_e) { }
        // Legacy path
        ensureDrones(a);
        // Harmonic field: small periodic heal/DR aura visual
        st.effects.push({ kind: 'cast', x: a.x, y: a.y - 40, color: '#aaf7ff', life: U.s2field.life_ms, max: U.s2field.life_ms });
        if (window.CombatFX) {
          try { window.CombatFX.castRelease(a, key, { element: elementHint }); } catch (_e) { }
        }
        if (!a.rageOn) startCD(a.id, 'S2'); return;
      }
      if (key === 'S3') {
        // Overcharge micro-beams: fire small bullets towards nearest enemies over time (scroll tuned)
        if (window.CombatFX) {
          try { window.CombatFX.castCharge(a, key, { element: elementHint, offset: { x: 0, y: -30 } }); } catch (_e) { }
        }
        let dur = U.overcharge.life_ms, tick = U.overcharge.micro_ms, mult = U.overcharge.micro_mult; const startT = performance.now();
        try { if (window.UnifiedSkills) { const it = window.UnifiedSkills.getItem(a.id, 3); if (it) { if (Number.isFinite(it.stats?.duration)) { dur = Math.max(500, Math.round((it.stats.duration || 4) * 1000)); } if (Number.isFinite(it.stats?.rate)) { tick = Math.max(60, Math.round(1000 / Math.max(1, it.stats.rate))); } } } } catch (_e) { }
        const timer = setInterval(() => {
          if (performance.now() - startT > dur) { clearInterval(timer); return; }
          let fired = 0; for (const e of st.enemies) { if (e.hp > 0) { const ang = Math.atan2(e.y - (a.y - 40), e.x - (a.x + 10)); const sp = 540; st.shots.push({ x: a.x + 10, y: a.y - 40, vx: Math.cos(ang) * sp, vy: Math.sin(ang) * sp, speed: sp, dmg: Math.round(b * mult), life: 900, ownerId: a.id }); if (++fired >= 3) break; } }
        }, tick);
        if (window.CombatFX) {
          try { window.CombatFX.castRelease(a, key, { element: elementHint }); } catch (_e) { }
        }
        if (!a.rageOn) startCD(a.id, 'S3'); return;
      }
      if (key === 'S4') {
        // Begin charge; release handled by unique_releaseStellarAnnihilator on pointerup
        a._stellarCharging = true; a._stellarMaxCharge = U.beam.dur_max; a._stellarCharge = 0;
        if (a._stellarChargingInterval) clearInterval(a._stellarChargingInterval);
        a._stellarChargingInterval = setInterval(() => { if (!a._stellarCharging) { clearInterval(a._stellarChargingInterval); a._stellarChargingInterval = null; return; } a._stellarCharge = Math.min(a._stellarMaxCharge, a._stellarCharge + 60); }, 60);
        if (CFG?.flags?.chargeFx) addChargeFx(a, U.beam.dur_max, '#7cf5ff');
        if (window.CombatFX) {
          try { window.CombatFX.castCharge(a, key, { element: elementHint, offset: { x: 0, y: -34 } }); } catch (_e) { }
        }
        return;
      }
      if (key === 'S5') {
        // Singularity pull: spawn a taunting guardian that pulls enemies (reuse missy_maneki behavior)
        if (window.CombatFX) {
          try { window.CombatFX.castCharge(a, key, { element: elementHint, offset: { x: 0, y: -28 } }); } catch (_e) { }
        }
        st.shots.push({ kind: 'missy_maneki', x: a.x + 160, y: a.y - 20, vx: 0, vy: 0, life: U.singularity.life_ms, hp: 1, pullRadius: U.singularity.radius, taunt: true, tauntCD: 400, ownerId: a.id });
        if (window.CombatFX) {
          try { window.CombatFX.castRelease(a, key, { element: elementHint }); } catch (_e) { }
        }
        if (!a.rageOn) startCD(a.id, 'S5'); return;
      }
      if (key === 'X1') {
        // Thicker, longer global beam + lattice (fast assist module) + loot vacuum aura
        const held = Math.min(2000, Math.max(300, (a._hold?.xhold) || 1000));
        const scale = (held - 300) / (2000 - 300);
        const life = U.beam.life_min + (U.beam.life_max - U.beam.life_min) * scale;
        if (window.CombatFX) {
          try { window.CombatFX.castCharge(a, key, { element: elementHint, offset: { x: 0, y: -30 } }); } catch (_e) { }
        }
        st.shots.push({ kind: 'unique_stellar_beam', x: a.x + 30, y: a.y - 40, dmg: Math.round(b * 6.0 * (1 + 0.2 * scale) * 0.1), life, w: 920, h: st.gameH ? (st.gameH / 2) : 120, persistent: true, tickRate: 50, ownerId: a.id });
        // Lattice: fast assist module near player
        st.shots.push({ kind: 'unique_module', x: a.x + 20, y: a.y - 20, hp: 50, life: 7000, assistCD: 110, ownerId: a.id });
        // Loot vacuum aura
        st.shots.push({ kind: 'missy_royal_bell', x: a.x, y: a.y - 20, hp: 1, life: 6000, healRate: 999999, lootPull: true, ownerId: a.id });
        if (window.CombatFX) {
          try { window.CombatFX.castRelease(a, key, { element: elementHint }); } catch (_e) { }
        }
        if (st.cds[a.id]) { st.cds[a.id].S1 = 0; st.cds[a.id].S2 = 0; }
        if (!a.rageOn) startCD(a.id, 'X1'); return;
      }
    }

    function spawnOneDrone(owner) { const U = CFG.Unique.drone; const hp = U.start_hp; st.shots.push({ kind: 'unique_module', x: owner.x + 30, y: owner.y - 20, hpMax: hp, hp: hp, life: 999999, assistCD: U.shot_ms, ownerId: owner.id, level: 1 }); }
    function spawnOneDrone(owner) {
      const U = CFG.Unique.drone; const hp = U.start_hp; const phase = Math.random() * 6.28; const orbitR = 30;
      st.shots.push({ kind: 'unique_module', x: owner.x + Math.cos(phase) * orbitR, y: owner.y - 20 + Math.sin(phase) * orbitR, hpMax: hp, hp: hp, life: 999999, assistCD: U.shot_ms, ownerId: owner.id, level: 1, phase, orbitR, aggrTier: 0 });
    }
    function upgradeDrones(owner) { const U = CFG.Unique.drone; for (const s of st.shots) { if (s.kind === 'unique_module' && s.ownerId === owner.id) { if ((s.level || 1) >= U.levelCap) continue; s.level = (s.level || 1) + 1; const sUp = 1 + U.upgPct; s.assistCD = Math.max(80, s.assistCD / sUp); s.hpMax = Math.round((s.hpMax || 20) * sUp); s.hp = Math.min(s.hpMax, Math.round((s.hp || s.hpMax) * sUp)); s.orbitR = Math.min(120, Math.round((s.orbitR || 30) * Math.sqrt(sUp))); s.aggrTier = Math.floor((s.level || 1) / 5); } } }
    function ensureDrones(owner) { const have = st.shots.filter(x => x.kind === 'unique_module' && x.ownerId === owner.id).length; if (have < CFG.Unique.drone.max) spawnOneDrone(owner); else upgradeDrones(owner); }

    // Handle S4 release for Unique
    function unique_releaseStellarAnnihilator(a) {
      if (!a._stellarCharging) return;

      a._stellarCharging = false;
      if (a._stellarChargingInterval) {
        clearInterval(a._stellarChargingInterval);
        a._stellarChargingInterval = null;
      }

      const U = CFG.Unique; const chargeRatio = Math.min(1, a._stellarCharge / a._stellarMaxCharge);
      const beamDuration = Math.round((U.beam.life_min || 2000) + (chargeRatio * ((U.beam.life_max || 4000) - (U.beam.life_min || 2000)))); // 2–4s per CFG
      const beamDamage = Math.round(a.dmg * (1 + chargeRatio * 4)); // 1x to 5x damage

      // Optional component-driven lifecycle, parallel to legacy push for compatibility
      try {
        if (CFG?.flags?.uniqueBeam && window.SkillEngine) {
          const U = CFG.Unique; const chargeRatio = Math.min(1, a._stellarCharge / a._stellarMaxCharge);
          const beamDuration = Math.round((U.beam.life_min || 2000) + (chargeRatio * ((U.beam.life_max || 4000) - (U.beam.life_min || 2000))));
          const beam = new window.SkillEngine.components.Beam({ lifeMs: beamDuration, baseWidth: 10, tickMs: 100, pierce: true, onTick: () => { }, onEnd: () => { } });
          beam.start();
          const t0 = performance.now?.() || Date.now();
          const tid = setInterval(() => { beam.update(); if (!beam.isActive || ((performance.now?.() || Date.now()) - t0) > (beamDuration + 120)) { clearInterval(tid); } }, 60);
          if (tid && typeof tid.unref === 'function') tid.unref();
        }
      } catch (_e) { }

      // Create the persistent beam
      st.shots.push({
        kind: 'unique_stellar_beam', x: a.x + 40, y: a.y - 40, vx: 0, vy: 0,
        dmg: Math.round(beamDamage * 0.1), // Damage per tick
        life: beamDuration, w: (st.gameW || 900), h: Math.round((st.gameH || 540) / 3), color: '#6aa8ff',
        persistent: true, tickRate: 50, ownerId: a.id
      });

      addCast(a.x, a.y, '#6aa8ff');
      notify(`Stellar Beam: ${Math.round(chargeRatio * 100)}% charged!`);

      // Reset charge
      a._stellarCharge = 0;
    }

    /* =================== MISSY Combat Kit (SUPPORT/LOOT) =================== */
    function missy_useSkill(a, key) {
      if (!a || a.isDefeated) return;
      if (!cdReady(a.id, key) && !(a.rageOn && (key === 'S1' || key === 'S2' || key === 'S3'))) return;
      // Delegate to bound skill if provided
      try {
        if (a && a.skills && typeof a.skills[key] === 'function') {
          a.skills[key](a);
          if (!a.rageOn) startCD(a.id, key);
          a.lastSkill = { key, time: (performance.now?.() || Date.now()) };
          return;
        }
      } catch (_) { }
      const C = CFG.Missy || {};
      const baseD = a.dmg || 18;
      const elementHint = getSkillElement(a, key, 'light');
      // Per-hero GCD
      a._gcdT = Math.max(a._gcdT || 0, C.gcdMs || 220);

      if (key === 'S1') {
        // Loot Cyclone: build stock and light vacuum VFX
        if (window.CombatFX) {
          try { window.CombatFX.castCharge(a, key, { element: elementHint, offset: { x: 0, y: -30 } }); } catch (_e) { }
        }
        _MissyRT.stock = Math.min((C.S1?.stockCap) || 4, (_MissyRT.stock || 0) + ((C.S1?.stockGain) || 1));
        // Team rage trickle
        try { for (const h of (st.players || [])) { if (!h.isDefeated) gainRage(h, (C.S1?.teamRageGain) || 0); } } catch (_) { }
        addCast(a.x, a.y - 40, '#ffd46e');
        st.effects.push({ kind: 'pull_field', x: (DESIGN_W || 900) / 2, y: (DESIGN_H || 540) / 2, life: 600, r: (C.S1?.chestVacuumRadius) || 1400 });
        notify(`Stock ${_MissyRT.stock}/${(C.S1?.stockCap) || 4}`, '#ffd56a');
        if (window.CombatFX) {
          try { window.CombatFX.castRelease(a, key, { element: elementHint }); } catch (_e) { }
        }
        if (!a.rageOn) startCD(a.id, 'S1');
        return;
      }
      if (key === 'S2') {
        // Healing Wind: team heal + brief ward VFX (tweak by Unified Skills)
        if (window.CombatFX) {
          try { window.CombatFX.castCharge(a, key, { element: elementHint, offset: { x: 0, y: -26 } }); } catch (_e) { }
        }
        let healPct = (C.S2?.healPctMaxHp) || 0.22;
        try { if (window.UnifiedSkills) { const it = window.UnifiedSkills.getItem(a.id, 2); if (it?.stats?.teamHeal) healPct = Math.min(0.45, Math.max(0.10, it.stats.teamHeal)); } } catch (_e) { }
        for (const h of (st.players || [])) {
          if (!h.isDefeated) { h.hp = Math.min(h.hpMax || 0, (h.hp || 0) + Math.round((h.hpMax || 0) * healPct)); }
        }
        st.effects.push({ kind: 'cast', x: a.x, y: a.y - 40, color: '#a3ffcc', life: (C.S2?.shieldMs) || 800, max: (C.S2?.shieldMs) || 800 });
        notify('Healing Wind!', '#36c777');
        if (window.CombatFX) {
          try { window.CombatFX.castRelease(a, key, { element: elementHint }); } catch (_e) { }
        }
        if (!a.rageOn) startCD(a.id, 'S2');
        return;
      }
      if (key === 'S3') {
        // Treasure Cannon (tap = min power) with scroll-tuned boost
        if (window.CombatFX) {
          try { window.CombatFX.castCharge(a, key, { element: elementHint, offset: { x: 0, y: -28 } }); } catch (_e) { }
        }
        let boost = 0; try { if (window.UnifiedSkills) { const it = window.UnifiedSkills.getItem(a.id, 3); if (it?.stats?.aoe) boost += 0.25; } } catch (_e) { }
        fireTreasureCannon(a, Math.max(0, Math.min(1, 0 + boost)));
        if (window.CombatFX) {
          try { window.CombatFX.castRelease(a, key, { element: elementHint }); } catch (_e) { }
        }
        if (!a.rageOn) startCD(a.id, 'S3');
        return;
      }
      if (key === 'S4') {
        // Black Cat Rain: simple falling strikes
        if (window.CombatFX) {
          try { window.CombatFX.castCharge(a, key, { element: elementHint, offset: { x: 0, y: -32 } }); } catch (_e) { }
        }
        blackCatRain(a);
        if (window.CombatFX) {
          try { window.CombatFX.castRelease(a, key, { element: elementHint }); } catch (_e) { }
        }
        if (!a.rageOn) startCD(a.id, 'S4');
        return;
      }
      if (key === 'S5') {
        // Mega Vacuum / Stage Skip with optional Gating rules
        if (window.CombatFX) {
          try { window.CombatFX.castCharge(a, key, { element: elementHint, offset: { x: 0, y: -32 } }); } catch (_e) { }
        }
        if (CFG?.flags?.missyS5 && window.SkillEngine) {
          try {
            const def = window.SkillEngine.Skills?.MISSY_S5 || { id: 'MISSY_S5', cooldownMs: 14000, rules: { hpPctMin: 0.5, killsMin: 15, forbidBoss: true, cost: null } };
            const ctx = { hp: a.hp, hpMax: a.hpMax || a.max || 1, kills: (st.kills || 0), targetIsBoss: !!st.bossAlive, resources: st.resources || {} };
            const gate = new window.SkillEngine.components.Gating({ now: () => performance.now?.() || Date.now() });
            const res = gate.canActivate(def, ctx);
            if (!res.ok) { try { notify('S5 blocked: ' + res.reasons.join(','), '#ff7a6a'); } catch (_e) { } return; }
            if (def.rules?.cost) window.SkillEngine.components.spendCost(def.rules.cost, ctx);
            gate.markUsed(def);
            if (!st.bossAlive) { st.wave = (st.wave || 1) + 1; notify('Stage skipped', '#ffd56a'); } else { st.effects.push({ kind: 'impact', x: a.x + 40, y: a.y - 30, color: '#ffd46e', life: 900, max: 900 }); }
            if (window.CombatFX) {
              try { window.CombatFX.castRelease(a, key, { element: elementHint }); } catch (_e) { }
            }
            if (!a.rageOn) startCD(a.id, 'S5');
            return;
          } catch (_e) { }
        }
        // Legacy behavior
        const allowSkip = !!(C.S5?.allowStageSkipIfNoBoss);
        if (allowSkip && !st.bossAlive) {
          st.wave = (st.wave || 1) + 1;
          notify('Stage skipped', '#ffd56a');
        } else {
          // Visual vacuum hint and light AoE ping
          st.effects.push({ kind: 'impact', x: a.x + 40, y: a.y - 30, color: '#ffd46e', life: 900, max: 900 });
        }
        if (window.CombatFX) {
          try { window.CombatFX.castRelease(a, key, { element: elementHint }); } catch (_e) { }
        }
        if (!a.rageOn) startCD(a.id, 'S5');
        return;
      }
      if (key === 'X1') {
        // Jackpot: team heal, scale with hold
        if (window.CombatFX) {
          try { window.CombatFX.castCharge(a, key, { element: elementHint, offset: { x: 0, y: -28 } }); } catch (_e) { }
        }
        const held = Math.min((C.X1?.chargeMsMax) || 2000, Math.max((C.X1?.chargeMsMin) || 250, (a._hold?.xhold) || 0));
        const frac = (held - ((C.X1?.chargeMsMin) || 250)) / Math.max(1, ((C.X1?.chargeMsMax) || 2000) - ((C.X1?.chargeMsMin) || 250));
        fireJackpot(a, Math.max(0, Math.min(1, frac)));
        if (window.CombatFX) {
          try { window.CombatFX.castRelease(a, key, { element: elementHint }); } catch (_e) { }
        }
        if (!a.rageOn) startCD(a.id, 'X1');
        return;
      }
    }

    // Missy hold helpers (S1/S3 charge → commit)
    function missy_onHoldStart(p, key) {
      if (!p || p.id !== 'Missy') return;
      _MissyRT.holdStart = performance.now();
      _MissyRT.holdKey = key;
      const C = CFG.Missy || {};
      let maxMs = 1500, col = '#ffd46e';
      if (key === 'S1') { maxMs = (C.S1?.chargeMsMax) || 1500; col = '#ffdf85'; }
      else if (key === 'S3') { maxMs = (C.S3?.chargeMsMax) || 2500; col = '#FBBF24'; }
      if (CFG?.flags?.chargeFx) addChargeFx(p, maxMs, col);
    }
    function missy_onHoldCommit(p, key) {
      if (!p || p.id !== 'Missy') return;
      const C = CFG.Missy || {};
      const t = Math.max(0, performance.now() - (_MissyRT.holdStart || 0));
      if (key === 'S1') {
        const frac = (t - ((C.S1?.chargeMsMin) || 250)) / Math.max(1, ((C.S1?.chargeMsMax) || 1500) - ((C.S1?.chargeMsMin) || 250));
        const stocks = _MissyRT.stock | 0; if (stocks > 0) { _MissyRT.stock = 0; spawnBreakableTreasureBox(p, Math.max(0, Math.min(1, frac)), stocks); }
      } else if (key === 'S3') {
        const frac = (t - ((C.S3?.chargeMsMin) || 250)) / Math.max(1, ((C.S3?.chargeMsMax) || 2500) - ((C.S3?.chargeMsMin) || 250));
        fireTreasureCannon(p, Math.max(0, Math.min(1, frac)));
      }
      _MissyRT.holdStart = 0; _MissyRT.holdKey = null; clearChargeFx(p);
    }

    // Spawn a big treasure chest as a pickup in the world
    function spawnBreakableTreasureBox(owner, chargeFrac, stockAtCast) {
      const C = CFG.Missy;
      const hp = Math.round((C.bigChest?.baseHp || 600) * (1 + Math.max(0, chargeFrac)) * (1 + 0.15 * Math.max(0, stockAtCast)));
      const chest = {
        kind: 'breakable_chest', hp, hpMax: hp, life: (C.S1?.bigChestLifeMs) || 18000,
        x: owner.x + 24, y: owner.y + ((C.S1?.spawnYOffset) || -8), w: 48, h: 48, vy: -40, groundY: owner.y,
        dropFn: () => { if (C.bigChest?.dropFn) C.bigChest.dropFn(chest); else { for (let i = 0; i < 10; i++) spawnDrop(chest.x, chest.y); } }
      };
      st.breakables = st.breakables || [];
      st.breakables.push(chest);
      notify('Treasure Chest!', '#FBBF24');
    }

    function fireTreasureCannon(p, frac) {
      const C = CFG.Missy;
      const r0 = (C.S3?.blastRadiusBase) || 220, r1 = (C.S3?.blastRadiusMax) || 520;
      const r = Math.round(r0 + (r1 - r0) * Math.max(0, Math.min(1, frac)));
      const dmg = Math.round(500 * (1 + 1.5 * Math.max(0, Math.min(1, frac))));
      const blastPos = { x: p.x + 150, y: p.y - 20 };
      // VFX ring + particles
      st.effects.push({ kind: 'aura', x: blastPos.x, y: blastPos.y, life: 900, r, color: 'rgba(251, 191, 36, 0.7)' });
      for (let i = 0; i < 20; i++) st.shots.push({ x: blastPos.x, y: blastPos.y, vx: (Math.random() - 0.5) * 600, vy: (Math.random() - 0.5) * 600, speed: 600, dmg: 0, life: 700, w: 5, h: 5, color: '#FBBF24' });
      st._screenShake = { t: 600, mag: 8 };
      // Damage core
      st.shots.push({ x: blastPos.x, y: blastPos.y, vx: 0, vy: 0, dmg, life: 100, aoe: r, ownerId: p.id });
      notify('Treasure Cannon!', '#FBBF24');
    }

    function blackCatRain(p) {
      const C = CFG.Missy || {}; const nMin = (C.S4?.rainCountMin) || 10, nMax = (C.S4?.rainCountMax) || 14; const n = Math.floor(nMin + Math.random() * (Math.max(0, nMax - nMin)));
      for (let i = 0; i < n; i++) {
        const sx = Math.random() * Math.max(600, DESIGN_W || 900); const vy = 200 + Math.random() * 180;
        st.shots.push({ x: sx, y: 0, vx: 0, vy, speed: vy, dmg: Math.round((p.dmg || 18) * 1.2), life: 1600, ownerId: p.id });
      }
      notify('Black Cat Rain!', '#ffd46e');
    }

    function fireJackpot(p, frac) {
      const C = CFG.Missy;
      (st.players || []).forEach(h => { if (!h.isDefeated) { const heal = Math.round((h.hpMax || 0) * ((C.X1?.healPct) || 0.85)); h.hp = Math.min(h.hpMax || 0, (h.hp || 0) + heal); addFloater(h.x, h.y - 34, '+' + heal, '#ffd56a'); } });
      st.effects.push({ kind: 'aura', x: p.x, y: p.y - 20, life: (C.X1?.invulnMs) || 2000, r: 200 + 140 * Math.max(0, Math.min(1, frac)), color: 'rgba(255, 215, 0, 0.5)' });
      for (let i = 0; i < 50; i++) st.shots.push({ x: Math.random() * DESIGN_W, y: -20, vx: 0, vy: 150 + Math.random() * 150, speed: 200, dmg: 0, life: 1500, w: 4, h: 4, color: '#FFD700' });
      st._screenShake = { t: 800, mag: 12 };
      notify('JACKPOT!', '#FFD700');
    }

    function spawnAllyClone(owner, i) { st.pets = st.pets || []; st.pets.push({ x: owner.x + 12 * i, y: owner.y, rate: 0.25, cd: 0, dmg: Math.round((owner.dmg || 18) * 1.0), hpMax: 70, hp: 70 }); }

    function updateA1RageMode(a, dtMs) {
      if (!a) return;
      if (a.rageOn) {
        a.rageDur -= dtMs;
        st._globalSkillLock = Math.max(st._globalSkillLock || 0, 200);
        if (a.rageDur <= 0) {
          a.rageOn = false;
          a._rageTrailT = 1000;
        }
      } else {
        if (a.rage >= a.rageMax && a.rageICD <= 0) {
          // Activate automatically only if player pressed Rage button; logic outside
        }
      }
      if (a.rageICD > 0) a.rageICD -= dtMs;
      if (a._rageTrailT > 0) a._rageTrailT -= dtMs;
    }

    /* ================ Legacy helper stubs reused ================ */
    function laneY(l) { return (DESIGN_H - 100) + (l === 0 ? -30 : (l === 2 ? 30 : 0)); }
    function addAfterImage(x, y, color = '#ff4d4f') { st.effects.push({ kind: 'after', x, y, color, life: 160, max: 160 }); }
    function addCast(x, y, color) {
      st.effects.push({ kind: 'cast', x, y, color, life: 320, max: 320 });
      if (window.CombatFX) {
        try {
          window.CombatFX.castCharge({ x, y }, null, { primary: color, offset: { x: 0, y: 0 } });
        } catch (_e) { /* ignore visual errors */ }
      }
    }
    function addImpact(x, y, color) {
      st.effects.push({ kind: 'impact', x, y, color, life: 260, max: 260 });
      if (window.CombatFX) {
        try {
          window.CombatFX.impact(x, y, { primary: color });
        } catch (_e) { /* ignore visual errors */ }
      }
    }
    function wave(a, mul, tint, fixed, homing = false) {
      const w = 46, h = 14;
      st.shots.push({
        kind: 'wave', color: tint || '#9ad1ff', w, h,
        x: a.x + 24, y: a.y - 40, vx: 640, vy: 0, speed: 640,
        dmg: fixed != null ? fixed : Math.round(a.dmg * mul),
        life: 2000, laneY: a.y, homing: homing, pierce: 2, ownerId: a.id
      });
    }
    function performMelee(a, reach, height, dmg, isFinisher = false) {
      // Set parry window
      st.parryT = 500; // 0.5s parry window on swing

      // Bullet reflection for A1 and Missy
      if (a.id === 'A1' || a.id === 'Missy') {
        for (const shot of st.eShots) {
          if (Math.abs(shot.x - a.x) < reach && Math.abs(shot.y - a.y) < height / 2) {
            shot.life = 0; // Destroy original bullet

            st.shots.push({
              x: shot.x,
              y: shot.y,
              vx: -shot.vx,
              vy: -shot.vy,
              speed: shot.speed,
              dmg: shot.dmg,
              life: 2000,
              homing: true,
              pierce: (shot.pierce || 0) + 1,
              ownerId: a.id,
              color: '#ffdd44',
              w: 20, // 5x size
              h: 20  // 5x size
            });

            addImpact(shot.x, shot.y, '#ffdd44');
            if (a.id === 'A1') {
              const heal = Math.round(a.hpMax * 0.05); // Heal 5% of max HP
              a.hp = Math.min(a.hpMax, a.hp + heal);
              addFloater(a.x, a.y - 40, `+${heal}`, '#36c777');
            }
          }
        }
      }


      // Damage enemies
      for (const e of st.enemies) {
        if (e.hp > 0 && e.x > a.x && (e.x - a.x) <= reach && Math.abs(e.y - a.y) <= height / 2) {
          let realDmg = dmg;
          if (e.armorShredDebuff) realDmg = Math.round(realDmg * (1 + e.armorShredDebuff));
          if (e.def) realDmg = Math.max(1, realDmg - e.def);
          e.hp -= realDmg;
          addFloater(e.x, e.y - 20, '-' + realDmg, '#ff7a6a');
          // Build rage when dealing damage
          gainRage(a, Math.floor(realDmg * 0.4));
          if (e.hp <= 0) {
            onEnemyKilled(e);
            if (a.id === 'A1') {
              const heal = Math.round(a.hpMax * 0.1); // Heal 10% of max HP
              a.hp = Math.min(a.hpMax, a.hp + heal);
              addFloater(a.x, a.y - 40, `+${heal}`, '#36c777');
            }
          } else if (a.id === 'A1' && dmg >= e.max * 0.5) {
            const heal = Math.round(a.hpMax * 0.1); // Heal 10% of max HP
            a.hp = Math.min(a.hpMax, a.hp + heal);
            addFloater(a.x, a.y - 40, `+${heal}`, '#36c777');
          }

          // Pushback logic
          if (e.kind !== 'boss' && e.kind !== 'miniboss') {
            const pushbackForce = isFinisher ? 15 : 5;
            e.x += pushbackForce; // Push the enemy to the right
          }
        }
      }
    }
    function melee(a, reach, height, dmg) {
      // Basic forward rectangle
      let hit = false;
      for (const e of st.enemies) {
        if (e.hp > 0 && e.x > a.x && (e.x - a.x) <= reach && Math.abs(e.y - a.y) <= height / 2) {
          let real = dmg;
          if (e.armorShredDebuff) real = Math.round(real * (1 + e.armorShredDebuff));
          if (e.def) real = Math.max(1, real - e.def);
          e.hp -= real; hit = true;
          // Build rage when dealing damage
          gainRage(a, Math.floor((real || 0) * 0.4));
          addFloater(e.x, e.y - 20, '-' + real, '#ff7a6a');
          if (e.hp <= 0) onEnemyKilled(e);
        }
      }
      if (hit) addImpact(a.x + reach / 2, a.y - 40, '#ff7a6a');
      // Parry window synergy
      st.parryT = Math.max(st.parryT, 500);
    }

    /* ================= Cooldowns ================== */
    const CD = {
      'A1': { S1: 2500, S2: 4000, S3: 6000, S4: 10000, S5: 45000, X1: 120000 },
      'Unique': { S1: 2000, S2: 4500, S3: 5500, S4: 12000, S5: 35000, X1: 120000 },
      // Use updated Apex Hunter spec for Missy
      'Missy': { S1: 1800, S2: 5000, S3: 4000, S4: 10000, S5: 14000, X1: 24000 },
      // Clone cooldowns (mirrors A1 by default)
      'clone': { S1: 6000, S2: 10000, S3: 16000, S4: 14000, S5: 45000, X1: 120000 }
    };
    function cdReady(id, key) {
      // Global lock
      if (st._globalSkillLock > 0) return false;
      // Per-player GCD and Rage bypass
      const p = (st.players || []).find(pp => pp.id === id);
      if (p) {
        if ((p._gcdT || 0) > 0) return false;
        if (p.rageOn && (key === 'S1' || key === 'S2' || key === 'S3')) return true;
      }
      return st.cds[id] && st.cds[id][key] <= 0;
    }
    function startCD(id, key) { if (st.cds[id]) st.cds[id][key] = CD[id][key]; }

    function ensureCooldownRow(id) {
      st.cds = st.cds || {};
      if (!st.cds[id]) st.cds[id] = { S1: 0, S2: 0, S3: 0, S4: 0, S5: 0, X1: 0 };
    }

    /* ================= S4 Release Handler ================= */
    function releaseS4(player) {
      if (!player || player.isDefeated) return;

      if (player.id === 'Unique') {
        unique_releaseStellarAnnihilator(player);
      } else if (player.id === 'A1') {
        // A1 doesn't have hold-to-charge S4, treat as instant
        // Could implement A1's S4 here if needed
      } else if (player.id === 'Missy') {
        // Missy's S4 could be implemented here
      }
    }

    // Generalized hold for charged skills (A1 S1/S3, Unique S4, X1 for all)
    function startHold(player, which) {
      if (!player) return;
      player._hold = player._hold || {};
      if (which === 'A1_S1' && player.id === 'A1') { player._hold.s1start = performance.now(); if (CFG?.flags?.chargeFx) addChargeFx(player, 1800, '#ff285a'); }
      if (which === 'A1_S3' && player.id === 'A1') { player._hold.s3start = performance.now(); if (CFG?.flags?.chargeFx) addChargeFx(player, 1600, '#ff5aa0'); }
      if (which === 'Unique_S4' && player.id === 'Unique') { player._hold.s4start = performance.now(); if (CFG?.flags?.chargeFx) addChargeFx(player, CFG.Unique.beam.dur_max, '#7cf5ff'); }
      if (which === 'ANY_X') { player._hold.xstart = performance.now(); const col = player.id === 'A1' ? '#ff1c53' : player.id === 'Unique' ? '#eaffff' : '#ffd46e'; if (CFG?.flags?.chargeFx) addChargeFx(player, 2000, col); }
      // Missy hooks: reuse A1 hold buttons for S1/S3
      if (which === 'A1_S1' && player.id === 'Missy') { missy_onHoldStart(player, 'S1'); }
      if (which === 'A1_S3' && player.id === 'Missy') { missy_onHoldStart(player, 'S3'); }
    }
    function releaseHold(player, which) {
      if (!player) return;

      // Initialize _hold if it doesn't exist
      if (!player._hold) {
        player._hold = {};
      }

      if (which === 'A1_S1' && player.id === 'A1') {
        const held = performance.now() - (player._hold?.s1start || performance.now());
        const waves = Math.round(CFG.A1.s1.waves_min + (Math.min(1800, Math.max(120, held)) - 120) / (1800 - 120) * (CFG.A1.s1.waves_max - CFG.A1.s1.waves_min));
        player._hold.s1waves = waves;
        // Cast via skill wrapper so Unified Skills/scroll logic can intercept
        useSkillWrapper(player, 'S1');
        clearChargeFx(player);
      }
      if (which === 'A1_S3' && player.id === 'A1') {
        const held = performance.now() - (player._hold?.s3start || performance.now());
        const waves = Math.round(CFG.A1.s3.waves_min + (Math.min(1600, Math.max(120, held)) - 120) / (1600 - 120) * (CFG.A1.s3.waves_max - CFG.A1.s3.waves_min));
        player._hold.s3waves = waves;
        // Cast via skill wrapper so Unified Skills/scroll logic can intercept
        useSkillWrapper(player, 'S3');
        clearChargeFx(player);
      }
      if (which === 'Unique_S4' && player.id === 'Unique') {
        clearChargeFx(player);
        unique_releaseStellarAnnihilator(player);
      }
      if (which === 'ANY_X') {
        const held = Math.min(2000, Math.max(300, performance.now() - (player._hold?.xstart || performance.now())));
        player._hold.xhold = held; if (canUseSecret(player)) useSkillWrapper(player, 'X1'); clearChargeFx(player);
      }
      // Missy hold commit
      if (which === 'A1_S1' && player.id === 'Missy') { missy_onHoldCommit(player, 'S1'); }
      if (which === 'A1_S3' && player.id === 'Missy') { missy_onHoldCommit(player, 'S3'); }
    }

    /* ================== Rage Activation ================== */
    function triggerRageFor(p) {
      if (p.rage >= p.rageMax && !p.rageOn && (p.exhaustionT || 0) <= 0 && p.rageICD <= 0) {
        p.rageOn = true; p.rage = 0; p.rageDur = (6000 + Math.floor(Math.random() * 4000)); p.rageICD = 20000;
        // Apply buffs
        p._atkMul = 1.25; p._speedMul = 1.2; recalcStats();
        addCast(p.x + 12, p.y - 44, '#f9cc2b');
        notify(p.id + ' Rage!');
      }
    }

    /* ================== Spawn Wave & Enemies (v9.5 + Boss Pools) ================== */

    // Boss Pool Spawner
    function spawnBossFromPool(bossData) {
      if (!bossData) return false;

      const e = {
        kind: 'boss',
        name: bossData.name,
        sprite: bossData.sprite,
        x: DESIGN_W + 100,
        y: laneY(Math.floor(Math.random() * 3)),
        hp: bossData.stats.hpMax,
        max: bossData.stats.hpMax,
        atk: bossData.stats.atk,
        def: bossData.stats.def,
        dmg: bossData.stats.atk,
        speed: 0.8,
        fireCD: 2000,
        isBoss: true,
        critChance: bossData.stats.critChance,
        critMult: bossData.stats.critMult,
        resist: bossData.stats.resist,
        ai: bossData.ai,
        drops: bossData.drops,
        affixes: bossData.affixes,
        pool: bossData.pool
      };

      st.enemies.push(e);
      st.bossAlive = true;
      st.bossHP = e.hp;
      st.bossMax = e.max;
      notify(`${bossData.name} appears!`, '#ff4d4f');
      return true;
    }

    const waveEvents = [
      // Boss on Wave 9.5 (step 18) - Use Boss Pool BigBoss
      {
        key: 'boss', when: () => (window.__PROG95 && window.__PROG95.baseWave() === 9 && window.__PROG95.isHalfStep() === true),
        run: () => {
          if (!window.BossPoolSystem) return false;
          const bosses = window.BossPoolSystem.getWaveBosses(9.5, {
            stage: Math.min(st.stageInArea || 1, 2),
            injectChance: 1.0 // Always spawn boss on 9.5
          });
          let spawned = false;
          bosses.forEach(b => {
            if (spawnBossFromPool(b)) spawned = true;
          });
          return spawned;
        }
      },

      // Mini-boss on Wave 9 main (step 17) - Use Boss Pool MiniBoss
      {
        key: 'miniBoss', when: () => (window.__PROG95 && window.__PROG95.baseWave() === 9 && window.__PROG95.isHalfStep() === false),
        run: () => {
          if (!window.BossPoolSystem) return false;
          const bosses = window.BossPoolSystem.getWaveBosses(9, {
            stage: Math.min(st.stageInArea || 1, 2),
            injectChance: 1.0 // Always spawn miniboss on 9
          });
          let spawned = false;
          bosses.forEach(b => {
            if (spawnBossFromPool(b)) spawned = true;
          });
          return spawned;
        }
      },

      // Random boss injection on waves 1-7 (75% chance)
      {
        key: 'randomBoss', when: () => {
          if (!window.__PROG95 || !window.BossPoolSystem) return false;
          const baseWave = window.__PROG95.baseWave();
          const isHalf = window.__PROG95.isHalfStep();
          // 75% chance on main waves 1-7
          return baseWave >= 1 && baseWave <= 7 && !isHalf;
        },
        run: () => {
          if (!window.BossPoolSystem) return false;
          const baseWave = window.__PROG95.baseWave();
          const bosses = window.BossPoolSystem.getWaveBosses(baseWave, {
            stage: Math.min(st.stageInArea || 1, 2),
            injectChance: 0.75 // 75% inject chance
          });
          let spawned = false;
          bosses.forEach(b => {
            if (spawnBossFromPool(b)) spawned = true;
          });
          return spawned;
        }
      }
    ];

    function spawnWave() {
      // Event gate (boss/miniboss/specials)
      for (const ev of waveEvents) {
        if (ev.when && ev.when()) {
          const didSpawn = ev.run ? ev.run() : false;
          if (didSpawn) {
            st.specialWave = true;
            return;
          }
        }
      }

      // === Composition & difficulty ===
      // Calculate difficulty multiplier
      const P = window.__PROG95;
      if (P) {
        st._difficultyMul = P.getDifficultyMultiplier();
        st.wave = P.baseWave(); // Mirror for compatibility
      }

      // Dynamic Difficulty Scaling + Smart Composition
      const difficulty = 1 + (st.stage * 0.2) + (st.wave * 0.05);
      const CALM_MIN_ENEMIES = 2;
      const CALM_REDUCTION_FACTOR = 0.5;
      const minEnemies = CALM_MIN_ENEMIES;
      const maxExtra = 1.5; // base spread before scaling
      let numEnemies = Math.max(CALM_MIN_ENEMIES, Math.floor(minEnemies + Math.random() * maxExtra * difficulty));

      const calmActive = (st.postBossCalmWaves || 0) > 0;
      if (calmActive) {
        numEnemies = Math.max(CALM_MIN_ENEMIES, Math.round(numEnemies * CALM_REDUCTION_FACTOR));
      }
      const CALM_ENEMY_CAP = 6;
      const NORMAL_ENEMY_CAP = 10;
      const hardCap = calmActive ? CALM_ENEMY_CAP : NORMAL_ENEMY_CAP;
      numEnemies = Math.min(hardCap, numEnemies);

      // Composition by wave: more ground early, more flyers later
      function getEnemyComposition(waveNum) {
        if (waveNum <= 3) return { ground: 0.8, flying: 0.2 };
        if (waveNum <= 6) return { ground: 0.6, flying: 0.4 };
        return { ground: 0.5, flying: 0.5 };
      }
      const composition = getEnemyComposition(st.wave);

      const groundRoles = ['melee', 'shooter'];
      const groundBehaviors = ['relentless', 'hitAndRun', 'berserker'];
      const flyingBehaviors = ['aerial'];

      for (let i = 0; i < numEnemies; i++) {
        const lane = i % 3;
        const isFlying = Math.random() > composition.ground;

        // Scaled stats: HP and speed increase with stage/wave
        const stageLevel = Math.max(1, st.stageInArea || st.stage || 1);
        const globalStage = Math.max(1, st.stage || stageLevel);
        const waveNumber = Math.max(1, st.wave || 1);
        const baseHPWave = 100 + (waveNumber - 1) * 20;
        const stageBonus = (globalStage - 1) * 15;
        const baseHP = baseHPWave + stageBonus;
        const hpVar = Math.max(10, Math.round(baseHP * 0.1));
        const hpRoll = baseHP + (Math.random() * (hpVar * 2) - hpVar);
        const enemyHP = Math.round(hpRoll);
        const baseSpeed = 0.15 + (st.stage * 0.01);

        const enemy = {
          kind: isFlying ? 'flyer' : 'mob',
          sprite: isFlying ? 'flyer' : 'mob',
          x: DESIGN_W + 50 + i * 40,
          y: isFlying ? 100 + Math.random() * 200 : laneY(lane),
          hp: enemyHP,
          max: enemyHP,
          vx: -(baseSpeed + Math.random() * 0.05),
          isFlying: isFlying
        };

        if (isFlying) {
          enemy.role = 'shooter';
          enemy.behavior = flyingBehaviors[Math.floor(Math.random() * flyingBehaviors.length)];
          enemy.originalY = enemy.y;
          enemy.diveBombCD = 3000 + Math.random() * 2000;
        } else {
          enemy.role = groundRoles[Math.floor(Math.random() * groundRoles.length)];
          enemy.behavior = groundBehaviors[Math.floor(Math.random() * groundBehaviors.length)];
        }

        // Regular enemies disabled - only bosses spawn
        if (window.BossPoolSystem && i === 0) {
          const bosses = window.BossPoolSystem.getWaveBosses(st.wave || 1, {
            stage: st.stageInArea || 1
          });

          for (const bossData of bosses) {
            const boss = {
              id: Math.random(),
              kind: 'boss',
              name: bossData.name,
              x: DESIGN_W + 120,
              y: DESIGN_H - 140,
              hp: bossData.stats?.hpMax || 600,
              max: bossData.stats?.hpMax || 600,
              dmg: bossData.stats?.atk || 45,
              vx: -(0.12 + Math.random() * 0.08),
              isBoss: true,
              pool: bossData.pool
            };
            st.enemies.push(boss);
          }
        }
      }

      // Post-spawn: apply global difficulty multiplier & half-wave tightening
      // P already declared above
      if (P && Array.isArray(st.enemies)) {
        if (P.isHalfStep()) {
          // Half-waves = fewer bodies (keep ~70%)
          const keep = Math.ceil(st.enemies.length * 0.7);
          st.enemies = st.enemies.slice(0, keep);
        }
        // All waves = scale durability
        for (const e of st.enemies) {
          e.hp = Math.round((e.hp || 100) * (st._difficultyMul || 1));
          e.max = Math.max(e.max || e.hp, e.hp);
        }
      }

      if (calmActive) {
        st.postBossCalmWaves = Math.max(0, (st.postBossCalmWaves || 0) - 1);
      }

      st.specialWave = false;
    }

    function spawnInteractiveObjects() {
      const objectTypes = ['chest', 'switch', 'ladder'];
      const objectType = objectTypes[Math.floor(Math.random() * objectTypes.length)];

      const x = 300 + Math.random() * 400;
      const y = laneY(Math.floor(Math.random() * 3));

      switch (objectType) {
        case 'chest':
          st.pickups.push({
            kind: 'chest',
            x: x,
            y: y,
            life: 60000,
            chestType: 'normal'
          });
          break;

        case 'switch':
          st.pickups.push({
            kind: 'switch',
            x: x,
            y: y,
            life: 120000,
            switchType: Math.random() < 0.5 ? 'treasure' : 'platform',
            activated: false,
            singleUse: true
          });
          break;

        case 'ladder':
          st.pickups.push({
            kind: 'ladder',
            x: x,
            y: y,
            life: 120000,
            direction: Math.random() < 0.5 ? 'up' : 'down',
            singleUse: false
          });
          break;
      }
    }

    /* ================= Enhanced Boss Encounters ================= */
    function spawnBoss() { return spawnBossForStage(); }

    /* ================== Boss Encounters ================== */
    // Note: Wave Leader, Treasure Boss, Supply Plane, and Revival Boss
    // have been removed and replaced with Boss Pool System.
    // All boss spawning now handled through BossPoolSystem.getWaveBosses()

    // Legacy boss spawner for compatibility (redirects to pool system)
    function spawnTreasureBoss() {
      // DEPRECATED: Now handled by Boss Pool System
      console.log('Legacy treasure boss spawn called - skipping (using Boss Pool System)');
    }

    // Spawn two mini-bosses for stage 9 special wave
    function spawnMiniBossesForStage9() {
      // DEPRECATED: Now handled by Boss Pool System
      // This function kept for compatibility but does nothing
      // Boss Pool System handles miniboss spawning at wave 9
      console.log('Legacy miniboss spawn called - skipping (using Boss Pool System)');
    }

    // Spawn a supply plane that drops supply crates. The plane is indestructible and leaves after a short time.
    function spawnSupplyPlane() {
      // DEPRECATED: Now handled by Boss Pool System
      console.log('Legacy supply plane spawn called - skipping (using Boss Pool System)');
    }

    function spawnRevivalBoss() {
      // DEPRECATED: Now handled by Boss Pool System
      console.log('Legacy revival boss spawn called - skipping (using Boss Pool System)');
    }

    function spawnWaveLeader() {
      // DEPRECATED: Now handled by Boss Pool System
      console.log('Legacy wave leader spawn called - skipping (using Boss Pool System)');
    }

    // Spawn a victory chest to reward clearing a special wave.
    function spawnVictoryChest() {
      st.pickups.push({
        kind: 'chest',
        chestType: 'victory',
        x: DESIGN_W * 0.5 + (Math.random() - 0.5) * 200,
        y: laneY(1),
        life: 40000,
        ring: true
      });
      notify('Victory Chest appears!', '#ffd56a');
    }

    const BOSSES = {
      1: { name: 'Grime', hp: 3000, vx: -0.05, fireCD: 1500, role: 'melee', behavior: 'boss_pattern', skills: ['boss_slam'] },
      2: { name: 'Slime King', hp: 4000, vx: -0.06, fireCD: 1200, role: 'shooter', behavior: 'hitAndRun' },
      3: { name: 'Giga Slug', hp: 5000, vx: -0.04, fireCD: 2000, role: 'melee', behavior: 'berserker' },
      4: { name: 'War Wyrm', hp: 6000, vx: -0.07, fireCD: 1000, role: 'shooter', behavior: 'aerial' },
      5: { name: 'Twin Colossus', hp: 7000, vx: -0.03, fireCD: 2500, role: 'melee', behavior: 'boss_pattern' },
      6: { name: 'Iron Hydra', hp: 8000, vx: -0.08, fireCD: 800, role: 'shooter', behavior: 'relentless' },
      7: { name: 'Cyber Demon', hp: 9000, vx: -0.1, fireCD: 600, role: 'shooter', behavior: 'berserker' },
      8: { name: 'Void Reaver', hp: 10000, vx: -0.09, fireCD: 1100, role: 'melee', behavior: 'boss_pattern' },
      9: { name: 'Celestial Dragon', hp: 12000, vx: -0.12, fireCD: 900, role: 'shooter', behavior: 'aerial' },
      10: { name: 'Apex Hunter', hp: 15000, vx: -0.15, fireCD: 500, role: 'boss', behavior: 'berserker' }
    };

    // Spawn bosses based on stage. Handles multiple bosses and scaling.
    function spawnBossForStage() {
      // DEPRECATED: Now handled by Boss Pool System
      // This function kept for compatibility but does nothing
      // Boss Pool System handles big boss spawning at wave 9.5
      console.log('Legacy boss spawn called - skipping (using Boss Pool System)');
    }

    /* ================= Enhanced Boss Skills System ================= */
    function useBossSkill(boss) {
      if (!boss.skills || boss.skills.length === 0) return;

      // Use skills in sequence for more predictable patterns
      const skill = boss.skills[boss.skillIndex % boss.skills.length];
      boss.skillIndex++;

      // Enhanced skill effects based on rage mode
      const rageMultiplier = boss.rageMode ? 1.5 : 1.0;
      const stageMultiplier = 1 + (st.stage - 1) * 0.2;

      switch (skill) {
        case 'boss_slam':
          // Enhanced ground slam that hits all lanes with warning
          addCast(boss.x, boss.y, '#ff4d4f');

          // Warning indicators first
          for (let lane = 0; lane < 3; lane++) {
            addCast(boss.x - 100, laneY(lane), '#ffaa00');
          }

          setTimeout(() => {
            for (let lane = 0; lane < 3; lane++) {
              st.shots.push({
                kind: 'boss_slam', x: boss.x - 100, y: laneY(lane), vx: 0, vy: 0,
                dmg: Math.round((30 + st.stage * 8) * rageMultiplier), life: 500, aoe: 150,
                color: '#ff4d4f', ownerId: 'boss'
              });
            }
            addImpact(boss.x - 100, boss.y, '#ff4d4f');
            notify('BOSS SLAM!', '#ff4d4f');
          }, 1200); // 1.2 second warning
          break;

        case 'boss_barrage':
          // Enhanced rapid fire projectiles with better patterns
          addCast(boss.x, boss.y, '#ff6aa8');
          const projectileCount = boss.rageMode ? 12 : 8;

          for (let i = 0; i < projectileCount; i++) {
            setTimeout(() => {
              const angle = (i / projectileCount) * Math.PI * 2;
              const speed = 300 + Math.random() * 200;
              st.eShots.push({
                x: boss.x - 20, y: boss.y - 20,
                vx: Math.cos(angle) * speed * -1,
                vy: Math.sin(angle) * speed,
                life: 4000,
                dmg: Math.round((12 + st.stage * 2) * rageMultiplier),
                color: '#ff6aa8',
                homing: boss.rageMode // Homing in rage mode
              });
            }, i * 150);
          }
          notify('BOSS BARRAGE!', '#ff6aa8');
          break;

        case 'throw_treasure':
          addCast(boss.x, boss.y, '#ffd56a');
          st.pickups.push({
            kind: 'chest',
            chestType: 'treasure',
            x: boss.x - 50,
            y: laneY(Math.floor(Math.random() * 3)),
            life: 20000, // 20 seconds to pick up
            ring: true
          });
          notify('Treasure Toss!', '#ffd56a');
          break;
        case 'boss_summon':
          // Summoning disabled to prevent post-boss enemy spikes
          notify('Boss tries to call reinforcements, but no one answers!', '#8b00ff');
          break;
      }

      // Reduce cooldown in rage mode
      boss.skillCD = boss.rageMode ? 3000 : 5000;
    }

    function createBossMinion(x, y, type, stageMultiplier) {
      const baseHP = 120 * stageMultiplier;

      const minion = {
        kind: 'boss_minion',
        minionType: type,
        x: x, y: y,
        hp: Math.round(baseHP), max: Math.round(baseHP),
        vx: -0.2, fireCD: 1000,
        role: 'melee', behavior: 'relentless'
      };

      switch (type) {
        case 'warrior':
          minion.hp = Math.round(baseHP * 1.5);
          minion.max = minion.hp;
          minion.role = 'melee';
          minion.behavior = 'berserker';
          minion.vx = -0.3;
          break;
        case 'archer':
          minion.role = 'shooter';
          minion.behavior = 'hitAndRun';
          minion.fireCD = 600;
          minion.vx = -0.15;
          break;
        case 'mage':
          minion.hp = Math.round(baseHP * 0.8);
          minion.max = minion.hp;
          minion.role = 'caster';
          minion.behavior = 'support';
          minion.fireCD = 1200;
          minion.vx = -0.1;
          minion.spellCD = 3000;
          break;
      }

      return minion;
    }

    /* ================= Post-Campaign Endless Mode ================= */
    function checkEndlessMode() {
      if (st.area >= 100 && st.wave > st.wavesPerStage && !st.endlessUnlocked) {
        st.endlessUnlocked = true;
        st.endlessMode = true;
        st.stage = 100; // Start endless at stage 100
        st.wave = 1;

        notify('ENDLESS MODE UNLOCKED!', '#ffaa00');
        notify('Stage 100 - Boss Rush Begins!', '#ff4444');
        notify('Every wave is a boss battle!', '#6aa8ff');

        // Reset some stats for endless mode
        st.endlessScore = st.kills * 100 + st.gold + st.gems * 1000;
        st.endlessStartTime = performance.now();

        spawnEndlessWave();
      }
    }

    function spawnEndlessWave() {
      if (!st.endlessMode) return spawnWave();

      // Endless mode: Boss Rush - Every wave is a boss battle!
      const difficultyMultiplier = Math.pow(1.2, st.stage - 100); // 20% increase per stage from 100
      const bossCount = 1 + Math.floor(st.wave / 5); // 1 boss, then 2 bosses every 5 waves

      for (let i = 0; i < bossCount; i++) {
        spawnEndlessBoss(difficultyMultiplier, i);
      }

      // Add elite minions for later waves
      if (st.wave > 5) {
        const minionCount = Math.floor((st.wave - 5) / 3);
        for (let i = 0; i < minionCount; i++) {
          const e = {
            kind: 'elite_minion', x: DESIGN_W + 50 + i * 60, y: laneY(i % 3),
            hp: Math.floor(500 * difficultyMultiplier),
            max: Math.floor(500 * difficultyMultiplier),
            vx: -0.15, role: 'melee', behavior: 'berserker',
            dmg: Math.floor(50 * difficultyMultiplier),
            name: 'Elite Minion',
            fireCD: 800
          };
          st.enemies.push(e);
        }
      }

      // Update endless score
      st.endlessScore += bossCount * 100 + Math.floor(st.wave * 10);
    }

    function spawnEndlessBoss(difficultyMultiplier, bossIndex = 0) {
      const bossHP = Math.floor(3000 * difficultyMultiplier);
      const bossTypes = ['berserker', 'caster', 'tank', 'assassin'];
      const bossType = bossTypes[bossIndex % bossTypes.length];

      const boss = {
        kind: 'endless_boss',
        name: `Endless ${bossType.charAt(0).toUpperCase() + bossType.slice(1)}`,
        x: DESIGN_W - 200 - (bossIndex * 100),
        y: laneY(1 + bossIndex),
        hp: bossHP,
        max: bossHP,
        vx: -0.05,
        fireCD: Math.max(150, 300 - st.stage * 5),
        role: 'boss',
        behavior: 'boss_pattern',
        rageMode: false,
        rageTrigger: 0.3 + (bossIndex * 0.1), // Earlier rage for multiple bosses
        skills: ['boss_slam', 'boss_barrage', 'boss_teleport'],
        skillCD: Math.max(1500, 4000 - st.stage * 80),
        endlessLevel: st.stage - 100,
        bossType: bossType,
        bossIndex: bossIndex
      };

      // Boss type specific modifications
      switch (bossType) {
        case 'berserker':
          boss.vx = -0.08; // Faster
          boss.skills.push('frenzy_attack');
          break;
        case 'caster':
          boss.fireCD = Math.max(100, boss.fireCD * 0.7); // Faster casting
          boss.skills.push('magic_storm', 'teleport');
          break;
        case 'tank':
          boss.hp = Math.floor(boss.hp * 1.5); // More HP
          boss.max = boss.hp;
          boss.skills.push('shield_wall', 'ground_slam');
          break;
        case 'assassin':
          boss.vx = -0.12; // Much faster
          boss.skills.push('stealth_strike', 'poison_dart');
          break;
      }

      st.enemies.push(boss);
      st.bossAlive = true;
      if (bossIndex === 0) {
        st.bossHP = boss.hp;
        st.bossMax = boss.max;
      }

      notify(`${boss.name} LV${boss.endlessLevel}!`, '#ff4d4f');
    }

    /* ================= Daily Quests System ================= */
    function initializeDailyQuests() {
      if (!st.dailyQuests) st.dailyQuests = [];
      if (!st.lastQuestRefresh) st.lastQuestRefresh = 0;
      if (!st.nextQuestRefresh) st.nextQuestRefresh = 0;

      const now = Date.now();
      const dayInMs = 24 * 60 * 60 * 1000;

      // Refresh quests if it's been more than a day
      if (now >= st.nextQuestRefresh) {
        generateDailyQuests();
        st.lastQuestRefresh = now;
        st.nextQuestRefresh = st.lastQuestRefresh + dayInMs;
      }
    }

    // Update the daily quest refresh timer display and refresh quests when the timer expires.
    function updateQuestTimer() {
      try {
        const timerEl = document.getElementById('questTimer');
        if (!timerEl || !st.nextQuestRefresh) return;
        const now = Date.now();
        let remaining = st.nextQuestRefresh - now;
        if (remaining <= 0) {
          // Time to refresh quests
          generateDailyQuests();
          // Setting next refresh time is handled inside generateDailyQuests
          renderQuests();
          return;
        }
        // Format remaining time HH:MM:SS
        const totalSec = Math.floor(remaining / 1000);
        const hrs = Math.floor(totalSec / 3600);
        const mins = Math.floor((totalSec % 3600) / 60);
        const secs = totalSec % 60;
        const parts = [];
        if (hrs > 0) parts.push(`${hrs}h`);
        parts.push(`${mins.toString().padStart(2, '0')}m`);
        parts.push(`${secs.toString().padStart(2, '0')}s`);
        timerEl.textContent = parts.join(' ');
      } catch (ex) { console.error(ex); }
    }

    function generateDailyQuests() {
      st.dailyQuests = [];

      const questTemplates = [
        // Bronze tier quests: simple objectives
        {
          id: 'kill_enemies',
          name: 'Enemy Hunter',
          description: 'Defeat 100 enemies',
          target: 100,
          progress: 0,
          reward: { gold: 500, gems: 10 },
          type: 'kills',
          questType: 'kill',
          metadata: { targetType: 'any', count: 100 },
          tier: 'bronze'
        },
        {
          id: 'reach_stage',
          name: 'Stage Clear',
          description: 'Reach Stage 5',
          target: 5,
          progress: Math.max(1, st.stage),
          reward: { gold: 300, tickets: 5 },
          type: 'stage',
          questType: 'progress',
          metadata: { targetStage: 5 },
          tier: 'bronze'
        },
        {
          id: 'boss_kills',
          name: 'Boss Slayer',
          description: 'Defeat 3 bosses',
          target: 3,
          progress: 0,
          reward: { gems: 25, bossKeys: 2 },
          type: 'bosses',
          questType: 'kill',
          metadata: { targetType: 'boss', count: 3 },
          tier: 'silver'
        },
        {
          id: 'use_skills',
          name: 'Skill Master',
          description: 'Use 50 skills',
          target: 50,
          progress: 0,
          reward: { gold: 200, silver: 100 },
          type: 'skills',
          questType: 'skill',
          metadata: { count: 50 },
          tier: 'bronze'
        },
        {
          id: 'collect_gold',
          name: 'Treasure Hunter',
          description: 'Collect 2000 gold',
          target: 2000,
          progress: 0,
          reward: { gems: 15, giftKeys: 3 },
          type: 'gold',
          questType: 'collect',
          metadata: { resource: 'gold', amount: 2000 },
          tier: 'silver'
        },
        // Additional quests demonstrating specific enemy types and time trials
        {
          id: 'kill_flyers',
          name: 'Skyfall',
          description: 'Defeat 20 flying enemies',
          target: 20,
          progress: 0,
          reward: { gold: 400, gems: 5 },
          type: 'kills',
          questType: 'kill',
          metadata: { targetType: 'flyer', count: 20 },
          tier: 'silver'
        },
        {
          id: 'speed_run_stage3',
          name: 'Speed Runner',
          description: 'Clear Stage 3 within 3 minutes',
          target: 1,
          progress: 0,
          reward: { gold: 800, gems: 25, giftKeys: 2 },
          type: 'timeTrial',
          questType: 'timeTrial',
          metadata: { targetStage: 3, timeLimit: 180000 },
          tier: 'gold'
        }
      ];

      // Pick 3 random quests for today
      for (let i = 0; i < 3; i++) {
        const template = questTemplates[Math.floor(Math.random() * questTemplates.length)];
        const quest = JSON.parse(JSON.stringify(template)); // Deep copy
        quest.id += '_' + Date.now() + '_' + i; // Unique ID
        // Add claimed flag to track reward collection
        quest.claimed = false;
        st.dailyQuests.push(quest);
      }

      notify('Daily Quests Updated!', '#6aa8ff');
      // Set next refresh time 24 hours from now
      const dayInMs = 24 * 60 * 60 * 1000;
      st.lastQuestRefresh = Date.now();
      st.nextQuestRefresh = st.lastQuestRefresh + dayInMs;
    }

    function updateQuestProgress(type, amount = 1, extra = null) {
      if (!st.dailyQuests) return;
      st.dailyQuests.forEach(quest => {
        if (quest.type !== type || quest.completed) return;
        // Additional filtering for kill quests with specific enemy types
        if (quest.questType === 'kill' && quest.metadata && quest.metadata.targetType && quest.metadata.targetType !== 'any') {
          if (extra !== quest.metadata.targetType) return;
        }
        // Update based on quest type semantics
        if (type === 'stage') {
          // For stage progress, use the player's current stage as progress
          quest.progress = Math.min(quest.target, st.stage);
        } else if (type === 'gold') {
          // For gold collection quests, accumulate amount (extra holds collected amount per call)
          quest.progress = Math.min(quest.target, quest.progress + amount);
        } else {
          quest.progress = Math.min(quest.target, quest.progress + amount);
        }
        if (quest.progress >= quest.target && !quest.completed) {
          quest.completed = true;
          notify(`Quest Complete: ${quest.name}!`, '#ffaa00');
        }
      });
    }

    function claimQuestReward(quest) {
      const reward = quest.reward;

      if (reward.gold) { st.gold += reward.gold; }
      if (reward.silver) { st.silver += reward.silver; }
      if (reward.gems) { st.gems += reward.gems; }
      if (reward.tickets) { st.tickets += reward.tickets; }
      if (reward.giftKeys) { st.giftKeys += reward.giftKeys; }
      if (reward.bossKeys) { st.bossKeys += reward.bossKeys; }

      updateCurrencies();
      notify(`Quest Complete: ${quest.name}!`, '#ffaa00');

      // Show rewards
      let rewardText = 'Rewards: ';
      Object.keys(reward).forEach(key => {
        rewardText += `${reward[key]} ${key} `;
      });
      notify(rewardText, '#6aa8ff');

      // Mark as claimed and refresh quests UI
      quest.claimed = true;
      if (typeof renderQuests === 'function') renderQuests();
    }

    // Check time trial quests to see if the player completed a stage within the time limit.
    function checkTimeTrials() {
      try {
        if (!st.dailyQuests) return;
        const now = Date.now();
        st.dailyQuests.forEach(quest => {
          if (quest.questType === 'timeTrial' && !quest.completed) {
            const meta = quest.metadata || {};
            if (st.stage >= (meta.targetStage || 0) && st.stageStartTime) {
              const elapsed = now - st.stageStartTime;
              if (elapsed <= (meta.timeLimit || 0)) {
                quest.progress = quest.target;
                quest.completed = true;
                notify(`Quest Complete: ${quest.name}!`, '#ffaa00');
              }
            }
          }
        });
      } catch (ex) { console.error(ex); }
    }

    /* ================= Action Toys System ================= */
    // Action Toys: Rocket Launcher, Lightsaber, Wild Pet Token (20-30s duration)
    st.currentActionToy = null;
    st.actionToyDuration = 0;
    st.actionToyCooldown = 0;

    const ACTION_TOYS = {
      rocket: {
        name: 'Rocket Launcher',
        duration: () => 20000 + Math.random() * 10000, // 20-30s
        cooldown: 5000,
        color: '#ff6600',
        effect: 'splash_damage'
      },
      lightsaber: {
        name: 'Lightsaber',
        duration: () => 20000 + Math.random() * 10000, // 20-30s
        cooldown: 5000,
        color: '#00ff00',
        effect: 'extended_melee'
      },
      wildpet: {
        name: 'Wild Pet',
        duration: () => 999999, // Effectively stage-long
        cooldown: 8000,
        color: '#ff9900',
        effect: 'summon_ally',
        stageLong: true
      }
    };

    function useActionToy(toyType) {
      const energyCost = 40; // Action Toys cost 40 energy
      if (st.sharedEnergy.current < energyCost) {
        notify("Not enough energy!", "#ff7a6a");
        return false;
      }

      if (!ACTION_TOYS[toyType]) return false;
      if (st.actionToyCooldown > 0) {
        notify('Action Toy on cooldown!', '#ff7a6a');
        return false;
      }

      // Clear existing toy (no stacking)
      if (st.currentActionToy) {
        deactivateActionToy();
      }

      st.sharedEnergy.current -= energyCost;
      const toy = ACTION_TOYS[toyType];
      st.currentActionToy = toyType;
      const duration = toy.duration();
      st.actionToyDuration = duration;
      st.actionToyMaxDuration = duration; // Store the max duration
      st.actionToyCooldown = toy.cooldown;

      if (toy.stageLong) {
        st.stageLongToyActive = true;
      }

      notify(`${toy.name} activated!`, toy.color);
      activateActionToyEffect(toyType);

      return true;
    }

    function activateActionToyEffect(toyType) {
      const L = leader();
      if (!L) return;

      switch (toyType) {
        case 'rocket':
          // Rocket Launcher: high splash damage, staggers enemies
          L._rocketMode = true;
          L._rocketCharges = 10; // Limited charges
          addCast(L.x, L.y, '#ff6600');
          break;

        case 'lightsaber':
          // Lightsaber: extended melee arc, pierces, reflects bullets
          L._lightsaberMode = true;
          addCast(L.x, L.y, '#00ff00');
          // Enhanced melee range and effects
          L._enhancedMeleeRange = 2.0; // 2x range multiplier
          break;

        case 'wildpet':
          // Wild Pet: summon powerful ally for one wave
          spawnWildPetAlly(L);
          st.currentActionToy = null; // Instant use, doesn't persist
          st.actionToyDuration = 0;
          break;
      }
    }

    function spawnWildPetAlly(owner) {
      const wildPet = {
        id: 'wild_pet_' + Date.now(),
        x: owner.x - 60,
        y: owner.y,
        hp: 300,
        hpMax: 300,
        dmg: Math.round(owner.dmg * 2),
        kind: 'wild_pet',
        owner: owner.id,
        atkCD: 0,
        life: 999999, // Lasts until wave ends
        isAlly: true
      };

      st.enemies.push(wildPet); // Add to enemies array but mark as ally
      addCast(wildPet.x, wildPet.y, '#ff9900');
      notify('Wild Pet summoned!', '#ff9900');
    }

    function updateActionToys(dtMs) {
      // Update action toy cooldown
      if (st.actionToyCooldown > 0) {
        st.actionToyCooldown -= dtMs;
      }

      // Update active action toy duration
      if (st.currentActionToy && st.actionToyDuration > 0) {
        st.actionToyDuration -= dtMs;

        if (st.actionToyDuration <= 0) {
          deactivateActionToy();
        }
      }
    }

    function deactivateActionToy() {
      if (!st.currentActionToy) return;

      const L = leader();
      if (L) {
        // Remove toy effects
        L._rocketMode = false;
        L._rocketCharges = 0;
        L._lightsaberMode = false;
        L._enhancedMeleeRange = 1.0;
      }

      notify(`${ACTION_TOYS[st.currentActionToy].name} expired`, '#888888');
      st.currentActionToy = null;
      st.actionToyDuration = 0;
    }

    function useRocketLauncher(player, targetX, targetY) {
      if (!player._rocketMode || player._rocketCharges <= 0) return false;

      player._rocketCharges--;

      // Create rocket projectile
      st.shots.push({
        kind: 'rocket',
        x: player.x + 20,
        y: player.y - 30,
        vx: 400,
        vy: 0,
        dmg: Math.round(player.dmg * 3),
        life: 2000,
        aoe: 120, // Large splash area
        color: '#ff6600',
        ownerId: player.id,
        explosive: true,
        breaksProps: true // Can break fragile props
      });

      addCast(player.x, player.y, '#ff6600');

      if (player._rocketCharges <= 0) {
        notify('Rocket ammo depleted!', '#ff7a6a');
      }

      return true;
    }

    function useLightsaber(player) {
      if (!player._lightsaberMode) return false;

      const reach = 80 * (player._enhancedMeleeRange || 1);
      const height = 80 * (player._enhancedMeleeRange || 1);

      // Extended melee with piercing
      performMelee(player, reach, height, Math.round(player.dmg * 1.5));

      // Reflect bullets during swing
      for (let i = st.eShots.length - 1; i >= 0; i--) {
        const shot = st.eShots[i];
        if (shot && Math.abs(shot.x - player.x) < reach && Math.abs(shot.y - player.y) < height / 2) {
          // Remove original bullet
          st.eShots.splice(i, 1);

          // Create reflected bullet
          st.shots.push({
            x: shot.x,
            y: shot.y,
            vx: -shot.vx * 2,
            vy: -shot.vy * 2,
            dmg: Math.round(player.dmg * 0.8),
            life: 2000,
            color: '#00ff88',
            pierce: 5,
            ownerId: player.id,
            w: 25, // Large reflected bullet
            h: 25
          });

          addImpact(shot.x, shot.y, '#00ff88');
        }
      }

      // Lightsaber trail effect
      st.effects.push({
        kind: 'beam',
        x1: player.x,
        y1: player.y - 30,
        x2: player.x + reach,
        y2: player.y - 30,
        color: '#00ff88',
        life: 300,
        max: 300,
        thick: 8
      });

      return true;
    }

    /* ================= Chest Trio Event System ================= */
    function spawnChestTrio() {
      // Spawn three chests: Gold, Weapon, and one Mimic
      const chestPositions = [
        { x: 200, y: laneY(0) },
        { x: 400, y: laneY(1) },
        { x: 600, y: laneY(2) }
      ];

      // Randomize which chest is the mimic
      const mimicIndex = Math.floor(Math.random() * 3);

      chestPositions.forEach((pos, index) => {
        let chestType;
        if (index === mimicIndex) {
          chestType = 'mimic';
        } else if (index === 0 && mimicIndex !== 0) {
          chestType = 'gold';
        } else if (index === 1 && mimicIndex !== 1) {
          chestType = 'weapon';
        } else {
          chestType = index === 2 && mimicIndex !== 2 ? 'gold' : 'weapon';
        }

        st.pickups.push({
          kind: 'chest',
          chestType: chestType,
          x: pos.x,
          y: pos.y,
          life: 60000, // 1 minute to interact
          opened: false
        });
      });

      notify('Chest Trio appeared!', '#ffd56a');
    }

    function openChest(chest) {
      if (chest.opened) return;
      chest.opened = true;

      const L = leader();
      if (!L) return;

      switch (chest.chestType) {
        case 'gold':
          // Gold chest: currency plus chance at gifts
          const goldAmount = 300 + Math.floor(Math.random() * 700);
          st.gold += goldAmount;
          updateCurrencies();
          addFloater(chest.x, chest.y - 30, `+${goldAmount} Gold`, '#ffd56a');

          if (Math.random() < 0.3) {
            st.giftKeys += 1;
            addFloater(chest.x, chest.y - 50, '+1 Gift Key', '#ff9aa8');
          }

          notify('Gold Chest opened!', '#ffd56a');
          break;

        case 'weapon':
          // Weapon chest: grants action toy
          const toyTypes = ['rocket', 'lightsaber'];
          const randomToy = toyTypes[Math.floor(Math.random() * toyTypes.length)];

          // Add toy to inventory or activate immediately
          if (useActionToy(randomToy)) {
            addFloater(chest.x, chest.y - 30, `${ACTION_TOYS[randomToy].name}!`, ACTION_TOYS[randomToy].color);
          }

          notify('Weapon Chest opened!', '#6aa8ff');
          break;

        case 'mimic':
          // Mimic: brief stun, spawn enemy, small consolation reward
          notify('MIMIC!', '#ff4d4f');

          // Stun player briefly
          if (L) {
            L._stunned = 800; // 0.8 second stun
            addFloater(L.x, L.y - 50, 'STUNNED!', '#ff4d4f');
          }

          // Spawn mimic enemy
          const mimicEnemy = {
            kind: 'mimic_spawn',
            x: chest.x + 30,
            y: chest.y,
            hp: 150,
            max: 150,
            vx: -0.2,
            vy: 0,
            fireCD: 1000,
            role: 'melee',
            behavior: 'berserker'
          };
          st.enemies.push(mimicEnemy);

          // Small consolation reward
          const consolationGold = 50 + Math.floor(Math.random() * 100);
          st.gold += consolationGold;
          updateCurrencies();
          addFloater(chest.x, chest.y - 30, `+${consolationGold} Gold`, '#ffd56a');

          // Visual effects
          addImpact(chest.x, chest.y, '#ff4d4f');
          st.effects.push({
            kind: 'cast',
            x: chest.x,
            y: chest.y - 40,
            color: '#ff4d4f',
            life: 500,
            max: 500
          });
          break;

        case 'supply':
          // Supply chest: heal party and give minor reward
          const healAmt2 = 200 + st.stage * 50;
          st.players.forEach(p => {
            if (!p.isDefeated) {
              p.hp = Math.min(p.hpMax || 0, (p.hp || 0) + healAmt2);
              addFloater(p.x, p.y - 40, '+' + healAmt2 + ' HP', '#36c777');
            }
          });
          // Chance to drop gift key or extra gold
          if (Math.random() < 0.5) {
            st.giftKeys++;
            updateCurrencies();
            addFloater(chest.x, chest.y - 50, '+Gift Key', '#ff9aa8');
          } else {
            const extraGold2 = 100 + Math.floor(Math.random() * 200);
            st.gold += extraGold2;
            updateCurrencies();
            addFloater(chest.x, chest.y - 50, '+' + extraGold2 + ' Gold', '#ffd56a');
          }
          notify('Supply Chest opened!', '#6aa8ff');
          break;
        case 'victory':
          // Victory chest: large reward
          const bigGold2 = 500 + st.stage * 200;
          st.gold += bigGold2;
          updateCurrencies();
          addFloater(chest.x, chest.y - 30, '+' + bigGold2 + ' Gold', '#ffd56a');
          const reward2 = rollLoot('bossChest');
          if (reward2) { addItemToBag(reward2); notify('Victory Loot: ' + reward2.name); }
          st.giftKeys += 2;
          updateCurrencies();
          notify('Victory Chest opened!', '#ffbb9a');
          break;
        case 'treasure':
          // Treasure chest: gives gold and a chance at a gem
          const gold = 200 + Math.floor(Math.random() * 300);
          st.gold += gold;
          updateCurrencies();
          addFloater(chest.x, chest.y - 30, '+' + gold + ' Gold', '#ffd56a');
          if (Math.random() < 0.1) {
            st.gems++;
            updateCurrencies();
            addFloater(chest.x, chest.y - 50, '+1 Gem', '#6aa8ff');
          }
          notify('Treasure Chest opened!', '#ffd56a');
          break;
      }

      // Remove chest after opening
      const chestIndex = st.pickups.indexOf(chest);
      if (chestIndex > -1) {
        st.pickups.splice(chestIndex, 1);
      }
    }

    /* ================= Party Potion System ================= */
    st.partyPotionCooldown = 0;
    st.partyPotionAutoTriggerThreshold = 0.4; // 40% average HP

    function usePartyPotion() {
      if (st.partyPotionCooldown > 0) {
        notify('Party Potion on cooldown!', '#ff7a6a');
        return false;
      }

      // Heal all non-defeated players to full HP
      let healedCount = 0;
      st.players.forEach(p => {
        if (!p.isDefeated) {
          const healAmount = p.hpMax - p.hp;
          if (healAmount > 0) {
            p.hp = p.hpMax;
            addFloater(p.x, p.y - 50, 'FULL HEAL!', '#36c777');
            healedCount++;
          }
        }
      });

      if (healedCount > 0) {
        // Start 30 second team cooldown
        st.partyPotionCooldown = 30000;
        notify('Party Potion used! Team fully healed.', '#36c777');

        // Visual effect
        st.players.forEach(p => {
          if (!p.isDefeated) {
            st.effects.push({
              kind: 'cast',
              x: p.x,
              y: p.y - 60,
              color: '#36c777',
              life: 800,
              max: 800
            });
          }
        });

        return true;
      }

      return false;
    }

    function checkAutoPartyPotion() {
      if (st.partyPotionCooldown > 0) return;

      // Calculate average team HP
      const aliveTeam = st.players.filter(p => !p.isDefeated);
      if (aliveTeam.length === 0) return;

      const avgHP = aliveTeam.reduce((sum, p) => sum + (p.hp / p.hpMax), 0) / aliveTeam.length;

      if (avgHP <= st.partyPotionAutoTriggerThreshold) {
        usePartyPotion();
        notify('Auto Party Potion triggered!', '#ffaa00');
      }
    }

    function updatePartyPotion(dtMs) {
      if (st.partyPotionCooldown > 0) {
        st.partyPotionCooldown -= dtMs;
      }

      // Check for auto-trigger every 500ms
      if (!st._lastPotionCheck) st._lastPotionCheck = 0;
      st._lastPotionCheck += dtMs;

      if (st._lastPotionCheck >= 500) {
        checkAutoPartyPotion();
        st._lastPotionCheck = 0;
      }
    }

    /* ================= Drop Rate Ramp System ================= */
    st.baseDropRate = 0.08; // 8% base
    st.dropRateBonus = 0; // +0.1% per kill
    st.baseDropRate = st.baseDropRate || 0.1;
    st.maxDropRateBonus = 0.22; // Cap at +22%

    function updateDropRate() {
      // Display live drop rate in HUD
      const luckBoost = ((st._usLuck || 0) * 0.001);
      const dropBonus = (st.npcSkillEffects?.dropBonus || 0);
      const currentDropRate = Math.round((st.baseDropRate + st.dropRateBonus + luckBoost + dropBonus) * 100);
      const dropDisplay = document.getElementById('dropRateDisplay');
      if (!dropDisplay) {
        // Create drop rate display in currency bar
        const currencyDiv = document.getElementById('currency');
        if (currencyDiv) {
          const dropPill = document.createElement('div');
          dropPill.className = 'pill';
          dropPill.id = 'dropRateDisplay';
          dropPill.style.pointerEvents = 'auto';
          dropPill.innerHTML = `Drop Rate: <b>${currentDropRate}%</b>`;
          currencyDiv.appendChild(dropPill);
        }
      } else {
        dropDisplay.innerHTML = `Drop Rate: <b>${currentDropRate}%</b>`;
      }
    }

    // Combo HUD pill (ensures presence and keeps it in sync)
    function updateComboHUD() {
      try {
        const currencyDiv = document.getElementById('currency');
        if (!currencyDiv) return;
        let pill = document.getElementById('comboPill');
        const combo = st.comboSystem || { currentCombo: 0, comboMultiplier: 1, maxCombo: 0 };
        const mult = (combo.comboMultiplier || 1);
        const multTxt = mult.toFixed(2) + 'x';
        const txt = `Combo: <b>${combo.currentCombo | 0}</b> • Max: <b>${combo.maxCombo | 0}</b> • Mult: <b>${multTxt}</b>`;
        if (!pill) {
          pill = document.createElement('div');
          pill.id = 'comboPill';
          pill.className = 'pill';
          pill.style.pointerEvents = 'auto';
          pill.title = 'Defeating enemies quickly increases combo and XP gain';
          pill.innerHTML = txt;
          currencyDiv.appendChild(pill);
        } else {
          pill.innerHTML = txt;
        }
      } catch (_e) { /* ignore HUD errors */ }
    }

    function showComboLostFX() {
      try {
        const currencyDiv = document.getElementById('currency');
        if (!currencyDiv) return;
        const fx = document.createElement('div');
        fx.className = 'pill';
        fx.textContent = 'Combo Lost';
        fx.style.opacity = '1';
        fx.style.transition = 'opacity .35s ease';
        fx.style.marginLeft = '6px';
        fx.style.background = '#2a2436';
        fx.style.border = '1px solid #8844aa';
        currencyDiv.appendChild(fx);
        // Fade out shortly after adding
        setTimeout(() => { fx.style.opacity = '0'; }, 20);
        setTimeout(() => { fx.remove(); }, 600);
      } catch (_e) { }
    }
    st.universalActionButtonState = 'IDLE'; // Add new state property
    st.universalActionTarget = null;
    st.stageLongToyActive = false; // Placeholder for stage-long toys

    function updateUniversalActionButton() {
      // Prefer the small joystick-side button; fall back to big ACTION if needed
      const btn = document.getElementById('btnActionNew') || document.getElementById('btnUniversalAction');
      const ringFg = document.getElementById('duration-ring-fg');
      const ringContainer = btn ? btn.parentElement.querySelector('.duration-ring') : null;
      const L = leader();

      if (!btn) return;

      const circumference = ringFg ? 2 * Math.PI * 42 : 0;
      const resetRing = () => {
        if (ringFg && ringContainer) {
          ringFg.style.strokeDasharray = `${circumference}`;
          ringFg.style.strokeDashoffset = `${circumference}`;
          ringContainer.style.display = 'none';
        }
      };

      if (!L || L.isDefeated) {
        btn.style.display = 'none';
        resetRing();
        return;
      }

      btn.style.display = 'flex';

      // 1. Check for USE state (Action Toy active)
      if (st.currentActionToy && st.actionToyDuration > 0) {
        const toy = ACTION_TOYS[st.currentActionToy];
        btn.textContent = 'USE';
        btn.style.backgroundColor = toy.color;
        st.universalActionButtonState = 'USE';

        // Update duration ring
        if (ringFg && ringContainer) {
          const progress = Math.max(0, st.actionToyDuration / st.actionToyMaxDuration);
          ringFg.style.strokeDashoffset = circumference * (1 - progress);
          ringContainer.style.display = 'block';
        }
        return;
      } else {
        resetRing();
      }

      // 2. Check for COOLDOWN state
      if (st.actionToyCooldown > 0) {
        const cooldownLeft = Math.ceil(st.actionToyCooldown / 1000);
        btn.textContent = `${cooldownLeft}s`;
        btn.style.backgroundColor = '#555';
        st.universalActionButtonState = 'COOLDOWN';
        return;
      }

      // 3. Check for LOCKED state
      if (st.stageLongToyActive) {
        btn.textContent = 'LOCKED';
        btn.style.backgroundColor = '#333';
        st.universalActionButtonState = 'LOCKED';
        return;
      }

      // 4. Check for interactables
      const interactables = findNearbyInteractables(L);
      if (interactables.weapons.length > 0) {
        btn.textContent = 'Equip';
        btn.style.backgroundColor = 'var(--pastel-attack)';
        st.universalActionButtonState = 'EQUIP';
        st.universalActionTarget = interactables.weapons[0];
        return;
      }
      if (interactables.chests.length > 0) {
        const target = interactables.chests[0];
        if ((target.kind === 'exit_gate' || target.kind === 'wave_gate') && target.opened) {
          btn.textContent = target.kind === 'wave_gate' ? 'Next' : 'Exit';
          btn.style.backgroundColor = target.kind === 'wave_gate' ? '#36c777' : 'var(--hp)';
          st.universalActionButtonState = target.kind === 'wave_gate' ? 'NEXTWAVE' : 'EXIT';
          st.universalActionTarget = target;
        } else {
          btn.textContent = 'Open';
          btn.style.backgroundColor = 'var(--pastel-pet)';
          st.universalActionButtonState = 'OPEN';
          st.universalActionTarget = target;
        }
        return;
      }

      if (interactables.pickups.length > 0) {
        btn.textContent = 'Pick';
        btn.style.backgroundColor = 'var(--pastel-action)';
        st.universalActionButtonState = 'PICK';
        st.universalActionTarget = interactables.pickups[0];
        return;
      }

      // 6. Default IDLE state
      btn.textContent = 'Act';
      btn.style.backgroundColor = 'var(--panel2)';
      st.universalActionButtonState = 'IDLE';
    }

    function performUniversalAction() {
      const L = leader();
      if (!L || L.isDefeated) return;

      switch (st.universalActionButtonState) {
        case 'USE':
          if (st.currentActionToy) {
            switch (st.currentActionToy) {
              case 'rocket':
                if (L._rocketMode) useRocketLauncher(L, L.x + 200, L.y);
                break;
              case 'lightsaber':
                if (L._lightsaberMode) useLightsaber(L);
                break;
            }
          }
          break;
        case 'EQUIP':
          if (st.universalActionTarget) {
            equipWeapon(st.universalActionTarget);
            st.universalActionTarget = null;
          }
          break;
        case 'OPEN':
          if (st.universalActionTarget) {
            openChest(st.universalActionTarget);
            st.universalActionTarget = null;
          }
          break;
        case 'PICK':
          if (st.universalActionTarget) {
            pickupItem(st.universalActionTarget);
            st.universalActionTarget = null;
          }
          break;
        case 'EQUIP':
          if (st.universalActionTarget) {
            equipWeapon(st.universalActionTarget);
            st.universalActionTarget = null;
          }
          break;
      }
    }

    function equipWeapon(weaponPickup) {
      let weapon;
      switch (weaponPickup.weaponType) {
        case 'sword':
          weapon = makeGear('Iron Sword', 'weapon', { atk: 15 });
          break;
        case 'axe':
          weapon = makeGear('Battle Axe', 'weapon', { atk: 20 });
          break;
        case 'bow':
          weapon = makeGear('Hunting Bow', 'weapon', { atk: 12 });
          break;
        default:
          return; // Unknown weapon type
      }

      st.equippedGear = st.equippedGear || {};
      if (!st.equippedGear.weapon) {
        st.equippedGear.weapon = weapon;
      } else if (!st.equippedGear.weapon2) {
        st.equippedGear.weapon2 = weapon;
      } else {
        addItemToBag(st.equippedGear.weapon);
        st.equippedGear.weapon = weapon;
      }
      recalcStats();
      notify(`Equipped ${weapon.name}!`);

      // Remove the pickup from the world
      const index = st.pickups.indexOf(weaponPickup);
      if (index > -1) st.pickups.splice(index, 1);
    }

    function pickupItem(item) {
      // Add item to bag and remove from world
      if (item.itemData) {
        addItemToBag(item.itemData);
        notify(`Picked up ${item.itemData.name}!`);
      }
      const index = st.pickups.indexOf(item);
      if (index > -1) st.pickups.splice(index, 1);
    }

    function activateSwitch(player, switch_) {
      if (switch_.activated && switch_.singleUse) {
        notify('Switch already activated', '#888888');
        return;
      }

      switch_.activated = !switch_.activated;

      if (switch_.switchType === 'treasure' && switch_.activated) {
        // Spawn treasure chest
        st.pickups.push({
          kind: 'chest',
          chestType: 'treasure',
          x: switch_.x + 100,
          y: switch_.y,
          life: 60000
        });
        notify('Treasure chest appeared!', '#ffd56a');
      } else if (switch_.switchType === 'platform' && switch_.activated) {
        // Could spawn platforms in platform mode
        notify('Platform activated!', '#6aa8ff');
      }

      addCast(switch_.x, switch_.y, switch_.activated ? '#36c777' : '#ff9aa8');
    }

    function findNearbyInteractables(player) {
      const range = 100; // Increased range for easier interaction
      const result = {
        chests: [], vehicles: [], pets: [], throwables: [],
        ladders: [], stunnedEnemies: [], switches: [],
        pickups: [], weapons: []
      };

      // Check pickups for chests, pets, etc.
      for (const pickup of st.pickups) {
        if (pickup.life <= 0) continue;
        const dist = Math.hypot(pickup.x - player.x, pickup.y - player.y);
        if (dist < range) {
          if (pickup.kind === 'chest') {
            // Handle treasure chests specially
            if (pickup.chestType === 'treasure' && !pickup._opened) {
              openTreasureChest(pickup, player);
            }
            result.chests.push(pickup);
          } else if (pickup.kind === 'pickup') { // Generic pickup type
            result.pickups.push(pickup);
          } else if (pickup.kind === 'equipment') {
            result.equipment = result.equipment || [];
            result.equipment.push(pickup);
          } else if (pickup.kind === 'pet') {
            result.pets.push(pickup);
          } else if (pickup.kind === 'ladder') {
            result.ladders.push(pickup);
          } else if (pickup.kind === 'switch') {
            result.switches.push(pickup);
          } else if (pickup.throwable) {
            result.throwables.push(pickup);
          } else if (pickup.kind === 'weapon') {
            result.weapons.push(pickup);
          } else if (pickup.kind === 'exit_gate' || pickup.kind === 'wave_gate') {
            result.chests.push(pickup); // Treat it like a chest for interaction
          }
        }
      }

      // Check for vehicles (if implemented)
      if (st.vehicles) {
        for (const vehicle of st.vehicles) {
          const dist = Math.hypot(vehicle.x - player.x, vehicle.y - player.y);
          if (dist < range) {
            result.vehicles.push(vehicle);
          }
        }
      }

      // Check for treasure chests with special handling
      for (const pickup of st.pickups) {
        if (pickup.kind === 'chest' && pickup.chestType === 'treasure') {
          const dist = Math.hypot(pickup.x - player.x, pickup.y - player.y);
          if (dist < range && !pickup._opened) {
            result.treasureChests = result.treasureChests || [];
            result.treasureChests.push(pickup);
          }
        }
      }

      // Check for stunned enemies
      for (const enemy of st.enemies) {
        if (enemy.hp > 0 && enemy._stunned > 0) {
          const dist = Math.hypot(enemy.x - player.x, enemy.y - player.y);
          if (dist < range) {
            result.stunnedEnemies.push(enemy);
          }
        }
      }

      return result;
    }

    /* ================= Enhanced Interactive Objects ================= */
    function climbLadder(player, ladder) {
      // Move player up/down based on ladder direction
      if (ladder.direction === 'up') {
        player.y -= 100;
        notify(player.id + ' climbed up!', '#6aa8ff');
      } else {
        player.y += 100;
        notify(player.id + ' climbed down!', '#6aa8ff');
      }

      // Remove ladder use or make it multi-use
      if (ladder.singleUse) {
        const idx = st.pickups.indexOf(ladder);
        if (idx >= 0) st.pickups.splice(idx, 1);
      }
    }

    function grabAndThrowEnemy(player, enemy) {
      // Create a thrown enemy projectile
      enemy.stunned = false; // Remove stun
      enemy.hp = 0; // Kill the enemy

      // Create projectile
      st.shots.push({
        kind: 'thrown_enemy',
        x: player.x + 20,
        y: player.y - 30,
        vx: 600,
        vy: -150,
        dmg: Math.round(player.dmg * 2),
        life: 3000,
        w: 40,
        h: 40,
        color: '#ff6e6e',
        gravity: true,
        aoe: 60,
        ownerId: player.id
      });

      notify('Enemy thrown!', '#ff6aa8');
      onEnemyKilled(enemy); // Grant rewards
    }

    function activateSwitch(player, switch_) {
      if (switch_.activated) return;

      switch_.activated = true;
      switch_.activatedBy = player.id;

      // Switch effects based on type
      switch (switch_.switchType) {
        case 'door':
          // Open door (would need door system)
          notify('Door opened!', '#6aa8ff');
          break;
        case 'platform':
          // Activate moving platform
          notify('Platform activated!', '#6aa8ff');
          break;
        case 'treasure':
          // Spawn treasure
          spawnTreasureRoom();
          notify('Secret treasure revealed!', '#ffd56a');
          break;
        case 'teleporter':
          // Teleport player
          teleportPlayer(player, switch_.destination);
          break;
        default:
          notify('Switch activated!', '#6aa8ff');
      }

      // Visual feedback
      addCast(switch_.x, switch_.y, '#6aa8ff');

      // Remove switch if single use
      if (switch_.singleUse) {
        const idx = st.pickups.indexOf(switch_);
        if (idx >= 0) st.pickups.splice(idx, 1);
      }
    }

    function teleportPlayer(player, destination) {
      if (!destination) return;

      // Teleport effect
      addCast(player.x, player.y, '#8b00ff');

      player.x = destination.x || player.x;
      player.y = destination.y || player.y;

      addCast(player.x, player.y, '#8b00ff');
      notify(player.id + ' teleported!', '#8b00ff');
    }

    function spawnTreasureRoom() {
      // Visual effects for treasure room activation
      addCast(400, laneY(1), '#ffd700', 2000);
      addCast(500, laneY(1), '#ffd700', 2000);
      addCast(600, laneY(1), '#ffd700', 2000);

      // Treasure chest types with different rarities
      const chestTypes = [
        { type: 'legendary', color: '#ff6b35', multiplier: 3, glow: true },
        { type: 'epic', color: '#8b00ff', multiplier: 2, glow: true },
        { type: 'rare', color: '#0080ff', multiplier: 1.5, glow: false }
      ];

      // Spawn treasure chests with variety
      for (let i = 0; i < 3; i++) {
        const chestData = chestTypes[i] || chestTypes[2];
        const chest = {
          kind: 'chest',
          x: 400 + i * 100,
          y: laneY(1) - 10,
          life: 45000, // Longer lasting
          chestType: 'treasure',
          rarity: chestData.type,
          rewardMultiplier: chestData.multiplier,
          glowing: chestData.glow,
          color: chestData.color,
          throwable: false,
          _sparkleTimer: 0
        };
        st.pickups.push(chest);
      }

      // Spawn bonus items around treasure area
      const bonusItems = [
        { kind: 'pickup', type: 'gem_large', value: 25, x: 350, y: laneY(0) },
        { kind: 'pickup', type: 'gem_large', value: 25, x: 650, y: laneY(2) },
        { kind: 'pickup', type: 'key_special', value: 3, x: 500, y: laneY(0) - 20 }
      ];

      bonusItems.forEach(item => {
        st.pickups.push({
          ...item,
          life: 30000,
          throwable: false,
          _glowTimer: 0
        });
      });

      // Immediate currency rewards
      const baseGems = 50;
      const baseKeys = 5;
      const bonusGems = Math.floor(Math.random() * 30) + 20; // 20-49 bonus
      const bonusKeys = Math.floor(Math.random() * 3) + 2;   // 2-4 bonus

      st.gems += baseGems + bonusGems;
      st.giftKeys += baseKeys + bonusKeys;

      // Rare chance for premium currency
      if (Math.random() < 0.3) {
        st.premiumCurrency = (st.premiumCurrency || 0) + Math.floor(Math.random() * 5) + 1;
        notify('Bonus Premium Currency!', '#ff1493');
      }

      updateCurrencies();

      // AI-style treasure room notifications
      aiNotify('🏆 ANOMALOUS ENERGY SIGNATURE DETECTED', '#ffd700');
      setTimeout(() => aiNotify('🔍 SCANNING... TREASURE VAULT IDENTIFIED', '#00ffff'), 300);
      setTimeout(() => aiNotify(`💎 RESOURCE ACQUISITION: +${baseGems + bonusGems} GEMS | 🗝️ +${baseKeys + bonusKeys} KEYS`, '#00ff88'), 800);
      setTimeout(() => aiNotify('📡 TREASURE ROOM SYSTEMS ONLINE', '#4CAF50'), 1200);

      // Spawn protective waves with equipment rewards
      if (Math.random() < 0.4) {
        spawnTreasureGuardians();
      } else {
        aiNotify('🛡️ TREASURE UNGUARDED - Claim rewards quickly!', '#00ff88');
        // Bonus equipment for unguarded treasure
        if (Math.random() < 0.6) {
          const bonusRarity = Math.random() < 0.3 ? 'epic' : 'rare';
          setTimeout(() => spawnRandomEquipment(500, laneY(0) - 40, bonusRarity), 1000);
        }
      }
    }

    function spawnTreasureGuardians() {
      const waveCount = 2; // Fixed 2 waves to prevent crashes
      let currentWave = 0;

      function spawnGuardianWave() {
        currentWave++;
        const enemiesPerWave = Math.floor(Math.random() * 6) + 5; // 5-10 enemies per wave

        for (let i = 0; i < enemiesPerWave; i++) {
          const guardian = {
            kind: 'guardian',
            x: 200 + Math.random() * 600,
            y: laneY(Math.floor(Math.random() * 3)),
            hp: 50 + (currentWave * 15),
            hpMax: 50 + (currentWave * 15),
            dmg: 15 + (currentWave * 3),
            speed: 0.8 + (currentWave * 0.1),
            ai: 'guardian',
            guardRadius: 120,
            centerX: 500,
            centerY: laneY(1),
            color: '#8b4513',
            rewardMultiplier: 1.2 + (currentWave * 0.3),
            wave: currentWave
          };
          st.enemies.push(guardian);
        }

        notify(`⚔️ Wave ${currentWave}/${waveCount} - ${enemiesPerWave} Guardians!`, '#ff4500');

        // Schedule next wave with simpler logic
        if (currentWave < waveCount) {
          setTimeout(() => {
            const remaining = st.enemies.filter(e => e.kind === 'guardian').length;
            if (remaining <= 2) {
              spawnGuardianWave();
            } else {
              setTimeout(spawnGuardianWave, 1500);
            }
          }, 2500);
        }
      }

      notify(`🏰 ${waveCount} Guardian Waves - Simplified!`, '#ff4500');
      spawnGuardianWave();
    }

    /* ================== Enhanced Treasure System ================== */
    function openTreasureChest(chest, player) {
      if (!chest || chest._opened) return;

      chest._opened = true;
      const multiplier = chest.rewardMultiplier || 1;

      // Base rewards scaled by rarity
      const baseGold = Math.floor((Math.random() * 100 + 50) * multiplier);
      const baseGems = Math.floor((Math.random() * 20 + 10) * multiplier);

      st.gold += baseGold;
      st.gems += baseGems;

      // Rare item chance based on chest rarity
      let itemChance = 0.3;
      if (chest.rarity === 'epic') itemChance = 0.5;
      if (chest.rarity === 'legendary') itemChance = 0.8;

      if (Math.random() < itemChance) {
        spawnRandomEquipment(chest.x, chest.y - 30, chest.rarity);
      }

      // Enhanced visual effects with particle burst
      addCast(chest.x, chest.y, chest.color || '#ffd700', 2000);
      addCast(chest.x - 20, chest.y - 10, '#ffffff', 1000);
      addCast(chest.x + 20, chest.y - 10, '#ffffff', 1000);

      // Screen shake for legendary chests
      if (chest.rarity === 'legendary') {
        // Add screen shake effect (if implemented)
        addCast(chest.x, chest.y - 30, '#ff6b35', 3000);
      }

      // AI-style progressive notifications
      const rarityEmoji = {
        'common': '📦',
        'rare': '🎁',
        'epic': '💜',
        'legendary': '👑'
      }[chest.rarity] || '📦';

      // Initial chest opening notification
      notify(`${rarityEmoji} ${chest.rarity.toUpperCase()} CHEST ACCESSED`, chest.color || '#ffd700');

      // Delayed reward analysis
      setTimeout(() => {
        notify(`🔍 ANALYZING CONTENTS...`, '#00ffff');
      }, 300);

      // Reward breakdown with AI commentary
      setTimeout(() => {
        const totalValue = baseGold + (baseGems * 2); // Gems worth 2x gold
        let commentary = '';

        if (totalValue > 200) commentary = ' [EXCEPTIONAL HAUL]';
        else if (totalValue > 150) commentary = ' [VALUABLE FIND]';
        else if (totalValue > 100) commentary = ' [DECENT REWARDS]';
        else commentary = ' [STANDARD LOOT]';

        notify(`💰 +${baseGold}G | 💎 +${baseGems} Gems${commentary}`, '#ffd700');
      }, 800);

      // Equipment drop notification (if applicable)
      if (Math.random() < itemChance) {
        setTimeout(() => {
          const equipType = ['WEAPON', 'ARMOR', 'ACCESSORY'][Math.floor(Math.random() * 3)];
          notify(`⚡ BONUS: ${chest.rarity.toUpperCase()} ${equipType} DETECTED`, getRarityColor(chest.rarity));
        }, 1200);
      }

      // Final status update
      setTimeout(() => {
        const efficiency = Math.floor((multiplier - 1) * 100);
        if (efficiency > 0) {
          notify(`📈 RARITY BONUS: +${efficiency}% REWARDS`, '#00ff88');
        }
        notify(`✅ CHEST EXTRACTION COMPLETE`, '#4CAF50');
      }, 1600);

      // Remove chest with fade effect
      chest._fading = true;
      setTimeout(() => {
        const idx = st.pickups.indexOf(chest);
        if (idx >= 0) st.pickups.splice(idx, 1);
      }, 2000);

      updateCurrencies();
    }

    function spawnRandomEquipment(x, y, rarity = 'common') {
      // Equipment categories with detailed subtypes
      const equipTypes = {
        weapon: {
          melee: ['Sword', 'Axe', 'Hammer', 'Dagger', 'Spear'],
          ranged: ['Bow', 'Crossbow', 'Staff', 'Wand'],
          magic: ['Tome', 'Crystal', 'Scepter', 'Rod']
        },
        armor: {
          heavy: ['Plate', 'Mail', 'Scale', 'Brigandine'],
          light: ['Leather', 'Studded', 'Padded'],
          cloth: ['Robe', 'Vestment', 'Mantle']
        },
        accessory: {
          jewelry: ['Ring', 'Amulet', 'Pendant'],
          trinkets: ['Charm', 'Talisman', 'Medallion'],
          gems: ['Ruby', 'Sapphire', 'Emerald']
        }
      };

      // Select equipment type and subtype
      const mainTypes = Object.keys(equipTypes);
      const mainType = mainTypes[Math.floor(Math.random() * mainTypes.length)];
      const subTypes = Object.keys(equipTypes[mainType]);
      const subType = subTypes[Math.floor(Math.random() * subTypes.length)];
      const baseName = equipTypes[mainType][subType][Math.floor(Math.random() * equipTypes[mainType][subType].length)];

      // Equipment sets for bonus synergy
      const equipmentSets = ['Shadowbane', 'Dragonheart', 'Voidwalker', 'Stormcaller', 'Bloodreaper'];
      const isSetItem = Math.random() < (rarity === 'legendary' ? 0.8 : rarity === 'epic' ? 0.4 : 0.1);
      const setName = isSetItem ? equipmentSets[Math.floor(Math.random() * equipmentSets.length)] : null;

      // Generate name with prefixes including S and SS ranks
      const rarityPrefixes = {
        'common': ['Worn', 'Simple', 'Basic'],
        'rare': ['Fine', 'Superior', 'Enhanced'],
        'epic': ['Masterwork', 'Enchanted', 'Arcane'],
        'legendary': ['Divine', 'Mythical', 'Eternal'],
        's_rank': ['Transcendent', 'Apex', 'Supreme', 'Sovereign'],
        'ss_rank': ['Omnipotent', 'Absolute', 'Primordial', 'Void-Touched']
      };

      const prefix = rarityPrefixes[rarity][Math.floor(Math.random() * rarityPrefixes[rarity].length)];
      const fullName = setName ? `${setName} ${baseName}` : `${prefix} ${baseName}`;

      // Generate equipment with advanced stats
      const stats = generateEquipmentStats(mainType, subType, rarity);
      const enchantments = Math.random() < (rarity === 'legendary' ? 0.9 : rarity === 'epic' ? 0.6 : 0.3) ? generateEnchantments(rarity) : [];

      // Special aura effects for S and SS rank
      const auraEffects = generateAuraEffects(rarity);
      const upgradeLevel = rarity === 'ss_rank' ? Math.floor(Math.random() * 5) + 10 : rarity === 's_rank' ? Math.floor(Math.random() * 3) + 5 : 0;

      const equipment = {
        kind: 'equipment',
        type: mainType,
        subType: subType,
        name: fullName,
        rarity: rarity,
        setName: setName,
        level: Math.floor(Math.random() * 10) + (rarity === 'ss_rank' ? 150 : rarity === 's_rank' ? 120 : rarity === 'legendary' ? 90 : 70),
        upgradeLevel: upgradeLevel,
        maxUpgradeLevel: rarity === 'ss_rank' ? 25 : rarity === 's_rank' ? 15 : rarity === 'legendary' ? 10 : 5,
        x: x,
        y: y,
        life: 60000,
        throwable: false,
        stats: stats,
        enchantments: enchantments,
        auraEffects: auraEffects,
        durability: rarity === 'ss_rank' ? 999 : rarity === 's_rank' ? 500 : 100,
        maxDurability: rarity === 'ss_rank' ? 999 : rarity === 's_rank' ? 500 : 100,
        socketSlots: rarity === 'ss_rank' ? 6 : rarity === 's_rank' ? 4 : rarity === 'legendary' ? 3 : 2,
        _glowTimer: 0,
        _discovered: Date.now(),
        _particleTimer: 0,
        _auraIntensity: rarity === 'ss_rank' ? 1.0 : rarity === 's_rank' ? 0.7 : 0
      };

      st.pickups.push(equipment);

      // Enhanced discovery notifications with S/SS rank effects
      const raritySymbol = {
        'common': '⚪', 'rare': '🔵', 'epic': '🟣', 'legendary': '🟡',
        's_rank': '🔥', 'ss_rank': '💀'
      }[rarity];
      const setIndicator = setName ? ' [SET]' : '';
      const upgradeIndicator = upgradeLevel > 0 ? ` +${upgradeLevel}` : '';

      // Special effects for S and SS rank
      if (rarity === 's_rank' || rarity === 'ss_rank') {
        // Screen flash effect
        addCast(x, y, rarity === 'ss_rank' ? '#000000' : '#ff4500', 3000);
        addCast(x - 30, y - 20, '#ffffff', 2000);
        addCast(x + 30, y - 20, '#ffffff', 2000);

        // Multiple notification waves
        aiNotify('🚨 ANOMALOUS ENERGY SPIKE DETECTED!', '#ff0000');
        setTimeout(() => aiNotify('⚡ REALITY DISTORTION FIELD ACTIVE', '#ffff00'), 300);
      }

      aiNotify(`${raritySymbol} ${fullName.toUpperCase()} (Lv.${equipment.level})${upgradeIndicator}${setIndicator}`, getRarityColor(rarity));

      // Show aura effects for S/SS rank
      if (auraEffects.length > 0) {
        setTimeout(() => {
          const auraList = auraEffects.map(a => a.name).join(', ');
          aiNotify(`🌟 AURA EFFECTS: ${auraList}`, rarity === 'ss_rank' ? '#000000' : '#ff4500');
        }, 800);
      }

      // Show stats after delay
      setTimeout(() => {
        const mainStats = Object.entries(stats).slice(0, 3).map(([k, v]) => `${k.toUpperCase()}: +${v}`).join(' | ');
        aiNotify(`📊 STATS: ${mainStats}`, '#ffffff');
      }, 500);

      // Show enchantments with special S/SS rank formatting
      if (enchantments.length > 0) {
        setTimeout(() => {
          const enchantColor = rarity === 'ss_rank' ? '#000000' : rarity === 's_rank' ? '#ff4500' : '#ff69b4';
          const enchantPrefix = rarity === 'ss_rank' ? '💀 CURSED:' : rarity === 's_rank' ? '🔥 EMPOWERED:' : '✨ ENCHANTED:';
          aiNotify(`${enchantPrefix} ${enchantments.map(e => e.name).join(', ')}`, enchantColor);
        }, 1000);
      }

      // Show upgrade potential
      if (rarity === 's_rank' || rarity === 'ss_rank') {
        setTimeout(() => {
          aiNotify(`⚡ UPGRADE POTENTIAL: +${equipment.maxUpgradeLevel} levels available`, '#ffff00');
        }, 1500);
      }
    }

    function generateEquipmentStats(type, subType, rarity) {
      const rarityMultiplier = {
        'common': 1, 'rare': 1.5, 'epic': 2.2, 'legendary': 3.5,
        's_rank': 6.0, 'ss_rank': 12.0
      }[rarity] || 1;

      // Base stats by equipment type and subtype
      const baseStatTemplates = {
        weapon: {
          melee: { dmg: [20, 35], critChance: [8, 15], attackSpeed: [85, 110] },
          ranged: { dmg: [15, 28], critChance: [12, 20], accuracy: [80, 95] },
          magic: { dmg: [18, 32], spellPower: [15, 30], manaEfficiency: [85, 110] }
        },
        armor: {
          heavy: { defense: [25, 40], hp: [80, 120], blockChance: [8, 15] },
          light: { defense: [15, 25], hp: [50, 80], dodgeChance: [10, 18] },
          cloth: { defense: [8, 15], hp: [30, 50], manaRegen: [15, 25] }
        },
        accessory: {
          jewelry: { luck: [8, 15], experience: [10, 20], goldFind: [15, 25] },
          trinkets: { speed: [15, 25], skillCooldown: [-5, -15], resourceRegen: [12, 22] },
          gems: { elementalDamage: [20, 35], penetration: [10, 18], resistance: [15, 25] }
        }
      };

      const template = baseStatTemplates[type]?.[subType] || {};
      const stats = {};

      // Generate primary stats
      for (const [statName, range] of Object.entries(template)) {
        const baseValue = range[0] + Math.random() * (range[1] - range[0]);
        const variance = 0.85 + (Math.random() * 0.3);
        stats[statName] = Math.floor(baseValue * rarityMultiplier * variance);
      }

      // Add bonus stats for higher rarities
      const bonusStatPools = {
        combat: ['lifesteal', 'thorns', 'cleave', 'multishot'],
        defensive: ['regeneration', 'barrier', 'immunity', 'reflection'],
        utility: ['experience', 'goldFind', 'magicFind', 'movementSpeed']
      };

      const bonusCount = {
        'common': 0, 'rare': 1, 'epic': 2, 'legendary': 3,
        's_rank': 5, 'ss_rank': 8
      }[rarity] || 0;
      const allBonusStats = Object.values(bonusStatPools).flat();

      for (let i = 0; i < bonusCount; i++) {
        const bonusStat = allBonusStats[Math.floor(Math.random() * allBonusStats.length)];
        if (!stats[bonusStat]) {
          const baseBonus = rarity === 'ss_rank' ? 80 : rarity === 's_rank' ? 50 : rarity === 'legendary' ? 20 : 10;
          stats[bonusStat] = Math.floor(Math.random() * 25) + baseBonus;
        }
      }

      // Add exclusive S/SS rank stats
      if (rarity === 's_rank' || rarity === 'ss_rank') {
        const exclusiveStats = ['voidDamage', 'realityBend', 'timeDistortion', 'soulBurn', 'dimensionRift'];
        const exclusiveStat = exclusiveStats[Math.floor(Math.random() * exclusiveStats.length)];
        stats[exclusiveStat] = Math.floor(Math.random() * 50) + (rarity === 'ss_rank' ? 100 : 50);
      }

      stats._powerScore = Object.values(stats).reduce((sum, val) => sum + Math.abs(val), 0);
      return stats;
    }

    function generateEnchantments(rarity) {
      const enchantmentPool = {
        'rare': [
          { name: 'Sharpness', effect: 'dmg', value: 8 },
          { name: 'Protection', effect: 'defense', value: 6 },
          { name: 'Swiftness', effect: 'speed', value: 10 }
        ],
        'epic': [
          { name: 'Vampiric', effect: 'lifesteal', value: 12 },
          { name: 'Thorns', effect: 'thorns', value: 15 },
          { name: 'Fortune', effect: 'goldFind', value: 25 }
        ],
        'legendary': [
          { name: 'Godslayer', effect: 'dmg', value: 25 },
          { name: 'Phoenix', effect: 'resurrection', value: 1 },
          { name: 'Infinity', effect: 'mana', value: 999 }
        ],
        's_rank': [
          { name: 'Apex Predator', effect: 'dmg', value: 75 },
          { name: 'Dimensional Rift', effect: 'teleportStrike', value: 1 },
          { name: 'Soul Harvest', effect: 'soulSteal', value: 25 },
          { name: 'Time Dilation', effect: 'timeControl', value: 15 }
        ],
        'ss_rank': [
          { name: 'Void Annihilation', effect: 'voidDamage', value: 200 },
          { name: 'Reality Collapse', effect: 'realityBend', value: 50 },
          { name: 'Omnipotence', effect: 'allStats', value: 100 },
          { name: 'Dark Aura', effect: 'darkAura', value: 1 },
          { name: 'Existence Erasure', effect: 'instantKill', value: 5 }
        ]
      };

      const available = enchantmentPool[rarity] || [];
      const count = rarity === 'ss_rank' ? 4 : rarity === 's_rank' ? 3 : rarity === 'legendary' ? 2 : 1;
      const selected = [];

      for (let i = 0; i < count && i < available.length; i++) {
        const enchant = available[Math.floor(Math.random() * available.length)];
        if (!selected.find(e => e.name === enchant.name)) {
          selected.push({ ...enchant });
        }
      }

      return selected;
    }

    function getRarityColor(rarity) {
      return {
        'common': '#9e9e9e',
        'rare': '#2196f3',
        'epic': '#9c27b0',
        'legendary': '#ff5722',
        's_rank': '#ff4500',
        'ss_rank': '#000000'
      }[rarity] || '#ffffff';
    }

    function generateAuraEffects(rarity) {
      if (rarity !== 's_rank' && rarity !== 'ss_rank') return [];

      const auraPool = {
        's_rank': [
          { name: 'Flame Aura', effect: 'burnEnemies', radius: 100, damage: 15 },
          { name: 'Lightning Field', effect: 'shockEnemies', radius: 80, damage: 20 },
          { name: 'Frost Emanation', effect: 'slowEnemies', radius: 120, slow: 0.5 },
          { name: 'Radiant Glow', effect: 'healAllies', radius: 150, heal: 10 }
        ],
        'ss_rank': [
          { name: 'Dark Aura', effect: 'fearEnemies', radius: 200, fear: 3 },
          { name: 'Void Emanation', effect: 'drainLife', radius: 180, drain: 25 },
          { name: 'Death Field', effect: 'necroticDamage', radius: 160, damage: 50 },
          { name: 'Reality Distortion', effect: 'warpSpace', radius: 220, distortion: 1 },
          { name: 'Soul Corruption', effect: 'convertEnemies', radius: 100, convert: 0.1 }
        ]
      };

      const available = auraPool[rarity] || [];
      const count = rarity === 'ss_rank' ? Math.floor(Math.random() * 2) + 2 : 1;
      const selected = [];

      for (let i = 0; i < count && i < available.length; i++) {
        const aura = available[Math.floor(Math.random() * available.length)];
        if (!selected.find(a => a.name === aura.name)) {
          selected.push({ ...aura });
        }
      }

      return selected;
    }

    // Equipment upgrade system
    function upgradeEquipment(equipment, materials) {
      if (!equipment || equipment.upgradeLevel >= equipment.maxUpgradeLevel) {
        aiNotify('❌ UPGRADE FAILED: Maximum level reached', '#ff0000');
        return false;
      }

      const upgradeCost = calculateUpgradeCost(equipment);
      if (!hasUpgradeMaterials(materials, upgradeCost)) {
        aiNotify('❌ UPGRADE FAILED: Insufficient materials', '#ff0000');
        return false;
      }

      // Consume materials
      consumeUpgradeMaterials(materials, upgradeCost);

      // Upgrade equipment
      equipment.upgradeLevel++;
      const statBonus = equipment.rarity === 'ss_rank' ? 15 : equipment.rarity === 's_rank' ? 10 : 5;

      // Boost all stats
      Object.keys(equipment.stats).forEach(stat => {
        if (!stat.startsWith('_')) {
          equipment.stats[stat] = Math.floor(equipment.stats[stat] * 1.1) + statBonus;
        }
      });

      // Recalculate power score
      equipment.stats._powerScore = Object.values(equipment.stats).reduce((sum, val) => sum + Math.abs(val), 0);

      // Special effects for high upgrade levels
      if (equipment.upgradeLevel >= 10 && equipment.rarity === 'ss_rank') {
        // Add transcendent effect
        if (!equipment.transcendent) {
          equipment.transcendent = true;
          equipment.name = `Transcendent ${equipment.name}`;
          aiNotify('🌟 TRANSCENDENCE ACHIEVED!', '#ffffff');
        }
      }

      aiNotify(`⬆️ ${equipment.name} upgraded to +${equipment.upgradeLevel}!`, getRarityColor(equipment.rarity));
      return true;
    }

    function calculateUpgradeCost(equipment) {
      const baseCost = equipment.upgradeLevel * 100;
      const rarityMultiplier = {
        'common': 1, 'rare': 2, 'epic': 4, 'legendary': 8,
        's_rank': 15, 'ss_rank': 30
      }[equipment.rarity] || 1;

      return {
        gold: baseCost * rarityMultiplier,
        gems: Math.floor(baseCost * rarityMultiplier / 10),
        essences: equipment.rarity === 'ss_rank' ? equipment.upgradeLevel * 5 : equipment.upgradeLevel * 2
      };
    }

    function hasUpgradeMaterials(materials, cost) {
      return materials.gold >= cost.gold &&
        materials.gems >= cost.gems &&
        materials.essences >= cost.essences;
    }

    function consumeUpgradeMaterials(materials, cost) {
      materials.gold -= cost.gold;
      materials.gems -= cost.gems;
      materials.essences -= cost.essences;
    }

    // Equipment management functions
    function equipItem(player, equipment) {
      if (!player.equipment) player.equipment = {};

      const slot = equipment.type + (equipment.subType ? '_' + equipment.subType : '');
      const currentItem = player.equipment[slot];

      if (currentItem) {
        // Move current item to inventory
        if (!player.inventory) player.inventory = [];
        player.inventory.push(currentItem);
      }

      player.equipment[slot] = equipment;
      applyEquipmentStats(player, equipment, true);

      aiNotify(`⚔️ ${equipment.name} EQUIPPED`, getRarityColor(equipment.rarity));
    }

    function applyEquipmentStats(player, equipment, isEquipping) {
      const multiplier = isEquipping ? 1 : -1;

      if (!player.equipmentStats) player.equipmentStats = {};

      // Apply base stats
      Object.entries(equipment.stats).forEach(([stat, value]) => {
        if (!stat.startsWith('_')) {
          player.equipmentStats[stat] = (player.equipmentStats[stat] || 0) + (value * multiplier);
        }
      });

      // Apply enchantment effects
      if (equipment.enchantments) {
        equipment.enchantments.forEach(enchant => {
          player.equipmentStats[enchant.effect] = (player.equipmentStats[enchant.effect] || 0) + (enchant.value * multiplier);
        });
      }

      updatePlayerStats(player);
    }

    // Equipment visual effects system
    function updateEquipmentEffects(equipment) {
      if (!equipment.auraEffects || equipment.auraEffects.length === 0) return;

      equipment._particleTimer = (equipment._particleTimer || 0) + 1;

      // Generate particles for S/SS rank equipment
      if (equipment._particleTimer % 30 === 0) {
        equipment.auraEffects.forEach(aura => {
          const particleColor = equipment.rarity === 'ss_rank' ? '#000000' : '#ff4500';
          addCast(equipment.x + Math.random() * 40 - 20,
            equipment.y + Math.random() * 40 - 20,
            particleColor, 1000);
        });
      }

      // Apply aura effects to nearby entities
      if (equipment._particleTimer % 60 === 0) {
        applyAuraEffects(equipment);
      }
    }

    function applyAuraEffects(equipment) {
      if (!equipment.auraEffects) return;

      equipment.auraEffects.forEach(aura => {
        // Find entities within aura radius
        const nearbyEnemies = st.enemies.filter(enemy => {
          const dist = Math.hypot(enemy.x - equipment.x, enemy.y - equipment.y);
          return dist <= aura.radius;
        });

        // Apply aura effects
        nearbyEnemies.forEach(enemy => {
          switch (aura.effect) {
            case 'burnEnemies':
              enemy.hp -= aura.damage;
              addCast(enemy.x, enemy.y, '#ff4500', 500);
              break;
            case 'drainLife':
              enemy.hp -= aura.drain;
              addCast(enemy.x, enemy.y, '#800080', 500);
              break;
            case 'fearEnemies':
              enemy._feared = aura.fear * 60; // 3 seconds
              enemy.speed *= 0.5;
              break;
            case 'necroticDamage':
              enemy.hp -= aura.damage;
              addCast(enemy.x, enemy.y, '#000000', 800);
              break;
          }
        });
      });
    }

    function updatePlayerStats(player) {
      if (!player.equipmentStats) return;

      // Update player properties based on equipment stats
      player.dmg = Math.max(1, (player.baseDmg || 10) + (player.equipmentStats.dmg || 0));
      player.hpMax = Math.max(1, (player.baseHpMax || 100) + (player.equipmentStats.hp || 0));
      player.speed = Math.max(0.1, (player.baseSpeed || 1) + ((player.equipmentStats.speed || 0) / 100));

      // Apply special S/SS rank effects
      if (player.equipmentStats.voidDamage) {
        player.voidDamage = player.equipmentStats.voidDamage;
      }
      if (player.equipmentStats.realityBend) {
        player.realityBend = player.equipmentStats.realityBend;
      }
      if (player.equipmentStats.darkAura) {
        player.darkAura = true;
        player._auraRadius = 200;
      }
    }

    // Enhanced notification system with AI-style formatting
    function aiNotify(message, color = '#00ffff', duration = 3000) {
      const timestamp = new Date().toLocaleTimeString('en-US', {
        hour12: false,
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
      });

      const formattedMessage = `[${timestamp}] ${message}`;
      notify(formattedMessage, color, duration);
    }

    // Equipment interaction system with S/SS rank handling
    function handleEquipmentPickup(player, equipment) {
      const slot = equipment.type + (equipment.subType ? '_' + equipment.subType : '');
      const currentItem = player.equipment?.[slot];

      // Special handling for S/SS rank equipment
      if (equipment.rarity === 's_rank' || equipment.rarity === 'ss_rank') {
        // Always prompt for S/SS rank items
        aiNotify(`🔥 ${equipment.rarity.toUpperCase()} EQUIPMENT DETECTED! Auto-equipping...`, getRarityColor(equipment.rarity));

        // Force equip S/SS rank items
        equipItem(player, equipment);

        // Special effects
        if (equipment.rarity === 'ss_rank') {
          aiNotify('💀 DARK POWER COURSES THROUGH YOU...', '#000000');
          player._darkEmpowered = true;
        }
        return;
      }

      // Auto-equip if better or no current item
      if (!currentItem || equipment.stats._powerScore > (currentItem.stats._powerScore || 0)) {
        equipItem(player, equipment);
        aiNotify('⬆️ AUTO-EQUIPPED: Superior stats detected', '#4caf50');
      } else {
        // Add to inventory
        if (!player.inventory) player.inventory = [];
        player.inventory.push(equipment);
        aiNotify('🎒 Added to inventory', '#2196f3');
      }
    }

    /* ================== Basic Pet System ================== */
    function pickupPet(player, petPickup) {
      // Add pet to player's collection
      if (!st.activePets) st.activePets = [];

      const pet = {
        id: Math.random(),
        name: petPickup.petName || 'Companion',
        x: player.x + 48,
        y: player.y - 30,
        hp: 50,
        hpMax: 50,
        owner: player.id,
        ai: 'follow',
        fireCD: 1500,
        reviveCD: 0
      };

      st.activePets.push(pet);

      // Remove pickup
      const idx = st.pickups.indexOf(petPickup);
      if (idx >= 0) st.pickups.splice(idx, 1);

      notify('Pet acquired: ' + pet.name, '#00ff88');
    }

    /* ================= Advanced Vehicle Mechanics ================= */
    // Spawns a vehicle entity near the leader and shows seat buttons
    function spawnVehicle(kind) {
      if (!st.vehicles) st.vehicles = [];
      // Gate by equipped vehicle ownership
      function _owned(kind) {
        const v = st.equippedVehicle;
        if (!v) return false;
        const t = (v.vehType || v.type || '').toLowerCase();
        const nm = (v.name || '').toLowerCase();
        let vk = t || (nm.includes('bike') ? 'bike' : nm.includes('chopper') ? 'chopper' : nm.includes('jetpack') ? 'jetpack' : nm.includes('car') ? 'car' : '');
        if (!vk) vk = 'car';
        return vk === (kind || 'car');
      }
      if (!_owned(kind)) {
        notify('Equip the ' + (kind || 'vehicle') + ' first', '#ff7a6a');
        return;
      }
      const L = leader();
      const v = {
        kind: kind || 'car',
        x: (L?.x || 200) + 80,
        y: (L?.y || DESIGN_H - 160),
        riders: [],
        _velocity: { x: 0, y: 0 },
        _acceleration: { x: 0, y: 0 },
        _boost: 0
      };
      // Kind-specific tuning
      if (kind === 'bike') {
        v._maxSpeed = 2.6; v._friction = 0.90; v.maxSeats = 2;
      } else if (kind === 'chopper') {
        v._maxSpeed = 2.0; v._friction = 0.88; v.maxSeats = 3;
      } else if (kind === 'jetpack') {
        v._maxSpeed = 2.4; v._friction = 0.92; v.maxSeats = 1;
      } else { // car default
        v._maxSpeed = 2.2; v._friction = 0.85; v.maxSeats = 3;
      }
      st.vehicles.push(v);
      showVehicleSelectionUI(v);
      notify((kind ? kind : 'car') + " spawned", '#e6e6fa');
    }

    function getLeaderVehicle() {
      if (!st.vehicles || !st.players) return null;
      const leaderId = st.players[st.leader || 0]?.id;
      if (!leaderId) return null;
      for (const veh of st.vehicles) {
        if (veh?.riders?.some(r => r.playerId === leaderId)) return veh;
      }
      return null;
    }
    function enterVehicleSeat(player, vehicle, seatIndex) {
      if (!vehicle.riders) vehicle.riders = [];

      // Check if seat is already taken
      if (vehicle.riders.some(r => r.seatIndex === seatIndex)) {
        notify('Seat already occupied!', '#ff6aa8');
        return;
      }

      // Determine role based on seat
      let role = 'passenger';
      if (seatIndex === 0) role = 'driver';
      else if (seatIndex === 1) role = 'gunner';

      vehicle.riders.push({
        playerId: player.id,
        role: role,
        seatIndex: seatIndex
      });

      player._riding = vehicle;
      player._vehicleRole = role;
      player._vehicleSeat = seatIndex;

      // Show vehicle selection UI for remaining seats
      if (vehicle.riders.length < vehicle.maxSeats) {
        showVehicleSelectionUI(vehicle);
      }

      notify(`${player.id} boarded vehicle seat ${seatIndex + 1} as ${role}`, '#6aa8ff');

      // Update vehicle skills UI
      updateVehicleSkillsUI(vehicle);
    }

    function enterVehicle(player, vehicle) {
      if (!vehicle.riders) vehicle.riders = [];
      if (!vehicle.maxRiders) vehicle.maxRiders = 3; // Default 3 seats

      if (vehicle.riders.length >= vehicle.maxRiders) {
        notify('Vehicle is full!', '#ff7a6a');
        return;
      }

      // Determine role based on seat
      const seatIndex = vehicle.riders.length;
      let role = 'passenger';
      if (seatIndex === 0) role = 'driver';
      else if (seatIndex === 1) role = 'gunner';

      vehicle.riders.push({
        playerId: player.id,
        role: role,
        seatIndex: seatIndex
      });

      player._riding = vehicle;
      player._vehicleRole = role;

      // Show vehicle selection UI for other heroes
      if (vehicle.riders.length === 1) {
        showVehicleSelectionUI(vehicle);
      }

      notify(`${player.id} entered vehicle as ${role}`, '#6aa8ff');

      // Update vehicle skills UI
      updateVehicleSkillsUI(vehicle);
    }

    function showVehicleSelectionUI(vehicle) {
      // Enhanced vehicle boarding with numbered seats (1-3)
      if (!vehicle.maxSeats) vehicle.maxSeats = 3;

      // Create seat buttons (1, 2, 3) above vehicle
      vehicle._seatButtons = [];

      for (let seatNum = 1; seatNum <= vehicle.maxSeats; seatNum++) {
        const isOccupied = vehicle.riders && vehicle.riders.some(r => r.seatIndex === seatNum - 1);

        if (!isOccupied) {
          const button = {
            x: vehicle.x + (seatNum - 2) * 40, // Spread seats around vehicle center
            y: vehicle.y - 80,
            w: 30,
            h: 30,
            text: seatNum.toString(),
            seatIndex: seatNum - 1,
            vehicle: vehicle,
            life: 15000 // 15 second timeout
          };
          vehicle._seatButtons.push(button);
        }
      }

      if (vehicle._seatButtons.length > 0) {
        notify(`Vehicle seats available! Click seat numbers (1-${vehicle.maxSeats})`, '#6aa8ff');
      }
    }

    function updateVehicleSelectionButtons(dtMs) {
      if (!st.vehicles) return;

      for (const vehicle of st.vehicles) {
        // Update seat button timers
        if (vehicle._seatButtons) {
          vehicle._seatButtons.forEach(btn => btn.life -= dtMs);
          vehicle._seatButtons = vehicle._seatButtons.filter(btn => btn.life > 0);

          if (vehicle._seatButtons.length === 0) {
            delete vehicle._seatButtons;
          }
        }

        // Legacy support for old selection buttons
        if (vehicle._selectionButtons) {
          vehicle._selectionButtons.forEach(btn => btn.life -= dtMs);
          vehicle._selectionButtons = vehicle._selectionButtons.filter(btn => btn.life > 0);

          if (vehicle._selectionButtons.length === 0) {
            delete vehicle._selectionButtons;
          }
        }
      }
    }

    function handleVehicleButtonClick(x, y) {
      if (!st.vehicles) return;

      for (const vehicle of st.vehicles) {
        // Check seat buttons first (new system)
        if (vehicle._seatButtons) {
          for (const btn of vehicle._seatButtons) {
            const dist = Math.hypot(x - btn.x, y - btn.y);
            if (dist < 25) { // Click radius
              // Find an available player to board this seat
              const availablePlayer = st.players.find(p => !p.isDefeated && !p._riding);
              if (availablePlayer) {
                enterVehicleSeat(availablePlayer, vehicle, btn.seatIndex);
                // Remove this button
                const idx = vehicle._seatButtons.indexOf(btn);
                if (idx >= 0) vehicle._seatButtons.splice(idx, 1);
              }
              return true;
            }
          }
        }

        // Legacy support for old selection buttons
        if (vehicle._selectionButtons) {
          for (const btn of vehicle._selectionButtons) {
            const dist = Math.hypot(x - btn.x, y - btn.y);
            if (dist < 30) { // Click radius
              const hero = st.players.find(p => p.id === btn.heroId);
              if (hero && !hero._riding && !hero.isDefeated) {
                enterVehicle(hero, vehicle);
                // Remove this button
                const idx = vehicle._selectionButtons.indexOf(btn);
                if (idx >= 0) vehicle._selectionButtons.splice(idx, 1);
              }
              return true;
            }
          }
        }
      }
      return false;
    }

    // Eject a specific seat occupant from a vehicle
    function ejectPlayerFromVehicle(vehicle, seatIndex) {
      if (!vehicle || !vehicle.riders) return;
      const rider = vehicle.riders.find(r => r.seatIndex === seatIndex);
      if (!rider) return;
      const player = st.players.find(p => p.id === rider.playerId);
      if (player) { exitVehicle(player); }
    }

    function updateVehicleSkillsUI(vehicle) {
      // Create/update vehicle skills UI
      if (!vehicle.skills) vehicle.skills = ['V1', 'V2']; // Default vehicle skills

      // This would create floating skill buttons above the vehicle
      // For now, we'll add them to the main UI when someone is driving
      const driver = vehicle.riders.find(r => r.role === 'driver');
      if (driver && st.players[st.leader].id === driver.playerId) {
        // Show vehicle skills in main UI (could be implemented as overlay)
        notify('Vehicle skills: V1, V2 available', '#6aa8ff');
      }
    }

    function exitVehicle(player) {
      if (!player._riding) return;

      const vehicle = player._riding;
      const riderIndex = vehicle.riders.findIndex(r => r.playerId === player.id);

      if (riderIndex >= 0) {
        vehicle.riders.splice(riderIndex, 1);

        // Reassign roles if driver left
        if (vehicle.riders.length > 0 && player._vehicleRole === 'driver') {
          vehicle.riders[0].role = 'driver';
          const newDriver = st.players.find(p => p.id === vehicle.riders[0].playerId);
          if (newDriver) newDriver._vehicleRole = 'driver';
        }
      }

      player._riding = null;
      player._vehicleRole = null;

      notify(`${player.id} exited vehicle`, '#6aa8ff');

      // Clear selection UI if vehicle is empty
      if (vehicle.riders.length === 0) {
        delete vehicle._selectionButtons;
      }
    }

    function useVehicleSkill(vehicle, skillKey) {
      const driver = vehicle.riders.find(r => r.role === 'driver');
      if (!driver) return;

      const driverPlayer = st.players.find(p => p.id === driver.playerId);
      if (!driverPlayer) return;

      if (skillKey === 'V1') {
        // Vehicle Boost - temporary speed increase
        vehicle._boost = 5000; // 5 second boost
        addCast(vehicle.x, vehicle.y, '#ffaa00');
        notify('Vehicle Boost Activated!', '#ffaa00');
      } else if (skillKey === 'V2') {
        // Vehicle Weapon - all passengers fire
        vehicle.riders.forEach(rider => {
          const passenger = st.players.find(p => p.id === rider.playerId);
          if (passenger) {
            // Fire from vehicle position
            st.shots.push({
              x: vehicle.x + (rider.seatIndex * 20),
              y: vehicle.y - 20,
              vx: 700,
              vy: 0,
              dmg: Math.round(passenger.dmg * 1.5),
              life: 1500,
              color: '#ff6aa8',
              ownerId: passenger.id
            });
          }
        });
        addCast(vehicle.x, vehicle.y, '#ff6aa8');
        notify('Vehicle Weapons Fired!', '#ff6aa8');
      }
    }

    function updateVehicles(dtMs) {
      if (!st.vehicles) return;

      for (const vehicle of st.vehicles) {
        // Initialize vehicle physics properties
        if (!vehicle._velocity) vehicle._velocity = { x: 0, y: 0 };
        if (!vehicle._acceleration) vehicle._acceleration = { x: 0, y: 0 };
        if (!vehicle._maxSpeed) vehicle._maxSpeed = 2.0;
        if (!vehicle._friction) vehicle._friction = 0.85;
        if (!vehicle._turnRate) vehicle._turnRate = 0.8;

        // Update boost timer
        if (vehicle._boost > 0) {
          vehicle._boost -= dtMs;
        }

        // Enhanced car-like movement with momentum
        const driver = vehicle.riders && vehicle.riders.find(r => r.role === 'driver');
        if (driver) {
          const driverPlayer = st.players.find(p => p.id === driver.playerId);
          if (driverPlayer) {
            const dt = dtMs / 1000; // Convert to seconds

            // Calculate speed multipliers
            const speedMultiplier = vehicle._boost > 0 ? 1.8 : 1.0;
            const maxSpeed = vehicle._maxSpeed * speedMultiplier;

            // Apply input acceleration (car-like acceleration)
            const accelForce = 1.5;
            vehicle._acceleration.x = joyX * accelForce * speedMultiplier;
            vehicle._acceleration.y = joyY * accelForce * speedMultiplier;

            // Update velocity with acceleration
            vehicle._velocity.x += vehicle._acceleration.x * dt;
            vehicle._velocity.y += vehicle._acceleration.y * dt;

            // Apply friction (momentum decay)
            vehicle._velocity.x *= Math.pow(vehicle._friction, dt * 60);
            vehicle._velocity.y *= Math.pow(vehicle._friction, dt * 60);

            // Limit max speed
            const currentSpeed = Math.hypot(vehicle._velocity.x, vehicle._velocity.y);
            if (currentSpeed > maxSpeed) {
              vehicle._velocity.x = (vehicle._velocity.x / currentSpeed) * maxSpeed;
              vehicle._velocity.y = (vehicle._velocity.y / currentSpeed) * maxSpeed;
            }

            // Update position with velocity
            const moveX = vehicle._velocity.x * DESIGN_W * dt;
            const moveY = vehicle._velocity.y * DESIGN_H * dt;
            vehicle.x += moveX;
            vehicle.y += moveY;

            // Keep vehicle in bounds with collision response
            const minX = 60, maxX = DESIGN_W - 60;
            const minY = 100, maxY = DESIGN_H - 100;

            if (vehicle.x < minX) {
              vehicle.x = minX;
              vehicle._velocity.x = Math.max(0, vehicle._velocity.x); // Stop leftward movement
            }
            if (vehicle.x > maxX) {
              vehicle.x = maxX;
              vehicle._velocity.x = Math.min(0, vehicle._velocity.x); // Stop rightward movement
            }
            if (vehicle.y < minY) {
              vehicle.y = minY;
              vehicle._velocity.y = Math.max(0, vehicle._velocity.y); // Stop upward movement
            }
            if (vehicle.y > maxY) {
              vehicle.y = maxY;
              vehicle._velocity.y = Math.min(0, vehicle._velocity.y); // Stop downward movement
            }

            // Update all riders' positions
            vehicle.riders.forEach((rider, index) => {
              const passenger = st.players.find(p => p.id === rider.playerId);
              if (passenger) {
                // Position passengers around vehicle with slight offset
                const offsetX = (rider.seatIndex - 1) * 20;
                const offsetY = rider.seatIndex === 0 ? -10 : 5; // Driver sits forward
                passenger.x = vehicle.x + offsetX;
                passenger.y = vehicle.y + offsetY;
              }
            });

            // Add exhaust VFX when moving fast
            if (currentSpeed > 0.5 || vehicle._boost > 0) {
              st.effects.push({
                kind: 'cast',
                x: vehicle.x - 35 + Math.random() * 10,
                y: vehicle.y + Math.random() * 20 - 10,
                color: vehicle._boost > 0 ? '#ffaa00' : '#888888',
                life: 300,
                max: 300
              });
            }
          }
        } else {
          // No driver - vehicle gradually stops
          if (vehicle._velocity) {
            vehicle._velocity.x *= 0.95;
            vehicle._velocity.y *= 0.95;

            // Move vehicle with remaining momentum
            const dt = dtMs / 1000;
            vehicle.x += vehicle._velocity.x * DESIGN_W * dt;
            vehicle.y += vehicle._velocity.y * DESIGN_H * dt;
          }
        }
      }

      updateVehicleSelectionButtons(dtMs);
      // Toggle vehicle skill button visibility based on leader driving
      try {
        const btnVS = document.getElementById('btnVehicleSkill');
        if (btnVS && st.players) {
          const v = getLeaderVehicle();
          const leaderId = st.players[st.leader || 0]?.id;
          const driving = !!(v && v.riders && v.riders.some(r => r.playerId === leaderId && r.role === 'driver'));
          btnVS.style.display = driving ? 'flex' : 'none';
        }
      } catch (e) { }
    }

    /* ================== Throwable System ================== */
    function throwItem(player, item) {
      // Create projectile from thrown item
      st.shots.push({
        kind: 'thrown_item',
        x: player.x + 20,
        y: player.y - 30,
        vx: 400,
        vy: -100,
        dmg: 25,
        life: 2000,
        w: 20,
        h: 20,
        color: '#ffaa00',
        gravity: true,
        ownerId: player.id
      });

      // Remove from pickups
      const idx = st.pickups.indexOf(item);
      if (idx >= 0) st.pickups.splice(idx, 1);

      notify('Item thrown!', '#ffaa00');
    }

    /* ================== Pet AI System ================== */

    // Simplified pet initialization
    function initializePetSkills(pet) {
      if (!pet.skills) {
        // Simple skill set for all pets
        pet.skills = ['attack_boost', 'heal'];
        pet.skillCooldowns = {};
        pet.skills.forEach(skill => {
          pet.skillCooldowns[skill] = 0;
        });
        pet.level = 1;
        pet.hp = pet.hpMax = 100;
        pet.atk = 20;
      }
    }

    function updatePets(dtMs) {
      if (!st.activePets) return;
      for (const pet of st.activePets) {
        if (pet.hp <= 0) continue;

        if (Array.isArray(st.equippedPets) && typeof pet._slotIndex === 'number' && !st.equippedPets[pet._slotIndex]) {
          const idx = st.activePets.indexOf(pet); if (idx > -1) st.activePets.splice(idx, 1); continue;
        }

        // Initialize pet skills if not already done
        initializePetSkills(pet);

        // Owner check
        const owner = st.players.find(p => p.id === pet.owner);
        if (!owner || owner.isDefeated) {
          const idx = st.activePets.indexOf(pet); if (idx > -1) st.activePets.splice(idx, 1); continue;
        }
        const dt = dtMs / 1000;
        // Berserk timer
        if (pet._berserkT > 0) { pet._berserkT -= dtMs; if (pet._berserkT <= 0) pet._berserkMul = 1; }
        const speedMul = (pet._berserkMul || 1);

        // Update skill cooldowns
        if (pet.skillCooldowns) {
          Object.keys(pet.skillCooldowns).forEach(skill => {
            if (pet.skillCooldowns[skill] > 0) {
              pet.skillCooldowns[skill] -= dtMs;
              if (pet.skillCooldowns[skill] < 0) {
                pet.skillCooldowns[skill] = 0;
              }
            }
          });
        }

        // Acquire target and set flank point
        const target = findNearestEnemyToPet(pet);
        let tx = owner.x - 60, ty = owner.y - 30; // default follow

        // Only target if it's not a player
        if (target && !target.isPlayer && !target.playerId) {
          const ang = Math.atan2(target.y - owner.y, target.x - owner.x);
          const flankDist = 50;
          // Pick side based on pet id hash for variety
          const side = (pet.id % 2 === 0) ? 1 : -1;
          tx = target.x + Math.cos(ang + side * 0.8) * flankDist;
          ty = target.y + Math.sin(ang + side * 0.8) * (flankDist * 0.6);
        }
        // Smooth move to tx,ty
        pet.x += (tx - pet.x) * (0.12 * speedMul);
        pet.y += (ty - pet.y) * (0.12 * speedMul);

        // ATTACK FIRST - Fire if in range (priority over skills)
        if (target && !target.isPlayer && !target.playerId) {
          const dist = Math.hypot(target.x - pet.x, target.y - pet.y);
          const atkRange = 280;
          pet.fireCD = Math.max(0, (pet.fireCD || 0) - dtMs * (speedMul));
          if (dist < atkRange && pet.fireCD <= 0) {
            const base = 15 + Math.floor(Math.random() * 10);
            const dmg = Math.round(base * (pet._berserkMul || 1));
            target.hp -= dmg;
            addFloater(target.x, target.y - 20, '-' + dmg, '#c1ffc1');

            // Handle different target types
            if (target.hp <= 0) {
              if (target.isPlayer || target.playerId) {
                // Don't kill players - reset HP to 1
                target.hp = 1;
                console.log('Pet prevented from killing player');
              } else if (target.isChest || target.chestType) {
                // Handle treasure damage with special function
                damageTreasureWithPet(pet, target, dmg);
              } else {
                // Handle enemy death and give pet experience
                onEnemyKilled(target);
                pet.experience = (pet.experience || 0) + 10;
                checkPetLevelUp(pet);
              }
            }
            // visual tracer
            st.shots.push({ x: pet.x, y: pet.y, vx: 400, vy: (Math.random() - 0.5) * 80, dmg: 0, life: 420, w: 6, h: 3, color: '#c1ffc1', ownerId: pet.id });
            pet.fireCD = 1200;

            // ONLY use skills AFTER attacking and with delay
            setTimeout(() => {
              if (pet.skills && pet.skills.length > 0 && Math.random() < 0.3) {
                const randomSkill = pet.skills[Math.floor(Math.random() * pet.skills.length)];
                if (pet.skillCooldowns && pet.skillCooldowns[randomSkill] <= 0) {
                  usePetSkill(pet, randomSkill);
                }
              }
            }, 800 + Math.random() * 1200); // 0.8-2.0 second delay after attack
          }
        }
      }
    }

    // Simplified pet skill system
    function usePetSkill(pet, skillName) {
      if (!pet || !skillName) return;

      // Simple cooldown system
      pet.skillCooldowns[skillName] = 5000; // 5 second cooldown

      // Execute skill effect
      executePetSkillEffect(pet, skillName);

      notify(`Pet used ${skillName}`, '#ffd700');
    }

    function executePetSkillEffect(pet, skillName) {
      const player = st.players[0];
      if (!player) return;

      switch (skillName) {
        case 'attack_boost':
          // Boost pet's attack power
          pet._berserkMul = 2.0;
          pet._berserkT = 5000; // 5 seconds
          addFloater(pet.x, pet.y - 20, 'BOOST', '#ff4444');
          break;

        case 'heal':
          // Heal player and pets
          player.hp = Math.min(player.hpMax || 100, player.hp + 30);
          st.activePets.forEach(p => {
            if (p && !p.isDefeated) {
              p.hp = Math.min(p.hpMax || 100, p.hp + 25);
            }
          });
          addFloater(pet.x, pet.y - 20, 'HEAL', '#4CAF50');
          break;
      }
    }

    function findNearestEnemyToPet(pet) {
      let nearest = null;
      let bestDist = Infinity;

      // Target enemies only, not players
      for (const e of st.enemies) {
        if (e.hp <= 0 || e.isDefeated) continue;
        // Make sure we're not targeting players
        if (e.isPlayer || e.playerId || e.name === 'Player') continue;
        const dist = Math.hypot(e.x - pet.x, e.y - pet.y);
        if (dist < bestDist) {
          bestDist = dist;
          nearest = e;
        }
      }

      // Also check for treasure/chests that can be damaged
      if (st.chests) {
        for (const chest of st.chests) {
          if (chest.hp <= 0 || chest.isOpened) continue;
          const dist = Math.hypot(chest.x - pet.x, chest.y - pet.y);
          if (dist < bestDist && dist < 200) { // Only target nearby treasure
            nearest = chest;
            bestDist = dist;
          }
        }
      }

      return nearest;
    }

    // Simple pet leveling system
    function checkPetLevelUp(pet) {
      if (!pet.experience) pet.experience = 0;
      const expNeeded = (pet.level || 1) * 50;

      if (pet.experience >= expNeeded) {
        pet.level = (pet.level || 1) + 1;
        pet.experience -= expNeeded;

        // Increase stats on level up
        pet.hpMax += 20;
        pet.hp = pet.hpMax; // Full heal
        pet.atk += 5;

        console.log(`Pet leveled up to ${pet.level}!`);
        notify(`Pet Level ${pet.level}!`, '#ffd700');
        addFloater(pet.x, pet.y - 30, `LEVEL ${pet.level}`, '#ffd700');
      }
    }

    // Enhanced treasure damage system for pets
    function damageTreasureWithPet(pet, treasure, damage) {
      if (!treasure || treasure.isOpened) return;

      // Apply damage to treasure
      treasure.hp = Math.max(0, treasure.hp - damage);

      // Visual feedback
      addFloater(treasure.x, treasure.y - 20, '-' + damage, '#ffd700');

      // Check if treasure should open
      if (treasure.hp <= 0) {
        treasure.isOpened = true;
        openChest(treasure);
        console.log(`Pet ${pet.name || 'Unknown'} opened treasure!`);
        notify('Treasure opened by pet!', '#ffd700');
      }
    }

    // Simple pet spawning for testing
    function spawnTestPet() {
      if (!st.activePets) st.activePets = [];

      const pet = {
        id: Math.random(),
        name: 'Test Pet',
        x: 100,
        y: DESIGN_H - 100,
        hp: 100,
        hpMax: 100,
        atk: 20,
        level: 1,
        experience: 0,
        owner: st.players[0]?.id || 'player1',
        fireCD: 0,
        skills: ['attack_boost', 'heal'],
        skillCooldowns: {},
        _berserkMul: 1,
        _berserkT: 0
      };

      // Initialize pet
      initializePetSkills(pet);
      st.activePets.push(pet);

      console.log('Test pet spawned!');
      notify('Pet spawned!', '#2EA8FF');
    }

    // Make functions globally accessible
    window.spawnTestPet = spawnTestPet;
    window.usePetSkill = usePetSkill;

    /* ================== Enhanced Game Logic System ================== */

    // Stage management system
    const STAGE_SYSTEM = {
      currentStage: 1,
      currentWave: 1,
      stageData: null,

      // Initialize stage system
      init() {
        this.loadStageData();
        this.applyStageTheme();
        this.setupStageMechanics();
      },

      // Load stage data from the enemy pack
      loadStageData() {
        try {
          const enemyPack = JSON.parse(document.getElementById('enemy-pack').textContent);
          this.stageData = enemyPack.stages.find(s => s.id === this.currentStage);
          if (this.stageData) {
            console.log(`Loaded stage: ${this.stageData.name}`);
            this.showStageInfo();
          }
        } catch (error) {
          console.error('Failed to load stage data:', error);
        }
      },

      // Apply stage-specific theming
      applyStageTheme() {
        if (!this.stageData) return;

        const themes = {
          forest: { bg: '#0d4f0d', particles: 'green' },
          mountain: { bg: '#4a4a4a', particles: 'gray' },
          desert: { bg: '#8b4513', particles: 'orange' },
          crystal: { bg: '#4b0082', particles: 'purple' },
          volcano: { bg: '#8b0000', particles: 'red' },
          ice: { bg: '#4682b4', particles: 'blue' },
          shadow: { bg: '#2f2f2f', particles: 'black' },
          storm: { bg: '#1a1a2e', particles: 'yellow' },
          void: { bg: '#000000', particles: 'white' },
          final_boss: { bg: '#8b0000', particles: 'gold' }
        };

        const theme = themes[this.stageData.theme];
        if (theme) {
          document.body.style.background = `linear-gradient(135deg, ${theme.bg}, #000000)`;
          this.createThemeParticles(theme.particles);
        }
      },

      // Create visual particles for stage theme
      createThemeParticles(color) {
        // Simple particle effect
        for (let i = 0; i < 20; i++) {
          setTimeout(() => {
            addFloater(
              Math.random() * DESIGN_W,
              Math.random() * DESIGN_H,
              '✦',
              color
            );
          }, i * 100);
        }
      },

      // Setup stage-specific mechanics
      setupStageMechanics() {
        if (!this.stageData || !this.stageData.specialMechanics) return;

        this.stageData.specialMechanics.forEach(mechanic => {
          this.activateMechanic(mechanic);
        });
      },

      // Activate specific stage mechanics
      activateMechanic(mechanic) {
        switch (mechanic) {
          case 'treasure_chests':
            this.spawnStageTreasures();
            break;
          case 'healing_pools':
            this.createHealingPools();
            break;
          case 'flying_enemies':
            this.enableFlyingEnemies();
            break;
          case 'sandstorms':
            this.startSandstorm();
            break;
          case 'lava_damage':
            this.addLavaDamage();
            break;
          case 'freeze_effects':
            this.enableFreezeEffects();
            break;

          case 'lightning_strikes':
            this.enableLightning();
            break;
          case 'gravity_shifts':
            this.enableGravityShifts();
            break;
          case 'multi_phase_boss':
            this.enableMultiPhaseBoss();
            break;
        }
      },

      // Spawn stage-specific treasures
      spawnStageTreasures() {
        setTimeout(() => {
          for (let i = 0; i < 3; i++) {
            const treasure = {
              x: 200 + (i * 200),
              y: DESIGN_H - 100,
              hp: 100,
              hpMax: 100,
              chestType: 'supply',
              isChest: true
            };
            if (!st.chests) st.chests = [];
            st.chests.push(treasure);
          }
          notify('Treasure chests spawned!', '#ffd700');
        }, 2000);
      },

      // Create healing pools
      createHealingPools() {
        st.healingPools = st.healingPools || [];
        st.healingPools.push({
          x: DESIGN_W / 2,
          y: DESIGN_H - 150,
          radius: 50,
          healRate: 10
        });
        notify('Healing pools available!', '#4CAF50');
      },

      // Enable flying enemies
      enableFlyingEnemies() {
        st.flyingEnemiesEnabled = true;
        notify('Flying enemies detected!', '#ff6b35');
      },

      // Start sandstorm effect
      startSandstorm() {
        st.sandstormActive = true;
        st.sandstormDamage = 2;
        notify('Sandstorm approaching!', '#ff8c00');
      },

      // Add lava damage
      addLavaDamage() {
        st.lavaDamage = 5;
        st.lavaZones = [
          { x: 100, y: DESIGN_H - 50, width: 200, height: 20 },
          { x: 600, y: DESIGN_H - 50, width: 200, height: 20 }
        ];
        notify('Lava zones active!', '#ff0000');
      },

      // Enable freeze effects
      enableFreezeEffects() {
        st.freezeEffects = true;
        st.freezeChance = 0.1;
        notify('Freeze effects enabled!', '#00bfff');
      },

      // Enable lightning strikes
      enableLightning() {
        st.lightningStrikes = true;
        setInterval(() => {
          if (Math.random() < 0.1) {
            this.strikeLightning();
          }
        }, 2000);
        notify('Lightning storm active!', '#ffff00');
      },

      // Strike lightning
      strikeLightning() {
        const x = Math.random() * DESIGN_W;
        addFloater(x, 50, '⚡', '#ffff00');
        // Damage all entities in lightning area
        st.enemies?.forEach(enemy => {
          if (Math.abs(enemy.x - x) < 100) {
            enemy.hp -= 50;
          }
        });
        st.players?.forEach(player => {
          if (Math.abs(player.x - x) < 100) {
            player.hp -= 25;
          }
        });
      },

      // Enable gravity shifts
      enableGravityShifts() {
        st.gravityShifts = true;
        st.gravityMultiplier = 1.0;
        setInterval(() => {
          st.gravityMultiplier = Math.random() > 0.5 ? 1.5 : 0.5;
          notify(`Gravity shift: ${st.gravityMultiplier}x`, '#ff00ff');
        }, 5000);
      },

      // Enable multi-phase boss
      enableMultiPhaseBoss() {
        st.multiPhaseBoss = true;
        st.bossPhases = 3;
        notify('Multi-phase boss detected!', '#ff0000');
      },

      // Show stage information
      showStageInfo() {
        if (this.stageData) {
          notify(`Stage ${this.stageData.id}: ${this.stageData.name}`, '#2EA8FF');
          setTimeout(() => {
            notify(this.stageData.description, '#ffffff');
          }, 2000);
        }
      },

      // Progress to next stage
      nextStage() {
        this.currentStage++;
        this.currentWave = 1;
        this.init();
        notify(`Advanced to Stage ${this.currentStage}!`, '#ffd700');
      },

      // Get current wave data
      getCurrentWaveData() {
        if (!this.stageData || !this.stageData.waves) return null;
        return this.stageData.waves.find(w => w.id === this.currentWave);
      },

      // Progress to next wave
      nextWave() {
        this.currentWave++;
        const waveData = this.getCurrentWaveData();
        if (waveData) {
          notify(`Wave ${this.currentWave} starting!`, '#ff6b35');
          return waveData;
        } else {
          // Stage completed
          this.completeStage();
          return null;
        }
      },

      // Complete current stage
      completeStage() {
        const rewards = this.getStageRewards();
        this.giveStageRewards(rewards);
        notify(`Stage ${this.currentStage} completed!`, '#4CAF50');
        setTimeout(() => {
          this.nextStage();
        }, 3000);
      },

      // Get stage rewards
      getStageRewards() {
        const rewardData = {
          1: { gold: 500, exp: 1000, items: ["basic_weapon"] },
          2: { gold: 750, exp: 1500, items: ["mountain_gear"] },
          3: { gold: 1000, exp: 2000, items: ["desert_gear"] },
          4: { gold: 1250, exp: 2500, items: ["crystal_gear"] },
          5: { gold: 1500, exp: 3000, items: ["volcanic_gear"] },
          6: { gold: 1750, exp: 3500, items: ["ice_gear"] },
          7: { gold: 2000, exp: 4000, items: ["shadow_gear"] },
          8: { gold: 2250, exp: 4500, items: ["storm_gear"] },
          9: { gold: 2500, exp: 5000, items: ["void_gear"] },
          10: { gold: 5000, exp: 10000, items: ["legendary_gear", "master_pet"] }
        };
        return rewardData[this.currentStage] || { gold: 100, exp: 200, items: [] };
      },

      // Give stage rewards to player
      giveStageRewards(rewards) {
        st.gold = (st.gold || 0) + rewards.gold;
        window.QuestSystem?.trackProgress?.('gold', rewards.gold);
        st.experience = (st.experience || 0) + rewards.exp;

        rewards.items.forEach(item => {
          this.giveItem(item);
        });

        notify(`Rewards: ${rewards.gold} gold, ${rewards.exp} exp`, '#ffd700');
      },

      // Give item to player
      giveItem(itemName) {
        const item = this.createItem(itemName);
        if (!st.inv) st.inv = [];
        st.inv.push(item);
        notify(`Received: ${item.name}`, '#2EA8FF');
      },

      // Create item from name
      createItem(itemName) {
        const items = {
          basic_weapon: { name: 'Basic Sword', type: 'weapon', dmg: 10 },
          mountain_gear: { name: 'Mountain Armor', type: 'armor', def: 15 },
          desert_gear: { name: 'Desert Cloak', type: 'armor', def: 12 },
          crystal_gear: { name: 'Crystal Staff', type: 'weapon', dmg: 25 },
          volcanic_gear: { name: 'Volcanic Plate', type: 'armor', def: 20 },
          ice_gear: { name: 'Ice Blade', type: 'weapon', dmg: 30 },
          shadow_gear: { name: 'Shadow Cloak', type: 'armor', def: 18 },
          storm_gear: { name: 'Storm Hammer', type: 'weapon', dmg: 35 },
          void_gear: { name: 'Void Armor', type: 'armor', def: 25 },
          legendary_gear: { name: 'Legendary Equipment', type: 'legendary', dmg: 50 },
          master_pet: { name: 'Master Pet Egg', type: 'pet', rarity: 'legendary' }
        };

        return {
          id: Math.random(),
          ...items[itemName],
          stackable: false
        };
      }
    };

    // Initialize stage system when game starts
    function initializeStageSystem() {
      STAGE_SYSTEM.init();
      console.log('Stage system initialized');
    }

    // Make stage system globally accessible
    window.STAGE_SYSTEM = STAGE_SYSTEM;
    window.initializeStageSystem = initializeStageSystem;

    /* ================== Helper Functions ================== */
    function openChest(chest) {
      // Extended chest logic with supply and victory types
      if (chest.chestType === 'supply') {
        // Supply chest: heal party
        const healAmt2 = 200 + st.stage * 50;
        st.players.forEach(p => {
          if (!p.isDefeated) {
            p.hp = Math.min(p.hpMax || 0, (p.hp || 0) + healAmt2);
            addFloater(p.x, p.y - 40, '+' + healAmt2 + ' HP', '#36c777');
          }
        });
        if (Math.random() < 0.5) {
          st.giftKeys++;
          updateCurrencies();
          addFloater(chest.x, chest.y - 50, '+Gift Key', '#ff9aa8');
        } else {
          const extraGold2 = 100 + Math.floor(Math.random() * 200);
          st.gold += extraGold2;
          window.QuestSystem?.trackProgress?.('gold', extraGold2);
          updateCurrencies();
          addFloater(chest.x, chest.y - 50, '+' + extraGold2 + ' Gold', '#ffd56a');
        }
        notify('Supply Chest opened!', '#6aa8ff');
      } else if (chest.chestType === 'victory') {
        const bigGold2 = 500 + st.stage * 200;
        st.gold += bigGold2;
        window.QuestSystem?.trackProgress?.('gold', bigGold2);
        updateCurrencies();
        addFloater(chest.x, chest.y - 30, '+' + bigGold2 + ' Gold', '#ffd56a');
        const reward2 = rollLoot('bossChest');
        if (reward2) { addItemToBag(reward2); notify('Victory Loot: ' + reward2.name); }
        st.giftKeys += 2;
        updateCurrencies();
        notify('Victory Chest opened!', '#ffbb9a');
      } else {
        // Simple chest opening - grants random loot
        const lootRoll = Math.random();
        if (lootRoll < 0.6) {
          const item = rollLoot('mobChest');
          if (item) addItemToBag(item);
        } else if (lootRoll < 0.9) {
          const gold = 100 + Math.floor(Math.random() * 200);
          st.gold += gold;
          window.QuestSystem?.trackProgress?.('gold', gold);
          updateCurrencies();
          notify('+' + gold + ' Gold', '#ffd56a');
        } else {
          st.giftKeys++;
          updateCurrencies();
          notify('+1 Gift Key', '#ff9aa8');
        }
        notify('Chest opened!', '#6aa8ff');
      }
      // Remove chest after opening
      const idx = st.pickups.indexOf(chest);
      if (idx >= 0) st.pickups.splice(idx, 1);
    }

    function basicAttackAction(player) {
      // Enhanced character-specific basic attacks
      if (player.id === 'A1') {
        a1_basicAttack(player);
      } else if (player.id === 'Unique') {
        unique_basicAttack(player);
      } else if (player.id === 'Missy') {
        missy_basicAttack(player);
      } else {
        // Fallback for any other characters
        melee(player, 32, 38, Math.round(player.dmg * 0.8));
      }
    }

    /* ================== Enemy Shooting ================== */
    function enemyShoot(e) {
      const L = leader();
      if (!L) return;
      const dx = L.x - e.x, dy = L.y - e.y;
      const mag = Math.hypot(dx, dy) || 1;
      const isBig = (e.kind === 'boss' || e.kind === 'miniboss' || e.kind === 'waveleader');
      const speed = isBig ? 360 : 300;
      const dmg = isBig ? 20 : 10;
      st.eShots.push({
        x: e.x - 18,
        y: e.y - 30,
        vx: speed * (dx / mag),
        vy: speed * (dy / mag),
        speed,
        dmg,
        life: 2200,
        w: 24,
        h: 24,
        color: '#ffbb66'
      });
      e._justFired = true;
    }

    /* ================== Enemy Death / Drops (Unified) ================== */
    function onEnemyKilled(e) {
      // Remove enemy
      const idx = st.enemies.indexOf(e);
      if (idx >= 0) st.enemies.splice(idx, 1);
      if (window.ArenaSystem?.active && window.ArenaSystem?.awaitingClear) {
        const anyArena = st.enemies.some(enemy => enemy?.arenaEnemy);
        if (!anyArena) {
          try { window.ArenaSystem.onWaveComplete(); } catch (_) { }
        }
      }

      // Counters and session stats
      st.kills++;
      window.QuestSystem?.trackProgress?.('kill', 1, e?.kind);
      if (st.sessionStats) st.sessionStats.enemiesKilled = (st.sessionStats.enemiesKilled || 0) + 1;

      // Combo system tick on kill
      if (st.comboSystem) {
        st.comboSystem.currentCombo++;
        st.comboSystem.comboTimer = COMBO_WINDOW;
        if (st.comboSystem.currentCombo > (st.comboSystem.maxCombo || 0)) {
          st.comboSystem.maxCombo = st.comboSystem.currentCombo;
        }
        st.comboSystem.comboMultiplier = 1.0 + (st.comboSystem.currentCombo * 0.05);
        updateComboHUD();
      }

      // XP gain with combo multiplier
      const baseExp = 10 + (e.level || 0);
      const mult = (st.comboSystem && st.comboSystem.comboMultiplier) ? st.comboSystem.comboMultiplier : 1.0;
      const totalExp = Math.round(baseExp * mult);
      try { grantXP(totalExp); } catch (_err) { st.xp += totalExp; }
      addFloater(e.x, e.y - 40, `+${totalExp} XP${mult > 1 ? ' (' + (st.comboSystem?.currentCombo || 1) + 'x)' : ''}`, mult > 1 ? '#FFD700' : '#00FF88');

      // Boss tracking
      if (e.kind === 'boss' || e.kind === 'treasureboss') {
        st.bossKills++;
        st.bossAlive = false;
        st.postBossCalmWaves = Math.max(st.postBossCalmWaves || 0, 2);
        notify(`Boss defeated!${st.comboSystem ? ' (+' + st.comboSystem.currentCombo + ' combo)' : ''}`, '#FF6B35');
        window.QuestSystem?.trackProgress?.('boss', 1, e.kind || e.name);

        // Boss Pool System drops (50k-700k gold/silver, B-S rank loot)
        if (e.drops && Array.isArray(e.drops)) {
          for (const drop of e.drops) {
            switch (drop.kind) {
              case 'gold':
                st.gold += drop.amount;
                window.QuestSystem?.trackProgress?.('gold', drop.amount);
                addFloater(e.x, e.y - 60, `+${Math.floor(drop.amount / 1000)}k Gold`, '#ffd56a');
                break;
              case 'silver':
                st.silver = (st.silver || 0) + drop.amount;
                addFloater(e.x, e.y - 80, `+${Math.floor(drop.amount / 1000)}k Silver`, '#c0c0c0');
                break;
              case 'armor':
                // Add B/A/S rank armor to inventory
                addItemToBag({
                  id: Math.random(),
                  type: 'gear',
                  slot: 'chest',
                  rank: drop.rank,
                  name: `${drop.rank}-Rank Armor`,
                  def: drop.rank === 'S' ? 30 : drop.rank === 'A' ? 20 : 15
                });
                addFloater(e.x, e.y - 100, `${drop.rank} Armor!`, '#6aa8ff');
                break;
              case 'petShard':
                // Add pet shards
                addItemToBag({
                  id: Math.random(),
                  type: 'petShard',
                  name: `${drop.which} Shard`,
                  petType: drop.which,
                  stackable: true,
                  qty: drop.qty
                });
                addFloater(e.x, e.y - 120, `+${drop.qty} ${drop.which} Shards`, '#ff6aa8');
                break;
              case 'bossKey':
                st.bossKeys = (st.bossKeys || 0) + drop.qty;
                addFloater(e.x, e.y - 140, '+Boss Key', '#ff4d4f');
                break;
              case 'gear':
                // B/A/S rank gear
                addItemToBag({
                  id: Math.random(),
                  type: 'gear',
                  slot: drop.slot || 'weapon',
                  rank: drop.rank,
                  name: `${drop.rank}-Rank Gear`,
                  atk: drop.rank === 'S' ? 25 : drop.rank === 'A' ? 18 : 12
                });
                addFloater(e.x, e.y - 100, `${drop.rank} Gear!`, '#9fe8ff');
                break;
              case 'vehicleBox':
                // Vehicle box drop
                addItemToBag({
                  id: Math.random(),
                  type: 'vehicle_box',
                  name: 'Vehicle Box',
                  stackable: true
                });
                addFloater(e.x, e.y - 110, '+Vehicle Box', '#ff6aa8');
                break;
              case 'gearKit':
                // B/A rank gear kit
                addItemToBag({
                  id: Math.random(),
                  type: 'gear',
                  slot: 'weapon',
                  rank: drop.rank,
                  name: `${drop.rank}-Rank Gear`,
                  atk: drop.rank === 'A' ? 18 : 12
                });
                addFloater(e.x, e.y - 120, `${drop.rank} Gear!`, '#9fe8ff');
                break;
              case 'giftBox':
                // Gift box drop
                addItemToBag({
                  id: Math.random(),
                  type: 'gift',
                  name: 'Gift Box',
                  stackable: true
                });
                addFloater(e.x, e.y - 130, '+Gift Box', '#ff9aa8');
                break;
              case 'consumable':
                addItemToBag({
                  id: Math.random(),
                  type: drop.id,
                  name: drop.id === 'rage_pill' ? 'Rage Pill' : 'Item',
                  stackable: true
                });
                addFloater(e.x, e.y - 110, `+${drop.id}`, '#f9cc2b');
                break;
            }
          }
        }
      }

      // Endless mode boss rewards
      if (e.kind === 'endless_boss') {
        st.bossAlive = false;

        // Massive XP and gold rewards for endless bosses
        const endlessXP = Math.floor(100 * Math.pow(1.2, st.stage - 100));
        const endlessGold = Math.floor(500 * Math.pow(1.2, st.stage - 100));
        const endlessGems = Math.floor(5 + (st.stage - 100) / 10);

        try { grantXP(endlessXP); } catch (_err) { st.xp += endlessXP; }
        st.gold += endlessGold;
        window.QuestSystem?.trackProgress?.('gold', endlessGold);
        st.gems += endlessGems;

        addFloater(e.x, e.y - 60, `+${endlessXP} XP`, '#FFD700');
        addFloater(e.x, e.y - 80, `+${endlessGold} Gold`, '#FFD700');
        addFloater(e.x, e.y - 100, `+${endlessGems} Gems`, '#6aa8ff');

        notify(`ENDLESS BOSS DEFEATED! +${endlessXP} XP`, '#ff4444');
        updateQuestProgress('bosses', 1);

        // Update endless score
        if (st.endlessScore) {
          st.endlessScore += endlessXP * 2 + endlessGold + endlessGems * 100;
        }
      }

      // Clone leveling/heal on any kill; extra when clone is killer
      try {
        st.clones = st.clones || [];
        for (const c of st.clones) {
          if (!c.hpMax) continue;
          c.level = (c.level || 1) + 1;
          const s = 1.02;
          c.atkMult = (c.atkMult || 1) * s;
          c.hpMax = Math.round((c.hpMax) * s);
          c.hp = Math.min(c.hpMax, Math.round((c.hp || c.hpMax) * s));
        }
        if (e._lastHitBy === 'clone') {
          const killer = st.clones?.[0];
          if (killer) {
            const extra = 1.08;
            killer.level = (killer.level || 1) + 1;
            killer.atkMult = (killer.atkMult || 1) * extra;
            killer.hpMax = Math.round(killer.hpMax * extra);
            killer.hp = Math.min(killer.hpMax, Math.round((killer.hp || killer.hpMax) * extra));
          }
        }
        for (const c of st.clones) {
          c.hp = Math.min(c.hpMax || 1, (c.hp || 0) + Math.round((c.hpMax || 1) * 0.05));
        }
      } catch (_) { }

      // Ramp drop rate and update HUD
      st.dropRateBonus = Math.min(st.maxDropRateBonus, st.dropRateBonus + 0.001); // +0.1%
      updateDropRate();

      // Quest updates
      updateQuestProgress('kills', 1, e.kind);
      if (e.kind === 'boss' || e.kind === 'treasureboss') updateQuestProgress('bosses', 1);

      // Fill secret gauge for all active players
      st.players.forEach(p => {
        if (p.isDefeated) return;
        let baseGain = 5;
        if (e.kind === 'boss' || e.kind === 'endless_boss' || e.kind === 'treasureboss') baseGain = 30;
        else if (e.kind === 'miniboss' || e.kind === 'waveleader') baseGain = 15;
        fillSecretGauge(p, baseGain);
      });

      // Base gold plus ramped loot
      const luckBoost = ((st._usLuck || 0) * 0.001);
      const dropBonus = (st.npcSkillEffects?.dropBonus || 0);
      const currentDropRate = st.baseDropRate + st.dropRateBonus + luckBoost + dropBonus;
      const baseGold = 20 + Math.floor(Math.random() * 40);
      st.gold += baseGold;
      window.QuestSystem?.trackProgress?.('gold', baseGold);
      updateQuestProgress('gold', baseGold);

      if (Math.random() < currentDropRate) {
        const dropTypes = ['gold', 'gift', 'box'];
        const dropType = dropTypes[Math.floor(Math.random() * dropTypes.length)];
        switch (dropType) {
          case 'gold': {
            const bonusGold = 30 + Math.floor(Math.random() * 120);
            st.gold += bonusGold;
            window.QuestSystem?.trackProgress?.('gold', bonusGold);
            addFloater(e.x, e.y - 30, `+${bonusGold}G`, '#ffd56a');
            break;
          }
          case 'gift': {
            st.giftKeys++;
            addFloater(e.x, e.y - 30, '+Gift', '#ff9aa8');
            break;
          }
          case 'box': {
            const boxItemData = { id: Math.random(), name: 'Loot Box', type: 'box', slot: 'item', rank: 'C' };
            st.pickups.push({ kind: 'pickup', x: e.x, y: e.y, life: 15000, itemData: boxItemData });
            addFloater(e.x, e.y - 30, 'DROP!', '#6aa8ff');
            break;
          }
        }
      }

      // Special enemy loot cases
      const chestRoll = Math.random();
      const luckScale = 1 + (st.luck || 0) * 0.01;
      if (e.kind === 'miniboss' || e.kind === 'waveleader') {
        const it = rollLoot('miniBossChest'); if (it) { addItemToBag(it); notify('Mini-Boss Gear: ' + it.name); }
      } else if (e.kind === 'boss' || e.kind === 'endless_boss') {
        st.bossAlive = false;
        st.postBossCalmWaves = Math.max(st.postBossCalmWaves || 0, 2);
        // Direct boss reward to bag: one A–S rank gear
        try {
          const pool = (LOOT_TABLES.bossChest || []).filter(i => i.rank === 'A' || i.rank === 'S');
          if (pool.length) {
            const tpl = pool[Math.floor(Math.random() * pool.length)];
            const item = JSON.parse(JSON.stringify(tpl));
            item.id = Math.random(); item.type = 'gear'; item.level = 0;
            addItemToBag(item);
            notify('Boss Reward: ' + item.name + ' [' + (item.rank || '-') + ']', '#ffd56a');
          }
        } catch (_e) { }
      } else if (e.kind === 'treasureboss') {
        st.bossAlive = false;
        const gold = 1000 + Math.floor(Math.random() * 2000);
        st.gold += gold; addFloater(e.x, e.y - 30, `+${gold}G`, '#ffd56a');
        const it = rollLoot('bossChest'); if (it) { addItemToBag(it); notify('Treasure Boss Gear: ' + it.name); }
        const it2 = rollLoot('bossChest'); if (it2) { addItemToBag(it2); notify('Treasure Boss Gear: ' + it2.name); }
        st.giftKeys += 3; notify('+3 Gift Keys', '#ff9aa8');
      } else if (chestRoll < 0.02 * luckScale) {
        const it = rollLoot('mobChest'); if (it) { addItemToBag(it); notify('Loot: ' + it.name); }
      }

      updateCurrencies();

    }

    /* ================== Currency UI ================== */
    function updateCurrencies() {
      $('#goldVal').textContent = st.gold;
      $('#silverVal').textContent = st.silver;
      $('#ticketVal').textContent = st.tickets;
      $('#gemVal').textContent = st.gems;
      $('#bossKillsVal').textContent = st.bossKills;
      $('#giftKeyVal').textContent = st.giftKeys;
      $('#bossKeyVal').textContent = st.bossKeys;
      if (st.bagOpen) $('#bagGoldVal').textContent = st.gold;
    }

    /* ================== Input / Controls ================== */
    $('#btnSpeed').onclick = () => {
      const i = SPEEDS.indexOf(st.speed);
      st.speed = SPEEDS[(i + 1) % SPEEDS.length];
      $('#btnSpeed').textContent = '×' + st.speed;
    };
    $('#btnStart').onclick = () => { st.running = !st.running; $('#btnStart').textContent = st.running ? 'Pause' : 'Start'; };
    $('#btnAuto').onclick = () => {
      // Toggle auto-play state and update label.  The button should reflect the
      // current auto status ("Auto: ON" when enabled and "Auto: OFF" when disabled).
      st.auto = !st.auto;
      $('#btnAuto').textContent = 'Auto: ' + (st.auto ? 'ON' : 'OFF');
    };

    // Ensure the auto button label reflects the initial auto state on page load.
    (function updateAutoLabelOnInit() {
      const btn = document.getElementById('btnAuto');
      if (btn) {
        btn.textContent = 'Auto: ' + (st.auto ? 'ON' : 'OFF');
      }
    })();

    (document.getElementById('hudBtnRage') || document.getElementById('btnRage'))?.addEventListener('click', () => triggerRageFor(leader()));

    // Wire the new AI button to the existing AI functionality
    document.getElementById('hudBtnAI')?.addEventListener('click', () => {
      // Trigger the same functionality as the existing AI button
      const existingAIButton = document.getElementById('btnAISummon');
      if (existingAIButton) {
        existingAIButton.click();
      }
    });

    document.getElementById('btnAISummonPanel')?.addEventListener('click', () => {
      document.getElementById('btnAISummon')?.click();
    });

    // UI Hide/Show Controls
    document.getElementById('btnHideAll')?.addEventListener('click', () => {
      document.querySelectorAll('#vj-wrap, .controls, .hud').forEach(el => el.style.display = 'none');
    });

    document.getElementById('btnShowAll')?.addEventListener('click', () => {
      document.querySelectorAll('#vj-wrap, .controls, .hud').forEach(el => el.style.display = '');
    });

    document.getElementById('btnHideUI')?.addEventListener('click', () => {
      document.querySelectorAll('#vj-wrap, .controls, .hud, .compact-stats').forEach(el => el.style.display = 'none');
    });

    document.getElementById('btnShowUI')?.addEventListener('click', () => {
      document.querySelectorAll('#vj-wrap, .controls, .hud, .compact-stats').forEach(el => el.style.display = '');
    });

    // Individual control toggles
    document.getElementById('toggleJoystick')?.addEventListener('change', (e) => {
      document.getElementById('vj-root')?.style.setProperty('display', e.target.checked ? '' : 'none');
    });

    document.getElementById('toggleSkills')?.addEventListener('change', (e) => {
      document.querySelector('.skill-row')?.style.setProperty('display', e.target.checked ? '' : 'none');
    });

    document.getElementById('toggleActions')?.addEventListener('change', (e) => {
      document.querySelectorAll('.big-btn.attack, .big-btn.jump')?.forEach(btn =>
        btn.style.setProperty('display', e.target.checked ? '' : 'none')
      );
    });

    document.getElementById('toggleRageShield')?.addEventListener('change', (e) => {
      document.querySelector('.rage-shield-container')?.style.setProperty('display', e.target.checked ? '' : 'none');
    });

    document.getElementById('toggleAI')?.addEventListener('change', (e) => {
      document.getElementById('hudBtnAI')?.style.setProperty('display', e.target.checked ? '' : 'none');
    });

    // Position Memory Button Events
    document.getElementById('btnResetPositions')?.addEventListener('click', () => {
      resetControlPositions();
    });

    document.getElementById('btnSavePositions')?.addEventListener('click', () => {
      saveControlPositions();
    });

    // Visual Feedback System
    function addButtonFeedback(buttonId, animationClass = 'btn-press') {
      const button = document.getElementById(buttonId);
      if (!button) return;

      button.addEventListener('click', () => {
        button.classList.add(animationClass);
        setTimeout(() => button.classList.remove(animationClass), 300);
      });
    }

    function addButtonGlow(buttonId) {
      const button = document.getElementById(buttonId);
      if (!button) return;

      button.classList.add('btn-glow');
    }

    function removeButtonGlow(buttonId) {
      const button = document.getElementById(buttonId);
      if (!button) return;

      button.classList.remove('btn-glow');
    }

    // Apply feedback to all control buttons
    addButtonFeedback('hudBtnAttack');
    addButtonFeedback('hudBtnJump');
    addButtonFeedback('hudBtnRage');
    addButtonFeedback('hudBtnShield');
    addButtonFeedback('hudBtnAI');
    addButtonFeedback('hudBtnS1');
    addButtonFeedback('hudBtnS2');
    addButtonFeedback('hudBtnS3');

    // Add glow effects for ready states
    function updateButtonGlows() {
      // Add glow to AI button when ready
      const aiButton = document.getElementById('hudBtnAI');
      if (aiButton) {
        aiButton.classList.add('btn-glow');
      }

      // Add glow to skills when ready
      document.querySelectorAll('.skill-pill.ready').forEach(skill => {
        skill.classList.add('btn-glow');
      });
    }

    // Update glows periodically
    setInterval(updateButtonGlows, 1000);

    // Dynamic Control Sizing System
    const sizePresets = {
      small: 0.6,
      medium: 0.7,
      large: 0.85,
      xlarge: 1.0
    };

    function setControlSize(size) {
      const leftEl = document.getElementById('vj-left');
      const rightEl = document.getElementById('vj-right');
      if (!leftEl || !rightEl) return;

      // Get current transform values and update scale
      const leftTransform = leftEl.style.transform || 'translateX(95%) scale(0.7)';
      const rightTransform = rightEl.style.transform || 'translateX(-95%) scale(0.7)';

      // Extract translateX values and apply new scale
      const leftTranslateX = leftTransform.includes('translateX(') ?
        leftTransform.match(/translateX\([^)]+\)/)[0] : 'translateX(95%)';
      const rightTranslateX = rightTransform.includes('translateX(') ?
        rightTransform.match(/translateX\([^)]+\)/)[0] : 'translateX(-95%)';

      leftEl.style.transform = `${leftTranslateX} scale(${size})`;
      rightEl.style.transform = `${rightTranslateX} scale(${size})`;

      // Save to localStorage
      localStorage.setItem('controlSize', size);

      // Update display
      document.getElementById('sizeValue').textContent = Math.round(size * 100) + '%';
    }

    function loadControlSize() {
      const savedSize = localStorage.getItem('controlSize');
      if (savedSize) {
        const size = parseFloat(savedSize);
        setControlSize(size);
        document.getElementById('sizeSlider').value = size;
        document.getElementById('sizeValue').textContent = Math.round(size * 100) + '%';

        // Update preset dropdown
        const preset = Object.keys(sizePresets).find(key =>
          Math.abs(sizePresets[key] - size) < 0.01
        );
        if (preset) {
          document.getElementById('sizePreset').value = sizePresets[preset];
        }
      }
    }

    function autoDetectSize() {
      const screenWidth = window.innerWidth;
      const screenHeight = window.innerHeight;
      const isMobile = screenWidth < 768;
      const isTablet = screenWidth >= 768 && screenWidth < 1024;

      let suggestedSize = 0.7; // Default

      if (isMobile) {
        suggestedSize = screenHeight < 600 ? 0.6 : 0.7;
      } else if (isTablet) {
        suggestedSize = 0.85;
      } else {
        suggestedSize = 1.0;
      }

      setControlSize(suggestedSize);
      document.getElementById('sizeSlider').value = suggestedSize;
      document.getElementById('sizeValue').textContent = Math.round(suggestedSize * 100) + '%';
    }

    // Event listeners for sizing controls
    document.getElementById('sizePreset')?.addEventListener('change', (e) => {
      const size = parseFloat(e.target.value);
      setControlSize(size);
      document.getElementById('sizeSlider').value = size;
    });

    document.getElementById('sizeSlider')?.addEventListener('input', (e) => {
      const size = parseFloat(e.target.value);
      setControlSize(size);
    });

    document.getElementById('btnAutoSize')?.addEventListener('click', () => {
      autoDetectSize();
    });

    // Load saved size on init
    loadControlSize();

    // Position Memory System
    function saveControlPositions() {
      const leftEl = document.getElementById('vj-left');
      const rightEl = document.getElementById('vj-right');
      if (!leftEl || !rightEl) return;

      const leftTransform = leftEl.style.transform || 'translateX(95%) scale(0.7)';
      const rightTransform = rightEl.style.transform || 'translateX(-95%) scale(0.7)';

      const controlState = {
        leftTransform: leftTransform,
        rightTransform: rightTransform,
        timestamp: Date.now()
      };

      localStorage.setItem('controlPositions', JSON.stringify(controlState));
    }

    function loadControlPositions() {
      try {
        const saved = JSON.parse(localStorage.getItem('controlPositions') || '{}');
        if (saved.leftTransform && saved.rightTransform) {
          const leftEl = document.getElementById('vj-left');
          const rightEl = document.getElementById('vj-right');
          if (leftEl && rightEl) {
            leftEl.style.transform = saved.leftTransform;
            rightEl.style.transform = saved.rightTransform;
          }
        }
      } catch (e) {
        console.warn('Failed to load control positions:', e);
      }
    }

    function resetControlPositions() {
      const leftEl = document.getElementById('vj-left');
      const rightEl = document.getElementById('vj-right');
      if (leftEl && rightEl) {
        leftEl.style.transform = 'translateX(95%) scale(0.7)';
        rightEl.style.transform = 'translateX(-95%) scale(0.7)';
        saveControlPositions();
      }
    }

    // Load positions on init
    loadControlPositions();

    // Save positions when they change (add to existing transform changes)
    const originalSetTransform = (el, transform) => {
      if (el) {
        el.style.transform = transform;
        saveControlPositions();
      }
    };

    /* ================== Boss Taming System ================== */
    function checkBossTaming(boss) {
      // Only allow taming on waves 3-8
      const wave = st.wave || 1;
      if (wave < 3 || wave > 8) return false;

      // Check if at capacity
      if (st.tamedBosses.length >= st.maxTamedBosses) return false;

      // Only tame regular bosses, not big bosses or minibosses
      if (boss.pool === 'bigBoss' || boss.pool === 'miniBoss') return false;

      // Check HP threshold (below 30%)
      const hpPercent = boss.hp / boss.max;
      if (hpPercent > 0.30) return false;

      // Random chance based on HP (lower HP = higher chance)
      const tameChance = st.tameChanceBase * (1 - hpPercent) * 3; // Up to 45% at very low HP
      if (Math.random() > tameChance) return false;

      // Mark boss as requesting taming
      boss._requestingTame = true;
      boss._stunned = 3000; // Stun for 3 seconds while waiting for answer
      showTamingDialog(boss);
      return true;
    }

    function showTamingDialog(boss) {
      // Pause game slightly
      st.matchStarted = false;

      // Create dialog
      const dialogId = 'tamingDialog';
      let el = document.getElementById(dialogId);

      if (!el) {
        el = document.createElement('div');
        el.id = dialogId;
        el.className = 'taming-dialog';
        el.innerHTML = `
          <div class="taming-dialog-box">
            <div id="tamingBossName" class="taming-boss-name"></div>
            <div class="taming-message">wants to join your party!</div>
            <div class="taming-count">Companions: <span id="tamingCount"></span>/${st.maxTamedBosses}</div>
            <div class="taming-buttons">
              <button id="tameYes" class="taming-btn-accept">Accept</button>
              <button id="tameNo" class="taming-btn-decline">Decline</button>
            </div>
          </div>
        `;
        document.body.appendChild(el);
      }

      // Update dialog content
      document.getElementById('tamingBossName').textContent = boss.name || 'Boss';
      document.getElementById('tamingCount').textContent = st.tamedBosses.length;

      // Show dialog
      el.style.display = 'flex';

      // Handle responses
      document.getElementById('tameYes').onclick = () => {
        acceptTaming(boss);
        el.style.display = 'none';
        st.matchStarted = true;
      };

      document.getElementById('tameNo').onclick = () => {
        declineTaming(boss);
        el.style.display = 'none';
        st.matchStarted = true;
      };

      // Auto-decline after 5 seconds
      setTimeout(() => {
        if (el.style.display === 'flex') {
          declineTaming(boss);
          el.style.display = 'none';
          st.matchStarted = true;
        }
      }, 5000);
    }

    function acceptTaming(boss) {
      // Remove from enemies
      const idx = st.enemies.indexOf(boss);
      if (idx >= 0) st.enemies.splice(idx, 1);

      // Convert to companion
      const companion = {
        id: 'tamed_' + Math.random(),
        name: boss.name,
        kind: 'companion',
        sprite: boss.sprite,
        x: boss.x,
        y: boss.y,
        hp: Math.round(boss.hp * 1.5), // Heal 50% when tamed
        hpMax: boss.max,
        max: boss.max,
        atk: Math.round(boss.atk * 0.7), // Slightly weaker as companion
        def: boss.def,
        dmg: Math.round((boss.dmg || boss.atk) * 0.7),
        pool: boss.pool,
        affixes: boss.affixes || [],
        facingLeft: false,
        _attackCooldown: 0,
        _gcdT: 0,
        _aiState: 'follow',
        _aiTimer: 0,
        isTamed: true,
        originalBoss: true
      };

      // Add to tamed bosses
      st.tamedBosses.push(companion);

      // Visual effects
      addCast(boss.x, boss.y, '#ffd56a', 800);
      addFloater(boss.x, boss.y - 60, 'TAMED!', '#ffd56a');
      notify(`${boss.name} joined your party!`, '#ffd56a');

      // Update counters
      st.kills++; // Count as kill for progression
      window.QuestSystem?.trackProgress?.('tame', 1, boss.name || boss.id || 'companion');
      updateCompanionHUD();
    }

    function declineTaming(boss) {
      // Resume combat
      boss._requestingTame = false;
      boss._stunned = 0;
      notify('Taming declined - combat continues', '#ff6aa8');
    }

    /* ================== Companion HUD ================== */
    function companionSafeName(name) {
      const raw = String(name || 'Companion');
      return raw.replace(/[&<>"']/g, (ch) => {
        switch (ch) {
          case '&': return '&amp;';
          case '<': return '&lt;';
          case '>': return '&gt;';
          case '"': return '&quot;';
          default: return '&#39;';
        }
      });
    }

    function renderCompanionCardMarkup(companion) {
      const hpMax = Math.max(1, Math.round(companion.hpMax || companion.max || 0) || 1);
      const hpCurrent = Math.max(0, Math.min(hpMax, Math.round(companion.hp || 0)));
      const hpPct = Math.max(0, Math.min(100, Math.round((hpCurrent / hpMax) * 100)));
      const roleLabel = companion.isTamed ? 'AI' : 'ALLY';
      return `
        <div class="companion-panel-card">
          <div class="companion-panel-top">
            <span class="companion-panel-name">${companionSafeName(companion.name)}</span>
            <span class="companion-panel-role">${roleLabel}</span>
          </div>
          <div class="companion-panel-bar">
            <span class="companion-panel-bar-fill" style="width:${hpPct}%;"></span>
          </div>
          <div class="companion-panel-hp">${hpCurrent}/${hpMax}</div>
        </div>
      `;
    }

    function syncTeamCompanionPanel() {
      // DISABLED: Floating companion panels moved to Team Management modal
      // const panel = document.getElementById('teamCompanionPanel');
      // const btn = document.getElementById('btnTeam');
      // if (!panel || !btn) return;
      // const companions = Array.isArray(st.tamedBosses) ? st.tamedBosses : [];
      // if (!companions.length) {
      //   panel.classList.remove('visible');
      //   panel.innerHTML = '';
      //   return;
      // }
      // panel.innerHTML = companions.map(renderCompanionCardMarkup).join('');
      // const rect = btn.getBoundingClientRect();
      // panel.style.left = `${Math.round(rect.left)}px`;
      // panel.style.top = `${Math.round(rect.bottom + 10)}px`;
      // panel.classList.add('visible');
    }

    function updateCompanionHUD() {
      // DISABLED: Floating companion panels moved to Team Management modal
      // const hud = document.getElementById('companionHUD');
      // const companions = Array.isArray(st.tamedBosses) ? st.tamedBosses : [];
      // if (hud) {
      //   if (!companions.length) {
      //     hud.innerHTML = '';
      //     hud.classList.remove('visible');
      //   } else {
      //     hud.innerHTML = companions.map(renderCompanionCardMarkup).join('');
      //     hud.classList.add('visible');
      //   }
      // }
      // syncTeamCompanionPanel();
    }

    // Update companion HUD periodically
    setInterval(updateCompanionHUD, 200);
    window.addEventListener('resize', () => syncTeamCompanionPanel());
    window.addEventListener('scroll', () => syncTeamCompanionPanel(), true);
    updateCompanionHUD();

    (function () {
      const shieldEl = document.getElementById('hudBtnShield') || document.getElementById('btnShield');
      if (!shieldEl) return;
      shieldEl.addEventListener('click', () => {
        if (!st.shieldCD || st.shieldCD <= 0) {
          st.shieldOn = true;
          st.shieldT = 3000; // 3 seconds duration
          st.shieldCD = 5000; // 5 seconds cooldown
          notify('Shields Up!', '#6aa8ff');
        } else {
          notify('Shield on cooldown', '#ff7a6a');
        }
      });
    })();
    const jumpBtnMain = document.getElementById('hudBtnJump') || document.getElementById('btnJump');
    if (jumpBtnMain) jumpBtnMain.addEventListener('click', () => jumpAll());
    document.getElementById('btnUniversalAction')?.addEventListener('click', () => performUniversalAction());
    // Clone stance button removed per request; stance fixed to 'assault'.
    // Make the small button by the joystick perform the contextual Open/Pick/Use
    const actionBtnNew = document.getElementById('btnActionNew');
    if (actionBtnNew) {
      actionBtnNew.addEventListener('click', () => performUniversalAction());
    }
    document.getElementById('btnAct2')?.addEventListener('click', () => {
      try { window.triggerAltAction?.(); } catch (_) { /* optional */ }
    });
    // ATTACK button (indoor aware)
    (function () {
      const attackBtn = document.getElementById('hudBtnAttack') || document.getElementById('btnShoot');
      if (!attackBtn) return;
      const onDown = () => {
        if (window.HouseInterior?.active && !window.MissyArcadeGame?.active) {
          try { window.HouseInterior.strikeIndoorEnemy(); window.HouseInterior.castIndoorSkillVfx?.('ATTACK'); } catch (_) { }
          return;
        }
        hold.shoot = true;
      };
      const onUp = () => { hold.shoot = false; };
      attackBtn.addEventListener('pointerdown', onDown);
      attackBtn.addEventListener('pointerup', onUp);
      attackBtn.addEventListener('pointerleave', onUp);
    })();

    function holdTokenForSkill(player, key) {
      if (!player) return null;
      const id = (player.ownerId && player.isClone) ? player.ownerId : player.id;
      if (!id) return null;
      const hero = String(id).toUpperCase();
      if (key === 'S1' && (hero === 'A1' || hero === 'MISSY')) return 'A1_S1';
      if (key === 'S3' && (hero === 'A1' || hero === 'MISSY')) return 'A1_S3';
      return null;
    }
    function onSkillButtonDown(key) {
      const p = leader();
      if (!p) return;
      const token = holdTokenForSkill(p, key);
      if (token) { startHold(p, token); return; }
      useSkillWrapper(p, key);
    }
    function onSkillButtonUp(key) {
      const p = leader();
      if (!p) return;
      const token = holdTokenForSkill(p, key);
      if (token) releaseHold(p, token);
    }
    const btnS1 = document.getElementById('hudBtnS1') || document.getElementById('btnS1');
    if (btnS1) {
      const down = () => {
        if (window.HouseInterior?.active && !window.MissyArcadeGame?.active) { try { window.HouseInterior.strikeIndoorEnemy(); window.HouseInterior.castIndoorSkillVfx?.('S1'); } catch (_) { } return; }
        if (window.beginHold) window.beginHold('S1');
        onSkillButtonDown('S1');
      };
      const up = () => {
        if (window.endHold) window.endHold('S1');
        onSkillButtonUp('S1');
      };
      btnS1.addEventListener('pointerdown', down);
      btnS1.addEventListener('pointerup', up);
      btnS1.addEventListener('pointerleave', up);
    }
    // S2: single-tap = spawn/command; double-tap (<=250ms) = recall + heal (20s CD)
    (function () {
      const el = document.getElementById('hudBtnS2') || document.getElementById('btnS2');
      if (!el) return;
      let lastTap = 0, singleTimer = null;
      el.addEventListener('click', (ev) => {
        ev.preventDefault(); ev.stopPropagation();
        if (window.HouseInterior?.active && !window.MissyArcadeGame?.active) { try { window.HouseInterior.strikeIndoorEnemy(); window.HouseInterior.castIndoorSkillVfx?.('S2'); } catch (_) { } return; }
        const now = performance.now?.() || Date.now();
        const TAP = 250;
        if (now - lastTap <= TAP) {
          if (singleTimer) { clearTimeout(singleTimer); singleTimer = null; }
          recallCloneForLeader();
          lastTap = 0; return;
        }
        lastTap = now;
        singleTimer = setTimeout(() => { singleTimer = null; useSkillWrapper(leader(), 'S2'); }, TAP + 5);
      }, true);
      // Cooldown ring updater
      setInterval(() => {
        const now = performance.now?.() || Date.now();
        const left = Math.max(0, (st._cloneRecallCDUntil || 0) - now);
        const frac = 1 - Math.min(1, left / 20000);
        el.style.setProperty('--p', Math.round(frac * 360) + 'deg');
      }, 120);
    })();
    const btnS3 = document.getElementById('hudBtnS3') || document.getElementById('btnS3');
    if (btnS3) {
      const down = () => {
        if (window.HouseInterior?.active && !window.MissyArcadeGame?.active) { try { window.HouseInterior.strikeIndoorEnemy(); window.HouseInterior.castIndoorSkillVfx?.('S3'); } catch (_) { } return; }
        if (window.beginHold) window.beginHold('S3');
        onSkillButtonDown('S3');
      };
      const up = () => {
        if (window.endHold) window.endHold('S3');
        onSkillButtonUp('S3');
      };
      btnS3.addEventListener('pointerdown', down);
      btnS3.addEventListener('pointerup', up);
      btnS3.addEventListener('pointerleave', up);
    }
    const btnS4 = document.getElementById('btnS4');
    if (btnS4) {
      btnS4.onpointerdown = () => { if (window.HouseInterior?.active && !window.MissyArcadeGame?.active) { try { window.HouseInterior.strikeIndoorEnemy(); window.HouseInterior.castIndoorSkillVfx?.('S4'); } catch (_) { } return; } useSkillWrapper(leader(), 'S4'); };
      btnS4.onpointerup = () => releaseS4(leader());
    }
    const btnS5 = document.getElementById('btnS5');
    if (btnS5) {
      btnS5.onclick = () => { if (window.HouseInterior?.active && !window.MissyArcadeGame?.active) { try { window.HouseInterior.strikeIndoorEnemy(); window.HouseInterior.castIndoorSkillVfx?.('S5'); } catch (_) { } return; } useSkillWrapper(leader(), 'S5'); };
    }
    const btnSecret = document.getElementById('btnSecret');
    if (btnSecret) {
      btnSecret.onclick = () => { if (window.HouseInterior?.active && !window.MissyArcadeGame?.active) { try { window.HouseInterior.strikeIndoorEnemy(); window.HouseInterior.castIndoorSkillVfx?.('SECRET'); } catch (_) { } return; } tryActivateSecretFor(leader()); };
    }
    setTimeout(() => { try { updateSkillReadyUI(); } catch (_e) { } }, 0);

    /* ================= Legacy Scroll Skill Functions (kept for compatibility) ================= */
    // The following helper functions allow scroll‑based skills from the UnifiedSkills
    // system to fully replace the hero's native skills. When a scroll is present in the
    // target slot we trigger the associated kit skill (falling back to the hero's native
    // version if needed). This keeps cooldowns and notifications unified.
    // Legacy scroll system helpers (mostly unused, kept for compatibility)
    function resolveScrollHeroId(entity) {
      if (!entity) return null;
      if (entity.isClone && entity.ownerId) return entity.ownerId;
      return entity.id;
    }
    function heroKeyForUnified(raw) {
      if (raw == null) return null;
      const text = String(raw).trim();
      if (!text) return null;
      const upper = text.toUpperCase();
      if (upper === 'UNIQUE') return 'UNIQUE';
      if (upper === 'MISSY') return 'MISSY';
      if (upper === 'CLONE') return 'A1';
      return upper;
    }
    function deepCloneFallback(obj) {
      if (obj === null || typeof obj !== 'object') return obj;
      if (Array.isArray(obj)) {
        return obj.map(deepCloneFallback);
      }
      const cloned = {};
      for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          cloned[key] = deepCloneFallback(obj[key]);
        }
      }
      return cloned;
    }
    function cloneDeep(obj) {
      if (obj === null || obj === undefined) return null;
      try { return JSON.parse(JSON.stringify(obj)); } catch (_e) { return deepCloneFallback(obj); }
    }
    // Legacy scroll functions - all return null now (system removed)
    function getScrollLibraryEntry(id) { return null; }
    function getUnifiedState() { return null; }
    function getEquippedScrollItem(heroKey, slotIdx) { return null; }
    function detectScrollHero(item, fallbackHeroKey) {
      const id = String(item?.id || '').toLowerCase();
      const origin = heroKeyForUnified(item?.origin || item?.hero || null);
      if (/^a1[_-]/.test(id)) return 'A1';
      if (/^(u[_-]|unique[_-])/.test(id)) return 'UNIQUE';
      if (/^(m[_-]|missy[_-])/.test(id)) return 'MISSY';
      if (origin) {
        if (origin === 'A1' || origin === 'UNIQUE' || origin === 'MISSY') return origin;
      }
      return fallbackHeroKey || 'A1';
    }
    function shortLabelFromScroll(item) {
      if (!item) return '';
      if (item.icon) return String(item.icon).slice(0, 3);
      if (item.name) {
        const cleaned = String(item.name).trim();
        if (cleaned.length <= 3) return cleaned.toUpperCase();
        const parts = cleaned.split(/\s+/).filter(Boolean);
        if (parts.length === 1) return parts[0].slice(0, 3).toUpperCase();
        return (parts[0][0] || '').toUpperCase() + (parts[1]?.[0] || '').toUpperCase();
      }
      if (item.id) {
        const seg = String(item.id).split('_')[0];
        return seg.slice(0, 3).toUpperCase();
      }
      return '';
    }
    // Legacy scrollSkillCast - no longer used, kept for compatibility
    function scrollSkillCast(a, key) {
      try {
        if (!a || a.isDefeated) return false;
        if (!/^S[1-5]$/.test(key)) return false;
        const idx = parseInt(key.slice(1), 10);
        const heroId = resolveScrollHeroId(a);
        if (!heroId) return false;
        const heroKey = heroKeyForUnified(heroId);
        const item = getEquippedScrollItem(heroKey, idx);
        if (!item) return false; // Will always return false now
        const slotKey = 'S' + idx;
        let casted = false;
        const sourceHeroKey = detectScrollHero(item, heroKey);
        const heroHandlers = {
          A1: a1_useSkill,
          UNIQUE: unique_useSkill,
          MISSY: missy_useSkill
        };
        const handler = heroHandlers[sourceHeroKey];
        if (typeof handler === 'function') {
          try {
            handler(a, slotKey);
            casted = true;
          } catch (_e) {
            casted = false;
          }
        }
        if (!casted) {
          try {
            if (a.id === 'A1') a1_useSkill(a, key);
            else if (a.id === 'Unique') unique_useSkill(a, key);
            else if (a.id === 'Missy') missy_useSkill(a, key);
            else genericSkill(a, key);
            casted = true;
          } catch (_) { }
        }
        if (casted) {
          try {
            const rs = item.stats && item.stats.reset;
            if (Array.isArray(rs) && rs.length) {
              const idKey = heroKeyForUnified(a.id) || heroKey;
              const cooldownTable = st.cds?.[a.id] || st.cds?.[idKey] || (st.cds ? st.cds[a.id] : null);
              for (const r of rs) {
                const m = String(r).match(/_s(\d+)/i); if (!m) continue;
                const s = 'S' + m[1];
                if (cooldownTable && s in cooldownTable) cooldownTable[s] = 0;
              }
            }
          } catch (_) { }
          try { window._lastScrollCast = { hero: a.id, slot: key, scrollId: item.id || '', sourceHero: sourceHeroKey, time: performance.now?.() || Date.now() }; } catch (_e) { console.error(_e); }
        }
        try {
          const feedback = { type: 'game:skill_cast', hero: a.id, slot: key, scrollUsed: item.name || '' };
          if (window.parent && window.parent !== window) {
            window.parent.postMessage(feedback, '*');
          }
        } catch (_e) { }
        if (casted) {
          try { updateSkillReadyUI(); } catch (_e) { }
        }
        return casted;
      } catch (err) {
        console.warn('scrollSkillCast error', err);
        return false;
      }
    }

    function normalizeHeroIdForCd(id) {
      const raw = (id === null || id === undefined) ? '' : String(id);
      const upper = raw.toUpperCase();
      if (upper === 'UNIQUE') return 'Unique';
      if (upper === 'MISSY') return 'Missy';
      if (upper === 'A1' || upper === 'CLONE') return 'A1';
      return raw;
    }

    function updateSkillReadyUI() {
      // Simplified version for new simple_skills.js system
      try {
        const L = (typeof leader === 'function') ? leader() : null;
        if (!L) return;

        // Update skill button states based on cooldowns
        const now = Date.now();
        const cooldowns = L.cooldowns || {};

        ['S1', 'S2', 'S3'].forEach((key) => {
          const ready = !cooldowns[key] || now >= cooldowns[key];
          window.HUD?.setSkillReady?.(key, ready);
          const el = document.getElementById('hudBtn' + key) ||
            document.querySelector('.skill-row [data-skill="' + key + '"]') ||
            document.getElementById('btn' + key);
          if (!el) return;
          el.classList.toggle('ready', ready);
          el.classList.toggle('on-cooldown', !ready);
          if (window.SIMPLE_SKILLS && window.SIMPLE_SKILLS[L.id]) {
            const skill = window.SIMPLE_SKILLS[L.id][key];
            if (skill) {
              el.title = `${key}: ${skill.name}`;
            }
          }
        });
      } catch (_e) {
        console.warn('updateSkillReadyUI error:', _e);
      }
    }

    const keys = {};
    let stickJoyX = 0;
    let stickJoyY = 0;

    const keymap = {
      ACT_PRIMARY: 'KeyA',
      ACT_SECONDARY: 'KeyE',
      ENTER_HOUSE: 'KeyA',
      SWITCH_LEADER: 'KeyS',
      INVENTORY: 'KeyB',
      PET_TOGGLE: 'KeyP',
      VEHICLE_TOGGLE: 'KeyV',
      SKILL_1: 'Digit1',
      SKILL_2: 'Digit2',
      SKILL_3: 'Digit3',
      INDOOR_ATTACK: 'Space'
    };
    window.A1K_KEYMAP = keymap;
    window.keymap = keymap;

    const updateAxisFromInputs = () => {
      const left = !!keys['ArrowLeft'];
      const right = !!keys['ArrowRight'];
      const up = !!keys['ArrowUp'];
      const down = !!keys['ArrowDown'];

      const digitalX = (right ? 1 : 0) - (left ? 1 : 0);
      const digitalY = (down ? 1 : 0) - (up ? 1 : 0);

      const analogX = Math.abs(stickJoyX) > 0.05 ? stickJoyX : 0;
      const analogY = Math.abs(stickJoyY) > 0.05 ? stickJoyY : 0;

      joyX = digitalX !== 0 ? digitalX : analogX;
      joyY = digitalY !== 0 ? digitalY : analogY;

      window.joyX = joyX;
      window.joyY = joyY;
    };

    addEventListener('keydown', e => {
      const activeEl = document.activeElement;
      const typing = activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA' || activeEl.isContentEditable);

      if (!typing) {
        keys[e.code] = true;
        updateAxisFromInputs();
      }

      if (typing) return;

      let handled = false;

      if (e.code === keymap.SWITCH_LEADER && Array.isArray(st.players) && st.players.length) {
        handled = true;
        let next = (st.leader + 1) % st.players.length;
        for (let i = 0; i < st.players.length; i++) {
          if (!st.players[next].isDefeated) break;
          next = (next + 1) % st.players.length;
        }
        st.leader = next;
        try { updateSkillReadyUI(); } catch (_e) { }
      }

      if (e.code === keymap.INVENTORY) {
        const bag = document.getElementById('inventory');
        if (bag) {
          handled = true;
          const isOpen = bag.classList.contains('open');
          if (isOpen) {
            try { closeBag(); } catch (_) { bag.classList.remove('open'); }
          } else {
            try { openBag('items'); } catch (_) { bag.classList.add('open'); }
          }
        }
      }

      if (e.code === keymap.PET_TOGGLE) {
        const btnPet = document.getElementById('btnPet');
        if (btnPet) {
          handled = true;
          btnPet.click();
        }
      }

      if (e.code === keymap.VEHICLE_TOGGLE) {
        const btnVeh = document.getElementById('btnVeh');
        if (btnVeh) {
          handled = true;
          btnVeh.click();
        }
      }

      if (e.code === keymap.INDOOR_ATTACK) {
        handled = true;
        if (window.chargeManager && !window.chargeManager.isJumpCharging()) {
          window.chargeManager.startJumpCharge();
        }
      }

      if (e.code === keymap.SKILL_1) { handled = true; useSkillWrapper(leader(), 'S1'); }
      if (e.code === keymap.SKILL_2) { handled = true; useSkillWrapper(leader(), 'S2'); }
      if (e.code === keymap.SKILL_3) { handled = true; useSkillWrapper(leader(), 'S3'); }
      if (e.code === 'Digit4') { handled = true; useSkillWrapper(leader(), 'S4'); }

      if (handled) {
        e.preventDefault();
        e.stopPropagation();
      }
    });
    addEventListener('keyup', e => {
      keys[e.code] = false;
      updateAxisFromInputs();
      if (e.code === keymap.INDOOR_ATTACK) {
        jumpAll();
      }
    });

    const stick = document.getElementById('vj-root');
    const nub = document.getElementById('vj-knob');
    let joyId = null, joyX = 0, joyY = 0, lastTap = 0;
    window.joyX = 0;
    window.joyY = 0;
    if (stick && nub) {
      const resetKnob = () => {
        nub.style.left = '50%';
        nub.style.top = '50%';
      };
      const handleUp = (e) => {
        if (e.pointerId !== joyId) return;
        joyId = null;
        stickJoyX = 0;
        stickJoyY = 0;
        resetKnob();
        const now = performance.now();
        if (now - lastTap < 260) {
          jumpAll();
        }
        lastTap = now;
        window.HUD?.setJoystickReady?.(true);
        updateAxisFromInputs();
      };
      stick.addEventListener('pointerdown', (e) => {
        stick.setPointerCapture(e.pointerId);
        joyId = e.pointerId;
        window.HUD?.setJoystickReady?.(false);
        onJoy(e);
      });
      stick.addEventListener('pointermove', (e) => { if (e.pointerId === joyId) onJoy(e); });
      stick.addEventListener('pointerup', handleUp);
      stick.addEventListener('pointercancel', handleUp);
      resetKnob();
    }
    function onJoy(e) {
      if (!stick || !nub) return;
      const r = stick.getBoundingClientRect();
      const cx = r.left + r.width / 2;
      const cy = r.top + r.height / 2;
      let dx = e.clientX - cx;
      let dy = e.clientY - cy;
      const m = Math.hypot(dx, dy);
      const lim = Math.min(r.width, r.height) * 0.38;
      if (lim <= 0) return;
      if (m > lim) {
        dx = dx / m * lim;
        dy = dy / m * lim;
      }
      nub.style.left = (50 + (dx / r.width) * 100) + '%';
      nub.style.top = (50 + (dy / r.height) * 100) + '%';
      stickJoyX = dx / lim;
      stickJoyY = dy / lim;
      updateAxisFromInputs();
    }
    window.HUD?.setJoystickReady?.(true);
    const hold = { shoot: false };

    /* ================= Basic Attack Wrapper ================= */
    function basicAttackLoop() {
      if (st.auto || hold.shoot) {
        const L = leader();
        if (!L.isDefeated && (!L._basicCD || L._basicCD <= 0)) {
          let triggered = false;
          // Use character-specific basic attacks with appropriate cooldowns
          if (L.id === 'A1') {
            a1_basicAttack(L);
            L._basicCD = 260; // A1's combo timing
            triggered = true;
          } else if (L.id === 'Unique') {
            unique_basicAttack(L);
            L._basicCD = 2000; // Slower cadence for heavy projectiles
            triggered = true;
          } else if (L.id === 'Missy') {
            missy_basicAttack(L);
            L._basicCD = 400; // Balanced for combo + pistol
            triggered = true;
          } else {
            basicAttackAction(L);
            L._basicCD = 420; // Default
            triggered = true;
          }
          if (triggered) {
            scheduleFollowerActions('attack', { source: 'basic', leaderId: L.id });
          }
        }
      }
    }

    /* ================= Jump Logic with Charge Mechanic ================= */
    function jumpAll() {
      const L = leader();
      if (!L.jumpCount) L.jumpCount = 0;

      // Get charge power if jump was charged
      let jumpPower = 1.0;
      if (window.chargeManager && window.chargeManager.isJumpCharging()) {
        jumpPower = window.chargeManager.releaseJumpCharge();
      }

      // Always persist jump power for platform physics, defaulting to 1.0
      L._jumpPower = jumpPower;

      // Base jump velocity
      const baseJumpVy = -0.22;
      const jumpVy = baseJumpVy * jumpPower;
      let followersShouldJump = false;

      // If Platform mode is active, queue a jump handled by platform physics
      if (window.Platform && Platform.enabled) {
        L._jumpQueued = true;
        scheduleFollowerActions('jump', { power: jumpPower, leaderId: L.id });
        return;
      }

      // Legacy lane jump fallback with charge power
      if (L.grounded) {
        L.vy = jumpVy;
        L.grounded = false;
        L.jumpCount = 1;
        followersShouldJump = true;

        // Visual feedback for charged jump
        if (jumpPower > 1.5 && window.globalParticles) {
          const emitter = window.globalParticles.createEmitter(L.x, L.y + 25, {
            type: 'point',
            burst: 20,
            rate: 0,
            duration: 0.25,
            speed: { min: 50, max: 150 },
            size: { min: 3, max: 6 },
            life: { min: 300, max: 600 },
            colors: ['#4ecdc4', '#FFFFFF'],
            spread: Math.PI * 2,
            gravity: 100,
            endSize: 0
          });
          emitter.stop();
        }
      } else if (L.jumpCount < 2) {
        L.vy = jumpVy;
        L.jumpCount++;
        followersShouldJump = true;
      }

      if (followersShouldJump) {
        scheduleFollowerActions('jump', { power: jumpPower, leaderId: L.id });
      }
    }

    /* ================= Core Helpers ================= */
    function ensureElementalState() {
      const meta = window.CORE_METADATA?.elemental;
      const cycle = Array.isArray(meta?.cycle) && meta.cycle.length > 0 ? meta.cycle : ['fire', 'ice', 'lightning'];
      if (!window._coreElementState) {
        window._coreElementState = {
          cycle: cycle.slice(),
          index: -1,
          active: cycle[0] || null,
          lastSwap: 0,
          lastHeroId: null,
          lastMessage: 0
        };
      } else {
        if (!Array.isArray(window._coreElementState.cycle) || window._coreElementState.cycle.length === 0) {
          window._coreElementState.cycle = cycle.slice();
        }
        if (!window._coreElementState.cycle.includes(window._coreElementState.active)) {
          window._coreElementState.active = window._coreElementState.cycle[0] || null;
        }
      }
      return window._coreElementState;
    }

    function advanceElementalCycle(actor) {
      const state = ensureElementalState();
      const cycle = state.cycle || [];
      if (!cycle.length) return null;
      const now = (typeof performance !== 'undefined' && performance.now) ? performance.now() : Date.now();
      const nextIndex = typeof state.index === 'number' && state.index >= 0
        ? (state.index + 1) % cycle.length
        : 0;
      const nextElement = cycle[nextIndex] || cycle[0];
      state.index = nextIndex;
      state.active = nextElement;
      state.lastSwap = now;
      state.lastHeroId = actor?.id || null;

      const runtime = window.CORE_RUNTIME_STATE?.elemental;
      if (runtime) {
        runtime.cycleIndex = nextIndex;
        runtime.activeElement = nextElement;
        runtime.lastUpdated = now;
        window.ACTIVE_CORE_STATE = runtime;
      }

      if (actor) {
        actor.coreElement = actor.coreElement || {};
        actor.coreElement.active = nextElement;
        actor.coreElement.lastSwap = now;
        actor.coreElement.index = nextIndex;
      }

      if (window.notify && (!state.lastMessage || now - state.lastMessage > 1200)) {
        window.notify(`Elemental Core shift: ${nextElement.toUpperCase()}`, '#6aa8ff');
        state.lastMessage = now;
      }

      return nextElement;
    }

    /* ================= Gadget Core Helpers ================= */
    const GADGET_OVERCLOCK_COLOR = '#61dafb';

    function ensureGadgetState() {
      const meta = window.CORE_METADATA?.gadget;
      const defaults = meta?.overclock || { duration: 4000, atkPerStack: 0.08, speedPerStack: 0.05, critPerStack: 6, maxStacks: 3 };
      if (!window._coreGadgetState) {
        window._coreGadgetState = {
          overclockStacks: 0,
          overclockExpires: 0,
          lastTrigger: 0,
          lastHeroId: null,
          turretRef: null,
          turretOwner: null,
          turretLastRefresh: 0,
          params: {
            duration: defaults.duration,
            atkPerStack: defaults.atkPerStack,
            speedPerStack: defaults.speedPerStack,
            critPerStack: defaults.critPerStack,
            maxStacks: defaults.maxStacks
          }
        };
      }
      if (!window._coreGadgetState.params) {
        window._coreGadgetState.params = {
          duration: defaults.duration,
          atkPerStack: defaults.atkPerStack,
          speedPerStack: defaults.speedPerStack,
          critPerStack: defaults.critPerStack,
          maxStacks: defaults.maxStacks
        };
      }
      return window._coreGadgetState;
    }

    function findPlayerById(id) {
      if (!id) return null;
      return (st.players || []).find(p => (p.id || '').toUpperCase() === ('' + id).toUpperCase()) || null;
    }

    function spawnGadgetTurret(owner) {
      if (!owner) return null;
      const state = ensureGadgetState();
      const cfg = (window.HERO_CFG?.Unique?.turret) || { life_ms: 6000, shot_ms: 280, mult: 0.55 };
      const now = performance.now?.() || Date.now();

      if (state.turretRef && state.turretOwner && state.turretOwner === owner.id) {
        state.turretRef.life = cfg.life_ms;
        state.turretRef.x = owner.x + 36;
        state.turretRef.y = owner.y - 32;
        state.turretRef.ownerId = owner.id;
        state.turretRef.spawnedAt = now;
        state.turretRef.lastShot = Math.min(state.turretRef.lastShot || 0, (cfg.shot_ms || 280) * 0.5);
        state.turretLastRefresh = now;
        if (window.CORE_RUNTIME_STATE?.gadget) {
          const runtime = window.CORE_RUNTIME_STATE.gadget;
          runtime.turretActive = true;
          runtime.lastUpdated = now;
        }
        return state.turretRef;
      }

      if (state.turretRef && state.turretRef.life > 0) {
        state.turretRef.life = 0;
      }

      const turret = {
        kind: 'gadget_turret',
        ownerId: owner.id,
        x: owner.x + 36,
        y: owner.y - 32,
        life: cfg.life_ms,
        shotMs: cfg.shot_ms || 280,
        dmgMult: cfg.mult || 0.55,
        lastShot: 0,
        spawnedAt: now
      };
      st.shots.push(turret);
      state.turretRef = turret;
      state.turretOwner = owner.id;
      state.turretLastRefresh = now;
      if (window.CORE_RUNTIME_STATE?.gadget) {
        const runtime = window.CORE_RUNTIME_STATE.gadget;
        runtime.turretActive = true;
        runtime.lastUpdated = now;
      }
      try { st.effects.push({ kind: 'cast', x: turret.x, y: turret.y, color: GADGET_OVERCLOCK_COLOR, life: 450, max: 450 }); } catch (_e) { }
      if (window.notify) {
        window.notify('Support turret deployed!', '#45c6ff');
      }
      return turret;
    }

    function applyGadgetOverclock(owner) {
      if (!owner) return;
      const state = ensureGadgetState();
      const params = state.params;
      const now = performance.now?.() || Date.now();
      const prevStacks = state.overclockStacks || 0;
      const nextStacks = Math.min(params.maxStacks || 3, (prevStacks || 0) + 1);
      state.overclockStacks = nextStacks;
      state.overclockExpires = now + (params.duration || 4000);
      state.lastTrigger = now;
      state.lastHeroId = owner.id;

      owner._gadgetOverclock = owner._gadgetOverclock || {};
      owner._gadgetOverclock.stacks = nextStacks;
      owner._gadgetOverclock.expires = state.overclockExpires;
      owner._coreAtkMul = 1 + nextStacks * (params.atkPerStack || 0.08);
      owner._coreSpeedMul = 1 + nextStacks * (params.speedPerStack || 0.05);
      owner._coreCritBonus = nextStacks * (params.critPerStack || 6);
      recalcStats();

      if (window.CORE_RUNTIME_STATE?.gadget) {
        const runtime = window.CORE_RUNTIME_STATE.gadget;
        runtime.stacks = nextStacks;
        runtime.overclockExpires = state.overclockExpires;
        runtime.lastUpdated = now;
        runtime.turretActive = runtime.turretActive || !!state.turretRef;
      }

      if (window.notify && nextStacks > prevStacks) {
        window.notify(`Overclock x${nextStacks}`, GADGET_OVERCLOCK_COLOR);
      }
    }

    function triggerGadgetCoreEffects(actor, key) {
      if (!actor || actor.isDefeated) return;
      if (window.EQUIPPED_CORE !== 'gadget') return;
      if (!/^S[123]$/.test(key)) return;
      spawnGadgetTurret(actor);
      applyGadgetOverclock(actor);
    }

    function updateGadgetCore(dtMs) {
      const state = window._coreGadgetState;
      if (!state) return;
      const now = performance.now?.() || Date.now();

      if (state.overclockStacks > 0 && state.overclockExpires > 0 && now >= state.overclockExpires) {
        state.overclockStacks = 0;
        state.overclockExpires = 0;
        const owner = findPlayerById(state.lastHeroId);
        if (owner) {
          owner._gadgetOverclock = null;
          owner._coreAtkMul = 1;
          owner._coreSpeedMul = 1;
          owner._coreCritBonus = 0;
          recalcStats();
        }
        if (window.CORE_RUNTIME_STATE?.gadget) {
          const runtime = window.CORE_RUNTIME_STATE.gadget;
          runtime.stacks = 0;
          runtime.overclockExpires = 0;
          runtime.lastUpdated = now;
        }
      }

      if (state.turretRef) {
        const owner = findPlayerById(state.turretOwner);
        if (!owner || owner.isDefeated || window.EQUIPPED_CORE !== 'gadget') {
          state.turretRef.life = 0;
        } else {
          state.turretRef.x = owner.x + 36;
          state.turretRef.y = owner.y - 32;
        }
        if (state.turretRef.life <= 0) {
          state.turretRef = null;
          state.turretOwner = null;
          if (window.CORE_RUNTIME_STATE?.gadget) {
            window.CORE_RUNTIME_STATE.gadget.turretActive = false;
            window.CORE_RUNTIME_STATE.gadget.lastUpdated = now;
          }
        }
      }
    }

    /* ================= Beast Core Helpers ================= */
    const BEAST_HOWL_COLOR = '#ff924c';

    function ensureBeastState() {
      window._coreBeastState = window._coreBeastState || {
        howlExpires: 0,
        howlReadyAt: 0,
        lastHowl: 0,
        params: {
          petPower: 1.25,
          petCooldown: 0.85,
          petHp: 1.5,
          duration: 6000,
          cooldown: 14000,
          atkBonus: 0.18,
          hasteBonus: 0.08
        }
      };
      return window._coreBeastState;
    }

    function applyBeastPetBonuses(pet) {
      if (!pet || window.EQUIPPED_CORE !== 'beast') return;
      const state = ensureBeastState();
      const params = state.params || {};
      const hpMul = Number(params.petHp) || 1.5;
      const baseHp = pet._beastBaseHp || pet.hpMax || pet.hp || 0;
      pet._beastBaseHp = baseHp;
      if (baseHp > 0) {
        pet.hpMax = Math.round(baseHp * hpMul);
        pet.hp = pet.hpMax;
      }
    }

    function triggerBeastHowl(source) {
      if (window.EQUIPPED_CORE !== 'beast') return;
      const state = ensureBeastState();
      const params = state.params || {};
      const now = performance.now?.() || Date.now();
      state.howlExpires = now + (params.duration || 6000);
      state.howlReadyAt = now + (params.cooldown || 14000);
      state.lastHowl = now;

      let recalcNeeded = false;
      const players = st.players || [];
      players.forEach(hero => {
        if (!hero || hero.isDefeated) return;
        hero._beastHowlMul = 1 + (params.atkBonus || 0);
        hero._beastHowlSpeedMul = 1 + (params.hasteBonus || 0);
        hero._beastHowlExpires = state.howlExpires;
        recalcNeeded = true;
        try { addFloater(hero.x, hero.y - 46, 'Howl!', BEAST_HOWL_COLOR); } catch (_e) { }
      });
      if (recalcNeeded) {
        recalcStats();
      }
      if (window.notify) {
        window.notify('Pack howl! Allies surge forward.', BEAST_HOWL_COLOR);
      }
      if (window.CORE_RUNTIME_STATE?.beast) {
        window.CORE_RUNTIME_STATE.beast.howlExpires = state.howlExpires;
        window.CORE_RUNTIME_STATE.beast.howlReadyAt = state.howlReadyAt;
        window.CORE_RUNTIME_STATE.beast.lastUpdated = now;
      }
    }

    function updateBeastCore(dtMs) {
      const state = window._coreBeastState;
      if (!state) return;
      const now = performance.now?.() || Date.now();

      if (window.EQUIPPED_CORE === 'beast' && (!state.howlReadyAt || now >= state.howlReadyAt) && (now - (state.lastHowl || 0) > 400)) {
        triggerBeastHowl(leader());
      }

      if (state.howlExpires && now >= state.howlExpires) {
        let recalcNeeded = false;
        for (const hero of (st.players || [])) {
          if (!hero) continue;
          if (hero._beastHowlMul && hero._beastHowlMul !== 1) {
            hero._beastHowlMul = 1;
            recalcNeeded = true;
          }
          if (hero._beastHowlSpeedMul && hero._beastHowlSpeedMul !== 1) {
            hero._beastHowlSpeedMul = 1;
          }
          hero._beastHowlExpires = 0;
        }
        state.howlExpires = 0;
        if (recalcNeeded) recalcStats();
      }

      if (window.CORE_RUNTIME_STATE?.beast) {
        window.CORE_RUNTIME_STATE.beast.howlExpires = state.howlExpires || 0;
        window.CORE_RUNTIME_STATE.beast.howlReadyAt = state.howlReadyAt || 0;
        window.CORE_RUNTIME_STATE.beast.lastUpdated = now;
      }
    }

    window.resetBeastCoreState = function resetBeastCoreState() {
      if (!window.st || !Array.isArray(st.players)) return;
      const state = ensureBeastState();
      const now = performance.now?.() || Date.now();
      state.howlExpires = 0;
      state.lastHowl = 0;
      state.howlReadyAt = now + 800;
      (st.pets || []).forEach(applyBeastPetBonuses);
      if (window.CORE_RUNTIME_STATE?.beast) {
        window.CORE_RUNTIME_STATE.beast.howlExpires = 0;
        window.CORE_RUNTIME_STATE.beast.howlReadyAt = state.howlReadyAt;
        window.CORE_RUNTIME_STATE.beast.lastUpdated = now;
      }
    };

    window.clearBeastCoreState = function clearBeastCoreState() {
      if (!window.st || !Array.isArray(st.players)) return;
      const state = ensureBeastState();
      state.howlExpires = 0;
      state.howlReadyAt = 0;
      state.lastHowl = 0;
      let recalcNeeded = false;
      for (const hero of (st.players || [])) {
        if (!hero) continue;
        if (hero._beastHowlMul && hero._beastHowlMul !== 1) {
          hero._beastHowlMul = 1;
          recalcNeeded = true;
        }
        if (hero._beastHowlSpeedMul && hero._beastHowlSpeedMul !== 1) {
          hero._beastHowlSpeedMul = 1;
        }
        hero._beastHowlExpires = 0;
      }
      for (const pet of (st.pets || [])) {
        if (pet && pet._beastBaseHp) {
          pet.hpMax = pet._beastBaseHp;
          pet.hp = Math.min(pet.hp || pet.hpMax, pet.hpMax);
        }
      }
      if (recalcNeeded) recalcStats();
      if (window.CORE_RUNTIME_STATE?.beast) {
        window.CORE_RUNTIME_STATE.beast.howlExpires = 0;
        window.CORE_RUNTIME_STATE.beast.howlReadyAt = 0;
        window.CORE_RUNTIME_STATE.beast.lastUpdated = performance.now?.() || Date.now();
      }
    };

    /* ================= Crystal Core Helpers ================= */
    const CRYSTAL_BARRIER_COLOR = '#90f7ec';

    function ensureCrystalState() {
      window._coreCrystalState = window._coreCrystalState || {
        barrierRatio: 0.25,
        rechargeDelay: 4500,
        rechargeRate: 0.18,
        damageReduction: 0.88,
        rechargeAt: 0,
        lastBreak: 0
      };
      return window._coreCrystalState;
    }

    function setCrystalBarrier(hero) {
      if (!hero) return;
      const state = ensureCrystalState();
      const ratio = Number(state.barrierRatio) || 0.25;
      const base = hero.hpMax || hero.hp || 0;
      const max = Math.round(base * ratio);
      hero._coreBarrier = hero._coreBarrier || {};
      hero._coreBarrier.max = max;
      hero._coreBarrier.current = max;
      hero._coreBarrier.lastBreak = 0;
    }

    window.resetCrystalBarrier = function resetCrystalBarrier() {
      if (!window.st || !Array.isArray(st.players)) return;
      const state = ensureCrystalState();
      const now = performance.now?.() || Date.now();
      state.rechargeAt = now + 1000;
      for (const hero of (st.players || [])) {
        setCrystalBarrier(hero);
        try { addFloater(hero.x, hero.y - 52, 'Barrier Ready', CRYSTAL_BARRIER_COLOR); } catch (_e) { }
      }
      const lead = leader();
      st.barrier = lead?._coreBarrier?.current || 0;
      st.barrierMax = lead?._coreBarrier?.max || 0;
      if (window.CORE_RUNTIME_STATE?.crystal) {
        window.CORE_RUNTIME_STATE.crystal.barrier = st.barrier;
        window.CORE_RUNTIME_STATE.crystal.barrierMax = st.barrierMax;
        window.CORE_RUNTIME_STATE.crystal.lastUpdated = now;
      }
    };

    window.clearCrystalBarrier = function clearCrystalBarrier() {
      if (!window.st || !Array.isArray(st.players)) return;
      const now = performance.now?.() || Date.now();
      for (const hero of (st.players || [])) {
        if (hero && hero._coreBarrier) {
          hero._coreBarrier.current = 0;
          hero._coreBarrier.max = 0;
        }
      }
      st.barrier = 0;
      st.barrierMax = 0;
      if (window.CORE_RUNTIME_STATE?.crystal) {
        window.CORE_RUNTIME_STATE.crystal.barrier = 0;
        window.CORE_RUNTIME_STATE.crystal.barrierMax = 0;
        window.CORE_RUNTIME_STATE.crystal.lastUpdated = now;
      }
    };

    function applyCrystalMitigation(target, dmg) {
      if (!target || window.EQUIPPED_CORE !== 'crystal') return dmg;
      const state = ensureCrystalState();
      const now = performance.now?.() || Date.now();
      const reduction = Number(state.damageReduction) || 0.88;
      let adjusted = Math.round(dmg * reduction);
      const barrier = target._coreBarrier;
      if (barrier && barrier.current > 0) {
        const absorbed = Math.min(adjusted, barrier.current);
        barrier.current -= absorbed;
        adjusted -= absorbed;
        state.rechargeAt = now + (Number(state.rechargeDelay) || 4500);
        if (barrier.current <= 0) {
          barrier.current = 0;
          if (!barrier.lastBreak || now - barrier.lastBreak > 600) {
            barrier.lastBreak = now;
            if (window.notify) {
              window.notify('Crystal barrier shattered!', CRYSTAL_BARRIER_COLOR);
            }
          }
        }
      } else {
        state.rechargeAt = now + (Number(state.rechargeDelay) || 4500);
      }
      if (window.CORE_RUNTIME_STATE?.crystal) {
        const lead = leader();
        const barrierVal = lead?._coreBarrier?.current || 0;
        const barrierMax = lead?._coreBarrier?.max || 0;
        window.CORE_RUNTIME_STATE.crystal.barrier = barrierVal;
        window.CORE_RUNTIME_STATE.crystal.barrierMax = barrierMax;
        window.CORE_RUNTIME_STATE.crystal.lastUpdated = now;
      }
      const lead = leader();
      if (lead) {
        st.barrier = lead._coreBarrier?.current || 0;
        st.barrierMax = lead._coreBarrier?.max || 0;
      }
      return Math.max(0, adjusted);
    }

    function updateCrystalCore(dtMs) {
      const state = window._coreCrystalState;
      if (!state) return;
      const now = performance.now?.() || Date.now();
      if (window.EQUIPPED_CORE !== 'crystal') return;
      if (state.rechargeAt && now < state.rechargeAt) {
        if (window.CORE_RUNTIME_STATE?.crystal) {
          const lead = leader();
          const barrierVal = lead?._coreBarrier?.current || 0;
          const barrierMax = lead?._coreBarrier?.max || 0;
          window.CORE_RUNTIME_STATE.crystal.barrier = barrierVal;
          window.CORE_RUNTIME_STATE.crystal.barrierMax = barrierMax;
          window.CORE_RUNTIME_STATE.crystal.lastUpdated = now;
        }
        return;
      }
      const regenRate = Number(state.rechargeRate) || 0.18;
      const regenMult = Math.max(0, regenRate) * (dtMs / 1000);
      let updated = false;
      for (const hero of (st.players || [])) {
        const barrier = hero?._coreBarrier;
        if (!barrier || barrier.max <= 0 || barrier.current >= barrier.max) continue;
        barrier.current = Math.min(barrier.max, barrier.current + barrier.max * regenMult);
        updated = true;
      }
      const lead = leader();
      if (window.CORE_RUNTIME_STATE?.crystal) {
        window.CORE_RUNTIME_STATE.crystal.barrier = lead?._coreBarrier?.current || 0;
        window.CORE_RUNTIME_STATE.crystal.barrierMax = lead?._coreBarrier?.max || 0;
        window.CORE_RUNTIME_STATE.crystal.lastUpdated = now;
      }
    }

    /* ================= Anime Skill Runner Bridge ================= */
    const skillIntegration = (() => {
      const HERO_IDS = new Set(['A1', 'UNIQUE', 'MISSY']);
      const SUPPORTED_KEYS = new Set(['S1', 'S2', 'S3', 'S4']);
      const state = {
        ready: false,
        hitboxManager: null,
        skillRunner: null,
        world: {
          width: DESIGN_W,
          height: DESIGN_H,
          groundY: DESIGN_H - 160,
          camera: { x: 0, y: 0 },
          entities: [],
          hitboxManager: null,
          vfxWorld: null,
          formationManager: null
        },
        legacySimpleSkill: null
      };

      let api;

      function toSkillKey(skillId) {
        if (!skillId) return '';
        const parts = String(skillId).split('_');
        return (parts[parts.length - 1] || '').toUpperCase();
      }

      function ensureReady() {
        if (state.ready) return true;
        if (!(window.AnimeSkillRunner && window.HitboxManager && window.AnimeVFXWorld)) {
          return false;
        }
        state.hitboxManager = new window.HitboxManager();
        state.world.hitboxManager = state.hitboxManager;
        state.world.vfxWorld = window.AnimeVFXWorld;
        if (!state.world.formationManager && window.FormationManager) {
          state.world.formationManager = new window.FormationManager();
        }
        if (window.SummonManager) {
          state.world.summonManager = new window.SummonManager(state.world);
        }
        state.skillRunner = new window.AnimeSkillRunner(state.world, state.hitboxManager, state.world.vfxWorld);
        state.ready = true;
        attachLegacyBridge();
        return true;
      }

      function bridgeProxy(actor, key, context) {
        const skip = context && context.__skipBridge;
        if (!skip && api && api.canHandle(actor, key) && api.cast(actor, key, context)) {
          return true;
        }
        if (typeof state.legacySimpleSkill === 'function') {
          return state.legacySimpleSkill(actor, key, context);
        }
        return false;
      }

      function attachLegacyBridge() {
        if (typeof state.legacySimpleSkill === 'function') return;
        if (typeof window.useSimpleSkill === 'function' && window.useSimpleSkill !== bridgeProxy) {
          state.legacySimpleSkill = window.useSimpleSkill.bind(window);
          window.useSimpleSkill = bridgeProxy;
        }
      }

      const legacyWatcher = setInterval(() => {
        if (typeof state.legacySimpleSkill === 'function') {
          clearInterval(legacyWatcher);
          return;
        }
        if (typeof window.useSimpleSkill === 'function' && window.useSimpleSkill !== bridgeProxy) {
          attachLegacyBridge();
          if (typeof state.legacySimpleSkill === 'function') {
            clearInterval(legacyWatcher);
          }
        }
      }, 200);

      function initAdapterProperties(adapter, source, defaults) {
        Object.defineProperty(adapter, 'x', {
          get() { return source.x || 0; },
          set(v) { source.x = v; }
        });
        Object.defineProperty(adapter, 'y', {
          get() { return source.y || 0; },
          set(v) { source.y = v; }
        });
        Object.defineProperty(adapter, 'width', {
          get() { return source.hitboxW || source.width || source.w || defaults.width; },
          set(v) { source.hitboxW = v; source.width = v; }
        });
        Object.defineProperty(adapter, 'height', {
          get() { return source.hitboxH || source.height || source.h || defaults.height; },
          set(v) { source.hitboxH = v; source.height = v; }
        });
        Object.defineProperty(adapter, 'active', {
          get() { return !(source.isDefeated || source.hp <= 0); },
          set() { }
        });
        Object.defineProperty(adapter, 'isDefeated', {
          get() { return !!source.isDefeated || source.hp <= 0; },
          set(v) { source.isDefeated = v; if (v) source.hp = 0; }
        });
        Object.defineProperty(adapter, 'hp', {
          get() { return source.hp || 0; },
          set(v) { source.hp = v; }
        });
        Object.defineProperty(adapter, 'hpMax', {
          get() { return source.hpMax || source.hp || defaults.height * 2; },
          set(v) { source.hpMax = v; }
        });
      }

      function getHeroAdapter(hero) {
        if (!hero) return null;
        if (!hero._skillAdapter) {
          const adapter = {
            id: String(hero.id || '').toUpperCase(),
            team: 'player',
            __heroRef: hero,
            cooldowns: {},
            buffs: []
          };

          initAdapterProperties(adapter, hero, { width: 42, height: 60 });

          Object.defineProperty(adapter, 'facingRight', {
            get() { return !hero.facingLeft; },
            set(v) { hero.facingLeft = !v; }
          });
          Object.defineProperty(adapter, 'iframes', {
            get() { return hero.iframes || hero._iframes || 0; },
            set(v) { hero.iframes = v; hero._iframes = v; }
          });
          Object.defineProperty(adapter, 'vx', {
            get() { return hero.vx || 0; },
            set(v) { hero.vx = v; }
          });
          Object.defineProperty(adapter, 'vy', {
            get() { return hero.vy || 0; },
            set(v) { hero.vy = v; }
          });
          Object.defineProperty(adapter, 'isCasting', {
            get() { return !!hero._isCasting; },
            set(v) { hero._isCasting = v; }
          });
          Object.defineProperty(adapter, 'castingSkill', {
            get() { return hero._castingSkill || null; },
            set(v) { hero._castingSkill = v; }
          });

          adapter.cooldownReady = (skillId) => {
            const key = toSkillKey(skillId);
            ensureCooldownRow(hero.id);
            return cdReady(hero.id, key);
          };

          adapter.startCooldown = (skillId, durationMs) => {
            const key = toSkillKey(skillId);
            ensureCooldownRow(hero.id);
            if (!CD[hero.id]) CD[hero.id] = {};
            if (typeof durationMs === 'number' && durationMs > 0) {
              CD[hero.id][key] = durationMs;
            }
            startCD(hero.id, key);
          };

          adapter.takeDamage = (amount) => {
            const dmg = Math.max(0, Math.round(amount || 0));
            if (dmg <= 0) return 0;
            const prev = hero.hp;
            if (typeof damagePlayer === 'function') {
              damagePlayer(hero, dmg);
            } else {
              hero.hp = Math.max(0, prev - dmg);
              if (hero.hp <= 0) {
                hero.isDefeated = true;
              }
            }
            return Math.max(0, prev - hero.hp);
          };

          adapter.addBuff = (buffId, duration, data = {}) => {
            hero.skillBuffs = hero.skillBuffs || [];
            hero.skillBuffs.push({ id: buffId, duration, data, expires: (performance.now?.() || Date.now()) + (duration || 0) });
          };

          hero._skillAdapter = adapter;
        }
        return hero._skillAdapter;
      }

      function getEnemyAdapter(enemy) {
        if (!enemy) return null;
        if (!enemy._skillAdapter) {
          const adapter = {
            id: enemy.id ? String(enemy.id).toUpperCase() : `ENEMY_${Math.random().toString(36).slice(2)}`,
            team: 'mobs',
            __enemyRef: enemy,
            cooldowns: {},
            buffs: []
          };

          initAdapterProperties(adapter, enemy, { width: 44, height: 54 });

          adapter.cooldownReady = () => true;
          adapter.startCooldown = () => { };
          adapter.addBuff = () => { };
          adapter.takeDamage = (amount) => {
            const dmg = Math.max(0, Math.round(amount || 0));
            if (dmg <= 0) return 0;
            const prev = enemy.hp;
            enemy.hp = Math.max(0, prev - dmg);
            if (typeof addFloater === 'function') {
              addFloater(enemy.x || 0, (enemy.y || 0) - 20, '-' + dmg, '#ff7a6a');
            }
            if (enemy.hp <= 0) {
              enemy.hp = 0;
              enemy.isDefeated = true;
              if (typeof onEnemyKilled === 'function') {
                onEnemyKilled(enemy);
              }
            }
            return Math.max(0, prev - enemy.hp);
          };

          enemy._skillAdapter = adapter;
        }
        return enemy._skillAdapter;
      }

      function syncEntityLists() {
        if (!window.st) return;
        const playerAdapters = [];
        const enemyAdapters = [];

        for (const hero of (window.st.players || [])) {
          const adapter = getHeroAdapter(hero);
          if (adapter) playerAdapters.push(adapter);
        }

        for (const enemy of (window.st.enemies || [])) {
          const adapter = getEnemyAdapter(enemy);
          if (adapter) enemyAdapters.push(adapter);
        }

        state.world.entities = playerAdapters.concat(enemyAdapters);
        state.world.width = DESIGN_W;
        state.world.height = DESIGN_H;
        if (typeof laneY === 'function') {
          state.world.groundY = laneY(1);
        }
        state.world.camera.x = st.camX || 0;
        state.world.camera.y = 0;
      }

      function canHandle(actor, key) {
        if (!actor || !key) return false;
        const heroId = String(actor.id || '').toUpperCase();
        const skillKey = String(key || '').toUpperCase();
        return HERO_IDS.has(heroId) && SUPPORTED_KEYS.has(skillKey);
      }

      function cast(actor, key, context = {}) {
        if (!canHandle(actor, key)) return false;
        if (!ensureReady()) return false;
        syncEntityLists();
        const adapter = getHeroAdapter(actor);
        if (!adapter) return false;
        const angle = context.angle != null ? context.angle : (adapter.facingRight ? 0 : Math.PI);
        const ran = state.skillRunner.runSkill(adapter, String(key).toUpperCase(), angle);
        if (ran) {
          try {
            actor.lastSkill = { key, time: performance.now?.() || Date.now() };
          } catch (_e) { }
        }
        return ran;
      }

      function update(dt, dtMs) {
        if (!state.ready) {
          if (!ensureReady()) return;
        }
        syncEntityLists();
        if (state.hitboxManager) {
          state.hitboxManager.update(dtMs, state.world.entities);
        }
        if (state.world.vfxWorld && typeof state.world.vfxWorld.update === 'function') {
          if (typeof state.world.vfxWorld.groundY !== 'undefined') {
            state.world.vfxWorld.groundY = state.world.groundY;
          }
          state.world.vfxWorld.update(dtMs);
        }
        if (state.world.summonManager && typeof state.world.summonManager.update === 'function') {
          state.world.summonManager.update(dtMs);
        }
      }

      function renderWorld(ctx, cameraX = 0) {
        if (!state.ready) return;
        state.world.camera.x = cameraX || 0;
        state.world.camera.y = 0;
        if (state.hitboxManager) {
          state.hitboxManager.render(ctx, state.world.camera, false);
        }
        if (state.world.vfxWorld && typeof state.world.vfxWorld.render === 'function') {
          state.world.vfxWorld.render(ctx, state.world.camera);
        }
        if (state.world.summonManager && typeof state.world.summonManager.render === 'function') {
          state.world.summonManager.render(ctx, state.world.camera);
        }
      }

      function onHit(payload) {
        if (!payload || !payload.hitbox || !payload.target) return;
        const damage = Math.max(0, payload.damage || 0);
        if (damage <= 0) return;
        const owner = payload.hitbox.owner;
        if (!owner || !owner.__heroRef) return;
        if (typeof gainRage === 'function') {
          gainRage(owner.__heroRef, Math.floor(damage * 0.4));
        }
      }

      api = {
        canHandle,
        cast,
        update,
        renderWorld,
        onHit,
        ensureReady: () => ensureReady()
      };

      return api;
    })();

    window.skillIntegration = skillIntegration;

    /* ================= NEW SIMPLIFIED SKILL WRAPPER ================= */
    function useSkillWrapper(a, key, context = {}) {
      if (!a || a.isDefeated) return false;

      const integration = window.skillIntegration;
      if (integration && integration.canHandle(a, key)) {
        const ok = integration.cast(a, key, context);
        if (ok) {
          try { a.lastSkill = { key, time: (performance.now?.() || Date.now()) }; } catch (_e) { }
          return true;
        }
      }

      if (typeof window.useSimpleSkill === 'function') {
        try {
          const payload = Object.assign({}, context, { __skipBridge: true });
          const ok = window.useSimpleSkill(a, key, payload);
          if (ok) {
            try { a.lastSkill = { key, time: (performance.now?.() || Date.now()) }; } catch (_e) { }
            try {
              const fallbackNormalize = (id) => {
                if (!id) return '';
                const raw = String(id).trim();
                const upper = raw.toUpperCase();
                if (upper === 'UNIQUE') return 'Unique';
                if (upper === 'MISSY') return 'Missy';
                if (upper === 'CLONE') return 'clone';
                if (upper.startsWith('A1')) return 'A1';
                return raw;
              };
              const normalize = (typeof normalizeHeroIdForCd === 'function') ? normalizeHeroIdForCd : fallbackNormalize;
              const heroCdKey = normalize(a.id);
              if (heroCdKey) {
                if (typeof ensureCooldownRow === 'function') ensureCooldownRow(heroCdKey);
                const cdsState = window.st?.cds && window.st.cds[heroCdKey];
                if (cdsState) {
                  const simpleHeroKey = String(a.id || '').toUpperCase();
                  const simpleLib = window.SIMPLE_SKILLS && window.SIMPLE_SKILLS[simpleHeroKey];
                  const cdMs = simpleLib && simpleLib[key] ? (simpleLib[key].cooldown || 0) : 0;
                  if (cdMs > 0) {
                    const current = cdsState[key] || 0;
                    cdsState[key] = Math.max(current, cdMs);
                  }
                }
              }
            } catch (_syncErr) { }
            return true;
          }
        } catch (err) {
          console.error('Skill error:', err);
        }
      }

      return false;
    }
    function genericSkill(a, key) {
      if (!cdReady(a.id, key)) return;
      a._castInvT = Math.max(a._castInvT || 0, 2000);
      if (key === 'S1') {
        // Small AoE
        addCast(a.x + 8, a.y - 40, '#6aa8ff');
        st.shots.push({ x: a.x + 80, y: a.y - 40, vx: 0, vy: 0, dmg: Math.round(a.dmg * 2.2), life: 100, aoe: 60 });
      } else if (key === 'S2') {
        // Heal self
        a.hp = Math.min(a.hpMax, a.hp + Math.round(a.hpMax * 0.25));
        addCast(a.x, a.y - 36, '#36c777');
      } else if (key === 'S3') {
        // Multi-shots
        for (let i = 0; i < 5; i++) {
          setTimeout(() => {
            st.shots.push({ x: a.x + 10, y: a.y - 40, vx: 700, vy: (i - 2) * 30, speed: 700, dmg: Math.round(a.dmg * 1.1), life: 1600, ownerId: a.id });
          }, i * 80);
        }
      }
      // During Rage, S1-S3 ignore normal cooldowns but obey tiny GCD
      if (a.rageOn && (key === 'S1' || key === 'S2' || key === 'S3')) {
        a._gcdT = Math.max(a._gcdT || 0, 200);
      } else {
        startCD(a.id, key);
      }
    }

    /* ================= Cooldown Tick ================= */
    function tickCooldowns(dtMs) {
      for (const hero in st.cds) {
        const key = (hero || '').toUpperCase();
        const cdr = (st._usCdr && st._usCdr[key]) ? st._usCdr[key] : 0;
        const tick = dtMs * (1 + Math.max(0, cdr));
        for (const k in st.cds[hero]) {
          st.cds[hero][k] = Math.max(0, st.cds[hero][k] - tick);
        }
      }
      if (st._globalSkillLock > 0) st._globalSkillLock -= dtMs;
      try { updateSkillReadyUI(); } catch (_e) { }
    }

    /* ================= Rage/Secret Gauges Tick ================= */
    function gainRage(p, amount) { if (!p || p.isDefeated || amount <= 0) return; p.rage = Math.min(p.rageMax, (p.rage || 0) + amount); }
    function canUseSecret(p) {
      if (!p || p.isDefeated) return false;
      const bossUp = !!st.bossAlive && (st.bossHP || 0) > 0;
      const lowHP = (p.hpMax > 0) ? (p.hp / p.hpMax) <= 0.35 : false;
      return (p.secretGauge >= p.secretMax) && (bossUp || lowHP) && !p.secretActive && !p.rageOn;
    }
    function tryActivateSecretFor(p) {
      if (!canUseSecret(p)) { notify('Secret not ready'); return; }
      p.secretActive = true; p.secretTimer = 2000; // 2s channel
      p._secretDrainPerMs = (p.hpMax || 1) * 0.0001; // 20% over 2s
      // Prevent switching leaders during channel
      st._noSwitchUntil = performance.now() + p.secretTimer;
      addCast(p.x, p.y - 44, '#ff6aa8');
      notify(p.id + " Channeling Secret...");
    }
    function tickGauges(dtMs) {
      for (const p of (st.players || [])) {
        // per-player GCD
        if ((p._gcdT || 0) > 0) p._gcdT = Math.max(0, p._gcdT - dtMs);
        // Rage
        if (p.rageOn) {
          p.rageDur -= dtMs;
          if (p.rageDur <= 0) {
            p.rageOn = false;
            p.exhaustionT = 3000; // 3s
            p._atkMul = 0.8; p._speedMul = 1; recalcStats();
            notify(p.id + ' Exhausted');
          }
        } else if ((p.exhaustionT || 0) > 0) {
          p.exhaustionT = Math.max(0, p.exhaustionT - dtMs);
          if (p.exhaustionT === 0) { p._atkMul = 1; recalcStats(); }
        }
        // Secret channel
        if (p.secretActive) {
          p.secretTimer -= dtMs;
          if (p._secretDrainPerMs) { p.hp = Math.max(1, p.hp - p._secretDrainPerMs * dtMs); }
          if (p.secretTimer <= 0) {
            p.secretActive = false; p.secretGauge = 0;
            // Fire Secret
            try { useSkillWrapper(p, 'X1'); } catch (_) { }
            if (st.cds && st.cds[p.id]) st.cds[p.id].X1 = 120000;
            notify(p.id + ' SECRET!', '#ffaa00');
          }
        }
      }
    }

    /* ================= Physics & Game Loop ================= */
    function nearestEnemy(a) {
      if (a !== leader()) {
        const livingEnemies = st.enemies.filter(e => e.hp > 0);
        if (livingEnemies.length > 0) {
          return livingEnemies[Math.floor(Math.random() * livingEnemies.length)];
        }
        return null;
      }
      let best = null, bestD = 1e9;
      for (const e of st.enemies) {
        if (e.hp > 0) {
          const d = Math.hypot(e.x - a.x, e.y - a.y);
          if (d < bestD) { bestD = d; best = e; }
        }
      }
      return best;
    }
    // Auto-charge Weapon (W=slot4) and Pet (P=slot5) and auto-cast when full
    function tickAutoWP(dtMs) {
      if (!window.UnifiedSkills) return;
      const ratePerSec = 10; // fills in ~10s
      for (const p of (st.players || [])) {
        if (!p || p.isDefeated) continue;
        const slots = window.UnifiedSkills.getSlots(p.id) || {};
        const US = window.UnifiedSkills.stateRef ? window.UnifiedSkills.stateRef() : {};
        const hk = (p.id || '').toUpperCase();
        const allowW = !US || !US.autoWByHero ? true : (US.autoWByHero[hk] !== false);
        const allowP = !US || !US.autoPByHero ? true : (US.autoPByHero[hk] !== false);
        // Initialize charges
        if (p._WCharge == null) p._WCharge = 0; if (p._PCharge == null) p._PCharge = 0;
        // Charge tick, scale by hero CDR a bit (speeds fill slightly)
        const cdr = (st._usCdr && st._usCdr[(p.id || '').toUpperCase()]) || 0;
        const mul = 1 + Math.min(0.5, Math.max(0, cdr * 0.5));
        if (slots[4]) p._WCharge = Math.min(100, p._WCharge + (ratePerSec * mul * dtMs / 1000));
        if (slots[5]) p._PCharge = Math.min(100, p._PCharge + (ratePerSec * mul * dtMs / 1000));
        // Auto-cast
        if (slots[4] && allowW && p._WCharge >= 100) { try { castWeaponAuto(p, window.UnifiedSkills.getItem(p.id, 4)); } catch (_e) { } p._WCharge = 0; }
        if (slots[5] && allowP && p._PCharge >= 100) { try { castPetAuto(p, window.UnifiedSkills.getItem(p.id, 5)); } catch (_e) { } p._PCharge = 0; }
        // Decay temporary speed buffs (e.g., Missy pet aura)
        if (p._usSpeedBuffT > 0) { p._usSpeedBuffT -= dtMs; if (p._usSpeedBuffT <= 0) p._usSpeedBuff = 1; }
        // Decay sword swing timer for visual effects
        if (p._swordT > 0) p._swordT -= dtMs;
      }
    }
    function castWeaponAuto(p, item) {
      const id = (p.id || '').toUpperCase();
      if (id === 'A1') {
        // Mini X-waves
        const waves = Math.max(2, Math.min(5, Math.round(item?.stats?.waves?.[0] || 3)));
        for (let i = 0; i < waves; i++) { const ang = (i - (waves - 1) / 2) * 0.12; spawnXWave(p, ang, 520, p.dmg * 0.35, 4, 0.04, 1100, 16 * 1.2); }
      } else if (id === 'UNIQUE') {
        // Shard fan volley
        const count = Math.max(4, Math.min(10, (item?.stats?.shards || 7)));
        for (let i = 0; i < count; i++) { const ang = (i - (count - 1) / 2) * 0.1; const sp = 560; st.shots.push({ x: p.x + 10, y: p.y - 40, vx: Math.cos(ang) * sp, vy: Math.sin(ang) * sp, speed: sp, dmg: Math.round(p.dmg * 0.35), life: 900, ownerId: p.id, freeze: true }); }
      } else if (id === 'MISSY') {
        // Light rain
        for (let i = 0; i < 6; i++) { const ang = (Math.random() * 0.2 - 0.1); const sp = 500; st.shots.push({ x: p.x + 10, y: p.y - 60, vx: Math.cos(ang) * sp, vy: Math.sin(ang) * sp, speed: sp, dmg: Math.round(p.dmg * 0.3), life: 1000, ownerId: p.id, color: '#ffd46e' }); }
      } else {
        // Default volley
        const count = Math.max(3, Math.min(9, (item?.stats?.shards || item?.stats?.projectiles?.[0] || 5)));
        for (let i = 0; i < count; i++) {
          const ang = (i - (count - 1) / 2) * 0.08; const sp = 600; const dmg = Math.round(p.dmg * 0.4);
          st.shots.push({ x: p.x + 10, y: p.y - 40, vx: Math.cos(ang) * sp, vy: Math.sin(ang) * sp, speed: sp, dmg, life: 900, ownerId: p.id, color: '#ffd56a' });
        }
      }
      try { addFloater(p.x, p.y - 52, 'W-CAST', '#ffd56a'); } catch (_) { }
    }
    function castPetAuto(p, item) {
      const id = (p.id || '').toUpperCase();
      if (id === 'MISSY') {
        // Small speed aura buff for team
        for (const h of (st.players || [])) {
          if (!h.isDefeated) { h._usSpeedBuff = Math.max(1, (h._usSpeedBuff || 1), 1.05); h._usSpeedBuffT = 3000; try { addFloater(h.x, h.y - 42, 'Haste', '#ffd46e'); } catch (_) { } }
        }
        try { st.effects.push({ kind: 'impact', x: p.x, y: p.y - 30, color: '#ffd46e', life: 700, max: 700 }); } catch (_) { }
      } else {
        // Default supportive heal
        const healPct = Math.min(0.25, Math.max(0.05, item?.stats?.teamHeal || 0.12));
        for (const h of (st.players || [])) {
          if (!h.isDefeated) { h.hp = Math.min(h.hpMax || 0, (h.hp || 0) + Math.round((h.hpMax || 0) * healPct)); try { addFloater(h.x, h.y - 42, '+HP', '#36c777'); } catch (_) { } }
        }
        try { st.effects.push({ kind: 'cast', x: p.x, y: p.y - 40, color: '#36c777', life: 600, max: 600 }); } catch (_) { }
      }
    }
    function updateWPStatusHUD() {
      const wrap = document.getElementById('currency'); if (!wrap) return;
      let pill = document.getElementById('wpStatusPill');
      if (!pill) { pill = document.createElement('div'); pill.className = 'pill'; pill.id = 'wpStatusPill'; wrap.appendChild(pill); }
      const L = (st.players || [])[st.leader || 0]; if (!L) { pill.textContent = 'W: - P: -'; return; }
      const w = Math.round(Math.min(100, L._WCharge || 0)); const q = Math.round(Math.min(100, L._PCharge || 0));
      pill.innerHTML = `W: <b>${w}%</b> P: <b>${q}%</b>`;
      // Also update dock bars if present
      try {
        const wb = document.getElementById('weapon-skill-bar'); if (wb) wb.style.width = w + '%';
        const pb = document.getElementById('pet-skill-bar'); if (pb) pb.style.width = q + '%';
      } catch (_e) { }
      // Update overlay W/P mini-bars for selected hero
      try {
        const US = window.UnifiedSkills && window.UnifiedSkills.stateRef ? window.UnifiedSkills.stateRef() : null;
        const hero = US?.activeHero || (st.players?.[st.leader || 0]?.id) || 'A1';
        const P = (st.players || []).find(h => (h.id || '').toUpperCase() === ('' + hero).toUpperCase());
        const w2 = Math.round(Math.min(100, P ? (P._WCharge || 0) : 0));
        const p2 = Math.round(Math.min(100, P ? (P._PCharge || 0) : 0));
        const ovW = document.querySelector('.ovSlot[data-slot="4"] .small-charge-bar-fill'); if (ovW) ovW.style.width = w2 + '%';
        const ovP = document.querySelector('.ovSlot[data-slot="5"] .small-charge-bar-fill'); if (ovP) ovP.style.width = p2 + '%';
      } catch (_e) { }
    }
    function update(dt) {
      const dtMs = dt * 1000;
      // Halt most game logic when Game Over
      if (st.isGameOver) {
        return;
      }

      if (window.skillIntegration) {
        try {
          if (typeof window.skillIntegration.ensureReady === 'function') {
            window.skillIntegration.ensureReady();
          }
          window.skillIntegration.update(dt, dtMs);
        } catch (_err) {
          console.error('Skill integration update failed:', _err);
        }
      }

      // ===== PROCEDURAL SYSTEMS UPDATE =====
      // Update particle system
      if (window.globalParticles) {
        window.globalParticles.update(dt);
      }

      // Update spell glyphs
      if (window.spellGlyphs) {
        window.spellGlyphs.update(dt);
      }

      // Update dynamic sky
      if (window.dynamicSky) {
        window.dynamicSky.update(dt, st.camX || 0);
        window.dynamicSky.setStage(st.stage || 1);
      }

      // Update charge manager
      if (window.chargeManager) {
        window.chargeManager.update(dt);
      }

      // Update enhanced enemy AI
      if (window.enhancedEnemyAI) {
        window.enhancedEnemyAI.update(st, dt);
      }

      // Update enemy abilities
      if (window.enemyAbilities) {
        window.enemyAbilities.update(st, dt);
      }

      // Update character renderers animation time
      if (window.CharacterRenderers) {
        Object.values(window.CharacterRenderers).forEach(renderer => {
          if (renderer && typeof renderer.update === 'function') {
            renderer.update(dt);
          }
        });
      }
      // Shield duration update: tick down active shield and disable when expired
      if (st.shieldOn && st.shieldT > 0) {
        st.shieldT -= dtMs;
        if (st.shieldT <= 0) {
          st.shieldOn = false;
        }
      }
      if (st.shieldCD > 0) {
        st.shieldCD -= dtMs;
      }
      // Timers
      if (st.parryT > 0) st.parryT -= dtMs;
      // Combo decay and HUD
      if (st.comboSystem) {
        if (st.comboSystem.comboTimer > 0) st.comboSystem.comboTimer -= dtMs;
        if (st.comboSystem.comboTimer <= 0 && st.comboSystem.currentCombo > 0) {
          // Show a tiny fade-out chip when combo expires
          showComboLostFX();
          st.comboSystem.currentCombo = 0;
          st.comboSystem.comboMultiplier = 1.0;
        }
        updateComboHUD();
      }
      tickCooldowns(dtMs);
      tickFollowerLocks(dtMs);
      checkPlayersRevive(dtMs);
      // Rage/Secret update
      tickGauges(dtMs);
      updateGadgetCore(dtMs);
      updateBeastCore(dtMs);
      updateCrystalCore(dtMs);
      // Weapon/Pet auto-charge and status HUD
      try { tickAutoWP(dtMs); updateWPStatusHUD(); } catch (_e) { }

      // Clone periodic AI (autoshoot X-waves and do simple melee)
      try { updateClones(dtMs); } catch (_e) { }

      // Unique's Rage Beam
      const unique = st.players.find(p => p.id === 'Unique');
      if (unique && unique.rageOn) {
        if (!unique.uniqueBeamTimer) unique.uniqueBeamTimer = 0;
        unique.uniqueBeamTimer -= dtMs;
        if (unique.uniqueBeamTimer <= 0) {
          unique.uniqueBeamTimer = 80; // ~0.08s
          const target = nearestEnemy(unique);
          if (target) {
            const dmg = Math.round(unique.dmg * 0.5); // Beam damage
            target.hp -= dmg;
            addFloater(target.x, target.y - 20, '-' + dmg, '#6aa8ff');
            if (target.hp <= 0) onEnemyKilled(target);

            // Add a visual effect for the beam
            st.effects.push({
              kind: 'beam',
              x1: unique.x,
              y1: unique.y - 30,
              x2: target.x,
              y2: target.y,
              color: '#6aa8ff',
              life: 100,
              max: 100,
              thick: 4
            });
          }
        }
      }

      // Movement
      for (const p of st.players) {
        // A1's On-Hit Buff Timer (FIXED: non-stacking)
        if (p.id === 'A1' && p.atkBuffActive) {
          if (p.atkBuffT > 0) {
            p.atkBuffT -= dtMs;
          }
          if (p.atkBuffT <= 0) {
            p.atkBuffActive = false;
            // Restore original stats
            p.dmgBase = p._origDmgBase;
            p.speedBase = p._origSpeedBase;
            p.defBase = p._origDefBase;
            recalcStats();
            addFloater(p.x, p.y - 45, 'Buff Down', '#aaa');
          }
        }
      }
      const L = leader();
      if (!L.isDefeated) {
        if (window.Platform && Platform.enabled) {
          Platform.playerStep(L, dt, { joyX, joyY, up: keys['ArrowUp'] || keys['KeyW'], down: keys['ArrowDown'] || keys['KeyS'] });
        } else {
          L.vx = joyX * ((L.speedBase || 0.5) * (L._speedMul || 1) * (L._usSpeedMul || 1) * (L._coreSpeedMul || 1) * (L._beastHowlSpeedMul || 1));
          L.vy += 0.0018;
          L.x += L.vx * DESIGN_W * dt;
          L.y += L.vy * DESIGN_H * dt;
          const gy = laneY(L.lane);
          if (L.y > gy) { L.y = gy; L.vy = 0; L.grounded = true; L.jumpCount = 0; }
          L.x = Math.max(40, Math.min((WORLD_WIDTH || DESIGN_W) - 40, L.x));
          if (Math.abs(joyX) > 0.1) { L.facingLeft = joyX < 0; }
        }
      }

      /* ================== Enemy Melee Collision System ================== */
      function checkEnemyMeleeCollision(enemy, dtMs) {
        if (enemy.hp <= 0) return;

        // Initialize enemy melee properties if not set
        if (!enemy._meleeCD) enemy._meleeCD = 0;
        if (!enemy._meleeDamage) enemy._meleeDamage = 12 + Math.floor(st.stage * 2);

        // Update melee cooldown
        if (enemy._meleeCD > 0) {
          enemy._meleeCD -= dtMs;
        }

        // Check collision with all players
        for (const player of st.players) {
          if (player.isDefeated) continue;

          const dist = Math.hypot(enemy.x - player.x, enemy.y - player.y);

          // Melee range collision (30 pixels)
          if (dist < 30 && enemy._meleeCD <= 0) {
            // Deal damage to player
            damagePlayer(player, enemy._meleeDamage);

            // Add pushback effect to enemy
            const pushX = (enemy.x - player.x) / dist;
            const pushY = (enemy.y - player.y) / dist;
            enemy.x += pushX * 15; // Push enemy back 15 pixels
            enemy.y += pushY * 15;

            // Set cooldown to prevent spam
            enemy._meleeCD = 1000; // 1 second cooldown

            // Add visual effect
            st.effects.push({
              kind: 'impact',
              x: player.x,
              y: player.y - 20,
              color: '#ff4d4f',
              life: 200,
              max: 200
            });

            // Screen shake effect (if available)
            if (typeof addScreenShake === 'function') {
              addScreenShake(5, 200);
            }

            break; // Only hit one player per frame
          }
        }
      }

      /* ================= Advanced Follower AI ================= */
      function updateAdvancedFollowerAI(dtMs) {
        const coord = st._followerCoordinator;
        st.players.forEach((p, i) => {
          if (p === leader() || p.isDefeated) return;

          if (coord && coord.queues) {
            const key = p.id || i;
            const queue = coord.queues[key];
            if (Array.isArray(queue) && queue.length) {
              let consumed = false;
              while (queue.length && !consumed) {
                const action = queue[0];
                const result = runFollowerAction(p, action, dtMs);
                queue.shift();
                if (result === 'consumed') consumed = true;
              }
              if (!queue.length) delete coord.queues[key];
            }
          }

          // Independent movement AI
          if (!p._riding && p._aiState !== 'shopping') {
            updateFollowerCombatAI(p, dtMs);
          }

          // Dodge and jump logic
          const nearbyShots = st.eShots.filter(s => Math.hypot(s.x - p.x, s.y - p.y) < 100);
          if (nearbyShots.length > 0) {
            let dodgeVx = 0;
            let dodgeVy = 0;
            for (const shot of nearbyShots) {
              const dx = p.x - shot.x;
              const dy = p.y - shot.y;
              const dist = Math.hypot(dx, dy);
              if (dist > 0) {
                dodgeVx += (dx / dist) * 50;
                dodgeVy += (dy / dist) * 50;
              }
            }
            p.vx += dodgeVx * dtMs / 1000;
            p.vy += dodgeVy * dtMs / 1000;

            // Jump to avoid
            if (p.grounded && Math.random() < 0.5) {
              p.vy = -0.22;
              p.grounded = false;
            }
          }

          // Between-wave inventory management
          if (st.enemies.every(e => e.hp <= 0) && !p._aiShopCooldown) {
            scheduleFollowerUpkeep(p);
          }
        });
      }

      function updateFollowerCombatAI(follower, dtMs) {
        const L = leader();

        // AI State machine
        if (!follower._aiState) follower._aiState = 'follow';
        if (!follower._aiTimer) follower._aiTimer = 0;

        follower._aiTimer += dtMs;

        switch (follower._aiState) {
          case 'follow':
            // Standard follow behavior with improved positioning
            const targetX = L.x - 80 - (Math.random() * 40);
            const targetY = laneY(follower.lane) + (Math.random() * 20 - 10);

            // Update facing direction based on movement
            const moveX = targetX - follower.x;
            if (Math.abs(moveX) > 5) {
              follower.facingLeft = moveX < 0;
            }

            follower.x += (targetX - follower.x) * 0.12;
            follower.y += (targetY - follower.y) * 0.18;

            // Check for better positioning opportunities
            if (follower._aiTimer > 3000) {
              const nearestEnemy = findNearestEnemyTo(follower);
              if (nearestEnemy && Math.hypot(nearestEnemy.x - follower.x, nearestEnemy.y - follower.y) > 200) {
                follower._aiState = 'reposition';
                follower._aiTimer = 0;
              }
            }
            break;

          case 'reposition':
            // Move to better firing position
            const enemy = findNearestEnemyTo(follower);
            if (enemy) {
              const optimalX = enemy.x - 180; // Stay at range
              const optimalY = enemy.y + (Math.random() * 60 - 30);

              // Update facing direction based on movement
              const moveX = optimalX - follower.x;
              if (Math.abs(moveX) > 5) {
                follower.facingLeft = moveX < 0;
              }

              follower.x += (optimalX - follower.x) * 0.15;
              follower.y += (optimalY - follower.y) * 0.15;

              // Return to follow after positioning
              if (follower._aiTimer > 2000 || Math.hypot(optimalX - follower.x, optimalY - follower.y) < 30) {
                follower._aiState = 'follow';
                follower._aiTimer = 0;
              }
            } else {
              follower._aiState = 'follow';
              follower._aiTimer = 0;
            }
            break;

          case 'cover':
            // Take cover behind obstacles or other players
            const coverX = L.x - 120;
            const coverY = L.y + 40;

            follower.x += (coverX - follower.x) * 0.20;
            follower.y += (coverY - follower.y) * 0.20;

            if (follower._aiTimer > 3000) {
              follower._aiState = 'follow';
              follower._aiTimer = 0;
            }
            break;

          case 'lootSweep':
            {
              const sweepX = L.x - 60;
              const sweepY = laneY(follower.lane) - 10;
              follower.x += (sweepX - follower.x) * 0.18;
              follower.y += (sweepY - follower.y) * 0.18;
              if (follower._aiTimer > 600) {
                follower._aiState = 'follow';
                follower._aiTimer = 0;
              }
            }
            break;

          case 'jump':
            {
              const jumpTargetX = L.x - 70;
              const laneTargetY = laneY(follower.lane);
              follower.x += (jumpTargetX - follower.x) * 0.12;
              if (!follower.grounded) {
                follower.y += (laneTargetY - 12 - follower.y) * 0.08;
              }
              if (follower.grounded && follower._aiTimer > 160) {
                follower._aiState = 'follow';
                follower._aiTimer = 0;
              }
            }
            break;
        }
      }

      function scheduleFollowerUpkeep(follower) {
        if (follower._aiState === 'shopping') return;

        follower._aiState = 'shopping';
        follower._aiShopCooldown = 20000; // 20 second cooldown between shopping

        // Delay the shopping to feel more natural
        setTimeout(() => {
          performFollowerUpkeep(follower);
        }, 1000 + Math.random() * 2000);
      }

      function performFollowerUpkeep(follower) {
        if (follower.isDefeated) return;

        notify(`${follower.id} is managing inventory...`, '#6aa8ff');

        // Auto-organize inventory
        autoOrganizeInventoryFor(follower);

        // Auto-sell low-value items
        autoSellItemsFor(follower);

        // Smart shopping based on needs
        smartShopFor(follower);

        // Return to normal AI
        setTimeout(() => {
          follower._aiState = 'follow';
          follower._aiTimer = 0;
        }, 3000);
      }

      function autoOrganizeInventoryFor(follower) {
        // Simulate inventory organization
        // In a full implementation, this would sort items by type, rarity, etc.
        if (Math.random() < 0.3) {
          notify(`${follower.id} organized inventory`, '#6aa8ff');
        }
      }

      function autoSellItemsFor(follower) {
        // Simulate selling low-value items
        const sellChance = Math.random();
        if (sellChance < 0.4) {
          const goldGain = 50 + Math.floor(Math.random() * 100);
          st.gold += goldGain;
          updateCurrencies();
          notify(`${follower.id} sold items (+${goldGain} gold)`, '#ffd56a');
        }
      }

      function smartShopFor(follower) {
        // AI shopping based on follower needs
        const needsHealing = follower.hp < follower.hpMax * 0.8;
        const hasGold = st.gold >= 60;

        if (needsHealing && hasGold && Math.random() < 0.6) {
          // Buy healing item
          st.gold -= 60;
          const heal = Math.round(follower.hpMax * 0.4);
          follower.hp = Math.min(follower.hpMax, follower.hp + heal);
          updateCurrencies();
          addFloater(follower.x, follower.y - 60, '+' + heal + ' HP', '#36c777');
          notify(`${follower.id} bought HP potion`, '#36c777');
        } else if (st.gold >= 90 && Math.random() < 0.3) {
          // Buy rage pill
          st.gold -= 90;
          follower.rage = Math.min(follower.rageMax, follower.rage + 30);
          updateCurrencies();
          notify(`${follower.id} bought rage pill`, '#f9cc2b');
        }
      }

      function findNearestEnemyTo(character) {
        let nearest = null;
        let bestDist = Infinity;

        for (const e of st.enemies) {
          if (e.hp <= 0) continue;
          const dist = Math.hypot(e.x - character.x, e.y - character.y);
          if (dist < bestDist) {
            bestDist = dist;
            nearest = e;
          }
        }
        return nearest;
      }

      /* ================== Tamed Boss Companion AI ================== */
      function updateTamedBosses(dtMs) {
        const L = leader();
        const dtSec = dtMs / 1000;

        st.tamedBosses.forEach((companion, index) => {
          if (!companion || companion.hp <= 0) return;

          // Following behavior - stagger positions
          const offsetX = -100 - (index * 60);
          const offsetY = (index % 2 === 0 ? -40 : 40);
          const targetX = L.x + offsetX;
          const targetY = L.y + offsetY;

          const dx = targetX - companion.x;
          const dy = targetY - companion.y;
          const distToLeader = Math.sqrt(dx * dx + dy * dy);

          // Move toward leader if too far
          if (distToLeader > 80) {
            const speed = 120 * dtSec;
            const angle = Math.atan2(dy, dx);
            companion.x += Math.cos(angle) * speed;
            companion.y += Math.sin(angle) * speed;
          }

          // Face direction based on nearest enemy
          const nearestEnemy = findNearestEnemyTo(companion);
          if (nearestEnemy) {
            companion.facingLeft = nearestEnemy.x < companion.x;
          }

          // Attack cooldown
          companion._attackCooldown = Math.max(0, (companion._attackCooldown || 0) - dtMs);

          // Attack nearest enemy
          if (nearestEnemy && companion._attackCooldown <= 0) {
            const distToEnemy = Math.hypot(nearestEnemy.x - companion.x, nearestEnemy.y - companion.y);

            if (distToEnemy < 400) {
              // Shoot at enemy
              const angle = Math.atan2(nearestEnemy.y - companion.y, nearestEnemy.x - companion.x);
              st.shots.push({
                kind: 'companion',
                x: companion.x,
                y: companion.y,
                vx: Math.cos(angle) * 0.4,
                vy: Math.sin(angle) * 0.4,
                dmg: companion.dmg || 20,
                life: 2000,
                color: '#ffd56a',
                ownerId: companion.id
              });

              companion._attackCooldown = 1500; // 1.5 second cooldown
              addCast(companion.x, companion.y, '#ffd56a', 200);
            }
          }
        });

        // Remove dead companions
        const beforeCount = st.tamedBosses.length;
        st.tamedBosses = st.tamedBosses.filter(c => c.hp > 0);
        if (beforeCount !== st.tamedBosses.length) {
          updateCompanionHUD();
        }
      }

      // Enemy update
      for (const e of st.enemies) {
        if (e.hp <= 0) continue;
        // Skip bosses that are requesting taming
        if (e._requestingTame) continue;

        tickStatuses(e, dtMs);
        if (e.hp <= 0) continue;

        if (e.spawnShieldT > 0) {
          e.spawnShieldT -= dtMs;
        }

        // Update boss tracking
        if (e.kind === 'boss') {
          st.bossHP = e.hp;
          st.bossMax = e.max;
        }

        // Basic move
        const statusSpeed = e._statusSpeedMult != null ? e._statusSpeedMult : 1;
        e.x += (e.vx || 0) * DESIGN_W * dt * statusSpeed;



        if (e._statusGravityForce) {
          const gravityDt = dtMs / 1000;
          e.vy = (e.vy || 0) + e._statusGravityForce * gravityDt;
        }

        if (e._statusPushDelta) {
          e.x += e._statusPushDelta;
          e._statusPushDelta = 0;
        }

        // Teleport VFX for newly spawned enemies
        if (e._justTeleported) {
          e._teleportTimer += dt * 1000;
          if (e._teleportTimer < 500) {
            // Add teleport effect
            st.effects.push({
              kind: 'cast',
              x: e.x + (Math.random() - 0.5) * 30,
              y: e.y + (Math.random() - 0.5) * 30,
              color: '#aa44ff',
              life: 200,
              max: 200
            });
          } else {
            e._justTeleported = false; // Stop teleport VFX
          }
        }

        // Enemy behaviour and shooting only after the wave has officially started
        if (st.matchStarted) {
          applyEnemyBehavior(e, dt);
          if (e.fireCD != null) {
            e.fireCD -= dtMs;
            if (e.fireCD <= 0) {
              enemyShoot(e);
              e.fireCD = 1000;
            }
          }
        }

        // Melee enemy collision with players
        if (st.matchStarted) {
          checkEnemyMeleeCollision(e, dtMs);
        }
      }
      updateEnemyFormations();

      // Update advanced follower AI
      updateAdvancedFollowerAI(dtMs);

      if (Array.isArray(st.aiCompanions) && st.aiCompanions.length) {
        for (const companion of st.aiCompanions) {
          if (!companion || companion.alive === false) continue;
          try {
            companion.update(dt, { state: st });
          } catch (err) {
            console.error('[Robox] companion update failed', err);
          }
        }
      }

      // Update tamed boss companions
      if (st.tamedBosses && st.tamedBosses.length > 0) {
        updateTamedBosses(dtMs);
      }

      // Update vehicles
      updateVehicles(dtMs);

      // Update pets
      updatePets(dtMs);

      // Update damage numbers


      // Update action button context
      updateUniversalActionButton();
      updateSharedGauge(st.dt);

      // ENHANCED: Update action toys system
      updateActionToys(dtMs);

      // ENHANCED: Update party potion system
      updatePartyPotion(dtMs);

      // Update AI shop cooldowns
      st.players.forEach(p => {
        if (p._aiShopCooldown > 0) p._aiShopCooldown -= dtMs;
      });
      updateEnemyFormations();

      // Player shots
      for (const s of st.shots) {
        if (s.bounce > 0) {
          if (s.y > DESIGN_H - 120 || s.y < 0) {
            s.vy *= -1;
            s.bounce--;
          }
        }
        s.x += (s.vx || 0) * dt;
        s.y += (s.vy || 0) * dt;
        if (s.roaming && !s._roamBoosted) {
          s.life += 1200;
          s._roamBoosted = true;
        }
        if (s.neverMiss && !s._neverMissBoosted) {
          s.life += 1500;
          s._neverMissBoosted = true;
        }
        const lifeDecay = s.roaming ? dtMs * 0.7 : dtMs;
        s.life -= lifeDecay;

        // Homing logic for player shots: adjust velocity towards nearest enemy with roaming metadata
        const baseSpeed = s.speed || Math.hypot(s.vx || 0, s.vy || 0) || 0;
        if (baseSpeed > 0) {
          const passes = s.neverMiss ? 2 : 1;
          const steer = s.roaming ? 0.24 : (s.neverMiss ? 0.18 : 0.10);
          const targeted = new Set();
          for (let pass = 0; pass < passes; pass++) {
            let nearest = null; let minDist2 = Infinity;
            for (const e of st.enemies) {
              if (e.hp > 0 && !targeted.has(e)) {
                const dx = e.x - s.x;
                const dy = e.y - s.y;
                const d2 = dx * dx + dy * dy;
                if (d2 < minDist2) {
                  minDist2 = d2;
                  nearest = e;
                }
              }
            }
            if (!nearest) break;
            targeted.add(nearest);
            const ang = Math.atan2(nearest.y - s.y, nearest.x - s.x);
            s.vx = (s.vx || 0) + Math.cos(ang) * baseSpeed * dt * steer;
            s.vy = (s.vy || 0) + Math.sin(ang) * baseSpeed * dt * steer;
            const curSpeed = Math.hypot(s.vx, s.vy);
            if (curSpeed > 0) {
              const limit = s.roaming ? Math.min(baseSpeed * 1.15, curSpeed) : baseSpeed;
              s.vx = (s.vx / curSpeed) * limit;
              s.vy = (s.vy / curSpeed) * limit;
            }
          }
        }

        // Special behavior for unique projectiles
        if (s.kind === 'unique_stellar_beam' && s.persistent && s.tickRate) {
          if (!s.lastTick) s.lastTick = 0;
          s.lastTick += dtMs;
          if (s.lastTick >= s.tickRate) {
            s.lastTick = 0;
            // Continuous damage to enemies in beam area
            for (const e of st.enemies) {
              if (e.hp > 0 && Math.abs(e.x - s.x) < s.w / 2 && Math.abs(e.y - s.y) < s.h / 2) {
                const rd = Math.max(1, (s.dmg || 0) - (e.def || 0));
                e.hp -= rd;
                addFloater(e.x, e.y - 20, '-' + rd, '#6aa8ff');
                if (e.hp <= 0) onEnemyKilled(e);
              }
            }
          }
        }

        // Update attached beams
        if (s.attachedTo && s.attachedTo.x !== undefined) {
          s.x = s.attachedTo.x + 30;
          s.y = s.attachedTo.y - 40;
        }

        // Assistance modules
        if (s.kind === 'unique_module' && s.assistCD) {
          s.lastAssist = (s.lastAssist || 0) + dtMs;
          if (s.lastAssist >= s.assistCD && s.hp > 0) {
            // Find nearest enemy to assist with
            const nearestEnemy = st.enemies.find(e => e.hp > 0 && Math.hypot(e.x - s.x, e.y - s.y) < 200);
            if (nearestEnemy) {
              st.shots.push({
                x: s.x, y: s.y, vx: 400, vy: 0,
                dmg: 20, life: 1000, color: '#00ff88', ownerId: s.ownerId
              });
              s.lastAssist = 0;
            }
          }
        }

        if (s.kind === 'gadget_turret') {
          const owner = findPlayerById(s.ownerId);
          if (!owner || owner.isDefeated || window.EQUIPPED_CORE !== 'gadget') {
            s.life = 0;
          } else {
            s.x = owner.x + 36;
            s.y = owner.y - 32;
            const cadence = Math.max(120, s.shotMs || 280);
            s.lastShot = (s.lastShot || 0) + dtMs;
            const range = s.range || window.CORE_METADATA?.gadget?.turret?.range || 260;
            if (s.lastShot >= cadence) {
              const target = st.enemies.find(e => e.hp > 0 && Math.hypot(e.x - s.x, e.y - s.y) <= range) || nearestEnemy(owner);
              if (target) {
                const ang = Math.atan2(target.y - s.y, target.x - s.x);
                const speed = 640;
                const dmgBase = owner.dmg || owner.dmgBase || 60;
                const shot = {
                  x: s.x,
                  y: s.y,
                  vx: Math.cos(ang) * speed,
                  vy: Math.sin(ang) * speed,
                  speed,
                  dmg: Math.round(dmgBase * (s.dmgMult || 0.55)),
                  life: 1000,
                  ownerId: owner.id,
                  color: '#61dafb',
                  tags: ['tech']
                };
                annotateProjectile(shot, ['tech']);
                st.shots.push(shot);
                s.lastShot = 0;
              } else {
                s.lastShot = cadence; // wait for a target
              }
            }
          }
        }

        // Maneki taunt behavior
        if (s.kind === 'missy_maneki' && s.taunt && s.hp > 0) {
          if (!s.lastTaunt) s.lastTaunt = 0;
          s.lastTaunt += dtMs;
          if (s.lastTaunt >= (s.tauntCD || 2000)) {
            // Pull nearby enemies towards this guardian
            for (const e of st.enemies) {
              if (e.hp > 0 && Math.hypot(e.x - s.x, e.y - s.y) < s.pullRadius) {
                const dx = s.x - e.x;
                const dy = s.y - e.y;
                const dist = Math.hypot(dx, dy);
                if (dist > 0) {
                  e.x += (dx / dist) * 20 * dt;
                  e.y += (dy / dist) * 20 * dt;
                }
              }
            }
            s.lastTaunt = 0;
          }
        }

        // Royal bells healing and loot pull
        if (s.kind === 'missy_royal_bell' && s.hp > 0) {
          if (!s.lastHeal) s.lastHeal = 0;
          s.lastHeal += dtMs;
          if (s.lastHeal >= s.healRate) {
            // Heal nearby players
            st.players.forEach(p => {
              if (!p.isDefeated && Math.hypot(p.x - s.x, p.y - s.y) < 150) {
                const heal = Math.round(p.hpMax * 0.02);
                p.hp = Math.min(p.hpMax, p.hp + heal);
                addFloater(p.x, p.y - 30, '+' + heal, '#36c777');
              }
            });
            s.lastHeal = 0;
          }

          // Loot pull effect (would need pickup system to be fully implemented)
          if (s.lootPull && st.pickups) {
            for (const pickup of st.pickups) {
              const dist = Math.hypot(pickup.x - s.x, pickup.y - s.y);
              if (dist < 200 && dist > 0) {
                const dx = s.x - pickup.x;
                const dy = s.y - pickup.y;
                pickup.x += (dx / dist) * 100 * dt;
                pickup.y += (dy / dist) * 100 * dt;
              }
            }
          }
        }
      }

      // -- Update player shots (movement + lifetime)
      for (const s of st.shots) {
        // Default direction for any projectile that forgot vx/vy
        if ((s.kind === 'a1_xwave') && !s.vx && !s.vy) {
          const Lp = leader();
          const dir = ((Lp?.face ?? Lp?.dir) ?? 1) >= 0 ? 1 : -1;
          s.vx = (s.speed || 900) * dir;
          s.vy = 0;
        }
        
        // Homing for X-waves
        if (s.kind === 'a1_xwave' && s.homing) {
          let nearestEnemy = null;
          let minDist = Infinity;
          for (const e of st.enemies) {
            if (e.hp <= 0) continue;
            const dist = Math.hypot(e.x - s.x, e.y - s.y);
            if (dist < minDist && dist < 400) {
              minDist = dist;
              nearestEnemy = e;
            }
          }
          if (nearestEnemy) {
            const ang = Math.atan2(nearestEnemy.y - s.y, nearestEnemy.x - s.x);
            const spd = Math.hypot(s.vx || 0, s.vy || 0) || 980;
            s.vx += Math.cos(ang) * spd * s.homing * dt;
            s.vy += Math.sin(ang) * spd * s.homing * dt;
            const curS = Math.hypot(s.vx, s.vy);
            if (curS > 0) {
              s.vx = (s.vx / curS) * spd;
              s.vy = (s.vy / curS) * spd;
            }
          }
        }
        
        if (s.gravity) s.vy += 0.0018 * dtMs;

        s.x += (s.vx || 0) * dt;
        s.y += (s.vy || 0) * dt;
        // record trail positions for ribbon/trail rendering (per-shot history)
        if (s.trail) {
          // keep newest at front
          s.trail.unshift({ x: s.x, y: s.y });
          const maxSteps = s.trailSteps || 12;
          if (s.trail.length > maxSteps) s.trail.length = maxSteps;
        }

        s.life -= dtMs;

        // Optional: screen clean-up
        if (s.x < -100 || s.x > DESIGN_W + 100 || s.y < -100 || s.y > DESIGN_H + 100) {
          s.life = 0;
        }
      }

      st.shots = st.shots.filter(s => s.life > 0 && (!s.hp || s.hp > 0));

      // Enemy shots
      for (const b of st.eShots) {
        // Homing logic for enemy shots: always track the leader
        {
          const Lp = leader();
          if (Lp) {
            const spd = b.speed || Math.hypot(b.vx || 0, b.vy || 0) || 420;
            const ang = Math.atan2(Lp.y - b.y, Lp.x - b.x);
            b.vx = (b.vx || 0) + Math.cos(ang) * spd * dt * 0.08;
            b.vy = (b.vy || 0) + Math.sin(ang) * spd * dt * 0.08;
            const curS = Math.hypot(b.vx, b.vy);
            if (curS > 0) {
              b.vx = (b.vx / curS) * spd;
              b.vy = (b.vy / curS) * spd;
            }
          }
        }
        if (b.gravity) {
          b.vy += 0.0018 * dtMs;
        }
        b.x += b.vx * dt;
        b.y += b.vy * dt;
        b.life -= dtMs;
      }
      st.eShots = st.eShots.filter(b => b.life > 0);

      // Collisions: player shots -> enemies
      for (const s of st.shots) {
        for (const e of st.enemies) {
          if (e.hp <= 0) continue;
          let hit = false;

          // Special collision for new A1 skills
          if (s.kind === 'a1_void_impale') {
            // Void Impale: rectangular hit area
            const dx = Math.abs(e.x - s.x);
            const dy = Math.abs(e.y - s.y);
            hit = dx < (s.w / 2) && dy < (s.h / 2);
          } else if (s.kind === 'astral_sever_h') {
            // Horizontal slash: full-width
            hit = Math.abs(e.y - s.y) < (s.h / 2);
          } else if (s.kind === 'astral_sever_v') {
            // Vertical slash: full-height
            hit = Math.abs(e.x - s.x) < (s.w / 2);
          } else {
            // Standard collision
            const dx = e.x - s.x;
            const dy = e.y - s.y;
            if (s.aoe) {
              hit = Math.hypot(dx, dy) < s.aoe;
            } else if (s.w || s.h) {
              const halfW = (s.w || 28) / 2;
              const halfH = (s.h || 28) / 2;
              hit = Math.abs(dx) < halfW && Math.abs(dy) < halfH;
            } else {
              hit = Math.hypot(dx, dy) < 28;
            }
          }

          if (hit) {
            const palette = resolveProjectilePalette(s);
            // ===== CHECK FOR ENEMY PARRY =====
            if (window.EnemyAbilities && window.EnemyAbilities.interceptProjectileHit) {
              const parried = window.EnemyAbilities.interceptProjectileHit(e, s, st);
              if (parried) {
                continue; // Parried - skip damage
              }
            }

            // ===== CHECK SPAWN SHIELD =====
            if (e.spawnShieldT && e.spawnShieldT > 0) {
              // Immune during spawn shield
              if (window.VFX && window.VFX.ImpactEffects) {
                window.VFX.ImpactEffects.flash(ctx, e.x, e.y, { color: palette.glow || '#4ecdc4', size: 30 });
              }
              continue; // Skip damage
            }

            // Track killer id for ally leveling
            e._lastHitBy = s.ownerId || e._lastHitBy;
            if (s.freeze) {
              e.vx *= 0.5; // Slow down enemy
            }
            let dmg = s.dmg;

            // ===== IMPACT EFFECTS =====
            // Add procedural impact effect
            if (window.VFX && window.VFX.ImpactEffects) {
              if (s.aoe && s.aoe > 50) {
                // Large AOE: shockwave
                window.VFX.ImpactEffects.shockwave(ctx, e.x, e.y, {
                  radius: s.aoe,
                  progress: 0.3,
                  color: palette.secondary || palette.accent || s.color || '#FFD93D'
                });
              } else {
                // Regular hit: flash
                window.VFX.ImpactEffects.flash(ctx, e.x, e.y, {
                  color: palette.accent || s.color || '#FFFFFF',
                  size: 30
                });
              }
            }

            // Add impact particles
            if (window.globalParticles && Math.random() < 0.5) {
              const emitter = window.globalParticles.createEmitter(e.x, e.y, {
                type: 'point',
                burst: 10,
                rate: 0,
                duration: 0.2,
                speed: { min: 30, max: 80 },
                size: { min: 2, max: 5 },
                life: { min: 200, max: 400 },
                colors: palette.particles?.length ? palette.particles : ['#FFFFFF'],
                spread: Math.PI * 2,
                endSize: 0
              });
              emitter.stop();
            }
            // Anime X impact effect (store as persistent effect for renderer)
            try {
              st.effects = st.effects || [];
              st.effects.push({ kind: 'x_impact', x: e.x, y: e.y, color: s.color || '#ff2d2d', life: 300, max: 300, r: (s.aoe || 32) * 1.5 });
            } catch (_e) { }
            // Trigger optional camera shake
            try { if (window.VFX && window.VFX.Camera && typeof window.VFX.Camera.shake === 'function') { window.VFX.Camera.shake(8, 220, 8); } } catch (_e) { }
            if (s.kind === 'a1_bomb') {
              // apply armor shred debuff
              e.armorShredDebuff = Math.max(e.armorShredDebuff || 0, s.armorShred || 0);
              setTimeout(() => { if (e.armorShredDebuff) e.armorShredDebuff -= (s.armorShred || 0); }, 6000);
            } else if (s.kind === 'a1_void_impale' && e.hp <= dmg && s.hpRecovery) {
              // Void Impale: HP recovery on kill
              const caster = st.players.find(p => p.id === s.ownerId);
              if (caster) {
                caster.hp = Math.min(caster.hpMax, caster.hp + s.hpRecovery);
                addFloater(caster.x, caster.y - 30, '+' + s.hpRecovery + ' HP', '#36c777');
              }
            }
            dmg = Math.max(1, (dmg || 0) - (e.def || 0));
            e.hp -= dmg;

            addFloater(e.x, e.y - 18, '-' + dmg, '#ff7a6a');

            // === X-WAVE PIERCE LOGIC ===
            // When an X-wave (or any AOE shot) hits, apply damage and support pierce
            if (s.kind === 'a1_xwave' || s.aoe) {
              // Simple pierce: allow N hits before despawn
              if (s.pierce == null) s.pierce = 0;
              if (s.pierce > 0) {
                s.pierce--;
              } else {
                s.life = 0;
              }
            }

            // Build rage for caster if available
            try { const caster = (st.players || []).find(p => p.id === s.ownerId); if (caster) gainRage(caster, Math.floor((dmg || 0) * 0.4)); } catch (_) { }

            const shotTags = toArray(s.tags).map(tag => String(tag).toLowerCase());
            if (shotTags.includes('bleed')) {
              const payload = { ...STATUS_DEFAULTS.bleed, ...extractStatusDataFromProjectile(s, 'bleed') };
              if (payload.stacks == null) {
                const stackSrc = s.bleedStacks ?? s.statusStacks?.bleed ?? s.stack ?? 1;
                const normalized = Number(stackSrc);
                payload.stacks = Number.isFinite(normalized) ? Math.max(1, normalized) : 1;
              }
              payload.sourceId = s.ownerId;
              applyStatus(e, 'bleed', payload);
            }
            if (shotTags.includes('paralyze')) {
              const payload = { ...STATUS_DEFAULTS.paralyze, ...extractStatusDataFromProjectile(s, 'paralyze') };
              if (payload.stacks == null) {
                const stackSrc = s.paralyzeStacks ?? s.statusStacks?.paralyze ?? 1;
                const normalized = Number(stackSrc);
                payload.stacks = Number.isFinite(normalized) ? Math.max(1, normalized) : 1;
              }
              if (payload.speedMult != null) {
                const normalized = Number(payload.speedMult);
                if (Number.isFinite(normalized)) {
                  payload.speedMult = Math.max(0, Math.min(1, normalized));
                }
              }
              payload.sourceId = s.ownerId;
              applyStatus(e, 'paralyze', payload);
            }
            if (shotTags.includes('freeze')) {
              const payload = { ...STATUS_DEFAULTS.freeze, ...extractStatusDataFromProjectile(s, 'freeze') };
              if (payload.stacks == null) {
                const stackSrc = s.freezeStacks ?? s.statusStacks?.freeze ?? 1;
                const normalized = Number(stackSrc);
                payload.stacks = Number.isFinite(normalized) ? Math.max(1, normalized) : 1;
              }
              if (payload.speedMult == null && typeof s.freeze === 'number') {
                payload.speedMult = Math.max(0, Math.min(1, s.freeze));
              }
              if (payload.speedMult != null) {
                const normalized = Number(payload.speedMult);
                if (Number.isFinite(normalized)) {
                  payload.speedMult = Math.max(0, Math.min(1, normalized));
                }
              }
              payload.sourceId = s.ownerId;
              applyStatus(e, 'freeze', payload);
            }
            if (shotTags.includes('gravity')) {
              const payload = { ...STATUS_DEFAULTS.gravity, ...extractStatusDataFromProjectile(s, 'gravity') };
              if (payload.force == null) {
                if (typeof s.gravityForce === 'number') payload.force = s.gravityForce;
                else if (typeof s.gravity === 'number') payload.force = s.gravity;
              }
              if (payload.force != null) {
                const normalizedForce = Number(payload.force);
                if (Number.isFinite(normalizedForce)) payload.force = normalizedForce;
              }
              if (payload.stacks == null) {
                const stackSrc = s.gravityStacks ?? s.statusStacks?.gravity ?? 1;
                const normalized = Number(stackSrc);
                payload.stacks = Number.isFinite(normalized) ? Math.max(1, normalized) : 1;
              }
              payload.sourceId = s.ownerId;
              applyStatus(e, 'gravity', payload);
            }
            if (shotTags.includes('pushback')) {
              const payload = { ...STATUS_DEFAULTS.pushback, ...extractStatusDataFromProjectile(s, 'pushback') };
              const vxSign = Math.sign(s.vx || 0) || Math.sign((e.x || 0) - (s.x || 0)) || 1;
              payload.direction = payload.direction ?? vxSign;
              if (payload.power == null && typeof s.pushbackPower === 'number') {
                payload.power = s.pushbackPower;
              }
              if (payload.power != null) {
                const normalizedPower = Number(payload.power);
                if (Number.isFinite(normalizedPower)) payload.power = normalizedPower;
              }
              if (payload.stacks == null) {
                const stackSrc = s.pushbackStacks ?? s.statusStacks?.pushback ?? 1;
                const normalized = Number(stackSrc);
                payload.stacks = Number.isFinite(normalized) ? Math.max(1, normalized) : 1;
              }
              payload.sourceId = s.ownerId;
              applyStatus(e, 'pushback', payload);
            }

            // Pushback for ranged attacks
            if (e.kind !== 'boss' && e.kind !== 'miniboss') {
              e.x += 3;
            }

            consumeProjectilePierce(s);
            if (e.hp <= 0) {
              onEnemyKilled(e);
            } else if (e.kind === 'boss' && !e._requestingTame && !e.isTamed) {
              // Check for taming opportunity
              checkBossTaming(e);
            }
          }
        }
      }

      // Enemy shots -> players (target leader mostly)
      for (const b of st.eShots) {
        for (const p of st.players) {
          if (p.isDefeated) continue;

          if (b.kind === 'damaging_treasure') {
            if (Math.abs(p.x - b.x) < 20 && Math.abs(p.y - b.y) < 30) {
              damagePlayer(p, b.dmg);
              b.life = 0;
              break;
            }
          } else {
            if (Math.abs(p.x - b.x) < 20 && Math.abs(p.y - b.y) < 30) {
              const dmg = (typeof b.dmg === 'number' && b.dmg > 0) ? b.dmg : 8;
              damagePlayer(p, dmg);
              b.life = 0;
              break;
            }
          }
        }
      }

      // Pickups (very simple)
      for (const it of st.pickups) {
        it.life -= dtMs;
      }
      st.pickups = st.pickups.filter(p => p.life > 0);

      // Effects
      for (const ef of st.effects) ef.life -= dtMs;
      st.effects = st.effects.filter(e => e.life > 0);

      // UPDATE PROJECTILES
      if (!st.projectiles) st.projectiles = [];
      for (let i = st.projectiles.length - 1; i >= 0; i--) {
        const proj = st.projectiles[i];
        if (proj.dead) {
          st.projectiles.splice(i, 1);
          continue;
        }
        if (proj.update) proj.update(dt);
      }

      // UPDATE SUMMONS (clones, drones, pets)
      if (!st.summons) st.summons = [];
      for (let i = st.summons.length - 1; i >= 0; i--) {
        const summon = st.summons[i];

        // Remove dead summons
        if (summon.dead || summon.hp <= 0) {
          st.summons.splice(i, 1);
          continue;
        }

        // Remove summons if owner is defeated
        if (summon.owner && (summon.owner.isDefeated || summon.owner.dead)) {
          st.summons.splice(i, 1);
          continue;
        }

        // Update summon AI
        if (summon.update) summon.update(dt);
      }

      // UPDATE FREEZE STATUS
      if (st.enemies) {
        st.enemies.forEach(enemy => {
          if (enemy.frozen && Date.now() > enemy.frozenUntil) {
            enemy.frozen = false;
            enemy.speed = enemy.originalSpeed || 2;
          }
        });
      }

      // UPDATE FLIGHT MODE (Missy S4)
      if (st.players) {
        st.players.forEach(player => {
          if (player.isFlying && Date.now() > player.flyUntil) {
            player.isFlying = false;
            player.hoverOffset = 0;
          }
        });
      }

      // Basic Attack
      for (const hero of st.players) {
        if (hero && hero._basicCD > 0) {
          hero._basicCD = Math.max(0, hero._basicCD - dtMs);
        }
      }
      basicAttackLoop();

      // Wave progression: if no enemies remain
      if (st.enemies.every(e => e.hp <= 0 || e.isAlly)) {
        // Update quest progress
        updateQuestProgress('stage', 0);

        // Use progression v9.5 state machine
        const P = window.__PROG95;
        if (P && !st.endlessMode) {
          P.advanceProgression();

          // Check for endless mode unlock
          if (st.area > 1 || st.area > 100) {
            if (typeof checkEndlessMode === 'function') {
              checkEndlessMode();
            }
          }
        } else if (!st.endlessMode) {
          // Fallback to old system if progression module not loaded
          st.wave++;
          if (st.wave > st.wavesPerStage) {
            st.stage++; st.wave = 1;
            // New random waves for special events in next stage
            st.waveLeaderWave = 2 + Math.floor(Math.random() * 8);
            st.treasureWave = 3 + Math.floor(Math.random() * 7);
            st.supplyPlaneWave = 2 + Math.floor(Math.random() * 8);
            st.revivalBossWave = 2 + Math.floor(Math.random() * 8);
            st.stageLongToyActive = false;
            st.stageStartTime = (performance.now?.() || Date.now());
            st.specialWave = false;
            updateQuestProgress('stage', 0);

            if (typeof checkTimeTrials === 'function') {
              checkTimeTrials();
            }

            if (st.area > 100 && typeof checkEndlessMode === 'function') {
              checkEndlessMode();
            }
          }
        }

        // Spawn next wave
        if (st.endlessMode) {
          spawnEndlessWave();
        } else {
          spawnWave();
        }
      }
      // Game Over check
      try {
        if (window.TransportSystem) {
          TransportSystem.update(dt);
        }
      } catch (_) { }
      checkGameOver();
      // Mirror leader hp for HUD
      mirrorLeaderHP();
    }

    /* ===================== Skill Button System ===================== */
    function drawPlayerSkillButtons() {
      // Draw skill buttons over non-leader players' heads
      for (let i = 0; i < st.players.length; i++) {
        const p = st.players[i];
        if (i === st.leader || p.isDefeated) continue; // Skip leader and defeated players

        // Draw skill buttons S1, S2, S3 above player head
        const skills = ['S1', 'S2', 'S3'];
        const buttonSize = 20;
        const spacing = 25;
        const startX = p.x - (skills.length - 1) * spacing / 2;
        const buttonY = p.y - 90;

        for (let j = 0; j < skills.length; j++) {
          const buttonX = startX + j * spacing;
          const skillKey = skills[j];

          // Check if skill is on cooldown
          const isOnCD = !cdReady(p.id, skillKey);

          // Draw button background
          ctx.fillStyle = isOnCD ? '#444444' : '#2a384f';
          ctx.fillRect(buttonX - buttonSize / 2, buttonY - buttonSize / 2, buttonSize, buttonSize);

          // Draw button border
          ctx.strokeStyle = '#6aa8ff';
          ctx.lineWidth = 1;
          ctx.strokeRect(buttonX - buttonSize / 2, buttonY - buttonSize / 2, buttonSize, buttonSize);

          // Draw skill text
          ctx.fillStyle = isOnCD ? '#888888' : '#ffffff';
          ctx.font = '10px Arial';
          ctx.textAlign = 'center';
          ctx.fillText(skillKey, buttonX, buttonY + 3);

          // Store button info for click detection
          if (!p._skillButtons) p._skillButtons = [];
          p._skillButtons[j] = {
            x: buttonX,
            y: buttonY,
            size: buttonSize,
            skill: skillKey,
            active: !isOnCD
          };
        }
      }
    }

    function drawPets() {
      if (!st.activePets) return;

      for (const pet of st.activePets) {
        // Draw pet body using sprite when available
        const imgPet = (window.petSprites && window.petSprites[pet.name]);
        const pw = 28, ph = 28;
        if (imgPet && imgPet.complete) {
          ctx.drawImage(imgPet, pet.x - pw / 2, pet.y - ph / 2, pw, ph);
        } else {
          // Enhanced pet body with HP-based color
          const hpPercent = pet.hp / pet.hpMax;
          if (hpPercent > 0.6) {
            ctx.fillStyle = '#c1ffc1'; // Green when healthy
          } else if (hpPercent > 0.3) {
            ctx.fillStyle = '#ffffc1'; // Yellow when damaged
          } else {
            ctx.fillStyle = '#ffc1c1'; // Red when low HP
          }
          ctx.fillRect(pet.x - 10, pet.y - 18, 20, 18);
        }

        // Draw pet HP bar
        const hpBarWidth = 24;
        const hpBarHeight = 3;
        const hpPercent = pet.hp / pet.hpMax;

        // HP bar background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.fillRect(pet.x - hpBarWidth / 2, pet.y - 25, hpBarWidth, hpBarHeight);

        // HP bar fill
        ctx.fillStyle = hpPercent > 0.5 ? '#4CAF50' : hpPercent > 0.25 ? '#FF9800' : '#F44336';
        ctx.fillRect(pet.x - hpBarWidth / 2, pet.y - 25, hpBarWidth * hpPercent, hpBarHeight);

        // Pet level indicator
        ctx.fillStyle = '#fff';
        ctx.font = '8px monospace';
        ctx.textAlign = 'center';
        ctx.fillText(`Lv${pet.level || 1}`, pet.x, pet.y + 15);

        // Draw simplified pet skill buttons
        const size = 16, by = pet.y - 38;
        const bx = [pet.x - 16, pet.x + 16];
        const labels = ['A', 'H']; // Attack Boost, Heal
        const skills = ['attack_boost', 'heal'];

        // draw + store
        if (!pet._skillButtons) pet._skillButtons = [];
        for (let i = 0; i < 2; i++) {
          const key = skills[i];
          const cdOK = !pet.skillCooldowns || (pet.skillCooldowns[key] || 0) <= 0;
          ctx.fillStyle = cdOK ? '#ffd56a' : '#777';
          ctx.beginPath(); ctx.arc(bx[i], by, size / 2, 0, Math.PI * 2); ctx.fill();
          ctx.fillStyle = '#000'; ctx.font = 'bold 9px monospace'; ctx.textAlign = 'center'; ctx.fillText(labels[i], bx[i], by + 3);
          pet._skillButtons[i] = { x: bx[i], y: by, size, skill: key, active: cdOK };
        }
      }
    }

    // Lightweight clone AI: periodic waves and simple melee
    function updateClones(dtMs) {
      if (!st.clones) return;
      const L = leader();
      for (const c of st.clones) {
        if (!c || c.isDefeated) continue;
        // timers
        if (c._autoNext == null) c._autoNext = 5000 + Math.floor(Math.random() * 5000);
        c._autoNext -= dtMs;
        if (c._meleeCD > 0) c._meleeCD -= dtMs;
        if (c._swordT > 0) c._swordT -= dtMs;

        // face nearest enemy
        const e = findNearestEnemyTo(c);
        if (e) { c.facingLeft = (e.x < c.x); }

        // Stance-based movement and support
        let targetX, targetY;
        switch (c.stance || 'assault') {
          case 'defend':
            targetX = L.x - 40; targetY = L.y;
            break;
          case 'support':
            targetX = L.x + 40; targetY = L.y;
            // periodic small aura ping
            c._supportAuraT = (c._supportAuraT || 0) - dtMs;
            if (c._supportAuraT <= 0) {
              try { st.effects.push({ kind: 'cast', x: c.x, y: c.y, color: '#a3ffcc', life: 500, max: 500 }); } catch (_e) { }
              c._supportAuraT = 5000;
            }
            break;
          case 'assault':
          default:
            targetX = (e ? e.x - 28 : (L.x + 30));
            targetY = (e ? e.y - 10 : (L.y - 10));
            break;
        }
        c.x += (targetX - c.x) * 0.18;
        c.y += (targetY - c.y) * 0.18;
        // Keep in bounds
        c.x = Math.max(40, Math.min((DESIGN_W || 1280) - 40, c.x));

        // periodic X-wave burst
        if (c._autoNext <= 0) {
          const waves = 2 + Math.floor(Math.random() * 2); // 2-3
          for (let i = 0; i < waves; i++) {
            const ang = (i - (waves - 1) / 2) * 0.10;
            spawnXWave(c, ang, 520, (c.dmg || 20) * 0.9, 8, 0.04, 1500, 22 * 1.6);
          }
          c._autoNext = 5000 + Math.floor(Math.random() * 5000);
          if (c.stance === 'defend') c._autoNext = Math.round(c._autoNext * 1.8);
          else if (c.stance === 'support') c._autoNext = Math.round(c._autoNext * 1.3);
        }

        // close combat attempt
        if (e) {
          const d = Math.hypot(e.x - c.x, e.y - c.y);
          if (d < 46 && c._meleeCD <= 0) {
            c._swordT = 220;
            melee(c, 34, 28, Math.round((c.dmg || 20) * 0.7));
            c._meleeCD = 900;
          }
        }
      }
    }

    function drawVehicles() {
      if (!st.vehicles) return;

      for (const vehicle of st.vehicles) {
        // Draw vehicle body
        ctx.fillStyle = '#e6e6fa';
        ctx.fillRect(vehicle.x - 30, vehicle.y - 20, 60, 40);

        // Draw vehicle border
        ctx.strokeStyle = '#9966cc';
        ctx.lineWidth = 2;
        ctx.strokeRect(vehicle.x - 30, vehicle.y - 20, 60, 40);

        // Draw boost effect if active
        if (vehicle._boost > 0) {
          ctx.fillStyle = '#ffaa00';
          ctx.globalAlpha = 0.5;
          ctx.fillRect(vehicle.x - 35, vehicle.y - 15, -20, 30); // Exhaust trail
          ctx.globalAlpha = 1;
        }

        // Draw seat buttons if available
        if (vehicle._seatButtons) {
          for (const btn of vehicle._seatButtons) {
            // Draw button background
            ctx.fillStyle = '#4a4a4a';
            ctx.fillRect(btn.x - btn.w / 2, btn.y - btn.h / 2, btn.w, btn.h);

            // Draw button border
            ctx.strokeStyle = '#6aa8ff';
            ctx.lineWidth = 2;
            ctx.strokeRect(btn.x - btn.w / 2, btn.y - btn.h / 2, btn.w, btn.h);

            // Draw seat number
            ctx.fillStyle = '#ffffff';
            ctx.font = '14px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(btn.text, btn.x, btn.y + 4);
          }
        }

        // Draw passenger indicators
        if (vehicle.riders) {
          for (let i = 0; i < vehicle.riders.length; i++) {
            const rider = vehicle.riders[i];
            const passenger = st.players.find(p => p.id === rider.playerId);
            if (passenger) {
              // Draw small indicator above vehicle for each passenger
              ctx.fillStyle = passenger.id === 'A1' ? '#ff4d4f' : (passenger.id === 'Unique' ? '#6aa8ff' : '#ff8c6a');
              ctx.fillRect(vehicle.x - 20 + i * 15, vehicle.y - 35, 10, 8);

              // Draw role text
              ctx.fillStyle = '#ffffff';
              ctx.font = '8px Arial';
              ctx.textAlign = 'center';
              ctx.fillText(rider.role.substring(0, 1).toUpperCase(), vehicle.x - 15 + i * 15, vehicle.y - 26);
            }
          }
        }
      }
    }

    /* ===================== Drawing ===================== */
    function draw() {
      ctx.clearRect(0, 0, DESIGN_W, DESIGN_H);
      // Interior scene override
      try {
        if (window.HouseInterior && HouseInterior.active) {
          HouseInterior.draw(ctx);
          return;
        }
      } catch (_) { }

      // ===== PROCEDURAL BACKGROUND RENDERING =====
      // Render dynamic sky system
      if (window.dynamicSky) {
        window.dynamicSky.render(ctx);
        // Render ground layer
        const groundY = DESIGN_H - 160;
        window.dynamicSky.renderGround(ctx, groundY);
      } else {
        // Fallback: simple gradient background
        const gradient = ctx.createLinearGradient(0, 0, 0, DESIGN_H);
        gradient.addColorStop(0, '#0f1826');
        gradient.addColorStop(1, '#14243a');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, DESIGN_W, DESIGN_H);
      }
      // Platforms (draw behind characters)
      try { if (window.Platform && Platform.layers) { Platform.draw(ctx); } } catch (e) { }
      // Screen shake wrapper for world content
      ctx.save();
      let cameraX = st.camX || 0;
      try {
        const L = (st.players || [])[st.leader || 0] || st.players?.[0] || null;
        if (L) {
          const targetCam = L.x - DESIGN_W * 0.35;
          cameraX = st.camX == null ? targetCam : (st.camX * 0.9 + targetCam * 0.1);
          const maxCam = (WORLD_WIDTH || DESIGN_W) - DESIGN_W;
          cameraX = Math.max(0, Math.min(maxCam, cameraX || 0));
          st.camX = cameraX;
        }
      } catch (_e) { }
      try {
        if (window.TransportSystem) {
          TransportSystem.draw(ctx, cameraX || 0);
        }
      } catch (_e) { }
      try {
        ctx.translate(-(cameraX || 0), 0);
      } catch (_e) { }
      // Zone labels
      try { if (typeof drawZoneLabels === 'function') { drawZoneLabels(ctx, cameraX || 0); } } catch (_e) { }
      if (st._screenShake && st._screenShake.t > 0) {
        const m = st._screenShake.mag || 6; const dx = (Math.random() * 2 - 1) * m, dy = (Math.random() * 2 - 1) * m;
        ctx.translate(dx, dy); st._screenShake.t -= 16; if (st._screenShake.t <= 0) st._screenShake = null;
      }
      // Players
      for (const p of st.players) {
        if (p.isDefeated) {
          ctx.save();
          ctx.globalAlpha = 0.6;
          ctx.fillStyle = '#555555';
          ctx.fillRect(p.x - 18, p.y - 44, 36, 60);
          ctx.restore();
          continue;
        }
        if (st.shieldOn) {
          ctx.save();
          ctx.globalAlpha = 0.3 + Math.sin(performance.now() * 0.01) * 0.1;
          ctx.fillStyle = '#6aa8ff';
          ctx.beginPath();
          ctx.arc(p.x, p.y - 22, 40, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }
        // ===== PROCEDURAL CHARACTER RENDERING =====
        // Use procedural character renderer
        if (window.CharacterRenderers && window.CharacterRenderers[p.id]) {
          const renderer = window.CharacterRenderers[p.id];
          const animState = Math.abs(p.vx) > 0.05 ? 'run' : 'idle';
          renderer.render(ctx, p.x, p.y, {
            facingLeft: p.facingLeft,
            isDefeated: false,
            animState: animState,
            animTime: performance.now()
          });
        } else {
          // Fallback: colored rectangle
          ctx.save();
          if (p.facingLeft) {
            ctx.scale(-1, 1);
            ctx.translate(-p.x * 2, 0);
          }
          ctx.fillStyle = p.id === 'A1' ? '#ff4d4f' : (p.id === 'Unique' ? '#6aa8ff' : '#ff8c6a');
          ctx.fillRect(p.x - 18, p.y - 44, 36, 60);
          ctx.restore();
        }

        // Draw facing indicator (arrow/triangle)
        ctx.save();
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        if (p.facingLeft) {
          ctx.moveTo(p.x - 15, p.y - 25);
          ctx.lineTo(p.x - 5, p.y - 20);
          ctx.lineTo(p.x - 5, p.y - 30);
        } else {
          ctx.moveTo(p.x + 15, p.y - 25);
          ctx.lineTo(p.x + 5, p.y - 20);
          ctx.lineTo(p.x + 5, p.y - 30);
        }
        ctx.closePath();
        ctx.fill();
        ctx.restore();
        // Overhead HP bar (personal)
        const ratio = p.hp / p.hpMax;
        ctx.fillStyle = '#1e2e34'; ctx.fillRect(p.x - 24, p.y - 56, 48, 4);
        ctx.fillStyle = '#36c777'; ctx.fillRect(p.x - 24, p.y - 56, 48 * ratio, 4);
        // Rage bar
        const rRatio = p.rage / p.rageMax;
        ctx.fillStyle = '#2d2208'; ctx.fillRect(p.x - 24, p.y - 62, 48, 3);
        ctx.fillStyle = '#f9cc2b'; ctx.fillRect(p.x - 24, p.y - 62, 48 * rRatio, 3);
        // Secret gauge bar
        const sRatio = p.secretGauge / p.secretMax;
        ctx.fillStyle = '#2d1a2d'; ctx.fillRect(p.x - 24, p.y - 68, 48, 3);
        ctx.fillStyle = '#ff6aa8'; ctx.fillRect(p.x - 24, p.y - 68, 48 * sRatio, 3);
        // Rage trail aura
        if (p.id === 'A1' && (p.rageOn || p._rageTrailT > 0)) {
          const t = p.rageOn ? 1 : Math.max(0, p._rageTrailT / 1000);
          ctx.globalAlpha = 0.15 + 0.15 * Math.sin(st.time * 8);
          ctx.fillStyle = '#ff4d4f';
          ctx.beginPath(); ctx.arc(p.x, p.y - 24, 42, 0, Math.PI * 2); ctx.fill();
          ctx.globalAlpha = 1;
        }

        // WEAPONS REMOVED - KEEPING ONLY EFFECTS
      }

      if (window.CharacterRenderers?.Robox && Array.isArray(st.aiCompanions) && st.aiCompanions.length) {
        for (const bot of st.aiCompanions) {
          if (!bot || bot.alive === false) continue;
          try {
            window.CharacterRenderers.Robox.render(ctx, bot.x, bot.y, {
              facingLeft: bot.facingLeft,
              animState: bot.animState,
              animTime: bot.animTime
            });
            const hpPct = Math.max(0, Math.min(1, (bot.hp || 0) / (bot.hpMax || 1)));
            ctx.fillStyle = 'rgba(12,18,28,0.7)';
            ctx.fillRect(bot.x - 18, bot.y - 54, 36, 4);
            ctx.fillStyle = '#24f3ff';
            ctx.fillRect(bot.x - 18, bot.y - 54, 36 * hpPct, 4);
          } catch (err) {
            console.error('[Robox] render failed', err);
          }
        }
      }

      // Draw skill buttons over non-leader players' heads
      drawPlayerSkillButtons();
      // Missy Stock Counter
      try {
        const missy = (st.players || []).find(pp => pp.id === 'Missy');
        if (missy && !missy.isDefeated && (_MissyRT?.stock || 0) > 0) {
          ctx.fillStyle = '#ffc107'; ctx.font = '900 14px ui-sans-serif'; ctx.textAlign = 'center';
          ctx.fillText(String(_MissyRT.stock), missy.x, missy.y - 60);
        }
      } catch (_) { }

      // Draw pets
      drawPets();
      // Draw gates (wave/exit) as simple doors
      try {
        for (const gk of (st.pickups || [])) {
          if (gk.kind === 'wave_gate' || gk.kind === 'exit_gate') {
            ctx.save();
            ctx.fillStyle = gk.kind === 'wave_gate' ? '#36c777' : '#ffd56a';
            const w = gk.w || 60, h = gk.h || 90;
            ctx.fillRect((gk.x || 0) - w / 2, (gk.y || 0) - h, w, h);
            ctx.fillStyle = '#0f1826';
            ctx.fillRect((gk.x || 0) - 10, (gk.y || 0) - 30, 20, 30); // doorway
            ctx.restore();
          }
        }
      } catch (_e) { }
      // Draw A1 clones (purple with HP and level)
      try {
        const clones = st.clones || [];
        for (const c of clones) {
          ctx.save(); ctx.fillStyle = 'rgba(154,107,255,.95)'; ctx.fillRect((c.x || 0) - 10, (c.y || 0) - 18, 20, 18);
          // HP bar
          if (c.hpMax) { ctx.fillStyle = '#15243a'; ctx.fillRect((c.x || 0) - 16, (c.y || 0) - 24, 32, 4); ctx.fillStyle = '#9a6bff'; ctx.fillRect((c.x || 0) - 16, (c.y || 0) - 24, 32 * Math.max(0, (c.hp || 0) / (c.hpMax || 1)), 4); }
          // Level label
          ctx.fillStyle = '#b9e7ff'; ctx.font = '600 10px ui-monospace'; ctx.textAlign = 'center'; ctx.fillText('Lv' + (c.level || 1), (c.x || 0), (c.y || 0) - 28);
          // Clone weapons removed - keeping effects only
          ctx.restore();

          // Overhead clone skill buttons 1/2/3 (S1/S3/S5)
          try {
            ensureCooldownRow('clone');
            const size = 14, by = (c.y || 0) - 38, bx = [(c.x || 0) - 22, (c.x || 0), (c.x || 0) + 22];
            const keys = ['S1', 'S3', 'S5']; const labels = ['1', '2', '3'];
            const now = performance.now?.() || Date.now();
            c._skillButtons = c._skillButtons || [];
            for (let i = 0; i < 3; i++) {
              const k = keys[i];
              const ready = cdReady('clone', k);
              ctx.fillStyle = ready ? '#a6ffcf' : '#777';
              ctx.beginPath(); ctx.arc(bx[i], by, size / 2, 0, Math.PI * 2); ctx.fill();
              ctx.fillStyle = '#102a3a'; ctx.font = 'bold 9px monospace'; ctx.textAlign = 'center'; ctx.fillText(labels[i], bx[i], by + 3);
              c._skillButtons[i] = { x: bx[i], y: by, size, skill: k, active: ready };
            }
          } catch (_e) { }
        }
      } catch (_) { }

      // Draw vehicles
      drawVehicles();

      // House door proximity prompt (world-space, respects camera)
      try {
        const L = leader();
        const H = (window.Platform && Platform.layers && Platform.layers.houses) ? Platform.layers.houses : [];
        let nearDoorInfo = null;
        for (let i = 0; i < H.length; i++) {
          const h = H[i]; const d = h && h.door ? h.door : null; if (!d) continue;
          const dx = (L.x - d.x), dy = ((L.y - 20) - d.y);
          if (Math.hypot(dx, dy) <= (d.r || 42)) {
            nearDoorInfo = {
              house: h,
              door: d,
              id: h.id,
              label: h.label || h.type || 'House',
              action: null
            };
            if (h.id === 'missy_house') {
              nearDoorInfo.label = 'Missy House';
              nearDoorInfo.action = () => {
                try {
                  window.A1KShared && A1KShared.push(A1KShared.fromRunner());
                } catch (_) { }
                if (typeof notify === 'function') {
                  try { notify('Entering Missy House...', '#FF69B4'); } catch (_) { }
                }
                setTimeout(() => {
                  try {
                    location.href = 'Missy Arcade.html#from=runner';
                  } catch (_e) {
                    location.href = 'Missy Arcade.html';
                  }
                }, 150);
              };
            }
            break;
          }
        }
        window.__houseNearDoor = nearDoorInfo;
        if (nearDoorInfo?.door) {
          const d = nearDoorInfo.door;
          const bx = d.x, by = d.y - 40;
          ctx.save();
          ctx.font = 'bold 12px ui-monospace';
          const prompt = nearDoorInfo.label ? `Press A: ${nearDoorInfo.label}` : 'Press A to Enter';
          const promptWidth = ctx.measureText(prompt).width + 20;
          const boxWidth = Math.max(140, promptWidth);
          ctx.fillStyle = 'rgba(11,18,32,0.85)'; ctx.strokeStyle = '#9a6bff'; ctx.lineWidth = 2;
          ctx.fillRect(bx - boxWidth / 2, by - 16, boxWidth, 22); ctx.strokeRect(bx - boxWidth / 2, by - 16, boxWidth, 22);
          ctx.fillStyle = '#cde7ff'; ctx.textAlign = 'center';
          ctx.fillText(prompt, bx, by);
          ctx.restore();
        }
      } catch (_e) { }

      // NPC Platform Decorations (draw before NPCs)
      try { if (typeof drawNPCDecorations === 'function') { drawNPCDecorations(ctx); } } catch (e) { }

      // World NPCs (draw after players but before enemies)
      try { if (typeof drawWorldNPCs === 'function') { drawWorldNPCs(ctx); } } catch (e) { }

      // Enemy - Use Advanced Enemy Rendering System
      if (typeof window.drawAdvancedEnemies === 'function') {
        window.drawAdvancedEnemies(ctx);
      } else {
        // Fallback to old enemy drawing if ADV renderer not loaded
        for (const e of st.enemies) {
          if (e.hp <= 0) continue;

          // Procedural drawing for all enemies
          let w, h;
          switch (e.kind) {
            case 'mob': ctx.fillStyle = '#ff6e6e'; w = 32; h = 32; break;
            case 'flyer': ctx.fillStyle = '#ffb18b'; w = 32; h = 32; break;
            case 'waveleader': ctx.fillStyle = '#ffbb9a'; w = 48; h = 48; break;
            case 'miniboss': ctx.fillStyle = '#ff8c6a'; w = 64; h = 64; break;
            case 'treasureboss': ctx.fillStyle = '#ffd56a'; w = 64; h = 64; break;
            case 'plane': ctx.fillStyle = '#e6e6fa'; w = 128; h = 64; break;
            case 'chest_pf': ctx.fillStyle = '#8b7355'; w = 48; h = 32; break;
            case 'revivalboss':
              const p = leader();
              ctx.fillStyle = p.id === 'A1' ? 'rgba(255,77,79,0.7)' : (p.id === 'Unique' ? 'rgba(106,168,255,0.7)' : 'rgba(255,140,106,0.7)');
              w = 64; h = 64;
              break;
            case 'boss':
              if (e.name === 'Grime') { ctx.fillStyle = '#a9a9a9'; w = 80; h = 80; }
              else if (e.name === 'Slime King') { ctx.fillStyle = '#32cd32'; w = 80; h = 80; }
              else if (e.name === 'Giga Slug') { ctx.fillStyle = '#daa520'; w = 80; h = 80; }
              else if (e.name === 'War Wyrm') { ctx.fillStyle = '#dc143c'; w = 80; h = 80; }
              else if (e.name === 'Twin Colossus') { ctx.fillStyle = '#4682b4'; w = 80; h = 80; }
              else if (e.name === 'Iron Hydra') { ctx.fillStyle = '#708090'; w = 80; h = 80; }
              else if (e.name === 'Cyber Demon') { ctx.fillStyle = '#9400d3'; w = 80; h = 80; }
              else if (e.name === 'Void Reaver') { ctx.fillStyle = '#4b0082'; w = 80; h = 80; }
              else if (e.name === 'Celestial Dragon') { ctx.fillStyle = '#00ffff'; w = 80; h = 80; }
              else if (e.name === 'Apex Hunter') { ctx.fillStyle = '#ff4500'; w = 80; h = 80; }
              else { ctx.fillStyle = '#ff4d4f'; w = 80; h = 80; }
              break;
            default: ctx.fillStyle = '#ff6e6e'; w = 40; h = 60; break;
          }
          ctx.fillRect(e.x - w / 2, e.y - h / 2, w, h);

          // HP bars
          const ratio = e.hp / e.max;
          if (e.kind === 'chest_pf') {
            // Big chest bar
            ctx.fillStyle = '#0b0e14'; ctx.fillRect(e.x - 60, e.y - 50, 120, 8);
            ctx.fillStyle = '#ffd56a'; ctx.fillRect(e.x - 60, e.y - 50, 120 * ratio, 8);
            ctx.strokeStyle = '#6a552e'; ctx.strokeRect(e.x - 60.5, e.y - 50.5, 121, 9);
          } else {
            ctx.fillStyle = '#1a1a1a'; ctx.fillRect(e.x - 20, e.y - 42, 40, 4);
            ctx.fillStyle = '#ff4d4f'; ctx.fillRect(e.x - 20, e.y - 42, 40 * ratio, 4);
          }

          // Spawn shield ring
          if (e.spawnShieldT > 0) {
            const pulse = 0.5 + 0.5 * Math.sin(st.time * 10);
            ctx.globalAlpha = 0.5 + 0.5 * pulse;
            ctx.strokeStyle = '#6aa8ff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.arc(e.x, e.y - 6, 30, 0, Math.PI * 2);
            ctx.stroke();
            ctx.globalAlpha = 1;
          }
        }
      }

      // Render tamed boss companions
      if (st.tamedBosses) {
        st.tamedBosses.forEach(companion => {
          if (companion.hp <= 0) return;

          ctx.save();
          if (companion.facingLeft) {
            ctx.scale(-1, 1);
            ctx.translate(-companion.x * 2, 0);
          }

          // Draw companion (golden tint to show they're tamed)
          ctx.globalAlpha = 0.9;
          ctx.fillStyle = '#ffd56a';
          ctx.fillRect(companion.x - 20, companion.y - 40, 40, 60);

          // HP bar
          const hpRatio = companion.hp / companion.hpMax;
          ctx.fillStyle = '#2a1420';
          ctx.fillRect(companion.x - 25, companion.y - 50, 50, 6);
          ctx.fillStyle = hpRatio > 0.5 ? '#36c777' : hpRatio > 0.25 ? '#ffd56a' : '#ff6aa8';
          ctx.fillRect(companion.x - 25, companion.y - 50, 50 * hpRatio, 6);

          // Name tag
          ctx.fillStyle = '#ffd56a';
          ctx.font = '10px monospace';
          ctx.textAlign = 'center';
          ctx.fillText(companion.name || 'Companion', companion.x, companion.y - 55);

          ctx.restore();
        });
      }

      // ===== PROCEDURAL PROJECTILE RENDERING =====
      for (const s of st.shots) {
        const palette = resolveProjectilePalette(s);
        const allyColor = s.color || palette.primary || '#9ad1ff';
        const enemyColor = s.color || palette.secondary || '#ffb18b';
        const accentColor = palette.accent || allyColor;

        // Use procedural VFX rendering for different projectile types
        if (window.VFX && window.VFX.ProjectileRenderers) {
          const VFXRenderers = window.VFX.ProjectileRenderers;

          // Add fallback for missing functions
          if (!VFXRenderers.energyWave) VFXRenderers.energyWave = () => { };
          if (!VFXRenderers.explosionBurst) VFXRenderers.explosionBurst = () => { };
          if (!VFXRenderers.megaExplosion) VFXRenderers.megaExplosion = () => { };

          // Render based on projectile kind
          if (s.kind === 'a1_xwave') {
            VFXRenderers.energyWave(ctx, s.x, s.y, {
              size: s.r || 16,
              color: accentColor,
              angle: Math.atan2(s.vy || 0, s.vx || 1)
            });
            continue;
          } else if (s.kind === 'a1_energy_burst') {
            const progress = 1 - (s.life / 60);
            VFXRenderers.explosionBurst(ctx, s.x, s.y, {
              radius: s.aoe || 90,
              progress: progress,
              color: accentColor
            });
            continue;
          } else if (s.kind === 'a1_mega_explosion') {
            const progress = 1 - (s.life / 100);
            VFXRenderers.megaExplosion(ctx, s.x, s.y, {
              radius: s.aoe || 150,
              progress: progress,
              color: allyColor
            });
            continue;
          }
        }

        // Continue with original rendering for other types
        ctx.fillStyle = allyColor;
        if (s.kind === 'wave') {
          ctx.fillStyle = allyColor;
          const w = s.w || 18;
          const h = s.h || 6;
          // ENHANCED: 6x larger bullets when uniqueBullet flag is set
          const multiplier = s.uniqueBullet ? 6 : 1;
          ctx.fillRect(s.x - (w * multiplier) / 2, s.y - (h * multiplier) / 2, w * multiplier, h * multiplier);
        } else if (s.kind === 'a1_xwave') {
          // use the anime slash renderer (ribbon trails, core/rim, bloom)
          try { drawAnimeX(ctx, s); } catch (e) { /* fallback to simple draw on error */
            const len = Math.max(20, ((s.r || s.aoe || 32)) * 3.25);
            ctx.save(); ctx.strokeStyle = s.color2 || '#000000'; ctx.lineWidth = 7; ctx.globalAlpha = 0.95;
            ctx.beginPath(); ctx.moveTo(s.x - len * 0.5, s.y - len * 0.5); ctx.lineTo(s.x + len * 0.5, s.y + len * 0.5); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(s.x - len * 0.5, s.y + len * 0.5); ctx.lineTo(s.x + len * 0.5, s.y - len * 0.5); ctx.stroke();
            ctx.strokeStyle = s.color || '#ff0000'; ctx.lineWidth = 4;
            ctx.beginPath(); ctx.moveTo(s.x - len * 0.5, s.y - len * 0.5); ctx.lineTo(s.x + len * 0.5, s.y + len * 0.5); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(s.x - len * 0.5, s.y + len * 0.5); ctx.lineTo(s.x + len * 0.5, s.y - len * 0.5); ctx.stroke();
            ctx.restore();
          }
        } else if (s.kind === 'a1_bomb') {
          ctx.fillStyle = accentColor;
          const radius = s.uniqueBullet ? 72 : 12; // 6x larger when flagged
          ctx.beginPath(); ctx.arc(s.x, s.y, radius, 0, Math.PI * 2); ctx.fill();
        } else if (s.kind === 'astral_sever_h' || s.kind === 'astral_sever_v') {
          ctx.fillStyle = allyColor;
          ctx.globalAlpha = 0.7;
          ctx.fillRect(s.x - s.w / 2, s.y - s.h / 2, s.w, s.h);
          ctx.globalAlpha = 1;
        } else if (s.kind === 'reflected_bullet') {
          // Reflected bullets are already 7x larger from parry system
          ctx.fillStyle = accentColor;
          ctx.beginPath();
          ctx.arc(s.x, s.y, (s.w || 35) / 2, 0, Math.PI * 2);
          ctx.fill();
        } else if (s.kind === 'unique_stellar_beam') {
          // Beam rectangle visualization
          ctx.globalAlpha = 0.85;
          ctx.fillStyle = allyColor;
          const th = s.h || 70; const w = s.w || 920;
          ctx.fillRect(s.x, (s.y || 0) - th / 2, w, th);
          ctx.globalAlpha = 1;
        } else {
          // Standard bullets: draw sprite based on owner (player or enemy)
          const isAlly = (s.owner === 'ally' || s.ownerId === 'Pet');
          const img = isAlly ? window.projPlayerImg : window.projEnemyImg;
          const w = (s.w || 8) * (s.uniqueBullet ? 6 : 1);
          const h = (s.h || 6) * (s.uniqueBullet ? 6 : 1);
          if (img && img.complete) {
            ctx.save();
            if (s.uniqueBullet) {
              ctx.shadowColor = s.color || (isAlly ? allyColor : enemyColor);
              ctx.shadowBlur = 15;
            }
            ctx.drawImage(img, s.x - w / 2, s.y - h / 2, w, h);
            ctx.shadowBlur = 0;
            ctx.restore();
          } else {
            // Fallback: draw colored primitive when sprite is not loaded
            ctx.fillStyle = s.color || (isAlly ? allyColor : enemyColor);
            if (s.uniqueBullet) {
              ctx.beginPath();
              ctx.arc(s.x, s.y, w / 2, 0, Math.PI * 2);
              ctx.fill();
            } else {
              ctx.fillRect(s.x - w / 2, s.y - h / 2, w, h);
            }
          }
        }
      }
      ctx.fillStyle = '#ffb18b';
      for (const b of st.eShots) {
        if (b.kind === 'damaging_treasure') {
          ctx.fillStyle = b.color || '#ffd56a';
          ctx.fillRect(b.x - 12, b.y - 10, 24, 20);
        } else {
          // Standard enemy bullets: draw sprite when available
          const img = window.projEnemyImg;
          const w = 6 * (b.uniqueBullet ? 4 : 1);
          const h = 6 * (b.uniqueBullet ? 4 : 1);
          if (img && img.complete) {
            ctx.drawImage(img, b.x - w / 2, b.y - h / 2, w, h);
          } else {
            ctx.fillStyle = b.color || '#ffb18b';
            ctx.fillRect(b.x - 3, b.y - 2, 6, 4);
          }
        }
      }
      // Interactive objects (pickups, chests, etc.)
      ctx.fillStyle = '#6aa8ff';
      for (const pickup of st.pickups) {
        if (pickup.kind === 'chest') {
          // Draw chest using sprite
          const img = window.chestImg;
          const w = 24, h = 24;
          if (img && img.complete) {
            ctx.drawImage(img, pickup.x - w / 2, pickup.y - h + 4, w, h);
          } else {
            ctx.fillStyle = pickup.chestType === 'treasure' ? '#ffd56a' : '#8b7355';
            ctx.fillRect(pickup.x - 12, pickup.y - 20, 24, 20);
            ctx.fillStyle = '#ffaa00';
            ctx.fillRect(pickup.x - 8, pickup.y - 18, 16, 4);
          }
        } else if (pickup.kind === 'switch') {
          ctx.fillStyle = pickup.activated ? '#36c777' : '#ff6aa8';
          ctx.fillRect(pickup.x - 8, pickup.y - 16, 16, 16);
          ctx.fillStyle = '#fff';
          ctx.fillRect(pickup.x - 4, pickup.y - 12, 8, 8);
        } else if (pickup.kind === 'ladder') {
          ctx.fillStyle = '#8b7355';
          ctx.fillRect(pickup.x - 4, pickup.y - 40, 8, 80);
          ctx.fillRect(pickup.x - 12, pickup.y - 30, 24, 4);
          ctx.fillRect(pickup.x - 12, pickup.y - 10, 24, 4);
          ctx.fillRect(pickup.x - 12, pickup.y + 10, 24, 4);
        } else if (pickup.kind === 'exit_gate') {
          ctx.fillStyle = pickup.opened ? '#36c777' : '#ff4d4f';
          ctx.fillRect(pickup.x, pickup.y, pickup.w, pickup.h);
          ctx.strokeStyle = '#fff';
          ctx.strokeRect(pickup.x, pickup.y, pickup.w, pickup.h);
        } else if (pickup.kind === 'pickup') {
          ctx.fillStyle = '#ffd56a'; // Gold color for pickups
          ctx.beginPath();
          ctx.arc(pickup.x, pickup.y, 8, 0, Math.PI * 2);
          ctx.fill();
          ctx.fillStyle = '#fff';
          ctx.textAlign = 'center';
          ctx.font = 'bold 10px sans-serif';
          ctx.fillText('!', pickup.x, pickup.y + 4);
        } else {
          // Generic pickup
          ctx.fillStyle = '#6aa8ff';
          ctx.fillRect(pickup.x - 6, pickup.y - 6, 12, 12);
        }
      }

      // Vehicle selection buttons
      if (st.vehicles) {
        for (const vehicle of st.vehicles) {
          if (vehicle._selectionButtons) {
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'center';
            for (const btn of vehicle._selectionButtons) {
              ctx.fillStyle = 'rgba(0,0,0,0.7)';
              ctx.fillRect(btn.x - btn.w / 2, btn.y - btn.h / 2, btn.w, btn.h);
              ctx.fillStyle = '#fff';
              ctx.fillText(btn.text, btn.x, btn.y + 4);
            }
          }
        }
      }
      // ===== PROCEDURAL EFFECTS RENDERING =====
      // Render global particles
      if (window.globalParticles) {
        window.globalParticles.render(ctx);
      }

      // Render spell glyphs
      if (window.spellGlyphs) {
        window.spellGlyphs.renderAll(ctx);
      }

      // Render charge feedback
      if (window.chargeManager) {
        window.chargeManager.render(ctx);

        // Render jump charge feedback if active
        const L = leader();
        if (window.chargeManager.isJumpCharging() && L) {
          window.chargeManager.renderJumpFeedback(ctx, L);
        }
      }

      if (window.skillIntegration) {
        try {
          window.skillIntegration.renderWorld(ctx, cameraX || 0);
        } catch (_err) {
          if (!window.__skillRenderError) {
            console.error('Skill integration render failed:', _err);
            window.__skillRenderError = true;
          }
        }
      }

      ctx.font = '12px sans-serif';
      ctx.textAlign = 'center';
      for (const ef of st.effects) {
        ctx.globalAlpha = Math.max(0, ef.life / (ef.max || 800));
        ctx.fillStyle = ef.color || '#fff';
        if (ef.kind === 'cast') {
          ctx.strokeStyle = ef.color || '#6aa8ff';
          ctx.lineWidth = 2;
          ctx.beginPath(); ctx.arc(ef.x, ef.y, 12 + (1 - (ef.life / (ef.max || 320))) * 20, 0, Math.PI * 2); ctx.stroke();
        } else if (ef.kind === 'impact') {
          ctx.strokeStyle = ef.color || '#ff7a6a';
          ctx.lineWidth = 2;
          ctx.beginPath(); ctx.arc(ef.x, ef.y, 8 + (1 - (ef.life / (ef.max || 260))) * 10, 0, Math.PI * 2); ctx.stroke();
        } else if (ef.kind === 'x_impact') {
          // Anime slash impact shock ring with bloom
          const p = 1 - (ef.life / (ef.max || 300));
          ctx.save();
          ctx.globalCompositeOperation = 'lighter';
          ctx.globalAlpha = Math.max(0, 0.95 - p * 0.95);
          // outer ring
          ctx.strokeStyle = ef.color || '#ff2d2d';
          ctx.lineWidth = 6 + p * 18;
          ctx.beginPath(); ctx.arc(ef.x, ef.y, (ef.r || 40) * (0.6 + p * 1.2), 0, Math.PI * 2); ctx.stroke();
          // inner flash
          ctx.globalAlpha = Math.max(0, 0.7 - p * 0.7);
          ctx.fillStyle = '#ffffff';
          ctx.beginPath(); ctx.arc(ef.x, ef.y, Math.max(4, (ef.r || 40) * (0.15 + p * 0.4)), 0, Math.PI * 2); ctx.fill();
          ctx.restore();
        } else if (ef.kind === 'after') {
          ctx.fillStyle = ef.color || '#ff4d4f';
          ctx.beginPath(); ctx.arc(ef.x, ef.y, 10, 0, Math.PI * 2); ctx.fill();
        } else if (ef.kind === 'beam') {
          const p = 1 - (ef.life / (ef.max || 120));
          ctx.globalAlpha = Math.max(0, 0.85 - p * 0.85);
          ctx.strokeStyle = ef.color || '#6aa8ff';
          ctx.lineWidth = ef.thick || 3;
          ctx.beginPath(); ctx.moveTo(ef.x1, ef.y1); ctx.lineTo(ef.x2, ef.y2); ctx.stroke();
          ctx.globalAlpha = 1;
        } else if (ef.kind === 'slash_arc') {
          // Sword slash arc - crescent shape
          const p = 1 - (ef.life / (ef.max || 320));
          const radius = ef.radius || 48;
          const angle = ef.angle || 0;
          const dir = ef.direction || 1;

          ctx.save();
          ctx.globalAlpha = Math.max(0, 0.9 - p * 0.9);
          ctx.translate(ef.x, ef.y);

          // Draw arc trail with glow
          ctx.shadowBlur = 15;
          ctx.shadowColor = ef.color || '#ffd56a';
          ctx.strokeStyle = ef.color || '#ffd56a';
          ctx.lineWidth = 6 - (p * 3); // Fade out thickness
          ctx.lineCap = 'round';

          // Arc path - crescent swing
          ctx.beginPath();
          const startAngle = angle - (Math.PI / 4);
          const endAngle = angle + (Math.PI / 4);
          ctx.arc(0, 0, radius, startAngle, endAngle);
          ctx.stroke();

          // Inner glow arc
          ctx.globalAlpha = Math.max(0, 0.6 - p * 0.6);
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 3 - (p * 2);
          ctx.beginPath();
          ctx.arc(0, 0, radius * 0.85, startAngle, endAngle);
          ctx.stroke();

          ctx.restore();
          ctx.globalAlpha = 1;
        } else if (ef.kind === 'luna_arc') {
          // Luna/Arc moon slash waves - crescent moon shape
          const p = 1 - (ef.life / (ef.max || 400));
          const radius = ef.radius || 120;
          const angle = ef.angle || 0;
          const dir = ef.direction || 1;

          ctx.save();
          ctx.globalAlpha = Math.max(0, 0.8 - p * 0.8);
          ctx.translate(ef.x, ef.y);
          ctx.scale(dir, 1); // Flip based on direction

          // Draw crescent moon arc with glow
          ctx.shadowBlur = 20;
          ctx.shadowColor = ef.color || '#ff4d4f';
          ctx.strokeStyle = ef.color || '#ff4d4f';
          ctx.lineWidth = 8 - (p * 4); // Fade out thickness
          ctx.lineCap = 'round';

          // Crescent moon arc - wider than slash_arc
          ctx.beginPath();
          const startAngle = angle - (Math.PI / 3); // Wider arc
          const endAngle = angle + (Math.PI / 3);
          ctx.arc(0, 0, radius, startAngle, endAngle);
          ctx.stroke();

          // Inner bright core
          ctx.globalAlpha = Math.max(0, 0.7 - p * 0.7);
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 4 - (p * 2);
          ctx.beginPath();
          ctx.arc(0, 0, radius * 0.9, startAngle, endAngle);
          ctx.stroke();

          // Outer glow ring
          ctx.globalAlpha = Math.max(0, 0.4 - p * 0.4);
          ctx.strokeStyle = ef.color || '#ff4d4f';
          ctx.lineWidth = 12 - (p * 6);
          ctx.beginPath();
          ctx.arc(0, 0, radius * 1.1, startAngle, endAngle);
          ctx.stroke();

          ctx.restore();
          ctx.globalAlpha = 1;
        } else if (ef.kind === 'rage_aura') {
          // Rage aura around character
          const p = 1 - (ef.life / (ef.max || 800));
          const radius = ef.radius || 60;

          ctx.save();
          ctx.globalAlpha = Math.max(0, 0.6 - p * 0.6);
          ctx.translate(ef.x, ef.y);

          // Outer red glow
          ctx.shadowBlur = 25;
          ctx.shadowColor = ef.color || '#ff4444';
          ctx.strokeStyle = ef.color || '#ff4444';
          ctx.lineWidth = 6 - (p * 3);
          ctx.beginPath();
          ctx.arc(0, 0, radius, 0, Math.PI * 2);
          ctx.stroke();

          // Inner bright core
          ctx.globalAlpha = Math.max(0, 0.8 - p * 0.8);
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 3 - (p * 2);
          ctx.beginPath();
          ctx.arc(0, 0, radius * 0.8, 0, Math.PI * 2);
          ctx.stroke();

          ctx.restore();
          ctx.globalAlpha = 1;
        } else if (ef.kind === 'dual_charge_aura' || ef.kind === 'rage_stack_aura') {
          // Dual charge aura (skill + rage charging) or rage stack gain
          const p = 1 - (ef.life / (ef.max || 2000));
          const radius = ef.radius || 80;

          ctx.save();
          ctx.globalAlpha = Math.max(0, 0.7 - p * 0.7);

          // Update position to follow player
          if (ef.owner) {
            ef.x = ef.owner.x;
            ef.y = ef.owner.y;
          }

          // Create pulsing dual-colored aura
          const time = Date.now();
          const pulse = Math.sin(time * 0.005) * 10 + radius;

          // Outer ring (character/skill color)
          ctx.strokeStyle = ef.color || '#ff4d4f';
          ctx.lineWidth = 6;
          ctx.shadowBlur = 30;
          ctx.shadowColor = ef.color || '#ff4d4f';
          ctx.beginPath();
          ctx.arc(ef.x, ef.y, pulse, 0, Math.PI * 2);
          ctx.stroke();

          // Inner ring (rage red)
          ctx.strokeStyle = '#ff4444';
          ctx.lineWidth = 4;
          ctx.shadowBlur = 25;
          ctx.shadowColor = '#ff4444';
          ctx.beginPath();
          ctx.arc(ef.x, ef.y, pulse * 0.7, 0, Math.PI * 2);
          ctx.stroke();

          // Sparks between rings
          ctx.globalAlpha = Math.max(0, 0.9 - p * 0.9);
          for (let i = 0; i < 8; i++) {
            const angle = (i / 8) * Math.PI * 2 + (time * 0.001);
            const sparkX = ef.x + Math.cos(angle) * pulse * 0.85;
            const sparkY = ef.y + Math.sin(angle) * pulse * 0.85;

            ctx.fillStyle = '#ffffff';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ffffff';
            ctx.beginPath();
            ctx.arc(sparkX, sparkY, 2, 0, Math.PI * 2);
            ctx.fill();
          }

          ctx.restore();
          ctx.globalAlpha = 1;
        } else if (ef.kind === 'fire_particle') {
          // Fire particles for rage effects
          const p = 1 - (ef.life / (ef.max || 400));
          const size = 3 - (p * 2);

          ctx.save();
          ctx.globalAlpha = Math.max(0, 0.8 - p * 0.8);
          ctx.fillStyle = ef.color || '#ff6b6b';
          ctx.shadowBlur = 8;
          ctx.shadowColor = ef.color || '#ff6b6b';
          ctx.beginPath();
          ctx.arc(ef.x, ef.y, size, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
          ctx.globalAlpha = 1;
        } else if (ef.kind === 'screen_shockwave') {
          // Screen-wide red shockwave
          const p = 1 - (ef.life / (ef.max || 600));
          const radius = ef.radius || 400;

          ctx.save();
          ctx.globalAlpha = Math.max(0, 0.4 - p * 0.4);
          ctx.strokeStyle = ef.color || '#ff4444';
          ctx.lineWidth = 8 - (p * 4);
          ctx.shadowBlur = 30;
          ctx.shadowColor = ef.color || '#ff4444';
          ctx.beginPath();
          ctx.arc(ef.x, ef.y, radius, 0, Math.PI * 2);
          ctx.stroke();
          ctx.restore();
          ctx.globalAlpha = 1;
        } else if (ef.kind === 'lightning_bolt') {
          // Red lightning bolts for rage effects
          const p = 1 - (ef.life / (ef.max || 200));

          ctx.save();
          ctx.globalAlpha = Math.max(0, 0.9 - p * 0.9);
          ctx.strokeStyle = ef.color || '#ff4444';
          ctx.lineWidth = 4 - (p * 2);
          ctx.shadowBlur = 15;
          ctx.shadowColor = ef.color || '#ff4444';
          ctx.beginPath();
          ctx.moveTo(ef.x, ef.y);
          ctx.lineTo(ef.targetX, ef.targetY);
          ctx.stroke();
          ctx.restore();
          ctx.globalAlpha = 1;
        } else if (ef.kind === 'screen_flash') {
          // Screen flash effect
          const p = 1 - (ef.life / (ef.max || 300));

          ctx.save();
          ctx.globalAlpha = Math.max(0, 0.3 - p * 0.3);
          ctx.fillStyle = ef.color || '#ff4444';
          ctx.fillRect(0, 0, canvas.width, canvas.height);
          ctx.restore();
          ctx.globalAlpha = 1;
        } else if (ef.kind === 'sword_trail') {
          const duration = 300;
          const p = 1 - (ef.life / (ef.max || duration));
          const fade = 1 - p;
          const base = ef.color || '#ff6b35';
          const dir = (ef.direction === 'left') ? -1 : 1;
          const px = (ef.x || 0) + (ef.vx || 0) * p;
          const py = (ef.y || 0) + (ef.vy || 0) * p;

          ctx.save();
          ctx.translate(px, py);
          ctx.scale(dir, 1);

          const radius = 80 + 20 * (1 - p); // Extended from 46 to 80+ pixels
          const sweep = Math.PI * 1.2 * (1 - 0.1 * p); // Extended sweep angle
          const start = -sweep * 0.55;
          const end = sweep * 0.45;

          // outer glow stroke - ENHANCED VISIBILITY
          ctx.globalAlpha = Math.min(0.95, 0.7 + 0.3 * fade);
          ctx.lineCap = 'round';
          ctx.lineWidth = 16 * (0.8 + 0.2 * fade); // Increased from 10 to 16
          ctx.shadowBlur = 35; // Increased from 22 to 35
          ctx.shadowColor = base;
          ctx.strokeStyle = base;
          ctx.beginPath();
          ctx.arc(0, 0, radius, start, end, false);
          ctx.stroke();

          // inner bright edge - ENHANCED VISIBILITY
          ctx.shadowBlur = 0;
          ctx.globalAlpha = 0.8 * fade; // Increased from 0.6 to 0.8
          ctx.lineWidth = 7; // Increased from 4.5 to 7
          ctx.strokeStyle = '#ffffff';
          ctx.beginPath();
          ctx.arc(0, 0, radius - 3, start, end, false);
          ctx.stroke();

          // faint trail fill wedge
          ctx.globalAlpha = 0.18 * fade;
          ctx.fillStyle = base;
          ctx.beginPath();
          ctx.moveTo(0, 0);
          ctx.arc(0, 0, radius + 6, start, end, false);
          ctx.closePath();
          ctx.fill();

          ctx.restore();
        } else if (ef.kind === 'shadow_materialize') {
          const duration = 600;
          const p = 1 - (ef.life / (ef.max || duration));
          const fade = 1 - p;
          const base = ef.color || '#121212';
          const core = '#FF3B3B';
          const px = (ef.x || 0) + (ef.vx || 0) * p;
          const py = (ef.y || 0) + (ef.vy || 0) * p - 18 * p;
          const TAU = Math.PI * 2;

          ctx.save();

          // dark mist halo
          ctx.globalAlpha = 0.22 * fade;
          ctx.shadowBlur = 26;
          ctx.shadowColor = core;
          const mg = ctx.createRadialGradient(px, py, 0, px, py, 44);
          mg.addColorStop(0, 'rgba(255,59,59,0.35)');
          mg.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = mg;
          ctx.beginPath();
          ctx.arc(px, py, 44, 0, TAU);
          ctx.fill();

          // rotating shadow squares with red cores
          const N = 9;
          for (let i = 0; i < N; i++) {
            const t = i / N;
            const ang = t * TAU - p * TAU * 0.9;
            const dist = 10 + 42 * p;
            const sx = px + Math.cos(ang) * dist;
            const sy = py + Math.sin(ang) * dist;

            ctx.save();
            ctx.translate(sx, sy);
            ctx.rotate(ang + p * 1.8);
            ctx.globalAlpha = (0.8 - 0.45 * t) * fade;

            // shadow square
            const s = 8 + 4 * (1 - p);
            ctx.shadowBlur = 12;
            ctx.shadowColor = core;
            ctx.fillStyle = base;
            ctx.strokeStyle = '#1d1d1d';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.rect(-s / 2, -s / 2, s, s);
            ctx.fill();
            ctx.stroke();

            // red core (glowing dot)
            ctx.shadowBlur = 16;
            ctx.shadowColor = core;
            ctx.fillStyle = core;
            ctx.globalAlpha *= 0.95;
            ctx.beginPath();
            ctx.arc(0, 0, 2.1, 0, TAU);
            ctx.fill();

            ctx.restore();
          }

          ctx.restore();
        } else if (ef.kind === 'tech_materialize') {
          const duration = 500;
          const p = 1 - (ef.life / (ef.max || duration));
          const fade = 1 - p;
          const base = ef.color || '#00E5FF';
          const px = (ef.x || 0) + (ef.vx || 0) * p;
          const py = (ef.y || 0) + (ef.vy || 0) * p - 24 * p;
          const TAU = Math.PI * 2;

          ctx.save();
          // central pulse
          ctx.globalAlpha = 0.35 * fade;
          ctx.shadowBlur = 20;
          ctx.shadowColor = base;
          const r = 10 + 18 * p;
          const rg = ctx.createRadialGradient(px, py, 0, px, py, r);
          rg.addColorStop(0, base);
          rg.addColorStop(1, 'rgba(0,0,0,0)');
          ctx.fillStyle = rg;
          ctx.beginPath();
          ctx.arc(px, py, r, 0, TAU);
          ctx.fill();

          // particles (squares & hexagons)
          const N = 10;
          for (let i = 0; i < N; i++) {
            const t = i / N;
            const ang = t * TAU + p * TAU * 1.5;
            const dist = 8 + 40 * p;
            const tx = px + Math.cos(ang) * dist;
            const ty = py + Math.sin(ang) * dist - 8 * (1 - p);

            ctx.save();
            ctx.translate(tx, ty);
            ctx.rotate(ang + p * 2.0);
            ctx.globalAlpha = (0.65 - 0.25 * t) * fade;
            ctx.shadowBlur = 14;
            ctx.shadowColor = base;
            ctx.strokeStyle = base;
            ctx.fillStyle = 'rgba(255,255,255,0.15)';

            if (i % 2 === 0) {
              // rotated square
              const s = 6 + 4 * (1 - p);
              ctx.lineWidth = 1.5;
              ctx.beginPath();
              ctx.rect(-s / 2, -s / 2, s, s);
              ctx.stroke();
              ctx.fill();
            } else {
              // hexagon
              const hr = 5 + 3 * (1 - p);
              ctx.lineWidth = 1.5;
              ctx.beginPath();
              for (let k = 0; k < 6; k++) {
                const a = k * TAU / 6;
                const x = Math.cos(a) * hr;
                const y = Math.sin(a) * hr;
                if (k === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
              }
              ctx.closePath();
              ctx.stroke();
              ctx.fill();
            }

            ctx.restore();
          }

          ctx.restore();
        } else if (ef.kind === 'tech_ring') {
          const duration = 520;
          const p = 1 - (ef.life / (ef.max || duration));
          const fade = 1 - p;
          const base = ef.color || '#00E5FF';
          const maxRadius = ef.maxRadius || 90;
          const radius = Math.max(2, maxRadius * p);
          const px = (ef.x || 0) + (ef.vx || 0) * p;
          const py = (ef.y || 0) + (ef.vy || 0) * p;
          const TAU = Math.PI * 2;

          ctx.save();

          // main expanding ring (dashed, glowy)
          ctx.globalAlpha = 0.85 * fade;
          ctx.lineWidth = 2.5;
          ctx.setLineDash([6, 6]);
          ctx.strokeStyle = base;
          ctx.shadowBlur = 18;
          ctx.shadowColor = base;
          ctx.beginPath();
          ctx.arc(px, py, radius, 0, TAU);
          ctx.stroke();
          ctx.setLineDash([]);

          // 12 tech dots orbiting
          ctx.shadowBlur = 10;
          for (let i = 0; i < 12; i++) {
            const ang = (i / 12) * TAU + p * TAU * 0.75;
            const dx = px + Math.cos(ang) * radius;
            const dy = py + Math.sin(ang) * radius;
            ctx.globalAlpha = 0.8 * fade;
            ctx.fillStyle = base;
            ctx.beginPath();
            ctx.arc(dx, dy, 3.2, 0, TAU);
            ctx.fill();
            // tiny inner pixel for crispness
            ctx.globalAlpha = 0.9 * fade;
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(dx - 0.8, dy - 0.8, 1.6, 1.6);
          }

          // circuit spokes/patterns
          ctx.globalAlpha = 0.45 * fade;
          ctx.lineWidth = 1.25;
          ctx.shadowBlur = 6;
          for (let j = 0; j < 6; j++) {
            const a = (j / 6) * TAU + p * 0.6;
            const r1 = radius * 0.65;
            const r2 = radius * 1.15;
            const x1 = px + Math.cos(a) * r1;
            const y1 = py + Math.sin(a) * r1;
            const x2 = px + Math.cos(a) * r2;
            const y2 = py + Math.sin(a) * r2;

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.strokeStyle = base;
            ctx.stroke();

            // small perpendicular tick
            const na = a + Math.PI / 2;
            const tx = x2 + Math.cos(na) * 6;
            const ty = y2 + Math.sin(na) * 6;
            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(tx, ty);
            ctx.stroke();
          }

          ctx.restore();
        } else if (ef.kind === 'nature_summon') {
          const duration = 700;
          const p = 1 - (ef.life / (ef.max || duration));
          const fade = 1 - p;
          const base = ef.color || '#FFD56A';
          const px = (ef.x || 0) + (ef.vx || 0) * p;
          const py = (ef.y || 0) + (ef.vy || 0) * p - 28 * p;
          const TAU = Math.PI * 2;

          ctx.save();

          // soft center aura
          ctx.globalAlpha = 0.28 * fade;
          ctx.shadowBlur = 24;
          ctx.shadowColor = base;
          const rg = ctx.createRadialGradient(px, py, 0, px, py, 36 + 28 * p);
          rg.addColorStop(0, 'rgba(255,213,106,0.8)');
          rg.addColorStop(1, 'rgba(255,213,106,0)');
          ctx.fillStyle = rg;
          ctx.beginPath();
          ctx.arc(px, py, 36 + 28 * p, 0, TAU);
          ctx.fill();

          // spiraling leaves/petals
          const N = 12;
          for (let i = 0; i < N; i++) {
            const t = i / N;
            const ang = t * TAU + p * TAU * 1.2;
            const rad = 12 + 64 * p * (0.7 + 0.3 * t);
            const lx = px + Math.cos(ang) * rad;
            const ly = py + Math.sin(ang) * rad - (18 * p);

            ctx.save();
            ctx.translate(lx, ly);
            ctx.rotate(ang + p * 2.2);
            ctx.globalAlpha = (0.9 - 0.5 * t) * fade;
            ctx.shadowBlur = 12;
            ctx.shadowColor = base;
            ctx.fillStyle = base;
            ctx.strokeStyle = '#fff9e6';
            ctx.lineWidth = 0.9;

            // leaf shape (two quadratic lobes)
            const w = 5 + 3 * (1 - p);
            const h = 10 + 6 * (1 - p);
            ctx.beginPath();
            ctx.moveTo(0, 0);
            ctx.quadraticCurveTo(-w, -h * 0.5, 0, -h);
            ctx.quadraticCurveTo(w, -h * 0.5, 0, 0);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();

            ctx.restore();
          }

          ctx.restore();
        } else if (ef.kind === 'aura_burst') {
          const duration = 560;
          const p = 1 - (ef.life / (ef.max || duration));
          const fade = (1 - p) * 0.85;
          const base = ef.color || '#FFD56A';
          const px = (ef.x || 0) + (ef.vx || 0) * p;
          const py = (ef.y || 0) + (ef.vy || 0) * p;
          const TAU = Math.PI * 2;

          ctx.save();

          // expanding gradient disc
          const R = 20 + 80 * p;
          const g = ctx.createRadialGradient(px, py, 0, px, py, R);
          g.addColorStop(0, 'rgba(255,213,106,0.85)');
          g.addColorStop(0.55, 'rgba(255,213,106,0.35)');
          g.addColorStop(1, 'rgba(255,213,106,0)');
          ctx.globalAlpha = fade;
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.arc(px, py, R, 0, TAU);
          ctx.fill();

          // rim highlight
          ctx.globalAlpha = 0.65 * fade;
          ctx.lineWidth = 2.4;
          ctx.strokeStyle = base;
          ctx.shadowBlur = 18;
          ctx.shadowColor = base;
          ctx.beginPath();
          ctx.arc(px, py, R * 0.92, 0, TAU);
          ctx.stroke();

          // sparkles radiating outward
          const S = 18;
          for (let i = 0; i < S; i++) {
            const a = (i / S) * TAU + p * 0.8;
            const len = 10 + 52 * p;
            const x1 = px + Math.cos(a) * (R * 0.25);
            const y1 = py + Math.sin(a) * (R * 0.25);
            const x2 = px + Math.cos(a) * (R * 0.25 + len);
            const y2 = py + Math.sin(a) * (R * 0.25 + len);

            ctx.globalAlpha = (0.85 - 0.45 * p) * 0.85;
            ctx.lineWidth = 1.6;
            ctx.strokeStyle = base;
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();

            // sparkle tip
            ctx.globalAlpha = 0.9 * (1 - p);
            ctx.fillStyle = '#ffffff';
            ctx.beginPath();
            ctx.arc(x2, y2, 1.6 + 1.0 * (1 - p), 0, TAU);
            ctx.fill();
          }

          ctx.restore();
        } else if (ef.kind === 'charge') {
          const o = ef.owner; if (o) {
            const prog = Math.min(1, (ef.t || 0) / (ef.max || 1)); const rad = 12 + 36 * prog;
            ctx.save(); ctx.globalAlpha = 0.85; ctx.strokeStyle = ef.color || '#9fe8ff'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.arc(o.x, o.y - 20, rad, 0, Math.PI * 2); ctx.stroke(); ctx.restore();
            ef.t = (ef.t || 0) + 16;
          }
        } else if (ef.kind === 'aura') {
          const p = ef.owner || ef; const pct = 1 - (ef.life / (ef.max || ef.life || 1));
          ctx.save(); ctx.globalAlpha = 0.35; ctx.fillStyle = ef.color || 'rgba(255,255,255,0.2)';
          ctx.beginPath(); ctx.arc(p.x, p.y - 20, (ef.r || 80) * Math.max(0.1, pct), 0, Math.PI * 2); ctx.fill(); ctx.restore();
        } else if (ef.kind === 'pull_field') {
          ctx.save(); ctx.strokeStyle = 'rgba(255, 212, 110, 0.5)'; ctx.lineWidth = 3;
          const pct = 1 - (ef.life / 600); ctx.beginPath(); ctx.arc(ef.x, ef.y, (ef.r || 1200) * Math.max(0, pct), 0, Math.PI * 2); ctx.stroke(); ctx.restore();
        } else if (ef.txt) {
          // --- Start of New Code ---
          // These new lines draw the outline first
          ctx.strokeStyle = '#1a1a1a'; // A dark, clean outline color
          ctx.lineWidth = 3;            // How thick the outline is
          ctx.strokeText(ef.txt, ef.x, ef.y);
          // --- End of New Code ---

          // This original line draws the colored text on top of the outline
          ctx.fillText(ef.txt, ef.x, ef.y);
        }
        ctx.globalAlpha = 1;
      }

      // ===== NEW PROJECTILE SYSTEM RENDERING =====
      if (st.projectiles && st.projectiles.length > 0) {
        st.projectiles.forEach(proj => {
          if (proj.render && !proj.dead) {
            ctx.save();
            proj.render(ctx);
            ctx.restore();
          }
        });
      }

      // ===== ENHANCED SUMMON RENDERING (clones, drones, pets) =====
      const SUMMON_DRAW_ELEMENTS = { clone: 'water', drone: 'lightning', pet: 'light' };
      if (Array.isArray(st.summons)) {
        const nowT = performance.now?.() || Date.now();
        for (const summon of st.summons) {
          if (!summon || summon.dead) continue;
          if (window.CombatFX) {
            window.CombatFX.attachProceduralSprite(summon, { element: SUMMON_DRAW_ELEMENTS[summon.type] || 'light' });
          }
          const sprite = summon.sprite?.image;
          const sizeMultiplier = summon.size || 1.0; // Apply size scaling

          if (!sprite) {
            const time = performance.now();
            const bounceOffset = Math.sin(time * 0.006 + ((summon.id || 0) * 0.7)) * 2;
            const s = { ...summon, y: (summon.y || 0) + bounceOffset };

            ctx.save();

            // Check if pet has emoji sprite override (🐅 tiger)
            if (s.type === 'pet' && typeof s.sprite === 'string') {
              // Render emoji sprite for pets (tiger)
              ctx.font = `${Math.floor(32 * sizeMultiplier)}px Arial`;
              ctx.textAlign = 'center';
              ctx.textBaseline = 'middle';
              ctx.fillText(s.sprite, s.x || 0, s.y || 0);
            } else {
              // Route to sprite renderers by type with size scaling
              let rendered = false;
              if (s.type === 'clone') {
                rendered = !!window.SummonSprites?.renderShadowClone?.(ctx, s, time, sizeMultiplier);
              } else if (s.type === 'drone') {
                rendered = !!window.SummonSprites?.renderRobotDrone?.(ctx, s, time, sizeMultiplier);
              } else if (s.type === 'pet') {
                rendered = !!window.SummonSprites?.renderTigerPet?.(ctx, s, time, sizeMultiplier);
              }

              if (!rendered) {
                // Fallback: simple circle with size scaling
                ctx.globalAlpha = 0.95;
                ctx.shadowBlur = 8 * sizeMultiplier;
                ctx.shadowColor = s.color || '#9aa0a6';
                ctx.fillStyle = s.color || '#9aa0a6';
                ctx.beginPath();
                ctx.arc((s.x || 0), (s.y || 0), 12 * sizeMultiplier, 0, Math.PI * 2);
                ctx.fill();
              }
            }

            ctx.restore();
          } else {
            const frameW = (summon.sprite.frameWidth || sprite.width) * sizeMultiplier;
            const frameH = (summon.sprite.frameHeight || sprite.height) * sizeMultiplier;
            const bounce = Math.sin((nowT / 180) + (summon.id ? summon.id.length : 0)) * 4;
            const drawX = (summon.x || 0) - frameW / 2;
            const drawY = (summon.y || 0) - frameH + bounce;
            ctx.save();
            if (summon.sprite.facingLeft) {
              ctx.translate(drawX + frameW, drawY);
              ctx.scale(-1, 1);
              ctx.drawImage(sprite, 0, 0, frameW / sizeMultiplier, frameH / sizeMultiplier, 0, 0, frameW, frameH);
            } else {
              ctx.drawImage(sprite, 0, 0, frameW / sizeMultiplier, frameH / sizeMultiplier, drawX, drawY, frameW, frameH);
            }
            ctx.restore();
          }

          // HP bar
          const hpPct = summon.hp / summon.hpMax;
          ctx.fillStyle = "rgba(0,0,0,0.6)";
          ctx.fillRect(summon.x - 18, summon.y - 30, 36, 5);
          ctx.fillStyle = hpPct > 0.5 ? "#0f0" : hpPct > 0.25 ? "#ff0" : "#f00";
          ctx.fillRect(summon.x - 18, summon.y - 30, 36 * hpPct, 5);

          // Level badge
          ctx.font = "bold 10px Arial";
          ctx.textAlign = "center";
          ctx.fillStyle = "#fff";
          ctx.strokeStyle = "#000";
          ctx.lineWidth = 3;
          ctx.strokeText("Lv" + summon.level, summon.x, summon.y - 35);
          ctx.fillText("Lv" + summon.level, summon.x, summon.y - 35);
        }
      }

      // Breakable Treasure Chests
      try {
        ctx.fillStyle = '#a5784b'; ctx.strokeStyle = '#d2ab72';
        for (const b of (st.breakables || [])) {
          if ((b.life || 0) <= 0 || (b.hp || 0) <= 0) continue;
          const w = b.w || 48, h = b.h || 48;
          const img = window.chestImg;
          if (img && img.complete) {
            ctx.drawImage(img, (b.x || 0) - w / 2, (b.y || 0) - h / 2, w, h);
            ctx.strokeRect((b.x || 0) - w / 2, (b.y || 0) - h / 2, w, h);
          } else {
            ctx.fillStyle = '#a5784b';
            ctx.fillRect((b.x || 0) - w / 2, (b.y || 0) - h / 2, w, h);
            ctx.strokeStyle = '#d2ab72';
            ctx.strokeRect((b.x || 0) - w / 2, (b.y || 0) - h / 2, w, h);
          }
          const ratio = Math.max(0, (b.hp || 0) / Math.max(1, (b.hpMax || 1)));
          ctx.fillStyle = '#1a1a1a'; ctx.fillRect((b.x || 0) - 20, (b.y || 0) - 30, 40, 4);
          ctx.fillStyle = '#ffd56a'; ctx.fillRect((b.x || 0) - 20, (b.y || 0) - 30, 40 * ratio, 4);
        }
      } catch {
        // Draw "Get Ready!" text
        ctx.strokeText('Get Ready!', centerX, centerY - 40);
        ctx.fillText('Get Ready!', centerX, centerY - 40);

        // Draw countdown number
        ctx.font = '64px Arial';
        ctx.fillStyle = '#ffaa00';
        ctx.strokeText(st._countdownTime.toString(), centerX, centerY + 20);
        ctx.fillText(st._countdownTime.toString(), centerX, centerY + 20);

        ctx.restore();
      }

      // End screen-shake wrapper for world content
      ctx.restore();

      // HUD updates
      updateTeamStatusUI();
      updateSecretGaugeUI();
      updateCompactHUD();
      document.getElementById('hpFill').style.transform = 'scaleX(' + (st.hp / st.hpMax) + ')';
      document.getElementById('mpFill').style.transform = 'scaleX(' + ((st.mp || 100) / (st.mpMax || 100)) + ')';
      document.getElementById('bossFill').style.transform = 'scaleX(' + (st.bossAlive ? (st.bossHP / st.bossMax) : 0) + ')';
      const xpNext = xpToNext(st.level);
      document.getElementById('xpDomFill').style.transform = 'scaleX(' + Math.min(1, st.xp / xpNext) + ')';
      document.getElementById('xpDomLabel').textContent = `${Math.floor(st.xp)}/${xpNext} XP — Lv ${st.level}`;
      // Use progression v9.5 labels
      const P = window.__PROG95;
      if (P && st.endlessMode !== true) {
        const stageText = `${P.areaLabel()} • ${P.stageLabel()} • Wave ${P.waveLabel()}/9.5 • Kills ${st.kills}`;
        document.getElementById('stagePill').textContent = stageText;
      } else if (st.endlessMode) {
        const stageText = `ENDLESS ${st.stage} • Wave ${st.wave} • Kills ${st.kills}`;
        document.getElementById('stagePill').textContent = stageText;
      } else {
        const stageText = `Stage ${st.stage} • Wave ${st.wave}/${st.wavesPerStage} • Kills ${st.kills}`;
        document.getElementById('stagePill').textContent = stageText;
      }
      document.getElementById('boostPill').textContent = `Lv ${st.level} • Booster: -`;
    }

    /* ================== Main Loop ================== */
    let last = performance.now();
    function loop(t) {
      const dt = (t - last) / 1000; last = t;
      if (st.running) {
        st.time += dt * st.speed; st.dt = dt * st.speed;
        if (!st.started) {
          st.started = true;
          st.stageStartTime = (performance.now?.() || Date.now());
          spawnWave();
        }
        update(st.dt);
      }
      draw();
      requestAnimationFrame(loop);
    }
    requestAnimationFrame(loop);

    /* ================== Damage Mirror & Simple Systems ================== */
    st.mp = 100; st.mpMax = 100; st.mpRegen = 8;
    function mpTick(dt) { st.mp = Math.min(st.mpMax, st.mp + st.mpRegen * dt); }

    /* ================ Damage Intakes replaced with per-player ================ */
    /* Already integrated through damagePlayer in collisions */

    /* ================= Key Systems End ================= */

    /* Initial build */
    tallyTalentStats();
    updateCurrencies();
    renderTalentLanes(); // pre-render lanes
    initializeDailyQuests(); // Initialize quest system

    /* ================ Auto Settings Panel ================= */
    document.getElementById('setting-auto-ai').addEventListener('change', e => {
      st.auto = e.target.checked;
      // Update the auto label: show "Auto: ON" when auto is enabled and "Auto: OFF" when disabled
      $('#btnAuto').textContent = 'Auto: ' + (st.auto ? 'ON' : 'OFF');
    });
    document.getElementById('setting-parallax').addEventListener('change', e => {
      st.useParallax = e.target.checked;
    });

    function applyTheme(mode) {
      try {
        if (window.Theme && window.Theme.set) {
          window.Theme.set(mode);
          const msg = mode === 'candy' ? 'Candy Mode enabled!' : 'Story Mode restored.';
          const notifyFn = window.notify;
          if (typeof notifyFn === 'function') {
            notifyFn(msg, mode === 'candy' ? '#FFB5E8' : '#6aa8ff');
          }
        }
      } catch (_) { }
    }

    document.getElementById('btnThemeCandy')?.addEventListener('click', () => applyTheme('candy'));
    document.getElementById('btnThemeStory')?.addEventListener('click', () => applyTheme('default'));

    // Wire settings button to open Apex QA panel
    document.getElementById('btnOpenQA')?.addEventListener('click', () => { try { window.toggleApexQA && window.toggleApexQA(); } catch (_) { } });

    /* ================ Public API (dev) ================= */
    window.game = {
      st,
      addGold(n) { st.gold += n; updateCurrencies(); },
      addItem(i) { addItemToBag(i); }
    };

    /* ================ Character Switching & Secret Skill from HUD ================= */
    function setupHeroPortraitClickHandlers() {
      st.players.forEach((p, index) => {
        const portrait = document.getElementById('hero' + p.id);
        if (!portrait) return;

        portrait.style.cursor = 'pointer';
        portrait.onclick = () => {
          const player = st.players[index];
          if (player.isDefeated) {
            notify(player.id + " is defeated.", "#ff7a6a");
            return;
          }

          // Priority: Use Secret Skill if available
          if (player.secretGauge >= player.secretMax) {
            useSkillWrapper(player, 'X1');
            notify(player.id + " uses Secret Skill!", "#ffaa00");
          } else {
            // Otherwise, switch leader
            st.leader = index;
            notify("Control switched to " + player.id, "#6aa8ff");
          }
          updateTeamStatusUI(); // Refresh UI to show new leader/state
        };
      });
    }

    /* Initial build */
    tallyTalentStats();
    updateCurrencies();
    renderTalentLanes(); // pre-render lanes
    initializeDailyQuests(); // Initialize quest system
    setupHeroPortraitClickHandlers(); // Wire up the hero portraits

    /* ================ Manual Character Switching ================= */
    function switchNextPlayer() {
      if (st._noSwitchUntil && performance.now() < st._noSwitchUntil) { notify("Can't switch during channel", "#ffd56a"); return; }
      if (st.players.every(p => p.isDefeated)) return; // No one to switch to

      let currentLeaderIndex = st.leader;
      let nextLeaderIndex = (currentLeaderIndex + 1) % st.players.length;

      // Find the next non-defeated player
      while (st.players[nextLeaderIndex].isDefeated) {
        nextLeaderIndex = (nextLeaderIndex + 1) % st.players.length;
        // If we've looped back to the start, break to avoid infinite loop if all are dead
        if (nextLeaderIndex === currentLeaderIndex) return;
      }

      st.leader = nextLeaderIndex;
      notify("Control switched to " + st.players[st.leader].id, "#6aa8ff");
    }
    document.getElementById('btnSwitchChar').addEventListener('click', switchNextPlayer);

    /* ================ Auto Systems & Alchemy Logic ================== */

    // Refactored `autoOpenAll` to be more robust and not rely on UI clicks
    function autoOpenAll() {
      // include boxes/gifts and boss_skip_pass so S-Box & SS Eggs open too
      // Expand to process all possible bag/box/gift/pass types
      const openableTypes = ['gold_bag', 'big_gold_bag', 'pet_box', 'vehicle_box', 'super_equipment_pack', 'big_box', 'gear_kit', 'treasure_box', 'boss_skip_pass', 'box', 'gift', 'bag', 's_box'];
      const itemsToOpen = st.inv.filter(it => it && openableTypes.includes(it.type));
      if (itemsToOpen.length === 0) {
        notify('No openable items found.');
        return false;
      }

      let openCount = 0;
      // Iterate backwards so splicing doesn't mess up the loop
      for (let i = st.inv.length - 1; i >= 0; i--) {
        const item = st.inv[i];
        if (item && openableTypes.includes(item.type)) {
          st.inv.splice(i, 1); // Remove item first
          openCount++;
          // Handle opening logic directly
          switch (item.type) {
            case 'gold_bag':
              const amt = 500 + Math.floor(Math.random() * 4501);
              st.gold += amt;
              notify(`+${amt} Gold`, '#ffd56a');
              break;
            case 'big_gold_bag':
              const bigAmt = 2000 + Math.floor(Math.random() * 8001);
              st.gold += bigAmt;
              notify(`+${bigAmt} Gold (Big Bag!)`, '#ffaa00');
              break;
            case 'pet_box':
              try {
                const speciesNames4 = Object.keys(window.PetData || {});
                const nameP4 = speciesNames4[Math.floor(Math.random() * speciesNames4.length)] || 'Pet';
                const dataP4 = window.PetData[nameP4] || { baseHP: 100, baseATK: 10, baseDEF: 5 };
                const newPetAuto = {
                  id: Math.random(),
                  name: nameP4,
                  type: 'gear',
                  slot: 'pet',
                  rank: 'C',
                  level: 1,
                  hp: dataP4.baseHP,
                  atk: dataP4.baseATK,
                  def: dataP4.baseDEF,
                  baseHP: dataP4.baseHP,
                  baseATK: dataP4.baseATK,
                  baseDEF: dataP4.baseDEF,
                  exp: 0,
                  kills: 0
                };
                addItemToBag(newPetAuto);
                notify('You got a new Pet!', '#ffd56a');
              } catch (ex) { console.error(ex); }
              break;
            case 'vehicle_box':
              try {
                const vehicles4 = [
                  { name: 'HoverBike', baseHP: 200, baseATK: 8, baseDEF: 6 },
                  { name: 'JetCart', baseHP: 210, baseATK: 10, baseDEF: 8 },
                  { name: 'MechWalker', baseHP: 230, baseATK: 12, baseDEF: 9 },
                  { name: 'DuneBuggy', baseHP: 190, baseATK: 9, baseDEF: 5 },
                  { name: 'CyberCar', baseHP: 205, baseATK: 11, baseDEF: 7 }
                ];
                const pick4 = vehicles4[Math.floor(Math.random() * vehicles4.length)] || { name: 'Vehicle', baseHP: 200, baseATK: 8, baseDEF: 6 };
                const newVehAuto = {
                  id: Math.random(),
                  name: pick4.name,
                  type: 'gear',
                  slot: 'vehicle',
                  rank: 'C',
                  level: 1,
                  hp: pick4.baseHP,
                  atk: pick4.baseATK,
                  def: pick4.baseDEF,
                  baseHP: pick4.baseHP,
                  baseATK: pick4.baseATK,
                  baseDEF: pick4.baseDEF,
                  exp: 0,
                  kills: 0
                };
                addItemToBag(newVehAuto);
                notify('You got a new Vehicle!', '#ffd56a');
              } catch (ex) { console.error(ex); }
              break;
            case 'treasure_box':
              const rank = item.name.charAt(0); // e.g., "C-Rank..."
              const pool = LOOT_TABLES.bossChest.filter(i => i.rank === rank);
              const loot = pool.length > 0 ? pool[Math.floor(Math.random() * pool.length)] : rollLoot('mobChest');
              if (loot) addItemToBag(JSON.parse(JSON.stringify(loot)));
              notify(`Box contained a ${rank}-rank item!`, '#3ec5ff');
              break;
            // Add cases for other box types if needed
            case 'box':
              {
                // generic box: derive rank (if present) or default 'C'; open accordingly
                const rank2 = (item.rank || (item.name ? item.name.charAt(0) : 'C')).toUpperCase();
                let table;
                if (rank2 === 'SS' || rank2 === 'S') {
                  table = 'bossChest';
                } else if (rank2 === 'A') {
                  table = 'miniBossChest';
                } else {
                  table = 'mobChest';
                }
                const loot2 = rollLoot(table);
                if (loot2) addItemToBag(JSON.parse(JSON.stringify(loot2)));
                notify(`Box contained a ${rank2}-rank item!`, '#3ec5ff');
              }
              break;
            case 'gift':
              {
                // convert gifts to keys or a new loot box
                if (!st.giftKeys) st.giftKeys = 0;
                if (Math.random() < 0.5) {
                  st.giftKeys++;
                } else {
                  st.inv.push({ id: Math.random(), name: 'Loot Box', type: 'box', rank: Math.random() < 0.2 ? 'S' : 'A' });
                }
                notify('Gift opened!', '#ffd56a');
              }
              break;

            case 's_box': {
              // S-Box: grant S-rank gear and bonus gold
              const lootS = { id: Math.random(), name: 'S-Rank Relic', type: 'gear', slot: 'acc1', rank: 'S', atk: 28 + Math.floor(Math.random() * 10) };
              addItemToBag(lootS);
              st.gold += 2000 + Math.floor(Math.random() * 3000);
              notify('S-Box opened!', '#ffd56a');
              break;
            }
            case 'super_equipment_pack': {
              // award multiple B/A rank gear
              for (let n = 0; n < 3; n++) {
                const rankEQ = Math.random() < 0.5 ? 'B' : 'A';
                const poolEQ = LOOT_TABLES.bossChest.filter(it => it.rank === rankEQ);
                const eq = poolEQ[Math.floor(Math.random() * poolEQ.length)];
                if (eq) addItemToBag(JSON.parse(JSON.stringify(eq)));
              }
              notify('Super Equipment Pack opened!', '#ffd56a');
              break;
            }
            case 'gear_kit': {
              // gear kit: 3 random gear pieces
              for (let n = 0; n < 3; n++) {
                const gearItem = rollLoot('mobChest');
                if (gearItem) addItemToBag(JSON.parse(JSON.stringify(gearItem)));
              }
              notify('Gear Kit opened!', '#ffd56a');
              break;
            }
            case 'big_box': {
              // big box: mix of items, pet, vehicle, and gear
              for (let n = 0; n < 3; n++) {
                const randIt = rollLoot('mobChest');
                if (randIt) addItemToBag(randIt);
              }
              // add one random pet
              try {
                const speciesNames3 = Object.keys(window.PetData || {});
                const nameP3 = speciesNames3[Math.floor(Math.random() * speciesNames3.length)] || 'Pet';
                const dataP3 = window.PetData[nameP3] || { baseHP: 100, baseATK: 10, baseDEF: 5 };
                const newPetBB = {
                  id: Math.random(),
                  name: nameP3,
                  type: 'gear',
                  slot: 'pet',
                  rank: 'C',
                  level: 1,
                  hp: dataP3.baseHP,
                  atk: dataP3.baseATK,
                  def: dataP3.baseDEF,
                  baseHP: dataP3.baseHP,
                  baseATK: dataP3.baseATK,
                  baseDEF: dataP3.baseDEF,
                  exp: 0,
                  kills: 0
                };
                addItemToBag(newPetBB);
              } catch (ex) { console.error(ex); }
              // add one random vehicle
              try {
                const vehiclesBB = [
                  { name: 'HoverBike', baseHP: 200, baseATK: 8, baseDEF: 6 },
                  { name: 'JetCart', baseHP: 210, baseATK: 10, baseDEF: 8 },
                  { name: 'MechWalker', baseHP: 230, baseATK: 12, baseDEF: 9 },
                  { name: 'DuneBuggy', baseHP: 190, baseATK: 9, baseDEF: 5 },
                  { name: 'CyberCar', baseHP: 205, baseATK: 11, baseDEF: 7 }
                ];
                const pickBB = vehiclesBB[Math.floor(Math.random() * vehiclesBB.length)] || { name: 'Vehicle', baseHP: 200, baseATK: 8, baseDEF: 6 };
                const newVehBB = {
                  id: Math.random(),
                  name: pickBB.name,
                  type: 'gear',
                  slot: 'vehicle',
                  rank: 'C',
                  level: 1,
                  hp: pickBB.baseHP,
                  atk: pickBB.baseATK,
                  def: pickBB.baseDEF,
                  baseHP: pickBB.baseHP,
                  baseATK: pickBB.baseATK,
                  baseDEF: pickBB.baseDEF,
                  exp: 0,
                  kills: 0
                };
                addItemToBag(newVehBB);
              } catch (ex) { console.error(ex); }
              const ranksBB = ['A', 'B', 'C'];
              const rBB = ranksBB[Math.floor(Math.random() * ranksBB.length)];
              const poolBB = LOOT_TABLES.bossChest.filter(it => it.rank === rBB);
              const gearBB = poolBB[Math.floor(Math.random() * poolBB.length)];
              if (gearBB) addItemToBag(JSON.parse(JSON.stringify(gearBB)));
              notify('Big Box opened!', '#ffd56a');
              break;
            }
            case 'boss_skip_pass': {
              // consume pass and add boss key
              st.bossKeys = (st.bossKeys || 0) + 1;
              notify('Boss Skip Pass consumed (key added)', '#ffd56a');
              break;
            }
            case 'bag': {
              // generic bag: moderate gold and silver
              st.gold += 400 + Math.floor(Math.random() * 600);
              st.silver = (st.silver || 0) + 50 + Math.floor(Math.random() * 100);
              notify('Bag opened!', '#ffd56a');
              break;
            }
          }
        }
      }

      if (openCount > 0) {
        notify(`Opened ${openCount} items.`);
        updateCurrencies();
        if (st.bagOpen) renderBag();
      }
      return openCount > 0;
    }
    document.getElementById('btnOpenAll').addEventListener('click', () => autoOpenAll());

    function autoUpgradeItems(silent = false) {
      let goldSpent = 0;
      let upgradedCount = 0;
      const allGear = st.inv.filter(it => it && it.type === 'gear');
      const gearToUpgrade = allGear.filter(it => it && it.type === 'gear' && it.level < 10);
      const uniqueGear = [...new Map(gearToUpgrade.map(item => [item.id, item])).values()];

      for (const item of uniqueGear) {
        while (item.level < 10) {
          const cost = calcUpgradeCost(item);
          if (st.gold < cost) {
            if (!silent) notify('Not enough gold to continue upgrading.');
            break;
          }
          st.gold -= cost;
          goldSpent += cost;
          item.level++;
          if (item.atk) item.atk = Math.round(item.atk * 1.12 + (item.rank === 'S' ? 2 : 1));
          if (item.def) item.def = Math.round(item.def * 1.12 + (item.rank === 'S' ? 2 : 1));
          upgradedCount++;
        }
      }

      if (upgradedCount > 0) {
        if (!silent) notify(`Auto-upgraded items ${upgradedCount} times for ${goldSpent} gold.`);
        updateCurrencies();
        recalcStats();
        if (st.bagOpen) renderBag();
      } else if (!silent) {
        notify('No items to upgrade or not enough gold.');
      }
      return upgradedCount > 0;
    }
    document.getElementById('btnAutoUp').addEventListener('click', () => autoUpgradeItems(false));

    function autoEquipBestGear(silent = false) {
      if (window.Game && typeof Game.autoEquipBestGear === 'function') {
        return Game.autoEquipBestGear(silent);
      }

      const slots = ['weapon', 'weapon2', 'armor', 'acc1', 'acc2', 'pet', 'vehicle'];
      const getItemScore = item => {
        if (!item) return -1;
        return (item.atk || 0) * 1.2 + (item.def || 0) + (item.level || 0);
      };
      const acceptsSlot = (slot, itemSlot) => {
        if (slot === 'weapon2') return itemSlot === 'weapon' || itemSlot === 'weapon2';
        if (slot === 'acc1' || slot === 'acc2') {
          return itemSlot === 'acc1' || itemSlot === 'acc2' || itemSlot === 'accessory';
        }
        return slot === itemSlot;
      };

      let equippedCount = 0;

      for (const slot of slots) {
        const potentialItems = st.inv.filter(it => it && acceptsSlot(slot, it.slot || it.type));
        if (potentialItems.length === 0) continue;

        const bestItemInBag = potentialItems.reduce((best, current) => {
          return getItemScore(current) > getItemScore(best) ? current : best;
        });

        const currentlyEquipped = st.equippedGear[slot];
        if (getItemScore(bestItemInBag) > getItemScore(currentlyEquipped)) {
          if (currentlyEquipped) addItemToBag(currentlyEquipped);
          st.equippedGear[slot] = bestItemInBag;
          const index = st.inv.indexOf(bestItemInBag);
          if (index >= 0) st.inv.splice(index, 1);
          equippedCount++;
        }
      }

      if (equippedCount > 0) {
        if (!silent) notify(`Auto-equipped ${equippedCount} new item(s).`);
        recalcStats();
        if (st.bagOpen) renderBag();
        return true;
      }

      if (!silent) notify('No better gear to equip.');
      return false;
    }
    document.getElementById('btnAutoEq').addEventListener('click', () => autoEquipBestGear(false));

    // Refactored Fusion Logic
    function performFusion(itemsToFuse) {
      const rankOrder = ['C', 'B', 'A', 'S'];
      const currentRank = itemsToFuse[0].rank || 'C';
      const currentRankIndex = rankOrder.indexOf(currentRank);

      if (currentRankIndex >= rankOrder.length - 1) {
        notify("Cannot fuse 'S' rank items further.", '#ff7a6a');
        itemsToFuse.forEach(it => addItemToBag(it)); // Return items
        return null;
      }

      const nextRank = rankOrder[currentRankIndex + 1];
      const totalAtk = itemsToFuse.reduce((sum, it) => sum + (it.atk || 0), 0);
      const totalDef = itemsToFuse.reduce((sum, it) => sum + (it.def || 0), 0);
      const highestLevel = itemsToFuse.reduce((max, it) => Math.max(max, it.level || 0), 0);

      return makeGear(
        `Fused ${itemsToFuse[0].name.replace('Rusty ', '').replace('Cracked ', '')}`,
        itemsToFuse[0].slot, {
        rank: nextRank,
        atk: Math.round(totalAtk / 3 * 1.5 + 5),
        def: Math.round(totalDef / 3 * 1.5 + 5),
        level: Math.floor(highestLevel / 2)
      }
      );
    }

    function autoFuseItems(isAutoButton = true) {
      let fusedCount = 0;
      const itemsByTypeAndRank = {};
      const equippedIds = Object.values(st.equippedGear).filter(Boolean).map(it => it.id);
      const gearToFuse = st.inv.filter(it => it && it.type === 'gear' && !equippedIds.includes(it.id));

      for (const item of gearToFuse) {
        const key = `${item.slot}_${item.rank || 'C'}`;
        if (!itemsByTypeAndRank[key]) itemsByTypeAndRank[key] = [];
        itemsByTypeAndRank[key].push(item);
      }

      for (const key in itemsByTypeAndRank) {
        const items = itemsByTypeAndRank[key];
        while (items.length >= 3) {
          const itemsToFuse = items.splice(0, 3);
          for (const item of itemsToFuse) {
            const index = st.inv.findIndex(invItem => invItem.id === item.id);
            if (index > -1) st.inv.splice(index, 1);
          }
          const newItem = performFusion(itemsToFuse);
          if (newItem) {
            addItemToBag(newItem);
            fusedCount++;
          }
        }
      }

      if (fusedCount > 0) {
        if (isAutoButton) notify(`Fused ${fusedCount} new item(s).`);
        if (st.bagOpen) renderBag();
      } else if (isAutoButton) {
        notify('Not enough items to fuse.');
      }
      return fusedCount > 0;
    }
    document.getElementById('btnAutoFuse').addEventListener('click', () => autoFuseItems(true));

    function autoSellItems() {
      const equippedIds = Object.values(st.equippedGear).filter(Boolean).map(it => it.id);
      const itemsToSell = st.inv.filter(it => it && it.type === 'gear' && (it.rank === 'C' || it.rank === 'B') && !equippedIds.includes(it.id));
      let goldGained = 0;

      if (itemsToSell.length === 0) {
        notify('No items to sell (unequipped rank C or B).');
        return;
      }

      itemsToSell.forEach(item => {
        const idx = st.inv.findIndex(x => x && x.id === item.id);
        if (idx >= 0) {
          st.inv.splice(idx, 1);
          const sellPrice = (item.level + 1) * 5 + (item.rank === 'B' ? 20 : 5);
          st.gold += sellPrice;
          goldGained += sellPrice;
        }
      });

      if (goldGained > 0) {
        notify(`Sold ${itemsToSell.length} items for ${goldGained} gold.`);
        updateCurrencies();
        if (st.bagOpen) renderBag();
      }
    }
    document.getElementById('btnAutoSell').addEventListener('click', autoSellItems);

    function renderAlchemyBag() {
      const strip = document.querySelector('.alchemy-bag-strip');
      strip.innerHTML = '';
      const equippedIds = Object.values(st.equippedGear).filter(Boolean).map(it => it.id);
      const items = st.inv.filter(it => it && (it.type === 'gear' || it.slot === 'pet') && !equippedIds.includes(it.id));

      items.forEach(it => {
        const cell = document.createElement('div');
        cell.className = 'slot-box item';
        cell.textContent = `${it.name} (${it.rank || 'C'})`;
        cell.draggable = true;
        cell.dataset.itemId = it.id;
        cell.addEventListener('dragstart', handleDragStart);
        strip.appendChild(cell);
      });
    }

    function handleDragStart(e) {
      e.dataTransfer.setData('text/plain', e.target.dataset.itemId);
      e.dataTransfer.effectAllowed = 'move';
    }

    const alchemySlots = document.querySelectorAll('.alchemy-slots .slot-box');
    alchemySlots.forEach(slot => {
      slot.addEventListener('dragover', handleDragOver);
      slot.addEventListener('drop', handleDrop);
      slot.addEventListener('click', clearAlchemySlot);
    });

    function handleDragOver(e) {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
    }

    function handleDrop(e) {
      e.preventDefault();
      const targetSlot = e.target.closest('.slot-box');
      if (!targetSlot) return;
      const itemId = e.dataTransfer.getData('text/plain');
      const item = st.inv.find(it => it.id == itemId);

      if (item) {
        const isAlreadyInSlot = Array.from(alchemySlots).some(s => s.dataset.itemId === itemId);
        if (isAlreadyInSlot) {
          notify("Item already in another slot.");
          return;
        }
        targetSlot.textContent = `${item.name} (${item.rank || 'C'})`;
        targetSlot.dataset.itemId = item.id;
        targetSlot.classList.add('item');
      }
    }

    function clearAlchemySlot(e) {
      const slot = e.target.closest('.slot-box');
      if (slot && slot.dataset.itemId) {
        slot.textContent = '?';
        delete slot.dataset.itemId;
        slot.classList.remove('item');
      }
    }

    function combineAlchemyItems() {
      const resultSlot = document.querySelector('.alchemy-result .slot-box');
      const itemsInSlots = Array.from(alchemySlots).map(slot => {
        if (!slot.dataset.itemId) return null;
        return st.inv.find(it => it.id == slot.dataset.itemId);
      }).filter(Boolean);

      if (itemsInSlots.length !== 3) {
        notify('Please place 3 items in the slots.', '#ff7a6a');
        return;
      }

      // --- Logic for Fusion ---
      const isFusion = itemsInSlots.every(it => it.slot === itemsInSlots[0].slot && (it.rank || 'C') === (itemsInSlots[0].rank || 'C'));
      if (isFusion) {
        itemsInSlots.forEach(item => {
          const index = st.inv.findIndex(invItem => invItem.id === item.id);
          if (index > -1) st.inv.splice(index, 1);
        });
        const newItem = performFusion(itemsInSlots);
        if (newItem) {
          addItemToBag(newItem);
          notify(`Fusion successful! Created a ${newItem.rank}-rank item.`, '#36c777');
        }
      } else {
        // --- Logic for Special Recipe ---
        const hasCGea = itemsInSlots.find(it => it.type === 'gear' && (it.rank || 'C') === 'C');
        const hasBGea = itemsInSlots.find(it => it.type === 'gear' && it.rank === 'B');
        const hasCPet = itemsInSlots.find(it => it.slot === 'pet' && (it.rank || 'C') === 'C');

        if (hasCGea && hasBGea && hasCPet) {
          itemsInSlots.forEach(item => {
            const index = st.inv.findIndex(invItem => invItem.id === item.id);
            if (index > -1) st.inv.splice(index, 1);
          });
          const lootTypes = ['gear', 'pet', 'gift_key', 'treasure_box'];
          const randomLootType = lootTypes[Math.floor(Math.random() * lootTypes.length)];
          let newItem;
          if (randomLootType === 'gear') newItem = rollLoot('miniBossChest');
          else if (randomLootType === 'pet') newItem = { id: Math.random(), name: 'Special Pet', type: 'gear', slot: 'pet', rank: 'B', atk: 15 };
          else if (randomLootType === 'gift_key') { st.giftKeys++; notify('+1 Gift Key', '#ff9aa8'); }
          else newItem = { id: Math.random(), name: 'B-Rank Treasure Box', type: 'treasure_box', slot: 'item' };

          if (newItem) addItemToBag(newItem);
          notify('Special Recipe successful!', '#ffd56a');
        } else {
          // --- Logic for Generic Alchemy ---
          itemsInSlots.forEach(item => {
            const index = st.inv.findIndex(invItem => invItem.id === item.id);
            if (index > -1) st.inv.splice(index, 1);
          });

          const rankOrder = ['C', 'B', 'A', 'S'];
          const highestRank = itemsInSlots.reduce((maxRank, item) => {
            const itemRank = item.rank || 'C';
            return rankOrder.indexOf(itemRank) > rankOrder.indexOf(maxRank) ? itemRank : maxRank;
          }, 'C');

          const lootBox = { id: Math.random(), name: `${highestRank}-Rank Treasure Box`, type: 'treasure_box', slot: 'item' };
          addItemToBag(lootBox);
          notify(`Alchemy successful! Created a ${lootBox.name}.`, '#3ec5ff');
        }
      }

      // Clear slots and update UI
      alchemySlots.forEach(slot => {
        slot.textContent = '?';
        delete slot.dataset.itemId;
        slot.classList.remove('item');
      });
      resultSlot.textContent = 'RESULT';
      renderAlchemyBag();
      if (st.bagOpen) renderBag();
    }
    document.getElementById('btnCombine').addEventListener('click', combineAlchemyItems);

    document.getElementById('toggleCurrencies').onclick = () => {
      const extraCurrencies = document.getElementById('extra-currencies');
      const toggleBtn = document.getElementById('toggleCurrencies');

      if (extraCurrencies.style.display === 'none') {
        extraCurrencies.style.display = 'flex';
        toggleBtn.innerHTML = '- Less'; // Optional: change button text
      } else {
        extraCurrencies.style.display = 'none';
        toggleBtn.innerHTML = '+ More'; // Optional: change button text
      }
    };
  </script>

  <!-- Scroll window overlay styles removed - no longer used -->
  <!-- ONECLICK_START : A1K Runner — Apex Hunter (offline, one‑click bootstrap) -->
  <style>
    /* Preloader */
    #apxPre {
      position: fixed;
      inset: 0;
      background: #0a0f18;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 99999
    }

    #apxPre h1 {
      margin: 0 0 10px;
      font: 600 14px/1.2 system-ui;
      color: #cfe3ff;
      letter-spacing: .6px
    }

    #apxPre .bar {
      width: 60%;
      max-width: 520px;
      height: 8px;
      border-radius: 999px;
      background: #111b22;
      border: 1px solid #293854;
      overflow: hidden
    }

    #apxPre .fill {
      height: 100%;
      transform-origin: left center;
      background: linear-gradient(90deg, #2EA8FF, #7B61FF);
      transform: scaleX(.2)
    }

    /* Floating interact prompt */
    #apxInteract {
      position: fixed;
      left: 50%;
      bottom: 120px;
      transform: translateX(-50%);
      background: #0f1826;
      border: 1px solid #293854;
      border-radius: 8px;
      padding: 6px 10px;
      color: #cfe3ff;
      font: 600 12px system-ui;
      display: none;
      z-index: 9000
    }

    #apxInteract small {
      color: #8ea5c4;
      font-weight: 500;
      margin-left: 6px
    }

    /* QA overlay */
    #apxQA {
      position: fixed;
      right: 12px;
      top: 12px;
      width: 310px;
      max-height: 70vh;
      overflow: auto;
      background: #0f1826;
      border: 1px solid #293854;
      border-radius: 8px;
      box-shadow: 0 8px 28px rgba(0, 0, 0, .45);
      z-index: 100000;
      display: none
    }

    #apxQA header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 10px;
      border-bottom: 1px solid #293854;
      color: #e9f4ff;
      font: 600 12px system-ui
    }

    #apxQA .b {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      padding: 10px
    }

    #apxQA button {
      background: #1a263a;
      color: #d7e9ff;
      border: 1px solid #3b4d71;
      border-radius: 6px;
      padding: 6px 8px;
      font: 600 11px system-ui;
      cursor: pointer
    }

    #apxQA pre {
      background: #0b1421;
      color: #9fb7d8;
      border-top: 1px solid #293854;
      margin: 0;
      padding: 8px;
      max-height: 160px;
      overflow: auto;
      font: 11px/1.4 ui-monospace, Menlo, Consolas, "Liberation Mono";
    }

    /* Pet/Vehicle barlet + HUD add‑ons */
    .apx-barlet {
      position: absolute;
      transform: translate(-50%, -100%);
      width: 32px;
      height: 4px;
      background: #15243a;
      border: 1px solid #293854;
      border-radius: 3px;
      overflow: hidden
    }

    .apx-barlet>i {
      display: block;
      height: 100%;
      background: linear-gradient(90deg, #36c777, #6de38e);
      transform-origin: left center
    }

    #petReady {
      position: fixed;
      left: 14px;
      bottom: 160px;
      background: #0f1826;
      border: 1px solid #293854;
      border-radius: 8px;
      padding: 4px 8px;
      color: #cfe3ff;
      font: 600 11px system-ui;
      opacity: .85;
      display: none;
      z-index: 9000
    }

    #vehFuelWrap {
      position: fixed;
      right: 14px;
      bottom: 160px;
      background: #0f1826;
      border: 1px solid #293854;
      border-radius: 8px;
      padding: 6px 8px;
      color: #cfe3ff;
      font: 600 11px system-ui;
      display: none;
      z-index: 9000
    }

    #vehFuelWrap .bar {
      width: 160px;
      height: 8px;
      border-radius: 999px;
      background: #111b22;
      border: 1px solid #293854;
      overflow: hidden
    }

    #vehFuelWrap {
      display: none !important;
    }

    #vehFuelWrap .bar .fill {
      height: 100%;
      background: linear-gradient(90deg, #ffaa00, #ff6aa8);
      transform-origin: left center
    }

    /* Alchemy: larger slots + drag affordance */
    #alchemy-panel .alchemy-slots .slot-box {
      width: 72px;
      height: 72px;
      font-size: 12px
    }

    [draggable=true] {
      cursor: grab
    }
  </style>

  <!-- ===== APEX PATCH: Pet Leveling & Hero Stats HUD (vA1K) ===== -->
  <script>
    (() => {
      // Do not double apply
      if (window.__A1K_PET_LEVEL_HUD_PATCH) return;
      window.__A1K_PET_LEVEL_HUD_PATCH = true;
      // Define PetData for 10 pets with base stats, passive, unique skill, and evolution info
      window.PetData = {
        FireCub: { baseHP: 100, baseATK: 20, baseDEF: 10, passive: 'Burn Aura (+5% fire dmg)', unique: 'Flame Burst', evolvesTo: 'FireBear', evolveLevel: 10 },
        WaterLizard: { baseHP: 90, baseATK: 18, baseDEF: 12, passive: 'Aqua Shield (+5% DEF)', unique: 'Water Jet', evolvesTo: 'WaterDragon', evolveLevel: 10 },
        EarthGolem: { baseHP: 120, baseATK: 15, baseDEF: 15, passive: 'Fortify (+10% HP)', unique: 'Rock Throw', evolvesTo: 'MountainGolem', evolveLevel: 10 },
        AirSprite: { baseHP: 80, baseATK: 22, baseDEF: 8, passive: 'Swift (+10% move)', unique: 'Gust', evolvesTo: 'AirElemental', evolveLevel: 10 },
        LightningBird: { baseHP: 85, baseATK: 24, baseDEF: 10, passive: 'Static Charge (+5% crit)', unique: 'Thunder Bolt', evolvesTo: 'StormPhoenix', evolveLevel: 10 },
        IceWolf: { baseHP: 95, baseATK: 23, baseDEF: 11, passive: 'Chill Aura (+5% slow)', unique: 'Frost Bite', evolvesTo: 'IceBear', evolveLevel: 10 },
        ShadowCat: { baseHP: 90, baseATK: 26, baseDEF: 8, passive: 'Shadowstep (+5% evasion)', unique: 'Dark Slash', evolvesTo: 'ShadowPanther', evolveLevel: 10 },
        LightFox: { baseHP: 88, baseATK: 21, baseDEF: 12, passive: 'Radiant Heal (+0.5 HP/s)', unique: 'Solar Flare', evolvesTo: 'SunFox', evolveLevel: 10 },
        MagicFrog: { baseHP: 80, baseATK: 19, baseDEF: 9, passive: 'Mana Regen (+5 MP/s)', unique: 'Arcane Wave', evolvesTo: 'MysticToad', evolveLevel: 10 },
        SteelDog: { baseHP: 110, baseATK: 20, baseDEF: 14, passive: 'Armor Plating (+5% damage reduction)', unique: 'Metal Bite', evolvesTo: 'SteelHound', evolveLevel: 10 }
      };

      function ensurePetProps(p) {
        if (!p) return;
        p.level = p.level || 1;
        p.exp = p.exp || 0;
        p.kills = p.kills || 0;
        const data = window.PetData[p.name] || { baseHP: p.hpMax || 100, baseATK: p.dmg || 10, baseDEF: 0 };
        const mul = 1 + 0.05 * (p.level - 1);
        p.hpMax = Math.round(data.baseHP * mul);
        p.hp = Math.min(p.hpMax, p.hp || p.hpMax);
        p.dmg = Math.round(data.baseATK * mul);
        p.def = Math.round(data.baseDEF * mul);
      }

      const _onEnemyKilled = window.onEnemyKilled;
      window.onEnemyKilled = function (e) {
        try {
          // Aggregate pets from equippedPets and fallback st.pets
          const petList = [];
          if (Array.isArray(st.equippedPets)) {
            for (const pt of st.equippedPets) { if (pt) petList.push(pt); }
          }
          if (Array.isArray(st.pets)) {
            for (const pt of st.pets) { if (pt) petList.push(pt); }
          }
          petList.forEach(p => {
            ensurePetProps(p);
            p.kills = (p.kills || 0) + 1;
            p.exp = (p.exp || 0) + 1;
            const needed = 10;
            while (p.exp >= needed && p.level < 30) {
              p.exp -= needed;
              p.level += 1;
              ensurePetProps(p);
              if (window.addFloater) addFloater((p.x || 200), (p.y || 560) - 80, 'Level ' + p.level + '!', '#ffd56a');
              if (window.addImpact) addImpact((p.x || 200), (p.y || 560), '#ffd56a');
            }
          });
          // Vehicle leveling: apply similar logic to equipped vehicle if present
          if (st.equippedVehicle) {
            const v = st.equippedVehicle;
            if (window.ensureVehProps) ensureVehProps(v);
            v.kills = (v.kills || 0) + 1;
            v.exp = (v.exp || 0) + 1;
            const neededV = 10;
            while (v.exp >= neededV && v.level < 30) {
              v.exp -= neededV;
              v.level += 1;
              if (window.ensureVehProps) ensureVehProps(v);
              if (window.addFloater) addFloater((v.x || 200), (v.y || 560) - 80, 'Level ' + v.level + '!', '#ffd56a');
              if (window.addImpact) addImpact((v.x || 200), (v.y || 560), '#ffd56a');
            }
          }
        } catch (ex) { console.error(ex); }
        return _onEnemyKilled && _onEnemyKilled(e);
      };

      function createHeroHUD() {
        // Only create once
        if (document.getElementById('heroHud')) return;
        const hud = document.createElement('div');
        hud.id = 'heroHud';
        // Add hide/show toggle button inside the HUD
        const toggleBtn = document.createElement('button');
        toggleBtn.textContent = '×';
        toggleBtn.title = 'Hide Stats';
        toggleBtn.className = 'hero-hud-toggle';
        toggleBtn.onclick = () => {
          const hudEl = document.getElementById('heroHud');
          if (!hudEl) return;
          const hidden = hudEl.style.display === 'none';
          // Toggle display
          hudEl.style.display = hidden ? 'block' : 'none';
          // Persist to localStorage
          try { localStorage.setItem('heroHudVisible', hidden ? 'true' : 'false'); } catch (_ex) { }
        };
        hud.appendChild(toggleBtn);
        document.body.appendChild(hud);
      }
      function updateHeroHUD() {
        const hud = document.getElementById('heroHud'); if (!hud) return;
        let html = '';
        (st.players || []).forEach(p => {
          // Compute attack and defense values
          const atk = Math.round((p.dmg || p.dmgBase || 0) * (p._atkMul || 1));
          const def = Math.round((p.defBase || 0) * (p._defMul || 1));
          const hpRatio = Math.max(0, Math.min(1, (p.hp || 0) / (p.hpMax || 1)));
          // Use HP bar and a secondary bar for MP/Stamina if available
          const mpRatio = Math.max(0, Math.min(1, (p.mp || p.mana || 0) / ((p.mpMax || p.manaMax || 1))));
          html += `<div class="hero-hud-margin">
        <div class="hero-hud-font-style">${p.id || p.name}</div>
        <div class="bar hero-hud-bar"><div class="fill hp hero-hud-hp-bar" style="transform:scaleX(${hpRatio.toFixed(2)})"></div></div>
        <div class="bar hero-hud-bar"><div class="fill mp hero-hud-mp-bar" style="transform:scaleX(${mpRatio.toFixed(2)})"></div></div>
        <div class="hero-hud-stats">ATK: ${atk} DEF: ${def}</div>
      </div>`;
        });
        hud.innerHTML = html;
      }
      createHeroHUD();
      setInterval(updateHeroHUD, 600);
    })();
  </script>
  <div id="apxInteract">[E] <span id="apxInteractLabel">Open Chest</span> <small id="apxInteractHint"></small></div>
  <div id="petReady">Pet: <b id="petReadyLabel">READY</b></div>
  <div id="vehFuelWrap">Fuel <div class="bar">
      <div class="fill" id="vehFuelFill"></div>
    </div>
  </div>
  <div id="apxQA">
    <header><span>QA • Apex</span><button id="apxQAclose" title="Close">✕</button></header>
    <div class="b">
      <button id="qaSpawnMini" type="button">Spawn Miniboss</button>
      <button id="qaSpawnBoss" type="button">Spawn Boss</button>
      <button id="qaChestTrioAlt" type="button">Open Chest Trio</button>
      <button id="qaResetSoft" type="button">Reset Skills (Soft)</button>
      <button id="qaResetHard" type="button">Reset Skills (Hard)</button>
      <button id="qaPet" type="button">Summon/Recall Pet</button>
      <button id="qaBoard" type="button">Board/Disembark Vehicle</button>
      <button id="qaSeatGizmo" type="button">Toggle Seat/Muzzle Gizmo</button>
      <button id="qaRefuel" type="button">Refill Fuel</button>
      <button id="qaEggB">Force Egg (B)</button>
      <button id="qaEggA">Force Egg (A)</button>
      <button id="qaEggS">Force Egg (S)</button>
      <button id="qaEggSS">Force Egg (SS)</button>
      <button id="qaAutoTwo">Auto‑test: Beat 2 Bosses</button>
      <button id="qaInteractDbg">Toggle Interact Debug</button>
    </div>
    <pre id="apxLog"></pre>
  </div>
  <script>
    (() => {
      "use strict";
      /* ===========================================================
         Apex Hunter One‑Click Bootstrap + Systems
         - Preloader, StageMgr fallback, Action Button, Chest Trio
         - Pets/Vehicles (polish), Alchemy DnD, Skills v4, QA overlay
         =========================================================== */
      const logEl = () => document.getElementById('apxLog');
      // Ensure no syntax errors: fix spread args usage in logger
      const ulog = (...a) => { try { console.log('[APEX]', ...a); const el = logEl(); if (el) { el.textContent = (el.textContent + '\n' + a.map(x => typeof x === 'object' ? JSON.stringify(x) : String(x)).join(' ')).slice(-4000); } } catch (_) { } };
      const $ = (q) => document.querySelector(q);
      const packEl = document.getElementById('enemy-pack');
      let PACK = {}; try { PACK = JSON.parse(packEl?.textContent || '{}'); } catch { PACK = { version: 'apex-1.0', stages: [] }; }

      /* ---------- existing HUD anchors (stable IDs) ---------- */
      const stagePill = document.getElementById('stagePill');
      const bossFill = document.getElementById('bossFill');
      const actionBtn = document.getElementById('btnUniversalAction');
      const btnPet = document.getElementById('btnPet');
      const btnVeh = document.getElementById('btnVeh');

      /* ---------- preloader ---------- */
      let pre = $('#apxPre'), preFill = $('#apxPreFill');
      if (!pre || !preFill) {
        try {
          pre = document.createElement('div');
          pre.id = 'apxPre';
          pre.innerHTML = '<h1>Loading…</h1><div class="bar"><div class="fill" id="apxPreFill"></div></div>';
          document.body.appendChild(pre);
          preFill = document.getElementById('apxPreFill');
        } catch (_) { }
      }
      let preT = 0; const preInt = setInterval(() => { preT = Math.min(1, preT + .12); if (preFill) preFill.style.transform = 'scaleX(' + preT + ')'; }, 120);
      function preDone() { clearInterval(preInt); if (preFill) preFill.style.transform = 'scaleX(1)'; setTimeout(() => pre?.remove(), 200); }

      /* ---------- tiny helpers ---------- */
      const clamp = (v, min, max) => v < min ? min : (v > max ? max : v);
      const now = () => performance.now();

      /* ---------- gameplay shims over existing state ---------- */
      const stRef = (typeof st !== 'undefined') ? st : (window.st = {
        stage: 1, wave: 1, kills: 0, bossAlive: false, bossHP: 0, bossMax: 1, enemies: [], pickups: [], effects: [],
        inv: [], equippedGear: { weapon: null, weapon2: null, armor: null, acc1: null, acc2: null }, equippedPets: [null, null], petSlots: 2, equippedVehicle: null, gold: 0, silver: 0, tickets: 0
      });
      // Ensure: no weapon pre-equipped at boot (Action Button opens first chest to equip).
      try {
        if (stRef?.equippedGear) {
          stRef.equippedGear.weapon = null;
          stRef.equippedGear.weapon2 = null;
        }
      } catch (_) { }

      /* ---------- Skills v4 (storage + resets + migration) ---------- */
      const SK_STORE = {
        vKey: 'a1k.skills.version', dataKey: 'a1k.skills.data',
        read() { try { return JSON.parse(localStorage.getItem(this.dataKey) || '{}'); } catch { return {}; } },
        write(d) { localStorage.setItem(this.dataKey, JSON.stringify(d || {})); },
      };
      const Skills = {
        version: 4,
        installBaseline() {
          const baseline = { apTotal: 0, apSpent: 0, picks: [], learned: {}, createdAt: Date.now() };
          SK_STORE.write(baseline); localStorage.setItem(SK_STORE.vKey, String(this.version));
          if (stRef) { stRef.apTotal = 0; stRef.apSpent = 0; stRef.talentPicks = new Set(); }
          ulog('Skills baseline installed');
        },
        migrate() {
          const v = Number(localStorage.getItem(SK_STORE.vKey) || 0);
          if (!v || v < this.version) { this.installBaseline(); }
        },
        resetSoft() {
          const d = SK_STORE.read(); d.apSpent = 0; d.picks = []; d.learned = {}; SK_STORE.write(d);
          if (stRef) { stRef.apSpent = 0; stRef.talentPicks = new Set(); stRef._talentStats = {}; }
          ulog('Skills soft reset');
        },
        resetHard() {
          this.installBaseline();
          ulog('Skills hard reset');
        }
      }; window.Skills = Skills; Skills.migrate();

      /* ---------- StageMgr fallback (one‑click start) ---------- */
      function getStage(stageId) { return (PACK.stages || []).find(s => s.id === stageId) || { id: stageId, waves: [] }; }
      const StageMgr = window.StageMgr || (window.StageMgr = (() => {
        let curStage = 1, waveIdx = 0, dropRamp = 0;
        function pill() {
          if (stagePill) {
            const P = window.__PROG95;
            if (P && stRef) {
              stagePill.textContent = `${P.areaLabel()} • ${P.stageLabel()} • Wave ${P.waveLabel()}/9.5 • Kills ${stRef.kills | 0}`;
            } else {
              stagePill.textContent = `Stage ${curStage} • Wave ${waveIdx}/10 • Kills ${stRef.kills | 0}`;
            }
          }
        }
        function bossBar() { if (bossFill) { const r = stRef.bossMax > 0 ? stRef.bossHP / stRef.bossMax : 0; bossFill.style.transform = `scaleX(${clamp(r, 0, 1)})`; } }
        function nextWave() {
          const ST = getStage(curStage); waveIdx++; stRef.wave = waveIdx; stRef.stage = curStage; pill();
          const wv = ST.waves[waveIdx - 1];
          if (!wv) { curStage++; waveIdx = 0; /* Prevent infinite recursion */ return; }
          if (wv.spawn === 'boss' || wv.spawn === 'miniboss') {
            stRef.bossAlive = true; stRef.bossMax = wv.hp || 1200; stRef.bossHP = stRef.bossMax; bossBar();
            let t = 0, ttk = (PACK.ttk?.boss || 60) * 1000;
            const tick = () => { if (!stRef.bossAlive) return; t += 500; const dmg = stRef.bossMax / (ttk / 500); api.onBossDamaged(dmg); if (stRef.bossAlive) setTimeout(tick, 500); };
            setTimeout(tick, 800);
          } else {
            const kinds = { 'trash': PACK.ttk?.trash || 8, 'elites': PACK.ttk?.elites || 15, 'mix': 12 };
            const dur = (kinds[wv.spawn] || 10) * 1000;
            setTimeout(() => api.onWaveCleared(), Math.max(1500, dur));
          }
        }
        function spawnChestTrio() { APEX.spawnChest('gold'); APEX.spawnChest('weapon'); APEX.spawnChest('mimic'); }
        const api = {
          start(s = 1) { curStage = s; waveIdx = 0; stRef.kills = 0; pill(); /* nextWave(); */ },
          onEnemyDefeated() { stRef.kills++; pill(); },
          onBossDamaged(dmg) {
            stRef.bossHP = Math.max(0, stRef.bossHP - (dmg || 0)); bossBar();
            if (stRef.bossHP <= 0) {
              stRef.bossAlive = false; stRef.bossKills = (stRef.bossKills || 0) + 1; spawnChestTrio(); api.onWaveCleared();
            }
          },
          onWaveCleared() {
            dropRamp = clamp(dropRamp + 0.05, 0, 0.5);
            spawnChestTrio();
            if (waveIdx >= 10) { curStage++; waveIdx = 0; }
            setTimeout(nextWave, 800);
          },
          forceMiniboss() { const ST = getStage(curStage); waveIdx = (ST.waves.findIndex(w => w.spawn === 'miniboss') + 1) || 5; /* nextWave(); */ },
          forceBoss() { const ST = getStage(curStage); waveIdx = (ST.waves.findIndex(w => w.spawn === 'boss') + 1) || 10; /* nextWave(); */ },
          autoTestTwoBosses() {
            let cleared = 0;
            const runOne = () => { api.forceBoss(); const chk = setInterval(() => { if (!stRef.bossAlive) { clearInterval(chk); if (++cleared < 2) runOne(); } }, 250); };
            runOne();
          }
        };
        return api;
      })());

      /* ---------- Interactables & Contextual Action Button ---------- */
      const APEX = (function () {
        const interactEl = $('#apxInteract'), labelEl = $('#apxInteractLabel'), hintEl = $('#apxInteractHint');
        const primaryCode = keymap.ACT_PRIMARY || 'KeyA';
        const primaryLabel = (() => {
          if (primaryCode === 'Space') return 'SPACE';
          if (primaryCode.startsWith('Key')) return primaryCode.slice(3).toUpperCase();
          if (primaryCode.startsWith('Digit')) return primaryCode.slice(5);
          return primaryCode.toUpperCase();
        })();
        if (interactEl && typeof interactEl.innerHTML === 'string') {
          interactEl.innerHTML = interactEl.innerHTML.replace(/\[[^\]]+\]/, `[${primaryLabel}]`);
        }
        const I = []; // {id, kind:'chest'|'pickup'|'toy', sub:'gold'|'weapon'|'mimic', x,y, r, rarity}
        function leader() { return (stRef.players && stRef.players[stRef.leader || 0]) || { x: 200, y: 560 }; }
        function near() {
          const L = leader(); let best = null, bd = 1e9;
          for (const it of I) { const d = Math.hypot(it.x - L.x, it.y - L.y); if (d < it.r && d < bd) { bd = d; best = it; } }
          return best;
        }
        function setActionLabel(txt) { if (actionBtn) actionBtn.textContent = txt || (stRef.equippedToy ? 'Use Toy' : 'ACTION'); }
        function refreshPrompt() {
          const t = near();
          if (!t) { interactEl.style.display = 'none'; setActionLabel(); return; }
          let txt = '', hint = ''; if (t.kind === 'chest') { txt = 'Open Chest'; hint = t.sub === 'mimic' ? '(careful)' : ''; }
          else if (t.kind === 'pickup') { txt = 'Pick Up'; }
          else if (stRef.equippedToy) { txt = 'Use Toy'; }
          labelEl.textContent = txt; hintEl.textContent = hint; interactEl.style.display = 'block'; setActionLabel(txt);
        }
        function openChest(obj) {
          const pityKey = 'apx.pity.weapon'; let pity = Number(localStorage.getItem(pityKey) || 0);
          if (obj.sub === 'weapon') {
            const guaranteed = (pity >= 3);
            pity = guaranteed ? 0 : (pity + 1);
            localStorage.setItem(pityKey, String(pity));
            const firstWeapon = { id: Math.random(), type: 'gear', slot: 'weapon', name: guaranteed ? 'APEX Toyblade' : 'Training Sword', rank: guaranteed ? 'A' : 'C', atk: guaranteed ? 28 : 6, level: 0 };
            try {
              (stRef.inv || []).push(firstWeapon);
              if (stRef.equippedGear) {
                if (!stRef.equippedGear.weapon) stRef.equippedGear.weapon = firstWeapon;
                else if (!stRef.equippedGear.weapon2) stRef.equippedGear.weapon2 = firstWeapon;
                else stRef.equippedGear.weapon = firstWeapon;
              }
              notify('Equipped: ' + firstWeapon.name);
            } catch (_) { }
          } else if (obj.sub === 'gold') { stRef.gold = (stRef.gold || 0) + Math.floor(200 + Math.random() * 800); notify('Gold acquired!'); }
          else if (obj.sub === 'mimic') { notify('Mimic! It snaps at you, but drops scraps.'); stRef.silver = (stRef.silver || 0) + Math.floor(20 + Math.random() * 60); }
          const idx = I.findIndex(x => x.id === obj.id); if (idx >= 0) I.splice(idx, 1);
          interactEl.style.display = 'none'; setActionLabel();
        }
        function spawnChest(kind) {
          const L = leader();
          const it = { id: Math.random(), kind: 'chest', sub: kind, x: (L.x + 40), y: L.y, r: 96, rarity: kind === 'weapon' ? 'purple' : (kind === 'gold' ? 'blue' : 'orange') };
          I.push(it); refreshPrompt();
        }
        function pickup(obj) {
          stRef.tickets = (stRef.tickets || 0) + 1;
          const idx = I.findIndex(x => x.id === obj.id); if (idx >= 0) I.splice(idx, 1);
          notify('Picked up 1 ticket');
        }
        function useToy() { notify('Toy used (cooldown started)'); }
        actionBtn?.addEventListener('click', () => { const t = near(); if (!t) { if (stRef.equippedToy) useToy(); return; } if (t.kind === 'chest') openChest(t); else if (t.kind === 'pickup') pickup(t); });
        setInterval(refreshPrompt, 250);
        return { spawnChest };
      })();
      window.APEX = APEX;

      /* ---------- Pets & Vehicles (summon/recall; fuel; i‑frames; gizmo; "ready") ---------- */
      const PetVehSys = (function () {
        let petSummoned = false, vehBoarded = false, pressId = null, petCharge = 0, petChargeMax = 100;
        let vehFuel = 1, vehFuelMax = 1, gizmo = false;
        const petReadyBox = document.getElementById('petReady'), petReadyLabel = document.getElementById('petReadyLabel');
        const fuelWrap = document.getElementById('vehFuelWrap'), fuelFill = document.getElementById('vehFuelFill');
        function leader() { return (stRef.players && stRef.players[stRef.leader || 0]) || { x: 200, y: 560 }; }
        function summonOrRecall() { petSummoned = !petSummoned; notify(petSummoned ? 'Pet summoned' : 'Pet recalled'); if (!petSummoned) petCharge = 0; }
        function boardToggle() {
          vehBoarded = !vehBoarded;
          if (vehBoarded) {
            vehFuelMax = 100; vehFuel = Math.max(vehFuel, vehFuelMax * 0.6); // give some fuel if empty
            fuelWrap.style.display = 'block';
            notify('Boarded vehicle');
          } else {
            fuelWrap.style.display = 'none';
            // 200ms i‑frames after eject
            window._apx_iFrameUntil = performance.now() + 200;
            notify('Disembarked (i‑frames 200ms)');
          }
        }
        // long‑press recall for pet
        function longPressStart(btn, fn) {
          const down = () => { pressId = setTimeout(() => { fn(); }, 550); };
          const up = () => { if (pressId) { clearTimeout(pressId); pressId = null; } };
          btn?.addEventListener('pointerdown', down); btn?.addEventListener('pointerup', up); btn?.addEventListener('pointerleave', up);
        }
        btnPet?.addEventListener('click', () => summonOrRecall());
        longPressStart(btnPet, () => { if (petSummoned) { petSummoned = false; petCharge = 0; notify('Pet recalled (long‑press)'); } });
        // btnVeh click handled by equipped-vehicle capture listener (no free boarding)
        // hook damage for i‑frames
        (function hookDamage() {
          if (typeof window.damagePlayer === 'function' && !window.damagePlayer._apxWrapped) {
            const orig = window.damagePlayer; window.damagePlayer = function (p, dmg) {
              if (window._apx_iFrameUntil && performance.now() < window._apx_iFrameUntil) { addFloater((leader().x || 200), (leader().y || 560) - 40, 'I‑FRAME', '#6aa8ff'); return; }
              return orig(p, dmg);
            }; window.damagePlayer._apxWrapped = true;
          }
        })();
        // HUD loops
        setInterval(() => {
          // pet charge & "ready" HUD
          if (petSummoned) {
            petCharge = Math.min(petChargeMax, petCharge + 2.5); // ~40s to full
            petReadyBox.style.display = 'block'; petReadyLabel.textContent = (petCharge >= petChargeMax) ? 'READY' : 'Charging...';
          } else {
            petReadyBox.style.display = 'none';
          }
          // fuel drain while boarded
          if (vehBoarded) {
            vehFuel = Math.max(0, vehFuel - 0.005); // drains slowly
            fuelFill.style.transform = 'scaleX(' + (vehFuel / vehFuelMax) + ')';
            if (vehFuel <= 0) { notify('Fuel empty'); vehBoarded = false; fuelWrap.style.display = 'none'; }
          }
          // gizmo markers (debug only)
          if (gizmo && vehBoarded) {
            const L = leader(); addFloater(L.x + 0, L.y - 20, 'SEAT', '#7B61FF'); addFloater(L.x + 30, L.y - 24, 'MUZZLE', '#ffaa00');
          }
        }, 100);
        // QA bindings
        document.getElementById('qaSeatGizmo')?.addEventListener('click', () => { gizmo = !gizmo; notify('Seat/Muzzle Gizmo: ' + (gizmo ? 'ON' : 'OFF')); });
        document.getElementById('qaRefuel')?.addEventListener('click', () => { vehFuel = Math.max(vehFuel, vehFuelMax); fuelFill.style.transform = 'scaleX(1)'; fuelWrap.style.display = vehBoarded ? 'block' : 'none'; notify('Fuel refilled'); });
        document.getElementById('qaPet')?.addEventListener('click', () => { summonOrRecall(); });
        document.getElementById('qaBoard')?.addEventListener('click', () => { boardToggle(); });
        // Pet "ready" activate on click if full
        document.getElementById('petReady')?.addEventListener('click', () => { if (petCharge >= petChargeMax) { petCharge = 0; addFloater((leader().x || 200), (leader().y || 560) - 70, 'PET BURST', '#c1ffc1'); } });
        return {};
      })();

      /* ---------- Alchemy: DnD & fusion (3-of-a-kind => tier up, 3% S-Box) ---------- */
      (function () {
        const panel = document.getElementById('alchemy-panel');
        const strip = panel?.querySelector('.alchemy-bag-strip');
        const slots = [...panel?.querySelectorAll('.alchemy-slots .slot-box') || []];
        function renderStrip() {
          if (!strip) return; strip.innerHTML = '';
          const items = (stRef.inv || []).slice(0, 16);
          items.forEach(it => {
            const d = document.createElement('div'); d.className = 'slot-box item'; d.draggable = true; d.textContent = (it.name || 'Item') + (it.rank ? (' [' + it.rank + ']') : '');
            d.addEventListener('dragstart', (e) => { e.dataTransfer.setData('text/plain', String(it.id || Math.random())); d.classList.add('dragging'); });
            d.addEventListener('dragend', () => d.classList.remove('dragging'));
            strip.appendChild(d);
          });
        }
        function acceptDrop(el) {
          el.addEventListener('dragover', (e) => e.preventDefault());
          el.addEventListener('drop', (e) => { e.preventDefault(); el.textContent = '•'; el.dataset.item = e.dataTransfer.getData('text/plain'); });
        }
        slots.forEach(acceptDrop);
        document.getElementById('btnCombineOverlay')?.addEventListener('click', () => {
          const ids = slots.map(s => s.dataset.item).filter(Boolean);
          if (ids.length < 3) { notify('Need 3 items'); return; }
          if (Math.random() < 0.03) { addItemToBag({ id: Math.random(), name: 'S-Box', type: 'box', rank: 'S', stackable: true }); notify('Alchemy miracle! S-Box created'); return; }
          addItemToBag({ id: Math.random(), name: 'Fused Relic', type: 'gear', slot: 'acc1', rank: 'B', level: 0 });
          notify('Fusion complete'); slots.forEach(s => { s.textContent = '?'; delete s.dataset.item; });
        });
        document.getElementById('btnAlchemy')?.addEventListener('click', renderStrip);
      })();

      /* ---------- QA overlay & hooks ---------- */
      (function () {
        const panel = document.getElementById('apxQA'), closeBtn = document.getElementById('apxQAclose');
        const tgl = () => { panel.style.display = panel.style.display === 'none' ? 'block' : 'none'; };
        // expose toggle for Settings button (assign globally on window)
        window.toggleApexQA = tgl;
        closeBtn?.addEventListener('click', tgl);
        window.addEventListener('keydown', (e) => { if (e.key === '`') { tgl(); } });
        document.getElementById('qaSpawnMini')?.addEventListener('click', () => StageMgr.forceMiniboss());
        document.getElementById('qaSpawnBoss')?.addEventListener('click', () => StageMgr.forceBoss());
        document.getElementById('qaChestTrio')?.addEventListener('click', () => { APEX.spawnChest('gold'); APEX.spawnChest('weapon'); APEX.spawnChest('mimic'); });
        document.getElementById('qaResetSoft')?.addEventListener('click', () => Skills.resetSoft());
        document.getElementById('qaResetHard')?.addEventListener('click', () => Skills.resetHard());
        document.getElementById('qaAutoTwo')?.addEventListener('click', () => StageMgr.autoTestTwoBosses());
        document.getElementById('qaInteractDbg')?.addEventListener('click', () => notify('Interact debug toggled'));
        // Force egg drops as items (B/A/S/SS)
        const egg = (rank) => { addItemToBag({ id: Math.random(), type: 'box', name: rank + ' Egg', rank, stackable: true }); notify(rank + ' Egg granted'); };
        document.getElementById('qaEggB')?.addEventListener('click', () => egg('B'));
        document.getElementById('qaEggA')?.addEventListener('click', () => egg('A'));
        document.getElementById('qaEggS')?.addEventListener('click', () => egg('S'));
        document.getElementById('qaEggSS')?.addEventListener('click', () => egg('SS'));
      })();

      /* ---------- One‑time Auto‑test (beats 2 bosses) ---------- */
      (function () {
        const K = 'apx.auto2.done';
        if (!localStorage.getItem(K)) {
          setTimeout(() => StageMgr.autoTestTwoBosses(), 1200);
          localStorage.setItem(K, '1');
        }
      })();

      /* ---------- Auto‑boot ---------- */
      window.addEventListener('load', () => {
        try { StageMgr.start(1); } catch (e) { console.warn('StageMgr start failed', e); }
        setTimeout(preDone, 500);
      });
    })();</script>
  <!-- ONECLICK_END -->
  <script>
    // ===== APEX PATCH: “Playable now” pass  =====
    (function () {
      const DESIGN_W = 1280, DESIGN_H = 720;
      function getDomSprites() {
        let d = document.getElementById('domSprites');
        if (!d) {
          d = document.createElement('div');
          d.id = 'domSprites';
          d.style.cssText = 'position:absolute;left:0;top:0;right:0;bottom:0;pointer-events:none';
          (document.getElementById('wrap') || document.body).appendChild(d);
        }
        return d;
      }
      const cv = document.getElementById('cv'), wrap = document.getElementById('wrap'), domLayer = getDomSprites();
      /* -------- Global feature flags -------- */
      const VFX_OFF = true;                      // disable heavy skill VFX for now (keep A1 slash)
      const MAX_PLAYER_SHOTS = 70, MAX_ENEMY_SHOTS = 80; // caps

      /* -------- Asset loading removed in favor of procedural drawing -------- */
      const assets = {}; // Keep empty object for compatibility with any remaining code that might reference it.

      /* -------- Helpers -------- */
      const $ = q => document.querySelector(q);
      function worldToCss(x, y) {
        const rect = cv.getBoundingClientRect();
        const scaleX = rect.width / DESIGN_W, scaleY = rect.height / DESIGN_H;
        return { x: rect.left + x * scaleX, y: rect.top + y * scaleY, sx: scaleX, sy: scaleY };
      }
      function clamp(v, a, b) { return v < a ? a : v > b ? b : v; }

      /* -------- Action button (new) -------- */
      const btnAct = document.getElementById('btnActionNew');
      let currentAction = null; // {kind:'open'|'pick'|'use', ref}
      function findNearby() {
        // very light scan around leader; you already track pickups/chests
        const Ld = typeof leader === 'function' ? leader() : (st.players[st.leader] || st.players[0]);
        const all = []
          .concat(st.pickups || [])
          .concat(st._chests || []);
        let best = null, bd = 1e9;
        for (const it of all) {
          const dx = (it.x || Ld.x) - Ld.x, dy = (it.y || Ld.y) - Ld.y, d = Math.hypot(dx, dy);
          if (d < 120 && d < bd) { bd = d; best = it; }
        }
        return best;
      }
      function refreshAction() {
        const t = findNearby();
        if (!t) { currentAction = st.equippedToy ? { kind: 'use' } : null; btnAct.textContent = currentAction ? 'Use' : 'Action'; return; }
        if (t.kind === 'chest' || t.type === 'chest') { currentAction = { kind: 'open', ref: t }; btnAct.textContent = 'Open'; }
        else { currentAction = { kind: 'pick', ref: t }; btnAct.textContent = 'Pick'; }
      }
      setInterval(refreshAction, 180);
      btnAct?.addEventListener('click', () => {
        if (!currentAction) { return; }
        if (currentAction.kind === 'open') { (window.openChestInstant || openChestInstant)(currentAction.ref); }
        else if (currentAction.kind === 'pick') { (window.pickupInstant || pickupInstant)(currentAction.ref); }
        else if (currentAction.kind === 'use') {
          try {
            if (st.equippedToy && typeof useActionToy === 'function') {
              const toyType = st.equippedToy;
              if (useActionToy(toyType)) { st.equippedToy = null; }
            }
          } catch (_) { }
        }
        currentAction = null; refreshAction();
      });

      /* -------- Pets & Vehicles (DOM sprites, overhead bars, skill chip) -------- */
      const dom = { pet: null, petHP: null, petSkill: null, veh: null, vehFuel: null };
      function ensureEl(kind) {
        if (kind === 'pet' && !dom.pet) {
          dom.pet = document.createElement('img'); dom.pet.className = 'sprite'; dom.pet.src = assets.PET ? assets.PET.src : '';
          dom.pet.style.background = assets.PET ? 'transparent' : '#c1ffc1'; wrap.appendChild(dom.pet);
          dom.petHP = document.createElement('div'); dom.petHP.className = 'barlet'; dom.petHP.innerHTML = '<i class="barlet-hp-bar" style="transform:scaleX(1)"></i>'; wrap.appendChild(dom.petHP);
          dom.petSkill = document.createElement('div'); dom.petSkill.className = 'pet-skill'; dom.petSkill.textContent = 'S'; dom.petSkill.title = 'Pet Skill'; dom.petSkill.onclick = () => { petBurst(); };
          wrap.appendChild(dom.petSkill);
        }
        if (kind === 'veh' && !dom.veh) {
          dom.veh = document.createElement('img'); dom.veh.className = 'sprite'; dom.veh.src = assets.VEH ? assets.VEH.src : '';
          dom.veh.style.background = assets.VEH ? 'transparent' : '#e6e6fa'; wrap.appendChild(dom.veh);
          dom.vehFuel = document.createElement('div'); dom.vehFuel.className = 'barlet fuelbar'; dom.vehFuel.innerHTML = '<i class="barlet-fuel-bar" style="transform:scaleX(1)"></i>'; wrap.appendChild(dom.vehFuel);
        }
      }
      function place(el, x, y) { const p = worldToCss(x, y); Object.assign(el.style, { left: (p.x - 24) + 'px', top: (p.y - 48) + 'px' }); }
      function placeBar(el, x, y, t) { const p = worldToCss(x, y); Object.assign(el.style, { left: (p.x - 20) + 'px', top: (p.y - (t === 'fuel' ? -8 : 54)) + 'px' }); }
      function placeSkill(el, x, y) { const p = worldToCss(x, y); Object.assign(el.style, { left: (p.x - 10) + 'px', top: (p.y - 74) + 'px', pointerEvents: 'auto' }); }

      // game‑state helpers
      function L() { return (typeof leader === 'function') ? leader() : (st.players[st.leader] || st.players[0]); }
      function nearestEnemy(p) { let best = null, bd = 1e9; for (const e of st.enemies || []) { if ((e.hp || 0) <= 0) continue; const d = Math.hypot((e.x - p.x), (e.y - p.y)); if (d < bd) { bd = d; best = e; } } return best; }

      // PET: summon/recall + auto‑fire
      st._pet = st._pet || { alive: false, hp: 100, hpMax: 100, cd: 0 };
      function summonPet() {
        st._pet.alive = true; notify('Pet summoned');
        ensureEl('pet');
      }
      function recallPet() { st._pet.alive = false;[dom.pet, dom.petHP, dom.petSkill].forEach(n => { if (n) n.style.display = 'none'; }); notify('Pet recalled'); }
      function petBurst() {
        if (!st._pet.alive) return;
        const p = L(), tgt = nearestEnemy(p) || { x: p.x + 160, y: p.y };
        // simple 3‑shot burst
        for (let i = 0; i < 3; i++) setTimeout(() => { st.shots.length < MAX_PLAYER_SHOTS && st.shots.push({ x: p.x + 20, y: p.y - 32, vx: 320, vy: -20 + i * 20, speed: 320, dmg: 18, life: 800, ownerId: 'Pet' }); }, i * 80);
      }
      document.getElementById('btnPet')?.addEventListener('click', () => { st._pet.alive ? recallPet() : summonPet(); });

      // VEH: board/disembark; fuel drains only while boarded
      // Legacy free vehicle toggle disabled; handled by equipped-vehicle capture listener

      // HUD update loop for sprites/bars
      setInterval(() => {
        const l = L(); if (!l) return;
        // pet
        if (st._pet.alive) {
          dom.pet?.style && (dom.pet.style.display = 'block'); dom.petHP?.style && (dom.petHP.style.display = 'block'); dom.petSkill?.style && (dom.petSkill.style.display = 'block');
          const px = l.x + 36, py = l.y; place(dom.pet, px, py); placeBar(dom.petHP, px, py, 'hp'); placeSkill(dom.petSkill, px, py);
          const r = clamp(st._pet.hp / st._pet.hpMax, 0, 1); dom.petHP.querySelector('i').style.transform = 'scaleX(' + r + ')';
          // auto fire every ~1.2s
          st._pet.cd = Math.max(0, st._pet.cd - (st.dt || 0) * 1000); if (st._pet.cd <= 0) { st._pet.cd = 1200; petBurst(); }
        }
        // veh
        if (st?._veh?.boarded) {
          dom.veh?.style && (dom.veh.style.display = 'block'); dom.vehFuel?.style && (dom.vehFuel.style.display = 'block');
          const vx = l.x + 8, vy = l.y; place(dom.veh, vx, vy); placeBar(dom.vehFuel, vx, vy, 'fuel');
          st._veh.fuel = clamp(st._veh.fuel - 0.04, 0, st._veh.fuelMax);
          const fuelI = dom.vehFuel?.querySelector('i');
          if (fuelI) fuelI.style.transform = 'scaleX(' + (st._veh.fuel / st._veh.fuelMax) + ')';
        } else { if (dom.veh) { dom.veh.style.display = 'none'; } if (dom.vehFuel) { dom.vehFuel.style.display = 'none'; } }

        // A1 clones overlay (HP bar + Lv label)
        try {
          wrap._cloneDom = wrap._cloneDom || [];
          const clones = st.clones || [];
          // Ensure DOM nodes
          for (let i = 0; i < clones.length; i++) {
            if (!wrap._cloneDom[i]) {
              const node = document.createElement('div'); node.className = 'sprite'; node.style.background = '#9a6bff';
              const bar = document.createElement('div'); bar.className = 'barlet'; bar.innerHTML = '<i class="barlet-hp-bar" style="transform:scaleX(1)"></i>';
              const lbl = document.createElement('div'); lbl.className = 'clone-level-label'; lbl.textContent = 'Lv1';
              node.appendChild(lbl); wrap.appendChild(node); wrap.appendChild(bar);
              wrap._cloneDom[i] = { node, bar, lbl };
            }
            const c = clones[i]; const u = wrap._cloneDom[i]; u.node.style.display = 'block'; u.bar.style.display = 'block';
            place(u.node, c.x || l.x, c.y || l.y); placeBar(u.bar, c.x || l.x, c.y || l.y, 'hp');
            const ratio = clamp((c.hp || 0) / (c.hpMax || 1), 0, 1); u.bar.querySelector('i').style.transform = 'scaleX(' + ratio + ')'; u.lbl.textContent = 'Lv' + (c.level || 1);
          }
          // Hide extras
          for (let i = clones.length; i < (wrap._cloneDom?.length || 0); i++) { const u = wrap._cloneDom[i]; if (u) { u.node.style.display = 'none'; u.bar.style.display = 'none'; } }
        } catch (_e) { }
      }, 1000 / 30);

      /* -------- Projectile clamps -------- */
      const _pushShots = st.shots.push.bind(st.shots), _pushEShots = st.eShots.push.bind(st.eShots);
      st.shots.push = function () { if (st.shots.length >= MAX_PLAYER_SHOTS) return st.shots.length; return _pushShots.apply(st.shots, arguments); };
      st.eShots.push = function () { if (st.eShots.length >= MAX_ENEMY_SHOTS) return st.eShots.length; return _pushEShots.apply(st.eShots, arguments); };

      /* -------- Open All (bags/gifts/S‑Box) + Chest open helpers -------- */
      window.openChestInstant = function (c) { try { if (c.opened) return; c.opened = true; notify('Chest opened'); st.gold = (st.gold || 0) + 300; } catch (_) { } };
      window.pickupInstant = function (p) {
        try {
          if (!p) return;
          p.taken = true;
          // If this pickup is an action toy, equip it for single-use via Action button
          if (p.type === 'toy' || p.toyType || p.toy) {
            const toyType = p.toyType || p.toy;
            if (toyType) {
              st.equippedToy = toyType;
              notify('Equipped Toy: ' + (toyType || 'Unknown'), '#6aa8ff');
            } else {
              notify('Picked', '#6aa8ff');
            }
          } else {
            notify('Picked');
          }
        } catch (_) { }
      };
      document.getElementById('btnOpenAll')?.addEventListener('click', () => {
        const items = st.inv || []; let opened = 0;
        for (const it of items) {
          if (it.type === 'bag' || it.type === 'gift' || it.type === 's_box') {
            opened++; // grant some loot
            st.gold += Math.floor(200 + Math.random() * 1200);
            if (it.type === 's_box') { st.gear = st.gear || []; st.gear.push({ id: Math.random(), name: 'S‑Rank Relic', type: 'gear', slot: 'acc1', rank: 'S', atk: 28 }); }
            it._opened = true;
          }
        }
        notify('Opened ' + opened + ' items');
      });

      /* -------- Simple weapon fusion (same name → Fused → +20 ATK after 2nd) -------- */
      window.fuseWeapons = function (a, b) {
        if (!a || !b) return notify('Select two weapons to fuse');
        if (a.slot !== 'weapon' || b.slot !== 'weapon' || a.name !== b.name) return notify('Need two identical weapons');
        a.fuse = (a.fuse || 0) + 1; a.atk = (a.atk || 10) + (a.fuse >= 2 ? 20 : 10); a.name = a.name.replace(/\s*\(Fused.*\)$/, '') + ' (Fused x' + a.fuse + ')';
        // remove b from bag
        const idx = st.inv.indexOf(b); if (idx >= 0) st.inv.splice(idx, 1);
        notify('Fusion success: ' + a.name);
      }
      document.getElementById('btnAutoFuse')?.addEventListener('click', () => {
        // pair by name
        const pool = (st.inv || []).filter(i => i.slot === 'weapon');
        pool.sort((x, y) => x.name.localeCompare(y.name));
        for (let i = 0; i < pool.length - 1; i++) { if (pool[i].name === pool[i + 1].name) { fuseWeapons(pool[i], pool[i + 1]); i++; } }
      });

      /* -------- Stats/Evolution drawer wiring -------- */
      function xpToNext(lv) { return 80 + (lv - 1) * 50; }
      function refreshStats() {
        document.getElementById('statLevel').textContent = st.level | 0;
        document.getElementById('statXP').textContent = st.xp | 0;
        document.getElementById('statXPTo').textContent = xpToNext(st.level);
        document.getElementById('statATK').textContent = (leader().dmg | 0);
        document.getElementById('statDEF').textContent = st.def || 0;
        document.getElementById('statHP').textContent = (leader().hpMax | 0);
        const r = Math.max(0, Math.min(1, st.xp / xpToNext(st.level))); document.getElementById('statsXpFill').style.transform = 'scaleX(' + r + ')';
        document.getElementById('btnEvolve').disabled = !(st.level >= 10 && (st.bossKills || 0) >= 2);
      }
      setInterval(refreshStats, 400);
      document.getElementById('btnEvolve')?.addEventListener('click', () => {
        if (st.level >= 10 && (st.bossKills || 0) >= 2) {
          const a = leader(); a.dmg += 15; a.hpMax += 80; a.hp = Math.min(a.hp + a.hpMax, a.hpMax);
          addFloater(a.x, a.y - 80, 'EVOLVED!', '#ffd56a');
          notify('Evolution applied (+15 ATK, +80 HP)');
        }
        refreshStats();
      });

      /* -------- QA Tools -------- */
      document.getElementById('qaMaxGold')?.addEventListener('click', () => {
        // grant a truly massive amount of currency
        const bigNum = 999999999999;
        st.gold = bigNum;
        st.silver = bigNum;
        // update UI for both gold and silver (if present)
        const gv = document.getElementById('goldVal'); if (gv) gv.textContent = st.gold;
        const bgv = document.getElementById('bagGoldVal'); if (bgv) bgv.textContent = st.gold;
        notify('Gold & Silver maxed');
      });
      document.getElementById('qaGems')?.addEventListener('click', () => { st.gems = (st.gems || 0) + 500; const gemEl = document.getElementById('gemVal'); if (gemEl) gemEl.textContent = st.gems; notify('+500 Gems'); });
      document.getElementById('qaStagePlus')?.addEventListener('click', () => { st.stage = (st.stage || 1) + 1; addFloater(DESIGN_W / 2, 80, 'Stage ' + st.stage, '#6aa8ff'); });
      document.getElementById('qaStageMinus')?.addEventListener('click', () => { st.stage = Math.max(1, (st.stage || 1) - 1); addFloater(DESIGN_W / 2, 80, 'Stage ' + st.stage, '#6aa8ff'); });
      document.getElementById('qaSkipBoss')?.addEventListener('click', () => {
        try {
          if (window.StageMgr?.forceBoss) {
            StageMgr.forceBoss();
          } else {
            if (window.__PROG95) {
              st.waveStep = 18; // Wave 9.5
            } else {
              st.wave = 10;
            }
            addFloater(DESIGN_W / 2, 80, 'Boss!', '#ff8c6a');
          }
        } catch (_) { }
      });
      document.getElementById('qaKeys')?.addEventListener('click', () => { st.giftKeys = (st.giftKeys || 0) + 3; st.bossKeys = (st.bossKeys || 0) + 3; notify('+3 keys each'); });
      document.getElementById('qaChestTrioAlt')?.addEventListener('click', () => { if (window.APEX?.spawnChest) { APEX.spawnChest('gold'); APEX.spawnChest('weapon'); APEX.spawnChest('mimic'); } });

      // God Mode: grant extremely large currency and buff stats drastically
      document.getElementById('qaGodMode')?.addEventListener('click', () => {
        const huge = 999999999999;
        st.gold = huge;
        st.silver = huge;
        st.gems = huge;
        // massively boost player stats
        for (const p of st.players) {
          p.hpMax = 99999;
          p.hp = p.hpMax;
          p.dmgBase = (p.dmgBase || p.dmg || 10) * 20;
          p.dmg = p.dmgBase;
        }
        // update UI values
        const gv = document.getElementById('goldVal'); if (gv) gv.textContent = st.gold;
        const bgv = document.getElementById('bagGoldVal'); if (bgv) bgv.textContent = st.gold;
        const gemv = document.getElementById('gemVal'); if (gemv) gemv.textContent = st.gems;
        notify('God Mode activated!', '');
      });

      /* -------- Backtick toggle setting -------- */
      addEventListener('keydown', (e) => { if (e.key === '`') { const allow = document.getElementById('setting-backtick')?.checked; if (allow) document.getElementById('inventory').classList.toggle('open'); } });

      /* -------- Skill/VFX trimmer -------- */
      if (VFX_OFF) {
        // wipe heavy S2/S3 by making cds never ready, keep A1 S1 only; followers basic fire handled by Battle Reference auto
        st.cds.A1.S2 = st.cds.A1.S3 = 999999;
        st.cds.Unique.S1 = st.cds.Unique.S2 = st.cds.Unique.S3 = 999999;
        st.cds.Missy.S1 = st.cds.Missy.S2 = st.cds.Missy.S3 = 999999;
      }
    })();
  </script>
  <!-- ==== APEX HOTFIX r7: bulk-open, action microbtn, pets/veh canvas entities, rage/secret, spam clamp, boss scale ==== -->
  <script>
    (function () {
      'use strict';
      /* ---------- shorthands ---------- */
      const $ = (q) => document.querySelector(q);
      const notify = (m, c) => { try { const w = document.getElementById('notificationWrap') || (() => { const d = document.createElement('div'); d.id = 'notificationWrap'; document.body.appendChild(d); return d })(); const t = document.createElement('div'); t.className = 'toast'; if (c) t.style.borderColor = c; t.textContent = m; w.appendChild(t); setTimeout(() => t.remove(), 1600); } catch (_) { } };
      const L = () => (st.players?.[st.leader || 0]) || st.players?.[0] || { x: DESIGN_W / 2, y: DESIGN_H - 120, hp: 100, hpMax: 100 };
      /* ---------- 0) Ensure compact micro actions exist (Act between Pet/Veh) ---------- */
      (function ensureMicroRow() {
        if ($('#btnActionNew')) return;
        const actions = document.querySelector('.actions'); if (!actions) return;
        const row = document.createElement('div'); row.className = 'micro-actions';
        row.style.display = 'flex'; row.style.flexDirection = 'column'; row.style.gap = '6px';
        const top = document.createElement('div');
        top.innerHTML = '<button class="btn-micro" id="btnBag">Bag</button>';
  const bottom = document.createElement('div');
  bottom.innerHTML = '<button class="btn-micro" id="btnPet">Pet</button><button class="btn-micro" id="btnVeh">Veh</button><button class="btn-micro" id="btnActionNew">Act</button><button class="btn-micro" id="btnRage">Rage</button>';
        row.appendChild(top); row.appendChild(bottom); actions.appendChild(row);

        // Wire Bag button to open inventory overlay
        setTimeout(() => {
          const btnBag = $('#btnBag');
          if (btnBag) {
            btnBag.addEventListener('click', () => {
              const inv = document.getElementById('inventory');
              if (inv) inv.classList.add('open');
              if (window.st) st.bagOpen = true;
            });
          }
        }, 100);
      })();

      /* ---------- 1) Bulk Open (bags/gifts/boxes/S-Box etc) ---------- */
      function grantLootFromBox(it) {
        st.gold = (st.gold || 0) + Math.floor(200 + Math.random() * 1200);
        st.silver = (st.silver || 0) + Math.floor(10 + Math.random() * 90);
        if (it.type === 's_box') {
          st.inv = st.inv || [];
          st.inv.push({ id: Math.random(), type: 'gear', slot: 'acc1', rank: 'S', name: 'S-Rank Relic', atk: 28 });
        }
        if (it.type === 'boss_skip_pass') { st.bossKeys = (st.bossKeys || 0) + 1; }
        it._opened = true;
      }
      function autoOpenAll() {
        const openables = new Set(['gold_bag', 'big_gold_bag', 'bag', 'gift', 'box', 's_box', 'treasure_box', 'super_equipment_pack', 'big_box', 'gear_kit', 'pet_box', 'vehicle_box', 'boss_skip_pass']);
        const items = st.inv || []; let opened = 0;
        for (const it of items) { if (openables.has(it.type)) { grantLootFromBox(it); opened++; } }
        // remove opened
        st.inv = items.filter(x => !x._opened);
        // refresh UI if present
        $('#goldVal') && ($('#goldVal').textContent = st.gold | 0);
        $('#bagGoldVal') && ($('#bagGoldVal').textContent = st.gold | 0);
        if (typeof renderBag === 'function') renderBag();
        notify('Opened ' + opened + ' items');
      }

      // expose improved bulk opener globally so other listeners call this version
      try { window.autoOpenAll = autoOpenAll; } catch (_) { }
      // Override bag open button to use the global autoOpenAll if available (invoke on click)
      // Always call the improved opener from window if present, otherwise fall back to the local
      if (document.getElementById('btnOpenAll')) {
        document.getElementById('btnOpenAll').onclick = () => { (window.autoOpenAll || autoOpenAll)(); };
      }

      /* ---------- 2) Context Act button (Open / Pick) ---------- */
      function findNearby(kind) {
        const P = L(); let best = null, bd = (kind === 'chest' ? 120 : 80);
        const list = (st.interactables || []).concat(st.pickups || []);
        for (const o of list) { if (kind && o.kind !== kind) continue; const d = Math.hypot((o.x - P.x), (o.y - P.y)); if (d < bd) { bd = d; best = o; } }
        return best;
      }
      // Act button behavior: enter house (with confirm) or interact/pickup; inside house => interact
      $('#btnActionNew') && $('#btnActionNew').addEventListener('click', () => {
        try {
          if (window.HouseInterior?.active) { window.HouseInterior.interact(); return; }
          // If a house is near, show a small confirm and enter on Yes
          const H = (window.Platform?.layers?.houses) || [];
          const Lp = L(); let near = null;
          for (const h of H) { const d = h?.door; if (!d) continue; if (Math.abs((Lp?.x || 0) - d.x) < 70 && Math.abs((Lp?.y || 0) - d.y) < 100) { near = h; break; } }
          if (near) { try { window.HouseUI && HouseUI.confirmEnter(() => { window.enterNearestHouse && window.enterNearestHouse(); }); return; } catch (_) { } }
        } catch (_) { }
        const chest = findNearby('chest'); if (chest && typeof openChest === 'function') { openChest(chest); return; }
        const pick = findNearby(); if (pick && typeof pickup === 'function') { pickup(pick); return; }
        notify('Nothing to interact');
      });

      // Context refresher: update Act button label + glow
      (function refreshActButton() {
        const el = document.getElementById('btnActionNew'); if (!el) return;
        function update() {
          try {
            if (window.HouseInterior?.active) {
              const H = window.HouseInterior; const h = H.hero, D = H.objs?.door; let label = 'Act', glow = false;
              if (D && h && h.x > D.x && h.x < D.x + D.w && Math.abs(h.y - D.y) < 26) { label = 'Exit'; glow = true; }
              else if ((H.objs?.chests || []).some(c => !c.opened && Math.abs(h.x - c.x) < 26 && Math.abs(h.y - c.y) < 26)) { label = 'Open'; glow = true; }
              else if ((H.objs?.counters || []).some(c => Math.abs(h.x - c.x) < (c.w / 2 + 6) && Math.abs(h.y - c.y) < 26)) { label = 'Use'; glow = true; }
              else if ((H.objs?.npcs || []).some(n => Math.abs(h.x - n.x) < 26 && Math.abs(h.y - n.y) < 26)) { label = 'Talk'; glow = true; }
              el.textContent = label; el.classList.toggle('glow', glow); return;
            }
            const near = (window.nearHouseDoor && nearHouseDoor());
            if (near) { el.textContent = 'Enter'; el.classList.add('glow'); return; }
            const chest = findNearby('chest'); if (chest) { el.textContent = 'Open'; el.classList.add('glow'); return; }
            const pick = findNearby(); if (pick) { el.textContent = 'Pick'; el.classList.add('glow'); return; }
            el.textContent = 'Act'; el.classList.remove('glow');
          } catch (_) { el.classList.remove('glow'); }
        }
        setInterval(update, 150);
      })();

      /* ---------- 3) Friendlies as canvas entities (pets & vehicle) ---------- */
      st.pets = st.pets || [];
      st.vehicle = st.vehicle || null;
      st.breakables = st.breakables || [];
      function summonPet() {
        if (st.pets.length >= (st.petSlots || 1)) return notify('Pet slot full');
        const p = { x: L().x - 36, y: L().y - 8, hp: 100, hpMax: 100, cd: 0, rate: 1.2, dmg: 14, kind: 'pet' };
        try { applyBeastPetBonuses(p); } catch (_e) { }
        st.pets.push(p); notify('Pet summoned', '#36c777');
      }
      function recallPets() { st.pets.length = 0; notify('Pet recalled'); }
      function boardVeh() {
        if (st.vehicle) return disembarkVeh();
        st.vehicle = { x: L().x, y: L().y + 6, hp: 200, hpMax: 200, fuel: 1, fuelMax: 1, cd: 0, rate: 0.6, dmg: 18, kind: 'veh' };
        notify('Boarded vehicle', '#e6e6fa');
      }
      function disembarkVeh() { st.vehicle = null; notify('Disembarked'); }
      $('#btnPet') && $('#btnPet').addEventListener('click', () => { st.pets.length ? recallPets() : summonPet(); });
      // Legacy free vehicle board disabled; handled by equipped-vehicle capture listener

      function nearestEnemy(x, y) { let best = null, bd = 1e9; for (const e of st.enemies || []) { if (e.hp > 0) { const d = Math.hypot(e.x - x, e.y - y); if (d < bd) { bd = d; best = e; } } } return best; }
      function fire(p, dmg, spd = 560) {
        const e = nearestEnemy(p.x, p.y); if (!e) return;
        const ang = Math.atan2(e.y - p.y, e.x - p.x);
        st.shots.push({ x: p.x, y: p.y - 10, vx: Math.cos(ang) * spd, vy: Math.sin(ang) * spd, life: 0.85, speed: spd, dmg, owner: 'ally', pierce: 1 });
      }
      function updateFriendlies(dt) {
        const P = L();
        // pets follow and shoot
        for (const p of st.pets) { const own = (p.owner && p.owner.x != null) ? p.owner : P; p.x += ((own.x || P.x) - 36 - p.x) * 6 * dt; p.y += ((own.y || P.y) - 8 - p.y) * 6 * dt; p.cd -= dt; if (p.cd <= 0) { fire(p, p.dmg); p.cd = p.rate; } }
        // Unique drones orbit around owner and assist faster with aggression tiers
        try {
          const U = (st.players || []).find(h => h.id === 'Unique');
          if (U) {
            for (const d of (st.shots || [])) {
              if (d.kind === 'unique_module' && d.ownerId === U.id) {
                const tier = Math.max(0, d.aggrTier || 0);
                d.phase = (d.phase || 0) + dt * (1.2 + 0.35 * tier) * (1 + 0.04 * (d.level || 1));
                const R = Math.max(28, d.orbitR || 36) * (1 + 0.08 * tier);
                d.x = U.x + Math.cos(d.phase) * R;
                d.y = U.y - 20 + Math.sin(d.phase) * Math.max(18, R * 0.8);
                d._assistAcc = (d._assistAcc || 0) - dt; if (d._assistAcc <= 0) {
                  d._assistAcc = Math.max(0.06, (d.assistCD || 0.5) / 1000 * (1 - 0.15 * tier));
                  const e = nearestEnemy({ x: d.x, y: d.y }); if (e) { const ang = Math.atan2(e.y - d.y, e.x - d.x); const sp = 580; st.shots.push({ x: d.x, y: d.y, vx: Math.cos(ang) * sp, vy: Math.sin(ang) * sp, speed: sp, dmg: Math.round((U.dmg || 20) * (0.40 + 0.025 * (d.level || 1))), life: 1000, ownerId: U.id }); }
                }
              }
            }
          }
        } catch (_e) { }
        // A1 clones: follow and shoot, scale with level
        st.clones = st.clones || [];
        for (const c of st.clones) {
          // Chase nearest enemy if any; otherwise follow leader
          const e = nearestEnemy({ x: c.x || P.x, y: c.y || P.y });
          const tx = e ? e.x : (P.x + 36), ty = e ? e.y : (P.y - 8);
          c.x = (c.x || P.x) + (tx - (c.x || P.x)) * 6 * dt;
          c.y = (c.y || P.y) + (ty - (c.y || P.y)) * 6 * dt;
          c.cd = (c.cd || 0) - dt; if (c.cd <= 0) {
            // Sword X-waves: forward and slight backslash, scaled by aggrTier
            const tier = Math.floor((c.level || 1) / 5);
            const baseR = (CFG.A1?.xwave?.r) || 16; const sizeMul = 1.2 + 0.15 * tier;
            const dmg = Math.round((P.dmg || 20) * (c.atkMult || 1) * 0.6 * (1 + 0.06 * tier));
            spawnXWave(c, 0, 540, dmg, 2, 0.06, 1100, baseR * sizeMul);
            spawnXWave(c, -0.12, 540, Math.round(dmg * 0.9), 1, 0.04, 1000, baseR * (0.9 + 0.08 * tier));
            // Afterimage arcs for swordy feel
            for (let k = 0; k < 3; k++) { st.effects.push({ type: 'after', x: (c.x || 0) + k * 4, y: (c.y || 0) - 16, color: '#ff4d4f', life: 160, max: 160 }); }
            c.cd = Math.max(0.12, (0.45 / (1 + 0.12 * tier)));
          }
        }
        // Breakable chests: timers, falling, and projectile collision
        try {
          // timers + falling
          for (const b of (st.breakables || [])) {
            b.life = (b.life || 0) - dt * 1000; if (b.life <= 0) { b.hp = 0; continue; }
            if (b.vy != null) { b.y += b.vy * dt; b.vy += 600 * dt; if (b.groundY != null && b.y >= b.groundY) { b.y = b.groundY; b.vy = 0; } }
          }
          // collisions with player shots
          for (const s of (st.shots || [])) {
            if ((s.life || 0) <= 0 || (s.dmg || 0) <= 0) continue;
            for (const b of (st.breakables || [])) {
              if ((b.hp || 0) <= 0) continue;
              const w = b.w || 48, h = b.h || 48;
              if (Math.abs((s.x || 0) - (b.x || 0)) < w / 2 && Math.abs((s.y || 0) - (b.y || 0)) < h / 2) {
                b.hp = Math.max(0, (b.hp || 0) - (s.dmg || 0));
                consumeProjectilePierce(s);
                if ((b.hp || 0) <= 0) { try { if (typeof b.dropFn === 'function') b.dropFn(); notify('Chest Destroyed!'); } catch (_) { } }
                break;
              }
            }
          }
          // filter dead breakables
          st.breakables = (st.breakables || []).filter(bb => (bb.hp || 0) > 0);
        } catch (_) { }

        // vehicle follows and shoots
        if (st.vehicle) { const v = st.vehicle; v.x += (P.x - v.x) * 10 * dt; v.y += (P.y + 6 - v.y) * 10 * dt; v.fuel = Math.max(0, v.fuel - 0.02 * dt); v.cd -= dt; if (v.cd <= 0) { fire({ x: v.x + 18, y: v.y - 10 }, v.dmg, 620); v.cd = v.rate; } if (v.fuel <= 0) disembarkVeh(); }
      }
      function drawFriendlies(ctx) {
        // pets
        ctx.save();
        for (const p of st.pets) {
          // Draw pet sprite when available, otherwise fallback rectangle
          const petImg = (window.petSprites && window.petSprites[p.name]);
          const pw = 28, ph = 28;
          if (petImg && petImg.complete) {
            ctx.drawImage(petImg, p.x - pw / 2, p.y - ph / 2, pw, ph);
          } else {
            ctx.fillStyle = 'rgba(193,255,193,.95)';
            ctx.fillRect(p.x - 10, p.y - 18, 20, 18);
          }
          // HP bar above pet
          ctx.fillStyle = '#15243a'; ctx.fillRect(p.x - 16, p.y - (ph / 2) - 8, 32, 4);
          ctx.fillStyle = '#36c777'; ctx.fillRect(p.x - 16, p.y - (ph / 2) - 8, 32 * Math.max(0, (p.hp || 0) / Math.max(1, p.hpMax || 1)), 4);
        }
        // unique drones (assist modules)
        for (const d of (st.shots || [])) {
          if (d.kind === 'unique_module') {
            ctx.fillStyle = 'rgba(134,255,233,.95)'; ctx.fillRect((d.x || 0) - 8, (d.y || 0) - 8, 16, 16);
            // HP bar + level
            ctx.fillStyle = '#15243a'; ctx.fillRect((d.x || 0) - 14, (d.y || 0) - 16, 28, 3);
            if (d.hpMax) { ctx.fillStyle = '#86ffe9'; ctx.fillRect((d.x || 0) - 14, (d.y || 0) - 16, 28 * Math.max(0, (d.hp || 0) / (d.hpMax || 1)), 3); }
            ctx.fillStyle = '#b9e7ff'; ctx.font = '600 10px ui-monospace'; ctx.textAlign = 'center'; ctx.fillText('Lv' + (d.level || 1), (d.x || 0), (d.y || 0) - 20);
          }
        }
        if (st.vehicle) { const v = st.vehicle; ctx.fillStyle = 'rgba(230,230,250,.95)'; ctx.fillRect(v.x - 22, v.y - 12, 44, 14); ctx.fillStyle = '#15243a'; ctx.fillRect(v.x - 24, v.y - 22, 48, 4); ctx.fillStyle = '#ffaa00'; ctx.fillRect(v.x - 24, v.y - 22, 48 * (v.fuel / v.fuelMax), 4); }

        // Clone stance ring indicator
        try {
          const stanceColors = { assault: '#ff4d4f', defend: '#6aa8ff', support: '#36c777' };
          for (const c of (st.clones || [])) {
            if (!c || c.isDefeated) continue;
            ctx.strokeStyle = stanceColors[c.stance || 'assault'] || '#ffffff';
            ctx.lineWidth = 2;
            ctx.globalAlpha = 0.7;
            ctx.beginPath(); ctx.arc((c.x || 0), (c.y || 0) - 9, 15, 0, Math.PI * 2); ctx.stroke();
            ctx.globalAlpha = 1;
          }
        } catch (_e) { }


        ctx.restore();

        // Game Over overlay
        if (st.isGameOver) {
          ctx.save();
          ctx.fillStyle = 'rgba(0,0,0,0.6)';
          ctx.fillRect(0, 0, DESIGN_W, DESIGN_H);
          ctx.fillStyle = '#ff4f4f';
          ctx.font = '60px ui-sans-serif';
          ctx.textAlign = 'center';
          ctx.fillText('GAME OVER', DESIGN_W / 2, DESIGN_H / 2);
          ctx.textAlign = 'left';
          ctx.restore();
        }
      }
      // Hook into your loop without rewriting it: wrap update/draw if present.
      const _upd = window.update; window.update = function (dt) { _upd && _upd(dt); updateFriendlies(dt); };
      const _draw = window.draw; window.draw = function () { _draw && _draw(); drawFriendlies(cv.getContext('2d')); };

      /* ---------- 4) Enemy spam clamp + boss scale ---------- */
      if (st && st.eShots && st.eShots.push) {
        const _pushE = st.eShots.push.bind(st.eShots);
        st.eShots.push = function () { if (st.eShots.length >= 80) return st.eShots.length; return _pushE.apply(st.eShots, arguments); };
      }
      // flag to upscale boss rendering paths that already read scale (no visual if engine ignores it)
      st._bossScale = 1.25;

      /* ---------- 5) Rage & Secret wiring ---------- */
      st.rage = st.rage || 0; st.rageActive = false;
      function tickRage(dt) {
        if (st.rageActive) {
          st.rage = Math.max(0, st.rage - dt * 22);
          // speed up all cooldown clocks while raging
          if (st.cds) { for (const k in st.cds) { const row = st.cds[k] || {}; for (const s in row) { if (typeof row[s] === 'number') { row[s] = Math.max(0, row[s] - dt * 2.5); } } } }
          if (st.rage <= 0) { st.rageActive = false; notify('Rage ended'); }
        }
      }
      const _upd2 = window.update; window.update = function (dt) { _upd2 && _upd2(dt); updateFriendlies(dt); tickRage(dt); };
      // Rage/Secret handled at per-player level; ensure Secret button binds
      const _bs = document.getElementById('btnSecret'); if (_bs) { _bs.addEventListener('click', () => { tryActivateSecretFor(leader()); }); }

      /* ---------- 6) QA helpers (menu already exposes “Open QA”) ---------- */
      $('#btnOpenQA') && $('#btnOpenQA').addEventListener('click', () => { try { window.toggleApexQA && window.toggleApexQA(); } catch (_) { } });
      window.qaMaxGold = () => { st.gold = 999999; $('#goldVal') && ($('#goldVal').textContent = st.gold); $('#bagGoldVal') && ($('#bagGoldVal').textContent = st.gold); };
      // On load, hide the legacy pet ready gauge and duration ring / chest prompt overlays
      try {
        const pr = document.getElementById('petReady'); if (pr) pr.classList.add('hidden');
        document.querySelectorAll('.duration-ring').forEach(el => { el.classList.add('hidden'); });
        const apxi = document.getElementById('apxInteract'); if (apxi) apxi.classList.add('hidden');
      } catch (e) { }
    })();
  </script>
  <!-- ===== APEX Patch r9: GameOver+Revive • Economy • Boss-only • Shop in Bag • QA Lite ===== -->
  <style>
    /* QA Lite & Overlays */
    #qaLite {
      position: fixed;
      right: 12px;
      top: 12px;
      width: 280px;
      max-height: 70vh;
      overflow: auto;
      background: #0f1826;
      border: 1px solid #293854;
      border-radius: 8px;
      box-shadow: 0 8px 28px rgba(0, 0, 0, .45);
      z-index: 100000;
      display: none
    }

    #qaLite header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 8px 10px;
      border-bottom: 1px solid #293854;
      color: #e9f4ff;
      font: 600 12px system-ui
    }

    #qaLite .b {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      padding: 10px
    }

    #qaLite button {
      background: #1a263a;
      color: #d7e9ff;
      border: 1px solid #3b4d71;
      border-radius: 6px;
      padding: 6px 8px;
      font: 600 11px system-ui;
      cursor: pointer
    }

    #countdownPane {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, .55);
      z-index: 90000;
      color: #e9f4ff;
      font: 700 48px/1.1 system-ui;
      text-shadow: 0 2px 10px #000
    }

    #gameOverPane {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, .7);
      z-index: 95000
    }

    #gameOverPane .card {
      background: #0f1826;
      border: 1px solid #293854;
      border-radius: 10px;
      padding: 16px;
      min-width: 320px;
      color: #cfe3ff
    }

    #gameOverPane .row {
      display: flex;
      gap: 8px;
      justify-content: flex-end;
      margin-top: 10px
    }

    #gameOverPane h3 {
      margin: 0 0 6px
    }

    #goMsg {
      font-size: 12px;
      color: #9baec8
    }

    .hidden {
      display: none !important
    }

    #countdownPane.show {
      display: flex !important
    }
  </style>
  <div id="countdownPane">GO</div>
  <div id="gameOverPane">
    <div class="card">
      <h3>Game Over</h3>
      <div id="goMsg">All heroes are down.</div>
      <div class="row">
        <button id="btnGoRetry">Retry Stage</button>
        <button id="btnGoCont">Continue (10s Respawn)</button>
      </div>
    </div>
  </div>
  <div id="qaLite">
    <header><span>QA • Lite</span><button id="qaClose">✕</button></header>
    <div class="b">
      <button id="qaGod">God Mode</button>
      <button id="qaFunds">Max Funds</button>
      <button id="qaGifts">Give 1 Gifts</button>
      <button id="qaRevives">Give 5 Auto‑Revives</button>
      <button id="qaStage">Stage++</button>
      <button id="qaBoss">Boss Now</button>
      <button id="qaKillWave">Kill Wave</button>
      <button id="qaEndless">Endless Mode</button>
    </div>
  </div>
  <script>
    (() => {
      'use strict';
      const $ = q => document.querySelector(q), now = () => performance.now(), rnd = (a, b) => Math.floor(a + Math.random() * (b - a + 1));
      const L = () => (st.players?.[st.leader || 0]) || st.players?.[0] || { x: DESIGN_W / 2, y: DESIGN_H - 120 };

      /* 0) Start economy & HP boost */
      function refreshCurrencies() {
        $('#goldVal') && (goldVal.textContent = st.gold | 0); $('#bagGoldVal') && (bagGoldVal.textContent = st.gold | 0);
        $('#silverVal') && (silverVal.textContent = st.silver | 0); $('#ticketVal') && (ticketVal.textContent = st.tickets | 0); $('#gemVal') && (gemVal.textContent = st.gems | 0);
      }
      // always set minimum 2000 gold at boot
      st.gold = Math.max(2000, st.gold || 0);
      st.silver = st.silver || 0; st.tickets = st.tickets || 0; st.gems = st.gems || 0;
      refreshCurrencies();

      /* 1) Disable start countdown */
      st._countdownBoot = 1; // mark as already done
      try { const pane = $('#countdownPane'); if (pane) { pane.classList.remove('show'); pane.style.display = 'none'; } } catch (_e) { }

      /* 2) Economy: kill gold & drops */
      st._lastKills = st._lastKills || 0;
      function pushBag(it) { st.inv = st.inv || []; st.inv.push(it); if (typeof renderBag === 'function') renderBag(); }
      function tickKillIncome() {
        if ((st.kills | 0) > st._lastKills) {
          const inc = (st.kills | 0) - st._lastKills;
          for (let i = 0; i < inc; i++) {
            st.gold += rnd(100, 200);
            const r = Math.random(); if (r < 0.12) { pushBag({ id: Math.random(), type: 'gift', name: 'Gift Box' }); } else if (r < 0.18) { pushBag({ id: Math.random(), type: 'treasure_box', name: 'Enemy Chest' }); }
          }
          st._lastKills = st.kills | 0; refreshCurrencies();
        }
      }

      /* 3) Shop conversions inside Bag */
      function ensureShopTab() {
        const btnShop = $('#btnShop'); btnShop?.addEventListener('click', () => { openBagTab('shop'); });
        const grid = document.getElementById('shopGrid'); if (grid && !grid._apx) {
          grid._apx = 1;
          grid.innerHTML += `
          <div class="shop-item"><h5>Convert 1 Diamond</h5><p>+1000 Gold</p><button id="cvGem">Convert</button></div>
          <div class="shop-item"><h5>Convert 1 Ticket</h5><p>+5000 Gold</p><button id="cvTix">Convert</button></div>
        `;
          grid.querySelector('#cvGem').onclick = () => { if (st.gems > 0) { st.gems--; st.gold += 1000; refreshCurrencies(); notify('Converted 1 Diamond → 1000 Gold'); } else notify('No diamonds'); };
          grid.querySelector('#cvTix').onclick = () => { if (st.tickets > 0) { st.tickets--; st.gold += 5000; refreshCurrencies(); notify('Converted 1 Ticket → 5000 Gold'); } else notify('No tickets'); };
        }
      }
      function openBagTab(tab) {
        const bag = $('#inventory'); if (!bag) return; bag.classList.add('open');
        document.querySelectorAll('.bag-nav-item').forEach(b => b.classList.toggle('active', b.dataset.tab === tab));
        document.querySelectorAll('.bag-panel').forEach(p => p.classList.toggle('active', p.id === 'bag-' + tab));
      }
      ensureShopTab();

      /* 4) Auto-Revive & 10s Respawn */
      function hasAutoRevive() { return (st.inv || []).some(x => x.type === 'auto_revive'); }
      function consumeAutoRevive() { const i = (st.inv || []).findIndex(x => x.type === 'auto_revive'); if (i >= 0) { st.inv.splice(i, 1); if (typeof renderBag === 'function') renderBag(); return true; } return false; }
      function handleDeaths(dt) {
        if (st.isGameOver) return; if (!Array.isArray(st.players)) return; let alive = 0, down = 0;
        for (const p of st.players) {
          if ((p.hp || 0) > 0) { alive++; continue; }
          if (!p._down) { if (hasAutoRevive() && consumeAutoRevive()) { p.hp = Math.ceil((p.hpMax || 200) * 0.4); notify('Auto‑Revive used! +40% HP', '#36c777'); } else { p._down = true; p.respawnAt = now() + 10000; } }
          if (p._down) { down++; if (now() >= p.respawnAt) { p._down = false; p.hp = p.hpMax || 200; const lead = L(); p.x = lead.x + rnd(-40, 40); p.y = lead.y + rnd(-10, 10); notify('Respawned'); } }
        }
        if (alive === 0 && down > 0 && !st._goShown) {
          st._goShown = 1; $('#gameOverPane').style.display = 'flex';
          $('#btnGoRetry').onclick = () => { st._goShown = 0; $('#gameOverPane').style.display = 'none'; try { StageMgr.start(st.stage || 1); } catch (_) { } };
          $('#btnGoCont').onclick = () => { st._goShown = 0; $('#gameOverPane').style.display = 'none'; };
        }
        document.querySelectorAll('.hero-portrait').forEach(node => {
          const id = node.id?.replace('hero', ''); const p = st.players?.find(q => q.id?.startsWith(id) || q.name === id) || null; if (!p) return;
          const status = node.querySelector('.hero-status'); if (p._down) { const left = Math.ceil((p.respawnAt - now()) / 1000); node.classList.add('defeated'); if (status) status.textContent = left > 0 ? left + 's' : 'ready'; }
          else { node.classList.remove('defeated'); if (status) status.textContent = 'OK'; }
          const fill = node.querySelector('.hero-hp-fill'); if (fill) { const r = (p.hp || 0) / (p.hpMax || 1); fill.style.transform = 'scaleX(' + Math.max(0, Math.min(1, r)) + ')'; }
        });
      }

      /* 5) Boss re-install and wave watcher */
      st._bossScale = 1.25;
      let lastWave = st.wave || 1;
      function onWaveChanged(w) {
        if (w === (st.wavesPerStage || 10)) { st.enemies = (st.enemies || []).filter(e => e.kind === 'boss'); st.bossAlive = true; st.bossMax = st.bossMax || 2400; st.bossHP = st.bossHP || st.bossMax; const f = document.getElementById('bossFill'); if (f) { const r = st.bossHP / st.bossMax; f.style.transform = 'scaleX(' + r + ')'; } }
        // Countdown disabled
      }
      // Allow enemy shots at all times; do not gate by bossAlive
      if (st && st.eShots && st.eShots.push) { const _push = st.eShots.push.bind(st.eShots); st.eShots.push = function (obj) { return _push(obj); }; }

      /* 6) QA Lite panel */
      const qa = $('#qaLite'); const toggleQA = () => { qa.style.display = qa.style.display === 'none' ? 'block' : 'none'; };
      $('#qaClose')?.addEventListener('click', toggleQA);
      window.addEventListener('keydown', (e) => { if (e.key === '`') toggleQA(); });
      $('#btnOpenQA')?.addEventListener('click', toggleQA);
      $('#qaGod')?.addEventListener('click', () => { st._god = !st._god; notify('God Mode: ' + (st._god ? 'ON' : 'OFF')); });
      $('#qaFunds')?.addEventListener('click', () => { st.gold = 999999; st.silver = 999999; st.tickets = 999; st.gems = 999; refreshCurrencies(); notify('Max funds granted'); });
      $('#qaGifts')?.addEventListener('click', () => { for (let i = 0; i < 20; i++) pushBag({ id: Math.random(), type: 'gift', name: 'Gift Box' }); notify('20 gifts added'); });
      $('#qaRevives')?.addEventListener('click', () => { for (let i = 0; i < 5; i++) pushBag({ id: Math.random(), type: 'auto_revive', name: 'Auto‑Revive' }); notify('5 Auto‑Revives added'); });
      $('#qaStage')?.addEventListener('click', () => {
        if (window.__PROG95) {
          st.waveStep = 18; // Jump to Wave 9.5
        } else {
          st.wave = (st.wavesPerStage || 10);
        }
        if (typeof onWaveChanged === 'function') onWaveChanged(st.wave);
        notify('Jumped to boss');
      });
      $('#qaBoss')?.addEventListener('click', () => {
        if (window.__PROG95) {
          st.waveStep = 18; // Jump to Wave 9.5
        } else {
          st.wave = (st.wavesPerStage || 10);
        }
        if (typeof onWaveChanged === 'function') onWaveChanged(st.wave);
      });
      $('#qaKillWave')?.addEventListener('click', () => { (st.enemies || []).forEach(e => e.hp = 0); st.kills = (st.kills | 0) + 20; });
      $('#qaEndless')?.addEventListener('click', () => {
        st.area = 100;
        st.stageInArea = 1;
        st.wave = 1;
        st.endlessMode = true;
        st.endlessUnlocked = true;
        st.enemies = [];
        notify('ENDLESS MODE ACTIVATED!', '#ffaa00');
        notify('Area 100 - Boss Rush Begins!', '#ff4444');
      });

      /* 7) Extend main loop */
      const origUpdate = window.update;
      window.update = function (dt) { origUpdate && origUpdate(dt); tickKillIncome(); handleDeaths(dt); if ((st.wave || 0) !== lastWave) { lastWave = st.wave || 0; onWaveChanged(lastWave); } if (st._god && Array.isArray(st.players)) { for (const p of st.players) { if (p.hp > 0) p.hp = Math.min(p.hpMax, p.hp + (dt * 0.02 * p.hpMax)); } } };

      /* 8) Enhance Open All (gifts/boxes) */
      function autoOpenAll() {
        const openables = new Set(['gold_bag', 'big_gold_bag', 'bag', 'gift', 'box', 's_box', 'treasure_box', 'super_equipment_pack', 'big_box', 'gear_kit', 'pet_box', 'vehicle_box', 'boss_skip_pass', 'auto_revive']); const items = st.inv || []; let opened = 0;
        for (const it of items) {
          if (openables.has(it.type)) {
            if (it.type === 's_box') { pushBag({ id: Math.random(), type: 'gear_kit', name: 'S‑Relic Pack' }); }
            if (it.type === 'auto_revive') continue;
            if (it.type.endsWith('_bag') || it.type === 'bag' || it.type === 'gift' || it.type === 'box' || it.type === 'treasure_box' || it.type === 'super_equipment_pack' || it.type === 'big_box' || it.type === 'gear_kit') { st.gold += rnd(200, 1200); }
            it._opened = true; opened++;
          }
        }
        st.inv = items.filter(x => !x._opened); if (typeof renderBag === 'function') renderBag(); refreshCurrencies(); notify('Opened ' + opened + ' items');
      };
      const btnOA = document.getElementById('btnOpenAll'); if (btnOA) { btnOA.onclick = autoOpenAll; }

    })();
  </script>
  <!-- ===== /APEX Patch r9 ===== -->
  <!-- ===== Performance/Difficulty Adjustments Patch ===== -->
  <script>
    (function () {
      // Reduce projectile speeds and cap shot counts, disable non-boss enemy skills
      if (window.st) {
        // Wrap shot pushers only once
        if (!st._perfTweaks) {
          const origPS = st.shots.push.bind(st.shots);
          st.shots.push = function (obj) {
            if (obj && typeof obj.vx === 'number') {
              obj.vx *= 0.5; obj.vy *= 0.5;
              if (obj.speed) obj.speed *= 0.5;
            }
            if (st.shots.length >= 35) return st.shots.length;
            return origPS(obj);
          };
          const origES = st.eShots.push.bind(st.eShots);
          st.eShots.push = function (obj) {
            if (!st.bossAlive) return st.eShots.length; // disable mob skills entirely
            if (obj && typeof obj.vx === 'number') {
              obj.vx *= 0.5; obj.vy *= 0.5;
              if (obj.speed) obj.speed *= 0.5;
            }
            if (st.eShots.length >= 40) return st.eShots.length;
            return origES(obj);
          };
          st._perfTweaks = true;
        }
        // Trim enemy numbers by 10% when wave starts
        let lastWaveNum = st.wave || 1;
        const origUpd = window.update;
        window.update = function (dt) {
          origUpd && origUpd(dt);
          if ((st.wave || 0) !== lastWaveNum) { lastWaveNum = st.wave || 0; st._enemyTrimmed = false; }
          if (!st._enemyTrimmed && st.enemies && st.enemies.length > 0) { const keep = Math.ceil(st.enemies.length * 0.9); st.enemies = st.enemies.slice(0, keep); st._enemyTrimmed = true; }
          // Reduce cooldown timers by 20% (faster recovery)
          if (st.cds) { for (const h in st.cds) { for (const s in st.cds[h]) st.cds[h][s] *= 0.8; } }
        };
      }
    })();
  </script>
  <!-- ===== /Performance/Difficulty Adjustments Patch ===== -->
  <!-- ===== Rage Core + Hold Meter + Planner (non-destructive scaffolding) ===== -->
  <script id="rage-core">
    (function () {
      'use strict';
      if (window.__RAGE_CORE__) return; window.__RAGE_CORE__ = true;

      // 0) Skill cooldowns and helpers (shared by player and clones)
      const SKILL_CD = { S1: 1600, S2: 3200, S3: 6500, S4: 5200, S5: 7200, X1: 9000 };
      function canCast(actor, key) {
        try {
          const now = performance.now();
          actor.cooldowns = actor.cooldowns || {};
          const t = actor.cooldowns[key] || 0;
          return now >= t;
        } catch (_) { return true; }
      }
      function startCd(actor, key, mult = 1) {
        try {
          const now = performance.now();
          actor.cooldowns = actor.cooldowns || {};
          const base = SKILL_CD[key] || 1500;
          actor.cooldowns[key] = now + base * mult;
        } catch (_) { }
      }
      window.SKILL_CD = SKILL_CD; window.canCast = canCast; window.startCd = startCd;

      // 1) Rage system
      const Rage = {
        active: false,
        toggle() { this.active = !this.active; try { notify && notify('Rage ' + (this.active ? 'ON' : 'OFF'), this.active ? '#ff4d4f' : '#6aa8ff'); } catch (_) { } },
        set(v) { this.active = !!v; }
      };
      window.Rage = Rage;
      // Wire the HUD button and a keybind
      setTimeout(() => { const b = document.getElementById('btnRage'); if (b && !b._rg) { b._rg = 1; b.addEventListener('click', () => Rage.toggle()); } }, 200);
      window.addEventListener('keydown', (e) => { if (e.code === 'KeyG') { Rage.toggle(); } });

      // 2) Hold meter tracking for S1/S2/S3
      const HOLD_THRESH = { S1: 350, S2: 350, S3: 600 };
      const holdState = { S1: null, S2: null, S3: null, any: null };
      function beginHold(skill) {
        const now = performance.now();
        holdState[skill] = { start: now, elapsed: 0, thresh: HOLD_THRESH[skill] || 350 };
        holdState.any = skill;
      }
      function endHold(skill) {
        const st = holdState[skill];
        holdState[skill] = null; if (holdState.any === skill) holdState.any = null;
        if (!st) return { held: false, ms: 0, mode: 'tap' };
        const ms = Math.max(0, performance.now() - st.start);
        const held = ms >= (HOLD_THRESH[skill] || 350);
        return { held, ms, mode: (Rage.active ? (held ? 'rageHold' : 'rageTap') : (held ? 'hold' : 'tap')) };
      }

      // 3) Central slash/X plan (initial S1/S3 only; others to follow)
      // Returns { slashes, cadenceMs, xs, xSize, xDmg, pierce, speed, extras }
      function getSlashPlan(skill, mode = 'tap') {
        const base = { cadenceMs: 500, extras: {} };
        if (skill === 'S1') {
          // Baseline: 3 slashes -> 3 X
          if (mode === 'rageTap') return { ...base, slashes: 4, xs: 3, xSize: 1.15, xDmg: 1.15, pierce: '+1', speed: undefined, extras: { pull: 80 } };
          if (mode === 'rageHold') return { ...base, slashes: 4, xs: 3, xSize: [1.35, 1, 1], xDmg: [1.35, 1, 1], pierce: ['+2', 0, 0], speed: undefined, extras: { parryMs: 120, floatMs: 250, chargeMs: 350 } };
          if (mode === 'hold') return { ...base, slashes: 3, xs: 3, xSize: [1.25, 1, 1], xDmg: [1.2, 1, 1], pierce: ['+1', 0, 0], extras: { floatMs: 200, chargeMs: 300 } };
          return { ...base, slashes: 3, xs: 3, xSize: 1.0, xDmg: 1.0, pierce: 0 };
        }
        if (skill === 'S2') {
          // Dash-to-enemy + close-range slashes
          if (mode === 'rageTap') return { ...base, slashes: 5, xs: 2, xSize: 1.10, xDmg: 1.10, pierce: 0, speed: undefined, extras: { dashRange: 600, dashSpeed: 18 } };
          if (mode === 'rageHold') return { ...base, slashes: 6, xs: 3, xSize: 1.20, xDmg: 1.20, pierce: '+1', speed: undefined, extras: { dashRange: 800, dashSpeed: 22, ghostMs: 180 } };
          if (mode === 'hold') return { ...base, slashes: 5, xs: 2, xSize: 1.05, xDmg: 1.05, pierce: 0, extras: { dashRange: 600, dashSpeed: 16 } };
          return { ...base, slashes: 4, xs: 2, xSize: 1.0, xDmg: 1.0, pierce: 0, extras: { dashRange: 500, dashSpeed: 14 } };
        }
        if (skill === 'S3') {
          // Make S3 look like S1 but heavier; baseline from spec: 5 slashes -> 4 X
          if (mode === 'rageTap') return { ...base, slashes: 6, xs: 4, xSize: 1.25, xDmg: 1.30, pierce: '+1', speed: 1080, extras: { fractureMs: 3000 } };
          if (mode === 'rageHold') return { ...base, slashes: 6, xs: 2, xSize: 1.60, xDmg: 1.50, pierce: '+2', speed: 1080, extras: { floatMs: 300, chargeMs: 600, ring: 0.6, slowmo: 0.08 } };
          if (mode === 'hold') return { ...base, slashes: 5, xs: 4, xSize: [1.35, 1, 1, 1], xDmg: [1.25, 1, 1, 1], pierce: ['+1', 0, 0, 0], speed: 1020, extras: { floatMs: 200, chargeMs: 450 } };
          return { ...base, slashes: 5, xs: 4, xSize: 1.0, xDmg: 1.0, pierce: 0, speed: 1000 };
        }
        // Default: simple pass-through
        return { ...base, slashes: 3, xs: 3, xSize: 1.0, xDmg: 1.0, pierce: 0 };
      }
      window.SkillPlanner = { getSlashPlan };

      // 4) Math console helper to verify plans quickly
      window.debugSkillMath = function () {
        const modes = ['tap', 'hold', 'rageTap', 'rageHold'];
        const out = {};
        for (const k of ['S1', 'S2', 'S3']) {
          out[k] = {};
          for (const m of modes) out[k][m] = getSlashPlan(k, m);
        }
        console.table({
          'S1 tap': out.S1.tap, 'S1 hold': out.S1.hold, 'S1 rageTap': out.S1.rageTap, 'S1 rageHold': out.S1.rageHold,
          'S3 tap': out.S3.tap, 'S3 hold': out.S3.hold, 'S3 rageTap': out.S3.rageTap, 'S3 rageHold': out.S3.rageHold
        });
        return out;
      };

      // 5) IFF tagging scaffold + strict enemy picker (non-destructive)
      function tagTeamsOnce() {
        try {
          if (window.st) {
            (st.players || []).forEach(p => { if (p && !p.team) p.team = 'ally'; });
            (st.enemies || []).forEach(e => { if (e && !e.team) e.team = 'enemy'; });
          }
        } catch (_) { }
      }
      function nearestEnemyStrict(pos) {
        try {
          tagTeamsOnce();
          const list = (st && st.enemies) || [];
          let best = null, bd = 1e9;
          for (const e of list) {
            if (!e || e.hp <= 0 || e.team !== 'enemy') continue;
            const d = Math.hypot((e.x - pos.x), (e.y - pos.y));
            if (d < bd) { bd = d; best = e; }
          }
          return best;
        } catch (_) { return null; }
      }
      window.nearestEnemyStrict = nearestEnemyStrict;

      // 6) Draw overhead hold meter
      function drawHoldMeters(ctx) {
        try {
          const skill = holdState.any; if (!skill) return;
          const L = (typeof leader === 'function') ? leader() : (st.players?.[st.leader || 0]); if (!L) return;
          const stt = holdState[skill]; if (!stt) return;
          stt.elapsed = performance.now() - stt.start;
          const t = Math.max(0, Math.min(1, stt.elapsed / (stt.thresh || 350)));
          const x = L.x, y = L.y - 86;
          ctx.save();
          ctx.translate(x, y);
          ctx.globalAlpha = 0.95;
          // back ring
          ctx.strokeStyle = '#15243a'; ctx.lineWidth = 6; ctx.beginPath(); ctx.arc(0, 0, 14, 0, Math.PI * 2); ctx.stroke();
          // progress
          const col = Rage.active ? '#ff4d4f' : '#6aa8ff';
          ctx.strokeStyle = col; ctx.lineWidth = 6; ctx.beginPath(); ctx.arc(0, 0, 14, -Math.PI / 2, -Math.PI / 2 + (Math.PI * 2 * t)); ctx.stroke();
          // icon
          ctx.fillStyle = '#e9f4ff'; ctx.font = '600 10px ui-monospace'; ctx.textAlign = 'center'; ctx.fillText(skill.replace('S',''), 0, 3);
          ctx.restore();
        } catch (_) { }
      }

      // 7) Hook draw and update
      const cv = document.getElementById('cv');
      const _draw = window.draw; window.draw = function () { _draw && _draw(); const ctx = cv?.getContext('2d'); if (ctx) drawHoldMeters(ctx); };
      const _upd = window.update; window.update = function (dt) { _upd && _upd(dt); tagTeamsOnce(); };

      // 8) Keyboard tracking for skill holds (non-invasive; does not cancel existing casts)
      window.addEventListener('keydown', (e) => {
        if (e.repeat) return;
        if (e.code === 'Digit1') beginHold('S1');
        if (e.code === 'Digit2') beginHold('S2');
        if (e.code === 'Digit3') beginHold('S3');
      }, true);
      window.addEventListener('keyup', (e) => {
        if (e.code === 'Digit1') { const r = endHold('S1'); window.lastHoldS1 = r; }
        if (e.code === 'Digit2') { const r = endHold('S2'); window.lastHoldS2 = r; }
        if (e.code === 'Digit3') { const r = endHold('S3'); window.lastHoldS3 = r; }
      }, true);

      console.log('✅ Rage Core + Hold Meter + Planner loaded');
    })();
  </script>
  <!-- ===== /Rage Core ===== -->
  <!-- ===== UI Fixes and Skill Buttons Patch ===== -->
  <style id="skill-btn-style">
    /* Prevent hero bars from overlapping by allowing wrap and adding margin */
    .team-status {
      flex-wrap: wrap;
    }

    .hero-portrait {
      margin-right: 8px;
    }

    /* Style for skill buttons that appear over non-leader heroes */
    .skill-btn {
      position: absolute;
      width: 18px;
      height: 18px;
      border-radius: 50%;
      background: #1a263a;
      color: #d7e9ff;
      font-size: 10px;
      font-weight: 600;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid #3b4d71;
      pointer-events: auto;
      cursor: pointer;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }

    .skill-btn:hover {
      background: #2e3a52;
    }

    .skill-btn-1 {
      transform: translate(315.876px, 656.208px);
    }

    .skill-btn-2 {
      transform: translate(359.39px, 688.971px);
    }

    .skill-btn-3 {
      transform: translate(741.304px, 287.065px);
    }

    .skill-btn-4 {
      transform: translate(502.032px, 690.748px);
    }
  </style>
  <script id="skill-btn-script">
    (function () {
      // Wait until game state is ready
      function init() {
        if (!window.st || !Array.isArray(st.players)) return setTimeout(init, 500);
        // Create overlay container for skill buttons if not present
        let overlay = document.getElementById('skillBtnOverlay');
        if (!overlay) {
          overlay = document.createElement('div');
          overlay.id = 'skillBtnOverlay';
          overlay.style.position = 'absolute';
          overlay.style.left = '0';
          overlay.style.top = '0';
          overlay.style.right = '0';
          overlay.style.bottom = '0';
          // ensure overlay sits above canvas and other elements but passes pointer events to its children
          overlay.style.zIndex = '10000';
          overlay.style.pointerEvents = 'none';
          document.body.appendChild(overlay);
        }
        // Create buttons for each non-leader hero
        const btns = [];
        function createButtons() {
          // Clear existing
          btns.forEach(b => b.el.remove()); btns.length = 0;
          const leaderIndex = st.leader || 0;
          (st.players || []).forEach((p, idx) => {
            if (idx === leaderIndex) return;
            const btn = document.createElement('div');
            btn.className = 'skill-btn';
            btn.textContent = 'S';
            btn.style.display = 'flex';
            // assign click handler to cast S2 for that hero
            btn.addEventListener('click', (ev) => {
              ev.stopPropagation();
              try {
                if (window.useSkillWrapper) useSkillWrapper(p, 'S2');
              } catch (e) { }
            });
            overlay.appendChild(btn);
            btns.push({ el: btn, id: p.id });
          });
        }
        createButtons();
        // Update positions each frame
        function update() {
          const cv = document.getElementById('cv');
          if (!cv) return;
          const rect = cv.getBoundingClientRect();
          const dpr = Math.min(window.devicePixelRatio || 1, 2);
          btns.forEach(obj => {
            const hero = (st.players || []).find(h => h.id === obj.id);
            if (!hero || hero.isDefeated) { obj.el.style.display = 'none'; return; }
            obj.el.style.display = 'flex';
            // position above hero head with slight horizontal offset based on hero index
            const baseX = rect.left + hero.x * (rect.width / cv.width * dpr);
            const baseY = rect.top + hero.y * (rect.height / cv.height * dpr);
            const offset = (hero.id === 'Unique' ? -24 : (hero.id === 'Missy' ? 24 : 0));
            obj.el.style.transform = `translate(${baseX + offset}px, ${baseY - 96}px)`;
          });
          requestAnimationFrame(update);
        }
        requestAnimationFrame(update);
        // Rebuild buttons if team composition changes
        setInterval(() => {
          if (!window.st || !Array.isArray(st.players)) return;
          const ids = (st.players || []).filter((_, idx) => idx !== (st.leader || 0)).map(p => p.id).sort().join(',');
          if (btns.map(b => b.id).sort().join(',') !== ids) {
            createButtons();
          }
        }, 2000);
      }
      init();
    })();
  </script>
  <!-- ===== /UI Fixes and Skill Buttons Patch ===== -->
  <!-- ===== UI Toggle and Switch Wiring ===== -->
  <script id="ui-toggle-script">
    (function () {
      function initHandlers() {
        // Hide the original Switch button in the top HUD if present
        // hide original Switch button after DOM is fully built
        setTimeout(() => {
          const oldSwitch = document.getElementById('btnSwitchChar');
          if (oldSwitch) oldSwitch.style.display = 'none';
        }, 0);

        const altSw = document.getElementById('btnSwitchAlt');
        if (altSw && typeof switchNextPlayer === 'function' && !altSw.__wired) {
          altSw.__wired = true;
          altSw.addEventListener('click', (e) => { e.stopPropagation(); try { switchNextPlayer(); } catch (_) { } });
        }
        const topUi = document.getElementById('btnHideUITop');
        if (topUi && !topUi.__wired) {
          topUi.__wired = true;
          topUi.addEventListener('click', (e) => {
            e.stopPropagation();
            document.querySelectorAll('.hud, #teamStatus, #currency').forEach(el => {
              el.classList.toggle('hidden');
            });
          });
        }
      }
      if (document.readyState === 'complete') initHandlers();
      else window.addEventListener('DOMContentLoaded', initHandlers);
    })();
  </script>
  <!-- ===== /UI Toggle and Switch Wiring ===== -->
  <!-- ===== Combat Integration & Pet/Vehicle Preview ===== -->
  <script id="combat-ai-and-preview">
    (function () {
      /* Auto-followers: simple AI to cast skills for non-leader heroes */
      function autoFollowerBrain() {
        try {
          if (!window.st || !st.auto) return;
          const leaderIdx = st.leader || 0;
          const players = st.players || [];
          for (let i = 0; i < players.length; i++) {
            if (i === leaderIdx) continue;
            const p = players[i];
            if (!p || p.isDefeated) continue;
            if (typeof cdReady === 'function' && typeof useSkillWrapper === 'function') {
              try {
                if (cdReady(p.id, 'S2')) { useSkillWrapper(p, 'S2'); continue; }
                if (cdReady(p.id, 'S3')) { useSkillWrapper(p, 'S3'); continue; }
              } catch (_e) { }
            }
          }
        } catch (e) { }
      }
      // Wrap existing update to call autoFollowerBrain every frame
      const _updateAI = window.update;
      window.update = function (dt) {
        _updateAI && _updateAI(dt);
        autoFollowerBrain();
      };
      /* Pet/Vehicle preview in bag: when clicking an item in Pets/Vehicles tabs, show basic stats */
      function attachPreview() {
        if (!window.st) return;
        const tab = st.bagTab;
        if (tab !== 'pets' && tab !== 'vehicles') return;
        const grid = document.querySelector(tab === 'pets' ? '#petList' : '#vehicleList');
        if (!grid || grid.__preview) return;
        grid.__preview = true;
        grid.addEventListener('click', function (e) {
          const cell = e.target.closest('.slot-box.item');
          if (!cell) return;
          const id = cell.getAttribute('data-item-id') || cell.dataset.itemId;
          if (!id) return;
          const it = (st.inv || []).find(x => x && String(x.id) === String(id));
          if (!it) return;
          // Basic placeholder stats; adjust if your item has stats
          if (tab === 'pets') { toast(`${it.name || 'Pet'}: HP 120, Attack 18`); }
          else { toast(`${it.name || 'Vehicle'}: HP 200, Fuel 100`); }
        });
      }
      // Observe bag open and attach preview
      setInterval(() => {
        try { if (st && st.bagOpen) attachPreview(); } catch (e) { }
      }, 600);
    })();
  </script>
  <!-- ===== /Combat Integration & Pet/Vehicle Preview ===== -->
  <!-- ===== Pet/Vehicle Evolution & Audio Controls Patch ===== -->
  <script id="pet-veh-evolve-audio">
    (function () {
      'use strict';
      // Ensure vehicle stat scaling similar to pets
      window.ensureVehProps = function (v) {
        if (!v) return;
        v.level = v.level || 1;
        // ensure base stats exist for scaling
        v.baseHP = v.baseHP || v.hp || 200;
        v.baseATK = v.baseATK || v.atk || 10;
        v.baseDEF = v.baseDEF || v.def || 5;
        const mul = 1 + 0.05 * (v.level - 1);
        v.hp = Math.round(v.baseHP * mul);
        v.atk = Math.round(v.baseATK * mul);
        v.def = Math.round(v.baseDEF * mul);
      };
      // Pet evolution: fuse duplicate pets at level thresholds 10/20/30 to next rank, inheriting evolvesTo species
      window.evolvePet = function (item, indexOrSlot) {
        try {
          const order = ['C', 'B', 'A', 'S'];
          const curRank = item.rank || 'C';
          const rankIdx = order.indexOf(curRank);
          if (rankIdx < 0 || rankIdx >= order.length - 1) return;
          // Check for duplicate pet with same name and rank in inventory
          const dupIdx = (st.inv || []).findIndex(x => x && x.slot === 'pet' && x.name === item.name && (x.rank || 'C') === curRank && x.id !== item.id);
          if (dupIdx < 0) return;
          const nextRank = order[rankIdx + 1];
          // Determine evolved species name
          const evolveName = (window.PetData && window.PetData[item.name] && window.PetData[item.name].evolvesTo) || item.name;
          const data = (window.PetData && window.PetData[evolveName]) || { baseHP: (item.baseHP || item.hp || 100), baseATK: (item.baseATK || item.atk || 10), baseDEF: (item.baseDEF || item.def || 5) };
          const newPet = {
            id: Math.random(),
            name: evolveName,
            type: 'gear',
            slot: 'pet',
            rank: nextRank,
            level: 1,
            hp: data.baseHP,
            atk: data.baseATK,
            def: data.baseDEF,
            baseHP: data.baseHP,
            baseATK: data.baseATK,
            baseDEF: data.baseDEF,
            exp: 0,
            kills: 0
          };
          // Replace the current pet with new evolved pet
          if (typeof indexOrSlot === 'string') {
            const parts = indexOrSlot.split(':');
            const slotIdx = parseInt(parts[1] || '0', 10);
            if (st.equippedPets && st.equippedPets[slotIdx]) {
              st.equippedPets[slotIdx] = newPet;
            }
          } else {
            const idx = indexOrSlot;
            if (st.inv && st.inv[idx]) st.inv[idx] = newPet;
          }
          // Remove one duplicate from inventory
          if (st.inv && dupIdx >= 0) st.inv.splice(dupIdx, 1);
          // Feedback: notification and VFX
          if (typeof notify === 'function') notify('Pet Evolved!', '#ffd56a');
          if (window.addFloater) addFloater((newPet.x || 200), (newPet.y || 560) - 80, 'Evolved!', '#ffd56a');
          if (window.addImpact) addImpact((newPet.x || 200), (newPet.y || 560), '#ffd56a');
          if (typeof renderBag === 'function') renderBag();
          if (typeof renderDetail === 'function') renderDetail(null);
        } catch (ex) { console.error(ex); }
      };
      // Vehicle evolution: fuse duplicate vehicles at level thresholds to next rank, scaling base stats up
      window.evolveVehicle = function (item, indexOrSlot) {
        try {
          const order = ['C', 'B', 'A', 'S'];
          const curRank = item.rank || 'C';
          const rankIdx = order.indexOf(curRank);
          if (rankIdx < 0 || rankIdx >= order.length - 1) return;
          const dupIdx = (st.inv || []).findIndex(x => x && x.slot === 'vehicle' && x.name === item.name && (x.rank || 'C') === curRank && x.id !== item.id);
          if (dupIdx < 0) return;
          const nextRank = order[rankIdx + 1];
          const factor = 1.2; // scale for vehicle evolution
          const baseHP = item.baseHP || item.hp || 200;
          const baseATK = item.baseATK || item.atk || 10;
          const baseDEF = item.baseDEF || item.def || 5;
          const newBaseHP = Math.round(baseHP * factor);
          const newBaseATK = Math.round(baseATK * factor);
          const newBaseDEF = Math.round(baseDEF * factor);
          const newVeh = {
            id: Math.random(),
            name: item.name,
            type: 'gear',
            slot: 'vehicle',
            rank: nextRank,
            level: 1,
            hp: newBaseHP,
            atk: newBaseATK,
            def: newBaseDEF,
            baseHP: newBaseHP,
            baseATK: newBaseATK,
            baseDEF: newBaseDEF,
            exp: 0,
            kills: 0
          };
          if (typeof indexOrSlot === 'string') {
            // equipped vehicle case
            if (st.equippedVehicle) st.equippedVehicle = newVeh;
          } else {
            const idx = indexOrSlot;
            if (st.inv && st.inv[idx]) st.inv[idx] = newVeh;
          }
          if (st.inv && dupIdx >= 0) st.inv.splice(dupIdx, 1);
          if (typeof notify === 'function') notify('Vehicle Evolved!', '#ffd56a');
          if (window.addFloater) addFloater((newVeh.x || 200), (newVeh.y || 560) - 80, 'Evolved!', '#ffd56a');
          if (window.addImpact) addImpact((newVeh.x || 200), (newVeh.y || 560), '#ffd56a');
          if (typeof renderBag === 'function') renderBag();
          if (typeof renderDetail === 'function') renderDetail(null);
        } catch (ex) { console.error(ex); }
      };
      // Audio slider initialization: persist and apply music and SFX volumes
      document.addEventListener('DOMContentLoaded', function () {
        try {
          const musicSlider = document.getElementById('musicVolSlider');
          const sfxSlider = document.getElementById('sfxVolSlider');
          if (!musicSlider || !sfxSlider) return;
          const storedMusic = parseFloat(localStorage.getItem('musicVol') || '1');
          const storedSfx = parseFloat(localStorage.getItem('sfxVol') || '1');
          musicSlider.value = storedMusic;
          sfxSlider.value = storedSfx;
          const applyMusic = (v) => {
            try {
              localStorage.setItem('musicVol', v);
              if (window.Howler && typeof Howler.volume === 'function') {
                Howler.volume(v);
              }
              // Additional music player volume adjustments can go here
            } catch (_ex) { console.error(_ex); }
          };
          const applySfx = (v) => {
            try {
              localStorage.setItem('sfxVol', v);
              // Save globally for code that checks sfx volume
              window.sfxVol = v;
              if (window.sfxAudios) {
                Object.keys(window.sfxAudios).forEach(k => {
                  try { window.sfxAudios[k].volume(v); } catch (_) { }
                });
              }
            } catch (_ex) { console.error(_ex); }
          };
          applyMusic(storedMusic);
          applySfx(storedSfx);
          musicSlider.addEventListener('input', (e) => applyMusic(parseFloat(e.target.value)));
          sfxSlider.addEventListener('input', (e) => applySfx(parseFloat(e.target.value)));

          // Initialize HUD visibility and position from localStorage
          try {
            const hud = document.getElementById('heroHud');
            const hudVisible = localStorage.getItem('heroHudVisible');
            if (hud) {
              if (hudVisible === 'false') { hud.style.display = 'none'; }
            }
            const pos = localStorage.getItem('hudPos') || 'top-right';
            const applyHudPos = (p) => {
              if (!hud) return;
              // Reset positions
              hud.style.top = '';
              hud.style.bottom = '';
              hud.style.left = '';
              hud.style.right = '';
              // Set based on p
              if (p.includes('top')) { hud.style.top = '60px'; } else { hud.style.bottom = '60px'; }
              if (p.includes('left')) { hud.style.left = '10px'; } else { hud.style.right = '10px'; }
            };
            applyHudPos(pos);
            // Set initial values for toggles
            const visToggle = document.getElementById('hudVisibleToggle');
            const posSelect = document.getElementById('hudPositionSelect');
            if (visToggle) { visToggle.checked = hud && hud.style.display !== 'none'; }
            if (posSelect) { posSelect.value = pos; }
            // Listen to changes
            if (visToggle) {
              visToggle.addEventListener('change', (e) => {
                const checked = e.target.checked;
                if (hud) { hud.style.display = checked ? 'block' : 'none'; }
                try { localStorage.setItem('heroHudVisible', checked ? 'true' : 'false'); } catch (_ex) { }
              });
            }
            if (posSelect) {
              posSelect.addEventListener('change', (e) => {
                const val = e.target.value;
                try { localStorage.setItem('hudPos', val); } catch (_ex) { }
                applyHudPos(val);
              });
            }
            // Start quest timer updates
            if (typeof updateQuestTimer === 'function') {
              updateQuestTimer();
              setInterval(updateQuestTimer, 1000);
            }
          } catch (_e) { console.error(_e); }
        } catch (ex) { console.error(ex); }
      });
    })();
  </script>
  <!-- ===== /Pet/Vehicle Evolution & Audio Controls Patch ===== -->
  <!-- External Game Improvements Script -->
  <script>
    /* ==========================================================
       AIRDROP PLANE v1.1 — DEPRECATED (Removed for Boss Pool System)
       Supply planes have been replaced with Boss Pool System.
       This section is commented out to prevent conflicts.
       ========================================================== */
    // (function installAirdropPlane() {
    //   if (window.__airdropPlane) return; window.__airdropPlane = true;
    //
    //   const ID = () => (window.crypto && crypto.randomUUID ? crypto.randomUUID() : ('id_' + Math.random().toString(36).slice(2)));
    //
    //   // Override supply plane spawner to advanced variant
    /*  window.spawnSupplyPlane = function () {
        const fromLeft = Math.random() < 0.5;
        const y = 50 + Math.random() * 100;
        const vx = fromLeft ? 0.42 : -0.42;
        const x = fromLeft ? -120 : (DESIGN_W + 120);
        const plane = {
          id: ID(), kind: 'plane', role: 'plane', behavior: 'plane',
          x, y, w: 96, h: 32,
          hp: 99999, max: 99999,
          vx, vy: 0.02 * (Math.random() < 0.5 ? -1 : 1),
          dropEvery: 700 + Math.random() * 400, dropT: 0,
          phase: 0, lifeT: 0, dead: false
        };
        st.enemies.push(plane);
        notify('Supply plane approaching!', '#6aa8ff');
        st.supplyPlaneWave = 2 + Math.floor(Math.random() * 8);
      };

      function dropSupplyCrate(cx, laneIdx) {
        st.pickups.push({ id: ID(), kind: 'chest', chestType: 'supply', ring: true, x: cx, y: laneY(laneIdx), vx: 0, vy: 0, life: 30000, opened: false });
      }
      function clamp(v, min, max) { return v < min ? min : (v > max ? max : v); }
      function fromEdge(e) { return (e.vx > 0 && e.x < -80) || (e.vx < 0 && e.x > DESIGN_W + 80); }

      function updatePlanes(dt) {
        for (const e of st.enemies) {
          if (!e || e.kind !== 'plane' || e.dead) continue;
          e.lifeT += dt;
          e.x += e.vx * (st.speed || 1) * (dt * 1000);
          e.y += (e.vy || 0) * (st.speed || 1) * (dt * 1000);
          if (e.y < 24) { e.y = 24; e.vy = Math.abs(e.vy || 0.02); }
          if (e.y > 140) { e.y = 140; e.vy = -Math.abs(e.vy || 0.02); }
          if (e.phase === 0 || e.phase === 2) {
            e.dropT += dt * 1000;
            if (e.dropT >= e.dropEvery) {
              e.dropT = 0;
              const midX = clamp(e.x, 100, DESIGN_W - 100);
              const lane = Math.floor(Math.random() * 3);
              if (Math.random() < 0.6) dropSupplyCrate(midX, lane);
              else { dropSupplyCrate(midX - 40, lane); dropSupplyCrate(midX + 40, (lane + 1) % 3); }
            }
          }
          const offRight = e.x > DESIGN_W + 160;
          const offLeft = e.x < -160;
          if (e.phase === 0 && (offRight || offLeft)) {
            e.phase = 1; e.vx *= -1; e.y += 24 * (Math.random() < 0.5 ? 1 : -1); e.dropT = 0;
          } else if (e.phase === 1) {
            if ((fromEdge(e) && Math.random() < 0.02) || e.lifeT > 5) e.phase = 2;
          } else if (e.phase === 2 && (offRight || offLeft)) {
            e.phase = 3;
          } else if (e.phase === 3 && (offRight || offLeft)) {
            e.dead = true;
          }
        }
        st.enemies = st.enemies.filter(e => !(e && e.kind === 'plane' && e.dead));
      }

      // const _update = window.update;
      // window.update = function (dt) { _update && _update(dt); updatePlanes(dt || 0); };

      // const _enemyKilled = window.onEnemyKilled;
      // window.onEnemyKilled = function (e) {
      //   _enemyKilled && _enemyKilled(e);
      //   if (e && e.kind === 'plane') {
      //     for (let i = 0; i < 4; i++) dropSupplyCrate(clamp(e.x + (i - 1.5) * 36, 80, DESIGN_W - 80), i % 3);
      //     notify('Supply plane shot down! Mega drop!', '#ffd56a');
      //   }
      // };
    // })();
    */
  </script>
  <!-- Platform layers stub for tests and platform mode toggle -->
  <script>
    // Full Platform module: procedural platforms per stage, Mario-like physics, chest + guards, boss platform break
    (function () {
      var g = window;
      const DESIGN_W = 1280, DESIGN_H = 720;

      const GRAV = 1800, RUN = 220, JUMP = 520, CLIMB = 160;
      function aabb(a, b) { return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }
      function solidUnder(x, y, plats) { return plats.some(p => y <= p.y && x > p.x && x < p.x + p.w && Math.abs(y - p.y) <= 8); }
      function onLadder(ent, lads) { return lads.find(L => aabb(ent, { x: L.x, y: L.y, w: L.w, h: L.h })); }
      function collide(ent, plats, levelW, levelH) {
        ent.onGround = false;
        ent.y += ent.vy * ent.dt;
        for (const p of plats) {
          if (aabb(ent, p)) {
            if (ent.vy > 0) { ent.y = p.y - ent.h; ent.vy = 0; ent.onGround = true; }
            else if (ent.vy < 0) { ent.y = p.y + p.h; ent.vy = 0; }
          }
        }
        ent.x += ent.vx * ent.dt;
        for (const p of plats) {
          if (aabb(ent, p)) {
            if (ent.vx > 0) { ent.x = p.x - ent.w; }
            else if (ent.vx < 0) { ent.x = p.x + p.w; }
            ent.vx = 0;
          }
        }
        ent.x = Math.max(0, Math.min(levelW - ent.w, ent.x));
        ent.y = Math.min(levelH - ent.h, ent.y);
      }

      const Platform = g.Platform = g.Platform || {};
      Platform.layers = Platform.layers || { solids: [], ladders: [], springs: [], houses: [] };
      Platform.actors = Platform.actors || [];
      Platform._lastStage = -1;
      Platform.enabled = true;

      /* ===== A1K: Labeled Zone System ===== */
      const ZONES = g.ZONES = [
        { id: 0, name: 'ENTRY', a: 0, b: 600, ax: 100 },
        { id: 1, name: 'TRAIN', a: 600, b: 1200, ax: 700 },
        { id: 2, name: 'PLAZA', a: 1200, b: 1800, ax: 1300 },
        { id: 3, name: 'HOME ROW', a: 1800, b: 2400, ax: 1850 },
        { id: 4, name: 'MARKET', a: 2400, b: 3000, ax: 2450 },
        { id: 5, name: 'ARCADE', a: 3000, b: 3600, ax: 3050 },
        { id: 6, name: 'TOWER GATE', a: 3600, b: 4200, ax: 3650 },
        { id: 7, name: 'PET YARD', a: 4200, b: 4800, ax: 4250 },
        { id: 8, name: 'SKY RAIL', a: 4800, b: 5400, ax: 4850 },
        { id: 9, name: 'GARDEN', a: 5400, b: 6000, ax: 5450 },
        { id: 10, name: 'BOSS TOWER', a: 6000, b: 6400, ax: 6050 }
      ];

      const getZoneAt = g.getZoneAt = function (x) {
        return ZONES.find(z => x >= z.a && x < z.b) || ZONES[ZONES.length - 1];
      };

      const drawZoneLabels = g.drawZoneLabels = function (ctx, cameraX) {
        if (!ZONES) return;
        ctx.save();
        ctx.font = '12px monospace';
        ctx.textAlign = 'center';
        ZONES.forEach(z => {
          const x = z.ax + 100 - (cameraX || 0);
          // outline
          ctx.lineWidth = 3;
          ctx.strokeStyle = '#0a0f18';
          ctx.strokeText(z.name, x, 80);
          ctx.fillStyle = '#9fd7ff';
          ctx.fillText(z.name, x, 80);
        });
        ctx.restore();
      };

      // Buildings catalog
      const BUILDINGS = g.BUILDINGS = [
        { id: 'home', zone: 3, x: 1880, w: 160, h: 120, label: 'Home' },
        { id: 'shop', zone: 4, x: 2460, w: 160, h: 120, label: 'Shop' },
        { id: 'forge', zone: 4, x: 2580, w: 140, h: 110, label: 'Forge' },
        { id: 'apothecary', zone: 4, x: 2720, w: 150, h: 110, label: 'Apothecary' },
        { id: 'missy_house', zone: 5, x: 3200, w: 160, h: 120, label: 'Missy House' },
        { id: 'blackmarket', zone: 5, x: 3380, w: 140, h: 110, label: 'Black Market' },
        { id: 'library', zone: 2, x: 1650, w: 160, h: 120, label: 'Archives' },
        { id: 'kiosk', zone: 2, x: 1500, w: 110, h: 100, label: 'Quest Board' },
        { id: 'shrine', zone: 9, x: 5600, w: 120, h: 110, label: 'Shrine' },
        { id: 'mail', zone: 3, x: 2100, w: 140, h: 110, label: 'Mail' },
        { id: 'workshop', zone: 8, x: 5020, w: 150, h: 115, label: 'Workshop' },
        { id: 'arena', zone: 1, x: 1180, w: 130, h: 105, label: 'Arena' },
        { id: 'photo', zone: 0, x: 260, w: 100, h: 95, label: 'Photo Booth' }
      ];

      // Spawn rules per zone
      const SPAWN_RULES = {
        0: { spawns: false, safe: true },   // ENTRY
        1: { spawns: true, types: ['training'] },  // TRAIN
        2: { spawns: false, safe: true },   // PLAZA
        3: { spawns: 'rare', types: ['thief'] },    // HOME ROW
        4: { spawns: 'rare', types: ['thief'] },    // MARKET
        5: { spawns: true, types: ['normal'] },    // ARCADE
        6: { spawns: 'guards', types: ['guard'] },  // TOWER GATE
        7: { spawns: true, types: ['pet_related'] }, // PET YARD
        8: { spawns: true, types: ['normal'] },    // SKY RAIL
        9: { spawns: false, safe: true },   // GARDEN
        10: { spawns: 'boss', types: ['boss'] }      // BOSS TOWER
      };

      g.canSpawnAtX = function (x) {
        const zone = getZoneAt(x);
        const rule = SPAWN_RULES[zone.id];
        if (!rule || !rule.spawns) return false;
        for (const b of BUILDINGS) {
          if (x > b.x - 64 && x < b.x + b.w + 64) return false;
        }
        return true;
      };

      // Zone bosses
      const ZONE_BOSSES = {
        gold_boss5: { name: 'Gold Boss V', hp: 8000, atk: 120, def: 60, skill: 'coin_shower', drops: ['gold_x1000'] },
        weapon_boss: { name: 'Arsenal Guardian', hp: 12000, atk: 150, def: 80, skill: 'blade_storm', drops: ['legendary_weapon'] },
        armor_boss: { name: 'Iron Colossus', hp: 15000, atk: 100, def: 150, skill: 'fortress_stance', drops: ['legendary_armor'] },
        scroll_boss: { name: 'Arcane Keeper', hp: 10000, atk: 140, def: 70, skill: 'spell_seal', drops: ['srank_scroll'] },
        gem_boss: { name: 'Crystal Warden', hp: 9000, atk: 130, def: 75, skill: 'prism_blast', drops: ['gems_x100'] }
      };

      g.spawnZoneBoss = function (zoneId, bossType) {
        if (!ZONES[zoneId] || !ZONE_BOSSES[bossType]) return null;
        const zone = ZONES[zoneId];
        const template = ZONE_BOSSES[bossType];
        const x = zone.a + (zone.b - zone.a) / 2;
        const ground = (Platform.layers.solids || []).find(p => p.type === 'ground');
        const y = ground ? ground.y - 60 : (DESIGN_H - 100);

        const boss = {
          x, y, vx: 0, vy: 0, w: 48, h: 56,
          hp: template.hp, hpMax: template.hp,
          atk: template.atk, def: template.def,
          isBoss: true, bossType: bossType,
          name: template.name,
          zoneId: zoneId,
          minX: zone.a, maxX: zone.b,
          skill: template.skill,
          drops: template.drops || []
        };
        return boss;
      };

      /* ===== A1K: Floating City Enforcer (inline, no deps) ===== */
      (function FloatingCityEnforcer() {
        'use strict';

        // Seeded RNG for deterministic visuals
        function seeded(seed) {
          let t = (seed >>> 0) + 0x6D2B79F5;
          return () => {
            t += 0x6D2B79F5;
            let r = Math.imul(t ^ t >>> 15, 1 | t);
            r ^= r + Math.imul(r ^ r >>> 7, 61 | r);
            return ((r ^ r >>> 14) >>> 0) / 4294967296;
          };
        }
        const R = seeded(0xF10A7);

        // State
        const offenders = [];
        const supportFootprints = [];
        let SHOW_VALIDATOR = false;

        // References
        const P = window.Platform || { layers: { solids: [], houses: [] } };
        const L = P.layers || {};
        L.supports = L.supports || [];

        // Helper: get ground Y at position
        function groundYAt(x) {
          try {
            const ground = (L.solids || []).find(p => p && p.type === 'ground');
            if (ground) return ground.y;
          } catch (_) { }
          return (window.DESIGN_H || 540) - 40;
        }

        // Helper: check if entity is on ground
        function isOnGround(e, eps = 4) {
          if (!e || typeof e.y !== 'number' || typeof e.h !== 'number') return false;
          const gy = groundYAt(e.x || 0);
          return Math.abs((e.y + e.h) - gy) < eps;
        }

        // Helper: lift gap
        function liftGap() {
          return 72 + Math.floor(R() * 28); // 72-100px
        }

        // Sprite makers
        function makeStrip(w, h) {
          w = w || 120; h = h || 18;
          const c = document.createElement('canvas');
          c.width = w; c.height = h;
          const ctx = c.getContext('2d');

          // Base slab
          ctx.fillStyle = '#a78bfa';
          ctx.fillRect(2, 4, w - 4, h - 8);

          // Bevel top
          ctx.fillStyle = '#c4b5fd';
          ctx.fillRect(3, 4, w - 6, 3);

          // Bevel bottom
          ctx.fillStyle = '#8b5cf6';
          ctx.fillRect(3, h - 7, w - 6, 3);

          // Outline
          ctx.strokeStyle = '#0a0f18';
          ctx.lineWidth = 1;
          ctx.strokeRect(2.5, 4.5, w - 5, h - 9);

          // Rim glow
          ctx.strokeStyle = 'rgba(0,229,255,0.3)';
          ctx.lineWidth = 1;
          ctx.strokeRect(1.5, 3.5, w - 3, h - 7);

          return c;
        }

        function makeCloud(w, h) {
          w = w || 96; h = h || 18;
          const c = document.createElement('canvas');
          c.width = w; c.height = h;
          const ctx = c.getContext('2d');

          // Puffy cloud blobs
          ctx.fillStyle = '#e0e7ff';
          const puffs = Math.floor(w / 24);
          for (let i = 0; i < puffs; i++) {
            const px = (i * (w / puffs)) + (w / puffs / 2);
            const py = h / 2;
            const pr = 10 + R() * 6;
            ctx.beginPath();
            ctx.arc(px, py, pr, 0, Math.PI * 2);
            ctx.fill();
          }

          // Base ledge
          ctx.fillStyle = '#c7d2fe';
          ctx.fillRect(4, h - 6, w - 8, 4);

          // Outline
          ctx.strokeStyle = 'rgba(159,215,255,0.5)';
          ctx.lineWidth = 1;
          for (let i = 0; i < puffs; i++) {
            const px = (i * (w / puffs)) + (w / puffs / 2);
            const py = h / 2;
            const pr = 10 + R() * 6;
            ctx.beginPath();
            ctx.arc(px, py, pr, 0, Math.PI * 2);
            ctx.stroke();
          }

          return c;
        }

        function makeBlock(w, h) {
          w = w || 96; h = h || 18;
          const c = document.createElement('canvas');
          c.width = w; c.height = h;
          const ctx = c.getContext('2d');

          const tileSize = 32;
          const tiles = Math.ceil(w / tileSize);

          for (let i = 0; i < tiles; i++) {
            const tx = i * tileSize;
            // Base tile
            ctx.fillStyle = '#1e293b';
            ctx.fillRect(tx, 0, tileSize - 2, h);

            // Rim
            ctx.strokeStyle = '#00E5FF';
            ctx.lineWidth = 1;
            ctx.strokeRect(tx + 0.5, 0.5, tileSize - 3, h - 1);

            // Inner detail
            ctx.strokeStyle = '#334155';
            ctx.strokeRect(tx + 3.5, 3.5, tileSize - 9, h - 7);
          }

          return c;
        }

        // Determine support kind based on entity type
        function pickKind(e) {
          if (!e) return 'strip';
          const type = e.type || e.id || '';
          if (type.includes('house') || type.includes('building') || type.includes('vehicle')) return 'strip';
          if (type.includes('npc')) return 'cloud';
          if (type.includes('chest') || type.includes('item')) return 'block';
          return 'strip';
        }

        // Add support
        function addSupport(kind, xMid, width, targetY) {
          const h = 18;
          const y = targetY || (groundYAt(xMid) - liftGap());

          let spr;
          if (kind === 'cloud') spr = makeCloud(width, h);
          else if (kind === 'block') spr = makeBlock(width, h);
          else spr = makeStrip(width, h);

          const s = {
            type: 'support',
            kind,
            x: Math.floor(xMid - width / 2),
            y: Math.floor(y),
            w: width,
            h: h,
            sprite: spr,
            solid: true,
            collide: true
          };

          (L.supports || []).push(s);

          // Also add to solids for collision
          (L.solids || []).push({
            x: s.x,
            y: s.y,
            w: s.w,
            h: s.h,
            type: 'support',
            hp: Infinity
          });

          // Track footprint
          supportFootprints.push({ a: s.x - 32, b: s.x + s.w + 32 });

          return s;
        }

        // Lift entity
        function liftEntity(e) {
          if (!e) return null;
          const width = Math.max((e.w || 96) + 48, 96);
          const kind = pickKind(e);
          const s = addSupport(kind, e.x + (e.w || 0) / 2, width);
          e.y = s.y - (e.h || 32);

          // Update door if house
          if (e.door) {
            e.door.y = s.y;
          }

          return s;
        }

        // Collect all entities that need checking
        function collectCandidates() {
          const candidates = [];

          // Houses
          try {
            const houses = (L.houses || []);
            houses.forEach(h => {
              if (h && typeof h.x === 'number') {
                candidates.push({ ref: h, type: 'house', x: h.x, y: h.y, w: h.w || 110, h: h.h || 86 });
              }
            });
          } catch (_) { }

          // NPCs
          try {
            const npcs = (window.st?.npcs || []);
            npcs.forEach(n => {
              if (n && typeof n.x === 'number') {
                candidates.push({ ref: n, type: 'npc', x: n.x, y: n.y, w: n.w || 32, h: n.h || 48 });
              }
            });
          } catch (_) { }

          // Chests
          try {
            const chests = (P.chests || []);
            chests.forEach(ch => {
              if (ch && !ch.opened && typeof ch.x === 'number') {
                candidates.push({ ref: ch, type: 'chest', x: ch.x, y: ch.y, w: ch.w || 40, h: ch.h || 36 });
              }
            });
          } catch (_) { }

          // Vehicles
          try {
            const vehicles = (window.st?.vehicles || []);
            vehicles.forEach(v => {
              if (v && typeof v.x === 'number') {
                candidates.push({ ref: v, type: 'vehicle', x: v.x, y: v.y, w: v.w || 80, h: v.h || 60 });
              }
            });
          } catch (_) { }

          return candidates;
        }

        // Deep scan and fix
        function auditAndFix() {
          offenders.length = 0;
          const candidates = collectCandidates();

          for (const c of candidates) {
            if (isOnGround(c.ref)) {
              liftEntity(c.ref);
              offenders.push(c);
            }
          }

          console.log(`[FloatingCityEnforcer] Audit complete: ${offenders.length} entities lifted`);
        }

        // Draw validator overlay
        function drawValidator(ctx, cameraX) {
          if (!SHOW_VALIDATOR) return;

          ctx.save();
          ctx.translate(-(cameraX || 0), 0);

          // Draw offenders
          const candidates = collectCandidates();
          let count = 0;

          for (const c of candidates) {
            if (isOnGround(c.ref)) {
              count++;
              ctx.strokeStyle = '#FF3B3B';
              ctx.lineWidth = 2;
              ctx.strokeRect(c.x, c.y, c.w, c.h);

              // Label
              ctx.fillStyle = '#FF3B3B';
              ctx.font = '10px monospace';
              ctx.fillText(c.type, c.x, c.y - 4);
            }
          }

          ctx.restore();

          // Counter top-left
          if (count > 0) {
            ctx.save();
            ctx.fillStyle = 'rgba(255,59,59,0.9)';
            ctx.fillRect(10, 100, 180, 24);
            ctx.fillStyle = '#fff';
            ctx.font = '12px monospace';
            ctx.fillText(`OFFENDERS: ${count}`, 16, 116);
            ctx.restore();
          }
        }

        // Draw supports
        function drawSupports(ctx, cameraX) {
          ctx.save();
          ctx.translate(-(cameraX || 0), 0);

          const supports = (L.supports || []);
          for (const s of supports) {
            if (s.sprite) {
              ctx.drawImage(s.sprite, s.x, s.y);
            }
          }

          ctx.restore();
        }

        // Hook into Platform.draw
        const _originalDraw = P.draw;
        P.draw = function (ctx) {
          // Draw supports first (under props)
          drawSupports(ctx, window.st?.camX || 0);

          // Original draw
          if (typeof _originalDraw === 'function') {
            _originalDraw.call(P, ctx);
          }

          // Validator overlay
          drawValidator(ctx, window.st?.camX || 0);
        };

        // Hook into Platform.resetForStage
        const _originalReset = P.resetForStage;
        P.resetForStage = function (stage) {
          if (typeof _originalReset === 'function') {
            _originalReset.call(P, stage);
          }
          setTimeout(auditAndFix, 100);
        };

        // Keyboard shortcuts
        window.addEventListener('keydown', function (e) {
          if (e.code === 'F7') {
            SHOW_VALIDATOR = !SHOW_VALIDATOR;
            console.log('[FloatingCityEnforcer] Validator:', SHOW_VALIDATOR ? 'ON' : 'OFF');
          }
          if (e.code === 'F8') {
            console.log('[FloatingCityEnforcer] Running auto-fix...');
            auditAndFix();
          }
          if (e.code === 'F10') {
            // Warp to next offender
            const candidates = collectCandidates();
            for (const c of candidates) {
              if (isOnGround(c.ref)) {
                try {
                  const L = (window.st?.players || [])[window.st?.leader || 0];
                  if (L) { L.x = c.x; }
                  console.log('[FloatingCityEnforcer] Warped to offender:', c.type);
                } catch (_) { }
                break;
              }
            }
          }
        });

        // Initial audit
        setTimeout(auditAndFix, 500);

        console.log('[FloatingCityEnforcer] Initialized');
      })();

      /* ===== A1K: QA & Debug Tools ===== */
      (function DebugTools() {
        'use strict';

        function leader() {
          try {
            return (window.st?.players || [])[window.st?.leader || 0];
          } catch (_) {
            return null;
          }
        }

        // Teleport system
        window.addEventListener('keydown', function (e) {
          const L = leader();
          if (!L) return;

          // F1: Reset to start
          if (e.code === 'F1') {
            L.x = 80;
            console.log('[Debug] Teleported to start');
          }

          // F2: Next zone
          if (e.code === 'F2') {
            if (typeof getZoneAt === 'function' && Array.isArray(ZONES)) {
              const cur = getZoneAt(L.x);
              const nextIdx = (cur.id + 1) % ZONES.length;
              const next = ZONES[nextIdx];
              L.x = next.ax;
              console.log(`[Debug] Teleported to zone: ${next.name}`);
            }
          }

          // F3: Cycle house interiors
          if (e.code === 'F3') {
            try {
              if (window.HouseInterior?.active) {
                window.HouseInterior.exit?.();
              } else {
                // Enter nearest house
                window.enterNearestHouse?.();
              }
            } catch (_) { }
          }

          // F9: House walk test
          if (e.code === 'F9') {
            console.log('[Debug] Starting house walk test...');
            let idx = 0;
            const houses = (Platform?.layers?.houses || []);

            const testNext = function () {
              if (idx >= houses.length) {
                console.log('[Debug] House walk test complete!');
                return;
              }

              const h = houses[idx];
              idx++;

              if (!h || !h.door) return testNext();

              console.log(`[Debug] Testing house ${idx}/${houses.length}: ${h.label || h.type}`);

              // Warp to door
              L.x = h.door.x;
              L.y = h.door.y - 40;

              setTimeout(() => {
                // Try to enter
                try {
                  window.enterNearestHouse?.();
                } catch (_) { }

                setTimeout(() => {
                  // Exit
                  try {
                    if (window.HouseInterior?.active) {
                      window.HouseInterior.exit?.();
                    }
                  } catch (_) { }

                  setTimeout(testNext, 300);
                }, 500);
              }, 300);
            };

            testNext();
          }
        });

        // Visual debug pillars at zone anchors
        const _origDraw = window.Platform?.draw;
        if (_origDraw && typeof _origDraw === 'function') {
          window.Platform.draw = function (ctx) {
            _origDraw.call(this, ctx);

            // Draw zone anchor pillars (if debug mode)
            if (window.A1K_DEBUG_ZONES) {
              ctx.save();
              ctx.translate(-(window.st?.camX || 0), 0);

              if (Array.isArray(ZONES)) {
                ZONES.forEach(z => {
                  ctx.fillStyle = '#00E5FF55';
                  ctx.fillRect(z.ax - 2, (window.DESIGN_H || 540) - 60, 4, 20);
                });
              }

              ctx.restore();
            }
          };
        }

        console.log('[DebugTools] Initialized - F1:reset, F2:next zone, F3:house toggle, F9:walk test');
      })();

      /* ===== A1K: Platform Toys & Interactables ===== */
      (function PlatformToys() {
        'use strict';

        // Jelly Trampoline Pad creator
        function createJellyPad(x, y) {
          const ground = (Platform.layers.solids || []).find(p => p.type === 'ground');
          const gY = ground ? ground.y : (window.DESIGN_H || 540) - 40;

          return {
            type: 'jelly_pad',
            x: x - 24,
            y: y || gY - 16,
            w: 48,
            h: 16,
            power: 1200,
            cooldown: 0,
            active: true,
            bounce: function (player) {
              if (this.cooldown > 0) return;
              player.vy = -this.power / 1000;
              this.cooldown = 0.3;
              console.log('[JellyPad] BOING!');
            },
            tick: function (dt) {
              this.cooldown = Math.max(0, this.cooldown - dt / 1000);
            },
            draw: function (ctx) {
              ctx.save();
              ctx.fillStyle = '#ff6aa8';
              ctx.fillRect(this.x, this.y, this.w, this.h);
              ctx.strokeStyle = '#ffc6ef';
              ctx.lineWidth = 2;
              ctx.strokeRect(this.x + 1, this.y + 1, this.w - 2, this.h - 2);
              ctx.restore();
            }
          };
        }

        // Taffy Swing Vine creator
        function createSwingVine(x, y) {
          const ground = (Platform.layers.solids || []).find(p => p.type === 'ground');
          const gY = ground ? ground.y : (window.DESIGN_H || 540) - 40;
          const topY = y || gY - 120;

          return {
            type: 'swing_vine',
            x: x,
            y: topY,
            w: 8,
            h: 120,
            swing: 0,
            swingSpeed: 2,
            active: true,
            tick: function (dt) {
              this.swing += this.swingSpeed * dt / 100;
              if (Math.abs(this.swing) > 20) this.swingSpeed *= -0.98;
            },
            draw: function (ctx) {
              ctx.save();
              // Vine rope
              ctx.strokeStyle = '#a78bfa';
              ctx.lineWidth = 3;
              ctx.beginPath();
              ctx.moveTo(this.x, this.y);
              ctx.lineTo(this.x + this.swing, this.y + this.h);
              ctx.stroke();
              // Bottom handle
              ctx.fillStyle = '#ff6aa8';
              ctx.fillRect(this.x + this.swing - 16, this.y + this.h - 8, 32, 8);
              ctx.restore();
            }
          };
        }

        // Initialize platform toys
        function initPlatformToys() {
          try {
            Platform.toys = Platform.toys || [];

            // Jelly Pads
            Platform.toys.push(createJellyPad(3180)); // ARCADE
            Platform.toys.push(createJellyPad(5120)); // SKY RAIL

            // Swing Vine
            Platform.toys.push(createSwingVine(5280)); // SKY RAIL

            // Bubble Jets (reuse existing bubble pad system if available)
            if (typeof Platform.ensureBubblePad === 'function') {
              // Already handled by existing system
              console.log('[PlatformToys] Bubble pads handled by existing system');
            }

            console.log(`[PlatformToys] Initialized ${Platform.toys.length} toys`);
          } catch (e) {
            console.warn('[PlatformToys] Init failed:', e);
          }
        }

        // Hook into platform draw
        const _origDraw2 = Platform.draw;
        if (_origDraw2 && typeof _origDraw2 === 'function') {
          Platform.draw = function (ctx) {
            _origDraw2.call(this, ctx);

            // Draw toys
            ctx.save();
            ctx.translate(-(window.st?.camX || 0), 0);

            const toys = Platform.toys || [];
            for (const toy of toys) {
              if (toy && toy.draw) toy.draw(ctx);
            }

            ctx.restore();
          };
        }

        // Hook into game update for toy physics
        const _origUpdate = window.update;
        if (_origUpdate && typeof _origUpdate === 'function') {
          window.update = function (dt) {
            const result = _origUpdate.call(this, dt);

            // Tick toys
            const toys = Platform.toys || [];
            for (const toy of toys) {
              if (toy && toy.tick) toy.tick(dt);
            }

            // Check player collision with toys
            try {
              const L = (window.st?.players || [])[window.st?.leader || 0];
              if (L) {
                for (const toy of toys) {
                  if (!toy || !toy.active) continue;

                  // Simple AABB collision
                  if (L.x + 14 > toy.x && L.x - 14 < toy.x + toy.w &&
                    L.y + 22 > toy.y && L.y < toy.y + toy.h) {
                    if (toy.type === 'jelly_pad' && toy.bounce) {
                      toy.bounce(L);
                    }
                  }
                }
              }
            } catch (_) { }

            return result;
          };
        }

        // Initialize on stage reset
        const _origReset2 = Platform.resetForStage;
        if (_origReset2 && typeof _origReset2 === 'function') {
          Platform.resetForStage = function (stage) {
            _origReset2.call(this, stage);
            setTimeout(initPlatformToys, 200);
          };
        } else {
          // Fallback: init after delay
          setTimeout(initPlatformToys, 600);
        }

        console.log('[PlatformToys] System initialized');
      })();

      /* ===== A1K: System Initialization Summary ===== */
      (function InitSummary() {
        setTimeout(function () {
          console.log('%c[A1K Floating City] All systems initialized', 'color: #00E5FF; font-weight: bold');
          console.log(`  World: ${window.WORLD_WIDTH}px (${ZONES.length} zones)`);
          console.log(`  Buildings: ${BUILDINGS.length} locations`);
          console.log(`  Bosses: ${Object.keys(ZONE_BOSSES).length} types`);
          console.log('  Controls:');
          console.log('    F1: Teleport to start');
          console.log('    F2: Next zone');
          console.log('    F3: Toggle house interior');
          console.log('    F7: Validator overlay');
          console.log('    F8: Auto-fix elevation');
          console.log('    F9: House walk test');
          console.log('    F10: Warp to offender');
        }, 1000);
      })();

      // Map management (JSON-driven layouts)
      Platform.maps = [];
      Platform._mapsLoaded = false;
      Platform._palette = ['#2a3b5a', '#254d4a', '#3b2a5a', '#5a3b2a', '#2a4a5a', '#3a5a2a'];
      Platform._rand = function (n) { return Math.random() * n; };
      Platform._pick = function (arr) { return arr[Math.floor(Math.random() * arr.length)]; };
      Platform._loadMaps = async function () {
        if (Platform._mapsLoaded) return;
        const candidates = [];
        for (const url of candidates) {
          try {
            const res = await fetch(url); if (!res.ok) continue;
            const j = await res.json();
            if (j && j.layers) { Platform.maps.push(j); }
            else if (j && Array.isArray(j.stages)) { j.stages.forEach(s => { if (s && s.layers) Platform.maps.push(s); }); }
          } catch (e) { /* ignore */ }
        }
        Platform._mapsLoaded = true;
      };
      Platform._applyMap = function (map) {
        const L = map.layers || {};
        let solids = (L.solids || []).map(p => ({ ...p, hp: (isFinite(p.hp) ? p.hp : 80) }));
        let ladders = (L.ladders || []).map(x => ({ ...x }));
        let springs = (L.springs || []).map(s => ({ ...s, power: s.power || 900 }));
        // Trim/expand to 3-6 platforms
        if (solids.length > 6) {
          const out = []; const step = Math.ceil(solids.length / 6);
          for (let i = 0; i < solids.length; i += step) out.push(solids[i]);
          solids = out.slice(0, 6);
        }
        while (solids.length < 3) {
          solids.push({ x: 200 + solids.length * 220, y: DESIGN_H - 260 - (solids.length * 60), w: 180, h: 14, hp: 80 });
        }
        // Size down and colorize
        solids = solids.map((p, i) => { const w = Math.max(120, Math.min(260, p.w || 180)); const c = Platform._palette[i % Platform._palette.length]; return { ...p, w, h: (p.h || 14), color: c }; });
        // If no springs, add a couple fun ones on random solids
        if (springs.length === 0 && solids.length) {
          for (let i = 0; i < Math.min(2, solids.length); i++) {
            const s = solids[(i * 2 + 1) % solids.length];
            springs.push({ x: s.x + s.w / 2 - 18, y: s.y - 6, w: 36, h: 6, power: 960 });
          }
        }
        Platform.layers = { solids, ladders, springs, houses: (Platform.layers.houses || []) };
      };

      Platform.generateDefault = function (stage) {
        const solids = [], ladders = [], springs = [];
        // Example of a more complex default generator
        for (let i = 0; i < 5; i++) {
          solids.push({
            x: 100 + i * 250,
            y: 400 + Math.random() * 150,
            w: 150 + Math.random() * 100,
            h: 20,
            hp: 100,
            type: 'platform'
          });
        }
        solids.push({ x: 0, y: DESIGN_H - 40, w: (window.WORLD_WIDTH || WORLD_WIDTH || DESIGN_W), h: 40, hp: Infinity, type: 'ground' });
        Platform.layers = { solids, ladders, springs, houses: (Platform.layers.houses || []) };
      };

      Platform.generateBridge = function (stage) {
        const solids = [], ladders = [], springs = [];
        const groundLevel = DESIGN_H - 80;
        const bridgeLevel = DESIGN_H - 300;
        const bridgeWidth = (window.WORLD_WIDTH || WORLD_WIDTH || (DESIGN_W * 2));

        // 1. Ground Plane
        solids.push({ x: 0, y: groundLevel, w: bridgeWidth + 200, h: 80, hp: Infinity, type: 'ground' });

        // 2. Wide Bridge with Trap Doors
        const segmentWidth = 200;
        const numSegments = Math.floor(bridgeWidth / segmentWidth);
        for (let i = 0; i < numSegments; i++) {
          const isTrap = (i % 4 === 2); // Make every 4th segment a trap door
          solids.push({
            x: i * segmentWidth,
            y: bridgeLevel,
            w: segmentWidth - 5,
            h: 20,
            hp: isTrap ? 30 : 200, // Trap doors are weaker
            type: isTrap ? 'trap' : 'bridge',
            color: isTrap ? '#5a3b2a' : '#2a3b5a'
          });
        }

        // 3. Ladders
        const ladderHeight = groundLevel - bridgeLevel;
        for (let i = 1; i < numSegments; i += 5) {
          ladders.push({
            x: i * segmentWidth - 30,
            y: bridgeLevel,
            w: 20,
            h: ladderHeight
          });
        }

        Platform.layers = { solids, ladders, springs, houses: (Platform.layers.houses || []) };
      };

      // Bubble Jet Pad: floating launch platform with bubble boost
      const BUBBLE_PAD = {
        width: 84,
        hoverAmplitude: 7,
        hoverFrequency: 3.4,
        launchPower: JUMP * 1.58,
        cooldown: 0.85,
        burstCount: 14
      };

      Platform.ensureBubblePad = function (stage) {
        try {
          const solids = Platform.layers.solids = Platform.layers.solids || [];
          for (let i = solids.length - 1; i >= 0; i--) {
            if (solids[i] && solids[i].type === 'bubble_strip') {
              solids.splice(i, 1);
            }
          }
          const worldWidth = (window.WORLD_WIDTH || WORLD_WIDTH || DESIGN_W * 2);
          const ground = solids.find(p => p && p.type === 'ground');
          const groundY = ground ? ground.y : (DESIGN_H - 40);
          const nonGround = solids.filter(p => p && p.type !== 'ground');
          let anchorEdge = 260;
          for (const strip of nonGround) {
            anchorEdge = Math.max(anchorEdge, strip.x + strip.w);
          }
          const stripWidth = 180;
          const leftLimit = Math.max(220, anchorEdge + 120);
          const stripX = Math.min(worldWidth - stripWidth - 160, leftLimit);
          let stripY = groundY - 180;
          if (stripY < 160) stripY = groundY - 120;
          const bubbleStrip = {
            x: stripX,
            y: stripY,
            w: stripWidth,
            h: 16,
            hp: 999,
            type: 'bubble_strip',
            color: '#152c44'
          };
          solids.push(bubbleStrip);
          Platform.bubblePad = {
            x: bubbleStrip.x + bubbleStrip.w / 2,
            baseY: bubbleStrip.y - 28,
            hover: 0,
            t: Math.random() * Math.PI * 2,
            w: BUBBLE_PAD.width,
            amp: BUBBLE_PAD.hoverAmplitude,
            freq: BUBBLE_PAD.hoverFrequency,
            cooldown: 0,
            glow: 0,
            ripple: 0,
            particles: [],
            strip: bubbleStrip
          };
          Platform.tickBubblePad(0);
        } catch (err) {
          console.warn('[Platform] Bubble pad spawn failed', err);
        }
      };

      Platform.ensurePlaza = function (stage) {
        try {
          const solids = Platform.layers.solids = Platform.layers.solids || [];
          const worldWidth = (window.WORLD_WIDTH || WORLD_WIDTH || DESIGN_W * 2);
          const ground = solids.find(p => p && p.type === 'ground');
          const groundY = ground ? ground.y : (DESIGN_H - 40);
          const stripWidth = 260;
          const centerX = worldWidth / 2;
          const targetY = Math.max(groundY - 220, 140);
          const ladders = Platform.layers.ladders = Platform.layers.ladders || [];
          for (let i = ladders.length - 1; i >= 0; i--) {
            if (ladders[i] && ladders[i].type === 'plaza_ladder') ladders.splice(i, 1);
          }
          for (let i = solids.length - 1; i >= 0; i--) {
            const s = solids[i];
            if (!s) continue;
            if (s.type === 'play_strip' || s.type === 'play_cloud') solids.splice(i, 1);
          }
          let strip = solids.find(p => p && p.type === 'plaza_strip');
          if (!strip) {
            strip = {
              x: centerX - stripWidth / 2,
              y: targetY,
              w: stripWidth,
              h: 18,
              hp: 999,
              type: 'plaza_strip',
              color: '#1f2f4f'
            };
            solids.push(strip);
          } else {
            strip.x = centerX - stripWidth / 2;
            strip.y = targetY;
            strip.w = stripWidth;
            strip.h = 18;
            strip.hp = 999;
            strip.color = '#1f2f4f';
          }
          ladders.push({
            x: centerX - 10,
            y: targetY,
            w: 20,
            h: Math.max((ground ? ground.y : DESIGN_H - 40) - targetY, 60),
            type: 'plaza_ladder'
          });
          Platform.plazaCloud = {
            x: centerX,
            y: targetY + 60,
            w: stripWidth + 200,
            h: 48
          };

          // Playground floating strips to the right
          const playStrips = [];
          const stripSpacing = 140;
          const stripCount = 4;
          for (let i = 0; i < stripCount; i++) {
            const px = strip.x + strip.w + 80 + i * (stripSpacing + 90);
            const py = targetY - 20 - (i % 2) * 18;
            const play = { x: px, y: py, w: stripSpacing, h: 14, hp: 999, type: 'play_strip', color: '#1d2840' };
            playStrips.push(play);
            solids.push(play);
          }
          // Anchor a large playground cloud at the end
          const cloudStrip = { x: strip.x + strip.w + 80 + stripCount * (stripSpacing + 90), y: targetY - 30, w: 200, h: 14, hp: 999, type: 'play_cloud', color: '#1c2742' };
          solids.push(cloudStrip);
          playStrips.push(cloudStrip);

          Platform.playgroundStrips = playStrips;
          Platform.playgroundPads = playStrips.slice(1).map((s, idx) => ({
            x: s.x + s.w / 2,
            baseY: s.y - 10,
            hover: 0,
            t: Math.random() * Math.PI * 2 + idx,
            amp: 4 + idx,
            freq: 1.2 + idx * 0.15,
            color: idx % 2 ? '#ff93d3' : '#9fd7ff'
          }));
        } catch (err) {
          console.warn('[Platform] Plaza placement failed', err);
        }
      };

      Platform.ensureCandyHouse = function (stage) {
        try {
          const solids = Platform.layers.solids = Platform.layers.solids || [];
          const houses = Platform.layers.houses = Platform.layers.houses || [];
          const ladders = Platform.layers.ladders = Platform.layers.ladders || [];
          // Remove old candy house ladder since house will be on ground
          for (let i = ladders.length - 1; i >= 0; i--) {
            if (ladders[i] && ladders[i].type === 'candy_house_ladder') ladders.splice(i, 1);
          }
          const ground = solids.find(p => p && p.type === 'ground');
          const groundY = ground ? ground.y : (DESIGN_H - 40);

          // Create elevated platform 40% right of center and 10% higher
          const target = {
            id: 'candy_house_strip',
            x: 4480 - 130,  // 40% right of center (4480 - 130 = 4350)
            y: groundY - 88,  // 10% higher above ground (was -20, now -88)
            w: 260,
            h: 20,
            hp: 999,
            type: 'candy_house_strip',
            color: '#20304a'
          };
          solids.push(target);

          const doorX = target.x + (target.w || 0) / 2;
          const doorY = target.y;
          let house = houses.find((h) => h && h.id === 'candy_house_float');
          if (!house) {
            addHouse(915732, target.x, target.y, 'Candy Dungeon', 'candy_dungeon');
            house = houses[houses.length - 1];
            if (!house) return;
            house.id = 'candy_house_float';
            house.type = 'candy_dungeon';
          }
          const door = house.door = house.door || { x: doorX, y: doorY, r: 34, w: 42, h: 36 };
          const currentDoorX = door.x || (house.x + (house.w || 110) / 2);
          const delta = currentDoorX - doorX;
          house.x = (house.x || 0) - delta;
          house.y = target.y - (house.h || 86) + 2;
          door.x = doorX;
          door.y = doorY;
          door.r = Math.max(door.r || 28, 34);
          door.w = door.w || 42;
          door.h = door.h || 36;
          house.stripRef = target;

          // Add ladder since house is elevated
          ladders.push({
            x: doorX - 10,
            y: target.y,
            w: 20,
            h: Math.max(groundY - target.y, 70),
            type: 'candy_house_ladder'
          });

          if (!Platform.__candyHouseAnnounced && typeof notify === 'function') {
            try { notify('Candy House moved 40% right and 10% higher', '#9fd7ff'); } catch (_) { }
            Platform.__candyHouseAnnounced = true;
          }
        } catch (err) {
          console.warn('[Platform] Candy house placement failed', err);
        }
      };

      Platform.ensureBlackMarket = function (stage) {
        try {
          const solids = Platform.layers.solids = Platform.layers.solids || [];
          const houses = Platform.layers.houses = Platform.layers.houses || [];
          const ground = solids.find(p => p && p.type === 'ground');
          const groundY = ground ? ground.y : (DESIGN_H - 40);
          // Pick a strip near quarter of the world
          const worldWidth = (window.WORLD_WIDTH || WORLD_WIDTH || DESIGN_W * 2);
          const targetX = Math.max(220, Math.floor(worldWidth * 0.25));
          let strip = solids
            .filter(p => p && p.type !== 'ground' && p.y < groundY - 20 && targetX >= p.x && targetX <= p.x + p.w)
            .sort((a, b) => Math.abs((a.x + a.w / 2) - targetX) - Math.abs((b.x + b.w / 2) - targetX))[0];
          if (!strip) {
            strip = { x: targetX - 120, y: groundY - 150, w: 240, h: 18, hp: 999, type: 'bm_strip', color: '#1b2236' };
            solids.push(strip);
          }
          let house = houses.find(h => h && h.id === 'black_market');
          if (!house) {
            addHouse(925551, strip.x + strip.w / 2 - 55, strip.y, 'Black Market', 'black_market');
            house = houses[houses.length - 1];
            house.id = 'black_market';
          } else {
            house.x = strip.x + strip.w / 2 - (house.w || 110) / 2;
            house.y = strip.y - (house.h || 86) + 2;
          }
          if (house.door) { house.door.x = strip.x + strip.w / 2; house.door.y = strip.y; }
        } catch (e) { console.warn('[Platform] Black Market ensure failed', e); }
      };

      Platform.ensureHouseSpread = function () {
        try {
          const houses = Platform.layers.houses = Platform.layers.houses || [];
          const worldWidth = (window.WORLD_WIDTH || WORLD_WIDTH || DESIGN_W * 2);
          const configs = [
            { label: 'Shop', type: 'shop' },
            { label: 'Arcade', type: 'arcade' },
            { label: 'Inn', type: 'inn' },
            { label: 'Workshop', type: 'workshop' },
            { label: 'Clinic', type: 'clinic' },
            { label: 'Forge', type: 'forge' },
            { label: 'Shrine', type: 'shrine' },
            { label: 'Archives', type: 'archives' },
            { label: 'Photo Booth', type: 'photo' },
            { label: 'Arena', type: 'arena' },
            { label: 'Mail', type: 'mail' },
            { label: 'Apothecary', type: 'apothecary' }
          ];
          // === PATCH: extend house configs (Gift Room, Boss Tower, Crafting House) ===
          try {
            configs.push(
              { label: 'Gift Room', type: 'gift_room' },
              { label: 'Boss Tower', type: 'boss_tower' },
              { label: 'Crafting House', type: 'crafting' }
            );
          } catch (_) { }
          const createArcadeIsland = (centerX) => {
            const solids = Platform.layers.solids = Platform.layers.solids || [];
            const ground = solids.find(p => p && p.type === 'ground');
            const groundY = ground ? ground.y : (DESIGN_H - 40);
            const baseY = Math.max(groundY - 260, 140);
            const segmentWidth = 110;
            const gap = 12;
            const segments = 4;
            const totalWidth = segments * segmentWidth + (segments - 1) * gap;
            const startX = Math.max(40, centerX - totalWidth / 2);
            const clouds = [];
            for (let i = 0; i < segments; i++) {
              const segX = startX + i * (segmentWidth + gap);
              const cloud = {
                x: segX,
                y: baseY,
                w: segmentWidth,
                h: 18,
                hp: 999,
                type: 'arcade_cloud',
                color: '#f4f6ff',
                glow: true
              };
              solids.push(cloud);
              clouds.push(cloud);
            }
            return { centerX, baseY, totalWidth, clouds, groundY };
          };
          const sections = configs.length;
          for (let i = 0; i < sections; i++) {
            const cfg = configs[i % configs.length];
            let targetX = Math.floor(((i + 1) / (sections + 1)) * worldWidth);
            if (cfg.type === 'arcade') {
              targetX = Math.min(Math.max(950000, worldWidth * 0.72), worldWidth - 600);
            }
            const existing = houses.find((h) => {
              const dx = Math.abs(((h?.door?.x) || (h?.x || 0) + ((h?.w || 110) / 2)) - targetX);
              return dx < 220;
            });
            if (existing) continue;
            const solids = Platform.layers.solids = Platform.layers.solids || [];
            const ground = solids.find(p => p && p.type === 'ground');
            const groundY = ground ? ground.y : (DESIGN_H - 40);
            if (cfg.type === 'arcade') {
              const island = createArcadeIsland(targetX);
              addHouse(970000 + i, island.centerX - 55, island.baseY, cfg.label, cfg.type);
              const house = houses[houses.length - 1];
              if (house) {
                house.x = island.centerX - (house.w || 110) / 2;
                house.y = island.baseY - (house.h || 86) + 2;
                if (house.door) { house.door.x = island.centerX; house.door.y = island.baseY; }
                house.cloudSegments = island.clouds;
                house.isArcade = true;
              }
              const ladders = Platform.layers.ladders = Platform.layers.ladders || [];
              ladders.push({ x: island.centerX - 12, y: island.baseY, w: 24, h: Math.max(80, (island.groundY || (DESIGN_H - 40)) - island.baseY + 24), type: 'arcade_ladder' });
              if (!Platform.__arcadeAnnounced && typeof notify === 'function') {
                try { notify('Arcade Unlocked! Cloud house now accessible.', '#ff93f7'); } catch (_) { }
                Platform.__arcadeAnnounced = true;
              }
              continue;
            }
            const ensureAirSupportAt = (x, preferredOffset = 160, width = 200) => {
              const y = Math.max(groundY - preferredOffset, 140);
              const near = solids.find(s => s && s.type && s.type.indexOf('auto_') === 0 && Math.abs((s.x + s.w / 2) - x) < 80 && Math.abs(s.y - y) < 16);
              if (near) return near;
              const strip = { x: Math.max(20, x - width / 2), y, w: width, h: 16, hp: 999, type: 'auto_strip', color: '#23344f' };
              solids.push(strip);
              return strip;
            };
            const support = ensureAirSupportAt(targetX);
            addHouse(950000 + i, support.x + support.w / 2 - 55, support.y, cfg.label, cfg.type);
          }
        } catch (err) {
          console.warn('[Platform] ensureHouseSpread failed', err);
        }
      };

      Platform.ensureAllFloatingWorld = function () {
        try {
          const solids = Platform.layers.solids = Platform.layers.solids || [];
          const houses = Platform.layers.houses = Platform.layers.houses || [];
          const ground = solids.find(p => p && p.type === 'ground');
          const groundY = ground ? ground.y : (DESIGN_H - 40);
          const ensureSupportAt = (x, preferredOffset = 160, width = 220, tag = 'auto_cloud') => {
            const y = Math.max(groundY - preferredOffset, 140);
            let s = solids.find(p => p && p.type === tag && x >= p.x && x <= p.x + p.w && Math.abs(p.y - y) < 20);
            if (!s) { s = { x: Math.max(20, x - width / 2), y, w: width, h: 16, hp: 999, type: tag, color: '#22344f' }; solids.push(s); }
            return s;
          };
          // 1) Lift all houses that sit on ground
          for (const h of houses) {
            if (h?.isArcade) continue;
            if (!h) continue;
            const hh = h.h || 86;
            const baseY = (h.y || 0) + hh;
            if (baseY >= groundY - 2) {
              const doorX = (h.door?.x) || ((h.x || 0) + (h.w || 110) / 2);
              const support = ensureSupportAt(doorX, 160, 240, 'auto_house_strip');
              h.x = support.x + support.w / 2 - (h.w || 110) / 2;
              h.y = support.y - (h.h || 86) + 2;
              if (h.door) { h.door.x = support.x + support.w / 2; h.door.y = support.y; }
            }
          }
          // 2) Vendor + transport zones: put on strip
          try {
            if (Platform.vendorZone) {
              const vx = Platform.vendorZone.x || (worldWidth / 2);
              const sup = ensureSupportAt(vx, 150, 200, 'auto_vendor_strip');
              Platform.vendorZone.y = sup.y - 10;
            }
          } catch (_) { }
          try {
            if (Platform.transport?.start) {
              const sx = Platform.transport.start.x || 80;
              const sup = ensureSupportAt(sx, 150, 200, 'auto_train_strip');
              Platform.transport.start.y = sup.y - 10;
            }
            if (Platform.transport?.end) {
              const ex = Platform.transport.end.x || ((window.WORLD_WIDTH || 4096) - 80);
              const sup2 = ensureSupportAt(ex, 150, 200, 'auto_train_strip');
              Platform.transport.end.y = sup2.y - 10;
            }
          } catch (_) { }
          // 3) Platform.chests: elevate
          try {
            if (Array.isArray(Platform.chests)) {
              for (const c of Platform.chests) {
                const sup = ensureSupportAt((c.x || 0) + (c.w || 22) / 2, 160, 160, 'auto_chest_strip');
                c.y = sup.y - 28;
              }
            }
          } catch (_) { }
          // 4) Runtime pickups: mark for lifting in step
          Platform._liftRuntime = true;
        } catch (e) {
          console.warn('[Platform] ensureAllFloatingWorld failed', e);
        }
      };

      Platform.ensureTransportStrips = function () {
        try {
          const solids = Platform.layers.solids = Platform.layers.solids || [];
          const strips = [
            { id: 'transport_strip_entry', cx: 300, y: 250, w: 100, h: 20 },
            { id: 'transport_strip_plaza', cx: 1500, y: 250, w: 100, h: 20 },
            { id: 'transport_strip_market', cx: 2700, y: 250, w: 100, h: 20 },
            { id: 'transport_strip_arcade', cx: 3300, y: 250, w: 100, h: 20 },
            { id: 'transport_strip_skyrail', cx: 5100, y: 250, w: 100, h: 20 },
            { id: 'transport_strip_garden', cx: 5700, y: 250, w: 100, h: 20 }
          ];
          const stripIds = new Set(strips.map(s => s.id));
          for (let i = solids.length - 1; i >= 0; i--) {
            const sid = solids[i] && solids[i].id;
            if (sid && stripIds.has(sid)) {
              solids.splice(i, 1);
            }
          }
          for (const strip of strips) {
            solids.push({
              id: strip.id,
              x: strip.cx - strip.w / 2,
              y: strip.y,
              w: strip.w,
              h: strip.h,
              hp: 999999,
              type: 'floating_strip',
              color: '#9B7BB7'
            });
          }
        } catch (err) {
          console.warn('[Platform] ensureTransportStrips failed', err);
        }
      };

      const NPC_REGISTRY = [
        {
          id: 'npc_home', spriteType: 'maid', name: 'Roomie', title: 'House Keeper', building: 'home', color: '#ff93d3', offsetX: -18, offsetY: -4, positionRatio: 0.18,
          platformHeight: 280, platformWidth: 200, decorStyle: 'maid',
          skills: [
            { id: 'tidy_up', name: 'Tidy Up', rank: 'C', cost: 500, desc: 'Restore 100 HP to the party.' },
            { id: 'home_meal', name: 'Home Meal', rank: 'B', cost: 1800, desc: 'Heal +10% DEF buff for 60s.' },
            { id: 'sanctuary', name: 'Sanctuary', rank: 'A', cost: 5200, desc: 'Revive one fallen ally post-combat.' }
          ]
        },
        {
          id: 'npc_shop', spriteType: 'merchant', name: 'Mints', title: 'Candy Merchant', building: 'shop', color: '#9fd7ff', offsetX: 18, positionRatio: 0.24,
          platformHeight: 320, platformWidth: 220, decorStyle: 'merchant',
          skills: [
            { id: 'discount10', name: 'Discount', rank: 'C', cost: 900, desc: '10% cheaper shop prices.' },
            { id: 'bargain', name: 'Bargain', rank: 'B', cost: 2400, desc: '20% discount + +5% sell value.' },
            { id: 'trade_empire', name: 'Trade Empire', rank: 'A', cost: 6200, desc: 'Passive +100 gold every wave.' }
          ]
        },
        {
          id: 'npc_forge', spriteType: 'blacksmith', name: 'Brim', title: 'Forge Master', building: 'forge', color: '#ff8a3a', offsetX: -16, positionRatio: 0.30,
          platformHeight: 300, platformWidth: 240, decorStyle: 'blacksmith',
          skills: [
            { id: 'sharpen', name: 'Sharpen', rank: 'C', cost: 1200, desc: 'Increase weapon ATK by 10%.' },
            { id: 'temper', name: 'Temper', rank: 'B', cost: 3200, desc: '+25% ATK +5% crit chance.' },
            { id: 'master_forge', name: 'Master Forge', rank: 'S', cost: 12500, desc: 'Unlock legendary forge recipes.' }
          ]
        },
        {
          id: 'npc_apothecary', spriteType: 'alchemist', name: 'Seren', title: 'Apothecary', building: 'apothecary', color: '#36c777', offsetX: 14, positionRatio: 0.35,
          platformHeight: 350, platformWidth: 200, decorStyle: 'alchemist',
          skills: [
            { id: 'health_potion', name: 'Health Potion', rank: 'C', cost: 750, desc: 'Craft potions that heal 150 HP.' },
            { id: 'elixir', name: 'Elixir', rank: 'B', cost: 2400, desc: 'Heal & cleanse party debuffs.' },
            { id: 'philosopher_stone', name: 'Philosopher Stone', rank: 'A', cost: 7200, desc: 'Invulnerability bubble for 5s.' }
          ]
        },
        {
          id: 'npc_dealer', spriteType: 'dealer', name: 'Shade', title: 'Black Market Dealer', building: 'black_market', color: '#7b61ff', offsetX: 20, positionRatio: 0.40,
          skills: [
            { id: 'bm_access', name: 'Access Badge', rank: 'B', cost: 3100, desc: 'Unlock Black Market inventory.' },
            { id: 'stolen_goods', name: 'Stolen Goods', rank: 'A', cost: 7400, desc: '+50% rare drop rate.' },
            { id: 'shadow_trade', name: 'Shadow Trade', rank: 'S', cost: 15200, desc: 'Double rare drops once per stage.' }
          ]
        },
        {
          id: 'npc_librarian', spriteType: 'librarian', name: 'Page', title: 'Archivist', building: 'archives', color: '#c9a6ff', offsetX: -14, positionRatio: 0.46,
          skills: [
            { id: 'study', name: 'Study Session', rank: 'C', cost: 800, desc: '+20% mission XP.' },
            { id: 'research', name: 'Research Notes', rank: 'B', cost: 2600, desc: '+50% XP + lore entries.' },
            { id: 'ancient_knowledge', name: 'Ancient Knowledge', rank: 'A', cost: 8800, desc: '+1 skill slot for leader.' }
          ]
        },
        {
          id: 'npc_quest', spriteType: 'quest', name: 'Questor', title: 'Guild Liaison', building: 'inn', color: '#ffd56a', offsetX: 16, positionRatio: 0.52,
          skills: [
            { id: 'daily_quest', name: 'Daily Contracts', rank: 'C', cost: 600, desc: 'Unlock daily quests.' },
            { id: 'weekly_challenge', name: 'Weekly Challenge', rank: 'B', cost: 2200, desc: 'Unlock weekly bounty board.' },
            { id: 'legendary_quest', name: 'Legendary Quest', rank: 'A', cost: 7600, desc: 'Unlock epic quest line.' }
          ]
        },
        {
          id: 'npc_priest', spriteType: 'priestess', name: 'Lumina', title: 'Shrine Priestess', building: 'shrine', color: '#b1fff6', offsetX: 0, positionRatio: 0.58,
          platformHeight: 380, platformWidth: 200, decorStyle: 'priestess',
          skills: [
            { id: 'bless', name: 'Bless', rank: 'C', cost: 1100, desc: 'Grant +15% DEF aura.' },
            { id: 'divine_shield', name: 'Divine Shield', rank: 'B', cost: 3500, desc: 'Gain barrier shield at wave start.' },
            { id: 'resurrection', name: 'Resurrection', rank: 'S', cost: 16800, desc: 'Auto-revive one ally per stage.' }
          ]
        },
        {
          id: 'npc_post', spriteType: 'postman', name: 'Pip', title: 'Postmaster', building: 'mail', color: '#6ec1ff', offsetX: -12, positionRatio: 0.63,
          skills: [
            { id: 'mail_delivery', name: 'Mail Delivery', rank: 'C', cost: 500, desc: 'Receive random items daily.' },
            { id: 'express_mail', name: 'Express Mail', rank: 'B', cost: 1900, desc: 'Instant mission rewards twice per day.' },
            { id: 'treasure_mail', name: 'Treasure Mail', rank: 'A', cost: 6300, desc: 'Chance for legendary loot crate.' }
          ]
        },
        {
          id: 'npc_engineer', spriteType: 'engineer', name: 'Wrench', title: 'Engineer', building: 'workshop', color: '#ffa96e', offsetX: 14, positionRatio: 0.68,
          skills: [
            { id: 'tune_up', name: 'Tune Up', rank: 'C', cost: 1000, desc: 'Gear enhancement +10% stats.' },
            { id: 'overcharge', name: 'Overcharge', rank: 'B', cost: 3400, desc: 'Gear +30%, durability reset.' },
            { id: 'masterwork', name: 'Masterwork', rank: 'S', cost: 15000, desc: 'Unlock masterwork crafting slots.' }
          ]
        },
        {
          id: 'npc_arena', spriteType: 'arena', name: 'Valor', title: 'Arena Master', building: 'arena', color: '#ff7171', offsetX: -18, positionRatio: 0.73,
          skills: [
            { id: 'training', name: 'Training Regimen', rank: 'C', cost: 850, desc: '+10% ATK/DEF for 30 min.' },
            { id: 'gladiator', name: 'Gladiator Course', rank: 'B', cost: 2600, desc: '+20% combat skill damage.' },
            { id: 'champion_might', name: "Champion's Might", rank: 'S', cost: 16200, desc: 'Team buff +50% for boss fights.' }
          ]
        },
        {
          id: 'npc_photo', spriteType: 'photographer', name: 'Snap', title: 'Photographer', building: 'photo', color: '#ffe0a6', offsetX: 10, positionRatio: 0.78,
          skills: [
            { id: 'snapshot', name: 'Snapshot', rank: 'C', cost: 400, desc: 'Save stylish screenshots.' },
            { id: 'perfect_shot', name: 'Perfect Shot', rank: 'B', cost: 2100, desc: 'Unlock candy camera cosmetics.' },
            { id: 'legendary_pose', name: 'Legendary Pose', rank: 'A', cost: 5400, desc: 'Apply legendary aura postures.' }
          ]
        }
      ];

      function spawnWorldNPCs(force) {
        try {
          const st = window.st || {};
          st.npcs = st.npcs || [];
          if (st.npcs.length && !force) return;
          if (force) st.npcs.length = 0;
          const solids = Platform.layers.solids = Platform.layers.solids || [];
          const houses = Platform.layers.houses = Platform.layers.houses || [];
          const ground = solids.find(p => p && p.type === 'ground');
          const groundY = ground ? ground.y : (DESIGN_H - 40);
          const ensureSupportAt = (x, preferredOffset = 150, width = 200, tag = 'npc_platform') => {
            // Make platforms more visible - lower height (150-250px above ground)
            const y = groundY - (150 + Math.random() * 100);
            let s = solids.find(p => p && p.type === tag && x >= p.x && x <= p.x + p.w && Math.abs(p.y - y) < 18);
            if (!s) {
              s = {
                x: Math.max(20, x - width / 2),
                y,
                w: width,
                h: 20,  // Thicker platform for visibility
                hp: 999,
                type: tag,
                color: '#ff6b6b'  // Bright red for visibility
              };
              solids.push(s);
            }
            return s;
          };
          const worldWidth = (window.WORLD_WIDTH || WORLD_WIDTH || DESIGN_W * 2);
          NPC_REGISTRY.forEach((entry, idx) => {
            let anchor = null;
            if (entry.building) {
              anchor = houses.find(h => h && h.type === entry.building) || null;
            }
            let x, y;
            if (anchor && anchor.door) {
              x = anchor.door.x;
              y = anchor.door.y - 4;
            } else {
              const ratio = entry.positionRatio != null ? entry.positionRatio : ((idx + 1) / (NPC_REGISTRY.length + 1));
              const fx = Math.max(80, Math.min(worldWidth - 80, ratio * worldWidth));
              const strip = ensureSupportAt(fx);
              // Link platform to NPC for decoration system
              strip.npcId = entry.id;
              // Add decorations to the platform
              addNPCPlatformDecor(strip, entry.spriteType);
              x = strip.x + strip.w / 2;
              y = strip.y - 4;
            }
            x += entry.offsetX || 0;
            y += entry.offsetY || 0;
            const sprite = getNPCSprite({ id: entry.id, registry: entry, color: entry.color || '#ffd56a' });
            st.npcs.push({
              id: entry.id,
              name: entry.name,
              title: entry.title,
              building: entry.building,
              x,
              y,
              w: entry.w || 26,
              h: entry.h || 38,
              color: entry.color || '#ffd56a',
              range: entry.range || 70,
              registry: entry,
              sprite,
              spriteOffsetX: sprite ? sprite.width / 2 : 0,
              spriteOffsetY: sprite ? sprite.height : 0
            });
          });
          applyAllNPCSkillEffects(true);
        } catch (e) {
          console.warn('[NPC] spawn error', e);
        }
      }

      window.spawnWorldNPCs = spawnWorldNPCs;

      // Initialize decorations layer
      if (!Platform.layers.decorations) {
        Platform.layers.decorations = [];
      }

      function addNPCPlatformDecor(platform, npcType) {
        if (!platform || !npcType) return;

        // Ensure decorations array exists
        if (!Platform.layers.decorations) {
          Platform.layers.decorations = [];
        }
        const decorations = Platform.layers.decorations;
        const centerX = platform.x + platform.w / 2;
        const platformY = platform.y;

        // Add awning/canopy above platform
        const awning = {
          type: 'awning',
          x: centerX - 30,
          y: platformY - 20,
          w: 60,
          h: 15,
          color: getNPCThemeColor(npcType),
          platformId: platform.npcId
        };
        decorations.push(awning);

        // Add themed decorations based on NPC type
        const decorProps = getNPCDecorProps(npcType, centerX, platformY, platform);
        decorations.push(...decorProps);
      }

      function getNPCThemeColor(npcType) {
        const colors = {
          'merchant': '#9fd7ff',
          'blacksmith': '#ff8a3a',
          'alchemist': '#36c777',
          'librarian': '#c9a6ff',
          'priestess': '#b1fff6',
          'dealer': '#7b61ff',
          'arena': '#ff7171',
          'engineer': '#ffa96e',
          'postman': '#6ec1ff',
          'photographer': '#ffe0a6',
          'quest': '#ffd56a',
          'maid': '#ff93d3'
        };
        return colors[npcType] || '#ffd56a';
      }

      function getNPCDecorProps(npcType, centerX, platformY, platform) {
        const props = [];

        switch (npcType) {
          case 'merchant':
            // Coin bags and treasure chests
            props.push({ type: 'coin_bag', x: centerX - 20, y: platformY - 8, w: 8, h: 6, color: '#ffd56a' });
            props.push({ type: 'treasure_chest', x: centerX + 15, y: platformY - 10, w: 10, h: 8, color: '#8b6f2a' });
            break;
          case 'blacksmith':
            // Anvil and weapon rack
            props.push({ type: 'anvil', x: centerX - 25, y: platformY - 6, w: 20, h: 8, color: '#41464f' });
            props.push({ type: 'weapon_rack', x: centerX + 15, y: platformY - 12, w: 8, h: 16, color: '#8b5520' });
            break;
          case 'alchemist':
            // Potion bottles and herbs
            props.push({ type: 'potion_bottle', x: centerX - 20, y: platformY - 8, w: 6, h: 12, color: '#36c777' });
            props.push({ type: 'potion_bottle', x: centerX - 10, y: platformY - 8, w: 6, h: 12, color: '#ff6b6b' });
            props.push({ type: 'herbs', x: centerX + 15, y: platformY - 6, w: 12, h: 4, color: '#8b6f2a' });
            break;
          case 'librarian':
            // Book stacks
            props.push({ type: 'book_stack', x: centerX - 25, y: platformY - 8, w: 16, h: 12, color: '#6c4cff' });
            props.push({ type: 'book_stack', x: centerX + 10, y: platformY - 8, w: 16, h: 12, color: '#4a2c8b' });
            break;
          case 'priestess':
            // Candles and shrine elements
            props.push({ type: 'candle', x: centerX - 20, y: platformY - 10, w: 4, h: 8, color: '#ffd56a' });
            props.push({ type: 'candle', x: centerX + 15, y: platformY - 10, w: 4, h: 8, color: '#ffd56a' });
            props.push({ type: 'shrine_symbol', x: centerX - 8, y: platformY - 12, w: 16, h: 8, color: '#b1fff6' });
            break;
          case 'arena':
            // Training equipment
            props.push({ type: 'training_dummy', x: centerX - 15, y: platformY - 12, w: 8, h: 16, color: '#8b6f2a' });
            props.push({ type: 'weapon_rack', x: centerX + 10, y: platformY - 12, w: 8, h: 16, color: '#41464f' });
            break;
          case 'engineer':
            // Tools and gadgets
            props.push({ type: 'toolbox', x: centerX - 20, y: platformY - 6, w: 12, h: 8, color: '#ffa96e' });
            props.push({ type: 'gear', x: centerX + 15, y: platformY - 8, w: 8, h: 8, color: '#41464f' });
            break;
          default:
            // Generic market goods
            props.push({ type: 'barrel', x: centerX - 20, y: platformY - 8, w: 12, h: 10, color: '#8b6f2a' });
            props.push({ type: 'crate', x: centerX + 10, y: platformY - 8, w: 12, h: 10, color: '#5a4520' });
        }

        return props.map(prop => ({
          ...prop,
          platformId: platform?.npcId || 'unknown'
        }));
      }

      const NPC_SPRITE_CACHE = {};

      const NPC_SKILL_STORAGE_KEY = 'A1K_NPC_SKILLS_V1';
      const RANK_ORDER = { C: 1, B: 2, A: 3, S: 4 };

      function saveNPCSkillStorage() {
        try {
          localStorage.setItem(NPC_SKILL_STORAGE_KEY, JSON.stringify(st.npcSkills || {}));
        } catch (_) { }
      }

      function loadNPCSkillStorage() {
        try {
          const raw = localStorage.getItem(NPC_SKILL_STORAGE_KEY);
          if (!raw) return;
          const data = JSON.parse(raw);
          if (data && typeof data === 'object') {
            st.npcSkills = data;
          }
        } catch (_) { }
      }

      function resetNPCSkillEffects() {
        st.npcSkillEffects = {
          atkMul: 1,
          gearMul: 1,
          combatAtkMul: 1,
          xpBonus: 0,
          dropBonus: 0,
          permanentDefBonus: 0,
          tempDefBuff: null,
          shopDiscount: 0,
          sellBonus: 0,
          autoReviveCharges: 0,
          goldTick: null,
          invulnUntil: null,
          critBonus: 0,
          rareDouble: false,
          blackMarketUnlocked: st.npcSkillEffects?.blackMarketUnlocked || false,
          extraSkillSlot: st.npcSkillEffects?.extraSkillSlot || false,
          loreUnlocked: st.npcSkillEffects?.loreUnlocked || false
        };
      }

      function healParty(amount, silent) {
        if (!amount || silent) return;
        const players = st.players || [];
        for (const p of players) {
          if (!p || p.isDefeated) continue;
          const prev = p.hp;
          p.hp = Math.min(p.hpMax || p.hp, p.hp + amount);
          if (p.hp > prev) addFloater(p.x, p.y - 50, '+' + (p.hp - prev), '#36c777');
        }
        mirrorLeaderHP();
      }

      function applyNPCSkillEffect(skillId, npc, options = {}) {
        const silent = !!options.silent;
        const now = performance.now ? performance.now() : Date.now();
        const eff = st.npcSkillEffects || {};
        switch (skillId) {
          case 'tidy_up':
            healParty(100, silent);
            break;
          case 'home_meal':
            healParty(150, silent);
            if (!silent) {
              eff.tempDefBuff = { value: Math.max(eff.tempDefBuff?.value || 0, 0.10), expires: now + 60000 };
            }
            break;
          case 'sanctuary':
            eff.autoReviveCharges = (eff.autoReviveCharges || 0) + 1;
            break;
          case 'discount10':
            eff.shopDiscount = Math.max(eff.shopDiscount || 0, 0.10);
            break;
          case 'bargain':
            eff.shopDiscount = Math.max(eff.shopDiscount || 0, 0.20);
            eff.sellBonus = Math.max(eff.sellBonus || 0, 0.05);
            break;
          case 'trade_empire':
            eff.goldTick = eff.goldTick || { amount: 0, interval: 20000, next: now + 20000 };
            eff.goldTick.amount = Math.max(eff.goldTick.amount || 0, 100);
            eff.goldTick.next = now + (silent ? eff.goldTick.interval : 5000);
            break;
          case 'sharpen':
            eff.atkMul = Math.max(eff.atkMul || 1, 1.10);
            break;
          case 'temper':
            eff.atkMul = Math.max(eff.atkMul || 1, 1.25);
            eff.critBonus = Math.max(eff.critBonus || 0, 0.05);
            break;
          case 'master_forge':
            eff.atkMul = Math.max(eff.atkMul || 1, 1.50);
            eff.legendaryForge = true;
            break;
          case 'health_potion':
            healParty(150, silent);
            eff.potionHeal = Math.max(eff.potionHeal || 0, 150);
            break;
          case 'elixir':
            healParty(200, silent);
            eff.tempDefBuff = { value: Math.max(eff.tempDefBuff?.value || 0.12, 0.12), expires: now + 45000 };
            st.statusEffects = [];
            break;
          case 'philosopher_stone':
            if (!silent) eff.invulnUntil = Math.max(eff.invulnUntil || 0, now + 5000);
            break;
          case 'bm_access':
            eff.blackMarketUnlocked = true;
            break;
          case 'stolen_goods':
            eff.dropBonus = Math.max(eff.dropBonus || 0, 0.50);
            break;
          case 'shadow_trade':
            eff.rareDouble = true;
            break;
          case 'study':
            eff.xpBonus = Math.max(eff.xpBonus || 0, 0.20);
            break;
          case 'research':
            eff.xpBonus = Math.max(eff.xpBonus || 0, 0.50);
            eff.loreUnlocked = true;
            break;
          case 'ancient_knowledge':
            eff.extraSkillSlot = true;
            break;
          case 'daily_quest':
            eff.dailyQuest = true;
            break;
          case 'weekly_challenge':
            eff.weeklyQuest = true;
            break;
          case 'legendary_quest':
            eff.legendaryQuest = true;
            break;
          case 'bless':
            eff.permanentDefBonus = Math.max(eff.permanentDefBonus || 0, 0.15);
            break;
          case 'divine_shield':
            eff.shieldBarrier = Math.max(eff.shieldBarrier || 0, 200);
            break;
          case 'resurrection':
            eff.autoReviveCharges = (eff.autoReviveCharges || 0) + 1;
            break;
          case 'mail_delivery':
            eff.mailDaily = true;
            break;
          case 'express_mail':
            eff.mailInstant = true;
            break;
          case 'treasure_mail':
            eff.mailTreasure = true;
            break;
          case 'tune_up':
            eff.gearMul = Math.max(eff.gearMul || 1, 1.10);
            break;
          case 'overcharge':
            eff.gearMul = Math.max(eff.gearMul || 1, 1.30);
            break;
          case 'masterwork':
            eff.gearMul = Math.max(eff.gearMul || 1, 2.00);
            eff.masterwork = true;
            break;
          case 'training':
            eff.combatAtkMul = Math.max(eff.combatAtkMul || 1, 1.10);
            eff.permanentDefBonus = Math.max(eff.permanentDefBonus || 0, 0.05);
            break;
          case 'gladiator':
            eff.combatAtkMul = Math.max(eff.combatAtkMul || 1, 1.20);
            break;
          case 'champion_might':
            eff.combatAtkMul = Math.max(eff.combatAtkMul || 1, 1.50);
            break;
          case 'snapshot':
            eff.photoUnlocked = true;
            break;
          case 'perfect_shot':
            eff.photoUnlocked = true;
            eff.photoCosmetics = true;
            break;
          case 'legendary_pose':
            eff.photoLegendary = true;
            break;
          default:
            break;
        }
      }

      function applyAllNPCSkillEffects(silent) {
        resetNPCSkillEffects();
        const skillsByNpc = st.npcSkills || {};
        for (const [npcId, skillMap] of Object.entries(skillsByNpc)) {
          const npc = NPC_REGISTRY.find(n => n.id === npcId);
          if (!npc || !skillMap) continue;
          for (const skillId of Object.keys(skillMap)) {
            if (!skillMap[skillId]) continue;
            applyNPCSkillEffect(skillId, npc, { silent: !!silent });
          }
        }
        try { recalcStats(); } catch (_) { }
        try { updateCurrencies && updateCurrencies(); } catch (_) { }
        try { updateDropRate && updateDropRate(); } catch (_) { }
      }

      function getBestSkillRank(npc) {
        if (!npc || !npc.registry?.skills) return 'C';
        let best = 'C';
        for (const skill of npc.registry.skills) {
          if (!skill) continue;
          const rank = skill.rank || 'C';
          if ((RANK_ORDER[rank] || 1) > (RANK_ORDER[best] || 1)) best = rank;
        }
        return best;
      }

      function drawRankBadge(ctx, x, y, rank) {
        const colors = { C: '#9aa7b8', B: '#5ba8ff', A: '#c58dff', S: '#ffd56a' };
        const color = colors[rank] || '#9aa7b8';
        ctx.save();
        ctx.fillStyle = color;
        ctx.strokeStyle = 'rgba(11,18,32,0.6)';
        ctx.lineWidth = 2;
        ctx.beginPath(); ctx.arc(x, y, 10, 0, Math.PI * 2); ctx.fill(); ctx.stroke();
        ctx.fillStyle = rank === 'S' ? '#5a3200' : '#0b1220';
        ctx.font = 'bold 10px ui-monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(rank, x, y + 1);
        ctx.restore();
      }

      function getNPCSprite(npc) {
        try {
          const key = npc.id || npc.registry?.id;
          if (NPC_SPRITE_CACHE[key]) return NPC_SPRITE_CACHE[key];
          const type = npc.registry?.spriteType || npc.registry?.building || 'default';
          const sprite = makeNPCSprite(type, npc.color || '#ffd56a');
          NPC_SPRITE_CACHE[key] = sprite;
          return sprite;
        } catch (_) {
          return null;
        }
      }

      function shade(hex, amt) {
        const num = parseInt(hex.replace('#', ''), 16);
        const r = Math.min(255, Math.max(0, ((num >> 16) & 0xff) + amt));
        const g = Math.min(255, Math.max(0, ((num >> 8) & 0xff) + amt));
        const b = Math.min(255, Math.max(0, (num & 0xff) + amt));
        return '#' + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
      }

      function makeNPCSprite(type, baseColor) {
        const canvas = document.createElement('canvas');
        canvas.width = 48;
        canvas.height = 64;
        const ctx = canvas.getContext('2d');
        const skin = '#ffe0c7';
        const hair = shade(baseColor, -40);
        const outfit = baseColor;

        function drawBase() {
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          // shadow
          ctx.fillStyle = 'rgba(0,0,0,0.25)';
          ctx.beginPath(); ctx.ellipse(24, 58, 14, 6, 0, 0, Math.PI * 2); ctx.fill();
          // legs
          ctx.fillStyle = shade(outfit, -40);
          ctx.fillRect(20, 38, 6, 16);
          ctx.fillRect(26, 38, 6, 16);
          ctx.fillStyle = '#0b1220';
          ctx.fillRect(20, 52, 6, 4);
          ctx.fillRect(26, 52, 6, 4);
          // body
          ctx.fillStyle = outfit;
          ctx.fillRect(16, 26, 16, 14);
          ctx.fillStyle = shade(outfit, -20);
          ctx.fillRect(16, 26, 16, 4);
          // arms
          ctx.fillStyle = outfit;
          ctx.fillRect(12, 28, 6, 10);
          ctx.fillRect(30, 28, 6, 10);
          // hands
          ctx.fillStyle = skin;
          ctx.fillRect(12, 36, 6, 4);
          ctx.fillRect(30, 36, 6, 4);
          // head
          ctx.fillStyle = skin;
          ctx.beginPath(); ctx.ellipse(24, 18, 10, 9, 0, 0, Math.PI * 2); ctx.fill();
          // hair fringe
          ctx.fillStyle = hair;
          ctx.beginPath(); ctx.ellipse(24, 12, 12, 10, 0, 0, Math.PI * 2); ctx.fill();
          ctx.fillRect(14, 15, 20, 8);
          // eyes
          ctx.fillStyle = '#0b1220';
          ctx.fillRect(20, 17, 3, 3);
          ctx.fillRect(27, 17, 3, 3);
          // mouth
          ctx.fillStyle = '#ff7a6a';
          ctx.fillRect(23, 22, 4, 2);
        }

        function drawApron() {
          ctx.fillStyle = '#ffffff';
          ctx.fillRect(18, 28, 12, 12);
          ctx.fillRect(20, 40, 8, 6);
          ctx.strokeStyle = '#ffd6ea';
          ctx.beginPath(); ctx.moveTo(18, 28); ctx.lineTo(30, 28); ctx.stroke();
        }

        function drawCoinBag() {
          ctx.fillStyle = '#6f4c2f';
          ctx.beginPath(); ctx.ellipse(36, 44, 6, 8, 0, 0, Math.PI * 2); ctx.fill();
          ctx.strokeStyle = '#ffd56a'; ctx.beginPath(); ctx.arc(36, 38, 4, 0, Math.PI * 2); ctx.stroke();
        }

        function drawHammer() {
          ctx.fillStyle = '#8b5520'; ctx.fillRect(34, 30, 4, 14);
          ctx.fillStyle = '#41464f'; ctx.fillRect(30, 32, 12, 6);
        }

        function drawPotion() {
          ctx.fillStyle = 'rgba(54,199,119,0.65)'; ctx.beginPath(); ctx.ellipse(34, 40, 6, 8, 0, 0, Math.PI * 2); ctx.fill();
          ctx.fillStyle = '#ffffff'; ctx.fillRect(32, 30, 4, 6);
        }

        function drawCloak() {
          ctx.fillStyle = 'rgba(11,18,32,0.85)';
          ctx.beginPath(); ctx.moveTo(16, 26); ctx.lineTo(8, 48); ctx.lineTo(18, 52); ctx.lineTo(24, 34); ctx.closePath(); ctx.fill();
          ctx.beginPath(); ctx.moveTo(32, 26); ctx.lineTo(40, 48); ctx.lineTo(30, 52); ctx.lineTo(24, 34); ctx.closePath(); ctx.fill();
        }

        function drawBook() {
          ctx.fillStyle = '#6c4cff'; ctx.fillRect(32, 26, 8, 10);
          ctx.fillStyle = '#ffffff'; ctx.fillRect(33, 27, 6, 8);
        }

        function drawScroll() {
          ctx.fillStyle = '#ffd56a'; ctx.fillRect(32, 30, 10, 4);
          ctx.fillStyle = '#cfa84b'; ctx.fillRect(32, 29, 2, 6);
          ctx.fillRect(40, 29, 2, 6);
        }

        function drawHalo() {
          ctx.strokeStyle = '#9fd7ff'; ctx.lineWidth = 2;
          ctx.beginPath(); ctx.ellipse(24, 6, 10, 4, 0, 0, Math.PI * 2); ctx.stroke();
          ctx.lineWidth = 1;
        }

        function drawMailbag() {
          ctx.fillStyle = '#2e3b58'; ctx.fillRect(30, 34, 10, 12);
          ctx.fillStyle = '#6ec1ff'; ctx.fillRect(32, 36, 6, 8);
        }

        function drawGoggles() {
          ctx.fillStyle = '#303a4f'; ctx.fillRect(18, 14, 12, 3);
          ctx.fillStyle = '#c3d1ff'; ctx.fillRect(19, 14, 4, 3);
          ctx.fillRect(25, 14, 4, 3);
        }

        function drawSwordAura() {
          ctx.fillStyle = 'rgba(255,113,113,0.35)'; ctx.fillRect(34, 20, 6, 26);
          ctx.fillStyle = '#ff7171'; ctx.fillRect(36, 20, 2, 24);
        }

        function drawCamera() {
          ctx.fillStyle = '#1b1f2a'; ctx.fillRect(31, 32, 12, 10);
          ctx.fillStyle = '#9fd7ff'; ctx.beginPath(); ctx.arc(37, 37, 3, 0, Math.PI * 2); ctx.fill();
        }

        drawBase();
        switch (type) {
          case 'maid':
            drawApron();
            break;
          case 'merchant':
            drawCoinBag();
            break;
          case 'blacksmith':
            drawHammer();
            break;
          case 'alchemist':
            drawPotion();
            break;
          case 'dealer':
            drawCloak();
            break;
          case 'librarian':
            drawBook();
            break;
          case 'quest':
            drawScroll();
            break;
          case 'priestess':
            drawHalo();
            break;
          case 'postman':
            drawMailbag();
            break;
          case 'engineer':
            drawGoggles();
            break;
          case 'arena':
            drawSwordAura();
            break;
          case 'photographer':
            drawCamera();
            break;
          default:
            break;
        }
        return { canvas, width: canvas.width, height: canvas.height };
      }

      let npcMenuOverlay = null;
      let npcMenuPanel = null;
      let npcMenuSkills = null;
      let npcMenuImg = null;
      let npcMenuTitle = null;
      let npcMenuDesc = null;
      let npcMenuCloseBtn = null;
      let npcMenuCurrent = null;

      function ensureNPCMenu() {
        if (npcMenuOverlay) return;
        npcMenuOverlay = document.createElement('div');
        npcMenuOverlay.id = 'npcMenuOverlay';
        Object.assign(npcMenuOverlay.style, {
          position: 'fixed', inset: '0', background: 'rgba(7, 10, 18, 0.65)',
          display: 'none', alignItems: 'center', justifyContent: 'center', zIndex: '16000'
        });
        npcMenuPanel = document.createElement('div');
        Object.assign(npcMenuPanel.style, {
          background: '#0f1626', border: '1px solid #23344f', borderRadius: '14px',
          padding: '18px 22px', minWidth: '360px', maxWidth: '440px', color: '#eaf3ff',
          font: '13px ui-monospace, monospace', boxShadow: '0 24px 50px rgba(0,0,0,0.45)'
        });

        const header = document.createElement('div');
        Object.assign(header.style, { display: 'flex', alignItems: 'center', gap: '14px', marginBottom: '12px' });
        npcMenuImg = document.createElement('img');
        Object.assign(npcMenuImg.style, { width: '72px', height: '96px', imageRendering: 'pixelated', borderRadius: '10px', border: '1px solid #23344f', background: '#0b1220' });
        const headerTextWrap = document.createElement('div');
        npcMenuTitle = document.createElement('div'); npcMenuTitle.style.fontWeight = '700'; npcMenuTitle.style.fontSize = '16px';
        npcMenuDesc = document.createElement('div'); npcMenuDesc.style.color = '#9fd7ff'; npcMenuDesc.style.fontSize = '12px'; npcMenuDesc.style.marginTop = '2px';
        headerTextWrap.appendChild(npcMenuTitle);
        headerTextWrap.appendChild(npcMenuDesc);
        header.appendChild(npcMenuImg);
        header.appendChild(headerTextWrap);

        npcMenuSkills = document.createElement('div');
        Object.assign(npcMenuSkills.style, { display: 'flex', flexDirection: 'column', gap: '10px', marginTop: '12px' });

        npcMenuCloseBtn = document.createElement('button');
        npcMenuCloseBtn.textContent = 'Close';
        Object.assign(npcMenuCloseBtn.style, {
          marginTop: '18px', alignSelf: 'flex-end', padding: '6px 16px', background: '#1a2335',
          border: '1px solid #2f3f57', color: '#eaf3ff', borderRadius: '8px', cursor: 'pointer'
        });
        npcMenuCloseBtn.addEventListener('click', closeNPCMenu);

        npcMenuPanel.appendChild(header);
        npcMenuPanel.appendChild(npcMenuSkills);
        npcMenuPanel.appendChild(npcMenuCloseBtn);
        npcMenuOverlay.appendChild(npcMenuPanel);
        npcMenuOverlay.addEventListener('click', (ev) => { if (ev.target === npcMenuOverlay) closeNPCMenu(); });
        document.body.appendChild(npcMenuOverlay);
      }

      function badgeForRank(rank) {
        const badge = document.createElement('span');
        badge.textContent = rank;
        badge.style.display = 'inline-flex';
        badge.style.alignItems = 'center';
        badge.style.justifyContent = 'center';
        badge.style.fontWeight = '700';
        badge.style.width = '24px';
        badge.style.height = '24px';
        badge.style.marginRight = '10px';
        badge.style.borderRadius = '50%';
        badge.style.border = '1px solid rgba(255,255,255,0.35)';
        badge.style.fontSize = '11px';
        const colors = { C: '#9aa7b8', B: '#5ba8ff', A: '#c58dff', S: '#ffd56a' };
        badge.style.background = colors[rank] || '#9aa7b8';
        badge.style.color = rank === 'S' ? '#5a3200' : '#0b1220';
        return badge;
      }

      function renderNPCSkills(npc) {
        npcMenuSkills.innerHTML = '';
        const st = window.st || {};
        const owned = (st.npcSkills && st.npcSkills[npc.id]) || {};
        npc.registry.skills.forEach((skill) => {
          const row = document.createElement('div');
          Object.assign(row.style, { display: 'flex', alignItems: 'center', justifyContent: 'space-between', gap: '12px', background: '#151e30', padding: '10px 12px', borderRadius: '10px', border: '1px solid #22344f' });
          const left = document.createElement('div');
          Object.assign(left.style, { display: 'flex', alignItems: 'center', gap: '10px', flex: '1 1 auto' });
          left.appendChild(badgeForRank(skill.rank));
          const textWrap = document.createElement('div');
          const title = document.createElement('div'); title.textContent = skill.name; title.style.fontWeight = '700';
          const desc = document.createElement('div'); desc.textContent = skill.desc; desc.style.fontSize = '11px'; desc.style.color = '#9fb8ff';
          textWrap.appendChild(title);
          textWrap.appendChild(desc);
          left.appendChild(textWrap);
          row.appendChild(left);

          const action = document.createElement('button');
          const isOwned = !!owned[skill.id];
          action.textContent = isOwned ? 'Owned' : `Buy — ${skill.cost.toLocaleString()}g`;
          Object.assign(action.style, {
            padding: '6px 12px', borderRadius: '8px', border: '1px solid #2f405f', cursor: isOwned ? 'default' : 'pointer',
            background: isOwned ? '#1e2636' : '#2a3b5a', color: '#eaf3ff', fontWeight: '600'
          });
          if (!isOwned) {
            action.addEventListener('click', () => {
              const st = window.st || {};
              st.gold = st.gold || 0;
              if (st.gold < skill.cost) {
                try { notify && notify('Not enough gold', '#ff7a6a'); } catch (_) { }
                return;
              }
              st.gold -= skill.cost;
              st.npcSkills = st.npcSkills || {};
              st.npcSkills[npc.id] = st.npcSkills[npc.id] || {};
              st.npcSkills[npc.id][skill.id] = true;
              saveNPCSkillStorage();
              applyNPCSkillEffect(skill.id, npc, { silent: false });
              try { recalcStats(); } catch (_) { }
              try { updateCurrencies && updateCurrencies(); } catch (_) { }
              try { updateDropRate && updateDropRate(); } catch (_) { }
              try { notify && notify(`${skill.name} acquired!`, '#9fd7ff'); } catch (_) { }
              renderNPCSkills(npc);
            });
          }
          row.appendChild(action);
          npcMenuSkills.appendChild(row);
        });
      }

      function openNPCMenu(npc) {
        ensureNPCMenu();
        const st = window.st || {};
        npcMenuCurrent = npc;
        const sprite = npc.sprite || getNPCSprite(npc);
        if (sprite && sprite.canvas) {
          npcMenuImg.style.background = '#0b1220';
          npcMenuImg.src = sprite.canvas.toDataURL();
        } else {
          npcMenuImg.src = '';
          npcMenuImg.style.background = npc.color || '#ffd56a';
        }
        npcMenuTitle.textContent = `${npc.name}`;
        npcMenuDesc.textContent = npc.title || '';
        renderNPCSkills(npc);
        npcMenuOverlay.style.display = 'flex';
        st._npcMenuOpen = true;
      }

      function closeNPCMenu() {
        const st = window.st || {};
        npcMenuCurrent = null;
        if (npcMenuOverlay) npcMenuOverlay.style.display = 'none';
        st._npcMenuOpen = false;
      }

      try {
        window.addEventListener('keydown', (ev) => {
          if (ev.key === 'Escape') {
            const st = window.st || {};
            if (st._npcMenuOpen) {
              ev.preventDefault();
              closeNPCMenu();
            }
          }
        });
      } catch (_) { }

      function drawNPCDecorations(ctx) {
        const decorations = Platform.layers.decorations;
        if (!decorations || !decorations.length) {
          console.log('[Decorations] No decorations to draw');
          return;
        }

        console.log('[Decorations] Drawing', decorations.length, 'decorations');
        const camX = camera?.x || 0;
        ctx.save();

        for (const decor of decorations) {
          const screenX = decor.x - camX;

          // Skip if off-screen
          if (screenX < -50 || screenX > DESIGN_W + 50) continue;

          console.log('[Decorations] Drawing', decor.type, 'at', screenX, decor.y, 'size', decor.w, 'x', decor.h);
          ctx.fillStyle = decor.color || '#ffd56a';

          switch (decor.type) {
            case 'awning':
              // Draw triangular awning
              ctx.fillStyle = decor.color || '#ff6b6b'; // Bright red for visibility
              ctx.beginPath();
              ctx.moveTo(screenX, decor.y);
              ctx.lineTo(screenX + decor.w / 2, decor.y - decor.h);
              ctx.lineTo(screenX + decor.w, decor.y);
              ctx.closePath();
              ctx.fill();
              // Add awning trim
              ctx.strokeStyle = '#000000';
              ctx.lineWidth = 3;
              ctx.stroke();
              break;

            case 'coin_bag':
              // Draw coin bag
              ctx.fillStyle = '#ffd56a'; // Bright gold
              ctx.fillRect(screenX, decor.y, decor.w, decor.h);
              ctx.strokeStyle = '#000000';
              ctx.lineWidth = 2;
              ctx.strokeRect(screenX, decor.y, decor.w, decor.h);
              break;

            case 'treasure_chest':
              // Draw treasure chest
              ctx.fillStyle = '#8b6f2a'; // Brown
              ctx.fillRect(screenX, decor.y, decor.w, decor.h);
              ctx.strokeStyle = '#000000';
              ctx.lineWidth = 2;
              ctx.strokeRect(screenX, decor.y, decor.w, decor.h);
              // Add chest lid
              ctx.fillStyle = '#5a4520';
              ctx.fillRect(screenX + 2, decor.y - 2, decor.w - 4, 2);
              break;

            case 'anvil':
              // Draw anvil
              ctx.fillRect(screenX, decor.y, decor.w, decor.h);
              ctx.strokeStyle = '#2b2b2b';
              ctx.lineWidth = 1;
              ctx.strokeRect(screenX, decor.y, decor.w, decor.h);
              break;

            case 'weapon_rack':
              // Draw weapon rack
              ctx.fillRect(screenX, decor.y, decor.w, decor.h);
              ctx.strokeStyle = '#5a4520';
              ctx.lineWidth = 1;
              ctx.strokeRect(screenX, decor.y, decor.w, decor.h);
              break;

            case 'potion_bottle':
              // Draw potion bottle
              ctx.fillRect(screenX, decor.y, decor.w, decor.h);
              ctx.strokeStyle = '#2b2b2b';
              ctx.lineWidth = 1;
              ctx.strokeRect(screenX, decor.y, decor.w, decor.h);
              break;

            case 'herbs':
              // Draw herbs
              ctx.fillRect(screenX, decor.y, decor.w, decor.h);
              break;

            case 'book_stack':
              // Draw book stack
              ctx.fillRect(screenX, decor.y, decor.w, decor.h);
              ctx.strokeStyle = '#4a2c8b';
              ctx.lineWidth = 1;
              ctx.strokeRect(screenX, decor.y, decor.w, decor.h);
              break;

            case 'candle':
              // Draw candle
              ctx.fillRect(screenX, decor.y, decor.w, decor.h);
              // Add flame
              ctx.fillStyle = '#ff6b6b';
              ctx.fillRect(screenX + 1, decor.y - 2, decor.w - 2, 2);
              break;

            case 'shrine_symbol':
              // Draw shrine symbol
              ctx.fillRect(screenX, decor.y, decor.w, decor.h);
              break;

            case 'training_dummy':
              // Draw training dummy
              ctx.fillRect(screenX, decor.y, decor.w, decor.h);
              ctx.strokeStyle = '#5a4520';
              ctx.lineWidth = 1;
              ctx.strokeRect(screenX, decor.y, decor.w, decor.h);
              break;

            case 'toolbox':
              // Draw toolbox
              ctx.fillRect(screenX, decor.y, decor.w, decor.h);
              ctx.strokeStyle = '#8b6f2a';
              ctx.lineWidth = 1;
              ctx.strokeRect(screenX, decor.y, decor.w, decor.h);
              break;

            case 'gear':
              // Draw gear
              ctx.beginPath();
              ctx.arc(screenX + decor.w / 2, decor.y + decor.h / 2, decor.w / 2, 0, Math.PI * 2);
              ctx.fill();
              ctx.strokeStyle = '#2b2b2b';
              ctx.lineWidth = 1;
              ctx.stroke();
              break;

            case 'barrel':
              // Draw barrel
              ctx.fillRect(screenX, decor.y, decor.w, decor.h);
              ctx.strokeStyle = '#5a4520';
              ctx.lineWidth = 1;
              ctx.strokeRect(screenX, decor.y, decor.w, decor.h);
              break;

            case 'crate':
              // Draw crate
              ctx.fillRect(screenX, decor.y, decor.w, decor.h);
              ctx.strokeStyle = '#3a2a10';
              ctx.lineWidth = 1;
              ctx.strokeRect(screenX, decor.y, decor.w, decor.h);
              break;
          }
        }

        ctx.restore();
      }

      function drawWorldNPCs(ctx) {
        const st = window.st;
        if (!st || !Array.isArray(st.npcs) || !st.npcs.length) return;
        const camX = camera?.x || 0;
        ctx.save();
        ctx.textAlign = 'center';
        console.log('[NPCs] Drawing', st.npcs.length, 'NPCs');
        for (const npc of st.npcs) {
          const sx = npc.x - camX;
          const bob = npc.bob || 0;
          const baseY = npc.y + bob;
          const h = (npc.h || 36) * 1.5; // Make NPCs 50% larger

          // Initialize renderer if needed
          if (!npc.renderer && window.NPCCharacterRenderer) {
            npc.renderer = new window.NPCCharacterRenderer(npc.id, {
              spriteType: npc.registry?.spriteType,
              color: npc.color,
              rank: getBestSkillRank(npc)
            });
          }

          // Render NPC with procedural renderer
          if (npc.renderer) {
            npc.renderer.render(ctx, sx, baseY, {
              animState: 'idle',
              animTime: performance.now(),
              facingLeft: false
            });
          } else {
            // Fallback rendering if renderer not available
            const w = (npc.w || 24) * 1.5;
            ctx.fillStyle = npc.color || '#ffd56a';
            ctx.fillRect(sx - w / 2, baseY - h, w, h);
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(sx - w / 2, baseY - h, w, h);
          }

          const rank = getBestSkillRank(npc);
          drawRankBadge(ctx, sx, baseY - h - 26, rank);
          ctx.font = 'bold 16px ui-monospace'; // Larger font
          ctx.lineWidth = 4;
          ctx.strokeStyle = '#000000'; // Black outline
          ctx.strokeText(npc.name, sx, baseY - h - 8);
          ctx.fillStyle = '#ffff00'; // Bright yellow text
          ctx.fillText(npc.name, sx, baseY - h - 8);
          if (st._npcNear === npc) {
            ctx.font = 'bold 14px ui-monospace'; // Larger font
            const prompt = 'E — Talk';
            ctx.strokeStyle = '#000000'; // Black outline
            ctx.lineWidth = 3;
            ctx.strokeText(prompt, sx, baseY - h - 24);
            ctx.fillStyle = '#00ff00'; // Bright green
            ctx.fillText(prompt, sx, baseY - h - 24);
          }
        }
        ctx.restore();
      }

      function ensureCandyHouseBadgeElement() {
        let el = document.getElementById('candyHouseBadge');
        if (!el) {
          el = document.createElement('div');
          el.id = 'candyHouseBadge';
          el.textContent = 'Candy Dungeon — Press A';
          Object.assign(el.style, {
            position: 'fixed',
            minWidth: '140px',
            padding: '6px 10px',
            background: 'rgba(15, 22, 38, 0.88)',
            border: '1px solid #9fd7ff',
            borderRadius: '10px',
            color: '#eaf3ff',
            font: '11px ui-monospace, monospace',
            letterSpacing: '0.5px',
            textAlign: 'center',
            pointerEvents: 'none',
            display: 'none',
            boxShadow: '0 0 14px rgba(159,215,255,0.35)'
          });
          document.body.appendChild(el);
        }
        return el;
      }

      function ensureCandyMapMarker() {
        const wrap = document.getElementById('miniMapWrap');
        if (!wrap) return null;
        if (!wrap.dataset.hasCandyMarker) {
          wrap.style.position = 'relative';
          wrap.dataset.hasCandyMarker = '1';
        }
        let marker = document.getElementById('candyMapMarker');
        if (!marker) {
          marker = document.createElement('div');
          marker.id = 'candyMapMarker';
          Object.assign(marker.style, {
            position: 'fixed',
            width: '10px',
            height: '10px',
            borderRadius: '50%',
            background: '#ff93d3',
            border: '1px solid #ffffff',
            boxShadow: '0 0 6px rgba(255,147,211,0.7)',
            pointerEvents: 'none',
            display: 'none',
            zIndex: '45'
          });
          document.body.appendChild(marker);
        }
        return marker;
      }

      function updateCandyHouseHud() {
        const badge = ensureCandyHouseBadgeElement();
        const marker = ensureCandyMapMarker();
        const houses = Platform.layers?.houses || [];
        const house = houses.find((h) => h && h.id === 'candy_house_float');
        const door = house?.door;
        const L = (window.st?.players || [])[window.st?.leader || 0];
        const isNear = !!(L && door && Math.abs(L.x - door.x) < 120 && Math.abs(L.y - door.y) < 140);
        const rect = cv.getBoundingClientRect();
        const scaleX = rect.width / DESIGN_W;
        const scaleY = rect.height / DESIGN_H;
        if (door) {
          const screenX = rect.left + (door.x - camera.x) * scaleX;
          const screenY = rect.top + (door.y - camera.y - 28) * scaleY;
          const badgeWidth = badge.offsetWidth || 160;
          Object.assign(badge.style, {
            left: `${screenX - badgeWidth / 2}px`,
            top: `${screenY}px`,
            display: isNear ? 'flex' : 'none'
          });
          if (marker) {
            const mini = document.getElementById('mini');
            if (mini) {
              const miniRect = mini.getBoundingClientRect();
              const worldWidth = (window.WORLD_WIDTH || WORLD_WIDTH || DESIGN_W * 2);
              const mx = miniRect.left + (door.x / worldWidth) * miniRect.width;
              const my = miniRect.top + miniRect.height * 0.6;
              Object.assign(marker.style, {
                left: `${mx - 5}px`,
                top: `${my - 5}px`,
                display: 'block'
              });
            }
          }
        } else {
          badge.style.display = 'none';
          if (marker) marker.style.display = 'none';
        }
        requestAnimationFrame(updateCandyHouseHud);
      }


      Platform.tickBubblePad = function (dt) {
        const pad = Platform.bubblePad;
        if (!pad) return;
        const freq = pad.freq || BUBBLE_PAD.hoverFrequency;
        const amp = pad.amp || BUBBLE_PAD.hoverAmplitude;
        pad.t += dt * freq;
        pad.hover = Math.sin(pad.t) * amp;
        pad.cooldown = Math.max(0, pad.cooldown - dt);
        pad.glow = Math.max(0, pad.glow - dt * 1.2);
        pad.ripple = Math.max(0, pad.ripple - dt * 0.9);
        const list = pad.particles || (pad.particles = []);
        for (let i = list.length - 1; i >= 0; i--) {
          const p = list[i];
          p.life -= dt;
          if (p.life <= 0) { list.splice(i, 1); continue; }
          p.x += p.vx * dt;
          p.y += p.vy * dt;
          p.vx *= 0.98;
          p.vy -= 22 * dt;
          p.alpha = Math.max(0, p.life / p.maxLife);
        }
      };

      Platform.emitBubbleBurst = function (x, y, count) {
        const pad = Platform.bubblePad;
        if (!pad) return;
        const list = pad.particles || (pad.particles = []);
        const total = count || BUBBLE_PAD.burstCount;
        for (let i = 0; i < total; i++) {
          const angle = (Math.random() * Math.PI / 1.2) + Math.PI * 1.1;
          const speed = 80 + Math.random() * 60;
          const vx = Math.cos(angle) * speed;
          const vy = Math.sin(angle) * speed;
          const life = 0.8 + Math.random() * 0.5;
          list.push({
            x: x + (Math.random() - 0.5) * 36,
            y: y + Math.random() * 12,
            vx,
            vy,
            life,
            maxLife: life,
            radius: 3 + Math.random() * 3,
            alpha: 1
          });
        }
        while (list.length > 70) list.shift();
      };

      function renderBubblePad(ctx) {
        const pad = Platform.bubblePad;
        if (!pad) return;
        const y = pad.baseY + pad.hover;
        const glow = 0.3 + pad.glow * 1.4;
        ctx.save();
        if (pad.strip) {
          ctx.fillStyle = 'rgba(60, 110, 180, 0.24)';
          ctx.fillRect(pad.strip.x, pad.strip.y - 6, pad.strip.w, 6);
          ctx.fillStyle = 'rgba(40, 70, 120, 0.5)';
          ctx.fillRect(pad.strip.x, pad.strip.y + pad.strip.h - 3, pad.strip.w, 3);
        }
        const grad = ctx.createRadialGradient(pad.x, y, 4, pad.x, y, 40);
        grad.addColorStop(0, `rgba(160,220,255,${0.35 + glow})`);
        grad.addColorStop(0.5, `rgba(120,200,255,${0.2 + glow * 0.6})`);
        grad.addColorStop(1, 'rgba(80,160,255,0.05)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.ellipse(pad.x, y, pad.w / 2, 16, 0, 0, Math.PI * 2);
        ctx.fill();
        if (pad.ripple > 0) {
          ctx.strokeStyle = `rgba(159,215,255,${0.35 + pad.ripple})`;
          ctx.lineWidth = 2 + pad.ripple * 4;
          ctx.beginPath();
          ctx.ellipse(pad.x, y, pad.w / 2 + 6 + pad.ripple * 18, 18 + pad.ripple * 10, 0, 0, Math.PI * 2);
          ctx.stroke();
        }
        const particles = pad.particles || [];
        for (const p of particles) {
          const alpha = Math.max(0, Math.min(1, (p.alpha || 0.8) * (0.6 + glow)));
          ctx.globalAlpha = alpha;
          ctx.fillStyle = '#c4ecff';
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.restore();
        ctx.globalAlpha = 1;
      }

      function renderPlaygroundPads(ctx) {
        const pads = Platform.playgroundPads || [];
        for (const pad of pads) {
          const y = pad.baseY + (pad.hover || 0);
          const grad = ctx.createRadialGradient(pad.x, y, 4, pad.x, y, 36);
          grad.addColorStop(0, 'rgba(255,255,255,0.6)');
          grad.addColorStop(1, 'rgba(255,255,255,0)');
          ctx.fillStyle = grad;
          ctx.beginPath(); ctx.ellipse(pad.x, y, 32, 14, 0, 0, Math.PI * 2); ctx.fill();
          ctx.fillStyle = pad.color || '#ff93d3';
          ctx.beginPath(); ctx.ellipse(pad.x, y, 22, 8, 0, 0, Math.PI * 2); ctx.fill();
        }
      }

      // === Houses: inline layer + procedural sprites (no assets) ===
      // Small seeded RNG so each house style is stable per seed
      function _rng(seed) { var t = (seed >>> 0) + 0x6D2B79F5; return function () { t += 0x6D2B79F5; var r = Math.imul(t ^ t >>> 15, 1 | t); r ^= r + Math.imul(r ^ r >>> 7, 61 | r); return ((r ^ r >>> 14) >>> 0) / 4294967296; }; }

      function makeHouseSprite(seed, w, h, style) {
        // Smaller candy house sprite with style variants
        style = style || 'home';
        if (!w) w = style === 'arcade' ? 128 : 110;
        if (!h) h = style === 'arcade' ? 96 : 86;
        const c = document.createElement('canvas'); c.width = w; c.height = h;
        const ctx = c.getContext('2d'); const R = _rng(seed || 12345);
        // Style palettes
        const palette = {
          home: { base: '#1a1424', wall: '#ffd6ea', wall2: '#ff93d3', roof: '#a78bfa', accent: '#9fd7ff' },
          shop: { base: '#0a0b12', wall: '#ffe9f7', wall2: '#ffa6e6', roof: '#ff6aa8', accent: '#00E5FF' },
          arcade: { base: '#101626', wall: '#ffd6ff', wall2: '#ff93f7', roof: '#7c3aed', accent: '#fffb8f' },
          clinic: { base: '#0d1320', wall: '#e9fff9', wall2: '#b4fff0', roof: '#36c777', accent: '#00E5FF' },
          forge: { base: '#201510', wall: '#ffe6cf', wall2: '#ffd6b3', roof: '#ff8a3a', accent: '#ffd56a' },
          workshop: { base: '#161820', wall: '#f5ecff', wall2: '#e1d4ff', roof: '#8b5cf6', accent: '#9fd7ff' },
          black_market: { base: '#0a0b12', wall: '#141a2a', wall2: '#0f1624', roof: '#00E5FF', accent: '#ff6aa8' },
          candy_dungeon: { base: '#141224', wall: '#fff0fa', wall2: '#ffd6ea', roof: '#7c3aed', accent: '#ff93d3' }
        };
        const P = palette[style] || palette.home;
        const base = P.base, wall = P.wall, wall2 = P.wall2, roof = P.roof, accent = P.accent;
        const baseH = 16, bodyH = 48, roofH = h - baseH - bodyH;
        // body (with subtle candy stripes)
        const bx = 6, bw = w - 12;
        const by = h - baseH - bodyH;
        ctx.fillStyle = wall; ctx.fillRect(bx, by, bw, bodyH);
        ctx.globalAlpha = 0.12; ctx.fillStyle = wall2;
        for (let sx = bx + 2; sx < bx + bw; sx += 8) { ctx.fillRect(sx, by, 3, bodyH); }
        ctx.globalAlpha = 1;
        ctx.strokeStyle = base; ctx.strokeRect(8 + 0.5, h - baseH - bodyH + 0.5, w - 17, bodyH - 1);
        // base
        ctx.fillStyle = base; ctx.fillRect(3, h - baseH, w - 6, baseH);
        // roof
        ctx.fillStyle = roof; ctx.beginPath();
        ctx.moveTo(5, h - baseH - bodyH); ctx.lineTo(w / 2, h - baseH - bodyH - roofH); ctx.lineTo(w - 5, h - baseH - bodyH); ctx.closePath(); ctx.fill();
        ctx.strokeStyle = base; ctx.stroke();
        // windows
        function win(wx, wy, ww, wh) {
          ctx.fillStyle = '#0b1222'; ctx.fillRect(wx, wy, ww, wh);
          ctx.strokeStyle = accent; ctx.strokeRect(wx + 0.5, wy + 0.5, ww - 1, wh - 1);
          ctx.fillStyle = '#0c1523';
          const cols = Math.max(2, Math.floor(ww / 14)), rows = Math.max(2, Math.floor(wh / 14));
          const cw = Math.floor((ww - 4) / cols), ch = Math.floor((wh - 4) / rows);
          for (let r = 0; r < rows; r++) for (let c2 = 0; c2 < cols; c2++) ctx.fillRect(wx + 2 + c2 * cw, wy + 2 + r * ch, cw - 3, ch - 3);
        }
        win(12, h - baseH - bodyH + 8, 22, 18);
        win(w - 34, h - baseH - bodyH + 8, 22, 18);
        // door
        const doorW = 16, doorH = 26, doorX = Math.floor(w / 2 - doorW / 2), doorY = h - baseH - doorH;
        ctx.fillStyle = '#2a334d'; ctx.fillRect(doorX, doorY, doorW, doorH);
        ctx.strokeStyle = accent; ctx.strokeRect(doorX + 0.5, doorY + 0.5, doorW - 1, doorH - 1);
        ctx.fillStyle = '#ff7a6a'; ctx.beginPath(); ctx.arc(doorX + doorW - 6, doorY + doorH / 2, 2, 0, Math.PI * 2); ctx.fill();
        // Style marks
        if (style === 'arcade') {
          ctx.save();
          ctx.shadowColor = accent;
          ctx.shadowBlur = 12;
          ctx.strokeStyle = 'rgba(255,255,255,0.4)';
          ctx.strokeRect(6.5, h - baseH - bodyH + 0.5, w - 13, bodyH + roofH);
          ctx.shadowBlur = 0;
          ctx.fillStyle = accent;
          ctx.fillRect(doorX - 40, doorY - 26, 80, 18);
          ctx.strokeStyle = '#ffffff';
          ctx.lineWidth = 1.5;
          ctx.strokeRect(doorX - 40, doorY - 26, 80, 18);
          ctx.fillStyle = '#0b1020';
          ctx.font = 'bold 12px ui-monospace, monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('ARCADE', doorX + doorW / 2, doorY - 17);
          ctx.restore();
        } else if (style === 'clinic') {
          ctx.fillStyle = '#36c777'; ctx.fillRect(doorX + 24, doorY - 12, 10, 10); ctx.fillStyle = '#0b1222'; ctx.fillRect(doorX + 27, doorY - 10, 4, 6); ctx.fillRect(doorX + 25, doorY - 8, 8, 2);
        } else if (style === 'forge' || style === 'workshop') {
          ctx.fillStyle = '#3a2a1a'; ctx.fillRect(6, h - baseH - bodyH - 6, 10, 6); ctx.fillStyle = '#ff8a3a'; ctx.fillRect(6, h - baseH - bodyH - 10, 8, 4);
        } else if (style === 'black_market') {
          ctx.fillStyle = '#ff6aa8'; ctx.fillRect(doorX - 20, doorY - 16, 40, 10);
          ctx.fillStyle = '#0b0f16'; ctx.font = 'bold 8px ui-monospace'; ctx.fillText('BM', doorX - 8, doorY - 8);
        } else if (style === 'missy_house') {
          ctx.fillStyle = '#6B4C9A'; // Main Missy House body
          ctx.fillRect(0, h - baseH - bodyH, w, bodyH);

          ctx.fillStyle = '#8B6BB7'; // Cat ear accents
          ctx.beginPath();
          ctx.moveTo(w * 0.2, h - baseH - bodyH);
          ctx.lineTo(w * 0.15, h - baseH - bodyH - 20);
          ctx.lineTo(w * 0.25, h - baseH - bodyH);
          ctx.fill();
          ctx.beginPath();
          ctx.moveTo(w * 0.8, h - baseH - bodyH);
          ctx.lineTo(w * 0.85, h - baseH - bodyH - 20);
          ctx.lineTo(w * 0.75, h - baseH - bodyH);
          ctx.fill();

          ctx.fillStyle = '#FF69B4'; // Missy sign
          ctx.fillRect(doorX - 25, doorY - 20, 50, 14);
          ctx.fillStyle = '#FFF';
          ctx.font = 'bold 10px ui-monospace';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('MISSY', doorX + (doorW / 2), doorY - 13);
          ctx.textAlign = 'start';
          ctx.textBaseline = 'alphabetic';
        } else if (style === 'candy_dungeon') {
          ctx.fillStyle = '#00E5FF'; ctx.fillRect(doorX - 20, doorY - 16, 40, 10);
          ctx.fillStyle = '#0b0f16'; ctx.font = 'bold 8px ui-monospace'; ctx.fillText('CD', doorX - 8, doorY - 8);
        }
        return { canvas: c, w, h, doorX, doorY, doorW, doorH };
      }

      function addHouse(seed, x, groundY, label, type) {
        try {
          Platform.layers.houses = Platform.layers.houses || [];
          // Use default compact candy size so it fits most strips
          const s = makeHouseSprite(seed, undefined, undefined, type);
          const hx = x, hy = groundY - s.h + 2;
          Platform.layers.houses.push({
            x: hx,
            y: hy,
            w: s.w,
            h: s.h,
            sprite: s.canvas,
            label: label || null,
            type: type || 'home',
            seed: seed,
            isArcade: type === 'arcade',
            glow: type === 'arcade' ? '#ff93f7' : null,
            door: { x: hx + s.doorX + s.doorW / 2, y: hy + s.doorY + s.doorH, r: 28 }
          });
        } catch (e) { /* ignore */ }
      }

      function spawnGroundHouses() {
        // DISABLED - replaced by zone-based building placement
        console.log('[Platform] spawnGroundHouses disabled - using zone-based system');
      }

      // NEW: Zone-based building placement
      function spawnZoneBuildings() {
        try {
          if (!BUILDINGS) return;
          Platform.layers.houses = Platform.layers.houses || [];

          const ground = (Platform.layers.solids || []).find(p => p && p.type === 'ground');
          const gY = ground ? ground.y : (DESIGN_H - 80);

          console.log('[Platform] Spawning zone-based buildings...');

          for (const b of BUILDINGS) {
            // Check if already spawned
            const exists = Platform.layers.houses.find(h => h.id === b.id);
            if (exists) continue;

            let buildingY = typeof supportYAtX === 'function' ? supportYAtX(b.x) : gY;
            if (!Number.isFinite(buildingY)) buildingY = gY;

            if (b.id === 'missy_house') {
              buildingY = gY - 180;
              const solids = Platform.layers.solids = Platform.layers.solids || [];
              const platformId = 'missy_house_platform';
              const hasPlatform = solids.some(s => s && s.id === platformId);
              if (!hasPlatform) {
                solids.push({
                  id: platformId,
                  x: b.x - 20,
                  y: buildingY + b.h - 10,
                  w: b.w + 40,
                  h: 15,
                  hp: 999999,
                  type: 'floating_strip',
                  color: '#9B7BB7'
                });
              }
            }

            const seed = b.id.split('').reduce((a, c) => a + c.charCodeAt(0), 100000);
            addHouse(seed, b.x - (b.w / 2), buildingY, b.label, b.id);

            // Mark with id for tracking
            const house = Platform.layers.houses[Platform.layers.houses.length - 1];
            if (house) house.id = b.id;
          }

          // Set first home as window.HOUSE
          window.HOUSE = Platform.layers.houses.find(h => h.id === 'home') || Platform.layers.houses[0];

          console.log(`[Platform] Spawned ${BUILDINGS.length} buildings`);
        } catch (e) {
          console.warn('[Platform] Failed to spawn zone buildings:', e);
        }
      }

      // Place a house for the given scene, on a platform if available
      function supportYAtX(x) {
        const solids = Platform.layers.solids || [];
        let best = null;
        for (const p of solids) {
          if (x >= p.x && x <= p.x + p.w) {
            if (!best || p.y < best.y) best = p;
          }
        }
        return best ? best.y : (DESIGN_H - 80);
      }
      function getLeaderPlatform() {
        try {
          const L = (window.st && (window.st.players || [])[window.st.leader || 0]);
          if (!L) return null;
          const x = L.x;
          const solids = Platform.layers.solids || [];
          // choose platform that contains leader.x and is closest by vertical distance to leader
          let best = null, bd = 1e9;
          for (const p of solids) {
            if (x >= p.x && x <= p.x + p.w) {
              const d = Math.abs((L.y || 0) - p.y);
              if (d < bd) { bd = d; best = p; }
            }
          }
          return best;
        } catch (_) { return null; }
      }

      function chooseHousePlatform(sceneIndex) {
        const solids = Platform.layers.solids || [];
        const WW = (window.WORLD_WIDTH || 4096);
        const sceneStart = (sceneIndex || 0) * WW;
        const nonGround = solids.filter(p => p && p.x >= sceneStart && p.x <= sceneStart + WW && p.hp < 1e9 && p.type !== 'ground');
        const lp = getLeaderPlatform();
        // Use leader platform if it's not ground
        if (lp && lp.hp < 1e9 && lp.type !== 'ground') return lp;
        // Otherwise, prefer the highest platform in the scene
        if (nonGround.length) {
          // Pick the one whose center is closest to scene center
          const cx = sceneStart + WW / 2;
          let best = nonGround[0], bd = Math.abs((best.x + best.w / 2) - cx);
          for (const p of nonGround) {
            const dd = Math.abs((p.x + p.w / 2) - cx);
            if (dd < bd) { bd = dd; best = p; }
          }
          return best;
        }
        return null;
      }
      // Multi-house spawner: pick up to 3 widest strips in this scene and place Home/Shop/Arcade
      function spawnHousesForScene(sceneIndex) {
        // DISABLED - replaced by zone-based building placement
        console.log('[Platform] spawnHousesForScene disabled - using zone-based system');
      }

      function spawnHouseForScene(sceneIndex) {
        // DISABLED - replaced by zone-based building placement
        console.log('[Platform] spawnHouseForScene disabled - using zone-based system');
      }

      // Enter helper: teleport to nearest house door (snap lanes) and enter / portal hop
      window.enterNearestHouse = function () {
        try {
          if (window.HouseInterior?.active) return true;
          const nearDoor = window.__houseNearDoor;
          if (nearDoor && typeof nearDoor.action === 'function') {
            try { nearDoor.action(); } catch (_) { }
            return true;
          }
          const L = (typeof leader === 'function' && leader()) || (window.st?.players?.[window.st.leader || 0]);
          if (!L) return false;
          const houses = (Platform.layers?.houses) || [];
          if (houses.length === 0) { try { spawnHouseForScene(window.currentScene || 0); } catch (_) { } }
          let nearest = null, bestDist = Infinity;
          for (const h of houses) {
            const d = h?.door;
            if (!d) continue;
            const dx = (L.x - d.x);
            const dy = (L.y - d.y);
            const dist = Math.hypot(dx, dy);
            if (dist < bestDist) { bestDist = dist; nearest = h; }
          }
          if (!nearest) return false;
          const door = nearest.door || { x: nearest.x + (nearest.w || 110) / 2, y: nearest.y + (nearest.h || 86) };
          L.x = door.x;
          L.y = door.y - 16;
          L.vx = 0; L.vy = 0; L.grounded = true; L.jumpCount = 0;
          if (nearest.type === 'candy_dungeon') {
            try {
              window.A1KShared && A1KShared.push(A1KShared.fromRunner());
              notify?.('Entering Candy Dungeon…', '#ff93d3');
            } catch (_) { }
            setTimeout(() => { location.href = 'candy dungeon(1).html#from=runner'; }, 150);
            return true;
          }
          if (nearest.type === 'missy_house') {
            try {
              window.A1KShared && A1KShared.push(A1KShared.fromRunner());
            } catch (_) { }
            if (typeof notify === 'function') {
              try { notify('Entering Missy House...', '#FF69B4'); } catch (_) { }
            }
            setTimeout(() => {
              try {
                location.href = 'Missy Arcade.html#from=runner';
              } catch (_e) {
                location.href = 'Missy Arcade.html';
              }
            }, 150);
            return true;
          }
          if (window.HouseInterior) { HouseInterior.enter(nearest); return true; }
          return false;
        } catch (_) { return false; }
      };

      Platform.resetForStage = function (stage) {
        // --- End-of-world features: Dark Room, vendor, transit, springs and chests ---
        try {
          const WW = (window.WORLD_WIDTH || 4096);
          const ground = (Platform.layers.solids || []).find(p => p && p.type === 'ground');
          const gY = ground ? ground.y : (DESIGN_H - 40);
          // Place the Dark Room house near the end on the ground strip
          const darkX = Math.max(WW - 380, 220);
          addHouse(444444, darkX, gY, 'Dark Room', 'dark_room');
          // Interaction zones
          Platform.modeZone = { x: darkX + 55, y: gY - 10, r: 70 };
          Platform.vendorZone = { x: WW - 650, y: gY - 10, r: 70 };
          Platform.transport = {
            start: { x: 80, y: gY - 10, r: 70 },
            end: { x: WW - 80, y: gY - 10, r: 70 }
          };
          // Extra springs near end
          Platform.layers.springs = (Platform.layers.springs || []).concat([
            { x: WW - 320, y: gY - 6, w: 36, h: 6, power: 980 },
            { x: WW - 220, y: gY - 6, w: 36, h: 6, power: 980 }
          ]);
          // Three chests; middle is a trap
          Platform.chests = [
            { x: WW - 540, y: gY - 28, w: 22, h: 18, kind: 'chest', opened: false },
            { x: WW - 420, y: gY - 28, w: 22, h: 18, kind: 'trap', opened: false },
            { x: WW - 300, y: gY - 28, w: 22, h: 18, kind: 'chest', opened: false }
          ];
          // Transit skeleton (ts-like interface planned)
          Platform.trainSystem = Platform.trainSystem || {
            stops: ['start', 'end'],
            request(which) { console.log('[Transit] request', which); },
            travelTo(which) { try { const st = window.st || {}; const L = (st.players || [])[st.leader || 0]; if (!L) return; if (which === 'start') L.x = 80; else if (which === 'end') L.x = (window.WORLD_WIDTH || 4096) - 120; } catch (_) { } }
          };
        } catch (_) { }
        if (stage === 3) {
          Platform.generateBridge(stage);
          Platform.spawnChestEncounter();
        } else {
          Platform.generateDefault(stage);
        }
        Platform.actors.length = 0;
        try { Platform.ensurePlaza(stage); } catch (_) { }
        try { Platform.ensureCandyHouse(stage); } catch (_) { }
        try { Platform.ensureBlackMarket(stage); } catch (_) { }
        try { Platform.ensureHouseSpread(); } catch (_) { }
        try { Platform.ensureBubblePad(stage); } catch (_) { }
        try { Platform.ensureAllFloatingWorld(); } catch (_) { }
        try { Platform.ensureTransportStrips(); } catch (_) { }
        try { spawnWorldNPCs(); } catch (_) { }
        Platform._lastStage = stage || 1;
        // NEW: Zone-based building placement
        try { spawnZoneBuildings(); } catch (e) { console.warn('[Platform] spawnZoneBuildings failed:', e); }
      };

      Platform.highestPlatform = function () {
        const nonGround = Platform.layers.solids.filter(p => p.hp < 1e9);
        if (nonGround.length === 0) return null;
        return nonGround.reduce((a, b) => (a.y < b.y ? a : b));
      };

      Platform.spawnChestEncounter = function () {
        if (!g.st) return;

        const bridgeLevel = DESIGN_H - 300;
        const bridgeWidth = (window.WORLD_WIDTH || WORLD_WIDTH || (DESIGN_W * 2));

        // Mid-bridge chest
        // Treasure chest disabled for now

        // Exit gate disabled for now

        // Bridge Boss
        const boss = {
          kind: 'boss',
          name: 'Bridge Guardian',
          x: bridgeWidth - 250,
          y: bridgeLevel - 40,
          hp: 4000,
          max: 4000,
          vx: -0.02,
          fireCD: 800,
          role: 'boss',
          behavior: 'boss_pattern',
          platformer: true,
          pf: { w: 48, h: 64, dir: -1 },
          onDeath: () => {
            exitGate.opened = true;
            if (window.notify) notify('The Exit Gate is now open!', '#6aa8ff');
          }
        };
        g.st.enemies.push(boss);

        // Gate Guards
        for (let i = 0; i < 2; i++) {
          const guard = {
            kind: 'mob',
            x: bridgeWidth - 180 + (i * 60),
            y: bridgeLevel - 40,
            hp: 150, max: 150,
            vx: -0.1,
            role: 'melee',
            behavior: 'guard',
            platformer: true,
            pf: { w: 28, h: 40, dir: -1, jumpCD: 0 }
          };
          g.st.enemies.push(guard);
        }

        // Weapons
        const weaponTypes = ['sword', 'axe', 'bow'];
        for (let i = 0; i < 3; i++) {
          g.st.pickups.push({
            kind: 'weapon',
            weaponType: weaponTypes[i],
            x: 100 + i * 150,
            y: groundLevel - 30,
            life: Infinity
          });
        }
      };

      function aiStep(e, dt) {
        const st = g.st || {}; const L = (st.players || [])[st.leader || 0] || { x: DESIGN_W / 2, y: DESIGN_H - 120 };
        const target = (st.bossAlive ? L : null) || Platform._guardPoint || L;
        let want = 0; e.pf.dir = e.pf.dir || 1;
        if (target) { want = target.x < e.x ? -1 : 1; e.pf.dir = want; }
        const lad = onLadder(e.pfBox, Platform.layers.ladders);
        const verticalDiff = target ? target.y - e.y : 0;
        if (lad && Math.abs(verticalDiff) > 22) {
          e.pf.climb = true; e.vx = 0; e.vy = Math.sign(verticalDiff) * CLIMB;
        } else {
          e.pf.climb = false; e.vx = want * RUN * 0.8;
          e.pf.jumpCD = (e.pf.jumpCD || 0) - dt;
          const aheadX = e.x + (e.pf.dir || want) * ((e.pfBox.w / 2) + 6);
          const groundAhead = solidUnder(aheadX, e.y + e.pfBox.h + 1, Platform.layers.solids);
          const shouldJump = (!groundAhead || Math.abs(verticalDiff) > 36) && e.onGround && e.pf.jumpCD <= 0;
          if (shouldJump) { e.vy = -JUMP; e.onGround = false; e.pf.jumpCD = 0.9; }
        }
      }

      Platform.step = function (dt) {
        if (!Platform.enabled) return; if (!g.st) return;
        // stage sync
        if (Platform._lastStage !== (g.st.stage || 1)) Platform.resetForStage(g.st.stage || 1);
        // Choose a guard point as chest position
        const top = Platform.highestPlatform(); if (top) Platform._guardPoint = { x: top.x + top.w / 2, y: top.y - 10 };
        // step each actor
        const plist = Platform.layers.solids, lads = Platform.layers.ladders;
        for (const e of g.st.enemies) {
          if (!e.platformer || e.hp <= 0) continue;
          e.dt = dt; e.w = (e.pf?.w) || 28; e.h = (e.pf?.h) || 40; e.pfBox = { x: e.x, y: e.y, w: e.w, h: e.h };
          if (e.kind === 'boss') {
            // slight aggression and periodic platform break
            e._pfBreakCD = (e._pfBreakCD || (3 + Math.random() * 2)) - dt; if (e._pfBreakCD <= 0) { Platform.breakNearest(e.x, e.y); e._pfBreakCD = 5 + Math.random() * 3; }
          }
          aiStep(e, dt);
          if (!e.pf?.climb) e.vy += GRAV * dt;
          collide(e, plist, DESIGN_W, DESIGN_H - 160);
        }
        // Playground pad animation
        try {
          const pads = Platform.playgroundPads;
          if (pads && pads.length) {
            for (const pad of pads) {
              pad.t += (pad.freq || 1.4) * dt;
              pad.hover = Math.sin(pad.t) * (pad.amp || 5);
            }
          }
        } catch (_) { }

        // Runtime lift: move ground pickups onto strips/clouds
        try {
          if (Platform._liftRuntime && g.st && Array.isArray(g.st.pickups)) {
            const solids = Platform.layers.solids || [];
            const ground = solids.find(p => p && p.type === 'ground');
            const groundY = ground ? ground.y : (DESIGN_H - 40);
            const ensureSupportAt = (x, preferredOffset = 140, width = 140, tag = 'auto_pickup_strip') => {
              const y = Math.max(groundY - preferredOffset, 120);
              let s = solids.find(p => p && p.type === tag && x >= p.x && x <= p.x + p.w && Math.abs(p.y - y) < 18);
              if (!s) { s = { x: Math.max(20, x - width / 2), y, w: width, h: 14, hp: 999, type: tag, color: '#203247' }; solids.push(s); }
              return s;
            };
            for (const p of g.st.pickups) {
              if (p && !p._lifted && Math.abs((p.y || 0) - (groundY - 20)) < 30) {
                const sup = ensureSupportAt(p.x || 100);
                p.y = sup.y - 20; p._lifted = true;
              }
            }
          }
        } catch (_) { }

        try {
          const st = g.st;
          if (st) {
            const nowMs = performance.now ? performance.now() : Date.now();
            if (Array.isArray(st.npcs) && st.npcs.length) {
              const leaderFn = typeof leader === 'function' ? leader : null;
              const L = leaderFn ? leaderFn() : null;
              let best = null;
              let bestDist = Infinity;
              for (const npc of st.npcs) {
                npc.bobT = (npc.bobT || 0) + dt * 3.2;
                npc.bob = Math.sin(npc.bobT) * 2.1;
                // Update renderer animation
                if (npc.renderer && npc.renderer.update) {
                  npc.renderer.update(dt);
                }
                if (L) {
                  const dx = (L.x - npc.x);
                  const dy = (L.y - npc.y);
                  const dist = Math.hypot(dx, dy);
                  if (dist < (npc.range || 70) && dist < bestDist) {
                    best = npc;
                    bestDist = dist;
                  }
                }
              }
              st._npcNear = L ? best : null;
            } else {
              st._npcNear = null;
            }
            const eff = st.npcSkillEffects || {};
            if (eff.tempDefBuff && eff.tempDefBuff.expires && nowMs >= eff.tempDefBuff.expires) {
              delete eff.tempDefBuff;
            }
            if (eff.goldTick && eff.goldTick.next && nowMs >= eff.goldTick.next) {
              st.gold = (st.gold || 0) + (eff.goldTick.amount || 0);
              eff.goldTick.next = nowMs + (eff.goldTick.interval || 20000);
              try { updateCurrencies && updateCurrencies(); } catch (_) { }
              try {
                const Ld = typeof leader === 'function' ? leader() : null;
                if (Ld) addFloater(Ld.x, Ld.y - 80, '+' + (eff.goldTick.amount || 0) + 'g', '#ffd56a');
              } catch (_) { }
            }
            if (eff.invulnUntil && nowMs >= eff.invulnUntil) {
              delete eff.invulnUntil;
            }
            if (eff.shieldBarrier && Array.isArray(st.players)) {
              for (const p of st.players) {
                if (!p || p.isDefeated) continue;
                p._coreBarrier = p._coreBarrier || { current: 0, max: 0 };
                if ((p._coreBarrier.current || 0) < eff.shieldBarrier) {
                  p._coreBarrier.current = eff.shieldBarrier;
                  p._coreBarrier.max = Math.max(p._coreBarrier.max || 0, eff.shieldBarrier);
                }
              }
            }
          }
        } catch (_) { }
      };

      Platform.breakNearest = function (x, y) {
        let best = null, bd = 1e9, bi = -1;
        const arr = Platform.layers.solids;
        for (let i = 0; i < arr.length; i++) {
          const p = arr[i]; if (!isFinite(p.hp)) continue;
          const cx = p.x + p.w / 2, cy = p.y + p.h / 2; const d = Math.hypot(cx - x, cy - y);
          if (d < bd) { bd = d; best = p; bi = i; }
        }
        if (best) { best.hp -= 60; g.st.effects.push({ x: best.x + best.w / 2, y: best.y, txt: 'SMASH', color: '#ff7a6a', life: 600 }); if (best.hp <= 0) { arr.splice(bi, 1); } }
      };

      Platform.draw = function (ctx) {
        try {
          const z = Platform.layers;
          ctx.save();
          // ladders
          ctx.fillStyle = '#29465e';
          for (const L of z.ladders) { ctx.fillRect(L.x, L.y, L.w, L.h); }
          // platforms with colors
          for (const p of z.solids) {
            if (p.type === 'npc_platform') {
              // Special rendering for NPC platforms (golden wood)
              ctx.fillStyle = p.color || '#c9944a';
              ctx.fillRect(p.x, p.y, p.w, p.h);

              // Draw wood grain details (3-4 horizontal lines)
              ctx.strokeStyle = '#8b6f2a';
              ctx.lineWidth = 1;
              for (let i = 0; i < 3; i++) {
                ctx.beginPath();
                ctx.moveTo(p.x, p.y + (i * 5) + 3);
                ctx.lineTo(p.x + p.w, p.y + (i * 5) + 3);
                ctx.stroke();
              }

              // Draw border
              ctx.strokeStyle = '#5a4520';
              ctx.lineWidth = 2;
              ctx.strokeRect(p.x, p.y, p.w, p.h);
            } else {
              // Regular platform rendering
              const col = p.color || '#1a263a';
              ctx.fillStyle = col;
              ctx.fillRect(p.x, p.y, p.w, p.h);
              ctx.strokeStyle = '#2b3c55';
              ctx.strokeRect(p.x + 0.5, p.y + 0.5, p.w - 1, p.h - 1);
            }
          }
          // springs
          if (z.springs) { ctx.fillStyle = '#ffd56a'; for (const s of z.springs) { ctx.fillRect(s.x, s.y, s.w, s.h); ctx.fillStyle = '#ffaa00'; ctx.fillRect(s.x + 4, s.y + 1, s.w - 8, s.h - 2); ctx.fillStyle = '#ffd56a'; } }
          if (Platform.plazaCloud) {
            const cloud = Platform.plazaCloud;
            ctx.save();
            ctx.fillStyle = 'rgba(162,210,255,0.2)';
            ctx.beginPath();
            ctx.ellipse(cloud.x, cloud.y, cloud.w / 2, cloud.h / 2, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = 'rgba(140,190,255,0.18)';
            ctx.beginPath();
            ctx.ellipse(cloud.x, cloud.y + 14, cloud.w * 0.36, cloud.h * 0.6, 0, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = 'rgba(180,225,255,0.35)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(cloud.x, cloud.y, (cloud.w / 2) * 0.82, (cloud.h / 2) * 0.72, 0, 0, Math.PI * 2);
            ctx.stroke();
            ctx.restore();
          }
          // trees & chests & markers
          try {
            // trees near end area
            const drawTree = (cx, cy, s) => { ctx.fillStyle = '#2a4a5a'; ctx.fillRect(cx - 6 * s, cy - 40 * s, 12 * s, 40 * s); ctx.fillStyle = '#36c777'; for (let i = 0; i < 3; i++) { ctx.beginPath(); ctx.arc(cx, cy - 40 * s - i * 16 * s, 20 * s - i * 4 * s, 0, Math.PI * 2); ctx.fill(); } };
            const WW = (window.WORLD_WIDTH || 4096); const ground = (Platform.layers.solids || []).find(p => p.type === 'ground'); const gY = ground ? ground.y : (DESIGN_H - 40);
            drawTree(WW - 480, gY - 6, 1); drawTree(WW - 560, gY - 6, .9);
          } catch (_) { }
          try {
            if (Platform.chests) { for (const c of Platform.chests) { if (c.opened) continue; ctx.fillStyle = c.kind === 'trap' ? '#8a4d64' : '#7d532b'; ctx.fillRect(c.x, c.y, c.w, c.h); ctx.strokeStyle = '#ffd56a'; ctx.strokeRect(c.x + .5, c.y + .5, c.w - 1, c.h - 1); } }
          } catch (_) { }
          // transport stops (improved train sprite)
          try {
            if (Platform.transport) {
              const drawStation = (S, flip) => {
                const x = S.x, y = S.y; // rail
                ctx.strokeStyle = '#2b3c55'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(x - 40, y + 30); ctx.lineTo(x + 40, y + 30); ctx.stroke();
                for (let i = -32; i <= 32; i += 12) { ctx.beginPath(); ctx.moveTo(x + i, y + 26); ctx.lineTo(x + i + 6, y + 34); ctx.stroke(); }
                // car
                ctx.fillStyle = '#9fd7ff'; ctx.fillRect(x - 22, y + 6, 44, 18);
                ctx.fillStyle = '#0b1220'; ctx.fillRect(x - 16, y + 10, 12, 8); ctx.fillRect(x + 4, y + 10, 12, 8);
                ctx.fillStyle = '#7B61FF'; ctx.fillRect(x - 24, y + 4, 48, 4);
                // wheels
                ctx.fillStyle = '#1a2436'; ctx.beginPath(); ctx.arc(x - 12, y + 28, 4, 0, Math.PI * 2); ctx.fill(); ctx.beginPath(); ctx.arc(x + 12, y + 28, 4, 0, Math.PI * 2); ctx.fill();
              };
              drawStation(Platform.transport.start);
              drawStation(Platform.transport.end);
            }
          } catch (_) { }
          // vendor kiosk + chibi helpers
          try {
            if (Platform.vendorZone) {
              const V = Platform.vendorZone; const x = V.x, y = V.y; // kiosk
              ctx.fillStyle = '#101a2c'; ctx.fillRect(x - 22, y - 18, 44, 18); ctx.fillStyle = '#ff93d3'; ctx.fillRect(x - 24, y - 24, 48, 6);
              ctx.fillStyle = '#0b0f16'; ctx.font = 'bold 9px ui-monospace'; ctx.fillText('SHOP', x - 16, y - 20);
              const chibi = (cx, cy, col) => { ctx.fillStyle = col; ctx.fillRect(cx - 5, cy - 10, 10, 10); ctx.fillStyle = '#0b0f16'; ctx.fillRect(cx - 2, cy - 7, 2, 2); ctx.fillRect(cx + 1, cy - 7, 2, 2); ctx.fillStyle = '#a78bfa'; ctx.fillRect(cx - 6, cy, 12, 2); };
              chibi(x - 34, y); chibi(x + 34, y, '#ffd56a');
            }
          } catch (_) { }
          // vendor marker
          try { if (Platform.vendorZone) { const V = Platform.vendorZone; ctx.strokeStyle = '#36c777'; ctx.beginPath(); ctx.arc(V.x, V.y, 36, 0, Math.PI * 2); ctx.stroke(); ctx.fillStyle = '#36c777'; ctx.font = '11px ui-monospace, monospace'; ctx.fillText('Vendor', V.x - 22, V.y + 54); } } catch (_) { }
          // houses
          const H = z.houses || [];
          for (let i = 0; i < H.length; i++) {
            const h = H[i];
            try { if (h.sprite) ctx.drawImage(h.sprite, h.x, h.y); } catch (e) { /* ignore */ }
            if (h.label) {
              ctx.fillStyle = '#ff93d3';
              ctx.font = '12px ui-monospace, monospace';
              ctx.fillText(h.label, h.x + 10, h.y + h.h / 2 + 6);
            }
          }
          renderBubblePad(ctx);
          renderPlaygroundPads(ctx);
          ctx.restore();
        } catch (e) { }
      };

      // Hook into update/draw and wave changes
      (function installHooks() {
        const _u = g.update; g.update = function (dt) { _u && _u(dt); Platform.step(dt || 0); };
        const _d = g.draw; g.draw = function () { _d && _d(); /* Platform drawn inside main draw after bg */ };
        // Reset/regen at wave 1
        try {
          const prev = g.onWaveChanged;
          g.onWaveChanged = function (w) { prev && prev(w); if (w === 1) { Platform.resetForStage((g.st && g.st.stage) || 1); } };
        } catch (e) { }
      })();

      // Disable platformer hook for bosses to avoid anchoring them
      const _spawnBossForStage = g.spawnBossForStage; g.spawnBossForStage = function () { return _spawnBossForStage && _spawnBossForStage(); };

      // Player platform physics
      Platform.playerStep = function (L, dt, input) {
        if (!L || L.isDefeated) return;
        if (Platform.bubblePad) Platform.tickBubblePad(dt);
        const entsz = { w: 36, h: 60 };
        // derive px velocities from input
        let vx = (input?.joyX || 0) * RUN * 1.0;
        let vy = (L.vy || 0) * DESIGN_H;
        // ladder check
        const box = { x: L.x - entsz.w / 2, y: L.y - entsz.h + 16, w: entsz.w, h: entsz.h };
        const lad = onLadder(box, Platform.layers.ladders);
        const joyXInput = input?.joyX || 0;
        const joyYInput = input?.joyY || 0;
        const onLad = !!lad && ((input?.up) || (input?.down) || Math.abs(joyYInput) > 0.35);
        let climbing = false;
        if (onLad) {
          const climbDir = input?.up ? -1 : (input?.down ? 1 : Math.sign(joyYInput));
          vy = climbDir * CLIMB;
          vx = Math.abs(joyXInput) > 0.05 ? joyXInput * RUN * 0.45 : 0;
          L._climbing = true;
          climbing = true;
        } else {
          L._climbing = false;
          vy += GRAV * dt;
        }
        // queued jump
        if (L._jumpQueued) {
          const jumpPower = (typeof L._jumpPower === 'number' && isFinite(L._jumpPower) ? L._jumpPower : 1);
          if (L.grounded || (L.jumpCount || 0) < 2) {
            const wasGrounded = !!L.grounded;
            vy = -JUMP * jumpPower;
            L.grounded = false;
            L.jumpCount = (wasGrounded ? 1 : ((L.jumpCount || 0) + 1));
          }
          L._jumpQueued = false;
          L._jumpPower = 1;
        }
        // move + collide
        const ent = { x: box.x, y: box.y, w: box.w, h: box.h, vx, vy, onGround: false, dt: dt };
        collide(ent, Platform.layers.solids, (window.WORLD_WIDTH || WORLD_WIDTH || DESIGN_W), DESIGN_H - 160);
        if (climbing) {
          ent.onGround = false;
        }
        // springs
        if (ent.onGround && Platform.layers.springs) {
          for (const s of Platform.layers.springs) {
            const footY = ent.y + ent.h;
            if (footY >= s.y - 2 && footY <= s.y + 6 && ent.x + ent.w / 2 >= s.x && ent.x + ent.w / 2 <= s.x + s.w) {
              ent.vy = - (s.power || 900);
              ent.onGround = false;
              if (g.st) g.st.effects.push({ x: ent.x + ent.w / 2, y: s.y - 8, txt: 'BOING!', color: '#ffd56a', life: 600 });
              break;
            }
          }
        }
        // bubble jet pad interaction (hovering launch pad)
        if (Platform.bubblePad) {
          const pad = Platform.bubblePad;
          const padY = pad.baseY + pad.hover;
          const half = (pad.w || BUBBLE_PAD.width) / 2;
          const footX = ent.x + ent.w / 2;
          const footY = ent.y + ent.h;
          const withinX = Math.abs(footX - pad.x) <= half + 12;
          const withinY = footY >= padY - 22 && footY <= padY + 36;
          if (withinX && withinY) {
            const keyLaunch = !!(input?.up || (g.keys && (g.keys.Space || g.keys.KeyW || g.keys.ArrowUp)));
            if (keyLaunch && pad.cooldown <= 0) {
              ent.vy = -BUBBLE_PAD.launchPower;
              ent.onGround = false;
              pad.cooldown = BUBBLE_PAD.cooldown;
              pad.glow = 0.55;
              pad.ripple = 0.6;
              if (window.CFG?.vfx?.bubbleBursts) {
                Platform.emitBubbleBurst(pad.x, padY - 8, BUBBLE_PAD.burstCount);
              }
              if (g.st) g.st.effects.push({ kind: 'cast', x: pad.x, y: padY - 16, color: '#9fd7ff', life: 280, max: 280 });
            } else if (ent.vy > 0) {
              ent.vy *= 0.7;
            }
          }
        }
        // commit
        L.x = ent.x + entsz.w / 2;
        L.y = ent.y - 16 + entsz.h;
        L.vx = ent.vx / DESIGN_W;
        L.vy = ent.vy / DESIGN_H;
        L.grounded = !!ent.onGround;
        if (Math.abs(L.vx) > 0.02) L.facingLeft = L.vx < 0;
        // Interaction prompts (mode, vendor, transit, chests)
        try {
          const now = performance.now ? performance.now() : Date.now();
          const near = (pt, r) => { const dx = L.x - pt.x, dy = L.y - pt.y; return dx * dx + dy * dy <= (r * r); };
          Platform._nearMode = Platform.modeZone && near(Platform.modeZone, Platform.modeZone.r);
          if (Platform._nearMode && (!Platform._modeAt || now - Platform._modeAt > 1400)) { Platform._modeAt = now; if (window.notify) notify('Press E for Mode Picker', '#7B61FF'); }
          Platform._nearVendor = Platform.vendorZone && near(Platform.vendorZone, Platform.vendorZone.r);
          if (Platform._nearVendor && (!Platform._vendorAt || now - Platform._vendorAt > 1400)) { Platform._vendorAt = now; if (window.notify) notify('Press E to talk to Vendor', '#36c777'); }
          if (Platform.transport) { const ns = near(Platform.transport.start, Platform.transport.start.r); const ne = near(Platform.transport.end, Platform.transport.end.r); Platform._nearTransport = ns ? 'start' : (ne ? 'end' : null); if (Platform._nearTransport && (!Platform._transAt || now - Platform._transAt > 1600)) { Platform._transAt = now; if (window.notify) notify('Press E to travel', '#2EA8FF'); } }
          Platform._nearChest = null; if (Platform.chests) { for (const c of Platform.chests) { if (c.opened) continue; if (near({ x: c.x + c.w / 2, y: c.y }, 40)) { Platform._nearChest = c; if (window.notify && (!Platform._chestAt || now - Platform._chestAt > 1400)) { Platform._chestAt = now; notify('Press E to open Chest', '#ffd56a'); } break; } } }
        } catch (_) { }
        // keep inside view
        L.x = Math.max(40, Math.min((WORLD_WIDTH || DESIGN_W) - 40, L.x));
        if (L.grounded) L.jumpCount = 0;
      };

      // Simple overlays and interaction handlers
      function ensureOverlay(id, html) {
        let el = document.getElementById(id);
        if (!el) {
          el = document.createElement('div'); el.id = id;
          el.style.cssText = 'position:fixed;right:16px;bottom:16px;background:#0e1220;border:1px solid #2b3c55;border-radius:10px;box-shadow:0 14px 40px rgba(0,0,0,.45);color:#e7f1ff;z-index:12000;min-width:260px;padding:12px;font:13px ui-monospace,monospace;';
          el.innerHTML = html; document.body.appendChild(el);
        }
        el.style.display = 'block'; return el;
      }
      function openVendor() {
        const roster = (window.PlatformInteractables && PlatformInteractables.NPC_ROSTER) || {};
        const opts = Object.entries(roster)
          .slice(0, 8)
          .map(([id, v]) => {
            const gold = (v.cost || 0).toLocaleString();
            const tickets = Math.ceil((v.cost || 0) / 1000);
            return (
              '<div class="npc-offer">' +
              '<div class="npc-offer-header">' +
              '<div><b>' + v.name + '</b> [' + (v.rank || '') + ']</div>' +
              '<div class="npc-offer-price">' + gold + 'g or ' + tickets + ' tickets</div>' +
              '</div>' +
              '<div class="npc-offer-buttons">' +
              '<button data-gold-id="' + id + '" class="npc-offer-btn-gold">Hire (Gold)</button>' +
              '<button data-ticket-id="' + id + '" class="npc-offer-btn-ticket">Pay in Tickets</button>' +
              '</div>' +
              '</div>'
            );
          })
          .join('');
        const el = ensureOverlay('vendorOverlay', "<div style='margin-bottom:8px'>Vendor</div>" + opts + "<div style='text-align:right;margin-top:8px'><button id='vClose' style='padding:6px 10px'>Close</button></div>");
        el.onclick = (e) => {
          const goldBtn = e.target.closest('button[data-gold-id]');
          const tixBtn = e.target.closest('button[data-ticket-id]');
          if (goldBtn) {
            try { PlatformInteractables.hireNpc(goldBtn.getAttribute('data-gold-id')); } catch (_) { }
          } else if (tixBtn) {
            try { PlatformInteractables.hireNpc(tixBtn.getAttribute('data-ticket-id'), true); } catch (_) { }
          } else if (e.target.id === 'vClose') {
            el.style.display = 'none';
          }
        };
      }
      function openModePicker() {
        const el = ensureOverlay('modeOverlay', `<div style='margin-bottom:8px'>Mode Picker</div><button id='mCandy' style='margin:6px 0;padding:8px 10px;width:100%'>Candy Mode</button><button id='mStory' style='margin:6px 0;padding:8px 10px;width:100%'>Story Mode</button><div style='text-align:right;margin-top:8px'><button id='mClose' style='padding:6px 10px'>Close</button></div>`);
        el.onclick = (e) => {
          try {
            if (e.target.id === 'mClose') { el.style.display = 'none'; return; }
            if (e.target.id === 'mCandy') {
              // Activate Candy theme
              try { window.Theme && window.Theme.set && window.Theme.set('candy'); } catch (_) {}
              notify('Mode set: Candy', '#FFB5E8');
              el.style.display = 'none';
              return;
            }
            if (e.target.id === 'mStory') {
              try { window.Theme && window.Theme.set && window.Theme.set('default'); } catch (_) {}
              notify('Mode set: Story', '#7B61FF');
              el.style.display = 'none';
              return;
            }
          } catch (_) {}
        };
      }
      function openTransport() {
        const el = ensureOverlay('transportOverlay', `<div style='margin-bottom:8px'>Transit Station</div><button id='goStart' style='margin:6px 0;padding:8px 10px;width:100%'>Go to Start</button><button id='goEnd' style='margin:6px 0;padding:8px 10px;width:100%'>Go to End</button><div style='text-align:right;margin-top:8px'><button id='tClose' style='padding:6px 10px'>Close</button></div>`);
        el.onclick = (e) => { const st = window.st || {}; const L = (st.players || [])[st.leader || 0]; if (!L) return; if (e.target.id === 'tClose') { el.style.display = 'none'; } if (e.target.id === 'goStart') { L.x = 80; notify('Transit to start', '#2EA8FF'); el.style.display = 'none'; } if (e.target.id === 'goEnd') { L.x = (window.WORLD_WIDTH || 15000) - 120; notify('Transit to end', '#2EA8FF'); el.style.display = 'none'; } };
      }
      function openNearestChest() {
        try {
          const st = window.st || {}; const L = (st.players || [])[st.leader || 0]; if (!L || !Platform.chests) return;
          for (const c of Platform.chests) {
            if (c.opened) continue; const dx = L.x - (c.x + c.w / 2), dy = L.y - (c.y); if (dx * dx + dy * dy < 40 * 40) { c.opened = true; if (c.kind === 'trap') { const pools = ['gold', 'silver', 'armor', 'gift', 'gear']; const spawn = (bx) => st.enemies.push({ kind: 'boss', isBoss: true, pool: pools[Math.floor(Math.random() * pools.length)], x: bx, y: (L.y - 40), hp: 1400, max: 1400, vx: 0.05, platformer: true, pf: { w: 48, h: 64, dir: -1 } }); spawn(L.x + 30); spawn(L.x + 90); notify('Trap! Two bosses appear!', '#ff6aa8'); } else { st.gold = (st.gold || 0) + 500; if (window.updateCurrencies) updateCurrencies(); notify('Chest opened! +500g', '#ffd56a'); } break; }
          }
        } catch (_) { }
      }
      // Interaction key
      try {
        window.addEventListener('keydown', (e) => {
          const k = (e.key || '').toLowerCase();
          if (k !== 'e') return;
          const st = window.st || {};
          if (st._npcMenuOpen) return;
          const nearNpc = st._npcNear;
          if (nearNpc) {
            e.preventDefault();
            openNPCMenu(nearNpc);
            return;
          }
          if (Platform._nearVendor) return openVendor();
          if (Platform._nearTransport) return openTransport();
          if (Platform._nearChest) return openNearestChest();
          if (Platform._nearMode) return openModePicker();
        });
      } catch (_) { }
      // Auto test: ?autodark=1 warps near the Dark Room and triggers E
      try { const q = new URLSearchParams(location.search); if (q.get('autodark') === '1') { const st = window.st || {}; const L = (st.players || [])[st.leader || 0]; const WW = (window.WORLD_WIDTH || 15000); if (L) { L.x = WW - 360; setTimeout(() => window.dispatchEvent(new KeyboardEvent('keydown', { key: 'e' })), 600); } } } catch (_) { }

      // Kick off map loading (best-effort) and ensure initial layout
      try { Platform._loadMaps(); } catch (e) { }
      try { loadNPCSkillStorage(); } catch (_) { }
      try { applyAllNPCSkillEffects(true); } catch (_) { }
      try { Platform.resetForStage((g.st && g.st.stage) || 1); } catch (e) { try { Platform.generate(1); } catch (_) { } }
      try { requestAnimationFrame(updateCandyHouseHud); } catch (_) { }
    })();
  </script>
  <!-- Test overrides: ensure currency bar is visible and window.st is exposed -->
  <style id="test-overrides">
    #currency {
      display: flex !important;
    }
  </style>
  <script>
    (function () {
      try {
        if (!('st' in window) && typeof st !== 'undefined') window.st = st;
        if (window.st) { window.st.pickups = window.st.pickups || []; }
      } catch (e) { /* noop */ }
    })();
  </script>
  <!-- Patch files integrated into unified system -->
  <!-- Advanced Enemy Rendering System -->
  <script>
    /* ================== ADVANCED ENEMY RENDERING SYSTEM ================== */
    (function () {
      if (window.__ADVANCED_ENEMY_RENDER__) return;
      window.__ADVANCED_ENEMY_RENDER__ = true;

      // Sprite cache
      const spriteCache = new Map();

      // Affix color mapping
      const AFFIX_COLORS = {
        vampiric: '#c0392b',
        armored: '#95a5a6',
        swift: '#3498db',
        regenerating: '#27ae60',
        volatile: '#e67e22',
        resistant: '#9b59b6'
      };

      // Enemy type colors for HP bars
      const HP_BAR_COLORS = {
        mob: '#e74c3c',      // Red
        boss: '#9b59b6',     // Purple
        miniboss: '#f39c12', // Orange
        flyer: '#3498db'     // Cyan
      };

      function loadSprite(spriteName) {
        if (!spriteName) return null;
        if (spriteCache.has(spriteName)) return spriteCache.get(spriteName);

        const img = new Image();
        img.src = `custom_assets_processed/${spriteName}`;
        spriteCache.set(spriteName, img);
        return img;
      }

      function drawEnemySprite(ctx, enemy) {
        if (enemy.isBoss) {
          drawProceduralBoss(ctx, enemy);
        } else {
          drawProceduralEnemy(ctx, enemy);
        }
      }

      function drawProceduralBoss(ctx, enemy) {
        const size = 80;
        const x = enemy.x;
        const y = enemy.y;

        // Boss pool-specific shapes
        switch (enemy.pool) {
          case 'gold':
            // Golden crown shape
            ctx.fillStyle = '#ffd700';
            ctx.beginPath();
            ctx.moveTo(x, y - size / 2);
            ctx.lineTo(x + size / 3, y);
            ctx.lineTo(x, y + size / 2);
            ctx.lineTo(x - size / 3, y);
            ctx.closePath();
            ctx.fill();
            break;

          case 'silver':
            // Silver hexagon
            drawHexagon(ctx, x, y, size / 2, '#c0c0c0');
            break;

          case 'armor':
            // Shield shape
            drawShield(ctx, x, y, size, '#95a5a6');
            break;

          case 'vehicle':
            // Tank/mech shape
            drawMech(ctx, x, y, size, '#3498db');
            break;

          case 'pet':
            // Pet egg shape
            ctx.fillStyle = '#f39c12';
            ctx.beginPath();
            ctx.ellipse(x, y, size / 2, size * 0.7, 0, 0, Math.PI * 2);
            ctx.fill();
            break;

          case 'gear':
            // Gear/ring shape
            drawGear(ctx, x, y, size / 2, '#9b59b6');
            break;

          case 'gift':
            // Gift box shape
            drawGiftBox(ctx, x, y, size, '#e91e63');
            break;

          case 'key':
            // Key shape
            drawKey(ctx, x, y, size, '#ff4d4f');
            break;

          default:
            // Default boss: large circle with gradient
            const gradient = ctx.createRadialGradient(x, y, 0, x, y, size / 2);
            gradient.addColorStop(0, '#ff4d4f');
            gradient.addColorStop(1, '#c0392b');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(x, y, size / 2, 0, Math.PI * 2);
            ctx.fill();
        }
      }

      function drawProceduralEnemy(ctx, enemy) {
        const size = enemy.isFlying ? 40 : 32;

        if (enemy.isFlying) {
          // Flying: Triangle/wing shape
          ctx.fillStyle = '#3498db';
          ctx.beginPath();
          ctx.moveTo(enemy.x, enemy.y - size / 2);
          ctx.lineTo(enemy.x + size / 2, enemy.y + size / 2);
          ctx.lineTo(enemy.x - size / 2, enemy.y + size / 2);
          ctx.closePath();
          ctx.fill();
        } else {
          // Ground: Pentagon/body shape
          ctx.fillStyle = '#e74c3c';
          drawPentagon(ctx, enemy.x, enemy.y, size / 2);
        }
      }

      function drawHexagon(ctx, x, y, r, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        for (let i = 0; i < 6; i++) {
          const angle = (Math.PI / 3) * i;
          const px = x + r * Math.cos(angle);
          const py = y + r * Math.sin(angle);
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();
      }

      function drawShield(ctx, x, y, size, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.moveTo(x, y - size / 2);
        ctx.quadraticCurveTo(x + size / 2, y - size / 4, x + size / 2, y + size / 4);
        ctx.lineTo(x, y + size / 2);
        ctx.lineTo(x - size / 2, y + size / 4);
        ctx.quadraticCurveTo(x - size / 2, y - size / 4, x, y - size / 2);
        ctx.closePath();
        ctx.fill();
      }

      function drawMech(ctx, x, y, size, color) {
        ctx.fillStyle = color;
        // Body
        ctx.fillRect(x - size / 3, y - size / 3, size * 2 / 3, size * 2 / 3);
        // Head
        ctx.fillRect(x - size / 6, y - size / 2, size / 3, size / 4);
        // Legs
        ctx.fillRect(x - size / 3, y + size / 6, size / 6, size / 3);
        ctx.fillRect(x + size / 6, y + size / 6, size / 6, size / 3);
      }

      function drawPentagon(ctx, x, y, r) {
        ctx.beginPath();
        for (let i = 0; i < 5; i++) {
          const angle = (Math.PI * 2 / 5) * i - Math.PI / 2;
          const px = x + r * Math.cos(angle);
          const py = y + r * Math.sin(angle);
          if (i === 0) ctx.moveTo(px, py);
          else ctx.lineTo(px, py);
        }
        ctx.closePath();
        ctx.fill();
      }

      function drawGear(ctx, x, y, r, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        // Inner circle
        ctx.arc(x, y, r * 0.7, 0, Math.PI * 2);
        ctx.fill();
        // Gear teeth
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 2;
        for (let i = 0; i < 8; i++) {
          const angle = (Math.PI / 4) * i;
          const px1 = x + (r * 0.8) * Math.cos(angle);
          const py1 = y + (r * 0.8) * Math.sin(angle);
          const px2 = x + r * Math.cos(angle);
          const py2 = y + r * Math.sin(angle);
          ctx.beginPath();
          ctx.moveTo(px1, py1);
          ctx.lineTo(px2, py2);
          ctx.stroke();
        }
      }

      function drawGiftBox(ctx, x, y, size, color) {
        ctx.fillStyle = color;
        // Main box
        ctx.fillRect(x - size / 2, y - size / 2, size, size);
        // Ribbon
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(x - size / 2, y);
        ctx.lineTo(x + size / 2, y);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(x, y - size / 2);
        ctx.lineTo(x, y + size / 2);
        ctx.stroke();
      }

      function drawKey(ctx, x, y, size, color) {
        ctx.fillStyle = color;
        // Key head (circle)
        ctx.beginPath();
        ctx.arc(x, y, size / 3, 0, Math.PI * 2);
        ctx.fill();
        // Key shaft
        ctx.fillRect(x, y - size / 6, size * 0.8, size / 3);
        // Key teeth
        ctx.fillRect(x + size * 0.6, y - size / 12, size / 8, size / 6);
      }

      function drawHPBar(ctx, enemy) {
        const barWidth = enemy.isBoss ? 100 : 60;
        const barHeight = 6;
        const x = enemy.x - barWidth / 2;
        const y = enemy.y - (enemy.isBoss ? 50 : 35);

        const hpPct = Math.max(0, enemy.hp / enemy.max);
        const barColor = HP_BAR_COLORS[enemy.kind] || HP_BAR_COLORS.mob;

        // Background
        ctx.fillStyle = '#2c3e50';
        ctx.fillRect(x, y, barWidth, barHeight);

        // HP fill
        ctx.fillStyle = barColor;
        ctx.fillRect(x, y, barWidth * hpPct, barHeight);

        // Border
        ctx.strokeStyle = '#ecf0f1';
        ctx.lineWidth = 1;
        ctx.strokeRect(x, y, barWidth, barHeight);

        // Shield indicator
        if (enemy.spawnShieldT > 0) {
          ctx.fillStyle = '#3498db';
          ctx.fillRect(x, y - 3, barWidth, 2);
        }
      }

      function drawAffixes(ctx, enemy) {
        if (!enemy.affixes || enemy.affixes.length === 0) return;

        const y = enemy.y - (enemy.isBoss ? 65 : 50);
        let offsetX = 0;

        ctx.font = '10px Arial';
        ctx.textAlign = 'center';

        for (const affix of enemy.affixes) {
          const affixName = affix.id || affix;
          const color = AFFIX_COLORS[affixName] || '#ffffff';

          ctx.fillStyle = color;
          ctx.fillText(affixName.toUpperCase(), enemy.x + offsetX, y);
          offsetX += 50;
        }
      }

      function drawBossPoolInfo(ctx, enemy) {
        if (!enemy.pool || !enemy.isBoss) return;

        const poolColors = {
          gold: '#ffd700',
          silver: '#c0c0c0',
          armor: '#95a5a6',
          pet: '#f39c12',
          vehicle: '#3498db',
          gear: '#9b59b6',
          gift: '#e91e63',
          key: '#ff4d4f'
        };

        const color = poolColors[enemy.pool] || '#ffffff';
        ctx.fillStyle = color;
        ctx.font = 'bold 12px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(enemy.name, enemy.x, enemy.y - 75);
      }

      window.drawAdvancedEnemies = function (ctxFromCaller) {
        const st = window.st;
        if (!st || !st.enemies) return;

        const ctx = ctxFromCaller || window.g?.ctx || document.getElementById('cv')?.getContext('2d');
        if (!ctx) return;

        const DESIGN_W = window.DESIGN_W || 1280;

        for (const enemy of st.enemies) {
          if (enemy.hp <= 0) continue;
          if (enemy.x < -100 || enemy.x > DESIGN_W + 100) continue; // Culling

          drawEnemySprite(ctx, enemy);
          drawHPBar(ctx, enemy);

          if (enemy.isBoss) {
            drawAffixes(ctx, enemy);
            drawBossPoolInfo(ctx, enemy);
            drawBossAura(ctx, enemy);
            drawAffixEffects(ctx, enemy);
          }
        }

        // Draw damage numbers
        ctx.globalAlpha = 1;
      };

      // Damage numbers system
      window.addDamageNumber = function () { };
      window.updateDamageNumbers = function () { };
      window.drawDamageNumbers = function () { };

      function drawBossAura(ctx, boss) {
        if (!boss.pool) return;

        const pulseTime = performance.now() * 0.003;
        const radius = 50 + Math.sin(pulseTime) * 10;

        ctx.save();
        ctx.globalAlpha = 0.3;
        // local color map to avoid scope issues
        const poolColors = { gold: '#ffd700', silver: '#c0c0c0', armor: '#95a5a6', vehicle: '#3498db', pet: '#f39c12', gear: '#9b59b6', gift: '#e91e63', key: '#ff4d4f' };
        ctx.strokeStyle = poolColors[boss.pool] || '#ff4d4f';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.arc(boss.x, boss.y, radius, 0, Math.PI * 2);
        ctx.stroke();
        ctx.restore();
      }

      function drawAffixEffects(ctx, enemy) {
        if (!enemy.affixes) return;

        for (const affix of enemy.affixes) {
          switch (affix.id) {
            case 'vampiric':
              // Red pulse
              drawPulse(ctx, enemy.x, enemy.y, '#c0392b');
              break;
            case 'swift':
              // Speed lines
              drawSpeedLines(ctx, enemy.x, enemy.y, '#3498db');
              break;
            case 'regenerating':
              // Green healing sparkles
              drawSparkles(ctx, enemy.x, enemy.y, '#27ae60');
              break;
          }
        }
      }

      function drawPulse(ctx, x, y, color) {
        const time = performance.now() * 0.01;
        const radius = 10 + Math.sin(time) * 5;
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }

      function drawSpeedLines(ctx, x, y, color) {
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.globalAlpha = 0.7;
        for (let i = 0; i < 3; i++) {
          const offset = i * 15;
          ctx.beginPath();
          ctx.moveTo(x - 30 - offset, y);
          ctx.lineTo(x + 30 + offset, y);
          ctx.stroke();
        }
        ctx.globalAlpha = 1;
      }

      function drawSparkles(ctx, x, y, color) {
        ctx.fillStyle = color;
        ctx.globalAlpha = 0.8;
        const time = performance.now() * 0.02;
        for (let i = 0; i < 4; i++) {
          const angle = (Math.PI / 2) * i + time;
          const px = x + Math.cos(angle) * 25;
          const py = y + Math.sin(angle) * 25;
          ctx.beginPath();
          ctx.arc(px, py, 3, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.globalAlpha = 1;
      }

      console.log('✅ Advanced Enemy Rendering System Loaded');
    })();
  </script>
  <!-- Self-tests overlay (sanity checks) -->
  <!--
  <script>
    (function(){
      function addOverlay(){
        const out=document.createElement('div');
        out.id='selfTests';
        out.className='self-test-panel';
        out.innerHTML='<b>Self-tests</b> <button id="runTestsBtn" class="self-test-run-btn">Run</button><div id="selfTestLog" class="self-test-log"></div>';
        document.body.appendChild(out);
        document.getElementById('runTestsBtn').onclick = run;
      }
      function log(msg, ok){
        const c=document.getElementById('selfTestLog'); if(!c) return;
        const s=document.createElement('div'); s.style.color= ok? '#9fffa8':'#ffb6b6'; s.textContent=(ok?'✔ ':'✖ ')+msg; c.appendChild(s);
      }
      function clearLog(){ const c=document.getElementById('selfTestLog'); if(c) c.innerHTML=''; }
      function row(id){ st.cds[id]=st.cds[id]||{S1:0,S2:0,S3:0,S4:0,S5:0,X1:0}; return st.cds[id]; }
      function run(){
        try{
          clearLog();
          const A = (st.players||[]).find(p=>p.id==='A1');
          const U = (st.players||[]).find(p=>p.id==='Unique');
          const M = (st.players||[]).find(p=>p.id==='Missy');
          if(!A||!U||!M){ log('Players present (A1/Unique/Missy)', false); return; }

          // Reset CDs for deterministic tests
          st.cds = st.cds||{}; row(A.id); row(U.id); row(M.id);
          for(const k of ['S1','S2','S3','S4','S5','X1']){ st.cds[A.id][k]=0; st.cds[U.id][k]=0; st.cds[M.id][k]=0; }

          // Test 1: Unique S2 spawns to cap then upgrades
          st.shots = st.shots||[]; // clear modules
          for(let i=0;i<6;i++) unique_useSkill(U,'S2');
          const drones = (st.shots||[]).filter(s=>s.kind==='unique_module' && s.ownerId===U.id);
          const capOK = drones.length === (CFG.Unique.drone.max||4);
          const lvlOK = drones.length>0 ? drones.every(d=> (d.level||1) >= 1) : false;
          log('Unique S2: spawns to cap; upgrades after', capOK && lvlOK);

          // Test 2: A1 clone rework — 20s timer + blink strike (no scaling)
          st.clones = []; st.enemies = st.enemies||[];
          // spawnClone(A); const c = st.clones[0]; const e={x:A.x+120,y:A.y,hp:100,max:100,kind:'mob'}; st.enemies.push(e);
          // drive patch update to trigger teleport strike (~1.2s)
          // if(typeof g?.update==='function') g.update(1.3);
          // const blinkHitOK = (e.hp < 100);
          // // drive expiry beyond 20s
          // if(typeof g?.update==='function') g.update(21);
          // const expiredOK = (st.clones||[]).length===0;
          // log('Clone: blink strike + 20s expiry', blinkHitOK && expiredOK);

          // Test 3: A1 S3 charged waves fire
          st.shots.length=0; A._hold={s3waves:8}; a1_useSkill(A,'S3'); log('A1 S3 fires charged waves', st.shots.length>=2);

          // Test 4: A1 projectile sizes — S3=3x, S5=4x, X1=6x
          const baseR = CFG.A1.xwave.r;
          st.shots.length=0; a1_useSkill(A,'S3'); const s3 = st.shots.at(-1); log('A1 S3 radius >= 3x base', s3 && (s3.aoe||0) >= baseR*3 - 0.1);
          st.shots.length=0; a1_useSkill(A,'S5'); const s5 = st.shots.at(-1); log('A1 S5 radius >= 4x base', s5 && (s5.aoe||0) >= baseR*4 - 0.1);
          st.shots.length=0; a1_useSkill(A,'X1'); const x1 = st.shots.at(-1); log('A1 X1 radius >= 6x base', x1 && (x1.aoe||0) >= baseR*6 - 0.1);

          // Test 5: Unique beams — S4 life ≈ 0.5–2.5s; X1 thicker than S4
          // (Runner uses 0.3–2.5s for S4 release.)
          U._stellarCharge = (U._stellarMaxCharge||2500); unique_releaseStellarAnnihilator(U);
          const s4Beam = (st.shots||[]).filter(s=>s.kind==='unique_stellar_beam' && s.ownerId===U.id).at(-1);
          U._hold={xhold:2000}; unique_useSkill(U,'X1'); const x1Beam = (st.shots||[]).filter(s=>s.kind==='unique_stellar_beam' && s.ownerId===U.id).at(-1);
          const thOK = (x1Beam?.h||0) > (s4Beam?.h||0);
          const lifeOK = (s4Beam?.life||0) >= 2000 && (s4Beam?.life||0) <= 4000; // matches runner charge math
          log('Unique beams (life and thickness)', thOK && lifeOK);

          // Test 6: Missy S5 skip rules (no boss skip; normal skip ok)
          const wave0 = st.wave; st.bossAlive=true; missy_useSkill(M,'S5'); const noSkip = (st.wave===wave0);
          st.bossAlive=false; const wave1=st.wave; missy_useSkill(M,'S5'); const didSkip = (st.wave>wave1);
          log('Missy S5 skip rules', noSkip && didSkip);

          // Test 7: A1 S5 resets S1 & S2
          row(A.id).S1=5000; row(A.id).S2=5000; useSkillWrapper(A,'S5'); const resetOK = (row(A.id).S1===0 && row(A.id).S2===0);
          log('A1 S5 resets S1 & S2', resetOK);

          // Test 8: Charge FX clears on release (flagged on)
          const eff0 = st.effects.length; startHold(A,'A1_S1'); releaseHold(A,'A1_S1'); const chargeLeft = st.effects.some(f=>f.kind==='charge' && f.owner===A);
          log('Charge FX clears on release', !chargeLeft);
        }catch(err){ console.error(err); log('Exception during tests: '+(err?.message||err), false); }
      }
      // Install overlay a tick later to ensure DOM/body ready
      window.addEventListener('load', ()=>{ try{ addOverlay(); setTimeout(run, 400); }catch(e){} });
    })();
  </script>
-->
  <!-- Runner Plus Patch: external JavaScript file -->
  <!-- Skills Core: registry + components + helpers inline to keep organized -->
  <script>
    // === Registry ===
    const freeze = (o) => Object.freeze(o);
    class SkillRegistry {
      constructor() { this._map = new Map(); }
      register(def) { const id = def?.id; if (!id) throw new Error('Skill id required'); if (this._map.has(id)) throw new Error('Duplicate skill ' + id); this._map.set(id, freeze({ ...def })); return this; }
      upsert(def) { const id = def?.id; if (!id) throw new Error('Skill id required'); this._map.set(id, freeze({ ...def })); return this; }
      registerMany(arr) { if (arr) for (const d of arr) this.register(d); return this; }
      get(id) { return this._map.get(id); }
      has(id) { return this._map.has(id); }
      all() { return Array.from(this._map.values()); }
      clear() { this._map.clear(); }
      static validate(def) { if (!def || typeof def !== 'object') return { ok: false, reason: 'no-def' }; if (!def.id || typeof def.id !== 'string') return { ok: false, reason: 'bad-id' }; if (!def.kind || typeof def.kind !== 'string') return { ok: false, reason: 'bad-kind' }; return { ok: true }; }
    }

    // ✅ SIMPLIFIED SKILL SYSTEM - 12 Skills (4 per character)
    // Based on: SIMPLIFIED_SKILLS_COMPLETE.md
    const Skills = {
      // === A1 - BOSS SLAYER ===
      A1_S1: { id: 'A1_S1', kind: 'attack', name: 'Crimson Slash', power: 140, cooldownMs: 2500, color: '#ff4d4f' },
      A1_S2: {
        id: 'A1_S2',
        kind: 'spawn',
        name: 'Shadow Clone Army',
        power: 100,
        cooldownMs: 6000,
        cap: 2,
        baseAtk: 30,
        baseHp: 100,
        summonType: 'clone',
        color: '#ff3b3b',
        spriteData: {
          heroType: 'A1',
          width: 18,
          height: 26,
          speed: 120,
          attackRange: 80,
          attackCooldown: 1200,
          projectileColor: '#DC143C',
          coolSkill: 'bloodRush',
          aiBehavior: 'aggressive'
        }
      },
      A1_S3: { id: 'A1_S3', kind: 'boss_killer', name: 'BOSS DESTROYER', power: 400, cooldownMs: 12000, bossMultiplier: 3, color: '#e74c3c' },
      A1_S4: { id: 'A1_S4', kind: 'execute', name: 'CRIMSON X-EXECUTION', power: 1500, cooldownMs: 20000, rageCost: 100, executeThreshold: 0.3, hits: 10, color: '#c0392b' },

      // === UNIQUE - MOB KILLER ===
      UNIQUE_S1: { id: 'UNIQUE_S1', kind: 'attack', name: 'Frost Wave', power: 130, cooldownMs: 2500, color: '#74b9ff' },
      UNIQUE_S2: {
        id: 'UNIQUE_S2',
        kind: 'spawn',
        name: 'Combat Drone Fleet',
        power: 80,
        cooldownMs: 6000,
        cap: 2,
        baseAtk: 35,
        baseHp: 100,
        summonType: 'drone',
        healAmount: 20,
        color: '#00E5FF',
        spriteData: {
          heroType: 'UNIQUE',
          width: 18,
          height: 26,
          speed: 120,
          attackRange: 80,
          attackCooldown: 1200,
          projectileColor: '#00E5FF',
          coolSkill: 'empBurst',
          aiBehavior: 'supportive'
        }
      },
      UNIQUE_S3: { id: 'UNIQUE_S3', kind: 'screen_wide', name: 'MOB ANNIHILATOR', power: 300, cooldownMs: 12000, groupBonus: 20, color: '#0984e3' },
      UNIQUE_S4: { id: 'UNIQUE_S4', kind: 'chain', name: 'CHAIN DESTRUCTION', power: 500, cooldownMs: 20000, rageCost: 100, chainRange: 150, maxChains: 8, color: '#6c5ce7' },

      // === MISSY - LOOT QUEEN ===
      MISSY_S1: { id: 'MISSY_S1', kind: 'attack', name: 'Lucky Spin', power: 150, cooldownMs: 2500, vacuum: true, vacuumRadius: 200, color: '#ffd700' },
      MISSY_S2: {
        id: 'MISSY_S2',
        kind: 'spawn',
        name: 'Lucky Battle Pets',
        power: 120,
        cooldownMs: 6000,
        cap: 3,
        baseAtk: 40,
        baseHp: 100,
        summonType: 'pet',
        healAmount: 25,
        color: '#ffd56a',
        spriteData: {
          heroType: 'MISSY',
          width: 18,
          height: 26,
          speed: 120,
          attackRange: 80,
          attackCooldown: 1200,
          projectileColor: '#FFD700',
          coolSkill: 'fortuneWave',
          aiBehavior: 'defensive'
        }
      },
      MISSY_S3: { id: 'MISSY_S3', kind: 'treasure', name: 'TREASURE NUKE', power: 350, cooldownMs: 10000, goldScaling: 0.005, lootBonus: 0.5, color: '#fdcb6e' },
      MISSY_S4: { id: 'MISSY_S4', kind: 'ultimate', name: 'DIVINE JACKPOT', power: 600, cooldownMs: 20000, rageCost: 100, duration: 10000, flight: true, invulnerable: true, petLevelBoost: 10, color: '#f39c12' },
    };
    const registry = new SkillRegistry(); for (const v of Object.values(Skills)) registry.register(v);

    // === Components ===
    class SpawnManager {
      constructor({ cap = Infinity, factory = () => ({}), onSpawn = () => { }, onDespawn = () => { }, applyUpgrade = () => { } } = {}) {
        this.cap = cap; this.factory = factory; this.onSpawn = onSpawn; this.onDespawn = onDespawn; this.applyUpgrade = applyUpgrade;
        this._active = new Set(); this._pool = [];
      }
      get count() { return this._active.size; } get atCap() { return this.count >= this.cap; }
      remaining() { return Math.max(0, this.cap - this.count); }
      acquire() { return this._pool.length ? this._pool.pop() : this.factory(); }
      spawn(args = {}, postUpgrades = []) { if (this.atCap) return null; const inst = this.acquire(); this._active.add(inst); try { this.onSpawn(inst, args); if (postUpgrades && postUpgrades.length) { for (const up of postUpgrades) this.applyUpgrade(inst, up); } } catch (e) { this._active.delete(inst); this._pool.push(inst); throw e; } return inst; }
      despawn(inst) { if (!this._active.has(inst)) return false; try { this.onDespawn(inst); } finally { this._active.delete(inst); this._pool.push(inst); } return true; }
      releaseAll() { for (const inst of Array.from(this._active)) this.despawn(inst); }
      listActive() { return Array.from(this._active); }
      withCap(n) { this.cap = Number.isFinite(n) ? n : this.cap; return this; }
    }

    const clamp01 = (v) => v < 0 ? 0 : v > 1 ? 1 : v;
    class Chargeable {
      constructor({ baseRadius = 0, minScale = 1, maxScale = 2, minHoldMs = 0, maxHoldMs = 1000, timeSource = () => Date.now(), onStart = () => { }, onRelease = () => { } } = {}) {
        this.baseRadius = baseRadius; this.minScale = minScale; this.maxScale = maxScale; this.minHoldMs = minHoldMs; this.maxHoldMs = Math.max(1, maxHoldMs); this.now = timeSource; this.onStart = onStart; this.onRelease = onRelease; this._t0 = 0; this._charging = false;
      }
      get isCharging() { return this._charging; }
      start(at = this.now()) { if (this._charging) return false; this._charging = true; this._t0 = at; this.onStart(); return true; }
      current(at = this.now()) { if (!this._charging) return { chargedMs: 0, t: 0, scale: this.minScale, radius: this.baseRadius * this.minScale }; const chargedMs = Math.max(0, at - this._t0); const t = clamp01(chargedMs / this.maxHoldMs); const scale = this.minScale + (this.maxScale - this.minScale) * t; const radius = this.baseRadius * scale; return { chargedMs, t, scale, radius }; }
      release(at = this.now()) { const was = this._charging; const s = this.current(at); const minMet = s.chargedMs >= this.minHoldMs; this._charging = false; this._t0 = 0; if (was) this.onRelease({ ...s, minMet }); return { ...s, minMet }; }
      cancel() { this._charging = false; this._t0 = 0; }
    }

    class Beam {
      constructor({ lifeMs = 1000, baseWidth = 10, tickMs = 100, pierce = false, timeSource = () => Date.now(), onTick = () => { }, onHit = () => { }, onEnd = () => { } } = {}) {
        this.lifeMs = lifeMs; this.baseWidth = baseWidth; this.tickMs = Math.max(1, tickMs); this.pierce = pierce; this.now = timeSource; this.onTick = onTick; this.onHit = onHit; this.onEnd = onEnd; this._t0 = 0; this._ticksDone = 0; this._active = false; this._hitSet = new Set();
      }
      get isActive() { return this._active; } get elapsed() { return this._active ? Math.max(0, this.now() - this._t0) : 0; } get progress() { return clamp01(this.elapsed / this.lifeMs); } get width() { return this.baseWidth; }
      start(at = this.now()) { if (this._active) return false; this._active = true; this._t0 = at; this._ticksDone = 0; this._hitSet.clear(); return true; }
      hit(target, info = {}) { if (!this._active) return false; if (!this.pierce) { if (this._hitSet.has(target)) return false; this._hitSet.add(target); } this.onHit(target, info); return true; }
      update(at = this.now()) { if (!this._active) return false; const elapsed = Math.max(0, at - this._t0); const maxTicks = Math.floor(elapsed / this.tickMs); const toRun = Math.min(32, Math.max(0, maxTicks - this._ticksDone)); for (let i = 0; i < toRun; i++) { const tickIndex = this._ticksDone + 1; const tickTime = this._t0 + tickIndex * this.tickMs; const ctx = { at: tickTime, elapsed: tickTime - this._t0, lifeMs: this.lifeMs, progress: clamp01((tickTime - this._t0) / this.lifeMs), width: this.width, pierce: this.pierce, hit: (t, extra) => this.hit(t, extra) }; this.onTick(ctx); this._ticksDone++; } if (elapsed >= this.lifeMs) { this._finish('expired'); } return true; }
      end() { if (!this._active) return false; this._finish('cancelled'); return true; }
      _finish(reason) { const was = this._active; this._active = false; try { if (was) this.onEnd(reason); } finally { this._hitSet.clear(); } }
    }

    function checkRules(rules = {}, ctx = {}) {
      const reasons = []; const hp = Number(ctx.hp ?? 0); const hpMax = Math.max(1, Number(ctx.hpMax ?? 1)); const hpPct = clamp01(hp / hpMax); const kills = Number(ctx.kills ?? 0); const targetIsBoss = !!ctx.targetIsBoss;
      if (typeof rules.hpPctMin === 'number' && hpPct < rules.hpPctMin) reasons.push('hp-low');
      if (typeof rules.hpPctMax === 'number' && hpPct > rules.hpPctMax) reasons.push('hp-high');
      if (typeof rules.killsMin === 'number' && kills < rules.killsMin) reasons.push('kills-low');
      if (typeof rules.killsMax === 'number' && kills > rules.killsMax) reasons.push('kills-high');
      if (rules.forbidBoss && targetIsBoss) reasons.push('forbid-boss');
      if (rules.requireBoss && !targetIsBoss) reasons.push('require-boss');
      if (rules.cost) { const res = ctx.resources || {}; for (const [k, v] of Object.entries(rules.cost)) { const need = Number(v || 0), have = Number(res[k] || 0); if (have < need) reasons.push(`insufficient-${k}`); } }
      return { ok: reasons.length === 0, reasons };
    }
    function spendCost(cost = {}, ctx = {}) { if (!cost) return true; const res = ctx.resources || {}; for (const [k, v] of Object.entries(cost)) { const need = Number(v || 0); const have = Number(res[k] || 0); if (have < need) return false; } for (const [k, v] of Object.entries(cost)) { const need = Number(v || 0); res[k] = Number(res[k] || 0) - need; } return true; }
    class Gating { constructor({ now = () => Date.now() } = {}) { this.now = now; this._lastUse = new Map(); } cooldownRemainingMs(id, cd) { const t = this._lastUse.get(id); if (!t) return 0; const r = cd - (this.now() - t); return r > 0 ? r : 0; } canActivate(def = {}, ctx = {}) { const id = def.id || ''; const cdMs = Number(def.cooldownMs || 0); const cr = cdMs > 0 ? this.cooldownRemainingMs(id, cdMs) : 0; const reasons = []; if (cr > 0) reasons.push('cooldown'); const ruleRes = checkRules(def.rules || {}, ctx); if (!ruleRes.ok) reasons.push(...ruleRes.reasons); return { ok: reasons.length === 0, reasons, cooldownRemainingMs: cr, cost: def.rules && def.rules.cost ? { ...def.rules.cost } : undefined }; } markUsed(def = {}) { const id = def.id || ''; if (!id) return false; this._lastUse.set(id, this.now()); return true; } reset(id) { this._lastUse.delete(id); } }

    // === Helpers and minimal adapters ===
    const __allyBuckets = new Map();
    function getOwnerList(owner, skillId) { const key = `${skillId || 'UNK'}:${owner?.id || 'owner'}`; if (!__allyBuckets.has(key)) __allyBuckets.set(key, []); return __allyBuckets.get(key); }

    const pool = {
      _store: new Map(),
      take(kind, init = {}) { const arr = this._store.get(kind) || []; const ent = arr.pop() || { kind }; Object.assign(ent, init); if (init.pos && typeof init.pos.x === 'number') { ent.x = init.pos.x; ent.y = init.pos.y; } if (ent.hp == null && init.hp != null) ent.hp = init.hp; if (ent.max == null && (init.hpMax != null || init.max != null)) ent.max = init.hpMax ?? init.max; if (ent.max == null && ent.hp != null) ent.max = ent.hp; return ent; },
      release(kind, ent) { const arr = this._store.get(kind) || []; arr.push(ent); this._store.set(kind, arr); }
    };

    function applyUpgrades(ent, ups = []) {
      for (const u of (ups || [])) {
        if (typeof u !== 'string') continue; let m; if ((m = /^\+atk(\d+)%$/i.exec(u))) { const pct = Number(m[1] || 0) / 100; if (ent.atk != null) ent.atk = Math.round(ent.atk * (1 + pct)); if (ent.dmg != null) ent.dmg = Math.round(ent.dmg * (1 + pct)); }
        else if ((m = /^\+hp(\d+)$/i.exec(u))) { const add = Number(m[1] || 0); ent.max = (ent.max || 0) + add; ent.hp = Math.min(ent.max, (ent.hp || 0) + add); }
        else if ((m = /^level\+(\d+)$/i.exec(u))) { ent.level = (ent.level || 1) + Number(m[1] || 0); }
      }
    }

    // Requested API: spawnAlly(owner, spec)
    function spawnAlly(owner, spec) {
      const list = getOwnerList(owner, spec?.id || 'UNIQUE_S2');
      if (list.length >= (spec?.cap ?? 0)) return null;
      const ent = pool.take('uniqueMinion', { pos: { x: owner.x ?? owner.pos?.x ?? 0, y: owner.y ?? owner.pos?.y ?? 0 }, atk: spec?.baseAtk ?? 10, hp: spec?.baseHp ?? 50, level: 1, ownerId: owner?.id });
      list.push(ent);
      applyUpgrades(ent, spec?.postUpgrades);
      return ent;
    }

    // Optional: simple dispatcher for immediate use without refactor
    const gating = new Gating({ now: () => performance.now() });
    function useSkill(owner, skillId) {
      if (owner && owner.isDefeated) return null; const def = registry.get(skillId) || Skills[skillId]; if (!def) { console.warn('Unknown skill', skillId); return null; } if (def.kind === 'gated') { const ctx = { hp: owner?.hp, hpMax: owner?.max, kills: (owner?.kills || 0), targetIsBoss: !!window?.st?.bossAlive, resources: window?.st?.resources || {} }; const res = gating.canActivate(def, ctx); if (!res.ok) { try { window.notify && window.notify('Skill blocked: ' + res.reasons.join(','), '#ffd56a'); } catch (_e) { } return null; } if (def.rules?.cost) spendCost(def.rules.cost, ctx); gating.markUsed(def); }
      switch (def.kind) {
        case 'spawn': {
          // Route S2 skills through anime system if available
          if (def.id && def.id.endsWith('_S2') && window.skillIntegration && window.skillIntegration.canHandle(owner, 'S2')) {
            const heroId = String(owner.id || '').toUpperCase();
            if (['A1', 'UNIQUE', 'MISSY'].includes(heroId)) {
              return window.skillIntegration.cast(owner, 'S2', { angle: owner.facingLeft ? Math.PI : 0 });
            }
          }
          if (def.id === 'UNIQUE_S2') return spawnAlly(owner, def);
          // Generic spawn via manager
          const manKey = `__sm:${def.id}`;
          const man = (useSkill._m ||= {})[manKey] ||= new SpawnManager({ cap: def.cap || Infinity, factory: () => ({ kind: 'ally', ownerId: owner?.id }), onSpawn: (e) => { e.x = owner?.x || 0; e.y = owner?.y || 0; }, applyUpgrade: (e, u) => applyUpgrades(e, [u]) });
          return man.spawn({}, def.postUpgrades || []);
        }
        case 'charge': {
          // Integrate with existing hold system if desired; here we just return a Chargeable instance
          return new Chargeable({ baseRadius: def.baseRadius || 0, minScale: def.minScale || 1, maxScale: def.maxScale || 2, maxHoldMs: 1600 });
        }
        case 'beam': {
          const beam = new Beam({ lifeMs: def.lifeMs || 1000, baseWidth: def.baseWidth || 10, tickMs: 100, pierce: !!def.pierce, onTick: () => { }, onHit: () => { }, onEnd: () => { } });
          beam.start(); return beam;
        }
        default: return null;
      }
    }

    // Simple FxController kept minimal and local to avoid conflicts
    class FxController { constructor({ owner = null, spawnFx = () => null, killFx = () => { }, now = () => Date.now() } = {}) { this.owner = owner; this.spawnFx = spawnFx; this.killFx = killFx; this.now = now; this._fx = new Map(); } setOwner(o) { this.owner = o; return this; } attach(name, options = {}) { const handle = this.spawnFx(name, { ...options, attachTo: this.owner }); const id = handle != null ? handle : ('fx_' + Math.random().toString(36).slice(2)); this._fx.set(id, { name, handle: handle ?? id }); return id; } attachOnce(name, options = {}, ms = 0) { const id = this.attach(name, options); if (ms > 0) { const t = setTimeout(() => { try { this.detach(id); } catch (_e) { } }, ms); if (t && typeof t.unref === 'function') t.unref(); } return id; } detach(id) { const rec = this._fx.get(id); if (!rec) return false; try { this.killFx(rec.handle); } finally { this._fx.delete(id); } return true; } detachAll() { for (const id of Array.from(this._fx.keys())) this.detach(id); } }

    // Expose to global for easy wiring
    window.SkillEngine = { registry, Skills, components: { SpawnManager, Chargeable, Beam, FxController, Gating, checkRules, spendCost }, useSkill, spawnAlly, getOwnerList, pool, applyUpgrades };

    console.debug('[Skills] Inline registry/components ready');
  </script>
  <script>
    (function () {
      function guard(name, fn) { return function () { try { return fn.apply(this, arguments); } catch (e) { console.error('[SkillGuard]', name, e); try { notify(name + ' error: ' + (e?.message || e), '#ff7a6a'); } catch (_) { } } } }
      window.addEventListener('load', function () {
        try {
          if (typeof window.unique_useSkill === 'function') window.unique_useSkill = guard('unique_useSkill', window.unique_useSkill);
          if (typeof window.a1_useSkill === 'function') window.a1_useSkill = guard('a1_useSkill', window.a1_useSkill);
          if (typeof window.missy_useSkill === 'function') window.missy_useSkill = guard('missy_useSkill', window.missy_useSkill);
          if (typeof window.unique_releaseStellarAnnihilator === 'function') window.unique_releaseStellarAnnihilator = guard('unique_releaseStellarAnnihilator', window.unique_releaseStellarAnnihilator);
        } catch (_e) { }
      });

      // Backtick debug HUD with flag toggles
      const hud = document.createElement('div');
      hud.id = 'debugHud';
      hud.innerHTML = '<b>Debug</b>' +
        '<div id="dbgCounts"></div>' +
        '<div id="dbgFlags"></div>' +
        '<div id="dbgActions"><button id="btnReRun">Re-run Tests</button></div>';
      function mkFlagRow(key) { const row = document.createElement('label'); row.style.display = 'block'; const cb = document.createElement('input'); cb.type = 'checkbox'; cb.checked = !!(CFG?.flags && CFG.flags[key]); cb.onchange = () => { CFG.flags = CFG.flags || {}; CFG.flags[key] = cb.checked; }; row.appendChild(cb); row.appendChild(document.createTextNode(' ' + key)); return row; }
      function refresh() {
        const c = document.getElementById('dbgCounts'); if (c) { const S = window.st || {}; c.textContent = `Enemies:${(S.enemies || []).length}  Shots:${(S.shots || []).length}  Clones:${(S.clones || []).length}`; }
        const f = document.getElementById('dbgFlags'); if (f) { f.replaceChildren(mkFlagRow('uniqueS2'), mkFlagRow('a1S3'), mkFlagRow('uniqueBeam'), mkFlagRow('missyS5'), mkFlagRow('chargeFx'), mkFlagRow('homingPlus'), mkFlagRow('autoPlus'), mkFlagRow('dragoonSwap')); }
        const btn = document.getElementById('btnReRun'); if (btn && !btn._wired) { btn._wired = true; btn.onclick = () => { try { document.getElementById('runTestsBtn')?.click(); } catch (_e) { } }; }
      }
      document.addEventListener('keydown', (ev) => { if (ev.key === '`') { hud.style.display = (hud.style.display === 'none' ? 'block' : 'none'); refresh(); } });
      setInterval(() => { if (hud.style.display !== 'none') refresh(); }, 1000);
      window.addEventListener('load', () => { try { document.body.appendChild(hud); } catch (_e) { } });
    })();
  </script>
  <div class="skill-btn-overlay" id="skillBtnOverlay">
    <div class="skill-btn skill-btn-1">S</div>
    <div class="skill-btn skill-btn-2">S</div>
    <div class="skill-btn skill-btn-3">S</div>
    <div class="skill-btn skill-btn-4">S</div>
  </div>
  <div class="self-tests" id="selfTests"><b>Self-tests</b> <button class="test-run-btn" id="runTestsBtn">Run</button>
    <div class="test-log" id="selfTestLog">
      <div class="test-fail">✖ Unique S2: spawns to cap; upgrades after</div>
      <div class="test-pass">✔ A1 clone heals and levels on kill</div>
      <div class="test-pass">✔ A1 S3 fires charged waves</div>
      <div class="test-fail">✖ A1 S3 radius &gt;= 3x base</div>
      <div class="test-pass">✔ A1 S5 radius &gt;= 4x base</div>
      <div class="test-pass">✔ A1 X1 radius &gt;= 6x base</div>
      <div class="test-fail">✖ Unique beams (life and thickness)</div>
      <div class="test-fail">✖ Missy S5 skip rules</div>
      <div class="test-pass">✔ A1 S5 resets S1 &amp; S2</div>
      <div class="test-fail">✖ Charge FX clears on release</div>
    </div>
  </div>
  <!-- OLD SCROLL/SKILL SYSTEM REMOVED - Now using simplified skills -->
  <script>
    /* === Enhanced Watchdog: Sleepy AI + Random Boss Spawner + Flawless Logic === */
    (function () {
      'use strict';
      const now = () => Date.now();
      const leader = () => { try { return (st.players || [])[st.leader || 0] || st.players?.[0] || null; } catch (_) { return null; } };

      // ===== FLAWLESS SLEEP SYSTEM =====
      let pulseAt = 0;
      let lastActionAt = 0;

      function pulse() {
        pulseAt = now();
        lastActionAt = now();
      }

      // Detect all player actions (attacks, skills, movement)
      window.addEventListener('mousedown', pulse);
      window.addEventListener('keydown', e => {
        if (e.code === 'Space' || e.code === 'KeyJ' || e.code === 'KeyK' ||
          e.code === 'Digit1' || e.code === 'Digit2' || e.code === 'Digit3' || e.code === 'Digit4' ||
          e.code === 'KeyA' || e.code === 'KeyD' || e.code === 'KeyW' || e.code === 'KeyS') {
          pulse();
        }
      });

      // ===== RANDOM BOSS SPAWNER AT PLATFORM END =====
      // Platform zones with progressive difficulty and spawn rules
      const BOSS_SPAWN_ZONES = [
        {
          x: 3800, width: 250, chance: 0.20, minWave: 3, difficulty: 'hard',
          name: 'Far Right Edge', eliteChance: 0.4
        },
        {
          x: 3200, width: 200, chance: 0.15, minWave: 2, difficulty: 'medium',
          name: 'Right Platform End', eliteChance: 0.3
        },
        {
          x: 2400, width: 180, chance: 0.12, minWave: 4, difficulty: 'hard',
          name: 'Mid-Right Section', eliteChance: 0.35
        },
        {
          x: 1600, width: 180, chance: 0.10, minWave: 2, difficulty: 'medium',
          name: 'Center Platform', eliteChance: 0.25
        },
        {
          x: 800, width: 150, chance: 0.08, minWave: 5, difficulty: 'elite',
          name: 'Left Section', eliteChance: 0.5
        },
        {
          x: 150, width: 120, chance: 0.06, minWave: 6, difficulty: 'elite',
          name: 'Far Left Edge (Danger Zone)', eliteChance: 0.6
        }
      ];

      let lastBossSpawnCheck = 0;
      let lastBossSpawnZone = null;
      const BOSS_CHECK_INTERVAL = 7000; // Check every 7 seconds
      const ZONE_COOLDOWN = 20000; // 20s cooldown per zone
      let bossesSpawnedThisWave = 0;
      let bossesSpawnedThisStage = 0;
      const MAX_BOSSES_PER_WAVE = 2;
      const MAX_BOSSES_PER_STAGE = 5;
      const zoneCooldowns = new Map();

      function getStageMultiplier() {
        // Stage 1: x1.0, Stage 2: x1.5
        return st.stage === 2 ? 1.5 : 1.0;
      }

      function getWaveMultiplier() {
        // Progressive difficulty per wave
        const wave = st.wave || 1;
        return 1 + (wave * 0.1); // +10% per wave
      }

      function canSpawnInZone(zone) {
        const t = now();
        const lastSpawn = zoneCooldowns.get(zone.name) || 0;
        if (t - lastSpawn < ZONE_COOLDOWN) return false;

        // Check wave requirement
        if ((st.wave || 1) < zone.minWave) return false;

        // Check if already spawned too many
        if (bossesSpawnedThisWave >= MAX_BOSSES_PER_WAVE) return false;
        if (bossesSpawnedThisStage >= MAX_BOSSES_PER_STAGE) return false;

        return true;
      }

      function trySpawnRandomBoss() {
        const t = now();
        if (t - lastBossSpawnCheck < BOSS_CHECK_INTERVAL) return;
        lastBossSpawnCheck = t;

        // Safety checks
        if (!st || !st.running || st.bossAlive) return;
        if ((st.enemies || []).length > 12) return; // Don't spawn if too crowded

        const L = leader();
        if (!L) return;

        // Calculate adjusted spawn chances based on difficulty
        const stageMulti = getStageMultiplier();
        const waveMulti = getWaveMultiplier();
        const totalMulti = stageMulti * waveMulti;

        // Check spawn zones in order of proximity
        const sortedZones = [...BOSS_SPAWN_ZONES].sort((a, b) => {
          const distA = Math.abs(L.x - a.x);
          const distB = Math.abs(L.x - b.x);
          return distA - distB;
        });

        for (const zone of sortedZones) {
          const distToZone = Math.abs(L.x - zone.x);

          // Player must be within zone width
          if (distToZone > zone.width) continue;

          // Check if can spawn in this zone
          if (!canSpawnInZone(zone)) continue;

          // Adjusted spawn chance
          const adjustedChance = Math.min(0.35, zone.chance * totalMulti);
          const roll = Math.random();

          if (roll < adjustedChance) {
            // Determine if elite or normal boss
            const isElite = Math.random() < zone.eliteChance;

            // Spawn position with slight randomness
            const spawnX = zone.x + (Math.random() - 0.5) * 80;
            const spawnY = (L.y || 0) - 60;

            // Attempt spawn
            let spawned = false;
            if (typeof window.spawnRandomBoss === 'function') {
              window.spawnRandomBoss(spawnX, spawnY, { elite: isElite, difficulty: zone.difficulty });
              spawned = true;
            } else if (typeof window.spawnBossForStage === 'function') {
              window.spawnBossForStage();
              spawned = true;
            }

            if (spawned) {
              bossesSpawnedThisWave++;
              bossesSpawnedThisStage++;
              zoneCooldowns.set(zone.name, t);
              lastBossSpawnZone = zone;

              // Visual + audio feedback
              if (typeof window.VFX !== 'undefined') {
                if (VFX.Particles) {
                  VFX.Particles.emit('confetti', spawnX, spawnY, {
                    count: isElite ? 30 : 20,
                    palette: isElite ? ['#ff0000', '#ff6600', '#ffaa00'] : ['#4444ff', '#6666ff', '#8888ff']
                  });
                  VFX.Particles.emit('smoke', spawnX, spawnY, { count: 15, color: '#333333' });
                }
                if (VFX.Camera) {
                  VFX.Camera.shake(isElite ? 10 : 6, isElite ? 400 : 280, 18);
                }
                if (VFX.Lighting) {
                  VFX.Lighting.halo(spawnX, spawnY, isElite ? 180 : 120, isElite ? '#ff0000' : '#4444ff', 1.2, 500);
                }
              }

              // Notify player
              const msg = isElite
                ? `⚡ ELITE BOSS spawned at ${zone.name}! ⚡`
                : `🎯 Boss spawned at ${zone.name}`;

              if (typeof window.notify === 'function') {
                window.notify(msg, isElite ? '#ff4444' : '#4444ff');
              }

              console.log(`${isElite ? '⚡ ELITE' : '🎯'} Boss spawned at ${zone.name} (x=${spawnX.toFixed(0)}, wave=${st.wave}, stage=${st.stage})`);

              break; // Only spawn one per check
            }
          }
        }
      }

      // Reset counters on wave/stage change
      let lastWave = 0;
      let lastStage = 1;
      function checkProgressionChange() {
        if (!st) return;

        // Wave change
        if (st.wave !== lastWave) {
          lastWave = st.wave;
          bossesSpawnedThisWave = 0;
          console.log(`[Watchdog] New wave ${st.wave} - boss counter reset`);
        }

        // Stage change
        if (st.stage !== lastStage) {
          lastStage = st.stage;
          bossesSpawnedThisStage = 0;
          zoneCooldowns.clear();
          console.log(`[Watchdog] New stage ${st.stage} - full reset`);
        }
      }

      // ===== ENHANCED SLEEPY AI =====
      function aiTick() {
        try {
          const L = leader();
          const t = now();
          const recent = (t - lastActionAt) < 800; // Player acted recently
          const arr = st.enemies || [];

          // Check for wave/stage changes
          checkProgressionChange();

          // Try spawning random boss (Stage 2+ with wave 2+ for safety)
          if (st && st.stage >= 2 && (st.wave || 1) >= 2) {
            trySpawnRandomBoss();
          } else if (st && st.stage === 1 && (st.wave || 1) >= 5) {
            // Stage 1: Only spawn after wave 5 for early game balance
            trySpawnRandomBoss();
          }

          // Update enemy AI states
          for (const e of arr) {
            if (!e || e.dead) continue;

            const ex = e.x || 0;
            const ey = e.y || 0;
            const lx = L ? (L.x || 0) : 0;
            const ly = L ? (L.y || 0) : 0;
            const dx = lx - ex;
            const dy = ly - ey;
            const dist = Math.hypot(dx, dy);

            // ===== DYNAMIC WAKE DISTANCE CALCULATION =====
            let wakeDist = e._wakeDist || 200;

            // Type-based wake distance
            if (e.boss) wakeDist = 450;           // Bosses: very far
            else if (e.elite) wakeDist = 380;     // Elites: far
            else if (e.flying) wakeDist = 320;    // Flying: medium-far
            else if (e.ranged) wakeDist = 280;    // Ranged: medium
            else if (e.fast) wakeDist = 300;      // Fast enemies: medium-far

            // Stage multiplier (higher stages = enemies wake earlier)
            if (st && st.stage === 2) wakeDist *= 1.2;

            // Wave multiplier (later waves = more aggressive)
            if (st && st.wave >= 5) wakeDist *= 1.15;

            // ===== SLEEPING LOGIC =====
            if (e.sleeping) {
              // Multiple wake conditions with priority
              const distCheck = dist < wakeDist;
              const recentAction = recent;
              const bossProximity = e.boss && dist < 700;
              const lowHpAggro = e.boss && e.hp < e.max * 0.4 && dist < 900;
              const aoeEffect = L && L.castingAOE && dist < 500; // Wake if player uses AOE nearby

              const shouldWake = distCheck || recentAction || bossProximity || lowHpAggro || aoeEffect;

              if (shouldWake) {
                // === SMOOTH WAKE SEQUENCE ===
                e.sleeping = false;
                e.wakeAnimProgress = 0;
                e.justWoke = true;
                e.wakeTime = t;

                // Velocity restoration with ramp-up
                if (e._vx0 !== undefined) {
                  const initialSpeed = e.boss ? 0.5 : 0.3; // Bosses wake faster
                  e.vx = e._vx0 * initialSpeed;

                  // Gradual speed increase
                  const rampDuration = e.boss ? 200 : 300;
                  const rampSteps = 5;
                  for (let i = 1; i <= rampSteps; i++) {
                    setTimeout(() => {
                      if (e && !e.sleeping && !e.dead) {
                        e.vx = e._vx0 * (initialSpeed + (1 - initialSpeed) * (i / rampSteps));
                      }
                    }, (rampDuration / rampSteps) * i);
                  }
                }

                // === VISUAL WAKE EFFECTS ===
                if (typeof window.VFX !== 'undefined') {
                  // Dust particles
                  if (VFX.Particles) {
                    const color = e.boss ? '#ff4444' : e.elite ? '#ff8844' : '#ffd56a';
                    const count = e.boss ? 15 : e.elite ? 12 : 8;
                    VFX.Particles.emit('dust', ex, ey, { count, color });

                    // Extra sparkle for bosses/elites
                    if (e.boss || e.elite) {
                      VFX.Particles.emit('sparkle', ex, ey, { count: 8, color: '#ffffff' });
                    }
                  }

                  // Warning glow for bosses
                  if ((e.boss || e.elite) && VFX.Lighting) {
                    VFX.Lighting.aura(ex, ey, e.boss ? 100 : 80, e.boss ? '#ff0000' : '#ff6600', 800);
                  }
                }

                // Alert sound (if available)
                if ((e.boss || e.elite) && typeof window.playSound === 'function') {
                  window.playSound('enemyWake');
                }
              } else {
                // === KEEP SLEEPING ===
                e.vx = 0;
                e.vy = Math.min(e.vy || 0, 2); // Allow gravity but cap fall speed

                // Breathing animation for sleeping enemies
                if (!e._sleepPhase) e._sleepPhase = Math.random() * Math.PI * 2;
                e._sleepPhase += 0.02;
                e.sleepBob = Math.sin(e._sleepPhase) * 2; // 2px vertical bob
              }
            } else {
              // === AWAKE STATE ===

              // Wake animation progress
              if (e.wakeAnimProgress !== undefined && e.wakeAnimProgress < 1) {
                e.wakeAnimProgress = Math.min(1, e.wakeAnimProgress + 0.04);
              }

              // Clear just-woke flag after 1 second
              if (e.justWoke && (t - e.wakeTime) > 1000) {
                e.justWoke = false;
              }

              // === SHOOTING COOLDOWN LOGIC ===
              if (e._noShootUntil && t < e._noShootUntil) {
                e.canShoot = false;
              } else {
                e.canShoot = true;
              }

              // === RE-SLEEP CONDITIONS ===
              // Regular enemies can go back to sleep, bosses/elites stay awake
              if (!e.boss && !e.elite) {
                const farEnough = dist > wakeDist * 1.6;
                const noRecentAction = !recent && (t - lastActionAt) > 4000;
                const notInCombat = !e.hitRecently || (t - (e.lastHitTime || 0)) > 3000;

                if (farEnough && noRecentAction && notInCombat) {
                  e.sleeping = true;
                  e._vx0 = e.vx;
                  e.vx = 0;
                  e._sleepPhase = Math.random() * Math.PI * 2;

                  // Gentle sleep visual
                  if (typeof window.VFX !== 'undefined' && VFX.Particles) {
                    VFX.Particles.emit('dust', ex, ey, { count: 4, color: '#888888' });
                  }
                }
              }
            }

            // ===== BOSS SPECIAL BEHAVIORS =====
            if ((e.boss || e.elite) && !e.sleeping) {
              const hpPercent = e.hp / (e.max || 1);

              // Low HP: Enraged state
              if (hpPercent < 0.3) {
                e.enraged = true;
                e.aggroRange = 1000;
                e.moveSpeed = (e.baseSpeed || 1) * 1.3;
                e.attackSpeed = (e.baseAttackSpeed || 1) * 1.2;

                // Periodic rage visual
                if (!e._rageEffectTime || (t - e._rageEffectTime) > 2000) {
                  e._rageEffectTime = t;
                  if (typeof window.VFX !== 'undefined' && VFX.Particles) {
                    VFX.Particles.emit('fire', ex, ey, { count: 12, color: '#ff0000' });
                  }
                }
              }
              // Medium HP: Alert state  
              else if (hpPercent < 0.6) {
                e.aggroRange = 700;
                e.moveSpeed = (e.baseSpeed || 1) * 1.15;
              }
              // Full HP: Normal state
              else {
                e.aggroRange = 500;
                e.moveSpeed = e.baseSpeed || 1;
              }

              // Special: Teleport when very far (prevent getting stuck)
              if (dist > 1500 && L) {
                const teleportChance = 0.001; // 0.1% per frame
                if (Math.random() < teleportChance) {
                  e.x = lx + (Math.random() > 0.5 ? 400 : -400);
                  e.y = ly - 100;

                  // Teleport effect
                  if (typeof window.VFX !== 'undefined' && VFX.Particles) {
                    VFX.Particles.emit('sparkle', ex, ey, { count: 20, color: '#8844ff' });
                    VFX.Particles.emit('sparkle', e.x, e.y, { count: 20, color: '#8844ff' });
                  }
                }
              }
            }
          }
        } catch (err) {
          console.error('[Watchdog] AI tick error:', err);
        } finally {
          requestAnimationFrame(aiTick);
        }
      }

      // Start the AI tick loop
      requestAnimationFrame(aiTick);

      // Expose comprehensive debug API
      window.WatchdogDebug = {
        pulse,
        getBossSpawnZones: () => BOSS_SPAWN_ZONES,
        getBossCountWave: () => bossesSpawnedThisWave,
        getBossCountStage: () => bossesSpawnedThisStage,
        getLastAction: () => (now() - lastActionAt),
        getLastBossZone: () => lastBossSpawnZone,
        getZoneCooldowns: () => Array.from(zoneCooldowns.entries()),
        getStageMultiplier,
        getWaveMultiplier,
        getEnemySleepStats: () => {
          const arr = st.enemies || [];
          const sleeping = arr.filter(e => e && e.sleeping).length;
          const awake = arr.filter(e => e && !e.sleeping && !e.dead).length;
          const bosses = arr.filter(e => e && (e.boss || e.elite) && !e.dead).length;
          return { total: arr.length, sleeping, awake, bosses };
        },
        forceSpawnAtZone: (zoneName) => {
          const zone = BOSS_SPAWN_ZONES.find(z => z.name === zoneName);
          if (!zone) {
            console.error('Zone not found:', zoneName);
            return false;
          }
          zoneCooldowns.delete(zone.name);
          bossesSpawnedThisWave = 0;
          console.log('Forcing spawn at', zoneName);
          return true;
        },
        resetAllCooldowns: () => {
          zoneCooldowns.clear();
          bossesSpawnedThisWave = 0;
          bossesSpawnedThisStage = 0;
          console.log('All cooldowns reset');
        }
      };

      console.log('[Watchdog] ✅ Enhanced AI System Initialized');
      console.log('  - Random Boss Spawner with 6 zones');
      console.log('  - Flawless Sleep/Wake system');
      console.log('  - Progressive difficulty scaling');
      console.log('  - Boss enrage mechanics');
      console.log('  - Use window.WatchdogDebug for controls');
    })();
  </script>

  <script>
    /* Platform draw camera wrapper */
    (function () {
      if (window.Platform && typeof Platform.draw === 'function' && !Platform._origDraw) {
        Platform._origDraw = Platform.draw;
        Platform.draw = function (ctx) {
          ctx.save();
          try { ctx.translate(-(st?.camX || 0), -(st?.camY || 0)); } catch (e) { /* ignore */ }
          try { Platform._origDraw.call(Platform, ctx); } finally { ctx.restore(); }
        };
      }
    })();
  </script>


  <!-- Removed obsolete ButtonControllerJS script; control wiring is handled by new-button-wiring -->


  <!-- Bridge new combat buttons to existing game logic. Each new button calls the underlying
       game functions directly rather than clicking the hidden legacy buttons. The Attack button
       supports both single‑tap and hold‑to‑fire behaviour. -->
  <script id="new-button-wiring">
    document.addEventListener('DOMContentLoaded', () => {
      // --- Attack button: single tap triggers one basic attack; holding triggers repeated attacks
      {
        const atk = document.getElementById('hudBtnAttack');
        if (atk) {
          // Helper to perform a single basic attack on the current leader
          const doAttack = () => {
            try {
              if (typeof basicAttackAction === 'function' && typeof leader === 'function') {
                const L = leader();
                if (L && !L.isDefeated) basicAttackAction(L);
              }
            } catch (_e) { /* ignore */ }
          };
          // On pointer down start firing repeatedly
          atk.addEventListener('pointerdown', () => {
            if (window.HouseInterior?.active && !window.MissyArcadeGame?.active) { try { window.HouseInterior.strikeIndoorEnemy(); window.HouseInterior.castIndoorSkillVfx?.('ATTACK'); } catch (_) { } return; }
            doAttack();
            // Start an interval to repeatedly attack while held
            window.__attackInterval && clearInterval(window.__attackInterval);
            window.__attackInterval = setInterval(doAttack, 260);
          });
          // Stop firing when pointer lifted or leaves the button
          const stop = () => {
            if (window.__attackInterval) {
              clearInterval(window.__attackInterval);
              window.__attackInterval = null;
            }
          };
          atk.addEventListener('pointerup', stop);
          atk.addEventListener('pointerleave', stop);
          atk.addEventListener('pointercancel', stop);
          // On click (tap) perform a single attack without starting the interval (covers non-touch devices)
          atk.addEventListener('click', (e) => {
            // Prevent the click from also firing immediately after pointerdown
            if (!window.__attackInterval) {
              if (window.HouseInterior?.active && !window.MissyArcadeGame?.active) { try { window.HouseInterior.strikeIndoorEnemy(); window.HouseInterior.castIndoorSkillVfx?.('ATTACK'); } catch (_) { } return; }
              doAttack();
            }
          });
        }
      }
      // --- Jump button: perform a jump for all characters
      {
        const jmp = document.getElementById('hudBtnJump');
        if (jmp) {
          jmp.addEventListener('click', () => {
            try {
              if (typeof jumpAll === 'function') jumpAll();
            } catch (_e) { /* ignore */ }
          });
        }
      }
      // --- Rage button: trigger rage for the current leader (no fallback needed)
      {
        const rage = document.getElementById('hudBtnRage');
        if (rage) {
          rage.addEventListener('click', () => {
            try {
              if (typeof triggerRageFor === 'function' && typeof leader === 'function') {
                const L = leader();
                if (L && !L.isDefeated) triggerRageFor(L);
              }
            } catch (_e) { /* ignore */ }
          });
        }
      }
      // --- Shield button: enable shield directly on the global game state
      {
        const shieldBtn = document.getElementById('hudBtnShield');
        if (shieldBtn) {
          shieldBtn.addEventListener('click', () => {
            try {
              if (typeof st !== 'undefined') {
                st.shieldOn = true;
                st.shieldT = 3000; // 3 seconds duration
              }
            } catch (_e) { /* ignore */ }
          });
        }
      }
      // --- Skill buttons S1–S3: cast the linked skill on the current leader
      {
        const castSkill = (slot) => {
          try {
            if (typeof cast === 'function' && typeof leader === 'function') {
              const L = leader();
              if (L && !L.isDefeated) cast(L, slot);
            }
          } catch (_e) { /* ignore */ }
        };
        const s1 = document.getElementById('hudBtnS1');
        if (s1) s1.addEventListener('click', () => { if (window.HouseInterior?.active && !window.MissyArcadeGame?.active) { try { window.HouseInterior.strikeIndoorEnemy(); window.HouseInterior.castIndoorSkillVfx?.('S1'); } catch (_) { } return; } castSkill('S1'); });
        const s2 = document.getElementById('hudBtnS2');
        if (s2) s2.addEventListener('click', () => { if (window.HouseInterior?.active && !window.MissyArcadeGame?.active) { try { window.HouseInterior.strikeIndoorEnemy(); window.HouseInterior.castIndoorSkillVfx?.('S2'); } catch (_) { } return; } castSkill('S2'); });
        const s3 = document.getElementById('hudBtnS3');
        if (s3) s3.addEventListener('click', () => { if (window.HouseInterior?.active && !window.MissyArcadeGame?.active) { try { window.HouseInterior.strikeIndoorEnemy(); window.HouseInterior.castIndoorSkillVfx?.('S3'); } catch (_) { } return; } castSkill('S3'); });
      }
      // OLD SCROLL BUTTON HANDLERS REMOVED - Buttons don't exist anymore
    });
  </script>

  <script>
    (function () {
      const MIN_ACTION_COOLDOWN = 250;

      function computeCooldown(momentum) {
        return Math.max(MIN_ACTION_COOLDOWN, 3000 - (momentum * 90));
      }

      function safeNotify(message, color) {
        try {
          if (typeof notify === 'function') {
            notify(message, color);
          } else {
            console.log(message);
          }
        } catch (err) {
          console.warn('InventoryAI notify fallback:', err);
        }
      }

      function bagHasOpenables() {
        if (!Array.isArray(window.st?.inv)) return false;
        const openableTypes = ['gold_bag', 'big_gold_bag', 'pet_box', 'vehicle_box', 'super_equipment_pack', 'big_box', 'gear_kit', 'treasure_box', 'boss_skip_pass', 'box', 'gift', 'bag', 's_box'];
        return st.inv.some(it => it && openableTypes.includes(it.type));
      }

      const InventoryAI = {
        active: false,
        startTime: 0,
        momentum: 0,
        actionCooldown: 3000,
        lastActionTime: 0,
        actionIndex: 0,
        actions: ['open', 'equip', 'fuse', 'upgrade', 'alchemy'],

        refreshButtons() {
          const active = this.active;
          document.querySelectorAll('[data-auto-ai-toggle]').forEach(btn => {
            btn.textContent = `Auto AI: ${active ? 'ON' : 'OFF'}`;
            btn.style.backgroundColor = active ? '#36c777' : '#ff6aa8';
            btn.setAttribute('aria-pressed', active ? 'true' : 'false');
          });
        },

        toggle() {
          this.active = !this.active;
          if (this.active) {
            this.startTime = performance.now();
            this.momentum = 0;
            this.actionCooldown = 3000;
            this.lastActionTime = 0;
            this.actionIndex = 0;
            try { (window.autoOpenAll || autoOpenAll)(); } catch (_) { }
            try { autoEquipBestGear(true); } catch (_) { }
            try { autoUpgradeItems(true); } catch (_) { }
            try { autoEquipBestGear(true); } catch (_) { }
          } else {
            this.startTime = 0;
            this.momentum = 0;
            this.actionCooldown = 3000;
            this.lastActionTime = 0;
          }
          this.refreshButtons();
          safeNotify(`Bag Companion AI is now ${this.active ? 'active' : 'inactive'}.`, this.active ? '#36c777' : '#ff6aa8');
        },

        increaseMomentum(amount = 1) {
          this.momentum += amount;
          this.actionCooldown = computeCooldown(this.momentum);
          safeNotify(`Bag AI momentum ${this.momentum.toFixed(0)} (speed ${this.actionCooldown.toFixed(0)}ms).`, '#6aa8ff');
        },

        update(currentTime) {
          if (!this.active) return;
          if (typeof currentTime !== 'number') currentTime = performance.now();
          if (this.startTime && currentTime - this.startTime > 120000) {
            this.instantUpgradeAll();
            this.toggle();
            return;
          }
          if (currentTime - this.lastActionTime < this.actionCooldown) return;
          const performed = this.performNextAction();
          this.lastActionTime = currentTime;
          if (!performed && this.momentum > 0) {
            this.momentum = Math.max(0, this.momentum - 0.5);
            this.actionCooldown = computeCooldown(this.momentum);
          }
        },

        performNextAction() {
          const action = this.actions[this.actionIndex];
          let acted = false;

          switch (action) {
            case 'open':
              if (typeof autoOpenAll === 'function' && bagHasOpenables()) {
                acted = !!autoOpenAll();
                if (acted) this.increaseMomentum(5);
              }
              break;
            case 'equip':
              if (typeof autoEquipBestGear === 'function') {
                acted = !!autoEquipBestGear(true);
                if (acted) this.increaseMomentum(2);
              }
              break;
            case 'fuse':
              if (typeof autoFuseItems === 'function') {
                acted = !!autoFuseItems(false);
                if (acted) this.increaseMomentum(3);
              }
              break;
            case 'upgrade':
              acted = this.upgradeSingleItem();
              if (acted) this.increaseMomentum(1);
              break;
            case 'alchemy':
              acted = this.performSimpleAlchemy();
              if (acted) this.increaseMomentum(2);
              break;
            default:
              break;
          }

          this.actionIndex = (this.actionIndex + 1) % this.actions.length;
          return acted;
        },

        upgradeSingleItem() {
          if (!Array.isArray(window.st?.inv)) return false;
          const candidates = st.inv.filter(it => it && it.type === 'gear' && (it.level || 0) < 10);
          if (!candidates.length) return false;
          const rankOrder = ['C', 'B', 'A', 'S', 'SS', 'SSS', 'SSSS', 'SSSSS'];
          const score = (item) => {
            const rankIdx = Math.max(0, rankOrder.indexOf(item.rank || 'C'));
            return rankIdx * 2000 + (item.level || 0) * 60 + (item.atk || 0) * 2 + (item.def || 0);
          };
          candidates.sort((a, b) => score(b) - score(a));
          const target = candidates[0];
          const costFn = (typeof calcUpgradeCost === 'function') ? calcUpgradeCost : (it) => 100 * ((it.level || 0) + 1);
          const cost = costFn(target);
          if (st.gold < cost) return false;
          st.gold -= cost;
          target.level = (target.level || 0) + 1;
          if (target.atk) target.atk = Math.round(target.atk * 1.08 + 1);
          if (target.def) target.def = Math.round(target.def * 1.08 + 1);
          safeNotify(`${target.name} upgraded to Lv${target.level}.`, '#6aa8ff');
          if (typeof updateCurrencies === 'function') updateCurrencies();
          if (typeof recalcStats === 'function') recalcStats();
          if (st.bagOpen && typeof renderBag === 'function') renderBag();
          return true;
        },

        performSimpleAlchemy() {
          if (!Array.isArray(window.st?.inv)) return false;
          const groups = new Map();
          for (const item of st.inv) {
            if (!item || item.type !== 'gear') continue;
            const key = `${item.slot || 'gear'}_${item.rank || 'C'}`;
            if (!groups.has(key)) groups.set(key, []);
            groups.get(key).push(item);
          }
          for (const group of groups.values()) {
            if (group.length >= 3) {
              const trio = group.splice(0, 3);
              trio.forEach(piece => {
                const idx = st.inv.findIndex(it => it && it.id === piece.id);
                if (idx >= 0) st.inv.splice(idx, 1);
              });
              const result = (typeof performFusion === 'function') ? performFusion(trio) : null;
              if (result) {
                addItemToBag(result);
                safeNotify('Bag AI fused a new relic!', '#6aa8ff');
              }
              if (st.bagOpen && typeof renderBag === 'function') renderBag();
              return true;
            }
          }
          return false;
        },

        instantUpgradeAll() {
          safeNotify('AI HYPER MODE! Performing bulk upgrades!', '#ffaa00');
          if (typeof autoUpgradeItems === 'function') autoUpgradeItems(true);
        }
      };

      window.InventoryAI = InventoryAI;

      document.addEventListener('DOMContentLoaded', () => {
        const autoButtons = document.querySelectorAll('[data-auto-ai-toggle]');
        autoButtons.forEach(btn => {
          btn.addEventListener('click', () => InventoryAI.toggle());
        });
        if (autoButtons.length) {
          InventoryAI.refreshButtons();
        }
      });

      const previousUpdate = window.update;
      window.update = function (dt) {
        if (typeof previousUpdate === 'function') previousUpdate(dt);
        try { if (window.HouseInterior?.active && typeof window.HouseInterior.step === 'function') window.HouseInterior.step(dt || 0.016); } catch (e) { }
        try {
          InventoryAI.update(performance.now());
        } catch (err) {
          console.error('InventoryAI update error', err);
        }
      };
    })();
  </script>

  <!-- Final override to hide any remaining old action buttons or duplicates.  Placed at the end of the body to ensure highest specificity. -->
  <script id="cast-bridge">
    // Global dispatcher so pixel HUD and keyboard can call into the unified skill wrapper
    function cast(L, slot) {
      try {
        if (!L && typeof leader === 'function') L = leader();
        if (!L || L.isDefeated) return;
        if (!/^S[1-5]$/.test(String(slot))) return;
        useSkillWrapper(L, String(slot));
      } catch (_e) { /* ignore */ }
    }
  </script>
  <style id="final-hide-old-buttons">
    /* Fully hide the legacy round buttons and their wrappers to prevent duplicate controls */
    .action-buttons-wrapper,
    .action-buttons-wrapper .actions,
    .action-buttons-wrapper .actions-secondary,
    #btnShoot,
    #btnJump,
    #btnRage,
    #btnShield,
    #btnS1,
    #btnS2,
    #btnS3,
    #btnS4,
    #btnS5,
    #btnSecret,
    #btnAttack,
    /* Hide any legacy round attack button that uses the big style */
    .action-buttons-wrapper .btn-round.big,
    .btn-round.big#btnShoot,
    .btn-round.big#btnAttack {
      display: none !important;
    }

    /* Hide the tiny X button that appears next to the rage button; the scroll button toggles the
       scroll overlay and the ESC key also closes it, so this extra close control is redundant. */
    /* Legacy scroll button styles removed */
  </style>

  <script>
    (function () {
      // Quick helper to pick a number in [a,b]
      function rr(a, b) { return a + Math.floor(Math.random() * (b - a + 1)); }

      // Add a few platforms into the current scene, without touching your button UI
      function addPlatformsForScene(sceneIndex, count) {
        // Use your platform module if present; otherwise no-op
        window.Platform = window.Platform || {};
        Platform.layers = Platform.layers || { solids: [], ladders: [], springs: [] };

        const solids = Platform.layers.solids;
        const WW = (window.WORLD_WIDTH || 4096);
        const sceneStart = sceneIndex * WW;

        for (let i = 0; i < count; i++) {
          const w = rr(140, 240);
          const x = sceneStart + rr(160, WW - 160 - w);  // keep inside bounds
          const y = rr(320, 520);                        // mid/high tiers; adjust if your ground differs
          solids.push({
            x, y, w, h: 14, hp: 80, type: 'platform'
          });
        }
      }

      // Add a few at boot
      addEventListener('load', function () {
        try { addPlatformsForScene((window.currentScene || 0), rr(2, 4)); } catch (e) { }
      });

      // After each scene transition, sprinkle 2–3 more
      const _transitionToScene = window.transitionToScene;
      if (typeof _transitionToScene === 'function') {
        window.transitionToScene = function (newScene) {
          _transitionToScene.apply(this, arguments);
          try { addPlatformsForScene(newScene, rr(2, 3)); } catch (e) { }
        };
      }
    })();
  </script>
  <script>
    (function () {
      const MIN_HP = 200;
      const MAX_HP = 500;
      const MAX_ATK = 20;

      const clampEnemyStats = (enemy) => {
        if (!enemy || enemy.isBoss) return;
        if (enemy.hp != null) enemy.hp = Math.max(MIN_HP, Math.min(MAX_HP, enemy.hp));
        if (enemy.max != null) enemy.max = Math.max(MIN_HP, Math.min(MAX_HP, enemy.max));
        if (enemy.hpMax != null) enemy.hpMax = Math.max(MIN_HP, Math.min(MAX_HP, enemy.hpMax));
        if (enemy.dmg != null) enemy.dmg = Math.max(1, Math.min(MAX_ATK, enemy.dmg));
      };

      const clampWave = (previousLength) => {
        const st = window.Game?.state;
        if (!st) return;
        const waveRaw = st.wave;
        const waveNumber = typeof waveRaw === 'number' ? waveRaw : parseInt(waveRaw, 10) || 0;
        if (waveNumber <= 0 || waveNumber > 8) return;
        const enemies = Array.isArray(st.enemies) ? st.enemies : [];
        const startIndex = Number.isInteger(previousLength) ? previousLength : 0;
        for (let i = startIndex; i < enemies.length; i++) clampEnemyStats(enemies[i]);
      };

      const patchGameSpawner = () => {
        if (!window.Game || window.Game.__earlyWaveClampPatched) return !!window.Game;
        const target = window.Game;
        let patched = false;

        const wrapSpawner = (fn) => {
          if (typeof fn !== 'function') return null;
          return function wrappedSpawner() {
            const before = target?.state?.enemies?.length ?? 0;
            const result = fn.apply(this, arguments);
            clampWave(before);
            return result;
          };
        };

        const originalCreate = typeof target._createEnemies === 'function' ? target._createEnemies.bind(target) : null;
        if (originalCreate) {
          target._createEnemies = wrapSpawner(originalCreate);
          patched = true;
        }

        const originalSpawn = typeof target.spawnWave === 'function' ? target.spawnWave.bind(target) : null;
        if (originalSpawn) {
          target.spawnWave = function patchedSpawnWave() {
            const before = target?.state?.enemies?.length ?? 0;
            const result = originalSpawn.apply(this, arguments);
            clampWave(before);
            return result;
          };
          patched = true;
        }

        if (typeof window.spawnWave === 'function') {
          const originalGlobal = window.spawnWave;
          window.spawnWave = function wrappedGlobalSpawn() {
            const before = target?.state?.enemies?.length ?? 0;
            const result = originalGlobal.apply(this, arguments);
            clampWave(before);
            return result;
          };
          patched = true;
        }

        if (!patched) return false;

        target.__earlyWaveClampPatched = true;
        return true;
      };

      const patchEnemyAbilities = () => {
        const mgr = window.enemyAbilities;
        if (!mgr || typeof mgr.autoUseAbilities !== 'function' || mgr.__waveAbilityPatch) {
          return !!mgr;
        }

        const originalAuto = mgr.autoUseAbilities.bind(mgr);
        mgr.autoUseAbilities = function patchedAutoUse(enemy, gameState, dt) {
          const stage = gameState?.stage || 1;
          const waveRaw = gameState?.wave;
          const waveNumber = typeof waveRaw === 'number' ? waveRaw : parseInt(waveRaw, 10) || 0;
          const advancedUnlocked = waveNumber > 8;

          if (typeof this.updateAvailableAbilities === 'function') {
            if (this._lastStageUpdate !== stage || this._advancedUnlocked !== advancedUnlocked) {
              this.updateAvailableAbilities(stage);
              this._lastStageUpdate = stage;
              this._advancedUnlocked = advancedUnlocked;
            }
          }

          if (!advancedUnlocked && this.activeAbilities && typeof this.activeAbilities.delete === 'function') {
            this.activeAbilities.delete('teleport');
            this.activeAbilities.delete('heal');
          }

          return originalAuto(enemy, gameState, dt);
        };

        if (typeof mgr.reset === 'function') {
          const originalReset = mgr.reset.bind(mgr);
          mgr.reset = function patchedReset() {
            originalReset();
            this._lastStageUpdate = undefined;
            this._advancedUnlocked = undefined;
          };
        }

        mgr.__waveAbilityPatch = true;
        return true;
      };

      const tryApplyPatches = () => {
        const gameReady = patchGameSpawner();
        const abilitiesReady = patchEnemyAbilities();
        if (gameReady && abilitiesReady) clearInterval(timer);
      };

      const timer = setInterval(tryApplyPatches, 100);
      tryApplyPatches();
    })();
  </script>

  <!-- OLD PURE SLOT SYSTEM REMOVED - Now using simple_skills.js directly -->

  <script>
    (() => {
      const canvas = document.getElementById('mini');
      if (!canvas) return;

      const ctx = canvas.getContext('2d');
      const W = canvas.width;
      const H = canvas.height;
      const RAD = 900; // world radius displayed
      const FADE_SWEEP = 'rgba(159,215,255,0.08)';
      let showMap = true;

      const mapButton = document.getElementById('btnMap');
      if (window.st && typeof window.st._showMini === 'boolean') {
        showMap = window.st._showMini;
        canvas.style.display = showMap ? 'block' : 'none';
        if (mapButton) {
          mapButton.textContent = showMap ? 'Hide Map' : 'Show Map';
        }
      }

      if (mapButton) {
        mapButton.addEventListener('click', () => {
          showMap = !showMap;
          if (window.st) {
            window.st._showMini = showMap;
          }
          canvas.style.display = showMap ? 'block' : 'none';
          mapButton.textContent = showMap ? 'Hide Map' : 'Show Map';
        });
      }

      const dot = (x, y, r, fill, stroke) => {
        ctx.beginPath();
        ctx.arc(x, y, r, 0, Math.PI * 2);
        if (stroke) {
          ctx.strokeStyle = stroke;
          ctx.stroke();
        }
        ctx.fillStyle = fill;
        ctx.fill();
      };

      const project = (x, y, leader) => {
        if (!leader) {
          return { x: W / 2, y: H / 2 };
        }
        return {
          x: W / 2 + ((x - leader.x) / RAD) * (W / 2),
          y: H / 2 + ((y - leader.y) / RAD) * (H / 2)
        };
      };

      const loop = () => {
        const st = window.st;
        if (!st) {
          requestAnimationFrame(loop);
          return;
        }
        if (typeof st._showMini === 'boolean' && st._showMini !== showMap) {
          showMap = st._showMini;
          canvas.style.display = showMap ? 'block' : 'none';
          if (mapButton) {
            mapButton.textContent = showMap ? 'Hide Map' : 'Show Map';
          }
        } else if (typeof st._showMini !== 'boolean') {
          st._showMini = showMap;
        }

        const leader = (st.players && st.players[st.leader || 0]) || st.player || null;

        if (showMap) {
          ctx.clearRect(0, 0, W, H);
          ctx.strokeStyle = '#28324b';
          ctx.lineWidth = 1;
          ctx.strokeRect(0.5, 0.5, W - 1, H - 1);

          // player
          dot(W / 2, H / 2, 3, '#9fd7ff', '#0a0b12');

          // houses/buildings from platform layer
          const houses = (window.Platform?.layers?.houses) || [];
          houses.forEach((house) => {
            if (typeof house?.x !== 'number' || typeof house?.y !== 'number') return;
            const p = project(house.x, house.y, leader);
            ctx.fillStyle = '#ffd56a';
            ctx.fillRect(p.x - 2, p.y - 2, 4, 4);
          });

          // doors/shops/arcade/pet-shop pickups
          const pickups = st.pickups || [];
          pickups.forEach((pk) => {
            if (!pk) return;
            if (!['door', 'shop', 'arcade', 'pet_shop'].includes(pk.kind)) return;
            const p = project(pk.x || 0, pk.y || 0, leader);
            const color = pk.kind === 'shop' ? '#b5ff7a' : pk.kind === 'arcade' ? '#9fd7ff' : '#ffd56a';
            dot(p.x, p.y, 2, color);
          });

          // enemies - tint for boss / elite
          const enemies = st.enemies || [];
          enemies.forEach((enemy) => {
            if (!enemy || enemy.hp <= 0) return;
            const p = project(enemy.x || 0, enemy.y || 0, leader);
            const fill = enemy.boss ? '#a29fff' : enemy.elite ? '#ffd56a' : '#ff7b6e';
            dot(p.x, p.y, 2, fill);
          });

          // vehicles (unowned) and unopened chests
          const vehicles = st.vehicles || [];
          vehicles.forEach((veh) => {
            if (!veh || veh.owner) return;
            const p = project(veh.x || 0, veh.y || 0, leader);
            dot(p.x, p.y, 2, '#a0a0a0');
          });

          const chests = window.Platform?.chests || [];
          chests.forEach((chest) => {
            if (!chest || chest.opened) return;
            const p = project((chest.x || 0) + (chest.w ? chest.w / 2 : 0), chest.y || 0, leader);
            dot(p.x, p.y, 2, '#8B4513', '#D2691E');
          });

          // radar sweep
          const t = typeof st.clock === 'number' ? st.clock : performance.now() * 0.001;
          const sweepAngle = (t * 1.1) % (Math.PI * 2);
          ctx.beginPath();
          ctx.moveTo(W / 2, H / 2);
          ctx.arc(W / 2, H / 2, W / 2 - 2, sweepAngle - 0.14, sweepAngle + 0.14);
          ctx.closePath();
          ctx.fillStyle = FADE_SWEEP;
          ctx.fill();

          // world event pings
          const events = st.worldEvents || [];
          events.forEach((ev) => {
            if (!ev) return;
            const p = project(ev.x || 0, ev.y || 0, leader);
            dot(p.x, p.y, 3, '#9fd7ff');
          });
        }

        requestAnimationFrame(loop);
      };

      loop();
    })();
  </script>

  <!-- A1K UI: Team Management Overlay -->
  <div id="teamMenu" class="a1k-ui hud-panel hidden" aria-hidden="true" role="dialog">
    <div class="panel-title">Team Management</div>
    <div class="panel-body">
      <button class="ui-line" id="btnTeamSwap">Swap Members</button>
      <button class="ui-line" id="btnTeamTrade">Trade / Share Inventory</button>
      <button class="ui-line" id="btnTeamRoster">NPC / Friends / Robots</button>
      <button class="ui-line" id="btnTeamClone">Clone Stance <span class="clone-label"
          id="teamCloneLabel">(ASSAULT)</span></button>
    </div>
    <div class="panel-footer">
      <button id="btnTeamClose">Close</button>
    </div>
  </div>

  <script>
    (function () {
      const $ = (selector, scope) => (scope || document).querySelector(selector);
      const $$ = (selector, scope) => Array.from((scope || document).querySelectorAll(selector));
      const CLONE_STANCES = ['assault', 'guard', 'support'];
      const STANCE_LABELS = { assault: 'Assault', guard: 'Guard', support: 'Support' };
      let teamCloneLabelEl = null;
      let lastCloneStance = null;
      let swapModal = null;
      let swapListEl = null;
      let swapNoticeEl = null;
      let rosterModal = null;
      let rosterListEl = null;
      let rosterDetailEl = null;
      let tradeOverlay = null;
      let tradeHandler = null;

      const normalizeCloneStance = (value) => {
        if (!value) return 'assault';
        const stance = String(value).toLowerCase();
        return CLONE_STANCES.includes(stance) ? stance : 'assault';
      };

      const getCloneStanceState = () => normalizeCloneStance(window.st && window.st._cloneStance);

      const applyCloneStanceState = (stance) => {
        const target = normalizeCloneStance(stance);
        if (typeof window.switchCloneStance === 'function') {
          window.switchCloneStance(target);
        } else if (typeof window.cloneStance === 'function') {
          window.cloneStance(target);
        } else if (window.st) {
          window.st._cloneStance = target;
        }
        return target;
      };

      const updateCloneStanceLabel = (stanceValue) => {
        const label = teamCloneLabelEl || document.getElementById('teamCloneLabel');
        if (!label) return;
        if (!teamCloneLabelEl) teamCloneLabelEl = label;
        const normalized = normalizeCloneStance(stanceValue || getCloneStanceState());
        if (normalized === lastCloneStance) return;
        lastCloneStance = normalized;
        const pretty = STANCE_LABELS[normalized] || normalized;
        label.textContent = `(${pretty.toUpperCase()})`;
      };

      const cycleCloneStanceState = () => {
        const current = getCloneStanceState();
        const index = CLONE_STANCES.indexOf(current);
        const next = CLONE_STANCES[(index + 1) % CLONE_STANCES.length];
        applyCloneStanceState(next);
        updateCloneStanceLabel(next);
        return next;
      };

      function hideLegacyWidgets() {
        const domTargets = ['#comboBox', '#wpStats', '#rightStatBox'];
        domTargets.forEach((sel) => {
          const el = $(sel);
          if (el) {
            el.style.display = 'none';
          }
        });

        $$('div,section,aside,span').forEach((node) => {
          const text = (node.textContent || '').trim();
          if (/^Combo:\s*/i.test(text) || /^W:\s*\d+%\s*P:\s*\d+%/i.test(text)) {
            node.style.display = 'none';
          }
        });

        if (window.A1K_FLAGS) {
          A1K_FLAGS.SHOW_COMBO = false;
          A1K_FLAGS.SHOW_WP = false;
          A1K_FLAGS.SHOW_RIGHT_STATS = false;
        }
      }

      function mountTeamMenu() {
        const btnTeam = $('#btnTeam');
        const panel = $('#teamMenu');
        const close = $('#btnTeamClose');
        teamCloneLabelEl = $('#teamCloneLabel');
        updateCloneStanceLabel();
        if (!btnTeam || !panel) return;

        const toggle = () => {
          panel.classList.toggle('hidden');
          const hidden = panel.classList.contains('hidden');
          panel.setAttribute('aria-hidden', hidden ? 'true' : 'false');
        };

        btnTeam.addEventListener('click', toggle);
        if (close) {
          close.addEventListener('click', toggle);
        }

        document.addEventListener('keydown', (event) => {
          if (event.key === 'Escape' && !panel.classList.contains('hidden')) {
            toggle();
          }
        });

        document.addEventListener('keydown', (event) => {
          const key = (event.key || '').toLowerCase();
          if (key === 't') {
            btnTeam.click();
          }
        });

        $('#btnTeamSwap')?.addEventListener('click', () => A1KTeam.swapUI());
        $('#btnTeamTrade')?.addEventListener('click', () => A1KTeam.tradeUI());
        $('#btnTeamRoster')?.addEventListener('click', () => A1KTeam.rosterUI());
        $('#btnTeamClone')?.addEventListener('click', () => A1KTeam.cloneStance());
      }

      function removeOldCloneButton() {
        const dockCloneBtn = document.getElementById('cloneStanceBtn');
        if (dockCloneBtn && dockCloneBtn.parentElement) dockCloneBtn.remove();
        const scopes = ['#combatDock', '.rightDock', '.action-buttons-wrapper'];
        for (const scope of scopes) {
          const root = $(scope);
          if (!root) continue;
          const candidates = $$('button, .btn, div', root);
          for (const el of candidates) {
            const text = (el.innerText || '').trim().toLowerCase();
            if (['clone', 'clone stance', 'stance: clone'].includes(text)) {
              el.remove();
              return;
            }
          }
        }
      }

      function ensureFormation() {
        const st = window.st || (window.st = {});
        const players = st.players || [];
        if (!Array.isArray(window.A1KTeam?.formation) || window.A1KTeam.formation.length !== players.length) {
          window.A1KTeam = window.A1KTeam || {};
          window.A1KTeam.formation = players.map(p => p?.id || String(p?.name || ''));
        }
      }

      function ensureSwapModal() {
        if (swapModal) return swapModal;
        swapModal = document.createElement('div');
        swapModal.id = 'teamSwapModal';
        swapModal.style.cssText = 'position:fixed;inset:0;background:rgba(8,12,18,0.78);display:none;align-items:center;justify-content:center;z-index:5100;';
        const panel = document.createElement('div');
        panel.style.cssText = 'background:#111b1f;border:1px solid #2f4f74;border-radius:14px;width:520px;max-width:94vw;max-height:80vh;display:flex;flex-direction:column;box-shadow:0 18px 48px rgba(0,0,0,0.35);';
        const header = document.createElement('div');
        header.style.cssText = 'padding:18px 24px;background:linear-gradient(90deg,#1f2d46,#2b3c60);color:#cde7ff;font-weight:600;font-size:18px;';
        header.textContent = 'Swap Formation';
        swapNoticeEl = document.createElement('div');
        swapNoticeEl.style.cssText = 'padding:0 24px 10px;color:#9abacc;font-size:12px;';
        swapNoticeEl.textContent = 'Select two heroes to swap their formation slots.';
        swapListEl = document.createElement('div');
        swapListEl.style.cssText = 'padding:0 24px 18px;display:flex;gap:16px;flex-wrap:wrap;justify-content:center;overflow-y:auto;';
        const footer = document.createElement('div');
        footer.style.cssText = 'padding:14px 24px;display:flex;justify-content:flex-end;background:#0d1522;';
        const closeBtn = document.createElement('button');
        closeBtn.textContent = 'Close';
        closeBtn.style.cssText = 'padding:8px 18px;border:none;border-radius:8px;background:#204e87;color:#fff;font-weight:600;cursor:pointer;';
        closeBtn.addEventListener('click', () => window.A1KTeam?.closeSwapUI());
        footer.appendChild(closeBtn);
        panel.appendChild(header);
        panel.appendChild(swapNoticeEl);
        panel.appendChild(swapListEl);
        panel.appendChild(footer);
        swapModal.appendChild(panel);
        swapModal.addEventListener('click', (evt) => {
          if (evt.target === swapModal) window.A1KTeam?.closeSwapUI();
        });
        document.body.appendChild(swapModal);
        return swapModal;
      }

      function renderSwapOptions() {
        ensureSwapModal();
        ensureFormation();
        if (!swapListEl) return;
        swapListEl.innerHTML = '';
        const st = window.st || (window.st = {});
        const players = st.players || [];
        players.forEach((player, idx) => {
          const card = document.createElement('button');
          card.type = 'button';
          card.dataset.index = String(idx);
          card.style.cssText = 'width:150px;padding:14px;border-radius:10px;border:1px solid #314d72;background:#121d2c;color:#cfe8ff;display:flex;flex-direction:column;align-items:center;gap:8px;cursor:pointer;transition:box-shadow 0.25s,border-color 0.25s;';
          if ((st.leader || 0) === idx) card.style.borderColor = '#6aa8ff';
          const portrait = document.createElement('div');
          portrait.style.cssText = 'width:64px;height:64px;border-radius:10px;background:linear-gradient(135deg,#2d3f5a,#3a5780);display:flex;align-items:center;justify-content:center;font-weight:600;font-size:18px;color:#cde7ff;';
          portrait.textContent = (player?.id || player?.name || `H${idx + 1}`).slice(0, 2).toUpperCase();
          const nameEl = document.createElement('div');
          nameEl.textContent = player?.id || player?.name || `Member ${idx + 1}`;
          nameEl.style.cssText = 'font-weight:600;';
          const statsEl = document.createElement('div');
          statsEl.style.cssText = 'font-size:12px;color:#9abacc;text-align:center;line-height:1.3;white-space:pre-line;';
          const hpLine = `${Math.round(player?.hp || 0)}/${Math.round(player?.hpMax || player?.hp || 0)} HP`;
          const atkVal = Math.round(player?.dmg || player?.dmgBase || 0);
          const defVal = Math.round(player?.def || player?.defBase || 0);
          statsEl.textContent = `${hpLine}\nATK ${atkVal} | DEF ${defVal}`;
          card.appendChild(portrait);
          card.appendChild(nameEl);
          card.appendChild(statsEl);
          card.addEventListener('click', () => window.A1KTeam?.selectSwap(idx));
          swapListEl.appendChild(card);
        });
        highlightSwapSelection(window.A1KTeam?._swapSelection || []);
      }

      function highlightSwapSelection(selected = []) {
        if (!swapListEl) return;
        const cards = swapListEl.querySelectorAll('button');
        cards.forEach(card => {
          if (!card.dataset.index) return;
          if (selected.includes(Number(card.dataset.index))) {
            card.style.boxShadow = '0 0 0 3px #6aa8ff';
          } else {
            card.style.boxShadow = 'none';
          }
        });
      }

      function performSwap(first, second) {
        const st = window.st || (window.st = {});
        const players = st.players || [];
        if (!players[first] || !players[second]) return;
        const tmp = players[first];
        players[first] = players[second];
        players[second] = tmp;
        ensureFormation();
        const formation = window.A1KTeam.formation || [];
        if (formation[first] != null && formation[second] != null) {
          const tmpForm = formation[first];
          formation[first] = formation[second];
          formation[second] = tmpForm;
        }
        const leaderIndex = typeof st.leader === 'number' ? st.leader : 0;
        if (leaderIndex === first) st.leader = second;
        else if (leaderIndex === second) st.leader = first;
        mirrorLeaderHP?.();
        window.updateTeamStatusUI?.();
      }

      function ensureTradeOverlay() {
        if (tradeOverlay) return tradeOverlay;
        tradeOverlay = document.createElement('div');
        tradeOverlay.id = 'tradeOverlay';
        tradeOverlay.style.cssText = 'position:fixed;top:20px;right:20px;background:#111b2b;border:1px solid #345d8a;border-radius:10px;padding:16px;width:260px;color:#cfe8ff;z-index:5200;box-shadow:0 12px 32px rgba(0,0,0,0.35);';
        const title = document.createElement('div');
        title.textContent = 'Trade Mode';
        title.style.cssText = 'font-weight:600;font-size:16px;margin-bottom:6px;';
        const desc = document.createElement('div');
        desc.style.cssText = 'font-size:13px;color:#9abacc;line-height:1.4;margin-bottom:12px;';
        desc.textContent = 'Click any inventory item to share it between heroes.';
        const footer = document.createElement('div');
        footer.style.cssText = 'display:flex;justify-content:flex-end;margin-top:10px;';
        const doneBtn = document.createElement('button');
        doneBtn.textContent = 'Done';
        doneBtn.style.cssText = 'padding:6px 14px;border:none;border-radius:6px;background:#204e87;color:#fff;font-weight:600;cursor:pointer;';
        doneBtn.addEventListener('click', () => {
          if (tradeOverlay) {
            tradeOverlay.remove();
            tradeOverlay = null;
          }
          if (tradeHandler) {
            document.removeEventListener('click', tradeHandler, true);
            tradeHandler = null;
          }
        });
        footer.appendChild(doneBtn);
        tradeOverlay.appendChild(title);
        tradeOverlay.appendChild(desc);
        tradeOverlay.appendChild(footer);
        document.body.appendChild(tradeOverlay);
        return tradeOverlay;
      }

      function ensureTradeHandler() {
        if (tradeHandler) return;
        tradeHandler = (event) => {
          const el = event.target instanceof Element ? event.target.closest('.bag-item, .inventory-item, [data-item-id]') : null;
          if (!el) return;
          const original = el.style.boxShadow;
          el.style.boxShadow = '0 0 0 3px #6aa8ff';
          el.style.transition = 'box-shadow 0.25s';
          setTimeout(() => { el.style.boxShadow = original || ''; }, 320);
          if (tradeOverlay) {
            let log = tradeOverlay.querySelector('.trade-log');
            if (!log) {
              log = document.createElement('div');
              log.className = 'trade-log';
              log.style.cssText = 'margin-top:12px;font-size:12px;color:#cfe8ff;max-height:120px;overflow-y:auto;';
              tradeOverlay.insertBefore(log, tradeOverlay.lastChild);
            }
            const entry = document.createElement('div');
            entry.textContent = `Transferred ${el.getAttribute('data-name') || (el.textContent || '').trim() || 'item'}`;
            log.appendChild(entry);
            log.scrollTop = log.scrollHeight;
          }
        };
        document.addEventListener('click', tradeHandler, true);
      }

      function ensureRosterModal() {
        if (rosterModal) return rosterModal;
        rosterModal = document.createElement('div');
        rosterModal.id = 'teamRosterModal';
        rosterModal.style.cssText = 'position:fixed;inset:0;background:rgba(7,12,20,0.8);display:none;align-items:center;justify-content:center;z-index:5100;';
        const panel = document.createElement('div');
        panel.style.cssText = 'background:#101a1f;border:1px solid #2f4f74;border-radius:16px;width:620px;max-width:95vw;max-height:84vh;display:flex;flex-direction:column;box-shadow:0 18px 45px rgba(0,0,0,0.38);';
        const header = document.createElement('div');
        header.style.cssText = 'padding:20px 26px;background:linear-gradient(90deg,#1f2f4a,#2b3f64);color:#cfe8ff;font-weight:600;font-size:18px;';
        header.textContent = 'Team Roster';
        rosterListEl = document.createElement('div');
        rosterListEl.style.cssText = 'padding:18px 24px;flex:1;overflow-y:auto;display:flex;flex-direction:column;gap:18px;';
        rosterDetailEl = document.createElement('div');
        rosterDetailEl.style.cssText = 'padding:16px 18px;background:#0d1522;border-radius:12px;border:1px solid rgba(72,118,170,0.35);color:#cfe8ff;font-size:13px;min-height:80px;white-space:pre-line;';
        rosterDetailEl.textContent = 'Select a hero, pet, or vehicle to view details.';
        const footer = document.createElement('div');
        footer.style.cssText = 'padding:16px 24px;background:#0d1522;display:flex;justify-content:flex-end;';
        const closeBtn = document.createElement('button');
        closeBtn.textContent = 'Close';
        closeBtn.style.cssText = 'padding:8px 18px;border:none;border-radius:8px;background:#204e87;color:#fff;font-weight:600;cursor:pointer;';
        closeBtn.addEventListener('click', () => window.A1KTeam?.closeRosterUI());
        footer.appendChild(closeBtn);
        panel.appendChild(header);
        panel.appendChild(rosterListEl);
        panel.appendChild(rosterDetailEl);
        panel.appendChild(footer);
        rosterModal.appendChild(panel);
        rosterModal.addEventListener('click', (evt) => {
          if (evt.target === rosterModal) window.A1KTeam?.closeRosterUI();
        });
        document.body.appendChild(rosterModal);
        return rosterModal;
      }

      function formatRosterStats(entry, type) {
        if (!entry) return '';
        if (type === 'hero') {
          const hp = `${Math.round(entry.hp || 0)}/${Math.round(entry.hpMax || entry.hp || 0)} HP`;
          const atk = Math.round(entry.dmg || entry.dmgBase || 0);
          const def = Math.round(entry.def || entry.defBase || 0);
          const speed = (entry.speedBase || entry._shopBaseSpeed || 0.5).toFixed(2);
          return `${hp}\nATK ${atk} | DEF ${def}\nSpeed ${speed}`;
        }
        if (type === 'pet') {
          const hp = Math.round(entry.hp || entry.hpMax || 0);
          const dmg = Math.round(entry.dmg || 0);
          return `Level ${entry.level || 1}\nHP ${hp} | DMG ${dmg}`;
        }
        if (type === 'vehicle') {
          const armor = Math.round(entry.def || entry.armor || 0);
          const speed = Math.round(entry.speed || entry.vx || 0);
          return `Level ${entry.level || 1}\nArmor ${armor} | Speed ${speed}`;
        }
        if (type === 'companion') {
          const hp = Math.round(entry.hp || entry.hpMax || entry.max || 0);
          const dmg = Math.round(entry.dmg || entry.atk || 0);
          return `HP ${hp} | DMG ${dmg}`;
        }
        return '';
      }

      function showRosterDetails(entry, type) {
        if (!rosterDetailEl) return;
        const lines = [];
        if (type === 'hero') {
          lines.push(`Hero: ${entry.id || entry.name || 'Unknown'}`);
          lines.push(`HP: ${Math.round(entry.hp || 0)} / ${Math.round(entry.hpMax || entry.hp || 0)}`);
          lines.push(`Attack: ${Math.round(entry.dmg || entry.dmgBase || 0)}`);
          lines.push(`Defense: ${Math.round(entry.def || entry.defBase || 0)}`);
          lines.push(`Speed Base: ${(entry.speedBase || entry._shopBaseSpeed || 0.5).toFixed(2)}`);
        } else if (type === 'pet') {
          lines.push(`Pet: ${entry.name || entry.id || 'Unnamed'}`);
          lines.push(`Level: ${entry.level || 1}  Kills: ${entry.kills || 0}`);
          lines.push(`HP: ${Math.round(entry.hp || entry.hpMax || 0)}`);
          lines.push(`Damage: ${Math.round(entry.dmg || 0)}`);
        } else if (type === 'vehicle') {
          lines.push(`Vehicle: ${entry.name || entry.id || 'Unnamed'}`);
          lines.push(`Level: ${entry.level || 1}`);
          lines.push(`Armor: ${Math.round(entry.def || entry.armor || 0)}`);
          lines.push(`Speed: ${Math.round(entry.speed || entry.vx || 0)}`);
        } else if (type === 'companion') {
          lines.push(`Companion: ${entry.name || entry.id || 'Ally'}`);
          lines.push(`HP: ${Math.round(entry.hp || entry.hpMax || entry.max || 0)} / ${Math.round(entry.hpMax || entry.max || entry.hp || 0)}`);
          lines.push(`Damage: ${Math.round(entry.dmg || entry.atk || 0)}`);
          lines.push(`Role: AI Companion`);
        }
        rosterDetailEl.textContent = lines.join('\n');
      }

      function renderRoster() {
        ensureRosterModal();
        if (!rosterListEl) return;
        rosterListEl.innerHTML = '';
        rosterDetailEl.textContent = 'Select a hero, pet, or vehicle to view details.';
        const st = window.st || (window.st = {});
        const heroes = st.players || [];
        const pets = [];
        if (Array.isArray(st.equippedPets)) st.equippedPets.forEach(p => { if (p) pets.push(p); });
        if (Array.isArray(st.pets)) st.pets.forEach(p => { if (p) pets.push(p); });
        const vehicles = [];
        if (Array.isArray(st.vehicles)) st.vehicles.forEach(v => { if (v) vehicles.push(v); });
        if (st.equippedVehicle) vehicles.push(st.equippedVehicle);

        const companions = Array.isArray(st.tamedBosses) ? st.tamedBosses : [];
        const sections = [
          { title: 'Heroes', list: heroes, type: 'hero' },
          { title: 'Companions', list: companions, type: 'companion' },
          { title: 'Pets', list: pets, type: 'pet' },
          { title: 'Vehicles', list: vehicles, type: 'vehicle' }
        ];
        sections.forEach(({ title, list, type }) => {
          if (!list || list.length === 0) return;
          const wrap = document.createElement('div');
          const heading = document.createElement('div');
          heading.textContent = title;
          heading.style.cssText = 'font-weight:600;color:#cfe8ff;margin-bottom:10px;';
          const grid = document.createElement('div');
          grid.style.cssText = 'display:flex;flex-wrap:wrap;gap:12px;';
          list.forEach((entry, idx) => {
            const card = document.createElement('button');
            card.type = 'button';
            card.style.cssText = 'flex:1 1 180px;padding:12px;border-radius:10px;border:1px solid rgba(70,110,160,0.35);background:#131f30;color:#cfe8ff;text-align:left;cursor:pointer;transition:box-shadow 0.25s;';
            card.innerHTML = `<div style="font-weight:600;margin-bottom:6px;">${entry?.name || entry?.id || `${title} ${idx + 1}`}</div>` +
              `<div style="font-size:12px;color:#9abacc;white-space:pre-line;line-height:1.3;">${formatRosterStats(entry, type)}</div>`;
            card.addEventListener('click', () => showRosterDetails(entry, type));
            card.addEventListener('mouseenter', () => { card.style.boxShadow = '0 0 0 3px rgba(106,168,255,0.4)'; });
            card.addEventListener('mouseleave', () => { card.style.boxShadow = 'none'; });
            grid.appendChild(card);
          });
          wrap.appendChild(heading);
          wrap.appendChild(grid);
          rosterListEl.appendChild(wrap);
        });
      }
      window.A1KTeam = Object.assign({
        roster: window.A1KTeam?.roster || ['A1', 'Unique', 'Missy'],
        formation: window.A1KTeam?.formation || [0, 1, 2],
        swapUI() {
          const st = window.st || (window.st = {});
          if (!Array.isArray(st.players) || st.players.length < 2) {
            notify?.('Need at least two heroes to swap.', '#ff7a6a');
            return;
          }
          ensureFormation();
          ensureSwapModal();
          this._swapSelection = [];
          renderSwapOptions();
          highlightSwapSelection([]);
          swapModal.style.display = 'flex';
          swapModal.setAttribute('aria-hidden', 'false');
        },
        tradeUI() {
          try {
            const invBtn = document.getElementById('invBtn');
            if (invBtn) invBtn.click();
          } catch (_) { }
          ensureTradeOverlay();
          ensureTradeHandler();
          notify?.('Trade mode active. Click items to share them between heroes.', '#6aa8ff');
        },
        rosterUI() {
          ensureRosterModal();
          renderRoster();
          rosterModal.style.display = 'flex';
          rosterModal.setAttribute('aria-hidden', 'false');
        },
        selectSwap(index) {
          const st = window.st || (window.st = {});
          if (!Array.isArray(st.players) || !st.players[index]) return;
          if (!swapModal || swapModal.style.display === 'none') {
            this.swapUI();
          }
          this._swapSelection = this._swapSelection || [];
          if (this._swapSelection.length === 0) {
            this._swapSelection.push(index);
            if (swapNoticeEl) swapNoticeEl.textContent = 'Select another hero to complete the swap.';
            highlightSwapSelection(this._swapSelection);
            return;
          }
          const first = this._swapSelection[0];
          if (first === index) {
            this._swapSelection = [];
            if (swapNoticeEl) swapNoticeEl.textContent = 'Select two heroes to swap their formation slots.';
            highlightSwapSelection([]);
            return;
          }
          const second = index;
          const nameA = st.players[first]?.id || st.players[first]?.name || `Hero ${first + 1}`;
          const nameB = st.players[second]?.id || st.players[second]?.name || `Hero ${second + 1}`;
          performSwap(first, second);
          this._swapSelection = [];
          highlightSwapSelection([]);
          renderSwapOptions();
          if (swapNoticeEl) swapNoticeEl.textContent = `Swapped ${nameA} and ${nameB}.`;
          notify?.(`Formation updated: ${nameA} ↔ ${nameB}`, '#6aa8ff');
        },
        closeSwapUI() {
          if (swapModal) {
            swapModal.style.display = 'none';
            swapModal.setAttribute('aria-hidden', 'true');
          }
          this._swapSelection = [];
          highlightSwapSelection([]);
        },
        closeRosterUI() {
          if (rosterModal) {
            rosterModal.style.display = 'none';
            rosterModal.setAttribute('aria-hidden', 'true');
          }
        },
        cloneStance(stance) {
          if (stance) {
            const applied = applyCloneStanceState(stance);
            updateCloneStanceLabel(applied);
            return applied;
          }
          return cycleCloneStanceState();
        },
        cycleCloneStance: cycleCloneStanceState,
        setCloneStance(stance) {
          const applied = applyCloneStanceState(stance);
          updateCloneStanceLabel(applied);
          return applied;
        },
        getCloneStance: getCloneStanceState
      }, window.A1KTeam || {});

      window.addEventListener('a1k:clone-stance', (event) => {
        updateCloneStanceLabel(event?.detail?.stance);
      });

      document.addEventListener('DOMContentLoaded', () => {
        if (window.A1K_FLAGS?.TEAM_MENU_ENABLED) {
          hideLegacyWidgets();
          mountTeamMenu();
          removeOldCloneButton();
          console.log('%c[A1K] Team Menu enabled', 'color:#00e5ff');
        }
      });
    })();
  </script>

  <script id="a1k-link-api">
    (function () {
      const KEY = 'A1K_PROFILE_V1';
      const DEF = { gold: 0, currencies: { gold: 0, silver: 0, gems: 0 }, bag: [], pets: [], vehicles: [] };

      const load = () => { try { return Object.assign({}, DEF, JSON.parse(localStorage.getItem(KEY) || '{}')); } catch { return { ...DEF }; } };
      const save = (p) => { try { localStorage.setItem(KEY, JSON.stringify(p)); } catch (_) { } };

      const P = load();
      const Link = {
        get profile() { return P; },
        setGold(n) { P.gold = Math.max(0, n | 0); P.currencies.gold = P.gold; save(P); },
        addGold(n) { Link.setGold((P.gold | 0) + (n | 0)); },
        addItem(it) { if (it) { P.bag.push(it); save(P); } },
        setBag(arr) { P.bag = Array.isArray(arr) ? arr.slice(0) : []; save(P); },
        addPet(p) { if (p) { (P.pets = P.pets || []).push(p); save(P); } },
        addVehicle(v) { if (v) { (P.vehicles = P.vehicles || []).push(v); save(P); } },

        attachToRunner() {
          try { if (window.st) window.st.gold = P.gold | 0; } catch (_) { }
          try { const add = window.game?.addItem; if (typeof add === 'function') for (const it of P.bag) add(it); } catch (_) { }
          let lastGold = (window.st?.gold | 0);
          setInterval(() => { try { const g = (window.st?.gold | 0); if (g !== lastGold) { lastGold = g; Link.setGold(g); } } catch (_) { } }, 250);
          const legacyAddItem = window.addItem;
          window.addItem = function (it) { try { window.game?.addItem?.(it); } catch (_) { } try { Link.addItem(it); } catch (_) { } if (typeof legacyAddItem === 'function') return legacyAddItem(it); };
        },

        attachToCandy() {
          try { if (window.st) window.st.gold = P.gold | 0; } catch (_) { }
          try { window.inventory = window.inventory || { items: [], pets: [], vehicles: [] }; } catch (_) { }
          const legacyAddItem = window.addItem;
          window.addItem = function (it) { try { Link.addItem(it); } catch (_) { } try { window.game?.addItem?.(it); } catch (_) { } if (typeof legacyAddItem === 'function') return legacyAddItem(it); };
          let lastGold = (window.st?.gold | 0);
          setInterval(() => { try { const g = (window.st?.gold | 0); if (g !== lastGold) { lastGold = g; Link.setGold(g); } } catch (_) { } }, 250);
        }
      };
      window.A1KLink = Link;
    })();
  </script>

  <style>
    #a1k-door-prompt {
      position: fixed;
      left: 50%;
      bottom: 14%;
      transform: translateX(-50%);
      background: #0b0f14cc;
      color: #cfe8ff;
      border: 1px solid #3aa3ff66;
      padding: 10px 14px;
      border-radius: 12px;
      font: 12px/1.2 monospace;
      display: none;
      z-index: 99999
    }
  </style>
  <div id="a1k-door-prompt">[E] Enter</div>

  <script id="a1k-door-actors">
    (function () {
      const enterCode = keymap.ENTER_HOUSE || keymap.ACT_PRIMARY || 'KeyE';
      const keys = { ENTER: false };
      const matchesEnter = (code, key) => {
        if (code === enterCode) return true;
        if (enterCode === 'Space') return key === ' ' || key === 'Spacebar';
        return false;
      };
      addEventListener('keydown', e => {
        if (matchesEnter(e.code, e.key)) keys.ENTER = true;
      });
      addEventListener('keyup', e => {
        if (matchesEnter(e.code, e.key)) keys.ENTER = false;
      });
      const aabb = (a, b) => a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y;

      const previous = window.A1KDoorActors;
      const doors = previous?.doors || [];
      const prompt = document.getElementById('a1k-door-prompt');
      const doorKeyLabel = (() => {
        if (enterCode === 'Space') return 'SPACE';
        if (enterCode.startsWith('Key')) return enterCode.slice(3).toUpperCase();
        if (enterCode.startsWith('Digit')) return enterCode.slice(5);
        return enterCode.toUpperCase();
      })();
      if (prompt) {
        prompt.textContent = `[${doorKeyLabel}] Enter`;
      }
      let lastUse = 0, COOLDOWN_MS = 600;

      function getPlayerAABB() {
        if (typeof window.getPlayerAABB === 'function') return window.getPlayerAABB();
        const st = window.st || window.player || {};
        const x = st.x ?? st.px ?? 0, y = st.y ?? st.py ?? 0;
        const w = st.w ?? st.pw ?? 32, h = st.h ?? st.ph ?? 48;
        return { x, y, w, h };
      }

      function mountDoorActor(options) {
        const {
          id = 'door_' + Math.random().toString(36).slice(2),
          x = 0,
          y = 0,
          w = 64,
          h = 96,
          href,
          label = 'Enter',
          promptText,
          mapLabel,
          worldLabel,
          glowColor = '#ff93d3',
          markerRadius = 26,
          minimapLabel
        } = options || {};
        let door = doors.find((d) => d.id === id);
        if (!door) {
          door = {};
          doors.push(door);
        }
        Object.assign(door, {
          id, x, y, w, h, href, label,
          promptText,
          mapLabel: mapLabel ?? label,
          worldLabel: worldLabel ?? mapLabel ?? label,
          glowColor,
          markerRadius,
          minimapLabel
        });
        return door;
      }

      function loop() {
        const player = getPlayerAABB();
        let active = null;

        for (const d of doors) {
          if (aabb(player, d)) { active = d; break; }
        }

        if (active) {
          prompt.textContent = active.promptText || `[${doorKeyLabel}] ${active.label}`;
          prompt.style.display = 'block';
          if (keys.ENTER && (performance.now() - lastUse > COOLDOWN_MS)) {
            lastUse = performance.now();
            location.href = active.href;
          }
        } else {
          prompt.style.display = 'none';
        }
        requestAnimationFrame(loop);
      }
      requestAnimationFrame(loop);
      const api = previous || {};
      api.mountDoorActor = mountDoorActor;
      api.doors = doors;
      api.getDoors = () => doors.slice();
      window.A1KDoorActors = api;
    })();
  </script>

  <script>
    window.addEventListener('load', () => {
      window.A1KLink?.attachToRunner?.();

      const doorPromptLabel = (() => {
        const code = keymap.ENTER_HOUSE || keymap.ACT_PRIMARY || 'KeyE';
        if (code === 'Space') return 'SPACE';
        if (code.startsWith('Key')) return code.slice(3).toUpperCase();
        if (code.startsWith('Digit')) return code.slice(5);
        return code.toUpperCase();
      })();

      A1KDoorActors.mountDoorActor({
        id: 'door_to_candy',
        x: 4480, y: 612, w: 72, h: 100,
        href: 'Candy Dungeon .html',
        label: 'Enter Candy Dungeon',
        promptText: `[${doorPromptLabel}] Enter Candy Dungeon`,
        mapLabel: 'Candy',
        worldLabel: 'Candy Dungeon',
        minimapLabel: 'Candy',
        glowColor: '#ff93d3',
        markerRadius: 30
      });
    });
  </script>

  <!-- Inlined: src/robox/RoboxVFX.js -->
<script>
const RoboxVFX = (() => {
  const noop = () => {};
  return {
    emitMuzzleFlash: noop,
    emitDashTrail: noop,
    emitLightningBurst: noop,
    emitFlameRing: noop,
    emitDomainAura: noop,
  };
})();

if (typeof window !== "undefined") {
  window.RoboxVFX = window.RoboxVFX || RoboxVFX;
}

</script>
  <!-- Inlined: src/robox/RoboxProjectiles.js -->
<script>
function annotate(shot, tags) {
  try {
    if (typeof window.annotateProjectile === "function") {
      window.annotateProjectile(shot, tags);
    }
  } catch (_) {
    /* palette helper not critical */
  }
}

const RoboxProjectiles = {
  makePulseShot(bot, target) {
    if (!bot || !target) return null;
    const dx = target.x - bot.x;
    const dy = target.y - bot.y;
    const dist = Math.hypot(dx, dy) || 1;
    const speed = bot.tuning?.ranged ?? 360;
    const shot = {
      kind: "robox_pulse",
      owner: "ally",
      ownerId: bot.id,
      x: bot.x + (dx / dist) * 22,
      y: bot.y - 22 + (dy / dist) * 8,
      vx: (dx / dist) * speed,
      vy: (dy / dist) * speed,
      speed,
      dmg: Math.round(bot.atk * 1.1),
      life: 1200,
      pierce: 0,
      r: 18,
      element: "shock",
      color: "#b57bff",
      tags: ["energy", "ally", "shock"],
    };
    annotate(shot, shot.tags);
    return shot;
  },

  makeDash(bot) {
    const shot = {
      kind: "robox_dash",
      owner: "ally",
      ownerId: bot.id,
      x: bot.x + (bot.facingLeft ? -20 : 20),
      y: bot.y - 10,
      vx: (bot.facingLeft ? -1 : 1) * 680,
      vy: 0,
      w: 120,
      h: 36,
      dmg: Math.round(bot.atk * 1.8),
      life: 220,
      pierce: 1,
      element: "physical",
      color: "#ff3344",
      tags: ["slash", "physical"],
    };
    annotate(shot, shot.tags);
    return shot;
  },

  makeLightningFan(bot, world) {
    const target = world?.state?.enemies?.find((e) => e.hp > 0) || null;
    const baseAngle = target
      ? Math.atan2(target.y - bot.y, target.x - bot.x)
      : bot.facingLeft
      ? Math.PI
      : 0;
    const count = 3;
    const spacing = Math.PI / 12;
    const speed = (bot.tuning?.ranged ?? 360) + 80;
    const shots = [];
    for (let i = 0; i < count; i++) {
      const angle = baseAngle + (i - (count - 1) / 2) * spacing;
      const shot = {
        kind: "robox_lightning",
        owner: "ally",
        ownerId: bot.id,
        x: bot.x,
        y: bot.y - 24,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        speed,
        dmg: Math.round(bot.atk * 0.9),
        life: 900,
        pierce: 1,
        r: 16,
        element: "shock",
        color: "#ff8855",
        tags: ["shock", "chain"],
      };
      annotate(shot, shot.tags);
      shots.push(shot);
    }
    return shots;
  },

  makeFlameSpiral(bot) {
    const count = 8;
    const speed = 280;
    const shots = [];
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count;
      const shot = {
        kind: "robox_fire",
        owner: "ally",
        ownerId: bot.id,
        x: bot.x,
        y: bot.y - 16,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        speed,
        dmg: Math.round(bot.atk * 0.75),
        life: 720,
        pierce: 0,
        r: 14,
        element: "fire",
        color: "#ff8855",
        tags: ["fire", "burn"],
      };
      annotate(shot, shot.tags);
      shots.push(shot);
    }
    return shots;
  },

  makeDomainField(bot) {
    const shot = {
      kind: "robox_domain",
      owner: "ally",
      ownerId: bot.id,
      x: bot.x,
      y: bot.y - 20,
      aoe: 180,
      dmg: Math.round(bot.atk * 1.2),
      life: 900,
      pierce: 0,
      element: "arcane",
      color: "#5ba3ff",
      tags: ["arcane", "zone"],
    };
    annotate(shot, shot.tags);
    return shot;
  },

  ensureRoboxProjectiles(scope = window) {
    scope.RoboxProjectiles = scope.RoboxProjectiles || RoboxProjectiles;
  },
};

if (typeof window !== "undefined") {
  window.RoboxProjectiles = RoboxProjectiles;
}

</script>
  <!-- Inlined: src/robox/RoboxSkills.js -->
<script>
(function () {
  const DEFAULT_SKILL_MULTIPLIER = 3;

  function gameState(world) {
    return world?.state || window.st || null;
  }

  function ensureShotBuffer(world) {
    const state = gameState(world);
    if (!state) return null;
    if (!state.shots) state.shots = [];
    return state.shots;
  }

  function skillMultiplier(bot) {
    return bot?.skillMultiplier || DEFAULT_SKILL_MULTIPLIER;
  }

  function spawnSwordSwing(bot, world, dmgOverride) {
    const shots = ensureShotBuffer(world);
    if (!shots || !bot) return;
    const facingLeft = !!bot.facingLeft;
    const damage = dmgOverride ?? bot.atk ?? 300;
    const shot = {
      kind: "robox_sword",
      owner: "ally",
      ownerId: bot.id,
      x: bot.x + (facingLeft ? -68 : 28),
      y: bot.y - 26,
      vx: 0,
      vy: 0,
      w: 112,
      h: 70,
      dmg: Math.round(damage),
      life: 160,
      pierce: 0,
      element: "physical",
      color: "#5bffaa",
      tags: ["ally", "slash"],
    };
    shots.push(shot);
    try {
      window.RoboxVFX?.emitDashTrail(bot.x, bot.y, facingLeft);
    } catch (_) {
      /* optional */
    }
  }

  function spawnEnergyBolt(bot, target, world, dmgOverride, speedOverride) {
    const shots = ensureShotBuffer(world);
    if (!shots || !bot) return;
    const damage = dmgOverride ?? bot.atk ?? 300;
    const tx = target?.x ?? bot.x + (bot.facingLeft ? -220 : 220);
    const ty = target?.y ?? bot.y;
    const dx = tx - bot.x;
    const dy = ty - bot.y;
    const dist = Math.hypot(dx, dy) || 1;
    const speed = speedOverride ?? (bot.tuning?.ranged ?? 360);
    const shot = {
      kind: "robox_bolt",
      owner: "ally",
      ownerId: bot.id,
      x: bot.x + (dx / dist) * 28,
      y: bot.y - 22 + (dy / dist) * 10,
      vx: (dx / dist) * speed,
      vy: (dy / dist) * speed,
      speed,
      dmg: Math.round(damage),
      life: 1400,
      pierce: 0,
      r: 20,
      element: "energy",
      color: "#5ba3ff",
      tags: ["ally", "energy"],
    };
    shots.push(shot);
    try {
      window.RoboxVFX?.emitMuzzleFlash(shot.x, shot.y);
    } catch (_) {
      /* optional */
    }
  }

  function spawnLightningFan(bot, world, dmgOverride) {
    const shots = ensureShotBuffer(world);
    if (!shots || !bot) return;
    const damage = dmgOverride ?? bot.atk ?? 300;
    const count = 6;
    const spacing = Math.PI / 18;
    const speed = (bot.tuning?.ranged ?? 360) + 80;
    for (let i = 0; i < count; i++) {
      const angle = (i - (count - 1) / 2) * spacing;
      const facingLeft = bot.facingLeft ? Math.PI : 0;
      const theta = facingLeft + angle;
      shots.push({
        kind: "robox_laser",
        owner: "ally",
        ownerId: bot.id,
        x: bot.x,
        y: bot.y - 20,
        vx: Math.cos(theta) * speed,
        vy: Math.sin(theta) * speed,
        speed,
        dmg: Math.round(damage),
        life: 900,
        pierce: 1,
        r: 16,
        element: "shock",
        color: "#b57bff",
        tags: ["ally", "shock"],
      });
    }
    try {
      window.RoboxVFX?.emitLightningBurst(bot.x, bot.y - 20);
    } catch (_) {}
  }

  function spawnDomainPulse(bot, world, dmgOverride) {
    const shots = ensureShotBuffer(world);
    if (!shots || !bot) return;
    const damage = dmgOverride ?? bot.atk ?? 300;
    shots.push({
      kind: "robox_domain",
      owner: "ally",
      ownerId: bot.id,
      x: bot.x,
      y: bot.y - 12,
      aoe: 220,
      dmg: Math.round(damage),
      life: 900,
      pierce: 0,
      element: "arcane",
      color: "#5ba3ff",
      tags: ["ally", "zone"],
    });
    try {
      window.RoboxVFX?.emitDomainAura(bot.x, bot.y - 40);
    } catch (_) {}
  }

  function spawnSpiralVolley(bot, world, dmgOverride) {
    const shots = ensureShotBuffer(world);
    if (!shots || !bot) return;
    const damage = dmgOverride ?? bot.atk ?? 300;
    const speed = (bot.tuning?.ranged ?? 360) + 160;
    const count = 8;
    for (let i = 0; i < count; i++) {
      const angle = (Math.PI * 2 * i) / count;
      shots.push({
        kind: "robox_spiral",
        owner: "ally",
        ownerId: bot.id,
        x: bot.x,
        y: bot.y - 18,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        speed,
        dmg: Math.round(damage),
        life: 1200,
        pierce: 1,
        r: 18,
        element: "arcane",
        color: "#8a2be2",
        tags: ["ally", "arcane"],
      });
    }
    try {
      window.RoboxVFX?.emitFlameRing(bot.x, bot.y - 36);
    } catch (_) {}
  }

  function rollRandomSkill(bot, world) {
    const stamp = performance.now?.() || Date.now();
    const cooldown = bot.skillRandomCooldown || 0;
    if (stamp < cooldown) return;
    const chance = bot.a1kRandomSkillChance ?? 0.18;
    if (Math.random() > chance) return;
    const key = `S${1 + Math.floor(Math.random() * 4)}`;
    if (castSkill(key, bot, world)) {
      bot.skillRandomCooldown = stamp + 2200;
    }
  }

  function primaryFire(bot, target, world) {
    const state = gameState(world);
    if (!bot || !state) return;
    const cycle = bot.attackCycle || (bot.attackCycle = { phase: "melee", count: 0 });
    if (cycle.phase === "melee") {
      spawnSwordSwing(bot, world);
      cycle.count += 1;
      if (cycle.count >= 3) {
        cycle.phase = "ranged";
        cycle.count = 0;
      }
    } else {
      spawnEnergyBolt(bot, target, world);
      cycle.count += 1;
      if (cycle.count >= 3) {
        cycle.phase = "melee";
        cycle.count = 0;
      }
    }
    rollRandomSkill(bot, world);
  }

  function castSkill(key, bot, world) {
    if (!bot) return false;
    const mult = skillMultiplier(bot);
    let handled = false;
    switch (String(key || "").toUpperCase()) {
      case "S1": {
        for (let i = 0; i < 3; i++) spawnSwordSwing(bot, world, bot.atk * mult);
        handled = true;
        break;
      }
      case "S2": {
        spawnLightningFan(bot, world, bot.atk * mult);
        handled = true;
        break;
      }
      case "S3": {
        spawnDomainPulse(bot, world, bot.atk * mult);
        handled = true;
        break;
      }
      case "S4": {
        spawnSpiralVolley(bot, world, bot.atk * mult);
        handled = true;
        break;
      }
      default:
        handled = false;
    }
    if (handled) reset(bot);
    return handled;
  }

  function cast(id, bot, world) {
    if (!bot) return false;
    const key =
      typeof id === "number"
        ? `S${id}`
        : String(id || "")
            .trim()
            .toUpperCase()
            .replace(/^SKILL/, "S");
    return castSkill(key, bot, world);
  }

  function reset(bot) {
    if (bot && bot.attackCycle) {
      bot.attackCycle.phase = "melee";
      bot.attackCycle.count = 0;
    }
  }

  const api = window.RoboxSkills || {};
  api.primaryFire = primaryFire;
  api.cast = cast;
  api.reset = reset;

  window.RoboxSkills = api;
})();

</script>
  <!-- Inlined: src/robox/createRoboxEntity.js -->
<script>
(function(){
  const BASE_STATS = {
    id: 'Robox',
    kind: 'robox',
    hpMax: 2000,
    atk: 300,
    speed: 140
  };

  function createRoboxEntity(options = {}) {
    const spawnTime = performance.now?.() || Date.now();
    const bot = {
      ...BASE_STATS,
      x: options.x ?? 320,
      y: options.y ?? 400,
      vx: 0,
      vy: 0,
      hp: options.hp ?? BASE_STATS.hpMax,
      mode: options.mode || 'follow',
      targetMode: options.targetMode || 'nearest',
      leaderId: options.leaderId ?? null,
      facingLeft: false,
      animState: 'idle',
      animTime: 0,
      alive: true,
      createdAt: spawnTime,
      nextFireAt: spawnTime + 320,
      fireRate: options.fireRate || 420,
      skillMultiplier: options.skillMultiplier || 3,
      attackCycle: {
        phase: 'melee',
        count: 0
      },
      tuning: options.tuning || {
        speed: BASE_STATS.speed,
        ranged: 320,
        melee: 90,
        fireCd: 420
      },
      pendingSkill: null,
      update(dt, world) {
        updateRobox(this, dt, world);
      }
    };
    return bot;
  }

  function updateRobox(bot, dt, world) {
    if (!bot.alive) return;
    const st = world?.state || window.st;
    if (!st) return;

    bot.animTime += dt * 1000;

    const leader = pickLeader(st, bot);
    if (!leader) return;

    const goal = getGoal(bot, leader, st);
    const dx = goal.x - bot.x;
    const dy = goal.y - bot.y;
    const dist = Math.hypot(dx, dy);
    const maxSpeed = (bot.tuning?.speed ?? BASE_STATS.speed);

    if (dist > 4) {
      const step = Math.min(maxSpeed * dt, dist);
      const nx = dx / (dist || 1);
      const ny = dy / (dist || 1);
      bot.vx = nx * maxSpeed;
      bot.vy = ny * maxSpeed * 0.6;
      bot.x += nx * step;
      bot.y += ny * step * 0.8;
      bot.animState = 'run';
    } else {
      bot.vx *= 0.8;
      bot.vy *= 0.8;
      bot.animState = 'idle';
    }

    bot.facingLeft = dx < 0;

    const minX = 40;
    const maxX = (window.WORLD_WIDTH || window.DESIGN_W || 1280) - 40;
    const floor = laneY(leader.lane ?? 2);
    bot.x = Math.max(minX, Math.min(maxX, bot.x));
    bot.y = Math.min(floor, bot.y);

    const now = performance.now?.() || Date.now();
    const skills = window.RoboxSkills;
    if (skills && now >= bot.nextFireAt) {
      const target = findTarget(bot, st);
      if (target) {
        skills.primaryFire(bot, target, world);
        bot.nextFireAt = now + (bot.tuning?.fireCd ?? bot.fireRate);
        bot.animState = 'attack';
      }
    }

    if (bot.pendingSkill && skills) {
      skills.cast(bot.pendingSkill, bot, world);
      bot.pendingSkill = null;
    }
  }

  function pickLeader(st, bot) {
    if (bot.leaderId) {
      const match = st.players?.find(p => p.id === bot.leaderId);
      if (match) return match;
    }
    if (st.players?.length) {
      return st.players[st.leader ?? 0] ?? st.players[0];
    }
    return null;
  }

  function getGoal(bot, leader, st) {
    switch (bot.mode) {
      case 'aggro': {
        const target = findTarget(bot, st);
        if (target) {
          return { x: target.x - 80, y: target.y };
        }
        break;
      }
      case 'guard':
        return { x: leader.x + (bot.tuning?.melee ?? 90), y: leader.y };
      case 'assist':
        return { x: leader.x, y: leader.y - 80 };
      case 'follow':
      default:
        return { x: leader.x - (bot.tuning?.melee ?? 90), y: leader.y };
    }
  }

  function findTarget(bot, st) {
    const enemies = st.enemies || [];
    if (!enemies.length) return null;

    let best = null;
    if (bot.targetMode === 'lowest') {
      let lowestHp = Infinity;
      for (const e of enemies) {
        if (e.hp > 0 && e.hp < lowestHp) {
          lowestHp = e.hp;
          best = e;
        }
      }
    } else if (bot.targetMode === 'boss') {
      best = enemies.find(e => e.isBoss && e.hp > 0) || null;
    }

    if (!best) {
      let bestDist = Infinity;
      for (const e of enemies) {
        if (e.hp <= 0) continue;
        const dx = e.x - bot.x;
        const dy = e.y - bot.y;
        const d2 = dx * dx + dy * dy;
        if (d2 < bestDist) {
          bestDist = d2;
          best = e;
        }
      }
    }

    return best;
  }

  function laneY(lane) {
    const lanes = {
      1: (window.DESIGN_H || 720) - 220,
      2: (window.DESIGN_H || 720) - 180,
      3: (window.DESIGN_H || 720) - 140
    };
    return lanes[lane] ?? lanes[2];
  }

  window.RoboxCreateEntity = createRoboxEntity;
})();

</script>
  <!-- Inlined: src/robox/RoboxRenderer.js -->
<script>
(function () {
  class RoboxRenderer {
    constructor() {
      this.animTime = 0;
    }

    render(ctx, x, y, opts = {}) {
      const facingLeft = !!opts.facingLeft;
      const animState = opts.animState || "idle";
      this.animTime = opts.animTime ?? this.animTime;

      ctx.save();
      ctx.translate(x, y);
      if (facingLeft) ctx.scale(-1, 1);

      const bob = Math.sin(this.animTime * 0.008) * 3;

      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      ctx.globalAlpha = 0.28 + Math.sin(this.animTime * 0.01) * 0.12;
      const gradient = ctx.createRadialGradient(0, -20, 0, 0, -24, 44);
      gradient.addColorStop(0, "rgba(91,163,255,0.45)");
      gradient.addColorStop(1, "rgba(91,163,255,0)");
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(0, -22, 34, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      ctx.fillStyle = "#101728";
      ctx.strokeStyle = "#5bffaa";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(-14, -36 + bob);
      ctx.quadraticCurveTo(-18, -12 + bob, -10, 12 + bob);
      ctx.quadraticCurveTo(-6, 30 + bob, 0, 34 + bob);
      ctx.quadraticCurveTo(6, 30 + bob, 10, 12 + bob);
      ctx.quadraticCurveTo(18, -12 + bob, 14, -36 + bob);
      ctx.closePath();
      ctx.fill();
      ctx.stroke();

      ctx.fillStyle = "#5ba3ff";
      ctx.fillRect(-10, -28 + bob, 20, 10);
      ctx.fillStyle = "#5bffaa";
      ctx.fillRect(-6, -26 + bob, 5, 5);
      ctx.fillRect(2, -26 + bob, 5, 5);

      const armSwing =
        animState === "attack"
          ? 0.5
          : Math.sin(this.animTime * 0.01) * (animState === "run" ? 0.45 : 0.2);

      ctx.strokeStyle = "#5bffaa";
      ctx.lineWidth = 3;
      ctx.lineCap = "round";

      ctx.save();
      ctx.translate(-12, -10 + bob);
      ctx.rotate(-armSwing);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(-6, 20);
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.translate(12, -10 + bob);
      ctx.rotate(armSwing);
      ctx.beginPath();
      ctx.moveTo(0, 0);
      ctx.lineTo(6, 20);
      ctx.stroke();
      ctx.restore();

      ctx.save();
      ctx.translate(0, 18 + bob);
      const thruster = Math.max(0.4, animState === "idle" ? 0.6 : 1.0);
      ctx.globalCompositeOperation = "lighter";
      ctx.globalAlpha = 0.4 * thruster;
      ctx.fillStyle = "#5ba3ff";
      ctx.beginPath();
      ctx.ellipse(0, 0, 12, 18, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.restore();

      ctx.restore();
    }
  }

  function registerRoboxRenderer(scope = window) {
    scope.CharacterRenderers = scope.CharacterRenderers || {};
    if (!scope.CharacterRenderers.Robox) {
      scope.CharacterRenderers.Robox = new RoboxRenderer();
    }
  }

  window.registerRoboxRenderer = registerRoboxRenderer;
})();

</script>
  <!-- Inlined: src/robox/RoboxController.js -->
<script>
(function () {
  const DEFAULT_TUNING = {
    speed: 140,
    ranged: 300,
    melee: 90,
    fireCd: 420,
  };

  const RoboxController = (() => {
    let engine = null;

    function state() {
      return engine?.state || window.st;
    }

    function ensureArray() {
      const st = state();
      if (!st) return null;
      if (!Array.isArray(st.aiCompanions)) {
        st.aiCompanions = [];
      }
      return st.aiCompanions;
    }

    function list() {
      const st = state();
      return Array.isArray(st?.aiCompanions) ? st.aiCompanions : [];
    }

    function get() {
      return list().find((bot) => bot.kind === "robox") || null;
    }

    function spawn(options = {}) {
      const st = state();
      if (!st) return null;
      const store = ensureArray();
      if (!store) return null;
      const existing = get();
      if (existing) {
        if (options.mode) existing.mode = options.mode;
        if (options.targetMode) existing.targetMode = options.targetMode;
        return existing;
      }

      const create = window.RoboxCreateEntity;
      if (typeof create !== "function") {
        console.warn("[Robox] createRoboxEntity missing");
        return null;
      }

      const leader = st.players?.[st.leader ?? 0];
      const spawnX = options.x ?? (leader ? leader.x - 70 : 320);
      const spawnY = options.y ?? (leader ? leader.y : 400);

      const bot = create({
        x: spawnX,
        y: spawnY,
        leaderId: leader?.id ?? null,
        tuning: { ...DEFAULT_TUNING },
        mode: options.mode || "follow",
        targetMode: options.targetMode || "nearest",
      });

      store.push(bot);
      engine?.dispatch?.("robox/spawned", bot);
      window.notify?.("Robox AI online", "#5ba3ff");
      return bot;
    }

    function despawn() {
      const st = state();
      if (!st?.aiCompanions) return;
      const idx = st.aiCompanions.findIndex((bot) => bot.kind === "robox");
      if (idx >= 0) {
        const removed = st.aiCompanions.splice(idx, 1)[0];
        if (removed) removed.alive = false;
        engine?.dispatch?.("robox/despawned", removed);
        window.notify?.("Robox offline", "#ff6666");
      }
    }

    function setMode(mode) {
      const bot = get();
      if (!bot) return;
      bot.mode = mode;
      bot.lastModeChange = performance.now?.() || Date.now();
    }

    function setTargetMode(mode) {
      const bot = get();
      if (!bot) return;
      bot.targetMode = mode;
    }

    function cast(id) {
      const bot = get();
      if (!bot) return;
      bot.pendingSkill = id;
    }

    function applyTuning(values = {}) {
      const bot = get();
      if (!bot) return;
      bot.tuning = bot.tuning || { ...DEFAULT_TUNING };
      if (typeof values.speed === "number") bot.tuning.speed = values.speed;
      if (typeof values.ranged === "number") bot.tuning.ranged = values.ranged;
      if (typeof values.melee === "number") bot.tuning.melee = values.melee;
      if (typeof values.fireCd === "number") {
        bot.tuning.fireCd = Math.max(160, values.fireCd);
        bot.fireRate = bot.tuning.fireCd;
      }
    }

    function attach(gameEngine) {
      engine = gameEngine;
      const api = (window.RoboxAI = window.RoboxAI || {});
      Object.assign(api, {
        __installed: true,
        spawn,
        despawn,
        get,
        list,
        setMode,
        setTargetMode,
        cast,
        applyTuning,
      });
      window.AI_SUMMON =
        window.AI_SUMMON ||
        function () {
          spawn();
        };
      return api;
    }

    return {
      attach,
      spawn,
      despawn,
      get,
      list,
      setMode,
      setTargetMode,
      cast,
      applyTuning,
    };
  })();

  window.RoboxController = RoboxController;
})();

</script>
  <!-- Inlined: src/robox/index.js -->
<script>
(function(){
  function bootRoboxModule() {
    try {
      if (typeof window.registerRoboxRenderer === 'function') {
        window.registerRoboxRenderer(window);
      }
      if (window.RoboxProjectiles?.ensureRoboxProjectiles) {
        window.RoboxProjectiles.ensureRoboxProjectiles(window);
      }
      const controller = window.RoboxController;
      if (!controller) {
        console.warn('[Robox] controller missing');
        return;
      }
      const engine = {
        get state() {
          return window.st;
        },
        dispatch(event, detail) {
          try {
            window.dispatchEvent?.(new CustomEvent(event, { detail }));
          } catch (_) {
            /* noop */
          }
        }
      };
      controller.attach(engine);
    } catch (err) {
      console.error('[Robox] failed to boot module', err);
    }
  }

  window.bootRoboxModule = window.bootRoboxModule || bootRoboxModule;
})();

</script>
  <script>window.bootRoboxModule?.();</script>
  <!-- Inlined: src/robox/bot/robox_inject.js -->
<script>
/* Robox HUD bridge – retro comm-link panel without neon VFX. */
(function () {
  if (window.__ROBOX_PANEL__) return;
  window.__ROBOX_PANEL__ = true;

  const doc = document;
  const $ = (sel, root = doc) => root.querySelector(sel);

  // ---------- Styles ----------
  const style = doc.createElement("style");
  style.textContent = `
  #btnAISummon{
    position:fixed;
    left:16px;
    bottom:186px;
    width:32px;
    height:32px;
    border:2px solid #6b5a43;
    border-radius:6px;
    background:#efe5cb;
    color:#2f291e;
    font-size:14px;
    font-weight:700;
    line-height:28px;
    text-align:center;
    cursor:pointer;
    z-index:12002;
    user-select:none;
  }
  #btnAISummon:active{ transform:translateY(1px); }
  #roboxPanel{
    position:fixed;
    left:12px;
    bottom:262px;
    width:680px;
    max-width:92vw;
    background:#e8dec4;
    border:2px solid #6b5a43;
    border-radius:8px;
    box-shadow:0 6px 16px rgba(0,0,0,.35);
    color:#2f291e;
    font:13px/1.25 "ui-monospace", monospace;
    padding:44px 12px 12px 12px;
    display:none;
    z-index:12000;
  }
  #roboxPanel .rbx-row{display:flex;gap:10px;}
  #roboxPanel .rbx-col{background:#f1e7cd;border:2px solid #6b5a43;border-radius:6px;padding:10px;display:flex;flex-direction:column;gap:10px;}
  #roboxPanel .rbx-col h3{margin:0;background:#cdbb95;border:2px solid #6b5a43;border-radius:4px;padding:4px 8px;font-weight:700;letter-spacing:.06em;text-transform:uppercase;text-align:center;}
  #roboxPanel .rbx-meter{display:flex;justify-content:space-between;gap:12px;}
  #roboxPanel .rbx-btn,#roboxPanel .rbx-chip{cursor:pointer;border:2px solid #6b5a43;background:#dfd2af;color:#2f291e;border-radius:6px;padding:6px 10px;user-select:none;text-align:center;}
  #roboxPanel .rbx-btn:active,#roboxPanel .rbx-chip:active{transform:translateY(1px);}
  #roboxPanel .rbx-chip.active{background:#cbb992;}
  #roboxPanel .rbx-grid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px;}
  #roboxPanel .rbx-skills{display:grid;grid-template-columns:repeat(4,minmax(0,1fr));gap:8px;}
  #roboxPanel .rbx-log{min-height:160px;max-height:200px;background:#d6c7a3;border:2px solid #6b5a43;border-radius:6px;overflow:auto;padding:8px;white-space:pre-wrap;}
  #roboxPanel .rbx-footer{display:flex;gap:8px;}
  #roboxPanel input.rbx-cmd{flex:1;min-width:0;padding:8px;border:2px solid #6b5a43;background:#efe5cb;color:#2f291e;border-radius:6px;}
  #roboxPanel .rbx-close{
    position:absolute;
    top:10px;
    right:12px;
    width:26px;
    height:26px;
    border:2px solid #6b5a43;
    border-radius:4px;
    background:#cdbb95;
    color:#2f291e;
    font-weight:700;
    line-height:20px;
    cursor:pointer;
  }
  #roboxPanel .rbx-close:active{transform:translateY(1px);}
  `;
  doc.head.appendChild(style);

  function createCloneSprite() {
    const canvas = doc.createElement("canvas");
    canvas.width = 28;
    canvas.height = 28;
    const ctx = canvas.getContext("2d");
    ctx.fillStyle = "#efe5cb";
    ctx.fillRect(6, 6, 16, 16);
    ctx.strokeStyle = "#6b5a43";
    ctx.lineWidth = 2;
    ctx.strokeRect(6, 6, 16, 16);
    ctx.fillStyle = "#2f291e";
    ctx.fillRect(9, 10, 4, 4);
    ctx.fillRect(15, 10, 4, 4);
    ctx.beginPath();
    ctx.moveTo(10, 18);
    ctx.lineTo(18, 18);
    ctx.stroke();
    return canvas.toDataURL("image/png");
  }

  const cloneSpriteURL = createCloneSprite();

  // ---------- Boot strap ----------
  function ensureBoot() {
    if (typeof window.bootRoboxModule === "function") {
      try {
        window.bootRoboxModule();
      } catch (err) {
        console.error(err);
      }
      return;
    }
    setTimeout(ensureBoot, 60);
  }
  ensureBoot();

  const topButton = $("#btnAISummonTop");
  let floatingBtn = $("#btnAISummon");
  if (!topButton && !floatingBtn) {
    floatingBtn = doc.createElement("button");
    floatingBtn.id = "btnAISummon";
    floatingBtn.title = "Companion Panel";
    floatingBtn.textContent = "AI";
    doc.body.appendChild(floatingBtn);
  }

  const toggleButtons = [];
  if (topButton) toggleButtons.push(topButton);
  if (floatingBtn) toggleButtons.push(floatingBtn);

  let panel = doc.getElementById("roboxPanel");
  if (!panel) {
    panel = doc.createElement("div");
    panel.id = "roboxPanel";
    panel.innerHTML = `
      <button class="rbx-close" id="rbxClose" aria-label="Close panel">X</button>
      <div class="rbx-row">
        <div class="rbx-col" style="flex:0 0 190px">
          <h3>Companion</h3>
          <div class="rbx-meter">
            <div>Lvl <span id="rbxLvl">1.0</span></div>
            <div>Mode <span id="rbxMode">Follow</span></div>
          </div>
          <div class="rbx-grid">
            <div class="rbx-btn" id="rbxSummon">Summon</div>
            <div class="rbx-btn" id="rbxDespawn">Despawn</div>
          </div>
        </div>
        <div class="rbx-col" style="flex:0 0 220px">
          <h3>Tactics</h3>
          <div class="rbx-grid">
            <div class="rbx-chip active" data-mode="follow" id="rbxFollow">Follow</div>
            <div class="rbx-chip" data-mode="hunt" id="rbxHunt">Hunt</div>
            <div class="rbx-chip" data-mode="assist" id="rbxAssist">Assist</div>
            <div class="rbx-chip" data-action="return" id="rbxReturn">Return</div>
          </div>
          <h3>Skills</h3>
          <div class="rbx-skills">
            <div class="rbx-btn" id="rbxS1">S1</div>
            <div class="rbx-btn" id="rbxS2">S2</div>
            <div class="rbx-btn" id="rbxS3">S3</div>
            <div class="rbx-btn" id="rbxS4">S4</div>
          </div>
        </div>
        <div class="rbx-col">
          <h3>Comm-Link</h3>
          <div class="rbx-log" id="rbxLog">Tip: Press Summon to deploy the companion.</div>
          <div class="rbx-footer">
            <input id="rbxCmd" class="rbx-cmd" placeholder="Give a command..." maxlength="120">
            <div class="rbx-btn" id="rbxSend">Send</div>
          </div>
        </div>
      </div>
    `;
    doc.body.appendChild(panel);
  }

  const logBox = $("#rbxLog", panel);
  const lvlLabel = $("#rbxLvl", panel);
  const modeLabel = $("#rbxMode", panel);
  const cmdInput = $("#rbxCmd", panel);
  const sendButton = $("#rbxSend", panel);
  const modeButtons = {
    follow: $("#rbxFollow", panel),
    hunt: $("#rbxHunt", panel),
    assist: $("#rbxAssist", panel),
  };
  const returnButton = $("#rbxReturn", panel);
  const skillButtons = {
    S1: $("#rbxS1", panel),
    S2: $("#rbxS2", panel),
    S3: $("#rbxS3", panel),
    S4: $("#rbxS4", panel),
  };

  const assistState = {
    active: false,
    saved: new Map(),
    targetY: null,
    raf: 0,
    platform: null,
    hoverY: null,
    phase: null,
    direction: 1,
    waitUntil: 0,
    xTarget: null,
    boarded: new Set(),
  };

  function log(message) {
    if (!logBox) return;
    const prefix = logBox.textContent ? `${logBox.textContent}\n` : "";
    logBox.textContent = `${prefix}AI: ${message}`;
    logBox.scrollTop = logBox.scrollHeight;
  }

  function roboxAPI() {
    return window.RoboxAI && window.RoboxAI.spawn ? window.RoboxAI : null;
  }

  function ensureRobox(cb) {
    const api = roboxAPI();
    if (api) {
      cb(api);
    } else {
      log("Robox core not ready yet.");
    }
  }

  function updateLevel() {
    const api = roboxAPI();
    if (!api) return;
    const bot = api.get?.();
    if (bot && typeof bot.level === "number") {
      lvlLabel.textContent = bot.level.toFixed(1);
    }
  }

  function setActiveMode(mode) {
    Object.values(modeButtons).forEach((btn) => btn?.classList.remove("active"));
    const btn = modeButtons[mode];
    if (btn) btn.classList.add("active");
    if (modeLabel) {
      modeLabel.textContent = mode.charAt(0).toUpperCase() + mode.slice(1);
    }
  }

  const modeMap = {
    follow: "follow",
    hunt: "aggro",
    assist: "assist",
  };

  const modeAlias = {
    aggro: "hunt",
    guard: "follow",
  };

  function findLandingY(x, y) {
    const solids = (window.Platform?.layers?.solids) || [];
    let best = null;
    for (const solid of solids) {
      if (!solid) continue;
      const sx = solid.x || 0;
      const sw = solid.w || 0;
      const sy = solid.y || 0;
      const within = x >= sx - 24 && x <= sx + sw + 24;
      if (within && sy > y) {
        if (best === null || sy < best) best = sy;
      }
    }
  if (best === null) {
    return y + 160;
  }
  return best - 40;
}

  function locatePlatform(x, y) {
    const solids = (window.Platform?.layers?.solids) || [];
    let best = null;
    let bestScore = Infinity;
    for (const solid of solids) {
      if (!solid) continue;
      const top = solid.y ?? 0;
      const width = solid.w ?? 160;
      const left = solid.x ?? 0;
      const right = left + width;
      const vertical = top >= y ? top - y : Infinity;
      if (vertical === Infinity) continue;
      const horiz = x < left ? left - x : x > right ? x - right : 0;
      const score = vertical * 1.5 + horiz;
      if (score < bestScore) {
        bestScore = score;
        best = { left, right, width, y: top };
      }
    }
    if (!best) {
      return { left: x - 80, right: x + 80, width: 160, y: y + 160 };
    }
    return best;
  }

  function computePlatformRoute(base) {
    if (!base) return { startX: base?.left ?? 0, endX: base?.right ?? 0 };
    const solids = (window.Platform?.layers?.solids) || [];
    const strip = solids.filter((solid) => {
      if (!solid) return false;
      const top = solid.y ?? 0;
      return Math.abs(top - base.y) < 6;
    });
    if (!strip.length) {
      return { startX: base.left, endX: base.right };
    }
    let min = base.left;
    let max = base.right;
    strip.forEach((solid) => {
      const left = solid.x ?? min;
      const right = (solid.x ?? min) + (solid.w ?? 0);
      if (left < min) min = left;
      if (right > max) max = right;
    });
    const pad = Math.min(96, (max - min) * 0.08);
    const startX = min + pad;
    const endX = max - pad;
    return { startX, endX };
  }

  function stopAssistCarry(message) {
    if (assistState.raf) {
      cancelAnimationFrame(assistState.raf);
      assistState.raf = 0;
    }
    if (!assistState.active) {
      if (message) log(message);
      return;
    }
    assistState.active = false;
    const st = window.st;
    if (st?.players) {
      st.players.forEach((player) => {
        const saved = assistState.saved.get(player);
        player.invulnerable = saved ? saved.invulnerable : false;
      });
    }
    assistState.saved.clear();
    assistState.boarded.clear();
    assistState.targetY = null;
    assistState.platform = null;
    assistState.phase = null;
    assistState.hoverY = null;
    assistState.direction = 1;
    assistState.waitUntil = 0;
    assistState.xTarget = null;
    if (message) log(message);
  }

  function assistStep() {
    if (!assistState.active) {
      assistState.raf = 0;
      return;
    }
    const api = roboxAPI();
    const st = window.st;
    const bot = api?.get?.();
    const players = (st?.players || []).filter((p) => p && !p.isDefeated);
    if (!api || !st || !bot || !players.length) {
      stopAssistCarry("Assist aborted.");
      return;
    }
    if (!assistState.platform) {
      stopAssistCarry("Assist platform lost.");
      return;
    }
    if (!assistState.boarded.size) {
      stopAssistCarry("Assist complete.");
      return;
    }

    const platform = assistState.platform;
    const now = performance.now?.() || Date.now();

    if (assistState.phase === "carry") {
      const hoverY = assistState.hoverY ?? platform.y - 40;
      assistState.hoverY = hoverY;
      const targetX = assistState.direction > 0 ? platform.endX : platform.startX;
      assistState.xTarget = targetX;

      const missing = [];
      assistState.boarded.forEach((player) => {
        if (!players.includes(player)) {
          missing.push(player);
          return;
        }
        if (!assistState.saved.has(player)) {
          assistState.saved.set(player, { invulnerable: !!player.invulnerable });
        }
        player.invulnerable = true;
        if (typeof player.vx === "number") player.vx = 0;
        if (typeof player.vy === "number") player.vy = 0;
        player.x += (bot.x - player.x) * 0.25;
        player.y += ((hoverY - 14) - player.y) * 0.25;
      });
      if (missing.length) {
        missing.forEach((player) => assistState.boarded.delete(player));
      }

      bot.y += (hoverY - bot.y) * 0.18;
      const deltaX = targetX - bot.x;
      const step = Math.max(-6, Math.min(6, deltaX));
      bot.x += step * 0.12;

      if (Math.abs(deltaX) < 6) {
        assistState.boarded.forEach((player) => {
          player.y = platform.y - 36;
        });
        assistState.phase = "wait";
        assistState.waitUntil = now + 10000;
        assistState.saved.forEach((saved, player) => {
          if (assistState.boarded.has(player)) {
            player.invulnerable = saved ? saved.invulnerable : false;
          }
        });
        assistState.saved.clear();
      }
    } else if (assistState.phase === "wait") {
      const anchorY = platform.y - 4;
      bot.y += (anchorY - bot.y) * 0.3;
      if (assistState.xTarget != null) {
        bot.x += (assistState.xTarget - bot.x) * 0.2;
      }
      if (now >= (assistState.waitUntil || now)) {
        const missing = [];
        assistState.boarded.forEach((player) => {
          if (!players.includes(player)) missing.push(player);
        });
        if (missing.length) {
          missing.forEach((player) => assistState.boarded.delete(player));
        }
        const stillOnboard = [];
        assistState.boarded.forEach((player) => {
          const dx = Math.abs((player.x ?? 0) - bot.x);
          const dy = Math.abs((player.y ?? 0) - (platform.y - 36));
          if (dx < 48 && dy < 36) {
            stillOnboard.push(player);
          }
        });
        if (!stillOnboard.length) {
          stopAssistCarry("Assist complete.");
          return;
        }
        assistState.boarded = new Set(stillOnboard);
        assistState.direction *= -1;
        assistState.phase = "carry";
        assistState.waitUntil = 0;
      }
    }

    assistState.raf = requestAnimationFrame(assistStep);
  }

  function startAssistCarry(api) {
    if (assistState.active) return;
    let bot = api.get?.();
    if (!bot) {
      bot = api.spawn?.({ mode: "assist" });
    }
    if (!bot) {
      log("Assist unavailable (cannot locate companion).");
      return;
    }
    const st = window.st;
    const players = (st?.players || []).filter((p) => p && !p.isDefeated);
    if (!players.length) {
      log("Assist unavailable (no active players).");
      return;
    }
    const plat = locatePlatform(bot.x ?? 0, bot.y ?? 0);
    const route = computePlatformRoute(plat);
    let startX = route.startX ?? plat.left;
    let endX = route.endX ?? plat.right;
    if (startX >= endX) {
      const mid = (plat.left + plat.right) / 2;
      startX = mid - 40;
      endX = mid + 40;
    }
    assistState.platform = {
      startX,
      endX,
      y: plat.y,
      left: plat.left,
      right: plat.right,
    };
    assistState.hoverY = plat.y - 48;
    assistState.direction = 1;
    assistState.xTarget = assistState.platform.endX;
    bot.x = assistState.platform.startX;
    bot.y = assistState.hoverY;
    assistState.phase = "carry";
    assistState.waitUntil = 0;
    assistState.active = true;
    assistState.saved.clear();
    assistState.boarded = new Set(players);
    assistState.targetY = null;
    assistState.raf = requestAnimationFrame(assistStep);
    log("Assist formation engaged.");
  }

  function applyMode(mode) {
    const normalized = modeAlias[mode] || mode;
    const next = modeMap[normalized] || "follow";
    ensureRobox((api) => {
      api.setMode?.(next);
      setActiveMode(normalized);
      if (normalized === "assist") {
        startAssistCarry(api);
      } else {
        stopAssistCarry();
      }
      log(`Mode set to ${normalized}.`);
    });
  }

  function handleReturn() {
    ensureRobox((api) => {
      stopAssistCarry();
      const bot = api.get?.();
      if (!bot) {
        log("No active companion to recall.");
        return;
      }
      bot.a1k = bot.a1k || {};
      bot.a1k.hunt = bot.a1k.hunt || {};
      bot.a1k.hunt.returning = true;
      log("Return order acknowledged.");
    });
  }

  function playSummonClones() {
    ensureRobox((api) => {
      const bot = api.get?.();
      const canvas = doc.getElementById("cv");
      const st = window.st;
      if (!bot || !canvas || !st) return;
      const rect = canvas.getBoundingClientRect();
      const scaleX = rect.width / (canvas.width || rect.width || 1);
      const scaleY = rect.height / (canvas.height || rect.height || 1);
      const camX = st.camX || st.cameraX || 0;
      const camY = st.camY || st.cameraY || 0;
      const baseX = rect.left + (bot.x - camX) * scaleX;
      const baseY = rect.top + (bot.y - camY) * scaleY;

      const ghosts = Array.from({ length: 3 }, () => {
        const img = doc.createElement("img");
        img.src = cloneSpriteURL;
        img.width = 24;
        img.height = 24;
        img.style.position = "fixed";
        img.style.pointerEvents = "none";
        img.style.opacity = "0.75";
        doc.body.appendChild(img);
        return img;
      });

      const start = performance.now();
      (function step() {
        const t = (performance.now() - start) / 800;
        ghosts.forEach((g, idx) => {
          const angle = t * 6 + idx * 2.094;
          const x = baseX + Math.cos(angle) * 18;
          const y = baseY + Math.sin(angle) * 12 - 24;
          g.style.transform = `translate(${Math.round(x)}px, ${Math.round(y)}px)`;
          g.style.opacity = String(Math.max(0, 0.7 * (1 - t)));
        });
        if (t < 1) {
          requestAnimationFrame(step);
        } else {
          ghosts.forEach((g) => g.remove());
        }
      })();
    });
  }

  function processCommand(raw) {
    const text = String(raw || "").trim();
    if (!text) return;
    const parts = text.split(/\s+/);
    const root = parts[0].toLowerCase();

    switch (root) {
      case "/summon":
        ensureRobox((api) => {
          const bot = api.spawn();
          if (bot) {
            log("Companion online.");
            playSummonClones();
            updateLevel();
          } else {
            log("Unable to deploy companion.");
          }
        });
        break;
      case "/despawn":
        stopAssistCarry();
        ensureRobox((api) => {
          api.despawn?.();
          log("Companion dismissed.");
        });
        break;
      case "/mode":
        applyMode((parts[1] || "follow").toLowerCase());
        break;
      case "/return":
        handleReturn();
        break;
      case "/create":
        ensureRobox((api) => {
          let bot = api.get?.();
          if (!bot) {
            bot = api.spawn?.();
            log(bot ? "Companion created." : "Unable to create companion.");
          } else {
            log("Companion already active.");
          }
          if (bot) playSummonClones();
        });
        break;
      case "/s1":
      case "/s2":
      case "/s3":
      case "/s4":
        ensureRobox((api) => {
          api.cast?.(root.slice(1).toUpperCase());
          log(`Skill ${root.slice(1).toUpperCase()} queued.`);
        });
        break;
      default:
        log(`Unknown command: ${text}`);
    }
  }

  modeButtons.follow?.addEventListener("click", () => applyMode("follow"));
  modeButtons.hunt?.addEventListener("click", () => applyMode("hunt"));
  modeButtons.assist?.addEventListener("click", () => applyMode("assist"));
  returnButton?.addEventListener("click", handleReturn);
  doc.getElementById("rbxClose")?.addEventListener("click", () => {
    panel.style.display = "none";
  });

  $("#rbxSummon", panel)?.addEventListener("click", () => processCommand("/summon"));
  $("#rbxDespawn", panel)?.addEventListener("click", () => processCommand("/despawn"));
  Object.entries(skillButtons).forEach(([key, btn]) => {
    btn?.addEventListener("click", () => processCommand(`/${key.toLowerCase()}`));
  });

  sendButton?.addEventListener("click", () => {
    const value = (cmdInput?.value || "").trim();
    if (!value) return;
    log(">> " + value);
    processCommand(value);
    cmdInput.value = "";
  });
  cmdInput?.addEventListener("keydown", (ev) => {
    if (ev.key === "Enter") {
      ev.preventDefault();
      sendButton?.click();
    }
  });

  function placeFloatingButton() {
    if (!floatingBtn || floatingBtn === topButton) return;
    const bag = $("#btnBag") || $("#btnBagQuick");
    if (bag) {
      const rect = bag.getBoundingClientRect();
      floatingBtn.style.position = "fixed";
      floatingBtn.style.left = `${Math.round(rect.right + 8)}px`;
      floatingBtn.style.top = `${Math.round(rect.top)}px`;
      floatingBtn.style.bottom = "";
    } else {
      floatingBtn.style.left = "16px";
      floatingBtn.style.bottom = "186px";
      floatingBtn.style.top = "";
    }
  }

  if (floatingBtn && floatingBtn !== topButton) {
    if (typeof ResizeObserver === "function") {
      const observer = new ResizeObserver(placeFloatingButton);
      observer.observe(doc.documentElement);
    }
    window.addEventListener("orientationchange", placeFloatingButton);
    window.addEventListener("resize", placeFloatingButton);
    window.addEventListener("load", placeFloatingButton);
    placeFloatingButton();
  }

  function togglePanel() {
    panel.style.display = panel.style.display === "block" ? "none" : "block";
    if (panel.style.display === "block") {
      log("Comm-link online.");
      updateLevel();
      placeFloatingButton();
    }
  }
  toggleButtons.forEach((button) => button?.addEventListener("click", togglePanel));

  setActiveMode("follow");
  log("Comm-link initialized.");

  // ---------- External helpers ----------
  window.AI_SUMMON = () => processCommand("/summon");
  window.AI_CMD = processCommand;
  window.AI_SET_MODE = (mode) => applyMode((mode || "follow").toLowerCase());
})();


</script>

  <!-- ===== NEW SIMPLIFIED SKILL SYSTEM ===== -->
  <!-- <script src="src/skills/skill_fx_manifest.js"></script> -->
  <!-- ⚡ SIMPLE SKILLS V2 - FRESH BUILD WITH ALL 12 SKILLS ⚡ -->
  <!-- <script src="src/simple_skills_v2.js"></script> -->

  <!-- ⚡ HIGH-GRADE AUTO PAGER AI ⚡ -->
  <script src="src/ai/auto_pager.js"></script>
  <!-- Inlined: src/ai/summon_ai_plus.js -->
<script>
'use strict';

// Enhanced Summon AI: hunt/collect/follow, low-HP focus, spread positioning, loot delivery.

;(function(global){

  function gs(){ return (global.st = global.st || {}); }

  function dist2(a,b){ const dx=(a.x||0)-(b.x||0), dy=(a.y||0)-(b.y||0); return dx*dx+dy*dy; }

  function nearest(list, origin, filt){ let best=null, bd=Infinity; for(const it of list){ if(filt && !filt(it)) continue; const d=dist2(it,origin); if(d<bd){ bd=d; best=it; } } return best; }

  function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }

  const SpreadDistance = 40;

  const Debugger = {
    enabled: false,
    events: [],
    stats: {
      minSpacing: Infinity,
      dashCount: 0,
      lootRuns: 0,
      lowHpFocus: 0,
    },
    enable(reset = true){
      this.enabled = true;
      if(reset){
        this.events = [];
        this.stats = {
          minSpacing: Infinity,
          dashCount: 0,
          lootRuns: 0,
          lowHpFocus: 0,
        };
      }
      console.info("[SummonAIPlus] debug enabled");
    },
    disable({ dump = false } = {}){
      if(dump) this.dump();
      this.enabled = false;
      console.info("[SummonAIPlus] debug disabled");
    },
    record(summon, payload){
      if(!this.enabled) return;
      const entry = {
        t: typeof performance !== "undefined" && performance.now ? performance.now() : Date.now(),
        id: summon?.id ?? summon?.name ?? "summon",
        type: summon?.type ?? "unknown",
        state: payload.state,
        speed: payload.speed,
        target: payload.targetType,
        distOwner: Math.sqrt(payload.ownerDist2 || 0),
        minMateDistance: payload.closestMateDistance,
        hasLoot: payload.hasLoot,
        lowHpFocus: payload.lowHpFocus,
      };
      this.events.push(entry);
      if(payload.closestMateDistance != null){
        this.stats.minSpacing = Math.min(this.stats.minSpacing, payload.closestMateDistance);
      }
      if(payload.state === "hunting" && payload.speed >= 11.5){
        this.stats.dashCount += 1;
      }
      if(payload.hasLoot) this.stats.lootRuns += 1;
      if(payload.lowHpFocus) this.stats.lowHpFocus += 1;
    },
    dump(){
      if(!this.events.length){
        console.info("[SummonAIPlus] no debug events recorded");
        return;
      }
      console.table(this.events);
      console.info("[SummonAIPlus] debug stats", this.stats);
    },
    summary(){
      return {
        events: this.events.slice(-25),
        stats: this.stats,
      };
    },
    reset(){
      this.events = [];
      this.stats = {
        minSpacing: Infinity,
        dashCount: 0,
        lootRuns: 0,
        lowHpFocus: 0,
      };
    },
  };
  global.SummonAIDebug = Debugger;

  function updateSummon(summon, dt){

    const S = gs(); const enemies = (S.enemies||[]).filter(e=>e && !e.dead && e.hp>0);

    const loot = S.items || [];

    const owner = summon.owner; if(!owner){ summon.dead=true; return; }

    // State machine: hunting, following, collecting

    let state = 'following';

    const nearEnemy = nearest(enemies, summon, e=>true);

    const lowHpEnemy = nearest(enemies, summon, e=> (e.hp||9999) < (e.hpMax||9999)*0.35 );

    const collectTarget = nearest(loot, summon, it=>!!it && typeof it.x==='number');

    let tx = owner.x, ty = owner.y;

    if(nearEnemy){ state='hunting'; tx=nearEnemy.x; ty=nearEnemy.y; }

    if(lowHpEnemy){ state='hunting'; tx=lowHpEnemy.x; ty=lowHpEnemy.y; }

    if(!nearEnemy && collectTarget){ state='collecting'; tx=collectTarget.x; ty=collectTarget.y; }

    // Spread positioning (avoid stacking)

    const mates=(S.summons||[]).filter(m=>m!==summon && m.owner===owner);
    let closestMateDistance = null;
    for(const m of mates){
      const dx=summon.x-m.x, dy=summon.y-m.y;
      const d2=dx*dx+dy*dy;
      if(d2>0){
        const d=Math.sqrt(d2);
        if(closestMateDistance === null || d < closestMateDistance){
          closestMateDistance = d;
        }
        if(d < SpreadDistance && d > 0.001){
          const push = (SpreadDistance - d) / SpreadDistance;
          const repel = push * 60 * dt;
          summon.x += (dx/d) * repel;
          summon.y += (dy/d) * repel;
        }
      }
    }

    // Follow distance gate

    const maxFollow = 200; const od2=dist2(summon, owner);

    let speed = state==='hunting'? 12 : (od2>maxFollow*maxFollow? 8 : 6);

    const dx=tx-summon.x, dy=ty-summon.y; const d=Math.hypot(dx,dy)||1; summon.x += (dx/d)*speed*dt; summon.y += (dy/d)*speed*dt;

    // Loot delivery if close to owner

    if(collectTarget && dist2(summon, collectTarget)<900){ collectTarget.x = owner.x; collectTarget.y = owner.y; }

    // Attack cadence

    summon._lastAtk = summon._lastAtk || 0; summon._atkCD = summon._atkCD || (summon.attackCD||700);

    summon._lastAtk -= dt*1000; if(summon._lastAtk<=0 && nearEnemy && dist2(summon, nearEnemy)<(summon.attackRadius||200)**2){

      const dmg = (summon.dmg||30); nearEnemy.hp -= dmg; 

      global.showDamage?.(nearEnemy.x, nearEnemy.y, dmg, summon.color||'#fff');

      global.CinematicPrimitives?.burstSparks1?.(nearEnemy.x, nearEnemy.y, summon.color||'#fff', 8);

      summon._lastAtk = summon._atkCD;

    }

    Debugger.record(summon, {
      state,
      speed,
      targetType: state === 'collecting' ? 'loot' : state === 'hunting' ? 'enemy' : 'owner',
      ownerDist2: od2,
      closestMateDistance,
      hasLoot: !!collectTarget,
      lowHpFocus: !!lowHpEnemy,
    });

  }

  function tick(dt){ const S=gs(); const arr=S.summons||[]; for(const s of [...arr]){ if(!s||s.dead) continue; try{ updateSummon(s, dt); }catch(e){ console.debug('summon ai error',e); } } }

  const Mod = {
    tick,
    debug: Debugger,
  };

  ;(global.SummonAIPlus = Mod);

})(typeof window!=='undefined'?window:globalThis);

</script>

  <!-- Equipment System -->
  <!-- Inlined: src/assets/equipment_database.js -->
<script>
// ⚔️ EQUIPMENT DATABASE
// Traditional equipment: weapons, armor, and accessories

(function () {
  "use strict";

  // ========== EQUIPMENT DATABASE ==========

  const EQUIPMENT_DATABASE = {
    // ========== WEAPONS ==========

    // SWORDS
    weapon_fire_sword_c: {
      id: "weapon_fire_sword_c",
      name: "Flame Blade",
      type: "weapon",
      subtype: "sword",
      rarity: "C",
      element: "fire",
      stats: { attack: 30, critRate: 5 },
      sprite: { shape: "sword", color: "#ff6b35" },
    },

    weapon_fire_sword_b: {
      id: "weapon_fire_sword_b",
      name: "Inferno Sword",
      type: "weapon",
      subtype: "sword",
      rarity: "B",
      element: "fire",
      stats: { attack: 50, critRate: 10 },
      sprite: { shape: "sword", color: "#ff6b35" },
    },

    weapon_ice_sword_a: {
      id: "weapon_ice_sword_a",
      name: "Frost Blade",
      type: "weapon",
      subtype: "sword",
      rarity: "A",
      element: "ice",
      stats: { attack: 75, critRate: 15, slow: 20 },
      sprite: { shape: "sword", color: "#4ecdc4" },
    },

    weapon_lightning_sword_s: {
      id: "weapon_lightning_sword_s",
      name: "Thunder Edge",
      type: "weapon",
      subtype: "sword",
      rarity: "S",
      element: "lightning",
      stats: { attack: 100, critRate: 25, attackSpeed: 10 },
      sprite: { shape: "sword", color: "#ffeb3b" },
    },

    weapon_dark_sword_ss: {
      id: "weapon_dark_sword_ss",
      name: "Void Reaver",
      type: "weapon",
      subtype: "sword",
      rarity: "SS",
      element: "dark",
      stats: { attack: 150, critRate: 30, lifesteal: 15 },
      sprite: { shape: "sword", color: "#2c3e50" },
    },

    // GUNS
    weapon_fire_gun_c: {
      id: "weapon_fire_gun_c",
      name: "Ember Pistol",
      type: "weapon",
      subtype: "gun",
      rarity: "C",
      element: "fire",
      stats: { attack: 25, critRate: 10, range: 200 },
      sprite: { shape: "gun", color: "#ff6b35" },
    },

    weapon_ice_gun_b: {
      id: "weapon_ice_gun_b",
      name: "Frost Blaster",
      type: "weapon",
      subtype: "gun",
      rarity: "B",
      element: "ice",
      stats: { attack: 45, critRate: 15, range: 250, slow: 15 },
      sprite: { shape: "gun", color: "#4ecdc4" },
    },

    weapon_lightning_gun_a: {
      id: "weapon_lightning_gun_a",
      name: "Storm Rifle",
      type: "weapon",
      subtype: "gun",
      rarity: "A",
      element: "lightning",
      stats: { attack: 70, critRate: 20, range: 300, pierce: 1 },
      sprite: { shape: "gun", color: "#ffeb3b" },
    },

    weapon_light_gun_s: {
      id: "weapon_light_gun_s",
      name: "Radiant Cannon",
      type: "weapon",
      subtype: "gun",
      rarity: "S",
      element: "light",
      stats: { attack: 95, critRate: 25, range: 350, healOnHit: 5 },
      sprite: { shape: "gun", color: "#ffd93d" },
    },

    // STAVES
    weapon_nature_staff_b: {
      id: "weapon_nature_staff_b",
      name: "Verdant Staff",
      type: "weapon",
      subtype: "staff",
      rarity: "B",
      element: "nature",
      stats: { attack: 40, critRate: 8, healPower: 20 },
      sprite: { shape: "staff", color: "#4caf50" },
    },

    weapon_light_staff_a: {
      id: "weapon_light_staff_a",
      name: "Holy Rod",
      type: "weapon",
      subtype: "staff",
      rarity: "A",
      element: "light",
      stats: { attack: 65, critRate: 12, healPower: 35 },
      sprite: { shape: "staff", color: "#ffd93d" },
    },

    weapon_fusion_staff_sss: {
      id: "weapon_fusion_staff_sss",
      name: "Prismatic Scepter",
      type: "weapon",
      subtype: "staff",
      rarity: "SSS",
      element: "fusion",
      stats: { attack: 200, critRate: 40, healPower: 60, allElements: true },
      sprite: { shape: "staff", color: "#ff00ff" },
    },

    // ========== ARMOR ==========

    // CHEST
    armor_plate_chest_c: {
      id: "armor_plate_chest_c",
      name: "Iron Chestplate",
      type: "armor",
      slot: "chest",
      rarity: "C",
      stats: { defense: 20, hp: 50 },
      sprite: { shape: "chest", color: "#a0a0a0" },
    },

    armor_plate_chest_b: {
      id: "armor_plate_chest_b",
      name: "Steel Chestplate",
      type: "armor",
      slot: "chest",
      rarity: "B",
      stats: { defense: 35, hp: 100 },
      sprite: { shape: "chest", color: "#a0a0a0" },
    },

    armor_plate_chest_a: {
      id: "armor_plate_chest_a",
      name: "Mithril Chestplate",
      type: "armor",
      slot: "chest",
      rarity: "A",
      stats: { defense: 55, hp: 175 },
      sprite: { shape: "chest", color: "#a0a0a0" },
    },

    armor_plate_chest_s: {
      id: "armor_plate_chest_s",
      name: "Dragon Scale Armor",
      type: "armor",
      slot: "chest",
      rarity: "S",
      stats: { defense: 80, hp: 280, fireResist: 30 },
      sprite: { shape: "chest", color: "#a0a0a0" },
    },

    armor_plate_chest_ss: {
      id: "armor_plate_chest_ss",
      name: "Titan's Aegis",
      type: "armor",
      slot: "chest",
      rarity: "SS",
      stats: { defense: 120, hp: 450, allResist: 20 },
      sprite: { shape: "chest", color: "#a0a0a0" },
    },

    // HELMETS
    armor_helmet_c: {
      id: "armor_helmet_c",
      name: "Iron Helm",
      type: "armor",
      slot: "helmet",
      rarity: "C",
      stats: { defense: 15, hp: 30 },
      sprite: { shape: "helmet", color: "#a0a0a0" },
    },

    armor_helmet_b: {
      id: "armor_helmet_b",
      name: "Steel Helm",
      type: "armor",
      slot: "helmet",
      rarity: "B",
      stats: { defense: 25, hp: 60 },
      sprite: { shape: "helmet", color: "#a0a0a0" },
    },

    armor_helmet_a: {
      id: "armor_helmet_a",
      name: "Crusader's Crown",
      type: "armor",
      slot: "helmet",
      rarity: "A",
      stats: { defense: 40, hp: 100, critResist: 15 },
      sprite: { shape: "helmet", color: "#a0a0a0" },
    },

    armor_helmet_s: {
      id: "armor_helmet_s",
      name: "Phoenix Crown",
      type: "armor",
      slot: "helmet",
      rarity: "S",
      stats: { defense: 60, hp: 170, critResist: 25, reviveOnce: true },
      sprite: { shape: "helmet", color: "#a0a0a0" },
    },

    // ========== ACCESSORIES ==========

    // RINGS
    accessory_power_ring_c: {
      id: "accessory_power_ring_c",
      name: "Bronze Ring",
      type: "accessory",
      slot: "ring",
      rarity: "C",
      element: "physical",
      stats: { attack: 10, speed: 2 },
      sprite: { shape: "ring", color: "#cd7f32" },
    },

    accessory_power_ring_b: {
      id: "accessory_power_ring_b",
      name: "Silver Ring",
      type: "accessory",
      slot: "ring",
      rarity: "B",
      element: "physical",
      stats: { attack: 20, speed: 5 },
      sprite: { shape: "ring", color: "#c0c0c0" },
    },

    accessory_power_ring_a: {
      id: "accessory_power_ring_a",
      name: "Gold Ring",
      type: "accessory",
      slot: "ring",
      rarity: "A",
      element: "physical",
      stats: { attack: 35, speed: 8, critRate: 5 },
      sprite: { shape: "ring", color: "#ffd700" },
    },

    accessory_fire_ring_s: {
      id: "accessory_fire_ring_s",
      name: "Ring of Flames",
      type: "accessory",
      slot: "ring",
      rarity: "S",
      element: "fire",
      stats: { attack: 50, speed: 12, critRate: 10, fireDamage: 20 },
      sprite: { shape: "ring", color: "#ff6b35" },
    },

    accessory_fusion_ring_sss: {
      id: "accessory_fusion_ring_sss",
      name: "Cosmic Band",
      type: "accessory",
      slot: "ring",
      rarity: "SSS",
      element: "fusion",
      stats: {
        attack: 100,
        speed: 20,
        critRate: 30,
        allDamage: 50,
        allElements: true,
      },
      sprite: { shape: "ring", color: "#ff00ff" },
    },

    // AMULETS
    accessory_health_amulet_b: {
      id: "accessory_health_amulet_b",
      name: "Vitality Amulet",
      type: "accessory",
      slot: "amulet",
      rarity: "B",
      element: "nature",
      stats: { hp: 100, hpRegen: 5 },
      sprite: { shape: "amulet", color: "#4caf50" },
    },

    accessory_light_amulet_a: {
      id: "accessory_light_amulet_a",
      name: "Radiant Pendant",
      type: "accessory",
      slot: "amulet",
      rarity: "A",
      element: "light",
      stats: { hp: 150, hpRegen: 10, healPower: 15 },
      sprite: { shape: "amulet", color: "#ffd93d" },
    },

    accessory_dark_amulet_s: {
      id: "accessory_dark_amulet_s",
      name: "Void Talisman",
      type: "accessory",
      slot: "amulet",
      rarity: "S",
      element: "dark",
      stats: { hp: 200, lifesteal: 20, darkDamage: 30 },
      sprite: { shape: "amulet", color: "#2c3e50" },
    },

    // BELTS
    accessory_defense_belt_b: {
      id: "accessory_defense_belt_b",
      name: "Guardian Belt",
      type: "accessory",
      slot: "belt",
      rarity: "B",
      element: "physical",
      stats: { defense: 25, damageReduction: 5 },
      sprite: { shape: "belt", color: "#8b4513" },
    },

    accessory_speed_belt_a: {
      id: "accessory_speed_belt_a",
      name: "Swift Sash",
      type: "accessory",
      slot: "belt",
      rarity: "A",
      element: "lightning",
      stats: { defense: 35, speed: 15, dodge: 10 },
      sprite: { shape: "belt", color: "#ffeb3b" },
    },

    accessory_legendary_belt_ss: {
      id: "accessory_legendary_belt_ss",
      name: "Champion's Girdle",
      type: "accessory",
      slot: "belt",
      rarity: "SS",
      element: "fusion",
      stats: {
        defense: 80,
        speed: 25,
        dodge: 20,
        allStats: 10,
      },
      sprite: { shape: "belt", color: "#ffd700" },
    },
  };

  // ========== UTILITY FUNCTIONS ==========

  function getEquipmentById(id) {
    return EQUIPMENT_DATABASE[id] || null;
  }

  function getEquipmentByType(type) {
    return Object.values(EQUIPMENT_DATABASE).filter((eq) => eq.type === type);
  }

  function getEquipmentByRarity(rarity) {
    return Object.values(EQUIPMENT_DATABASE).filter(
      (eq) => eq.rarity === rarity
    );
  }

  function getWeapons() {
    return getEquipmentByType("weapon");
  }

  function getArmor() {
    return getEquipmentByType("armor");
  }

  function getAccessories() {
    return getEquipmentByType("accessory");
  }

  function getAllEquipment() {
    return Object.values(EQUIPMENT_DATABASE);
  }

  // ========== EXPORTS ==========

  window.EQUIPMENT_DATABASE = EQUIPMENT_DATABASE;
  window.EquipmentDB = {
    getEquipmentById,
    getEquipmentByType,
    getEquipmentByRarity,
    getWeapons,
    getArmor,
    getAccessories,
    getAllEquipment,
  };

  console.log(
    "⚔️ Equipment Database loaded: " +
      Object.keys(EQUIPMENT_DATABASE).length +
      " items"
  );
})();

</script>
  <!-- Inlined: src/utils/core_sprite_integration.js -->
<script>
// 🎨 CORE SPRITE INTEGRATION
// Adds sprite properties to existing CORE_DATABASE

(function () {
  "use strict";

  // Function to enhance cores with sprite data
  function enhanceCoresWithSprites() {
    if (!window.CORE_DATABASE) {
      console.warn("CORE_DATABASE not found, waiting...");
      setTimeout(enhanceCoresWithSprites, 100);
      return;
    }

    const CORE_DATABASE = window.CORE_DATABASE;
    let enhancedCount = 0;

    // Enhance each core with sprite data
    Object.keys(CORE_DATABASE).forEach((coreId) => {
      const core = CORE_DATABASE[coreId];

      // Skip if already has sprite data
      if (core.sprite) return;

      // Determine element from ID
      let element = "fire"; // default
      let shape = "flame";

      if (coreId.includes("fire")) {
        element = "fire";
        shape = "flame";
      } else if (coreId.includes("ice") || coreId.includes("frost")) {
        element = "ice";
        shape = "snowflake";
      } else if (coreId.includes("lightning") || coreId.includes("thunder")) {
        element = "lightning";
        shape = "bolt";
      } else if (coreId.includes("nature") || coreId.includes("forest")) {
        element = "nature";
        shape = "leaf";
      } else if (coreId.includes("dark") || coreId.includes("void")) {
        element = "dark";
        shape = "void";
      } else if (coreId.includes("light") || coreId.includes("holy")) {
        element = "light";
        shape = "radiance";
      } else if (coreId.includes("advanced")) {
        element = "advanced";
        shape = "hexagon";
      } else if (coreId.includes("fusion") || coreId.includes("cosmic")) {
        element = "fusion";
        shape = "prismatic";
      }

      // Add sprite data
      core.sprite = {
        element: element,
        shape: shape,
        size: 32,
      };

      // Add element property if missing
      if (!core.element) {
        core.element = element;
      }

      enhancedCount++;
    });

    console.log(`🎨 Enhanced ${enhancedCount} cores with sprite data`);
  }

  // Run enhancement when page loads
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", enhanceCoresWithSprites);
  } else {
    enhanceCoresWithSprites();
  }
})();

</script>
  <!-- Inlined: src/assets/equipment_drops.js -->
<script>
// 💎 EQUIPMENT DROPS SYSTEM
// Handles equipment drops with floating sprite icons

(function () {
  "use strict";

  // ========== EQUIPMENT DROP SPAWNING ==========

  function spawnEquipmentDrop(equipment, x, y) {
    const st = gameState();
    if (!st.items) st.items = [];

    // Create floating equipment item
    const drop = {
      type: "equipment",
      equipmentId: equipment.id,
      equipmentData: equipment,
      x: x,
      y: y,
      vy: -3, // Initial upward velocity
      vx: (Math.random() - 0.5) * 2, // Slight horizontal spread
      floatOffset: 0, // For bobbing animation
      floatSpeed: 0.05 + Math.random() * 0.03, // Varied bobbing speed
      floatPhase: Math.random() * Math.PI * 2, // Random start phase
      spawnTime: Date.now(),
      gravity: 0.15, // Fall speed
      rarity: equipment.rarity,
      collected: false,
      collectionRadius: 40, // Pickup radius
    };

    st.items.push(drop);
    return drop;
  }

  // Spawn random equipment drop
  function spawnRandomEquipmentDrop(x, y, rarityBoost = 0) {
    // Determine rarity (higher rarityBoost = better drops)
    const rand = Math.random() + rarityBoost;
    let rarity = "C";

    if (rand > 0.95) rarity = "SSS";
    else if (rand > 0.9) rarity = "SS";
    else if (rand > 0.85) rarity = "S+";
    else if (rand > 0.75) rarity = "S";
    else if (rand > 0.6) rarity = "A";
    else if (rand > 0.4) rarity = "B";

    // Get random equipment of that rarity
    let equipment;

    if (window.CORE_DATABASE && Math.random() > 0.5) {
      // 50% chance for core
      const cores = Object.values(window.CORE_DATABASE).filter(
        (c) => c.rarity === rarity
      );
      if (cores.length > 0) {
        equipment = cores[Math.floor(Math.random() * cores.length)];
      }
    }

    if (!equipment && window.EQUIPMENT_DATABASE) {
      // Get traditional equipment
      const items = Object.values(window.EQUIPMENT_DATABASE).filter(
        (e) => e.rarity === rarity
      );
      if (items.length > 0) {
        equipment = items[Math.floor(Math.random() * items.length)];
      }
    }

    // Fallback to any equipment
    if (!equipment) {
      const allEquipment = [
        ...(window.CORE_DATABASE ? Object.values(window.CORE_DATABASE) : []),
        ...(window.EQUIPMENT_DATABASE ? Object.values(window.EQUIPMENT_DATABASE) : []),
      ];
      if (allEquipment.length > 0) {
        equipment = allEquipment[Math.floor(Math.random() * allEquipment.length)];
      }
    }

    if (equipment) {
      return spawnEquipmentDrop(equipment, x, y);
    }

    return null;
  }

  // ========== EQUIPMENT DROP RENDERING ==========

  function renderEquipmentDrops(ctx) {
    const st = gameState();
    if (!st.items) return;

    const now = Date.now();

    st.items.forEach((item, index) => {
      if (item.type !== "equipment") return;
      if (item.collected) return;

      // Update physics
      item.vy += item.gravity; // Apply gravity
      item.y += item.vy;
      item.x += item.vx;

      // Friction
      item.vx *= 0.98;
      item.vy *= 0.98;

      // Ground collision (approximate)
      const groundY = 500; // Adjust based on your game
      if (item.y > groundY) {
        item.y = groundY;
        item.vy = 0;
        item.vx = 0;
      }

      // Bobbing animation
      const age = (now - item.spawnTime) / 1000;
      item.floatPhase += item.floatSpeed;
      const bobOffset = Math.sin(item.floatPhase) * 3;

      // Render position (with bobbing)
      const renderY = item.y + bobOffset;

      // Draw rarity glow pulse
      const glowAlpha = 0.3 + Math.sin(now / 500) * 0.2;
      const glowRadius = 20 + Math.sin(now / 300) * 5;

      ctx.save();
      ctx.globalAlpha = glowAlpha;

      // Glow color based on rarity
      let glowColor = "#808080"; // Default gray
      if (window.EquipmentSprites && window.EquipmentSprites.RARITY_BORDERS) {
        const rarityData = window.EquipmentSprites.RARITY_BORDERS[item.rarity];
        if (rarityData) {
          glowColor = rarityData.color === "rainbow" ? "#ff00ff" : rarityData.color;
        }
      }

      const gradient = ctx.createRadialGradient(item.x, renderY, 0, item.x, renderY, glowRadius);
      gradient.addColorStop(0, glowColor);
      gradient.addColorStop(1, "rgba(0,0,0,0)");
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(item.x, renderY, glowRadius, 0, Math.PI * 2);
      ctx.fill();

      ctx.globalAlpha = 1;
      ctx.restore();

      // Draw equipment sprite
      if (window.EquipmentSprites && item.equipmentData) {
        window.EquipmentSprites.renderEquipmentSprite(
          ctx,
          item.equipmentData,
          item.x,
          renderY,
          32
        );
      } else {
        // Fallback: draw colored circle
        ctx.fillStyle = glowColor;
        ctx.beginPath();
        ctx.arc(item.x, renderY, 12, 0, Math.PI * 2);
        ctx.fill();
      }

      // Draw equipment name above sprite (if player is nearby)
      const player = st.players && st.players[st.leader || 0];
      if (player) {
        const dx = player.x - item.x;
        const dy = player.y - item.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < 100) {
          // Player nearby, show name
          ctx.save();
          ctx.font = "bold 10px Arial";
          ctx.textAlign = "center";
          ctx.fillStyle = "#ffffff";
          ctx.strokeStyle = "#000000";
          ctx.lineWidth = 3;

          const name = item.equipmentData.name || "Equipment";
          ctx.strokeText(name, item.x, renderY - 25);
          ctx.fillText(name, item.x, renderY - 25);

          // Show rarity
          ctx.font = "8px Arial";
          const rarityText = `[${item.rarity}]`;
          ctx.strokeText(rarityText, item.x, renderY - 15);
          ctx.fillStyle = glowColor;
          ctx.fillText(rarityText, item.x, renderY - 15);

          ctx.restore();
        }
      }

      // Auto-collect if player touches
      if (player) {
        const dx = player.x - item.x;
        const dy = player.y - item.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < item.collectionRadius) {
          collectEquipment(item, player);
          item.collected = true;
        }
      }
    });

    // Remove collected items
    st.items = st.items.filter((item) => {
      if (item.type === "equipment" && item.collected) return false;
      return true;
    });
  }

  // ========== EQUIPMENT COLLECTION ==========

  function collectEquipment(drop, player) {
    if (!drop.equipmentData) return;

    // Add to player inventory
    if (!player.inventory) player.inventory = [];
    player.inventory.push(drop.equipmentData);

    // Visual feedback
    showMessage(`Collected ${drop.equipmentData.name}!`);

    // Collection particles
    const st = gameState();
    st.effects = st.effects || [];

    for (let i = 0; i < 10; i++) {
      st.effects.push({
        kind: "collect_particle",
        x: drop.x + (Math.random() - 0.5) * 20,
        y: drop.y + (Math.random() - 0.5) * 20,
        vx: (Math.random() - 0.5) * 3,
        vy: -Math.random() * 3,
        color: window.EquipmentSprites?.RARITY_BORDERS[drop.rarity]?.color || "#ffd700",
        life: 500,
        max: 500,
      });
    }

    console.log(`✅ ${player.id || "Player"} collected ${drop.equipmentData.name}`);
  }

  // ========== INTEGRATION WITH GAME LOOP ==========

  // Hook into game's render loop
  function integrateWithGameLoop() {
    // Try to find and enhance the main render function
    if (typeof window.renderEquipmentDrops === "undefined") {
      window.renderEquipmentDrops = renderEquipmentDrops;
    }

    console.log("💎 Equipment Drops System integrated");
  }

  // ========== EXPORTS ==========

  window.EquipmentDrops = {
    spawnEquipmentDrop,
    spawnRandomEquipmentDrop,
    renderEquipmentDrops,
    collectEquipment,
  };

  // Initialize
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", integrateWithGameLoop);
  } else {
    integrateWithGameLoop();
  }

  console.log("💎 Equipment Drops System loaded");
})();


</script>
  <!-- Inlined: src/ui/equipment_inventory_ui.js -->
<script>
// 🎒 EQUIPMENT INVENTORY UI
// Renders equipment sprites in inventory interface

(function () {
  "use strict";

  // ========== INVENTORY UI RENDERING ==========

  function renderEquipmentSlots(ctx, player, x, y) {
    if (!player) return;

    const slotSize = 48;
    const slotSpacing = 56;
    const slots = [
      { key: "weaponCore", label: "Weapon 1" },
      { key: "weapon2Core", label: "Weapon 2" },
      { key: "vehicleCore", label: "Vehicle" },
      { key: "petCore", label: "Pet" },
    ];

    slots.forEach((slot, index) => {
      const slotX = x + index * slotSpacing;
      const slotY = y;

      // Draw slot background
      ctx.fillStyle = "#1a1a1a";
      ctx.fillRect(slotX - slotSize / 2, slotY - slotSize / 2, slotSize, slotSize);

      // Draw slot border
      ctx.strokeStyle = "#666666";
      ctx.lineWidth = 2;
      ctx.strokeRect(slotX - slotSize / 2, slotY - slotSize / 2, slotSize, slotSize);

      // Get equipped item
      const equippedItem = player.equipment && player.equipment[slot.key];

      if (equippedItem) {
        // Render equipment sprite
        if (window.EquipmentSprites) {
          window.EquipmentSprites.renderEquipmentSprite(
            ctx,
            equippedItem,
            slotX,
            slotY,
            slotSize - 8
          );
        }
      } else {
        // Draw empty slot icon
        ctx.fillStyle = "#333333";
        ctx.font = "12px Arial";
        ctx.textAlign = "center";
        ctx.fillText("+", slotX, slotY + 4);
      }

      // Draw slot label
      ctx.fillStyle = "#ffffff";
      ctx.font = "8px Arial";
      ctx.textAlign = "center";
      ctx.fillText(slot.label, slotX, slotY + slotSize / 2 + 12);
    });
  }

  function renderInventoryGrid(ctx, player, x, y, columns = 6) {
    if (!player || !player.inventory) return;

    const slotSize = 40;
    const slotSpacing = 44;
    const inventory = player.inventory || [];

    inventory.forEach((item, index) => {
      const col = index % columns;
      const row = Math.floor(index / columns);
      const slotX = x + col * slotSpacing;
      const slotY = y + row * slotSpacing;

      // Draw slot background
      ctx.fillStyle = "#2a2a2a";
      ctx.fillRect(slotX - slotSize / 2, slotY - slotSize / 2, slotSize, slotSize);

      // Draw slot border
      ctx.strokeStyle = "#555555";
      ctx.lineWidth = 1;
      ctx.strokeRect(slotX - slotSize / 2, slotY - slotSize / 2, slotSize, slotSize);

      // Render equipment sprite
      if (window.EquipmentSprites) {
        window.EquipmentSprites.renderEquipmentSprite(
          ctx,
          item,
          slotX,
          slotY,
          slotSize - 4
        );
      }
    });
  }

  // ========== EQUIPMENT TOOLTIP ==========

  function renderEquipmentTooltip(ctx, equipment, x, y) {
    if (!equipment) return;

    const width = 200;
    const height = 120;

    // Draw tooltip background
    ctx.fillStyle = "rgba(0, 0, 0, 0.9)";
    ctx.fillRect(x, y, width, height);

    // Draw tooltip border (rarity color)
    let borderColor = "#808080";
    if (window.EquipmentSprites && window.EquipmentSprites.RARITY_BORDERS) {
      const rarityData = window.EquipmentSprites.RARITY_BORDERS[equipment.rarity];
      if (rarityData) {
        borderColor = rarityData.color === "rainbow" ? "#ff00ff" : rarityData.color;
      }
    }

    ctx.strokeStyle = borderColor;
    ctx.lineWidth = 2;
    ctx.strokeRect(x, y, width, height);

    // Draw equipment name
    ctx.fillStyle = borderColor;
    ctx.font = "bold 14px Arial";
    ctx.textAlign = "left";
    ctx.fillText(equipment.name, x + 10, y + 20);

    // Draw rarity
    ctx.fillStyle = "#cccccc";
    ctx.font = "10px Arial";
    const rarityName = window.EquipmentSprites?.RARITY_BORDERS[equipment.rarity]?.name || equipment.rarity;
    ctx.fillText(`[${rarityName}]`, x + 10, y + 35);

    // Draw stats
    let statY = y + 55;
    ctx.fillStyle = "#ffffff";
    ctx.font = "10px Arial";

    if (equipment.stats) {
      Object.keys(equipment.stats).forEach((stat) => {
        const value = equipment.stats[stat];
        const statText = `${stat}: +${value}`;
        ctx.fillText(statText, x + 10, statY);
        statY += 15;
      });
    }

    // Draw element if present
    if (equipment.element) {
      ctx.fillStyle = "#ffaa00";
      ctx.fillText(`Element: ${equipment.element}`, x + 10, statY);
    }
  }

  // ========== HTML INTEGRATION ==========

  function createInventoryUI() {
    // Check if inventory UI already exists
    if (document.getElementById("equipment-inventory-ui")) return;

    // Create inventory UI container
    const inventoryUI = document.createElement("div");
    inventoryUI.id = "equipment-inventory-ui";
    inventoryUI.style.cssText = `
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0, 0, 0, 0.95);
      border: 3px solid #666;
      border-radius: 10px;
      padding: 20px;
      display: none;
      z-index: 1000;
      min-width: 400px;
      min-height: 300px;
    `;

    // Create canvas for rendering equipment sprites
    const canvas = document.createElement("canvas");
    canvas.width = 600;
    canvas.height = 500;
    canvas.id = "inventory-canvas";
    inventoryUI.appendChild(canvas);

    // Create close button
    const closeBtn = document.createElement("button");
    closeBtn.textContent = "Close (I)";
    closeBtn.style.cssText = `
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 5px 10px;
      background: #ff4444;
      border: none;
      color: white;
      cursor: pointer;
      border-radius: 5px;
    `;
    closeBtn.onclick = () => toggleInventoryUI();
    inventoryUI.appendChild(closeBtn);

    document.body.appendChild(inventoryUI);

    console.log("🎒 Equipment Inventory UI created");
  }

  function toggleInventoryUI() {
    const ui = document.getElementById("equipment-inventory-ui");
    if (!ui) {
      createInventoryUI();
      return;
    }

    if (ui.style.display === "none") {
      ui.style.display = "block";
      updateInventoryUI();
    } else {
      ui.style.display = "none";
    }
  }

  function updateInventoryUI() {
    const canvas = document.getElementById("inventory-canvas");
    if (!canvas) return;

    const ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Get player
    const st = gameState();
    const player = st.players && st.players[st.leader || 0];
    if (!player) return;

    // Draw title
    ctx.fillStyle = "#ffffff";
    ctx.font = "bold 20px Arial";
    ctx.textAlign = "center";
    ctx.fillText("Equipment Inventory", canvas.width / 2, 30);

    // Draw equipped slots
    ctx.font = "bold 14px Arial";
    ctx.textAlign = "left";
    ctx.fillText("Equipped:", 20, 70);
    renderEquipmentSlots(ctx, player, 120, 90);

    // Draw inventory grid
    ctx.fillText("Inventory:", 20, 160);
    renderInventoryGrid(ctx, player, 60, 190, 8);
  }

  // Keyboard shortcut to open inventory (I key)
  document.addEventListener("keydown", (e) => {
    if (e.key === "i" || e.key === "I") {
      toggleInventoryUI();
    }
  });

  // ========== EXPORTS ==========

  window.EquipmentInventoryUI = {
    renderEquipmentSlots,
    renderInventoryGrid,
    renderEquipmentTooltip,
    createInventoryUI,
    toggleInventoryUI,
    updateInventoryUI,
  };

  // Initialize
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", createInventoryUI);
  } else {
    createInventoryUI();
  }

  console.log("🎒 Equipment Inventory UI loaded");
})();


</script>

  <!-- ===== ENHANCED SUMMON COMBAT SYSTEM ===== -->
  <!-- Makes clones chase enemies, enemies target summons, adds RED projectile attacks -->
  <!-- Inlined: src/systems/summon-combat-enhanced.js -->
<script>
// ⚔️ ENHANCED SUMMON COMBAT SYSTEM
// Makes clones chase enemies, enemies target summons, and gives summons projectile attacks
(function () {
  "use strict";

  const now = () => performance.now?.() || Date.now();
  const dist = (a, b) =>
    Math.hypot((a.x || 0) - (b.x || 0), (a.y || 0) - (b.y || 0));

  // ===== SUMMON CHASE AI =====
  function updateSummonChaseAI(summon, dtMs) {
    if (!summon || summon.dead) return;
    const st = window.st;
    if (!st) return;

    const dt = dtMs / 1000;
    const owner = summon.owner;

    // Find nearest enemy to chase
    const enemies = (st.enemies || []).filter((e) => e && !e.dead && e.hp > 0);
    
    // Check for loot (gold, items, chests)
    const loot = [];
    if (st.drops) {
      loot.push(...st.drops.filter(d => d && !d.collected && dist(summon, d) < 400));
    }
    if (st.chests) {
      loot.push(...st.chests.filter(c => c && !c.opened && dist(summon, c) < 300));
    }

    if (enemies.length === 0 && loot.length === 0) {
      // No enemies or loot - return to owner
      if (owner) {
        const dx = owner.x - summon.x;
        const dy = owner.y - summon.y;
        const distance = Math.hypot(dx, dy);
        
        // Only move if far from owner
        if (distance > 100) {
          summon.x += dx * 0.15 * dt * 60;
          summon.y += dy * 0.15 * dt * 60;
          summon.mode = "following";
        } else {
          summon.mode = "idle";
        }
      }
      return;
    }

    // CLONES: Aggressive melee hunters with loot collection
    if (summon.type === "clone") {
      // Priority 1: Collect nearby loot
      if (loot.length > 0) {
        const nearestLoot = loot.reduce((nearest, l) => {
          const d = dist(summon, l);
          return d < dist(summon, nearest) ? l : nearest;
        });
        
        const lootDist = dist(summon, nearestLoot);
        if (lootDist < 30) {
          // Collect loot
          if (nearestLoot.gold) {
            st.gold = (st.gold || 0) + nearestLoot.gold;
            nearestLoot.collected = true;
          }
          if (nearestLoot.opened !== undefined) {
            nearestLoot.opened = true;
          }
          summon.lootCollected = (summon.lootCollected || 0) + 1;
        } else {
          // Rush to loot
          const dx = nearestLoot.x - summon.x;
          const dy = nearestLoot.y - summon.y;
          const angle = Math.atan2(dy, dx);
          summon.x += Math.cos(angle) * 0.28 * dt * 60; // Fast loot collection
          summon.y += Math.sin(angle) * 0.28 * dt * 60;
          summon.facingLeft = dx < 0;
          summon.mode = "looting";
        }
        return;
      }

      // Priority 2: Hunt enemies aggressively
      if (enemies.length > 0) {
        let nearestEnemy = null;
        let minDist = Infinity;
        for (const e of enemies) {
          const d = dist(summon, e);
          if (d < minDist) {
            minDist = d;
            nearestEnemy = e;
          }
        }

        if (!nearestEnemy) return;

        summon.target = nearestEnemy;
        const meleeRange = 70; // Close range for sword attacks
        const rangedRange = 250; // Extended projectile range

        if (minDist <= meleeRange) {
          // MELEE RANGE: Sword attacks while staying close
          summon.mode = "melee";
          summon.inMeleeRange = true;
          
          // Stay close to enemy, slight circle movement
          const strafeAngle = now() * 0.001 + (summon.id || 0);
          const strafeRadius = meleeRange * 0.6;
          const targetX = nearestEnemy.x + Math.cos(strafeAngle) * strafeRadius;
          const targetY = nearestEnemy.y + Math.sin(strafeAngle) * strafeRadius;
          
          summon.x += (targetX - summon.x) * 0.18 * dt * 60;
          summon.y += (targetY - summon.y) * 0.18 * dt * 60;
          summon.facingLeft = nearestEnemy.x < summon.x;
          
          // Melee attack happens in update function
        } else if (minDist <= rangedRange) {
          // RANGED: Fire projectiles while advancing
          summon.mode = "ranged";
          summon.inMeleeRange = false;
          
          const dx2 = nearestEnemy.x - summon.x;
          const dy2 = nearestEnemy.y - summon.y;
          const angle2 = Math.atan2(dy2, dx2);
          
          // Advance while keeping distance for shooting
          if (minDist > 120) {
            summon.x += Math.cos(angle2) * 0.15 * dt * 60;
            summon.y += Math.sin(angle2) * 0.15 * dt * 60;
          }
          summon.facingLeft = dx2 < 0;
          summon.chasing = true;
          
          // Projectile shooting happens in update function
        } else {
          // FAR: Aggressive chase
          summon.mode = "hunting";
          summon.inMeleeRange = false;
          
          const dx3 = nearestEnemy.x - summon.x;
          const dy3 = nearestEnemy.y - summon.y;
          const angle3 = Math.atan2(dy3, dx3);
          
          summon.x += Math.cos(angle3) * 0.25 * dt * 60; // Fast pursuit
          summon.y += Math.sin(angle3) * 0.25 * dt * 60;
          summon.facingLeft = dx3 < 0;
          summon.chasing = true;
        }
        
        // Keep in bounds
        summon.x = Math.max(40, Math.min(1240, summon.x));
        summon.y = Math.max(40, Math.min(680, summon.y));
        return;
      }
    }

    // Select closest enemy (for non-clones)
    let nearestEnemy = null;
    let minDist = Infinity;
    for (const e of enemies) {
      const d = dist(summon, e);
      if (d < minDist) {
        minDist = d;
        nearestEnemy = e;
      }
    }

    if (!nearestEnemy) return;

    // Chase behavior based on summon type
    const attackRange =
      summon.type === "drone" ? 280 : summon.type === "pet" ? 220 : 80;
    const chaseSpeed =
      summon.type === "drone" ? 0.25 : summon.type === "pet" ? 0.22 : 0.18;

    if (minDist > attackRange) {
      // CHASE: Move toward enemy aggressively
      const dx = nearestEnemy.x - summon.x;
      const dy = nearestEnemy.y - summon.y;
      const angle = Math.atan2(dy, dx);

      summon.x += Math.cos(angle) * chaseSpeed * dt * 60;
      summon.y += Math.sin(angle) * chaseSpeed * dt * 60;

      // Face enemy
      summon.facingLeft = dx < 0;
      summon.chasing = true;
      summon.target = nearestEnemy;
    } else {
      // IN RANGE: Attack position (orbit/strafe)
      summon.chasing = false;
      summon.target = nearestEnemy;

      // Orbit enemy at attack range
      const orbitAngle = now() * 0.001 + (summon.id || 0) * 0.5;
      const orbitRadius = attackRange * 0.8;
      const targetX = nearestEnemy.x + Math.cos(orbitAngle) * orbitRadius;
      const targetY = nearestEnemy.y + Math.sin(orbitAngle) * orbitRadius;

      summon.x += (targetX - summon.x) * 0.12 * dt * 60;
      summon.y += (targetY - summon.y) * 0.12 * dt * 60;
    }

    // Keep in bounds
    summon.x = Math.max(40, Math.min(1240, summon.x));
    summon.y = Math.max(40, Math.min(680, summon.y));
  }

  // ===== MELEE ATTACK SYSTEM FOR CLONES =====
  function performMeleeAttack(summon, enemy) {
    const t = now();
    const meleeCD = 450; // Fast melee attacks
    
    if (summon._lastMelee && t - summon._lastMelee < meleeCD) return;
    summon._lastMelee = t;
    
    const st = window.st;
    if (!st) return;
    
    // Calculate melee damage
    const baseDmg = (summon.dmg || 40) * 1.2; // 20% bonus for melee
    const isCrit = Math.random() < 0.35; // 35% crit chance in melee
    const finalDmg = Math.round(baseDmg * (isCrit ? 2.0 : 1.0));
    
    // Apply damage
    enemy.hp -= finalDmg;
    
    // Damage number
    if (window.showDamage) {
      window.showDamage(
        enemy.x,
        enemy.y - 30,
        finalDmg,
        isCrit ? "#ffff00" : "#ff4444"
      );
    }
    
    // Sword slash VFX
    if (window.VFX) {
      if (window.VFX.Particles) {
        window.VFX.Particles.emit("slash", enemy.x, enemy.y, {
          count: isCrit ? 12 : 6,
          color: isCrit ? "#ffff00" : "#ff0000",
          speed: isCrit ? 3 : 2
        });
        
        if (isCrit) {
          window.VFX.Particles.emit("sparkle", enemy.x, enemy.y, {
            count: 8,
            color: "#ffff00"
          });
        }
      }
      
      if (window.VFX.Camera && isCrit) {
        window.VFX.Camera.shake(4, 120, 18);
      }
    }
    
    // Slash effect arc
    if (!st.effects) st.effects = [];
    const angle = Math.atan2(enemy.y - summon.y, enemy.x - summon.x);
    st.effects.push({
      kind: "slash_arc",
      x: summon.x + Math.cos(angle) * 30,
      y: summon.y + Math.sin(angle) * 30,
      angle: angle,
      color: isCrit ? "#ffff00" : "#ff0000",
      size: isCrit ? 50 : 35,
      life: 150,
      max: 150
    });
    
    // Track melee stats
    summon.meleeHits = (summon.meleeHits || 0) + 1;
    summon.meleeDamage = (summon.meleeDamage || 0) + finalDmg;
    if (isCrit) summon.meleeCrits = (summon.meleeCrits || 0) + 1;
  }

  // ===== SUMMON PROJECTILE SYSTEM =====
  function fireSummonProjectile(summon) {
    if (!summon || !summon.target) return;
    const st = window.st;
    if (!st) return;

    // Cooldown check
    const t = now();
    if (summon._lastShot && t - summon._lastShot < (summon.attackCD || 800))
      return;
    summon._lastShot = t;

    const target = summon.target;
    const dx = target.x - summon.x;
    const dy = target.y - summon.y;
    const angle = Math.atan2(dy, dx);
    const distance = Math.hypot(dx, dy);

    // Projectile configuration by type
    let projectileConfig;
    let burstCount = 1; // Default single shot

    switch (summon.type) {
      case "drone": // UNIQUE - Combat Drones (RED triple laser bursts)
        // Drones fire 3-shot burst
        burstCount = 3;
        const spread = 0.15; // Spread angle

        for (let i = 0; i < burstCount; i++) {
          const burstAngle = angle + (i - 1) * spread;
          projectileConfig = {
            kind: "drone_laser",
            x: summon.x + Math.cos(burstAngle) * 15,
            y: summon.y + Math.sin(burstAngle) * 15,
            vx: Math.cos(burstAngle) * 720,
            vy: Math.sin(burstAngle) * 720,
            speed: 720,
            dmg: Math.round((summon.dmg || 35) * 0.85), // Slightly reduced per shot
            life: 1800,
            w: 22,
            h: 14,
            color: "#ff0000", // RED as requested
            glowColor: "#ff4444",
            pierce: 3,
            homing: 0.04,
            ownerId: summon.owner?.id || "drone",
            summonId: summon.id,
            isSummonShot: true,
          };

          if (!st.shots) st.shots = [];
          st.shots.push(projectileConfig);
        }
        projectileConfig = null; // Already added in loop
        break;

      case "pet": // MISSY - Battle Pets (RED homing energy orbs)
        // Smart targeting - track moving enemies
        const leadTime = distance / 580;
        const predictedX = target.x + (target.vx || 0) * leadTime;
        const predictedY = target.y + (target.vy || 0) * leadTime;
        const leadAngle = Math.atan2(
          predictedY - summon.y,
          predictedX - summon.x
        );

        projectileConfig = {
          kind: "pet_orb",
          x: summon.x,
          y: summon.y,
          vx: Math.cos(leadAngle) * 580,
          vy: Math.sin(leadAngle) * 580,
          speed: 580,
          dmg: summon.dmg || 40,
          life: 2400,
          w: 26,
          h: 26,
          color: "#ff0000", // RED as requested
          glowColor: "#ff6666",
          pierce: 2,
          homing: 0.06, // Strong homing
          tracking: true,
          neverMiss: true, // Missy's luck
          ownerId: summon.owner?.id || "pet",
          summonId: summon.id,
          isSummonShot: true,
          trail: [],
          trailSteps: 10,
        };
        break;

      case "clone": // A1 - Shadow Clones (RED critical slashes + sword wielding)
        // Track shot counter for melee transition
        if (!summon._projectileCount) summon._projectileCount = 0;
        
        // After 2 projectiles, force into melee range
        if (summon._projectileCount >= 2 && distance < 150) {
          summon._shouldMelee = true;
          return; // Skip projectile, will melee instead
        }
        
        // Clones have chance to fire critical projectile
        const isCrit = Math.random() < 0.25; // 25% crit chance
        
        // Increment projectile counter
        summon._projectileCount++;

        projectileConfig = {
          kind: "clone_slash",
          x: summon.x + Math.cos(angle) * 20,
          y: summon.y + Math.sin(angle) * 20,
          vx: Math.cos(angle) * (isCrit ? 850 : 680),
          vy: Math.sin(angle) * (isCrit ? 850 : 680),
          speed: isCrit ? 850 : 680,
          dmg: (summon.dmg || 40) * (isCrit ? 1.8 : 1.0), // Buffed damage
          life: isCrit ? 2200 : 1700,
          w: isCrit ? 48 : 36,
          h: isCrit ? 42 : 32,
          color: "#ff0000", // RED sword slash
          glowColor: isCrit ? "#ffff00" : "#ff4444",
          pierce: isCrit ? 4 : 2,
          critical: isCrit,
          ownerId: summon.owner?.id || "clone",
          summonId: summon.id,
          isSummonShot: true,
          swordSlash: true, // Mark as sword attack
        };

        // Critical hit extra effects
        if (isCrit && window.VFX) {
          if (window.VFX.Camera) window.VFX.Camera.shake(4, 180, 20);
          if (window.VFX.Particles) {
            window.VFX.Particles.emit("fire", summon.x, summon.y, {
              count: 12,
              color: "#ff0000",
            });
            window.VFX.Particles.emit("sparkle", summon.x, summon.y, {
              count: 10,
              color: "#ffff00",
            });
          }
        }
        
        // Sword trail effect
        if (!st.effects) st.effects = [];
        st.effects.push({
          kind: "sword_trail",
          x: summon.x,
          y: summon.y,
          angle: angle,
          color: isCrit ? "#ffff00" : "#ff0000",
          life: 200,
          max: 200,
          length: isCrit ? 60 : 45
        });
        
        break;

      default:
        return;
    }

    // Add projectile if not already added in loop
    if (projectileConfig) {
      if (!st.shots) st.shots = [];
      st.shots.push(projectileConfig);
    }

    // === VISUAL FEEDBACK ===
    // Muzzle flash
    if (window.VFX && window.VFX.Particles) {
      const particleCount =
        summon.type === "drone" ? 6 : summon.type === "pet" ? 8 : 5;
      window.VFX.Particles.emit("sparkle", summon.x, summon.y, {
        count: particleCount,
        color: "#ff0000",
      });

      // Extra effects for pets
      if (summon.type === "pet") {
        window.VFX.Particles.emit("dust", summon.x, summon.y, {
          count: 3,
          color: "#ff8888",
        });
      }
    }

    // Firing animation ring
    if (!st.effects) st.effects = [];
    st.effects.push({
      kind: "cast",
      x: summon.x,
      y: summon.y,
      color: "#ff0000",
      life: 180,
      max: 180,
    });

    // Shot counter for stats
    summon.shotsFired = (summon.shotsFired || 0) + (burstCount || 1);
  }

  // ===== ENEMY TARGET SELECTION - PRIORITIZE SUMMONS =====
  function getEnemyPreferredTarget(enemy) {
    if (!enemy) return null;
    const st = window.st;
    if (!st) return null;

    // Build target priority list
    const potentialTargets = [];

    // Priority 1: SUMMONS (highest priority)
    const summons = (st.summons || []).filter((s) => s && !s.dead && s.hp > 0);
    summons.forEach((summon) => {
      const d = dist(enemy, summon);
      if (d < 600) {
        // Detection range
        potentialTargets.push({
          entity: summon,
          distance: d,
          priority: 100, // HIGHEST PRIORITY
          isSummon: true,
        });
      }
    });

    // Priority 2: Clones
    const clones = (st.clones || []).filter(
      (c) => c && !c.isDefeated && c.hp > 0
    );
    clones.forEach((clone) => {
      const d = dist(enemy, clone);
      if (d < 600) {
        potentialTargets.push({
          entity: clone,
          distance: d,
          priority: 90,
          isClone: true,
        });
      }
    });

    // Priority 3: Players (lowest priority)
    const players = (st.players || []).filter(
      (p) => p && !p.isDefeated && p.hp > 0
    );
    players.forEach((player) => {
      const d = dist(enemy, player);
      if (d < 800) {
        potentialTargets.push({
          entity: player,
          distance: d,
          priority: 50,
          isPlayer: true,
        });
      }
    });

    if (potentialTargets.length === 0) return null;

    // Sort by priority first, then distance
    potentialTargets.sort((a, b) => {
      if (a.priority !== b.priority) return b.priority - a.priority;
      return a.distance - b.distance;
    });

    return potentialTargets[0].entity;
  }

  // ===== ENHANCED SUMMON UPDATE =====
  function updateEnhancedSummons(dtMs) {
    const st = window.st;
    if (!st || !st.summons) return;

    for (let i = st.summons.length - 1; i >= 0; i--) {
      const summon = st.summons[i];

      // Remove dead
      if (!summon || summon.dead || summon.hp <= 0) {
        st.summons.splice(i, 1);
        continue;
      }

      // Update chase AI
      updateSummonChaseAI(summon, dtMs);

      // CLONES: Special hybrid combat system - CONTINUOUS RANGED + MELEE
      if (summon.type === "clone" && summon.target && !summon.target.dead && summon.target.hp > 0) {
        const d = dist(summon, summon.target);
        
        // Ranged combat - ALWAYS fire projectiles at medium range
        if (d > 70 && d <= 250) {
          fireSummonProjectile(summon);
        }
        // Melee range - sword attacks (handled in updateSummonChaseAI via performMeleeAttack)
        else if (d <= 70) {
          summon.inMeleeRange = true;
        }
      }
      // Other summon types: normal projectile firing
      else if (summon.target && !summon.target.dead && summon.target.hp > 0) {
        const d = dist(summon, summon.target);
        const range =
          summon.type === "drone" ? 280 : summon.type === "pet" ? 220 : 200;

        if (d <= range) {
          fireSummonProjectile(summon);
        }
      }

      // Heal owner periodically (if configured)
      if (summon.healAmount > 0 && summon.owner) {
        const t = now();
        if (!summon.lastHeal || t - summon.lastHeal > (summon.healCD || 5000)) {
          summon.lastHeal = t;
          summon.owner.hp = Math.min(
            summon.owner.hpMax || summon.owner.hp,
            (summon.owner.hp || 0) + summon.healAmount
          );

          // Show heal effect
          if (window.showDamage) {
            window.showDamage(
              summon.owner.x,
              summon.owner.y - 30,
              `+${summon.healAmount}`,
              "#55ff88"
            );
          }
        }
      }
    }
  }

  // ===== ENHANCED ENEMY AI - TARGET SUMMONS FIRST =====
  const originalEnemyUpdate = window.updateEnemies;

  window.updateEnemies = function (dtMs) {
    // Run original update
    if (originalEnemyUpdate) originalEnemyUpdate(dtMs);

    const st = window.st;
    if (!st || !st.enemies) return;

    // Update enemy targeting to prioritize summons
    for (const enemy of st.enemies) {
      if (!enemy || enemy.dead) continue;

      // Get preferred target (summons > clones > players)
      const preferredTarget = getEnemyPreferredTarget(enemy);

      if (preferredTarget) {
        enemy.currentTarget = preferredTarget;
        enemy.targetX = preferredTarget.x;
        enemy.targetY = preferredTarget.y;

        // Visual: Show targeting line (debug)
        if (window.DEBUG_SUMMON_TARGETING && st.effects) {
          st.effects.push({
            kind: "line",
            x1: enemy.x,
            y1: enemy.y,
            x2: preferredTarget.x,
            y2: preferredTarget.y,
            color: "#ff0000",
            life: 80,
            max: 80,
          });
        }
      }
    }
  };

  // ===== INTEGRATION WITH GAME LOOP =====
  // Hook into existing update loop
  const originalUpdate = window.update;
  if (originalUpdate && !window.__summonCombatEnhanced) {
    window.update = function (dtMs) {
      originalUpdate(dtMs);

      // Update enhanced summons after main update
      updateEnhancedSummons(dtMs);
    };
    window.__summonCombatEnhanced = true;
  }

  // ===== FORMATION SYSTEM FOR SUMMONS =====
  function updateSummonFormation(summons, owner) {
    if (!summons || summons.length === 0) return;

    const formations = {
      wedge: (index, total) => {
        const row = Math.floor(index / 2);
        const side = index % 2 === 0 ? -1 : 1;
        return {
          offsetX: side * (40 + row * 25),
          offsetY: -30 - row * 20,
        };
      },
      line: (index, total) => {
        const spacing = 60;
        const centerOffset = ((total - 1) * spacing) / 2;
        return {
          offsetX: -centerOffset + index * spacing,
          offsetY: -25,
        };
      },
      circle: (index, total) => {
        const angle = (index / total) * Math.PI * 2;
        const radius = 70;
        return {
          offsetX: Math.cos(angle) * radius,
          offsetY: Math.sin(angle) * radius - 30,
        };
      },
    };

    const formation = owner?.summonFormation || "wedge";
    const formationFn = formations[formation] || formations.wedge;

    summons.forEach((summon, index) => {
      if (summon.chasing || summon.target) return; // Skip if actively chasing

      const offset = formationFn(index, summons.length);
      const targetX = (owner?.x || 0) + offset.offsetX;
      const targetY = (owner?.y || 0) + offset.offsetY;

      summon.formationX = targetX;
      summon.formationY = targetY;
    });
  }

  // ===== SUMMON DAMAGE TAKEN =====
  function processSummonDamage(summon, damage) {
    summon.hp -= damage;
    summon.damageTaken = (summon.damageTaken || 0) + damage;

    // Show damage
    if (window.showDamage) {
      window.showDamage(summon.x, summon.y - 20, damage, "#ff0000");
    }

    // Defense reduction
    const defReduction = Math.min(damage * 0.5, summon.def || 0);
    const actualDamage = damage - defReduction;

    // Hit flash effect
    summon.hitFlash = 200; // ms

    // Death check
    if (summon.hp <= 0) {
      summon.dead = true;
      summon.deathTime = now();

      // Death effects
      if (window.VFX) {
        if (window.VFX.Particles) {
          window.VFX.Particles.emit("smoke", summon.x, summon.y, {
            count: 12,
            color: "#666666",
          });
          window.VFX.Particles.emit("sparkle", summon.x, summon.y, {
            count: 8,
            color: "#ff0000",
          });
        }
        if (window.VFX.Camera) window.VFX.Camera.shake(2, 100, 14);
      }

      console.log(
        `💀 ${summon.type.toUpperCase()} defeated at level ${summon.level}`
      );
    }

    return actualDamage;
  }

  // ===== SUMMON SQUAD TACTICS =====
  function updateSummonSquadTactics(summons) {
    if (!summons || summons.length < 2) return;

    // Group summons by owner
    const squads = {};
    summons.forEach((s) => {
      const ownerId = s.owner?.id || "none";
      if (!squads[ownerId]) squads[ownerId] = [];
      squads[ownerId].push(s);
    });

    // Apply squad bonuses
    Object.values(squads).forEach((squad) => {
      if (squad.length < 2) return;

      // Squad bonuses per summon count
      const squadBonus = {
        dmgMultiplier: 1 + squad.length * 0.05, // +5% per summon
        defBonus: squad.length * 2, // +2 def per summon
        healBonus: squad.length * 3, // +3 healing per summon
        rangeBonus: squad.length * 10, // +10px range per summon
      };

      squad.forEach((summon) => {
        summon._squadBonus = squadBonus;
        summon._inSquad = true;
        summon._squadSize = squad.length;
      });
    });
  }

  // ===== ADVANCED ENEMY TARGETING =====
  function updateEnemyAggroSystem() {
    const st = window.st;
    if (!st || !st.enemies) return;

    const summons = (st.summons || []).filter((s) => s && !s.dead && s.hp > 0);
    const clones = (st.clones || []).filter(
      (c) => c && !c.isDefeated && c.hp > 0
    );
    const allSummons = [...summons, ...clones];

    for (const enemy of st.enemies) {
      if (!enemy || enemy.dead) continue;

      // Calculate threat scores
      const threats = [];

      // Summons generate high threat
      allSummons.forEach((summon) => {
        const d = dist(enemy, summon);
        if (d < 800) {
          const threat = 100 - d / 8; // 100 at point blank, decreases with distance
          const aggroBonus = summon.tauntRadius > 0 ? 50 : 0; // Taunting summons
          threats.push({
            entity: summon,
            threat: threat + aggroBonus,
            distance: d,
            isSummon: true,
          });
        }
      });

      // Players generate moderate threat
      (st.players || []).forEach((player) => {
        if (player.isDefeated) return;
        const d = dist(enemy, player);
        if (d < 1000) {
          const threat = 50 - d / 20; // Lower base threat
          threats.push({
            entity: player,
            threat,
            distance: d,
            isPlayer: true,
          });
        }
      });

      // Select highest threat target
      if (threats.length > 0) {
        threats.sort((a, b) => b.threat - a.threat);
        const topThreat = threats[0];

        enemy.currentTarget = topThreat.entity;
        enemy.aggroedToSummon = topThreat.isSummon;
        enemy._threatLevel = topThreat.threat;
      }
    }
  }

  // ===== GLOBAL API =====
  window.SummonCombatSystem = {
    updateSummonChaseAI,
    fireSummonProjectile,
    getEnemyPreferredTarget,
    updateEnhancedSummons,
    updateSummonFormation,
    processSummonDamage,
    updateSummonSquadTactics,
    updateEnemyAggroSystem,

    // Formation control
    setSummonFormation: (owner, formation) => {
      if (owner) owner.summonFormation = formation;
    },

    // Debug helpers
    enableTargetingDebug: () => {
      window.DEBUG_SUMMON_TARGETING = true;
    },
    disableTargetingDebug: () => {
      window.DEBUG_SUMMON_TARGETING = false;
    },
    getSummonStats: () => {
      const st = window.st;
      if (!st || !st.summons)
        return { total: 0, clones: 0, drones: 0, pets: 0 };
      const summons = st.summons.filter((s) => s && !s.dead);
      return {
        total: summons.length,
        clones: summons.filter((s) => s.type === "clone").length,
        drones: summons.filter((s) => s.type === "drone").length,
        pets: summons.filter((s) => s.type === "pet").length,
        chasing: summons.filter((s) => s.chasing).length,
        hasTarget: summons.filter((s) => s.target).length,
        totalShotsFired: summons.reduce(
          (sum, s) => sum + (s.shotsFired || 0),
          0
        ),
        totalDamageTaken: summons.reduce(
          (sum, s) => sum + (s.damageTaken || 0),
          0
        ),
      };
    },
    getEnemyAggroStats: () => {
      const st = window.st;
      if (!st || !st.enemies)
        return { total: 0, targetingSummons: 0, targetingPlayers: 0 };
      const enemies = st.enemies.filter((e) => e && !e.dead);
      return {
        total: enemies.length,
        targetingSummons: enemies.filter((e) => e.aggroedToSummon).length,
        targetingPlayers: enemies.filter((e) => !e.aggroedToSummon).length,
        averageThreat:
          enemies.reduce((sum, e) => sum + (e._threatLevel || 0), 0) /
          (enemies.length || 1),
      };
    },
  };

  console.log(
    "%c[SummonCombat] ⚔️ Enhanced System Active (AGGRESSIVE MODE)",
    "color:#ff0000; font-weight:bold; font-size:14px"
  );
  console.log("%c  🎯 Summons hunt enemies aggressively", "color:#ff0000");
  console.log("%c  🛡️ Enemies target summons first (threat system)", "color:#ff0000");
  console.log("%c  💰 Clones collect loot automatically", "color:#ff0000");
  console.log("%c  🔴 All summons fire RED projectiles", "color:#ff0000");
  console.log("%c  ✈️ Drones: 3-shot laser bursts", "color:#ff0000");
  console.log("%c  🔮 Pets: Smart-tracking orbs (never miss)", "color:#ff0000");
  console.log("%c  ⚔️ A1 Clones: SWORD WIELDERS", "color:#ffff00; font-weight:bold");
  console.log("%c     - Hunt enemies & collect loot", "color:#ffff00");
  console.log("%c     - Fire 2 projectiles then rush to melee", "color:#ffff00");
  console.log("%c     - 35% crit chance in melee (2x damage)", "color:#ffff00");
  console.log("%c     - Aggressive pursuit with circle strafing", "color:#ffff00");
  console.log("%c  🤝 Squad tactics and formation system", "color:#ff0000");
})();

</script>

  <!-- ===== CLONE SWORD VISUAL RENDERER ===== -->
  <script id="clone-sword-renderer">
    (function() {
      'use strict';
      
      if (window.__CLONE_SWORD_RENDERER__) return;
      window.__CLONE_SWORD_RENDERER__ = true;
      
      // Draw sword on clone based on their mode
      function drawCloneSword(ctx, summon) {
        if (!summon || summon.type !== 'clone' || summon.dead) return;
        
        const mode = summon.mode || 'idle';
        const facingLeft = summon.facingLeft;
        const time = performance.now() * 0.01;
        
        ctx.save();
        ctx.translate(summon.x, summon.y);
        if (facingLeft) ctx.scale(-1, 1);
        
        // Sword position offset based on mode
        let swordX = 18;
        let swordY = -5;
        let swordAngle = 0;
        let swordGlow = false;
        
        switch(mode) {
          case 'melee':
            // Slash animation
            swordAngle = Math.sin(time * 8) * 0.8 - 0.3;
            swordGlow = true;
            swordY -= 3;
            break;
          case 'hunting':
          case 'ranged':
            // Ready position - sword held forward
            swordAngle = -0.4;
            swordX = 20;
            swordY = -8;
            break;
          case 'looting':
            // Sheathed position
            swordAngle = -1.2;
            swordX = 10;
            swordY = 5;
            break;
          default:
            // Idle - slight bob
            swordAngle = Math.sin(time * 2) * 0.1 - 0.5;
            swordX = 12;
        }
        
        ctx.translate(swordX, swordY);
        ctx.rotate(swordAngle);
        
        // Glow effect for active combat
        if (swordGlow || summon.inMeleeRange) {
          ctx.shadowColor = '#ff0000';
          ctx.shadowBlur = 12;
        }
        
        // Sword blade (red energy sword)
        const gradient = ctx.createLinearGradient(0, 0, 30, 0);
        gradient.addColorStop(0, '#ff0000');
        gradient.addColorStop(0.5, '#ff4444');
        gradient.addColorStop(1, '#ff8888');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, -2, 32, 4); // Blade
        
        // Blade edge highlight
        ctx.fillStyle = '#ffffff';
        ctx.fillRect(0, -1, 32, 1);
        
        // Blade glow trails during slash
        if (mode === 'melee') {
          ctx.globalAlpha = 0.4;
          ctx.fillStyle = '#ff0000';
          ctx.fillRect(-5, -4, 35, 8);
          ctx.globalAlpha = 1;
        }
        
        // Guard
        ctx.fillStyle = '#333333';
        ctx.fillRect(-3, -4, 5, 8);
        
        // Pommel
        ctx.fillStyle = '#660000';
        ctx.beginPath();
        ctx.arc(-5, 0, 3, 0, Math.PI * 2);
        ctx.fill();
        
        ctx.restore();
      }
      
      // Hook into draw function
      const originalDraw = window.draw;
      if (originalDraw && !window.__cloneSwordDrawHooked) {
        window.draw = function() {
          originalDraw();
          
          const st = window.st;
          if (st && st.summons && st.summons.length > 0) {
            const ctx = window.ctx;
            if (!ctx) return;
            
            // Draw swords on all clones
            st.summons.forEach(summon => {
              if (summon && summon.type === 'clone' && !summon.dead) {
                drawCloneSword(ctx, summon);
              }
            });
          }
        };
        window.__cloneSwordDrawHooked = true;
      }
      
      console.log('%c[CloneSword] ⚔️ Visual renderer active', 'color:#ff0000; font-weight:bold');
    })();
  </script>

  <script id="gift-tower-crafting-systems">
    (function () {
      'use strict';

      if (window.__A1K_CURRENCY_BUNDLE__) return;
      window.__A1K_CURRENCY_BUNDLE__ = true;

      const $ = (q) => document.querySelector(q);
      function have(id) { return !!document.getElementById(id); }
      function pill(labelHTML) { const d = document.createElement('div'); d.className = 'pill'; d.innerHTML = labelHTML; return d; }
      function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }

      (function ensureCurrencyHUD() {
        const bar = document.getElementById('currency'); if (!bar) return;
        const setTitle = (sel, title) => { const el = bar.querySelector(sel); if (el) el.title = title; };
        const ensureVal = (id, label, title) => { if (!have(id)) { bar.appendChild(pill(`${label}: <b id="${id}">0</b>`)); } setTitle(`#${id}`, title); };
        ensureVal('giftKeyVal', 'Gift Keys', 'Earn from bosses, spend in Gift Room');
        ensureVal('bossKeyVal', 'Boss Keys', 'Earn from special bosses, spend in Boss Tower');
        ensureVal('ticketVal', 'Tickets', 'Use for travel, NPC hiring, and crafting');
        ensureVal('gemVal', 'Gems', 'Premium currency for crafting');
        ensureVal('silverVal', 'Silver', 'Secondary currency for crafting');
      })();

      window.CRAFT_RECIPES = [
        { id: 'b_weapon', name: 'B-Rank Weapon', cost: { gold: 2000, silver: 500, gems: 2 }, result: { type: 'gear', slot: 'weapon', rank: 'B', atk: 45 } },
        { id: 'b_armor', name: 'B-Rank Armor', cost: { gold: 2000, silver: 500, gems: 2 }, result: { type: 'gear', slot: 'armor', rank: 'B', def: 40 } },
        { id: 'a_weapon', name: 'A-Rank Weapon', cost: { gold: 5000, silver: 1500, gems: 5, tickets: 1 }, result: { type: 'gear', slot: 'weapon', rank: 'A', atk: 70 } },
        { id: 'a_armor', name: 'A-Rank Armor', cost: { gold: 5000, silver: 1500, gems: 5, tickets: 1 }, result: { type: 'gear', slot: 'armor', rank: 'A', def: 65 } },
        { id: 's_weapon', name: 'S-Rank Weapon', cost: { gold: 15000, silver: 5000, gems: 15, tickets: 3, giftKeys: 2 }, result: { type: 'gear', slot: 'weapon', rank: 'S', atk: 120 } },
        { id: 's_armor', name: 'S-Rank Armor', cost: { gold: 15000, silver: 5000, gems: 15, tickets: 3, giftKeys: 2 }, result: { type: 'gear', slot: 'armor', rank: 'S', def: 110 } },
        { id: 'pet_c', name: 'C-Rank Pet', cost: { silver: 800, gems: 3 }, result: { type: 'gear', slot: 'pet', rank: 'C', atk: 15 } },
        { id: 'pet_b', name: 'B-Rank Pet', cost: { gold: 3000, silver: 1200, gems: 6, tickets: 1 }, result: { type: 'gear', slot: 'pet', rank: 'B', atk: 30 } },
        { id: 'vehicle_c', name: 'C-Rank Vehicle', cost: { silver: 1000, gems: 4 }, result: { type: 'gear', slot: 'vehicle', rank: 'C', atk: 10 } },
        { id: 'hp_potion', name: 'HP Potion', cost: { silver: 200, tickets: 1 }, result: { type: 'consumable', name: 'HP Potion', effect: 'heal' } },
        { id: 'rage_pill', name: 'Rage Pill', cost: { silver: 300, gems: 1 }, result: { type: 'consumable', name: 'Rage Pill', effect: 'rage' } },
        { id: 'boss_key_craft', name: 'Boss Key', cost: { gold: 8000, giftKeys: 5, tickets: 2 }, result: { type: 'currency', currency: 'bossKeys', amount: 1 } },
        { id: 'gift_key_craft', name: 'Gift Key x3', cost: { gold: 5000, tickets: 3, gems: 5 }, result: { type: 'currency', currency: 'giftKeys', amount: 3 } }
      ];

      window.craftItem = function craftItem(recipeId) {
        const st = window.st || (window.st = {});
        const recipe = window.CRAFT_RECIPES.find(r => r.id === recipeId); if (!recipe) return;
        const cost = recipe.cost || {}; const need = (k, v) => (v && (st[k] | 0) < v);
        if (need('gold', cost.gold)) return notify('Not enough gold', '#ff6b6b');
        if (need('silver', cost.silver)) return notify('Not enough silver', '#ff6b6b');
        if (need('gems', cost.gems)) return notify('Not enough gems', '#ff6b6b');
        if (need('tickets', cost.tickets)) return notify('Not enough tickets', '#ff6b6b');
        if (need('giftKeys', cost.giftKeys)) return notify('Not enough gift keys', '#ff6b6b');
        if (need('bossKeys', cost.bossKeys)) return notify('Not enough boss keys', '#ff6b6b');
        if (cost.gold) st.gold -= cost.gold;
        if (cost.silver) st.silver -= cost.silver;
        if (cost.gems) st.gems -= cost.gems;
        if (cost.tickets) st.tickets -= cost.tickets;
        if (cost.giftKeys) st.giftKeys -= cost.giftKeys;
        if (cost.bossKeys) st.bossKeys -= cost.bossKeys;
        try { updateCurrencies(); } catch (_) { }
        const r = recipe.result || {};
        if (r.type === 'currency') { st[r.currency] = (st[r.currency] | 0) + (r.amount | 0); notify(`Crafted! +${r.amount} ${r.currency}`, '#4ecdc4'); window.QuestSystem?.trackProgress?.('craft', 1, recipeId); try { updateCurrencies(); } catch (_) { } return; }
        const item = { id: Math.random(), name: recipe.name, ...r };
        try { addItemToBag && addItemToBag(item); } catch (_) { }
        notify(`Crafted ${recipe.name}!`, '#4ecdc4');
        window.QuestSystem?.trackProgress?.('craft', 1, recipeId);
        try { updateCurrencies(); if (st.bagOpen && window.renderBag) renderBag(); } catch (_) { }
      };

      function openCraftingPanel() {
        const panel = document.createElement('div'); panel.id = 'craftingPanel'; panel.className = 'crafting-panel';
        let html = `<div style="background:#0f1826;border:1px solid #293854;border-radius:10px;padding:20px;max-width:900px;max-height:80vh;overflow:auto;color:#cfe3ff"><h2 style="margin-top:0">Crafting House</h2><div style="display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:10px">`;
        window.CRAFT_RECIPES.forEach(r => { const costStr = Object.entries(r.cost).map(([k, v]) => `${v} ${k}`).join(', '); html += `<div style="border:1px solid #293854;padding:10px;border-radius:6px"><h4 style="margin:5px 0">${r.name}</h4><p style="font-size:12px;color:#9ab">Cost: ${costStr}</p><button onclick="craftItem('${r.id}')" style="width:100%;padding:6px;cursor:pointer">Craft</button></div>`; });
        html += `</div><button onclick="document.getElementById('craftingPanel').remove()" style="margin-top:15px;padding:8px 16px;cursor:pointer">Close</button></div>`; panel.innerHTML = html; document.body.appendChild(panel);
      }

      function installHousePatches() {
        const H = window.HouseInterior; if (!H || H.__giftTowerPatched) return; H.__giftTowerPatched = true;
        const enter0 = typeof H.enter === 'function' ? H.enter.bind(H) : function () { };
        const step0 = typeof H.step === 'function' ? H.step.bind(H) : function () { };
        const draw0 = typeof H.draw === 'function' ? H.draw.bind(H) : function () { };
        const inter0 = typeof H.interact === 'function' ? H.interact.bind(H) : function () { };
        const exit0 = typeof H.exit === 'function' ? H.exit.bind(H) : function () { };
        const heroOf = (that) => that.hero || (window.st?.players?.[window.st.leader || 0]) || null;
        H.spawnTowerBoss = function (floor) { if (!this.towerState) return; const names = ['Tower Guard', 'Elite Warrior', 'Ancient Sentinel', 'Tower Lord', 'Tower King']; this.towerState.currentBoss = { name: names[floor - 1] || 'Tower Boss', floor, x: 640, y: 300, hp: 800 * floor, max: 800 * floor, atk: 40 + floor * 15, defeated: false }; this.towerState.showStairs = false; };
        H.enter = function (house) { const out = enter0(house); try { const st = window.st || (window.st = {}); const t = this.house?.type; if (t === 'gift_room') { if ((st.giftKeys | 0) < 1) { notify('Need 1 Gift Key to enter!', '#ff6b6b'); this.exit(); return out; } st.giftKeys -= 1; try { updateCurrencies(); } catch (_) { } this.giftBosses = []; const bossTypes = ['Candy King', 'Sugar Beast', 'Chocolate Golem', 'Gummy Dragon']; for (let i = 0; i < 4; i++) { this.giftBosses.push({ name: bossTypes[i], x: 200 + i * 220, y: 230, hp: 500 + i * 220, max: 500 + i * 220, atk: 30 + i * 10, defeated: false }); } this.giftKing = { name: 'Gift King', x: 520, y: 160, hp: 2500, max: 2500, atk: 80, defeated: false, locked: true }; notify('Gift Room Challenge Started!', '#ff9aa8'); } if (t === 'boss_tower') { if ((st.bossKeys | 0) < 1) { notify('Need 1 Boss Key to enter!', '#ff6b6b'); this.exit(); return out; } st.bossKeys -= 1; try { updateCurrencies(); } catch (_) { } this.towerState = { floor: 1, maxFloor: 5, currentBoss: null, showStairs: false, completed: false }; this.spawnTowerBoss(1); notify('Boss Tower Challenge Started! Floor 1/5', '#ff4d4f'); } } catch (_) { } return out; };
        H.step = function (dt) {
          step0(dt); const st = window.st || (window.st = {}); const hero = heroOf(this); const t = this.house?.type; if (!hero) return; if (t === 'gift_room' && this.giftBosses) { let target = null; for (const b of this.giftBosses) { if (!b.defeated) { const d = Math.hypot(hero.x - b.x, hero.y - b.y); if (d < 100) { target = b; break; } } } if (!target && this.giftKing && !this.giftKing.locked && !this.giftKing.defeated) { const d = Math.hypot(hero.x - this.giftKing.x, hero.y - this.giftKing.y); if (d < 100) target = this.giftKing; } if (target && (!this._lastAttack || performance.now() - this._lastAttack > 1000)) { this._lastAttack = performance.now(); const dmg = 50 + Math.floor(Math.random() * 30); target.hp -= dmg; if (target.hp <= 0 && !target.defeated) { target.defeated = true; if (target === this.giftKing) { const goldReward = 5000 + Math.floor(Math.random() * 5000); const gemsReward = 10 + Math.floor(Math.random() * 10); st.gold = (st.gold | 0) + goldReward; st.gems = (st.gems | 0) + gemsReward; try { updateCurrencies(); } catch (_) { } notify(`Gift King defeated! +${goldReward}g +${gemsReward} gems!`, '#ffd700'); setTimeout(() => this.exit(), 2000); } else { const goldReward = 1000 + Math.floor(Math.random() * 2000); st.gold = (st.gold | 0) + goldReward; try { updateCurrencies(); } catch (_) { } notify(`${target.name} defeated! +${goldReward}g`, '#ff9aa8'); const allDefeated = this.giftBosses.every(b => b.defeated); if (allDefeated && this.giftKing) { this.giftKing.locked = false; notify('Gift King has appeared!', '#ffd700'); } } } } }
          if (t === 'boss_tower' && this.towerState) { const ts = this.towerState; const boss = ts.currentBoss; if (boss && !boss.defeated) { const d = Math.hypot(hero.x - boss.x, hero.y - boss.y); if (d < 100 && (!this._lastAttack || performance.now() - this._lastAttack > 800)) { this._lastAttack = performance.now(); const dmg = 60 + Math.floor(Math.random() * 40); boss.hp -= dmg; if (boss.hp <= 0 && !boss.defeated) { boss.defeated = true; const goldReward = 1500 * ts.floor + Math.floor(Math.random() * 1000); st.gold = (st.gold | 0) + goldReward; try { updateCurrencies(); } catch (_) { } notify(`Floor ${ts.floor} cleared! +${goldReward}g`, '#ffd700'); if (ts.floor >= ts.maxFloor) { const finalReward = 10000, gemReward = 20; st.gold = (st.gold | 0) + finalReward; st.gems = (st.gems | 0) + gemReward; try { updateCurrencies(); } catch (_) { } ts.completed = true; notify(`Tower Cleared! +${finalReward}g +${gemReward} gems!`, '#ffd700'); setTimeout(() => this.exit(), 3000); } else { ts.showStairs = true; notify('Stairs appeared! Move right to climb.', '#6aa8ff'); } } } } if (ts.showStairs && hero.x > 1100 && hero.y > 500) { ts.floor = clamp(ts.floor + 1, 1, ts.maxFloor); this.spawnTowerBoss(ts.floor); notify(`Climbing to Floor ${ts.floor}/${ts.maxFloor}`, '#6aa8ff'); } }
        };
        H.draw = function (ctx) {
          draw0(ctx); const t = this.house?.type; if (t === 'gift_room' && this.giftBosses) { ctx.save(); ctx.font = 'bold 16px sans-serif'; for (const boss of this.giftBosses) { if (boss.defeated) continue; ctx.fillStyle = '#ff6aa8'; ctx.fillRect(boss.x - 20, boss.y - 30, 40, 50); const r = boss.hp / boss.max; ctx.fillStyle = '#ff4444'; ctx.fillRect(boss.x - 30, boss.y - 45, 60, 8); ctx.fillStyle = '#44ff44'; ctx.fillRect(boss.x - 30, boss.y - 45, 60 * r, 8); ctx.fillStyle = '#fff'; ctx.fillText(boss.name, boss.x - 40, boss.y - 50); } if (this.giftKing && !this.giftKing.locked && !this.giftKing.defeated) { const king = this.giftKing; ctx.fillStyle = '#ffd700'; ctx.fillRect(king.x - 30, king.y - 40, 60, 70); const rr = king.hp / king.max; ctx.fillStyle = '#ff4444'; ctx.fillRect(king.x - 40, king.y - 55, 80, 10); ctx.fillStyle = '#44ff44'; ctx.fillRect(king.x - 40, king.y - 55, 80 * rr, 10); ctx.fillStyle = '#fff'; ctx.font = 'bold 18px sans-serif'; ctx.fillText(king.name, king.x - 40, king.y - 60); } ctx.restore(); }
          if (t === 'boss_tower' && this.towerState) { const ts = this.towerState; ctx.save(); ctx.fillStyle = '#fff'; ctx.font = 'bold 24px sans-serif'; ctx.fillText(`Floor ${ts.floor}/${ts.maxFloor}`, 50, 50); const boss = ts.currentBoss; if (boss && !boss.defeated) { ctx.fillStyle = '#ff4d4f'; ctx.fillRect(boss.x - 30, boss.y - 40, 60, 70); const r = boss.hp / boss.max; ctx.fillStyle = '#ff4444'; ctx.fillRect(boss.x - 40, boss.y - 55, 80, 10); ctx.fillStyle = '#44ff44'; ctx.fillRect(boss.x - 40, boss.y - 55, 80 * r, 10); ctx.fillStyle = '#fff'; ctx.font = 'bold 18px sans-serif'; ctx.fillText(boss.name, boss.x - 60, boss.y - 60); } if (ts.showStairs) { ctx.fillStyle = '#8b6914'; ctx.fillRect(1100, 500, 80, 100); ctx.fillStyle = '#fff'; ctx.font = '14px sans-serif'; ctx.fillText('Stairs ↑', 1105, 545); } ctx.restore(); }
        };
        H.interact = function () { if (this.house?.type === 'crafting') { openCraftingPanel(); return; } return inter0(); };
        H.showTowerMenu = function () { if (!this.towerState || !this.towerState.completed) return; const menu = document.createElement('div'); menu.id = 'towerMenu'; menu.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.8);display:flex;align-items:center;justify-content:center;z-index:99999'; menu.innerHTML = `<div style="background:#0f1826;border:1px solid #293854;border-radius:10px;padding:20px;min-width:320px;color:#cfe3ff"><h2>Tower Cleared!</h2><p>Select floor to replay (costs 1 Boss Key):</p>${Array.from({ length: 5 }, (_, i) => `<button onclick="replayFloor(${i + 1})" style="margin:4px">Floor ${i + 1}</button>`).join('')}<div style="margin-top:10px"><button onclick="document.getElementById('towerMenu').remove()">Exit</button></div></div>`; document.body.appendChild(menu); };
        H.exit = function () { const out = exit0(); try { if (this.towerState?.completed) this.showTowerMenu(); } catch (_) { } return out; };
      }

      window.replayFloor = function (floor) { const st = window.st || (window.st = {}); if ((st.bossKeys | 0) < 1) return notify('Need 1 Boss Key to replay!', '#ff6b6b'); st.bossKeys -= 1; try { updateCurrencies(); } catch (_) { } try { document.getElementById('towerMenu')?.remove(); } catch (_) { } if (window.HouseInterior?.active) { const H = window.HouseInterior; H.towerState = { floor: floor, maxFloor: 5, currentBoss: null, showStairs: false, completed: false }; H.spawnTowerBoss(floor); notify(`Boss Tower Replay: Floor ${floor}/5`, '#6aa8ff'); } else { notify('Stand near the Boss Tower door and press E to enter.', '#9ab'); } };

      (function waitHouse() { if (window.HouseInterior) { installHousePatches(); return; } setTimeout(waitHouse, 60); })();
    })();
  </script>

  <!-- BEGIN A1K: Action Unifier — E/A keys + ACT button (v1) -->
  <style>
    #a1k-act-btn {
      position: fixed;
      right: 22px;
      bottom: 42px;
      width: 68px;
      height: 68px;
      border-radius: 999px;
      z-index: 100000;
      display: none;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
      background: radial-gradient(circle at 40% 40%, rgba(255, 255, 255, 0.16), rgba(0, 0, 0, 0.48));
      border: 2px solid rgba(255, 255, 255, 0.20);
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.35), inset 0 3px 8px rgba(255, 255, 255, 0.08);
      color: #fff;
      text-align: center;
      font: 800 14px/68px system-ui, -apple-system, Segoe UI, Roboto, Arial;
      letter-spacing: 0.6px;
    }
  </style>

  <div id="a1k-act-btn" aria-hidden="true">ACT</div>

  <script>
    (() => {
      if (window.__A1K_ACTION_UNIFIER_V1) return;
      window.__A1K_ACTION_UNIFIER_V1 = true;

      const HI = () => window.HouseInterior;
      const arcadeActive = () => !!(window.MissyArcadeGame && window.MissyArcadeGame.active);
      const indoor = () => !!(HI() && HI().active) && !arcadeActive();

      function canActOutside() {
        if (indoor() || arcadeActive()) return false;
        const w = window;
        if (w.UI?.canInteract?.()) return true;
        if (w.Player?.nearDoor) return true;
        if (w.World?.nearbyDoor) return true;
        if (w.NEAR_DOOR === true) return true;
        if (w.__houseNearDoor) return true;
        return false;
      }

      function codeToKey(code) {
        if (!code) return '';
        if (code === 'Space') return ' ';
        if (code.startsWith('Key')) return code.slice(3).toLowerCase();
        if (code.startsWith('Digit')) return code.slice(5);
        return code.toLowerCase();
      }

      function triggerAction() {
        if (indoor()) {
          try { HI().interact(); } catch (_) { }
          return;
        }
        try {
          const primaryCode = keymap.ACT_PRIMARY || 'KeyA';
          const primaryKey = codeToKey(primaryCode);
          const kd = new KeyboardEvent('keydown', { code: primaryCode, key: primaryKey, bubbles: true, cancelable: true });
          const ku = new KeyboardEvent('keyup', { code: primaryCode, key: primaryKey, bubbles: true, cancelable: true });
          window.dispatchEvent(kd);
          window.dispatchEvent(ku);
        } catch (_) { }
      }

      window.addEventListener('keydown', (e) => {
        if (!indoor() || arcadeActive()) return;
        if (e.code === keymap.ACT_PRIMARY || e.code === keymap.ACT_SECONDARY) {
          e.preventDefault();
          e.stopPropagation();
          try { HI().interact(); } catch (_) { }
          return;
        }
        // Space bar strikes indoors as a quick attack
        const isSpace = (e.code === keymap.INDOOR_ATTACK) || (e.key === ' ') || (e.key === 'Spacebar');
        if (isSpace) {
          e.preventDefault();
          e.stopPropagation();
          try { HI().strikeIndoorEnemy?.(); HI().castIndoorSkillVfx?.('ATTACK'); } catch (_) { }
        }
      }, true);

      window.addEventListener('keydown', (e) => {
        if (indoor() || arcadeActive()) return;
        if (e.code === keymap.ACT_SECONDARY) {
          e.preventDefault();
          e.stopPropagation();
          triggerAction();
        }
      }, true);

      const actBtn = document.getElementById('a1k-act-btn');
      const pressAct = (ev) => { triggerAction(); ev.preventDefault(); };
      actBtn.addEventListener('mousedown', pressAct, { passive: false });
      actBtn.addEventListener('touchstart', pressAct, { passive: false });

      function syncActVisibility() {
        const visible = indoor() || canActOutside();
        actBtn.style.display = visible ? 'block' : 'none';
        actBtn.setAttribute('aria-hidden', visible ? 'false' : 'true');
      }
      setInterval(syncActVisibility, 120);

      window.A1K_ACT = {
        click: triggerAction,
        show: () => { actBtn.style.display = 'block'; actBtn.setAttribute('aria-hidden', 'false'); },
        hide: () => { actBtn.style.display = 'none'; actBtn.setAttribute('aria-hidden', 'true'); }
      };
    })();
  </script>
  <!-- END A1K: Action Unifier (v1) -->

  <!-- ========================================
       PHASE 4: QUALITY OF LIFE FEATURES
       ======================================== -->
  <script>
    (function () {
      'use strict';

      // === KEYBOARD SHORTCUTS ===
      document.addEventListener('keydown', (e) => {
        // Ignore if typing in input/textarea
        const activeEl = document.activeElement;
        if (activeEl && (activeEl.tagName === 'INPUT' || activeEl.tagName === 'TEXTAREA')) {
          return;
        }

        const code = e.code;
        const noModifiers = !e.ctrlKey && !e.altKey && !e.metaKey;

        // Q - Quest Board
        if (code === 'KeyQ' && noModifiers) {
          e.preventDefault();
          if (window.QuestSystem) {
            const modal = document.getElementById('questBoardModal');
            if (modal && modal.style.display === 'flex') {
              window.QuestSystem.closeQuestBoard();
            } else {
              window.QuestSystem.openQuestBoard();
            }
          }
        }

        // R - Arena
        if (code === 'KeyR' && noModifiers) {
          e.preventDefault();
          if (window.ArenaSystem && !window.ArenaSystem.active) {
            window.ArenaSystem.startArena();
          }
        }

        // B - Bag / Inventory
        if (code === keymap.INVENTORY && noModifiers) {
          e.preventDefault();
          const bag = document.getElementById('inventory');
          if (bag) {
            const isOpen = bag.classList.contains('open');
            if (isOpen) {
              try { closeBag(); } catch (_) { bag.classList.remove('open'); }
            } else {
              try { openBag('items'); } catch (_) { bag.classList.add('open'); }
            }
          }
        }

        // ESC - Close any open modal
        if (code === 'Escape') {
          e.preventDefault();

          // Close all modals
          const modals = [
            'teamManagementModal',
            'questBoardModal',
            'shopModal',
            'rosterModal'
          ];

          modals.forEach(modalId => {
            const modal = document.getElementById(modalId);
            if (modal && modal.style.display !== 'none') {
              modal.style.display = 'none';
              modal.setAttribute('aria-hidden', 'true');
            }
          });

          // Close team management specifically
          if (window.TeamManagementSystem && window.TeamManagementSystem.closeModal) {
            window.TeamManagementSystem.closeModal();
          }

          // Close quest board specifically
          if (window.QuestSystem && window.QuestSystem.closeQuestBoard) {
            window.QuestSystem.closeQuestBoard();
          }

          // Close shop specifically
          if (window.ShopSystem && window.ShopSystem.closeShop) {
            window.ShopSystem.closeShop();
          }
        }
      });

      console.log('[QoL] Keyboard shortcuts initialized: Q (Quests), R (Arena), B (Bag), ESC (Close)');

    })();
  </script>

  <!-- Quest Notifications Widget -->
  <style>
    #questNotifications {
      position: fixed;
      top: 160px;
      right: 20px;
      width: 280px;
      max-height: 200px;
      overflow: hidden;
      z-index: 5500;
      display: flex;
      flex-direction: column;
      gap: 8px;
      pointer-events: none;
    }

    .quest-notification {
      background: linear-gradient(145deg, #1a2332, #0f1824);
      border: 1px solid #345d8a;
      border-radius: 8px;
      padding: 10px 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
      animation: slideInRight 0.3s ease-out;
      pointer-events: auto;
      cursor: pointer;
      transition: transform 0.2s;
    }

    .quest-notification:hover {
      transform: translateX(-4px);
      border-color: #4a7db0;
    }

    .quest-notification.pinned {
      background: linear-gradient(145deg, #2a3f5f, #1e3049);
      border-color: #ffd56a;
    }

    .quest-notification-title {
      color: #e0f2ff;
      font-weight: 600;
      font-size: 13px;
      margin-bottom: 4px;
    }

    .quest-notification-progress {
      color: #9baec8;
      font-size: 12px;
    }

    @keyframes slideInRight {
      from {
        opacity: 0;
        transform: translateX(100%);
      }

      to {
        opacity: 1;
        transform: translateX(0);
      }
    }
  </style>

  <div id="questNotifications"></div>

  <script>
    // Quest Notifications System
    (function () {
      'use strict';

      const state = {
        pinnedQuests: [],
        notifications: []
      };

      function showQuestNotification(questName, progress, target, isPinned = false) {
        const container = document.getElementById('questNotifications');
        if (!container) return;

        // Check if notification already exists
        let existing = container.querySelector(`[data-quest="${questName}"]`);

        if (existing) {
          // Update existing
          const progressEl = existing.querySelector('.quest-notification-progress');
          if (progressEl) {
            progressEl.textContent = `${progress}/${target}`;
          }
        } else {
          // Create new notification
          const notification = document.createElement('div');
          notification.className = 'quest-notification' + (isPinned ? ' pinned' : '');
          notification.setAttribute('data-quest', questName);
          notification.innerHTML = `
            <div class="quest-notification-title">${questName}</div>
            <div class="quest-notification-progress">${progress}/${target}</div>
          `;

          notification.onclick = () => {
            if (window.QuestSystem) {
              window.QuestSystem.openQuestBoard();
            }
          };

          container.appendChild(notification);

          // Auto-remove after 3 seconds if not pinned
          if (!isPinned) {
            setTimeout(() => {
              if (notification.parentElement) {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => {
                  if (notification.parentElement) {
                    notification.remove();
                  }
                }, 300);
              }
            }, 3000);
          }
        }
      }

      function pinQuest(questName) {
        if (state.pinnedQuests.length >= 2) {
          if (typeof notify === 'function') {
            notify('Maximum 2 pinned quests', '#ff7043');
          }
          return;
        }

        if (!state.pinnedQuests.includes(questName)) {
          state.pinnedQuests.push(questName);
        }
      }

      function unpinQuest(questName) {
        const index = state.pinnedQuests.indexOf(questName);
        if (index !== -1) {
          state.pinnedQuests.splice(index, 1);
        }
      }

      // Hook into QuestSystem to show notifications
      if (window.QuestSystem) {
        const originalTrackProgress = window.QuestSystem.trackProgress;
        window.QuestSystem.trackProgress = function (type, amount, detail) {
          const result = originalTrackProgress.call(this, type, amount, detail);

          // Show notification for updated quests
          if (window.QuestSystem.quests) {
            window.QuestSystem.quests.forEach(quest => {
              if (quest.type === type && !quest.completed) {
                const isPinned = state.pinnedQuests.includes(quest.name);
                showQuestNotification(quest.name, quest.progress, quest.target, isPinned);
              }
            });
          }

          return result;
        };
      }

      window.QuestNotifications = {
        show: showQuestNotification,
        pin: pinQuest,
        unpin: unpinQuest
      };

      console.log('[QoL] Quest notifications initialized');

    })();
  </script>

  <!-- ========================================
       PHASE 5: POLISH & ENHANCEMENT FEATURES
       ======================================== -->
  <style>
    /* Counter Animations */
    @keyframes counterPulse {

      0%,
      100% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.05);
      }
    }

    @keyframes counterGlow {

      0%,
      100% {
        box-shadow: 0 0 10px rgba(255, 215, 106, 0.3);
      }

      50% {
        box-shadow: 0 0 20px rgba(255, 215, 106, 0.6);
      }
    }

    .counter-animated {
      animation: counterPulse 2s ease-in-out infinite;
    }

    .counter-available {
      animation: counterGlow 2s ease-in-out infinite;
    }

    /* Gold Gain Animation */
    @keyframes goldFly {
      0% {
        transform: translate(0, 0) scale(0.5);
        opacity: 0;
      }

      50% {
        opacity: 1;
      }

      100% {
        transform: translate(-100px, -150px) scale(1);
        opacity: 0;
      }
    }

    .gold-particle {
      position: absolute;
      color: #ffd56a;
      font-size: 24px;
      pointer-events: none;
      animation: goldFly 1s ease-out forwards;
      z-index: 10000;
    }

    /* XP Flash */
    @keyframes xpFlash {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.3;
        box-shadow: 0 0 20px rgba(0, 255, 136, 0.8);
      }
    }

    .xp-flash {
      animation: xpFlash 0.5s ease-out;
    }

    /* Quest Complete Fanfare */
    @keyframes fanfare {
      0% {
        transform: scale(0) rotate(-180deg);
        opacity: 0;
      }

      50% {
        transform: scale(1.2) rotate(10deg);
      }

      100% {
        transform: scale(1) rotate(0);
        opacity: 1;
      }
    }

    .quest-complete-banner {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: linear-gradient(145deg, #ffd56a, #ff6b35);
      color: #fff;
      padding: 24px 48px;
      border-radius: 16px;
      font-size: 28px;
      font-weight: 700;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
      z-index: 11000;
      animation: fanfare 0.6s ease-out;
      pointer-events: none;
    }
  </style>

  <script>
    // UX Feedback Enhancements
    (function () {
      'use strict';

      // Gold Gain Animation
      function createGoldParticle(x, y) {
        const particle = document.createElement('div');
        particle.className = 'gold-particle';
        particle.textContent = '💰';
        particle.style.left = x + 'px';
        particle.style.top = y + 'px';
        document.body.appendChild(particle);

        setTimeout(() => {
          particle.remove();
        }, 1000);
      }

      // XP Gain Flash
      function flashXPBar() {
        const xpBar = document.querySelector('.xp-bar, #xpBar');
        if (xpBar) {
          xpBar.classList.add('xp-flash');
          setTimeout(() => {
            xpBar.classList.remove('xp-flash');
          }, 500);
        }
      }

      // Quest Complete Fanfare
      function showQuestCompleteFanfare(questName) {
        const banner = document.createElement('div');
        banner.className = 'quest-complete-banner';
        banner.textContent = `🎉 ${questName} Complete! 🎉`;
        document.body.appendChild(banner);

        setTimeout(() => {
          banner.style.opacity = '0';
          banner.style.transform = 'translate(-50%, -50%) scale(0.5)';
          banner.style.transition = 'all 0.3s ease-out';
          setTimeout(() => {
            banner.remove();
          }, 300);
        }, 2000);
      }

      // Team Member Join Celebration
      function celebrateTeamJoin(memberName) {
        const celebrationEffects = ['⭐', '✨', '🎊', '🎉'];
        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 2;

        for (let i = 0; i < 12; i++) {
          setTimeout(() => {
            const effect = document.createElement('div');
            effect.className = 'gold-particle';
            effect.textContent = celebrationEffects[i % celebrationEffects.length];
            effect.style.left = centerX + (Math.random() - 0.5) * 200 + 'px';
            effect.style.top = centerY + (Math.random() - 0.5) * 200 + 'px';
            effect.style.fontSize = (16 + Math.random() * 16) + 'px';
            document.body.appendChild(effect);

            setTimeout(() => {
              effect.remove();
            }, 1000);
          }, i * 50);
        }
      }

      // Arena Wave Clear Flash
      function flashArenaWaveClear() {
        const flash = document.createElement('div');
        flash.style.cssText = `
          position: fixed;
          inset: 0;
          background: rgba(255, 255, 255, 0.3);
          z-index: 10500;
          pointer-events: none;
          animation: fadeOut 0.3s ease-out;
        `;
        document.body.appendChild(flash);

        setTimeout(() => {
          flash.remove();
        }, 300);
      }

      // Hook into existing systems
      if (window.TeamManagementSystem) {
        const originalAddToRoster = window.TeamManagementSystem.addToRoster;
        window.TeamManagementSystem.addToRoster = function (member, type) {
          const result = originalAddToRoster.call(this, member, type);
          if (result && member.name) {
            celebrateTeamJoin(member.name);
          }
          return result;
        };
      }

      if (window.QuestSystem) {
        const originalCompleteQuest = window.QuestSystem.completeQuest;
        window.QuestSystem.completeQuest = function (questOrId) {
          const quest = typeof questOrId === 'string' ?
            window.QuestSystem.getQuest(questOrId) : questOrId;
          const result = originalCompleteQuest.call(this, questOrId);
          if (quest && quest.name) {
            showQuestCompleteFanfare(quest.name);
          }
          return result;
        };
      }

      if (window.ArenaSystem) {
        const originalOnWaveComplete = window.ArenaSystem.onWaveComplete;
        if (originalOnWaveComplete) {
          window.ArenaSystem.onWaveComplete = function () {
            flashArenaWaveClear();
            return originalOnWaveComplete.call(this);
          };
        }
      }

      // Hook into gold changes
      if (window.st) {
        let lastGold = window.st.gold || 0;
        setInterval(() => {
          const currentGold = window.st.gold || 0;
          if (currentGold > lastGold) {
            // Gold increased, create particle at random position
            const x = Math.random() * window.innerWidth;
            const y = Math.random() * window.innerHeight * 0.5 + window.innerHeight * 0.25;
            createGoldParticle(x, y);
          }
          lastGold = currentGold;
        }, 500);
      }

      // Hook into XP changes
      if (typeof grantXP !== 'undefined') {
        const originalGrantXP = grantXP;
        window.grantXP = function () {
          const result = originalGrantXP.apply(this, arguments);
          flashXPBar();
          return result;
        };
      }

      window.UXFeedback = {
        goldParticle: createGoldParticle,
        xpFlash: flashXPBar,
        questFanfare: showQuestCompleteFanfare,
        teamCelebration: celebrateTeamJoin,
        arenaFlash: flashArenaWaveClear
      };

      console.log('[UXFeedback] Visual feedback enhancements initialized');

    })();
  </script>

  <!-- Add fadeOut animation -->
  <style>
    @keyframes fadeOut {
      from {
        opacity: 1;
      }

      to {
        opacity: 0;
      }
    }

    /* Phase 5.4: Theme CSS Variables */
    :root {
      --modal-bg: linear-gradient(145deg, #1a2332, #0f1824);
      --modal-text: #e0f2ff;
      --modal-border: #345d8a;
      --modal-header-bg: linear-gradient(90deg, #2a3f5f, #1e3049);
      --card-bg: #1e3049;
      --text-primary: #e0f2ff;
      --text-secondary: #9baec8;
      --modal-font-size: 14px;
      --modal-title-size: 20px;
    }
  </style>

  <!-- ========================================
       PHASE 5.4: MODAL THEME SYSTEM
       ======================================== -->
  <script>
    (function () {
      'use strict';

      const themeState = {
        current: 'dark', // 'dark' | 'light'
        fontSize: 'normal' // 'normal' | 'large'
      };

      function loadThemePreferences() {
        try {
          const saved = localStorage.getItem('a1k_theme_preferences');
          if (saved) {
            const prefs = JSON.parse(saved);
            themeState.current = prefs.theme || 'dark';
            themeState.fontSize = prefs.fontSize || 'normal';
            applyTheme();
          }
        } catch (error) {
          console.error('[Theme] Failed to load preferences:', error);
        }
      }

      function saveThemePreferences() {
        try {
          localStorage.setItem('a1k_theme_preferences', JSON.stringify({
            theme: themeState.current,
            fontSize: themeState.fontSize
          }));
        } catch (error) {
          console.error('[Theme] Failed to save preferences:', error);
        }
      }

      function applyTheme() {
        const root = document.documentElement;

        if (themeState.current === 'light') {
          root.style.setProperty('--modal-bg', 'linear-gradient(145deg, #e8eef5, #f5f8fc)');
          root.style.setProperty('--modal-text', '#1a2332');
          root.style.setProperty('--modal-border', '#5ba3ff');
          root.style.setProperty('--modal-header-bg', 'linear-gradient(90deg, #b8d4f0, #d0e4f8)');
          root.style.setProperty('--card-bg', '#ffffff');
          root.style.setProperty('--text-primary', '#1a2332');
          root.style.setProperty('--text-secondary', '#4a5f7f');
        } else {
          root.style.setProperty('--modal-bg', 'linear-gradient(145deg, #1a2332, #0f1824)');
          root.style.setProperty('--modal-text', '#e0f2ff');
          root.style.setProperty('--modal-border', '#345d8a');
          root.style.setProperty('--modal-header-bg', 'linear-gradient(90deg, #2a3f5f, #1e3049)');
          root.style.setProperty('--card-bg', '#1e3049');
          root.style.setProperty('--text-primary', '#e0f2ff');
          root.style.setProperty('--text-secondary', '#9baec8');
        }

        // Font size
        if (themeState.fontSize === 'large') {
          root.style.setProperty('--modal-font-size', '16px');
          root.style.setProperty('--modal-title-size', '24px');
        } else {
          root.style.setProperty('--modal-font-size', '14px');
          root.style.setProperty('--modal-title-size', '20px');
        }

        document.body.classList.toggle('theme-light', themeState.current === 'light');
        document.body.classList.toggle('font-large', themeState.fontSize === 'large');
      }

      function toggleTheme() {
        themeState.current = themeState.current === 'dark' ? 'light' : 'dark';
        applyTheme();
        saveThemePreferences();
        notify?.(`Theme: ${themeState.current}`, '#5ba3ff');
      }

      function toggleFontSize() {
        themeState.fontSize = themeState.fontSize === 'normal' ? 'large' : 'normal';
        applyTheme();
        saveThemePreferences();
        notify?.(`Font size: ${themeState.fontSize}`, '#5ba3ff');
      }

      function addThemeControls(modalHeader) {
        if (!modalHeader || modalHeader.querySelector('[title="Toggle Theme"]')) return;

        const controls = document.createElement('div');
        controls.style.cssText = 'display:flex;gap:8px;';

        const themeBtn = document.createElement('button');
        themeBtn.innerHTML = themeState.current === 'dark' ? '☀️' : '🌙';
        themeBtn.title = 'Toggle Theme';
        themeBtn.style.cssText = `
          padding: 6px 12px;
          background: rgba(255,255,255,0.1);
          border: 1px solid rgba(255,255,255,0.2);
          border-radius: 6px;
          color: #fff;
          cursor: pointer;
          font-size: 16px;
        `;
        themeBtn.onclick = () => {
          toggleTheme();
          themeBtn.innerHTML = themeState.current === 'dark' ? '☀️' : '🌙';
        };

        const fontBtn = document.createElement('button');
        fontBtn.innerHTML = themeState.fontSize === 'normal' ? 'A+' : 'A-';
        fontBtn.title = 'Toggle Font Size';
        fontBtn.style.cssText = `
          padding: 6px 12px;
          background: rgba(255,255,255,0.1);
          border: 1px solid rgba(255,255,255,0.2);
          border-radius: 6px;
          color: #fff;
          cursor: pointer;
          font-weight: 700;
        `;
        fontBtn.onclick = () => {
          toggleFontSize();
          fontBtn.innerHTML = themeState.fontSize === 'normal' ? 'A+' : 'A-';
        };

        controls.appendChild(themeBtn);
        controls.appendChild(fontBtn);

        if (modalHeader.querySelector('h2')) {
          const header = modalHeader.querySelector('h2');
          header.parentElement.style.display = 'flex';
          header.parentElement.style.justifyContent = 'space-between';
          header.parentElement.style.alignItems = 'center';
          header.after(controls);
        }
      }

      loadThemePreferences();
      applyTheme();

      // Auto-add to existing modals
      setTimeout(() => {
        const modals = ['teamManagementModal', 'questBoardModal', 'shopModal'];
        modals.forEach(modalId => {
          const modal = document.getElementById(modalId);
          if (modal) {
            const header = modal.querySelector('[style*="background"]');
            if (header) {
              addThemeControls(header);
            }
          }
        });
      }, 500);

      window.ModalTheme = {
        toggle: toggleTheme,
        toggleFontSize,
        addControls: addThemeControls,
        get current() { return themeState.current; },
        get fontSize() { return themeState.fontSize; }
      };

      console.log('[ModalTheme] Theme system initialized');

    })();
  </script>


  <!-- Charge Meter Bar (hidden by default) -->
  <div id="charge-meter" style="position:absolute; left:50%; transform:translateX(-50%); bottom:100px; z-index:9999;
              width:300px; height:20px; display:none;
              background:rgba(0,0,0,0.55); border:2px solid #ffffff; border-radius:10px; overflow:hidden;">
    <div id="charge-fill" style="height:100%; width:0%;
                background:linear-gradient(90deg, #ff3b3b 0%, #ff8800 100%);
                transition:width 200ms ease-in-out;"></div>
  </div>

  <!-- Skills and Spirit System JavaScript -->
  <script>

    // Spirit System
    const spiritSystem = {
      equippedSpirit: null,

      spirits: {
        'dark-soul': { name: 'Dark Soul', icon: '🌑', type: 'Dark Energy', power: 85, level: 1 },
        'light-soul': { name: 'Light Soul', icon: '☀️', type: 'Light Energy', power: 90, level: 1 },
        'golden-spirit': { name: 'Golden Spirit', icon: '🏆', type: 'Gold Energy', power: 75, level: 1 },
        'tech-essence': { name: 'Tech Essence', icon: '⚡', type: 'Tech Energy', power: 80, level: 1 }
      },

      characterAuras: {
        a1: { name: 'Arch Angel', auras: ['dark', 'light'], unlockLevel: 50, dualAura: true },
        missy: { name: 'Golden Guardian', auras: ['gold'], unlockLevel: 15, dualAura: false },
        unique: { name: 'Tech Spirit', auras: ['pink', 'purple'], unlockLevel: 15, dualAura: false }
      },

      equipSpirit(spiritId) {
        if (this.spirits[spiritId]) {
          this.equippedSpirit = spiritId;
          this.updateSpiritDisplay();
          this.saveSpirit();
        }
      },

      unequipSpirit() {
        this.equippedSpirit = null;
        this.updateSpiritDisplay();
        this.saveSpirit();
      },

      updateSpiritDisplay() {
        const equippedEl = document.getElementById('equippedSpirit');
        if (equippedEl) {
          if (this.equippedSpirit && this.spirits[this.equippedSpirit]) {
            const spirit = this.spirits[this.equippedSpirit];
            equippedEl.innerHTML = `
              <div class="spirit-icon">${spirit.icon}</div>
              <div class="spirit-name">${spirit.name}</div>
              <div class="spirit-desc">${spirit.type} - Power: ${spirit.power}</div>
            `;
          } else {
            equippedEl.innerHTML = `
              <div class="spirit-icon">❌</div>
              <div class="spirit-name">No Spirit Equipped</div>
              <div class="spirit-desc">Select a spirit to equip</div>
            `;
          }
        }
      },

      saveSpirit() {
        localStorage.setItem('equippedSpirit', this.equippedSpirit);
      },

      loadSpirit() {
        const saved = localStorage.getItem('equippedSpirit');
        if (saved && this.spirits[saved]) {
          this.equippedSpirit = saved;
          this.updateSpiritDisplay();
        }
      }
    };

    // Initialize systems when DOM is ready
    document.addEventListener('DOMContentLoaded', function () {
      // Load saved data
      spiritSystem.loadSpirit();

      // Spirit system event listeners
      document.querySelectorAll('.spirit-item').forEach(item => {
        item.addEventListener('click', function () {
          const spiritId = this.dataset.spirit;
          spiritSystem.equipSpirit(spiritId);
        });
      });

      // Action buttons
      document.getElementById('equipSpirit')?.addEventListener('click', () => {
        // Equip selected spirit logic
      });

      document.getElementById('unequipSpirit')?.addEventListener('click', () => {
        spiritSystem.unequipSpirit();
      });
    });
  </script>

  <!-- Inject Anime Skill bridge (auto-integrated) -->
  <!-- This file has been consolidated into unified systems -->

  <script>
    /* INLINE A1K SKILLS (OFFLINE)
       No UI changes. No imports. No fetch.
       Do NOT touch Robox/background.
       Binds to existing S1/S2/S3/R & keys 1/2/3/4/R.
       Exposes: window.Skills.run("S1"|"A1.S2"|...).
       [A1K_STYLE] Solo-Leveling × DBZ × Bleach neon vibe
    */
    (function () {
      // Helpers and safe stubs
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const sgn = (d) => (d && d < 0 ? -1 : 1);
      function rng(seed = (Date.now() >>> 0)) { let s = seed >>> 0; return () => { s ^= s << 13; s ^= s >>> 17; s ^= s << 5; return (s >>> 0) / 0xffffffff; }; }
      function getWorld() {
        const w = window.game?.world || window.world || window.__world; if (w) return w;
        const stub = { seed: 1337, fx: { emit: (e) => console.info('[FX]', e) }, spawnHitbox: (h) => console.info('[HB]', h), spawnProjectile: (p) => console.info('[PR]', p), spawnSummon: (s) => console.info('[SUM]', s), now: () => Date.now() };
        window.__world = stub; console.warn('[inline skills] Using world stub.'); return stub;
      }
      function getHero() {
        const h = window.game?.party?.active || window.game?.player || window.hero || window.player;
        return h || { id: 101, name: 'A1', x: 100, y: 100, w: 32, h: 48, dir: 1, team: 'player', spriteId: 'hero_a1', rig: { arms: 'a1_arms', legs: 'a1_legs' }, hpMax: 350, rage: 3 };
      }

      // FX events
      const FX = {
        speed: (o) => ({ kind: 'speedlines', x: o.x, y: o.y, dir: o.dir ?? 1, n: o.n ?? 28, life: 220 }),
        slash: (o) => ({ kind: 'slash', x: o.x, y: o.y, dir: o.dir ?? 1, color: o.color || '#FF3B3B', life: 200 }),
        shock: (o) => ({ kind: 'shock', x: o.x, y: o.y, color: o.color || '#00E5FF', life: 240 }),
        bolt: (o) => ({ kind: 'bolt', x: o.x, y: o.y, life: 160 }),
        boom: (o) => ({ kind: 'boom', x: o.x, y: o.y, color: o.color || '#FF3B3B', life: 240 }),
        timeslice: () => ({ kind: 'time_slice', life: 280 }),
        aura: (id, t = 140) => ({ kind: 'aura_on', entityId: id, time: t }),
        hitflash: (o) => ({ kind: 'hit_flash', x: o.x, y: o.y, color: o.color || '#FFD1A1', life: 120 }),
        ground: (o) => ({ kind: 'ground_impact', x: o.x, y: o.y, mag: o.mag || 4, life: 180 }),
        cam: (mag = 6, time = 180) => ({ kind: 'camera_shake', mag, time })
      };

      // Building hitbox, projectile, summons
      function makeHitbox({ x, y, w = 48, h = 20, team, dmg = 80, life = 160, owner }) {
        return {
          kind: 'hitbox', x: x - w / 2, y: y - h / 2, w, h, team, dmg, life, owner,
          onHit: () => { owner?.world?.fx?.emit && owner.world.fx.emit(FX.hitflash({ x, y })); }
        };
      }
      function makeProjectile({ x, y, vx, vy, w = 12, h = 12, team, dmg = 60, life = 900, owner, kind = 'pierce', meta = {} }) {
        return { kind: 'projectile', x, y, vx, vy, w, h, team, dmg, life, owner, type: kind, meta };
      }
      function makeShadowClone({ hero, x, y, life = 30000, dmgScale = 0.65 }) {
        return {
          kind: 'summon', summonType: 'shadow_clone', team: hero.team, ownerId: hero.id,
          x: x ?? hero.x, y: y ?? hero.y, w: hero.w, h: hero.h, hp: Math.max(1, Math.round((hero.hpMax || 300) * 0.5)),
          dmgScale, lifespanMs: life,
          appearance: { spriteId: hero.spriteId || hero.appearance?.spriteId || 'hero_a1', rig: hero.rig || hero.appearance?.rig || null, tint: '#111a', alpha: 0.92, mimic: true },
          ai: { role: 'aggressive_melee', range: 84, jumpOk: true, preferBoss: true }, anim: { state: 'idle_ready', speed: 1.0 }
        };
      }
      function makeMicroDrone({ owner, x, y, life = 30000 }) {
        return {
          kind: 'summon', summonType: 'micro_drone', team: owner.team, ownerId: owner.id,
          x: x ?? (owner.x + 12), y: y ?? (owner.y - 46), w: 16, h: 14, hp: 1e9, lifespanMs: life,
          appearance: { spriteId: 'drone_basic', tint: '#A78BFA', alpha: 0.95, scale: 0.75 },
          ai: { role: 'ranged_support', orbit: 26, fireRate: 320, projectileKind: 'tech_beam' }
        };
      }
      function makeBeast({ owner, x, y, life = 30000 }) {
        return {
          kind: 'summon', summonType: 'beast_ally', team: owner.team, ownerId: owner.id,
          x: x ?? (owner.x + 10), y: y ?? owner.y, w: 58, h: 42, hp: 900, lifespanMs: life,
          appearance: { spriteId: 'beast_onyx', tint: '#2A1E3F', alpha: 1.0, scale: 1.25, bloom: 0.2 },
          ai: { role: 'frontliner_tank', dashCD: 1100, rushSpeed: 5.0, leash: 200 }
        };
      }

      // Execute one step
      function doStep(world, hero, step, bx, by, dir, withHB) {
        const x = bx + (step.dx || 0) * dir, y = by + (step.dy || 0);
        switch (step.a) {
          case 'speed': world.fx?.emit(FX.speed({ x, y, dir, n: step.n })); break;
          case 'shock': world.fx?.emit(FX.shock({ x, y })); world.fx?.emit(FX.cam(step.shake ?? 5, step.time ?? 160)); break;
          case 'timeslice': world.fx?.emit(FX.timeslice()); break;
          case 'aura': hero.id != null && world.fx?.emit(FX.aura(hero.id, step.time ?? 140)); break;
          case 'slash': world.fx?.emit(FX.slash({ x, y, dir, color: step.color }));
            if (withHB) world.spawnHitbox?.(makeHitbox({ x, y, w: step.w || 56, h: step.h || 24, team: hero.team, dmg: step.dmg || 140, life: step.life || 180, owner: hero })); break;
          case 'boom': world.fx?.emit(FX.boom({ x, y, color: step.color }));
            if (withHB) world.spawnHitbox?.(makeHitbox({ x: x - 12, y, w: step.w || 72, h: step.h || 48, team: hero.team, dmg: step.dmg || 220, life: step.life || 220, owner: hero }));
            world.fx?.emit(FX.ground({ x, y, mag: 6 })); break;
          case 'bolt': {
            const r = rng(world.seed || 12345), n = step.n || 8, spread = step.spread || 52, vs = step.vspread || 26;
            for (let i = 0; i < n; i++) {
              const bx2 = bx + (r() * 2 - 1) * spread, by2 = by - 60 + (r() * 2 - 1) * vs; world.fx?.emit(FX.bolt({ x: bx2, y: by2 + 60 }));
              if (withHB) world.spawnHitbox?.(makeHitbox({ x: bx2 - 8, y: by2 + 24, w: 22, h: 40, team: hero.team, dmg: step.dmg || 180, life: step.life || 180, owner: hero }));
            }
            world.fx?.emit(FX.cam(step.shake ?? 6, step.time ?? 180));
          } break;
          case 'projectile': {
            const r = rng(world.seed || 9001), n = step.n || 1, spread = step.spread || 0, spd = step.speed || 3.6;
            for (let i = 0; i < n; i++) {
              const ang = (r() * 2 - 1) * spread + (dir < 0 ? Math.PI : 0);
              const vx = Math.cos(ang) * spd * 60, vy = Math.sin(ang) * spd * 30;
              world.spawnProjectile?.(makeProjectile({ x, y, vx, vy, w: step.w || 12, h: step.h || 12, team: hero.team, dmg: step.dmg || 90, life: step.life || 900, owner: hero, kind: step.kind || 'pierce', meta: step.meta || {} }));
            }
          } break;
          case 'summon_clones': { const c = step.count || 3; for (let i = 0; i < c; i++)world.spawnSummon?.(makeShadowClone({ hero, x: hero.x + (i - (c - 1) / 2) * 20, y: hero.y, life: step.life || 30000, dmgScale: step.dmgScale ?? 0.65 })); } break;
          case 'summon_drones': { const c = step.count || 3; for (let i = 0; i < c; i++)world.spawnSummon?.(makeMicroDrone({ owner: hero, x: hero.x + 10 + i * 14, y: hero.y - 44, life: step.life || 30000 })); } break;
          case 'summon_beast': world.spawnSummon?.(makeBeast({ owner: hero, x: hero.x + 24 * dir, y: hero.y, life: step.life || 30000 })); break;
        }
      }

      // Skill definitions (precast → cast → aftermath)
      const REG = {
        A1: {
          S1: { id: 'A1.S1', precast: [{ a: 'speed' }], cast: [{ a: 'slash', dx: 32, w: 58, h: 24, dmg: 160 }, { a: 'shock', dx: 50, dy: 12 }], aftermath: [{ a: 'boom', dx: 72, dy: 8 }] },
          S2: { id: 'A1.S2', precast: [{ a: 'speed' }, { a: 'aura', time: 160 }], cast: [{ a: 'summon_clones', count: 3, life: 30000, dmgScale: 0.65 }], aftermath: [{ a: 'shock' }] },
          S3: { id: 'A1.S3', precast: [{ a: 'speed' }, { a: 'shock' }], cast: [{ a: 'slash', dx: 26, dy: -8, w: 86, h: 30, dmg: 240 }, { a: 'slash', dx: 72, dy: 4, w: 104, h: 32, dmg: 280 }], aftermath: [{ a: 'boom', dx: 96 }, { a: 'shock' }] },
          S4: { id: 'A1.S4', rageCost: 3, precast: [{ a: 'timeslice' }, { a: 'speed' }, { a: 'shock' }], cast: [{ a: 'slash', dx: 30, dy: -12, w: 112, h: 30, dmg: 320 }, { a: 'slash', dx: 70, w: 132, h: 34, dmg: 380 }, { a: 'slash', dx: 108, dy: 12, w: 152, h: 38, dmg: 460 }], aftermath: [{ a: 'boom', dx: 122 }, { a: 'shock' }], camera: { shake: 8, time: 220 } }
        },
        Unique: {
          S1: { id: 'Unique.S1', precast: [{ a: 'shock' }], cast: [{ a: 'projectile', kind: 'frost_shard', speed: 4.0, w: 22, h: 16, dmg: 140, n: 4, spread: 0.14 }], aftermath: [{ a: 'boom' }] },
          S2: { id: 'Unique.S2', precast: [{ a: 'speed' }], cast: [{ a: 'summon_drones', count: 3, life: 30000 }], aftermath: [{ a: 'shock' }] },
          S3: { id: 'Unique.S3', precast: [{ a: 'shock' }], cast: [{ a: 'bolt', n: 8, spread: 56, dmg: 200 }], aftermath: [{ a: 'boom' }] },
          S4: { id: 'Unique.S4', rageCost: 3, precast: [{ a: 'timeslice' }, { a: 'shock' }], cast: [{ a: 'bolt', n: 16, spread: 92, dmg: 220 }, { a: 'bolt', n: 12, spread: 130, dmg: 180 }], aftermath: [{ a: 'boom' }], camera: { shake: 8, time: 260 } }
        },
        Missy: {
          S1: { id: 'Missy.S1', precast: [{ a: 'speed' }], cast: [{ a: 'slash', dx: 28, w: 60, h: 26, dmg: 150 }, { a: 'projectile', kind: 'coin', n: 6, speed: 3.4, spread: 0.32, w: 10, h: 10, dmg: 44 }], aftermath: [{ a: 'shock' }] },
          S2: { id: 'Missy.S2', precast: [{ a: 'shock' }], cast: [{ a: 'summon_beast', life: 30000 }, { a: 'boom', dx: 48, w: 80, h: 48, dmg: 220 }], aftermath: [{ a: 'shock' }] },
          S3: { id: 'Missy.S3', precast: [{ a: 'shock' }], cast: [{ a: 'boom', dx: 64, w: 96, h: 56, dmg: 260 }], aftermath: [{ a: 'shock' }] },
          S4: { id: 'Missy.S4', rageCost: 3, precast: [{ a: 'timeslice' }], cast: [{ a: 'boom', dx: 58, w: 88, h: 52, dmg: 280 }, { a: 'projectile', kind: 'coin', n: 12, speed: 3.2, spread: 0.6, w: 10, h: 10, dmg: 52 }], aftermath: [{ a: 'shock' }], camera: { shake: 7, time: 200 } }
        }
      };

      function runSkill(world, hero, sid) {
        const group = REG[hero?.name || 'A1']; if (!group) return;
        const def = group[sid] || (sid.includes('.') ? group[sid.split('.')[1]] : group[sid]); if (!def) return;
        if (def.rageCost && (hero.rage || 0) < def.rageCost) return;
        if (def.rageCost) hero.rage = Math.max(0, (hero.rage || 0) - def.rageCost);
        hero.world = world;
        const dir = sgn(hero.dir || 1), bx = (hero.x || 0) + (hero.w || 0) / 2 + dir * 12, by = (hero.y || 0) + (hero.h || 0) / 2 - 10;
        (def.precast || []).forEach(s => doStep(world, hero, s, bx, by, dir, false));
        (def.cast || []).forEach(s => doStep(world, hero, s, bx, by, dir, true));
        (def.aftermath || []).forEach(s => doStep(world, hero, s, bx, by, dir, false));
        if (def.camera) world.fx?.emit(FX.cam(def.camera.shake || 6, def.camera.time || 180));
      }

      function bind() {
        const nodes = Array.from(document.querySelectorAll('button,[role="button"],.btn,.button,.hud-button'));
        const pick = (txt) => nodes.find(el => (el.dataset?.skill === txt) || ((el.textContent || '').trim().toUpperCase() === txt));
        const map = { S1: pick('S1'), S2: pick('S2'), S3: pick('S3'), S4: pick('R') || pick('RAGE') };
        // OLD SKILLS BINDING DISABLED - Using new src/skills/ system instead
        // Object.entries(map).forEach(([k, el]) => { if (!el) return; el.addEventListener('click', () => window.Skills.run(k)); console.info('[inline skills] bound', k); });
        // window.addEventListener('keydown', (e) => { const KM = { Digit1: 'S1', Digit2: 'S2', Digit3: 'S3', Digit4: 'S4', KeyR: 'S4' }; const s = KM[e.code]; if (s) window.Skills.run(s); });
        // console.info('[inline skills] keyboard ready (1/2/3/4/R).');
      }

      // OLD SKILLS SYSTEM DISABLED - Using new src/skills/ system instead
      // window.Skills = {
      //   run: (sidOrHero, maybeSid) => {
      //     const world = getWorld(); const hero = (typeof sidOrHero === 'string') ? getHero() : (sidOrHero || getHero());

      // === X-WAVE DEBUG TEST KEY ===
      // Press T to spawn a cross-burst at the leader for smoke testing
      addEventListener('keydown', (ev) => {
        if ((ev.code || ev.key) === 'KeyT') {
          const L = (window.st?.players || [])[window.st?.leader || 0];
          if (L && window.emitXCrossBurst) {
            emitXCrossBurst(L, 6);
            console.log('[X-WAVE TEST] Fired 6 X-waves from player position');
          }
        }
      }, true);

      //     const sid = (typeof sidOrHero === 'string') ? sidOrHero : (maybeSid || 'S1');
      //     const scoped = sid.includes('.') ? sid : `${hero.name}.${sid}`; runSkill(world, hero, scoped);
      //   },
      //   registry: REG,
      //   debug() { const h = getHero(); console.log('--- test A1.S1 ---'); this.run(h, 'S1'); console.log('--- test A1.S2 ---'); this.run(h, 'S2'); h.name = 'Unique'; console.log('--- test Unique.S2 ---'); this.run(h, 'S2'); h.name = 'Missy'; console.log('--- test Missy.S2 ---'); this.run(h, 'S2'); }
      // };
      if (document.readyState === 'complete' || document.readyState === 'interactive') bind(); else document.addEventListener('DOMContentLoaded', bind);
    })();
  </script>

</body>

</html>