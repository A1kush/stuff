<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Hero World</title>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
            }
        }
    </script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: #fff;
            font-family: monospace;
        }

        canvas {
            display: block;
        }

        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            display: block;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 10px;
        }

        #stats-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 154px;
            /* 30% smaller */
            max-height: 245px;
            /* 30% smaller */
            background-color: rgba(0, 0, 0, 0.7);
            padding: 0;
            border: 1px solid #555;
            border-radius: 5px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
            font-size: 11px;
            /* smaller font */
            display: flex;
            flex-direction: column;
            overflow: hidden;
            transition: transform 0.3s ease, opacity 0.3s ease;
        }

        #stats-panel.hidden {
            transform: translateY(-100%);
            opacity: 0;
            pointer-events: none;
        }

        .stats-panel-toggle {
            position: absolute;
            top: 5px;
            right: 5px;
            width: 24px;
            height: 24px;
            background-color: rgba(100, 100, 100, 0.7);
            border: 1px solid #555;
            border-radius: 3px;
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            z-index: 10;
            transition: background-color 0.2s;
        }

        .stats-panel-toggle:hover {
            background-color: rgba(150, 150, 150, 0.9);
        }

        .stats-panel-tabs {
            display: flex;
            background-color: rgba(0, 0, 0, 0.8);
            border-bottom: 1px solid #555;
            position: relative;
        }

        .stats-panel-tab {
            flex: 1;
            padding: 6px 4px;
            /* Reduced padding */
            background-color: rgba(50, 50, 50, 0.5);
            border: none;
            border-right: 1px solid #555;
            color: #ccc;
            cursor: pointer;
            font-size: 10px;
            /* Reduced font size */
            transition: all 0.2s;
            min-width: 0;
        }

        .stats-panel-tab:last-child {
            border-right: none;
        }

        .stats-panel-tab:hover {
            background-color: rgba(70, 70, 70, 0.7);
            color: #fff;
        }

        .stats-panel-tab.active {
            background-color: rgba(100, 100, 100, 0.8);
            color: #fff;
            font-weight: bold;
        }

        .stats-panel-content {
            padding: 10px;
            overflow-y: auto;
            max-height: 450px;
        }

        .stats-panel-tab-content {
            display: none;
        }

        .stats-panel-tab-content.active {
            display: block;
        }

        #stats-panel h3,
        #stats-panel h4 {
            margin: 0 0 5px 0;
            padding-bottom: 5px;
            border-bottom: 1px solid #444;
        }

        #stats-panel h4 {
            margin-top: 10px;
        }

        #stats-panel p {
            margin: 3px 0;
        }

        .stat-block {
            margin-bottom: 5px;
        }

        /* Radar/Map styles */
        .radar-container {
            position: relative;
            width: 100%;
            height: 126px;
            /* 30% smaller */
            background: radial-gradient(circle, rgba(0, 50, 0, 0.3) 0%, rgba(0, 0, 0, 0.8) 100%);
            border: 2px solid #0a0;
            border-radius: 5px;
            margin: 10px 0;
        }

        .radar-canvas {
            width: 100%;
            height: 100%;
            position: relative;
        }

        .radar-center {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            background: #0f0;
            border-radius: 50%;
            box-shadow: 0 0 10px #0f0;
        }

        .radar-dot {
            position: absolute;
            width: 6px;
            height: 6px;
            border-radius: 50%;
            transform: translate(-50%, -50%);
        }

        .radar-dot.enemy {
            background: #f00;
            box-shadow: 0 0 5px #f00;
        }

        .radar-dot.hero {
            background: #00f;
            box-shadow: 0 0 5px #00f;
        }

        .radar-dot.civilian {
            background: #ff0;
            box-shadow: 0 0 5px #ff0;
        }

        .radar-dot.party {
            background: #0ff;
            box-shadow: 0 0 5px #0ff;
        }

        .radar-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
            font-size: 11px;
        }

        .radar-legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .radar-legend-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .controls-list {
            list-style: none;
            padding: 0;
            margin: 10px 0;
        }

        .controls-list li {
            padding: 5px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .controls-list li:last-child {
            border-bottom: none;
        }

        .controls-list .key {
            display: inline-block;
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: bold;
            margin-right: 8px;
            min-width: 30px;
            text-align: center;
        }

        /* Stats panel show button when hidden */
        .stats-panel-show-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 40px;
            height: 40px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 1px solid #555;
            border-radius: 5px;
            color: #fff;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            z-index: 100;
            transition: background-color 0.2s;
        }

        .stats-panel-show-btn:hover {
            background-color: rgba(50, 50, 50, 0.9);
        }

        #stats-panel.hidden~.stats-panel-show-btn,
        .stats-panel-show-btn.visible {
            display: flex;
        }

        .hp-bar {
            width: 100%;
            height: 10px;
            background-color: #555;
            border: 1px solid #333;
            border-radius: 3px;
            margin-bottom: 5px;
        }

        .hp-fill {
            height: 100%;
            background-color: #4CAF50;
            /* Green */
            border-radius: 2px;
            transition: width 0.2s ease-in-out;
        }

        .xp-bar {
            width: 100%;
            height: 10px;
            background-color: #333;
            border: 1px solid #555;
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }

        .xp-fill {
            height: 100%;
            background-color: #a78bfa;
            /* Violet */
            border-radius: 2px;
            transition: width 0.3s ease-in-out;
            box-shadow: 0 0 10px rgba(167, 139, 250, 0.7);
        }

        .mp-bar {
            width: 100%;
            height: 10px;
            background-color: #333;
            border: 1px solid #555;
            border-radius: 3px;
            margin-top: 5px;
            overflow: hidden;
        }

        .mp-fill {
            height: 100%;
            background-color: #3b82f6;
            /* Blue */
            border-radius: 2px;
            transition: width 0.3s ease-in-out;
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.7);
        }


        #health-bars-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
            z-index: 10;
        }

        .enemy-health-bar {
            position: absolute;
            width: 60px;
            height: 6px;
            background-color: rgba(0, 0, 0, 0.5);
            border: 1px solid #fff;
            border-radius: 2px;
            transform: translateX(-50%);
            /* Center the bar */
        }

        .enemy-health-fill {
            width: 100%;
            height: 100%;
            background-color: #dc2626;
            /* Red */
            border-radius: 1px;
            transition: width 0.2s ease-in-out;
        }

        .skill-cooldown-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 1;
            /* Ensure it's above other content but below badges */
        }

        .skill-pill.on-cooldown {
            filter: grayscale(80%) brightness(0.7);
            cursor: not-allowed;
        }

        .skill-pill.not-enough-mana {
            filter: grayscale(50%) brightness(0.9);
            cursor: not-allowed;
        }

        .skill-pill.on-cooldown .skill-cooldown-overlay {
            opacity: 1;
        }


        #level-up-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.5);
            font-size: 80px;
            font-weight: bold;
            color: #ffd700;
            text-shadow: 0 0 10px #ffd700, 0 0 20px #ff8c00, 0 0 30px #ff8c00;
            z-index: 1001;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.5s ease-out, transform 0.5s ease-out;
        }


        #damage-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            /* Allows clicks to go through */
            overflow: hidden;
        }

        .damage-text {
            position: absolute;
            color: #ffc107;
            /* Yellow */
            font-size: 18px;
            font-weight: bold;
            text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000;
            opacity: 1;
            transition: transform 1s ease-out, opacity 1s ease-out;
            transform: translateY(0);
        }

        /* ===== A1K BUTTON SYSTEM - CANDY STYLE (SIZES REDUCED BY 20%) ===== */
        /* ===== LAYOUT ===== */
        #hud-wrap {
            position: fixed;
            inset: auto 0 0 0;
            padding: 10px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            pointer-events: none;
            z-index: 55;
        }

        #hud-left {
            pointer-events: auto;
            justify-self: start;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            margin-left: 32px;
        }

        #hud-right {
            pointer-events: auto;
            justify-self: end;
            display: grid;
            grid-template-rows: auto auto;
            gap: 8px;
            align-content: end;
            margin-right: 118px;
            margin-bottom: 32px;
        }

        /* ===== JOYSTICK - CANDY STYLE ===== */
        #vj-root {
            width: 112px;
            height: 112px;
            position: relative;
            -webkit-user-select: none;
            user-select: none;
            touch-action: none;
            filter: drop-shadow(0 6px 16px rgba(0, 0, 0, 0.4));
        }

        #vj-base {
            position: absolute;
            inset: 0;
            margin: auto;
            width: 94px;
            height: 94px;
            border-radius: 50%;
            background: radial-gradient(circle at 35% 25%, rgba(255, 255, 255, 0.15), rgba(122, 213, 255, 0.08), rgba(0, 0, 0, 0.4));
            border: 2px solid rgba(122, 213, 255, 0.35);
            box-shadow:
                inset 0 2px 10px rgba(0, 0, 0, 0.3),
                inset 0 -2px 8px rgba(122, 213, 255, 0.25),
                inset 0 1px 2px rgba(255, 255, 255, 0.4),
                0 0 20px rgba(122, 213, 255, 0.2);
        }

        #vj-knob {
            position: absolute;
            left: 50%;
            top: 50%;
            width: 45px;
            height: 45px;
            margin-left: -22.5px;
            margin-top: -22.5px;
            border-radius: 50%;
            background: radial-gradient(circle at 35% 25%, rgba(255, 255, 255, 0.35), rgba(122, 213, 255, 0.25), rgba(167, 139, 250, 0.15));
            border: 2px solid rgba(122, 213, 255, 0.85);
            box-shadow:
                0 5px 14px rgba(0, 0, 0, 0.4),
                0 0 22px rgba(122, 213, 255, 0.45),
                inset 0 2px 5px rgba(255, 255, 255, 0.45),
                inset 0 -2px 6px rgba(122, 213, 255, 0.3);
            transform: translate(0, 0);
            transition: transform 0.08s ease-out;
        }

        /* Joystick READY - Candy Pulse */
        @keyframes candyJoystickPulse {

            0%,
            100% {
                box-shadow:
                    0 5px 14px rgba(0, 0, 0, 0.4),
                    0 0 24px rgba(122, 213, 255, 0.5),
                    0 0 40px rgba(167, 139, 250, 0.4),
                    inset 0 2px 5px rgba(255, 255, 255, 0.5),
                    inset 0 -2px 6px rgba(122, 213, 255, 0.35);
            }

            50% {
                box-shadow:
                    0 5px 18px rgba(0, 0, 0, 0.45),
                    0 0 36px rgba(122, 213, 255, 0.75),
                    0 0 56px rgba(167, 139, 250, 0.6),
                    inset 0 2px 6px rgba(255, 255, 255, 0.6),
                    inset 0 -2px 8px rgba(122, 213, 255, 0.45);
                transform: translate(0, 0) scale(1.08);
            }
        }

        #vj-root.ready #vj-base {
            border-color: rgba(122, 213, 255, 0.7);
            box-shadow:
                inset 0 2px 11px rgba(0, 0, 0, 0.35),
                inset 0 -2px 10px rgba(122, 213, 255, 0.4),
                inset 0 1px 2px rgba(255, 255, 255, 0.5),
                0 0 26px rgba(122, 213, 255, 0.35);
        }

        #vj-root.ready #vj-knob {
            animation: candyJoystickPulse 1.6s ease-in-out infinite;
        }

        #vj-root.ready::after {
            content: "";
            position: absolute;
            inset: -6px;
            border-radius: 50%;
            border: 2px solid rgba(122, 213, 255, 0.5);
            box-shadow:
                0 0 22px rgba(122, 213, 255, 0.4),
                0 0 40px rgba(167, 139, 250, 0.35);
            pointer-events: none;
            animation: ringPulse 1.6s ease-in-out infinite;
        }

        @keyframes flashFade {
            from {
                opacity: 1;
            }

            to {
                opacity: 0;
            }
        }

        @keyframes ringPulse {

            0%,
            100% {
                opacity: 0.6;
                transform: scale(1);
            }

            50% {
                opacity: 1;
                transform: scale(1.05);
            }
        }

        /* ===== UTILITY BUTTONS - CANDY STYLE ===== */
        .utility-stack {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 12px;
            justify-content: center;
            align-items: center;
        }

        .utility-row {
            display: flex;
            gap: 8px;
        }

        .utility-btn {
            padding: 8px 11px;
            border-radius: 999px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: radial-gradient(ellipse at 30% 20%, rgba(255, 255, 255, 0.28), rgba(255, 182, 255, 0.12), rgba(167, 139, 250, 0.15));
            color: #fff;
            font-weight: 800;
            letter-spacing: .03em;
            font-size: 11px;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
            box-shadow:
                0 3px 13px rgba(0, 0, 0, 0.35),
                inset 0 1px 0 rgba(255, 255, 255, 0.4),
                inset 0 -2px 6px rgba(167, 139, 250, 0.3),
                0 0 16px rgba(255, 182, 255, 0.2);
            touch-action: manipulation;
            cursor: pointer;
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .utility-btn:hover {
            transform: translateY(-2px) scale(1.05);
            box-shadow:
                0 5px 16px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.5),
                inset 0 -2px 8px rgba(167, 139, 250, 0.4),
                0 0 22px rgba(255, 182, 255, 0.35);
        }

        .utility-btn:active {
            transform: translateY(1px) scale(0.97);
            box-shadow:
                0 2px 8px rgba(0, 0, 0, 0.3),
                inset 0 2px 8px rgba(0, 0, 0, 0.3),
                inset 0 -1px 3px rgba(255, 255, 255, 0.2);
        }

        /* Top row - Sky Candy */
        .utility-row.top .utility-btn {
            background: radial-gradient(ellipse at 30% 20%, rgba(255, 255, 255, 0.3), rgba(122, 213, 255, 0.2), rgba(168, 230, 255, 0.18));
            border-color: rgba(122, 213, 255, 0.5);
            box-shadow:
                0 3px 13px rgba(0, 0, 0, 0.35),
                inset 0 1px 0 rgba(255, 255, 255, 0.45),
                inset 0 -2px 6px rgba(122, 213, 255, 0.35),
                0 0 16px rgba(122, 213, 255, 0.25);
        }

        /* Bottom row - Yellow Candy */
        .utility-row.bot .utility-btn[data-btn="bag"],
        .utility-row.bot .utility-btn[data-btn="switch"] {
            background: radial-gradient(ellipse at 30% 20%, rgba(255, 255, 255, 0.28), rgba(255, 214, 102, 0.2), rgba(255, 235, 153, 0.15));
            border-color: rgba(255, 214, 102, 0.6);
            box-shadow:
                0 3px 13px rgba(0, 0, 0, 0.35),
                inset 0 1px 0 rgba(255, 255, 255, 0.4),
                inset 0 -2px 6px rgba(255, 214, 102, 0.35),
                0 0 16px rgba(255, 214, 102, 0.3);
        }

        /* AI Button - Purple Magic */
        .utility-btn[data-btn="ai"] {
            background: radial-gradient(ellipse at 30% 20%, rgba(255, 255, 255, 0.15), rgba(186, 85, 211, 0.18), rgba(233, 215, 255, 0.1));
            border: 2px dashed rgba(186, 85, 211, 0.75);
            color: #F3E8FF;
            box-shadow:
                0 3px 13px rgba(0, 0, 0, 0.35),
                inset 0 1px 0 rgba(255, 255, 255, 0.3),
                inset 0 -2px 6px rgba(186, 85, 211, 0.25),
                0 0 20px rgba(186, 85, 211, 0.3);
        }

        /* ===== SKILL PILLS - CANDY STYLE ===== */
        .skill-row {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
            justify-content: flex-end;
            position: relative;
        }

        .skill-pill {
            padding: 8px 11px;
            border-radius: 999px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            background: radial-gradient(ellipse at 30% 20%, rgba(255, 255, 255, 0.25), rgba(255, 255, 255, 0.08), rgba(0, 0, 0, 0.15));
            font-weight: 900;
            letter-spacing: .05em;
            font-size: 11px;
            position: relative;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.6);
            color: #fff;
            cursor: pointer;
            touch-action: manipulation;
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .skill-pill::after {
            content: attr(data-skill);
        }

        .skill-pill:active {
            transform: scale(0.95) translateY(2px);
        }

        /* S1 - Pink Candy */
        .skill-pill.s1 {
            border-color: rgba(255, 122, 217, 0.75);
            background: radial-gradient(ellipse at 30% 20%, rgba(255, 255, 255, 0.3), rgba(255, 122, 217, 0.25), rgba(255, 181, 232, 0.15));
            box-shadow:
                0 3px 13px rgba(0, 0, 0, 0.35),
                inset 0 2px 5px rgba(255, 255, 255, 0.4),
                inset 0 -2px 8px rgba(255, 122, 217, 0.3),
                0 0 20px rgba(255, 122, 217, 0.25);
        }

        /* S2 - Mint Candy */
        .skill-pill.s2 {
            border-color: rgba(122, 248, 200, 0.8);
            background: radial-gradient(ellipse at 30% 20%, rgba(255, 255, 255, 0.3), rgba(122, 248, 200, 0.25), rgba(168, 255, 224, 0.15));
            box-shadow:
                0 3px 13px rgba(0, 0, 0, 0.35),
                inset 0 2px 5px rgba(255, 255, 255, 0.4),
                inset 0 -2px 8px rgba(122, 248, 200, 0.3),
                0 0 20px rgba(122, 248, 200, 0.25);
        }

        /* S3 - Sky Candy */
        .skill-pill.s3 {
            border-color: rgba(122, 213, 255, 0.8);
            background: radial-gradient(ellipse at 30% 20%, rgba(255, 255, 255, 0.3), rgba(122, 213, 255, 0.25), rgba(168, 230, 255, 0.15));
            box-shadow:
                0 3px 13px rgba(0, 0, 0, 0.35),
                inset 0 2px 5px rgba(255, 255, 255, 0.4),
                inset 0 -2px 8px rgba(122, 213, 255, 0.3),
                0 0 20px rgba(122, 213, 255, 0.25);
        }

        /* READY GLOW ANIMATIONS */
        @keyframes candyGlowPink {

            0%,
            100% {
                box-shadow:
                    0 3px 13px rgba(0, 0, 0, 0.4),
                    0 0 22px rgba(255, 122, 217, 0.55),
                    0 0 32px rgba(255, 122, 217, 0.35),
                    inset 0 2px 6px rgba(255, 255, 255, 0.5),
                    inset 0 -2px 10px rgba(255, 122, 217, 0.4);
            }

            50% {
                box-shadow:
                    0 3px 16px rgba(0, 0, 0, 0.45),
                    0 0 32px rgba(255, 122, 217, 0.85),
                    0 0 48px rgba(255, 122, 217, 0.55),
                    inset 0 2px 8px rgba(255, 255, 255, 0.6),
                    inset 0 -2px 11px rgba(255, 122, 217, 0.5);
            }
        }

        @keyframes candyGlowMint {

            0%,
            100% {
                box-shadow:
                    0 3px 13px rgba(0, 0, 0, 0.4),
                    0 0 22px rgba(122, 248, 200, 0.55),
                    0 0 32px rgba(122, 248, 200, 0.35),
                    inset 0 2px 6px rgba(255, 255, 255, 0.5),
                    inset 0 -2px 10px rgba(122, 248, 200, 0.4);
            }

            50% {
                box-shadow:
                    0 3px 16px rgba(0, 0, 0, 0.45),
                    0 0 32px rgba(122, 248, 200, 0.85),
                    0 0 48px rgba(122, 248, 200, 0.55),
                    inset 0 2px 8px rgba(255, 255, 255, 0.6),
                    inset 0 -2px 11px rgba(122, 248, 200, 0.5);
            }
        }

        @keyframes candyGlowSky {

            0%,
            100% {
                box-shadow:
                    0 3px 13px rgba(0, 0, 0, 0.4),
                    0 0 22px rgba(122, 213, 255, 0.55),
                    0 0 32px rgba(122, 213, 255, 0.35),
                    inset 0 2px 6px rgba(255, 255, 255, 0.5),
                    inset 0 -2px 10px rgba(122, 213, 255, 0.4);
            }

            50% {
                box-shadow:
                    0 3px 16px rgba(0, 0, 0, 0.45),
                    0 0 32px rgba(122, 213, 255, 0.85),
                    0 0 48px rgba(122, 213, 255, 0.55),
                    inset 0 2px 8px rgba(255, 255, 255, 0.6),
                    inset 0 -2px 11px rgba(122, 213, 255, 0.5);
            }
        }

        .skill-pill.ready {
            filter: saturate(130%) brightness(1.1);
        }

        .skill-pill.s1.ready {
            animation: candyGlowPink 1.25s ease-in-out infinite;
        }

        .skill-pill.s2.ready {
            animation: candyGlowMint 1.25s ease-in-out infinite;
        }

        .skill-pill.s3.ready {
            animation: candyGlowSky 1.25s ease-in-out infinite;
        }

        .skill-pill.ready::before {
            content: "";
            position: absolute;
            inset: -5px;
            border-radius: 999px;
            border: 2px solid rgba(255, 255, 255, 0.35);
            pointer-events: none;
            animation: ringPulse 1.25s ease-in-out infinite;
        }

        /* Skill Tooltip */
        .skill-tooltip {
            position: fixed;
            background: linear-gradient(135deg, rgba(20, 20, 30, 0.95), rgba(10, 10, 20, 0.95));
            border: 2px solid rgba(255, 215, 0, 0.6);
            border-radius: 12px;
            padding: 12px 16px;
            min-width: 280px;
            max-width: 350px;
            z-index: 10000;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.8), 0 0 20px rgba(255, 215, 0, 0.3);
            font-size: 13px;
            line-height: 1.6;
        }

        .skill-tooltip.visible {
            opacity: 1;
        }

        .skill-tooltip-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(255, 215, 0, 0.3);
        }

        .skill-tooltip-icon {
            font-size: 24px;
        }

        .skill-tooltip-name {
            font-size: 16px;
            font-weight: bold;
            color: #FFD700;
            flex: 1;
        }

        .skill-tooltip-tier {
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 4px;
            background: rgba(255, 215, 0, 0.2);
            color: #FFD700;
        }

        .skill-tooltip-description {
            color: #ccc;
            margin-bottom: 10px;
            font-style: italic;
        }

        .skill-tooltip-stats {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            font-size: 12px;
        }

        .skill-tooltip-stat {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .skill-tooltip-stat-label {
            color: #aaa;
        }

        .skill-tooltip-stat-value {
            color: #fff;
            font-weight: bold;
        }

        .skill-tooltip-element {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(255, 215, 0, 0.3);
            font-size: 11px;
            color: #FFD700;
        }

        /* Synergy Combo Counter (inside stats panel) */
        #synergy-combo-counter {
            background: rgba(0, 0, 0, 0.6);
            border: 2px solid rgba(255, 215, 0, 0.6);
            border-radius: 8px;
            padding: 10px 15px;
            color: #FFD700;
            font-size: 14px;
            font-weight: bold;
            text-align: center;
            box-shadow: 0 0 15px rgba(255, 215, 0, 0.3);
            margin-bottom: 15px;
        }

        #synergy-combo-counter.active {
            animation: synergyComboPulse 0.5s ease-out;
        }

        #synergy-combo-counter .combo-label {
            font-size: 11px;
            color: #ccc;
            margin-bottom: 4px;
        }

        #synergy-combo-counter .combo-value {
            font-size: 28px;
            color: #FFD700;
            text-shadow: 0 0 8px rgba(255, 215, 0, 0.8);
            margin: 6px 0;
        }

        #synergy-combo-counter .combo-stats {
            font-size: 10px;
            color: #aaa;
            margin-top: 6px;
            border-top: 1px solid rgba(255, 215, 0, 0.2);
            padding-top: 6px;
            display: flex;
            justify-content: space-around;
        }

        @keyframes synergyComboPulse {
            0% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.15);
            }

            100% {
                transform: scale(1);
            }
        }

        /* Mastery UI Elements */
        .skill-pill .mastery-badge {
            position: absolute;
            top: -5px;
            right: -5px;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #FFD700, #FFA500);
            border: 2px solid #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            font-weight: bold;
            color: #000;
            z-index: 15;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }

        .skill-pill .mastery-xp-bar {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 0 0 999px 999px;
            overflow: hidden;
            z-index: 12;
        }

        .skill-pill .mastery-xp-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            transition: width 0.3s ease;
            box-shadow: 0 0 8px rgba(76, 175, 80, 0.6);
        }

        .skill-pill .mastery-tooltip {
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.95);
            color: #fff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
            z-index: 1000;
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        .skill-pill:hover .mastery-tooltip {
            opacity: 1;
        }

        /* Synergy UI Elements */
        .skill-pill.synergy-available {
            position: relative;
        }

        .skill-pill.synergy-available::after {
            content: "";
            position: absolute;
            inset: -4px;
            border-radius: 999px;
            border: 2px solid #FFD700;
            pointer-events: none;
            animation: synergyPulse 1.5s ease-in-out infinite;
            z-index: 5;
        }

        @keyframes synergyPulse {

            0%,
            100% {
                opacity: 0.6;
                transform: scale(1);
            }

            50% {
                opacity: 1;
                transform: scale(1.05);
            }
        }

        .synergy-connection {
            position: absolute;
            height: 2px;
            background: linear-gradient(90deg, rgba(255, 215, 0, 0.8), rgba(255, 165, 0, 0.8));
            z-index: 4;
            pointer-events: none;
            box-shadow: 0 0 8px rgba(255, 215, 0, 0.6);
            animation: synergyFlow 2s ease-in-out infinite;
            top: 0;
            left: 0;
        }

        @keyframes synergyFlow {

            0%,
            100% {
                opacity: 0.5;
            }

            50% {
                opacity: 1;
            }
        }

        .synergy-indicator {
            position: absolute;
            top: -12px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 215, 0, 0.9);
            color: #000;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 9px;
            font-weight: bold;
            z-index: 16;
            white-space: nowrap;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.4);
        }

        /* ===== ATTACK BUTTONS - CANDY STYLE ===== */
        .big-btn {
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
            padding: 14px 19px;
            border-radius: 16px;
            border: 3px solid rgba(255, 255, 255, 0.35);
            background: radial-gradient(ellipse at 30% 20%, rgba(255, 255, 255, 0.25), rgba(255, 255, 255, 0.1), rgba(0, 0, 0, 0.2));
            color: #fff;
            font-weight: 900;
            letter-spacing: .06em;
            font-size: 15px;
            text-shadow: 0 3px 8px rgba(0, 0, 0, 0.6);
            cursor: pointer;
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .big-btn:hover {
            transform: translateY(-3px) scale(1.03);
        }

        .big-btn:active {
            transform: translateY(2px) scale(0.97);
        }

        .big-btn.attack {
            border-color: rgba(255, 122, 217, 0.85);
            background: radial-gradient(ellipse at 30% 20%, rgba(255, 255, 255, 0.3), rgba(255, 122, 217, 0.25), rgba(255, 100, 150, 0.2));
            box-shadow:
                0 5px 20px rgba(0, 0, 0, 0.4),
                inset 0 2px 6px rgba(255, 255, 255, 0.4),
                inset 0 -3px 10px rgba(255, 122, 217, 0.35),
                0 0 26px rgba(255, 122, 217, 0.35);
        }

        .big-btn.jump {
            border-color: rgba(122, 213, 255, 0.85);
            background: radial-gradient(ellipse at 30% 20%, rgba(255, 255, 255, 0.3), rgba(122, 213, 255, 0.25), rgba(100, 180, 255, 0.2));
            box-shadow:
                0 5px 20px rgba(0, 0, 0, 0.4),
                inset 0 2px 6px rgba(255, 255, 255, 0.4),
                inset 0 -3px 10px rgba(122, 213, 255, 0.35),
                0 0 26px rgba(122, 213, 255, 0.35);
        }

        .rage-shield-container {
            position: absolute;
            right: -64px;
            top: 0%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .btn-container {
            position: relative;
        }

        .rage-shield-btn {
            width: 54px;
            height: 54px;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.35);
            background: radial-gradient(circle at 35% 25%, rgba(255, 255, 255, 0.3), rgba(255, 255, 255, 0.1), rgba(0, 0, 0, 0.2));
            color: #fff;
            font-weight: 900;
            letter-spacing: .05em;
            font-size: 9px;
            text-shadow: 0 2px 5px rgba(0, 0, 0, 0.6);
            cursor: pointer;
            touch-action: manipulation;
            -webkit-user-select: none;
            user-select: none;
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .rage-shield-btn:hover {
            transform: scale(1.08);
        }

        .rage-shield-btn:active {
            transform: scale(0.95);
        }

        .rage-shield-btn.rage {
            border-color: rgba(255, 100, 100, 0.85);
            background: radial-gradient(circle at 35% 25%, rgba(255, 255, 255, 0.3), rgba(255, 100, 100, 0.25), rgba(255, 50, 50, 0.2));
            box-shadow:
                0 5px 16px rgba(0, 0, 0, 0.4),
                inset 0 2px 5px rgba(255, 255, 255, 0.4),
                inset 0 -3px 8px rgba(255, 100, 100, 0.35),
                0 0 22px rgba(255, 100, 100, 0.35);
        }

        .rage-shield-btn.shield {
            border-color: rgba(100, 200, 255, 0.85);
            background: radial-gradient(circle at 35% 25%, rgba(255, 255, 255, 0.3), rgba(100, 200, 255, 0.25), rgba(80, 180, 255, 0.2));
            box-shadow:
                0 5px 16px rgba(0, 0, 0, 0.4),
                inset 0 2px 5px rgba(255, 255, 255, 0.4),
                inset 0 -3px 8px rgba(100, 200, 255, 0.35),
                0 0 22px rgba(100, 200, 255, 0.35);
        }

        /* ═══════════════════════════════════════════════════════════════════════════ */
        /* A1K BAG SYSTEM STYLES - Integrated from a1 last bag/index.html */
        /* ═══════════════════════════════════════════════════════════════════════════ */
        :root {
            --a1k-cyan: #00e5ff;
            --a1k-violet: #a78bfa;
            --a1k-red: #ff3b3b;
            --a1k-gold: #ffd77a;
            --a1k-green: #38ef7d;
            --bg-primary: #0a1220;
            --bg-panel: rgba(15, 24, 38, 0.98);
            --bg-secondary: rgba(20, 30, 45, 0.95);
            --text-primary: #cfe3ff;
            --text-secondary: rgba(207, 227, 255, 0.7);
            --border-default: rgba(79, 195, 247, 0.3);
            --shadow-default: 0 10px 30px rgba(0, 0, 0, 0.45);
            --transition-fast: 0.2s ease;
            --transition-normal: 0.3s ease;
            --rarity-common: #9ca3af;
            --rarity-uncommon: #10b981;
            --rarity-rare: #3b82f6;
            --rarity-epic: #a78bfa;
            --rarity-legendary: #f59e0b;
            --rarity-mythic: #ef4444;
        }

        /* ═══ BAG WINDOW ═══ */
        .bag-window {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 98vw;
            max-width: 1980px;
            height: 98vh;
            max-height: 1476px;
            background: linear-gradient(135deg, rgba(255, 154, 158, 0.15) 0%, rgba(254, 207, 239, 0.15) 50%, rgba(255, 236, 210, 0.15) 100%), var(--bg-panel);
            border: 3px solid rgba(255, 255, 255, 0.5);
            border-radius: 20px;
            box-shadow: 0 8px 0 rgba(0, 0, 0, 0.2), 0 12px 32px rgba(255, 105, 180, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.2);
            display: none;
            flex-direction: column;
            z-index: 999;
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
        }

        .bag-window.open {
            display: flex;
            animation: bagFadeIn 0.3s ease;
        }

        @keyframes bagFadeIn {
            from {
                opacity: 0;
                transform: translate(-50%, -45%);
            }

            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }

        /* ═══ HEADER ═══ */
        .bag-header {
            padding: 16px 24px;
            border-bottom: 2px solid var(--border-default);
            display: flex;
            justify-content: space-between;
            align-items: center;
            background: rgba(0, 0, 0, 0.2);
        }

        .bag-title {
            font-size: 24px;
            font-weight: 700;
            color: var(--a1k-gold);
            text-shadow: 0 2px 8px rgba(255, 215, 122, 0.4);
        }

        .bag-close-btn {
            background: rgba(255, 59, 59, 0.2);
            border: 2px solid var(--a1k-red);
            color: var(--a1k-red);
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all var(--transition-fast);
        }

        .bag-close-btn:hover {
            background: rgba(255, 59, 59, 0.4);
            transform: scale(1.05);
        }

        /* ═══ CURRENCIES ═══ */
        .bag-currencies {
            padding: 12px 24px;
            border-bottom: 2px solid var(--border-default);
            background: rgba(0, 0, 0, 0.15);
        }

        .currencies-strip {
            display: flex;
            gap: 16px;
            flex-wrap: wrap;
        }

        .currency-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: rgba(79, 195, 247, 0.1);
            border: 1px solid var(--border-default);
            border-radius: 8px;
        }

        .currency-icon {
            font-size: 20px;
        }

        .currency-details {
            display: flex;
            flex-direction: column;
        }

        .currency-label {
            font-size: 10px;
            color: var(--text-secondary);
        }

        .currency-value {
            font-size: 14px;
            font-weight: 700;
            color: var(--a1k-gold);
        }

        /* ═══ PRIMARY TABS ═══ */
        .bag-tabs-bar {
            padding: 12px 24px;
            border-bottom: 2px solid var(--border-default);
            background: rgba(0, 0, 0, 0.2);
        }

        .bag-tabs-strip {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .bag-tab {
            background: rgba(79, 195, 247, 0.1);
            border: 2px solid var(--border-default);
            color: var(--text-primary);
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: all var(--transition-fast);
        }

        .bag-tab:hover {
            background: rgba(79, 195, 247, 0.2);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(79, 195, 247, 0.3);
        }

        .bag-tab.active {
            background: linear-gradient(135deg, rgba(79, 195, 247, 0.3), rgba(167, 139, 250, 0.3));
            border-color: var(--a1k-cyan);
            box-shadow: 0 0 20px rgba(79, 195, 247, 0.5);
        }

        .tab-icon {
            font-size: 18px;
        }

        /* ═══ SUB-TABS (HUB NAVIGATION) ═══ */
        .hub-subtabs {
            padding: 12px 24px;
            border-bottom: 2px solid var(--border-default);
            background: rgba(0, 0, 0, 0.15);
            display: none;
            gap: 8px;
            flex-wrap: wrap;
        }

        .hub-subtabs.active {
            display: flex;
        }

        .hub-subtab {
            background: rgba(167, 139, 250, 0.1);
            border: 2px solid rgba(167, 139, 250, 0.3);
            color: var(--text-primary);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 500;
            font-size: 12px;
            transition: all var(--transition-fast);
        }

        .hub-subtab:hover {
            background: rgba(167, 139, 250, 0.2);
            transform: translateY(-1px);
        }

        .hub-subtab.active {
            background: linear-gradient(135deg, rgba(167, 139, 250, 0.3), rgba(79, 195, 247, 0.3));
            border-color: var(--a1k-violet);
            box-shadow: 0 0 15px rgba(167, 139, 250, 0.4);
        }

        /* ═══ CONTENT PANE ═══ */
        .bag-content-pane {
            flex: 1;
            padding: 24px;
            overflow-y: auto;
            overflow-x: hidden;
        }

        /* ═══ GRID LAYOUTS ═══ */
        .cards-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 16px;
        }

        .item-card {
            background: var(--bg-secondary);
            border: 2px solid var(--border-default);
            border-radius: 12px;
            padding: 16px;
            text-align: center;
            transition: all var(--transition-fast);
            position: relative;
        }

        .item-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(79, 195, 247, 0.3);
            border-color: var(--a1k-cyan);
        }

        .item-card[data-rarity="common"] {
            border-color: var(--rarity-common);
        }

        .item-card[data-rarity="uncommon"] {
            border-color: var(--rarity-uncommon);
        }

        .item-card[data-rarity="rare"] {
            border-color: var(--rarity-rare);
        }

        .item-card[data-rarity="epic"] {
            border-color: var(--rarity-epic);
            box-shadow: 0 0 20px rgba(167, 139, 250, 0.3);
        }

        .item-card[data-rarity="legendary"] {
            border-color: var(--rarity-legendary);
            box-shadow: 0 0 25px rgba(245, 158, 11, 0.4);
        }

        .item-card[data-rarity="mythic"] {
            border-color: var(--rarity-mythic);
            box-shadow: 0 0 30px rgba(239, 68, 68, 0.5);
            animation: mythicGlow 2s ease-in-out infinite;
        }

        @keyframes mythicGlow {

            0%,
            100% {
                box-shadow: 0 0 30px rgba(239, 68, 68, 0.5);
            }

            50% {
                box-shadow: 0 0 40px rgba(239, 68, 68, 0.7);
            }
        }

        .item-icon {
            font-size: 48px;
            margin-bottom: 12px;
        }

        .item-name {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 8px;
        }

        .item-rarity {
            font-size: 11px;
            text-transform: uppercase;
            font-weight: 700;
            margin-bottom: 8px;
        }

        .item-rarity[data-rarity="common"] {
            color: var(--rarity-common);
        }

        .item-rarity[data-rarity="uncommon"] {
            color: var(--rarity-uncommon);
        }

        .item-rarity[data-rarity="rare"] {
            color: var(--rarity-rare);
        }

        .item-rarity[data-rarity="epic"] {
            color: var(--rarity-epic);
        }

        .item-rarity[data-rarity="legendary"] {
            color: var(--rarity-legendary);
        }

        .item-rarity[data-rarity="mythic"] {
            color: var(--rarity-mythic);
        }

        .item-description {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 12px;
            min-height: 36px;
        }

        .item-stats {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 12px;
            text-align: left;
        }

        .item-action-btn {
            background: linear-gradient(135deg, rgba(79, 195, 247, 0.3), rgba(167, 139, 250, 0.3));
            border: 2px solid var(--a1k-cyan);
            color: var(--text-primary);
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 12px;
            width: 100%;
            transition: all var(--transition-fast);
        }

        .item-action-btn:hover {
            background: linear-gradient(135deg, rgba(79, 195, 247, 0.5), rgba(167, 139, 250, 0.5));
            transform: scale(1.05);
        }

        /* ═══ COMPANIONS OVERVIEW ═══ */
        .companions-overview {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 16px;
        }

        .companion-card {
            background: var(--bg-secondary);
            border: 2px solid var(--border-default);
            border-radius: 12px;
            padding: 16px;
            transition: all var(--transition-fast);
        }

        .companion-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 24px rgba(79, 195, 247, 0.3);
            border-color: var(--a1k-cyan);
        }

        .companion-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 12px;
        }

        .companion-icon {
            font-size: 32px;
        }

        .companion-info h3 {
            font-size: 16px;
            color: var(--a1k-gold);
            margin-bottom: 4px;
        }

        .companion-info p {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .companion-stats {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid var(--border-default);
        }

        .stat-label {
            color: var(--text-secondary);
        }

        .stat-value {
            color: var(--a1k-green);
            font-weight: 600;
        }

        /* ═══ EMPTY STATE ═══ */
        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--text-secondary);
        }

        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 16px;
            opacity: 0.5;
        }

        .empty-state-text {
            font-size: 18px;
            margin-bottom: 8px;
        }

        .empty-state-subtext {
            font-size: 14px;
            opacity: 0.7;
        }

        /* ═══ SETTINGS STYLES ═══ */
        .settings-section {
            display: none;
        }

        .settings-section.active {
            display: block;
        }

        .setting-group {
            background: var(--bg-secondary);
            border: 2px solid var(--border-default);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 16px;
        }

        .setting-group h3 {
            font-size: 18px;
            color: var(--a1k-gold);
            margin-bottom: 16px;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid var(--border-default);
        }

        .setting-item:last-child {
            border-bottom: none;
        }

        .setting-label {
            font-size: 14px;
            color: var(--text-primary);
        }

        .setting-control {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
            background: rgba(79, 195, 247, 0.3);
            border-radius: 13px;
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .toggle-switch.active {
            background: var(--a1k-green);
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            top: 3px;
            left: 3px;
            transition: all var(--transition-fast);
        }

        .toggle-switch.active::after {
            left: 27px;
        }

        .slider {
            width: 200px;
            height: 6px;
            background: rgba(79, 195, 247, 0.3);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            background: var(--a1k-cyan);
            border-radius: 50%;
            cursor: pointer;
        }

        /* ═══ SCROLLBAR ═══ */
        .bag-content-pane::-webkit-scrollbar {
            width: 8px;
        }

        .bag-content-pane::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }

        .bag-content-pane::-webkit-scrollbar-thumb {
            background: rgba(79, 195, 247, 0.5);
            border-radius: 4px;
        }

        .bag-content-pane::-webkit-scrollbar-thumb:hover {
            background: rgba(79, 195, 247, 0.7);
        }

        /* ═══ GEAR SLOTS ═══ */
        .gear-slots-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 16px;
            margin-bottom: 24px;
        }

        .gear-slot {
            background: var(--bg-secondary);
            border: 2px dashed var(--border-default);
            border-radius: 12px;
            padding: 16px;
            text-align: center;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        .gear-slot.equipped {
            border: 2px solid var(--a1k-green);
            background: rgba(56, 239, 125, 0.1);
        }

        .gear-slot-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 8px;
            text-transform: uppercase;
        }

        .gear-slot-item {
            font-size: 32px;
            margin-bottom: 8px;
        }

        .gear-slot-name {
            font-size: 11px;
            color: var(--text-primary);
        }

        /* ═══ ALCHEMY GRID ═══ */
        .alchemy-container {
            display: flex;
            gap: 24px;
            flex-wrap: wrap;
        }

        .alchemy-grid-section {
            flex: 1;
            min-width: 300px;
        }

        .alchemy-title {
            font-size: 18px;
            color: var(--a1k-gold);
            margin-bottom: 16px;
            text-align: center;
        }

        .alchemy-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            background: var(--bg-secondary);
            border: 2px solid var(--border-default);
            border-radius: 12px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .alchemy-square {
            aspect-ratio: 1;
            background: rgba(79, 195, 247, 0.1);
            border: 2px dashed var(--border-default);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all var(--transition-fast);
            position: relative;
            min-height: 80px;
        }

        .alchemy-square:hover {
            background: rgba(79, 195, 247, 0.2);
            border-color: var(--a1k-cyan);
            transform: scale(1.05);
        }

        .alchemy-square.filled {
            background: rgba(167, 139, 250, 0.2);
            border: 2px solid var(--a1k-violet);
            border-style: solid;
        }

        .alchemy-square-icon {
            font-size: 32px;
        }

        .alchemy-square-name {
            position: absolute;
            bottom: 4px;
            left: 4px;
            right: 4px;
            font-size: 9px;
            color: var(--text-primary);
            text-align: center;
            background: rgba(0, 0, 0, 0.6);
            border-radius: 4px;
            padding: 2px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .alchemy-result {
            background: var(--bg-secondary);
            border: 3px solid var(--a1k-gold);
            border-radius: 12px;
            padding: 24px;
            text-align: center;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .alchemy-result-label {
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 12px;
            text-transform: uppercase;
        }

        .alchemy-result-icon {
            font-size: 64px;
            margin-bottom: 12px;
        }

        .alchemy-result-name {
            font-size: 16px;
            color: var(--a1k-gold);
            font-weight: 600;
            margin-bottom: 8px;
        }

        .alchemy-craft-btn {
            background: linear-gradient(135deg, rgba(79, 195, 247, 0.3), rgba(167, 139, 250, 0.3));
            border: 2px solid var(--a1k-cyan);
            color: var(--text-primary);
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 700;
            font-size: 14px;
            margin-top: 16px;
            transition: all var(--transition-fast);
            width: 100%;
        }

        .alchemy-craft-btn:hover:not(:disabled) {
            background: linear-gradient(135deg, rgba(79, 195, 247, 0.5), rgba(167, 139, 250, 0.5));
            transform: scale(1.05);
        }

        .alchemy-craft-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .alchemy-recipes {
            background: var(--bg-secondary);
            border: 2px solid var(--border-default);
            border-radius: 12px;
            padding: 16px;
            max-height: 500px;
            overflow-y: auto;
        }

        .alchemy-recipe-card {
            background: rgba(79, 195, 247, 0.1);
            border: 1px solid var(--border-default);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
            cursor: pointer;
            transition: all var(--transition-fast);
        }

        .alchemy-recipe-card:hover {
            background: rgba(79, 195, 247, 0.2);
            border-color: var(--a1k-cyan);
            transform: translateX(4px);
        }

        .alchemy-recipe-name {
            font-size: 14px;
            color: var(--a1k-gold);
            font-weight: 600;
            margin-bottom: 8px;
        }

        .alchemy-recipe-ingredients {
            font-size: 11px;
            color: var(--text-secondary);
            margin-bottom: 4px;
        }

        .alchemy-recipe-result {
            font-size: 12px;
            color: var(--a1k-green);
            font-weight: 600;
        }

        /* ═══ SKILL SELECTOR MODAL ═══ */
        .skill-selector-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            -webkit-backdrop-filter: blur(10px);
            backdrop-filter: blur(10px);
            z-index: 10000;
            display: none;
            align-items: center;
            justify-content: center;
            animation: modalFadeIn 0.3s ease;
        }

        .skill-selector-modal.open {
            display: flex;
        }

        @keyframes modalFadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        .skill-selector-content {
            background: var(--bg-panel);
            border: 3px solid var(--a1k-cyan);
            border-radius: 20px;
            padding: 24px;
            max-width: 800px;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
            position: relative;
        }

        .skill-selector-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 16px;
            border-bottom: 2px solid var(--border-default);
        }

        .skill-selector-title {
            font-size: 20px;
            font-weight: 700;
            color: var(--a1k-gold);
        }

        .skill-selector-close {
            background: rgba(255, 59, 59, 0.2);
            border: 2px solid var(--a1k-red);
            color: var(--a1k-red);
            padding: 8px 16px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: all var(--transition-fast);
        }

        .skill-selector-close:hover {
            background: rgba(255, 59, 59, 0.4);
            transform: scale(1.05);
        }

        .skill-selector-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(180px, 1fr));
            gap: 12px;
        }

        .skill-selector-item {
            background: var(--bg-secondary);
            border: 2px solid var(--border-default);
            border-radius: 12px;
            padding: 12px;
            cursor: pointer;
            transition: all var(--transition-fast);
            text-align: center;
        }

        .skill-selector-item:hover {
            transform: translateY(-4px);
            border-color: var(--a1k-cyan);
            box-shadow: 0 8px 24px rgba(79, 195, 247, 0.3);
        }

        .skill-selector-item.selected {
            border-color: var(--a1k-green);
            background: rgba(56, 239, 125, 0.1);
            box-shadow: 0 0 20px rgba(56, 239, 125, 0.4);
        }

        .skill-selector-item.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .skill-selector-item-icon {
            font-size: 32px;
            margin-bottom: 8px;
        }

        .skill-selector-item-name {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-primary);
            margin-bottom: 4px;
        }

        .skill-selector-item-slot {
            font-size: 10px;
            color: var(--text-secondary);
        }

        .opacity-50 {
            opacity: 0.5;
        }

        @keyframes toastSlideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes toastSlideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }

            to {
                transform: translateX(400px);
                opacity: 0;
            }
        }

        /* Hidden state for synergy combo counter */
        #synergy-combo-counter.hidden {
            display: none;
        }

        /* XP text styling */
        .xp-text-styled {
            text-align: right;
            font-size: 10px;
            margin-top: 2px;
        }

        /* Backpack section header */
        .backpack-header {
            margin-top: 24px;
        }

        /* Game Over Screen */
        #game-over-screen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 200;
            font-size: 48px;
        }

        /* Restart button */
        .restart-button {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 20px;
            cursor: pointer;
            background: #333;
            color: white;
            border: 1px solid #555;
            border-radius: 5px;
        }

        .restart-button:hover {
            background: #444;
        }

        .restart-button:active {
            background: #222;
        }
    </style>
</head>

<body>

    <div id="level-up-indicator">LEVEL UP!</div>
    <div id="health-bars-container"></div>

    <div id="stats-panel">
        <button class="stats-panel-toggle" id="stats-panel-toggle" title="Hide/Show Panel">−</button>
        <div class="stats-panel-tabs">
            <button class="stats-panel-tab" data-tab="stats">Stats</button>
            <button class="stats-panel-tab" data-tab="info">Info</button>
            <button class="stats-panel-tab active" data-tab="radar">Map</button>
            <button class="stats-panel-tab" data-tab="mastery">Mastery</button>
            <button class="stats-panel-tab" data-tab="heatmap">Heatmap</button>
            <button class="stats-panel-tab" data-tab="logs">Logs</button>
        </div>
        <div class="stats-panel-content">
            <div class="stats-panel-tab-content" id="stats-tab-content">
                <div id="synergy-combo-counter" class="hidden">
                    <div class="combo-label">SYNERGY COMBO</div>
                    <div class="combo-value">0x</div>
                    <div class="combo-stats">
                        <span>DMG: <span id="combo-damage">+0%</span></span>
                        <span>CRIT: <span id="combo-crit">+0%</span></span>
                    </div>
                </div>

                <div class="stat-block">
                    <h4>Progression</h4>
                    <p>Level: <span id="hero-level">1</span></p>
                    <div class="xp-bar">
                        <div class="xp-fill" id="hero-xp-fill"></div>
                    </div>
                    <p class="xp-text-styled"><span id="hero-xp-text">0 /
                            100</span></p>
                </div>

            </div>
            <div class="stats-panel-tab-content" id="info-tab-content"></div>
            <div class="stats-panel-tab-content active" id="radar-tab-content"></div>
            <div class="stats-panel-tab-content" id="mastery-tab-content"></div>
            <div class="stats-panel-tab-content" id="heatmap-tab-content"></div>
            <div class="stats-panel-tab-content" id="logs-tab-content">
                <!-- Synergy Combo Counter -->
                <div id="synergy-combo-counter-logs">
                    <div class="combo-label">SYNERGY COMBO</div>
                    <div class="combo-value" id="synergy-combo-value">0</div>
                    <div class="combo-stats">
                        <div>Total: <span id="synergy-total">0</span></div>
                        <div>Best: <span id="synergy-max">0</span></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <button class="stats-panel-show-btn" id="stats-panel-show-btn" title="Show Stats Panel">📊</button>

    <div id="damage-container"></div>

    <!-- A1K Button System HUD -->
    <div id="hud-wrap">
        <!-- LEFT CLUSTER -->
        <div id="hud-left">
            <!-- Utility Buttons -->
            <div class="utility-stack">
                <div class="utility-row top">
                    <button class="utility-btn" data-btn="pet">Pet</button>
                    <button class="utility-btn" data-btn="veh">Veh</button>
                    <button class="utility-btn" data-btn="act">Act</button>
                    <button class="utility-btn" data-btn="act2">Act2</button>
                </div>
                <div class="utility-row bot">
                    <button class="utility-btn" data-btn="bag">Bag</button>
                    <button class="utility-btn" data-btn="ai">AI</button>
                    <button class="utility-btn" data-btn="switch">Switch</button>
                </div>
            </div>

            <!-- Joystick -->
            <div id="vj-root">
                <div id="vj-base"></div>
                <div id="vj-knob"></div>
            </div>
        </div>

        <!-- RIGHT CLUSTER -->
        <div id="hud-right">
            <!-- Skill Pills -->
            <div class="skill-row">
                <button class="skill-pill s1" data-skill="S1" data-btn="s1" aria-label="Skill 1"></button>
                <button class="skill-pill s2" data-skill="S2" data-btn="s2" aria-label="Skill 2"></button>
                <button class="skill-pill s3" data-skill="S3" data-btn="s3" aria-label="Skill 3"></button>
            </div>

            <!-- Attack Buttons -->
            <div class="btn-container">
                <button class="big-btn attack" data-btn="attack">ATTACK</button>
                <button class="big-btn jump" data-btn="jump">JUMP</button>
                <div class="rage-shield-container">
                    <button class="rage-shield-btn rage" data-btn="rage">RAGE</button>
                    <button class="rage-shield-btn shield" data-btn="shield">SHIELD</button>
                </div>
            </div>
        </div>
    </div>


    <!-- ═══════════════════════════════════════════════════════════════════════════ -->
    <!-- A1K BAG SYSTEM - HTML STRUCTURE -->
    <!-- ═══════════════════════════════════════════════════════════════════════════ -->
    <div class="bag-window" id="bag-window">
        <div class="bag-header">
            <h2 class="bag-title">🎒 Inventory</h2>
            <button class="bag-close-btn" id="bag-close-btn">Close</button>
        </div>
        <div class="bag-tabs-bar">
            <div class="bag-tabs-strip">
                <button class="bag-tab active" data-tab="inventory"><span class="tab-icon">📦</span> Gear &
                    Items</button>
                <button class="bag-tab" data-tab="companions"><span class="tab-icon">🐾</span> Companions</button>
                <button class="bag-tab" data-tab="alchemy"><span class="tab-icon">⚗️</span> Alchemy</button>
                <button class="bag-tab" data-tab="settings"><span class="tab-icon">⚙️</span> Settings</button>
            </div>
        </div>
        <div class="bag-content-pane">
            <!-- INVENTORY TAB CONTENT -->
            <div class="hub-subtabs active" id="hub-inventory">
                <h3>Equipped Gear</h3>
                <div class="gear-slots-container">
                    <div class="gear-slot" data-slot="weapon">
                        <div class="gear-slot-label">Weapon</div>
                        <div class="gear-slot-item opacity-50">➕</div>
                        <div class="gear-slot-name">Empty</div>
                    </div>
                    <div class="gear-slot" data-slot="helmet">
                        <div class="gear-slot-label">Helmet</div>
                        <div class="gear-slot-item opacity-50">➕</div>
                        <div class="gear-slot-name">Empty</div>
                    </div>
                    <div class="gear-slot" data-slot="chest">
                        <div class="gear-slot-label">Chest</div>
                        <div class="gear-slot-item opacity-50">➕</div>
                        <div class="gear-slot-name">Empty</div>
                    </div>
                    <div class="gear-slot" data-slot="legs">
                        <div class="gear-slot-label">Legs</div>
                        <div class="gear-slot-item opacity-50">➕</div>
                        <div class="gear-slot-name">Empty</div>
                    </div>
                    <div class="gear-slot" data-slot="boots">
                        <div class="gear-slot-label">Boots</div>
                        <div class="gear-slot-item opacity-50">➕</div>
                        <div class="gear-slot-name">Empty</div>
                    </div>
                    <div class="gear-slot" data-slot="accessory">
                        <div class="gear-slot-label">Accessory</div>
                        <div class="gear-slot-item opacity-50">➕</div>
                        <div class="gear-slot-name">Empty</div>
                    </div>
                </div>
                <h3 class="backpack-header">Backpack</h3>
                <div class="cards-grid">
                    <!-- Items will be injected here by JS -->
                </div>
            </div>
            <!-- OTHER TABS (for future use) -->
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';

        // -- CONFIG --
        const WORLD_SIZE = 500;
        const PLAYER_BASE_SPEED = 20.0;
        const PLAYER_SPRINT_SPEED = 35.0;
        const PLAYER_ROTATION_SPEED = 2.5;
        const NPC_COUNT = 30;
        const CAMERA_DISTANCE = 15;
        const CAMERA_HEIGHT = 8;

        // ═══════════════════════════════════════════════════════════════
        // PHASE 1.1: SKILL DATA ARRAYS - All 18 Core Skills
        // ═══════════════════════════════════════════════════════════════

        // A1 Skills (Warrior) - 6 skills
        const A1_SKILLS_DATA = [
            {
                id: 'A1_S1',
                name: 'Crimson Slash',
                characterId: 'A1',
                slot: 1,
                baseDamage: 150,
                damage: 150,
                cooldown: 2.5,
                unlockLevel: 1,
                unlock: 1,
                projectileCount: 3,
                shape: 'xwave',
                color: '#ff0000',
                icon: '⚔️',
                description: 'Launch 3 crimson X-wave projectiles',
                element: 'PHYSICAL',
                tier: 'common',
                // Enhanced stats
                critChance: 0.05,
                critMultiplier: 2.0,
                pierceCount: 0,
                bounceCount: 0,
                areaOfEffect: 0,
                knockback: 0,
                lifesteal: 0,
                statusEffects: [],
                damageOverTime: 0,
                slowAmount: 0,
                stunDuration: 0
            },
            {
                id: 'A1_S2',
                name: 'Summon Clone',
                characterId: 'A1',
                slot: 2,
                baseDamage: 0,
                damage: 0,
                cooldown: 15,
                unlockLevel: 20,
                unlock: 20,
                projectileCount: 0,
                shape: 'summon',
                color: '#ff0000',
                icon: '👥',
                description: 'Summon a shadow clone to fight alongside you',
                element: 'SUMMON',
                tier: 'uncommon'
            },
            {
                id: 'A1_S3',
                name: 'Power Wave',
                characterId: 'A1',
                slot: 3,
                baseDamage: 250,
                damage: 250,
                cooldown: 4,
                unlockLevel: 1,
                unlock: 1,
                projectileCount: 4,
                shape: 'xwave',
                enhanced: true,
                color: '#ff0000',
                icon: '💥',
                description: 'Unleash 4 enhanced power waves with Tier 3 VFX',
                element: 'ENERGY',
                tier: 'rare',
                // Enhanced stats
                critChance: 0.10,
                critMultiplier: 2.2,
                pierceCount: 2,
                bounceCount: 0,
                areaOfEffect: 3,
                knockback: 5,
                lifesteal: 0,
                statusEffects: [],
                damageOverTime: 0,
                slowAmount: 0,
                stunDuration: 0
            },
            {
                id: 'A1_S4',
                name: 'Phantom Step: Backstab Waltz',
                characterId: 'A1',
                slot: 4,
                baseDamage: 110,
                damage: 110,
                cooldown: 20,
                unlockLevel: 30,
                unlock: 30,
                setupSwings: 6,
                swingInterval: 0.12,
                finalPower: 320,
                executeThreshold: 0.30,
                arcRadius: 120,
                crescentRadius: 180,
                teleport: true,
                vacuumRadius: 80,
                shape: 'backstab_waltz',
                enhanced: true,
                color: '#00E5FF',
                icon: '⏰',
                description: 'Teleport backstab combo with time manipulation',
                element: 'SHADOW',
                tier: 'epic'
            },
            {
                id: 'A1_S5',
                name: 'Crimson Cyclone: Blink Chain',
                characterId: 'A1',
                slot: 5,
                baseDamage: 150,
                damage: 150,
                cooldown: 24,
                unlockLevel: 40,
                unlock: 40,
                blinkCount: 3,
                spinTicks: 6,
                spinTickDamage: 50,
                slamDamage: 300,
                stunDuration: 0.4,
                vortexRadius: 200,
                shape: 'blink_chain',
                enhanced: true,
                color: '#FF0000',
                icon: '🌪️',
                description: 'Blink between enemies in a crimson cyclone',
                element: 'PHYSICAL',
                tier: 'epic',
                // Enhanced stats
                critChance: 0.15,
                critMultiplier: 2.5,
                pierceCount: 0,
                bounceCount: 0,
                areaOfEffect: 8,
                knockback: 10,
                lifesteal: 0.1,
                statusEffects: [{ type: 'STUN', duration: 0.4, stacks: 1 }],
                damageOverTime: 0,
                slowAmount: 0,
                stunDuration: 0.4
            },
            {
                id: 'A1_X1',
                name: 'World Splitter',
                characterId: 'A1',
                slot: 'X',
                baseDamage: [260, 320, 380],
                damage: 260,
                cooldown: 28,
                unlockLevel: 50,
                unlock: 50,
                charge: { t1: 0.50, t2: 0.80 },
                riftCount: 2,
                riftWidth: [60, 75, 90],
                riftSeparation: 36,
                pierceUnlimited: true,
                bossTailBonus: 0.25,
                bleedDps: 20,
                bleedDuration: 2.0,
                shape: 'world_splitter',
                color: '#00E5FF',
                icon: '🌌',
                description: 'Create twin dimensional rifts (Chargeable Ultimate)',
                element: 'ARCANE',
                tier: 'legendary',
                chargeable: true
            },
            {
                id: 'A1_X2',
                name: 'Phantom ULTIMATE',
                characterId: 'A1',
                slot: 'X2',
                baseDamage: 500,
                damage: 500,
                cooldown: 30,
                unlockLevel: 60,
                unlock: 60,
                phantomBarrage: true,
                barrageCount: 8,
                shadowClones: 3,
                cloneDamage: 0.5,
                teleportCount: 8,
                shape: 'phantom_ultimate',
                color: '#000000',
                icon: '👻',
                description: 'Ultimate phantom barrage combo with shadow clones',
                element: 'SHADOW',
                tier: 'legendary'
            }
        ];

        // UNIQUE Skills (Cyborg) - 6 skills
        const UNIQUE_SKILLS_DATA = [
            {
                id: 'UNIQUE_S1',
                name: 'Plasma Blast',
                characterId: 'UNIQUE',
                slot: 1,
                baseDamage: 120,
                damage: 120,
                cooldown: 2,
                unlockLevel: 1,
                unlock: 1,
                projectileCount: 3,
                shape: 'plasma',
                color: '#00ffff',
                icon: '🔫',
                description: 'Fire 3 plasma projectiles',
                element: 'PLASMA',
                tier: 'common'
            },
            {
                id: 'UNIQUE_S2',
                name: 'Summon Drone',
                characterId: 'UNIQUE',
                slot: 2,
                baseDamage: 0,
                damage: 0,
                cooldown: 15,
                unlockLevel: 20,
                unlock: 20,
                projectileCount: 0,
                shape: 'summon',
                color: '#00ffff',
                icon: '🤖',
                description: 'Deploy a combat drone',
                element: 'SUMMON',
                tier: 'uncommon'
            },
            {
                id: 'UNIQUE_S3',
                name: 'Aether Wave Beam',
                characterId: 'UNIQUE',
                slot: 3,
                baseDamage: 400,
                damage: 400,
                cooldown: 8,
                unlockLevel: 1,
                unlock: 1,
                projectileCount: 0,
                shape: 'beam',
                enhanced: true,
                color: '#00ffff',
                icon: '💠',
                description: 'Channel an Aether Wave energy beam',
                element: 'ENERGY',
                tier: 'rare'
            },
            {
                id: 'UNIQUE_S4',
                name: 'Absolute Zero Rail + Cryo Barrage',
                characterId: 'UNIQUE',
                slot: 4,
                baseDamage: 45,
                damage: 45,
                cooldown: 20,
                unlockLevel: 30,
                unlock: 30,
                railDuration: 0.45,
                railTicksPerSec: 12,
                cryoCount: 4,
                cryoDamage: 180,
                cryoPierce: 2,
                cryoChain: 1,
                chainFalloff: 0.6,
                shape: 'cryo_rail',
                enhanced: true,
                color: '#87CEEB',
                icon: '❄️',
                description: 'Freeze enemies with rail beam and cryo barrage',
                element: 'ICE',
                tier: 'epic',
                freeze: true
            },
            {
                id: 'UNIQUE_S5',
                name: 'Ion Helix Drill',
                characterId: 'UNIQUE',
                slot: 5,
                baseDamage: 38,
                damage: 38,
                cooldown: 24,
                unlockLevel: 40,
                unlock: 40,
                drillDuration: 0.9,
                drillTicksPerSec: 15,
                pullStrength: 120,
                steerDegrees: 8,
                endBurst: 220,
                shape: 'helix_drill',
                enhanced: true,
                color: '#00FFFF',
                icon: '🔩',
                description: 'Drill through enemies with rotating helix beam',
                element: 'PLASMA',
                tier: 'epic'
            },
            {
                id: 'UNIQUE_X1',
                name: 'Hyper Ion Wave',
                characterId: 'UNIQUE',
                slot: 'X',
                baseDamage: [34, 41, 46],
                damage: 34,
                cooldown: 28,
                unlockLevel: 50,
                unlock: 50,
                charge: { t1: 0.60, t2: 1.00 },
                beamDuration: 1.6,
                beamTicksPerSec: 16,
                beamWidth: [80, 96, 112],
                steerDegrees: 10,
                endCone: [200, 240, 300],
                deepChillStacks: 3,
                shape: 'aurora_burst_beam',
                color: '#00FFFF',
                icon: '⚡',
                description: 'Massive Aurora Burst beam wave (Chargeable Ultimate)',
                element: 'ENERGY',
                tier: 'legendary',
                chargeable: true,
                freeze: true
            },
            {
                id: 'UNIQUE_X2',
                name: 'Voidlight ULTIMATE',
                characterId: 'UNIQUE',
                slot: 'X2',
                baseDamage: 600,
                damage: 600,
                cooldown: 30,
                unlockLevel: 60,
                unlock: 60,
                voidConvergence: true,
                convergenceLayers: 5,
                voidPull: 250,
                layerDamage: [100, 150, 200, 250, 300],
                shape: 'voidlight_ultimate',
                color: '#8A2BE2',
                icon: '🌌',
                description: 'Ultimate convergence attack with void pull',
                element: 'ARCANE',
                tier: 'legendary'
            }
        ];

        // MISSY Skills (Cat Angel) - 6 skills
        const MISSY_SKILLS_DATA = [
            {
                id: 'MISSY_S1',
                name: 'Blade Dance',
                characterId: 'MISSY',
                slot: 1,
                baseDamage: 130,
                damage: 130,
                cooldown: 2.5,
                unlockLevel: 1,
                unlock: 1,
                projectileCount: 3,
                shape: 'slash',
                color: '#ff69b4',
                icon: '🗡️',
                description: 'Elegant blade dance launching 3 slashes',
                element: 'PHYSICAL',
                tier: 'common'
            },
            {
                id: 'MISSY_S2',
                name: 'Summon Pet',
                characterId: 'MISSY',
                slot: 2,
                baseDamage: 0,
                damage: 0,
                cooldown: 15,
                unlockLevel: 20,
                unlock: 20,
                projectileCount: 0,
                shape: 'summon',
                color: '#ff69b4',
                icon: '🐱',
                description: 'Summon a magical pet companion',
                element: 'SUMMON',
                tier: 'uncommon'
            },
            {
                id: 'MISSY_S3',
                name: 'Gun Barrage',
                characterId: 'MISSY',
                slot: 3,
                baseDamage: 200,
                damage: 200,
                cooldown: 4,
                unlockLevel: 1,
                unlock: 1,
                projectileCount: 4,
                shape: 'bullet',
                enhanced: true,
                color: '#ff69b4',
                icon: '💰',
                description: 'Rapid-fire bullet barrage with golden effects',
                element: 'LIGHT',
                tier: 'rare'
            },
            {
                id: 'MISSY_S4',
                name: 'Golden Rail & Comets',
                characterId: 'MISSY',
                slot: 4,
                baseDamage: 560,
                damage: 560,
                cooldown: 6,
                unlockLevel: 30,
                unlock: 30,
                railDuration: 0.6,
                railTicksPerSec: 10,
                cometCount: 8,
                cometDamage: 180,
                cometPierce: 4,
                magnetRadius: 200,
                magnetTime: 2.0,
                boomerangDegrees: 45,
                shape: 'gold_rail',
                enhanced: true,
                color: '#ffd700',
                icon: '✨',
                description: 'Golden rail beam with orbiting magnetic comets',
                element: 'ARCANE',
                tier: 'epic'
            },
            {
                id: 'MISSY_S5',
                name: 'Royal Typhoon',
                characterId: 'MISSY',
                slot: 5,
                baseDamage: 720,
                damage: 720,
                cooldown: 8,
                unlockLevel: 40,
                unlock: 40,
                cycloneDuration: 1.8,
                cycloneTicks: 18,
                cycloneTickDamage: 40,
                cycloneMagnet: 140,
                coneVolleys: 3,
                conePellets: 8,
                coneSpread: 35,
                conePower: 110,
                shape: 'royal_typhoon',
                enhanced: true,
                typhoonRadius: 150,
                color: '#ffd700',
                icon: '🌀',
                description: 'Create a royal cyclone with gunfire volleys',
                element: 'LIGHT',
                tier: 'epic'
            },
            {
                id: 'MISSY_X1',
                name: 'Royal Coin Cannon',
                characterId: 'MISSY',
                slot: 'X',
                baseDamage: [1400, 2000, 2800],
                damage: 1400,
                cooldown: 20,
                unlockLevel: 50,
                unlock: 50,
                charge: { t1: 0.5, t2: 0.9, dmgMult: [1.0, 1.4, 1.8], sizeMult: [1.0, 1.3, 1.6] },
                beamDuration: 1.4,
                beamWidth: [70, 90, 110],
                beamMagnet: [180, 220, 280],
                beamTickDamage: 90,
                beamTicksPerSec: 12,
                finalNova: [1200, 1800, 2400],
                shape: 'vegeta_cannon',
                color: '#ffd700',
                icon: '💎',
                description: 'Royal coin beam cannon (Chargeable Ultimate)',
                element: 'ARCANE',
                tier: 'legendary',
                chargeable: true
            },
            {
                id: 'MISSY_X2',
                name: 'Angel ULTIMATE',
                characterId: 'MISSY',
                slot: 'X2',
                baseDamage: 550,
                damage: 550,
                cooldown: 28,
                unlockLevel: 60,
                unlock: 60,
                divineBeam: true,
                judgmentRadius: 300,
                healAmount: 200,
                beamDuration: 2.0,
                shape: 'angel_ultimate',
                color: '#FFD700',
                icon: '👼',
                description: 'Divine judgment beam with healing',
                element: 'LIGHT',
                tier: 'legendary'
            }
        ];

        // Merge all skills into a single array for SkillLibrary
        const ALL_SKILLS_DATA = [...A1_SKILLS_DATA, ...UNIQUE_SKILLS_DATA, ...MISSY_SKILLS_DATA];

        console.log('✅ Phase 1.1 Complete: Skill Data Arrays loaded');
        console.log(`📊 Total Skills: ${ALL_SKILLS_DATA.length} (A1: ${A1_SKILLS_DATA.length}, UNIQUE: ${UNIQUE_SKILLS_DATA.length}, MISSY: ${MISSY_SKILLS_DATA.length})`);

        // ═══════════════════════════════════════════════════════════════
        // PHASE 1.2 & 1.3: PROGRESSION MANAGER & SKILL LIBRARY
        // ═══════════════════════════════════════════════════════════════

        /**
         * ProgressionManager - Manages player level and progression
         * Used by SkillLibrary to determine skill unlocks
         */
        class ProgressionManager {
            constructor() {
                this.level = 1;
                this.xp = 0;
                this.xpToNext = 100;
                this.loadFromStorage();
            }

            getLevel() {
                return this.level;
            }

            gainXP(amount) {
                this.xp += amount;
                while (this.xp >= this.xpToNext) {
                    this.xp -= this.xpToNext;
                    this.level++;
                    this.xpToNext = Math.floor(100 * Math.pow(1.2, this.level - 1));
                    console.log(`🎉 Level Up! Now Level ${this.level}`);
                }
                this.saveToStorage();
            }

            loadFromStorage() {
                try {
                    const saved = localStorage.getItem('progression');
                    if (saved) {
                        const data = JSON.parse(saved);
                        this.level = data.level || 1;
                        this.xp = data.xp || 0;
                        this.xpToNext = data.xpToNext || 100;
                    }
                } catch (e) {
                    console.warn('Failed to load progression:', e);
                }
            }

            saveToStorage() {
                try {
                    localStorage.setItem('progression', JSON.stringify({
                        level: this.level,
                        xp: this.xp,
                        xpToNext: this.xpToNext
                    }));
                } catch (e) {
                    console.warn('Failed to save progression:', e);
                }
            }
        }

        /**
         * SkillLibrary - Manages all skills: owned, unlocked, equipped, mastery
         * Features:
         * - Track all skills per character
         * - Skill unlock by level (via ProgressionManager)
         * - Skill mastery (XP, level 1-10)
         * - Equip/unequip to slots
         */
        class SkillLibrary {
            constructor(skillsData, progressionManager) {
                this.skillsData = skillsData || ALL_SKILLS_DATA;
                this.progressionManager = progressionManager;

                // Track skill mastery per character
                // Structure: { skillId: { level: 1-10, xp: 0, xpToNext: 100, totalUses: 0, damageBonus: 0, cooldownReduction: 0, effectBonus: 0 } }
                this.skillMastery = {
                    A1: {},
                    UNIQUE: {},
                    MISSY: {}
                };

                // Track skill usage stats
                // Structure: { skillId: { totalDamage: 0, totalKills: 0, lastUsed: 0, averageDamage: 0 } }
                this.skillStats = {
                    A1: {},
                    UNIQUE: {},
                    MISSY: {}
                };

                // Currently equipped skills per character
                // Only S1, S2, S3 slots - X1/X2 skills can be equipped to any of these slots
                this.equipped = {
                    A1: { S1: null, S2: null, S3: null },
                    UNIQUE: { S1: null, S2: null, S3: null },
                    MISSY: { S1: null, S2: null, S3: null }
                };

                // Initialize from localStorage if available
                this.loadFromStorage();

                console.log('✅ SkillLibrary initialized with', this.skillsData.length, 'skills');
            }

            /**
             * Get all skills for a character
             */
            getAllSkills(characterId) {
                return this.skillsData.filter(skill => skill.characterId === characterId);
            }

            /**
             * Get unlocked skills based on player level (Phase 1.3)
             */
            getUnlockedSkills(characterId) {
                const playerLevel = this.progressionManager ? this.progressionManager.getLevel() : 1;
                return this.getAllSkills(characterId).filter(skill => {
                    const unlockLevel = skill.unlockLevel || skill.unlock || 1;
                    return playerLevel >= unlockLevel;
                });
            }

            /**
             * Get locked skills (for preview)
             */
            getLockedSkills(characterId) {
                const playerLevel = this.progressionManager ? this.progressionManager.getLevel() : 1;
                return this.getAllSkills(characterId).filter(skill => {
                    const unlockLevel = skill.unlockLevel || skill.unlock || 1;
                    return playerLevel < unlockLevel;
                });
            }

            /**
             * Equip a skill to a slot
             */
            equipSkill(characterId, slot, skillId) {
                const skill = this.skillsData.find(s => s.id === skillId && s.characterId === characterId);
                if (!skill) {
                    console.warn(`Skill ${skillId} not found for ${characterId}`);
                    return false;
                }

                // Check if unlocked
                const unlocked = this.getUnlockedSkills(characterId);
                if (!unlocked.find(s => s.id === skillId)) {
                    console.warn(`Skill ${skillId} is locked for ${characterId}`);
                    return false;
                }

                this.equipped[characterId][slot] = skill;
                this.saveToStorage();
                return true;
            }

            /**
             * Get equipped skill for a slot
             */
            getEquippedSkill(characterId, slot) {
                return this.equipped[characterId]?.[slot] || null;
            }

            /**
             * Get skill by ID
             */
            getSkillById(skillId) {
                return this.skillsData.find(s => s.id === skillId);
            }

            /**
             * Initialize mastery for a skill if it doesn't exist
             */
            initMastery(characterId, skillId) {
                if (!this.skillMastery[characterId][skillId]) {
                    this.skillMastery[characterId][skillId] = {
                        level: 1,
                        xp: 0,
                        xpToNext: 100,
                        totalUses: 0,
                        damageBonus: 0,
                        cooldownReduction: 0,
                        effectBonus: 0
                    };
                }
                if (!this.skillStats[characterId][skillId]) {
                    this.skillStats[characterId][skillId] = {
                        totalDamage: 0,
                        totalKills: 0,
                        lastUsed: 0,
                        averageDamage: 0
                    };
                }
            }

            /**
             * Gain mastery XP for a skill
             */
            gainSkillMasteryXP(characterId, skillId, baseXP = 10, bonusXP = 0) {
                this.initMastery(characterId, skillId);
                const mastery = this.skillMastery[characterId][skillId];
                const totalXP = baseXP + bonusXP;

                // XP formula: baseXP * (1 + masteryLevel * 0.1) - higher levels need more XP
                const xpGain = totalXP * (1 + mastery.level * 0.1);
                mastery.xp += xpGain;
                mastery.totalUses++;

                // Check for level up
                while (mastery.xp >= mastery.xpToNext && mastery.level < 10) {
                    mastery.xp -= mastery.xpToNext;
                    const oldLevel = mastery.level;
                    mastery.level++;
                    mastery.xpToNext = Math.floor(100 * Math.pow(1.5, mastery.level - 1));
                    console.log(`⭐ ${skillId} reached Mastery Level ${mastery.level}!`);

                    // Recalculate bonuses
                    this.updateMasteryBonuses(characterId, skillId);

                    // Trigger level-up celebration
                    if (typeof celebrateMasteryLevelUp === 'function') {
                        celebrateMasteryLevelUp(characterId, skillId, mastery.level);
                    }
                }

                this.saveToStorage();
            }

            /**
             * Update mastery bonuses based on level
             */
            updateMasteryBonuses(characterId, skillId) {
                const mastery = this.skillMastery[characterId][skillId];
                if (!mastery) return;

                const level = mastery.level;

                // Level 1-3: +5% damage per level
                if (level <= 3) {
                    mastery.damageBonus = level * 0.05;
                    mastery.cooldownReduction = 0;
                    mastery.effectBonus = 0;
                }
                // Level 4-6: +5% damage, -2% cooldown per level
                else if (level <= 6) {
                    mastery.damageBonus = 0.15 + (level - 3) * 0.05; // 15% base + 5% per level
                    mastery.cooldownReduction = (level - 3) * 0.02;
                    mastery.effectBonus = 0;
                }
                // Level 7-9: +5% damage, -2% cooldown, +10% effect duration per level
                else if (level <= 9) {
                    mastery.damageBonus = 0.30 + (level - 6) * 0.05; // 30% base + 5% per level
                    mastery.cooldownReduction = 0.06 + (level - 6) * 0.02; // 6% base + 2% per level
                    mastery.effectBonus = (level - 6) * 0.10;
                }
                // Level 10: +50% damage, -20% cooldown, +50% effect duration
                else {
                    mastery.damageBonus = 0.50;
                    mastery.cooldownReduction = 0.20;
                    mastery.effectBonus = 0.50;
                }
            }

            /**
             * Get mastery bonuses for a skill
             */
            getMasteryBonuses(characterId, skillId) {
                this.initMastery(characterId, skillId);
                const mastery = this.skillMastery[characterId][skillId];
                if (!mastery) {
                    return { damageBonus: 0, cooldownReduction: 0, effectBonus: 0 };
                }

                // Ensure bonuses are up to date
                this.updateMasteryBonuses(characterId, skillId);

                return {
                    damageBonus: mastery.damageBonus || 0,
                    cooldownReduction: mastery.cooldownReduction || 0,
                    effectBonus: mastery.effectBonus || 0
                };
            }

            /**
             * Update skill stats after use
             */
            updateSkillStats(characterId, skillId, damage, isKill = false) {
                this.initMastery(characterId, skillId);
                const stats = this.skillStats[characterId][skillId];

                stats.totalDamage += damage;
                stats.lastUsed = Date.now();
                if (isKill) stats.totalKills++;
                stats.averageDamage = stats.totalDamage / (this.skillMastery[characterId][skillId].totalUses || 1);

                this.saveToStorage();
            }

            loadFromStorage() {
                try {
                    const saved = localStorage.getItem('skillLibrary');
                    if (saved) {
                        const data = JSON.parse(saved);
                        if (data.equipped) this.equipped = data.equipped;
                        if (data.skillMastery) this.skillMastery = data.skillMastery;
                        if (data.skillStats) this.skillStats = data.skillStats;
                    }
                } catch (e) {
                    console.warn('Failed to load skill library:', e);
                }
            }

            saveToStorage() {
                try {
                    localStorage.setItem('skillLibrary', JSON.stringify({
                        equipped: this.equipped,
                        skillMastery: this.skillMastery,
                        skillStats: this.skillStats
                    }));
                } catch (e) {
                    console.warn('Failed to save skill library:', e);
                }
            }
        }

        // Initialize managers
        const progressionManager = new ProgressionManager();

        // Unlock S2 skills by setting level to 20 (S2 unlocks at level 20)
        if (progressionManager.getLevel() < 20) {
            progressionManager.level = 20;
            progressionManager.xp = 0;
            progressionManager.xpToNext = Math.floor(100 * Math.pow(1.2, 20 - 1));
            progressionManager.saveToStorage();
            console.log('🔓 S2 Skills unlocked! Level set to 20');
        }

        const skillLibrary = new SkillLibrary(ALL_SKILLS_DATA, progressionManager);

        // Expose globally
        window.ProgressionManager = ProgressionManager;
        window.SkillLibrary = SkillLibrary;
        window.progressionManager = progressionManager;
        window.skillLibrary = skillLibrary;

        console.log('✅ Phase 1.2 & 1.3 Complete: SkillLibrary and ProgressionManager initialized');
        console.log(`📚 Unlocked skills at Level ${progressionManager.getLevel()}:`, {
            A1: skillLibrary.getUnlockedSkills('A1').length,
            UNIQUE: skillLibrary.getUnlockedSkills('UNIQUE').length,
            MISSY: skillLibrary.getUnlockedSkills('MISSY').length
        });

        // ═══════════════════════════════════════════════════════════════
        // PHASE 1.4: DEFAULT SKILL EQUIPMENT
        // ═══════════════════════════════════════════════════════════════

        /**
         * Equip default skills (S1, S2, S3) for all characters
         * Called during game initialization
         */
        function equipDefaultSkills() {
            const characters = ['A1', 'UNIQUE', 'MISSY'];

            characters.forEach(characterId => {
                // Get default skills for this character (S1, S2, S3)
                const defaultSkills = skillLibrary.getAllSkills(characterId)
                    .filter(skill => [1, 2, 3].includes(skill.slot))
                    .sort((a, b) => a.slot - b.slot);

                // Equip S1, S2, S3 if they exist and are unlocked
                defaultSkills.forEach(skill => {
                    if (skill.slot >= 1 && skill.slot <= 3) {
                        const slotKey = `S${skill.slot}`;
                        const currentEquipped = skillLibrary.getEquippedSkill(characterId, slotKey);

                        // Only equip if slot is empty or if we're initializing
                        if (!currentEquipped) {
                            const unlocked = skillLibrary.getUnlockedSkills(characterId);
                            if (unlocked.find(s => s.id === skill.id)) {
                                skillLibrary.equipSkill(characterId, slotKey, skill.id);
                                console.log(`✅ Equipped ${skill.name} (${skill.id}) to ${characterId} ${slotKey}`);
                            } else {
                                console.log(`⏳ ${skill.name} (${skill.id}) locked for ${characterId} - requires Level ${skill.unlockLevel || skill.unlock}`);
                            }
                        }
                    }
                });

                // Force equip S2 if unlocked but not equipped (for testing)
                const s2Skill = defaultSkills.find(s => s.slot === 2);
                if (s2Skill) {
                    const slotKey = 'S2';
                    const currentEquipped = skillLibrary.getEquippedSkill(characterId, slotKey);
                    const unlocked = skillLibrary.getUnlockedSkills(characterId);
                    if (!currentEquipped && unlocked.find(s => s.id === s2Skill.id)) {
                        skillLibrary.equipSkill(characterId, slotKey, s2Skill.id);
                        console.log(`🔓 Force-equipped S2: ${s2Skill.name} (${s2Skill.id}) to ${characterId}`);
                    }
                }
            });

            console.log('✅ Phase 1.4 Complete: Default skills equipped for all characters');
        }

        // Call equipDefaultSkills after SkillLibrary is ready
        equipDefaultSkills();

        // ═══════════════════════════════════════════════════════════════
        // PHASE 3: 3D SPRITE SYSTEM - Cell-Shaded Style
        // ═══════════════════════════════════════════════════════════════
        /**
         * 3D Sprite Manager - Creates and manages 3D cell-shaded character sprites
         * Style: Anime cell-shaded with toon shading, rim lighting, and glow effects
         */
        class Sprite3DManager {
            constructor(THREE, scene) {
                this.THREE = THREE;
                this.scene = scene;
                this.sprites = new Map(); // characterId -> sprite3D instance
                this.gradientTexture = this.createGradientTexture();
            }

            /**
             * Create gradient texture for toon shading (cel-shaded look)
             */
            createGradientTexture() {
                const gradientSize = 256;
                const gradientCanvas = document.createElement('canvas');
                gradientCanvas.width = 1;
                gradientCanvas.height = gradientSize;
                const gradientCtx = gradientCanvas.getContext('2d');
                const gradient = gradientCtx.createLinearGradient(0, 0, 0, gradientSize);
                const steps = 4;
                for (let i = 0; i <= steps; i++) {
                    const stop = i / steps;
                    gradient.addColorStop(stop, `hsl(0, 0%, ${Math.floor(100 - (stop * 60))}%)`);
                }
                gradientCtx.fillStyle = gradient;
                gradientCtx.fillRect(0, 0, 1, gradientSize);
                return new THREE.CanvasTexture(gradientCanvas);
            }

            /**
             * Create a 3D sprite for a character
             */
            createSprite(characterId, position, palette = 'fire') {
                let sprite3D;

                switch (characterId) {
                    case 'A1':
                        sprite3D = new Warrior3DSprite(this.THREE, this.scene, this.gradientTexture, palette);
                        break;
                    case 'UNIQUE':
                        sprite3D = new Cyborg3DSprite(this.THREE, this.scene, this.gradientTexture, palette);
                        break;
                    case 'MISSY':
                        sprite3D = new CatAngel3DSprite(this.THREE, this.scene, this.gradientTexture, palette);
                        break;
                    default:
                        console.warn(`No 3D sprite for character: ${characterId}`);
                        return null;
                }

                if (sprite3D) {
                    sprite3D.group.position.copy(position);
                    this.sprites.set(characterId, sprite3D);
                }

                return sprite3D;
            }

            /**
             * Update all sprites
             */
            update(deltaTime) {
                this.sprites.forEach(sprite => {
                    if (sprite && sprite.update) {
                        sprite.update(deltaTime);
                    }
                });
            }

            /**
             * Get sprite by character ID
             */
            getSprite(characterId) {
                return this.sprites.get(characterId);
            }
        }

        /**
         * Base 3D Sprite Class - Common functionality for all 3D sprites
         */
        class Sprite3DBase {
            constructor(THREE, scene, gradientTexture, palette) {
                this.THREE = THREE;
                this.scene = scene;
                this.gradientTexture = gradientTexture;
                this.palette = palette;
                this.group = new THREE.Group();
                this.animState = {
                    current: 'idle',
                    frame: 0,
                    timer: 0
                };
                this.parts = {}; // Store all mesh parts for animation
            }

            /**
             * Create toon material with palette colors
             */
            createToonMaterial(color) {
                const material = new THREE.MeshToonMaterial({
                    color: color,
                    gradientMap: this.gradientTexture,
                    flatShading: false
                });
                return material;
            }

            /**
             * Update animation state
             */
            update(deltaTime) {
                this.animState.timer += deltaTime * 1000;
                const anim = this.getAnimation(this.animState.current);

                if (anim && this.animState.timer >= anim.frameTime) {
                    this.animState.timer = 0;
                    this.animState.frame++;

                    if (this.animState.frame >= anim.frames) {
                        if (anim.loop) {
                            this.animState.frame = 0;
                        } else {
                            this.animState.frame = anim.frames - 1;
                            // Auto-return to idle after non-looping animation
                            if (this.animState.current !== 'idle') {
                                this.playAnimation('idle');
                            }
                        }
                    }
                }

                this.updateAnimationPose(this.animState.current, this.animState.frame);
            }

            /**
             * Play an animation
             */
            playAnimation(animKey) {
                if (this.getAnimation(animKey)) {
                    this.animState.current = animKey;
                    this.animState.frame = 0;
                    this.animState.timer = 0;
                }
            }

            /**
             * Get animation definition (override in subclasses)
             */
            getAnimation(animKey) {
                return { frames: 8, frameTime: 250, loop: true };
            }

            /**
             * Update animation pose (override in subclasses)
             */
            updateAnimationPose(anim, frame) {
                // Default: idle bobbing
                const bobY = Math.sin(frame / 4 * Math.PI) * 0.05;
                this.group.position.y = bobY;
            }
        }

        /**
         * Warrior 3D Sprite (A1) - Dual sword warrior with red/black theme
         */
        class Warrior3DSprite extends Sprite3DBase {
            constructor(THREE, scene, gradientTexture, palette = 'fire') {
                super(THREE, scene, gradientTexture, palette);

                const pal = this.getPalette(palette);
                this.createMesh(pal);
                this.scene.add(this.group);
            }

            getPalette(palette) {
                const palettes = {
                    fire: {
                        skin: { base: 0x8b6347, highlight: 0xb8866b, shadow: 0x5c4033 },
                        clothes: { base: 0x2a1a1a, highlight: 0x4a2a2a, shadow: 0x1a0a0a },
                        weapon: { core: 0xff3333, glow: 0xff6666, bloom: 0xff0000 },
                        eyes: 0xff0000
                    },
                    ice: {
                        skin: { base: 0x8b6347, highlight: 0xb8866b, shadow: 0x5c4033 },
                        clothes: { base: 0x1a2a3a, highlight: 0x2a3a4a, shadow: 0x0a1a2a },
                        weapon: { core: 0x00ccff, glow: 0x66eeff, bloom: 0x00ffff },
                        eyes: 0x00ffff
                    }
                };
                return palettes[palette] || palettes.fire;
            }

            createMesh(pal) {
                // Body
                const bodyGeometry = new THREE.CylinderGeometry(0.7, 0.7, 1.2, 8);
                const bodyMesh = new THREE.Mesh(bodyGeometry, this.createToonMaterial(pal.clothes.base));
                bodyMesh.castShadow = true;
                this.parts.body = bodyMesh;
                this.group.add(bodyMesh);

                // Head
                const headGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                const headMesh = new THREE.Mesh(headGeometry, this.createToonMaterial(pal.skin.base));
                headMesh.position.set(0, 0.8, 0);
                headMesh.castShadow = true;
                this.parts.head = headMesh;
                this.group.add(headMesh);

                // Eyes (glowing)
                const eyeGeometry = new THREE.SphereGeometry(0.05, 8, 8);
                const eyeMaterial = new THREE.MeshBasicMaterial({
                    color: pal.eyes,
                    emissive: pal.eyes,
                    emissiveIntensity: 2.0
                });

                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.12, 0.85, 0.38);
                this.group.add(leftEye);

                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.12, 0.85, 0.38);
                this.group.add(rightEye);

                // Arms
                const armGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.6, 8);
                const armMaterial = this.createToonMaterial(pal.clothes.base);

                const leftArm = new THREE.Mesh(armGeometry, armMaterial);
                leftArm.position.set(-0.5, 0.3, 0);
                leftArm.rotation.z = 0.3;
                this.parts.leftArm = leftArm;
                this.group.add(leftArm);

                const rightArm = new THREE.Mesh(armGeometry, armMaterial);
                rightArm.position.set(0.5, 0.3, 0);
                rightArm.rotation.z = -0.3;
                this.parts.rightArm = rightArm;
                this.group.add(rightArm);

                // Legs
                const legGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.7, 8);
                const legMaterial = this.createToonMaterial(pal.clothes.base);

                const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
                leftLeg.position.set(-0.25, -0.6, 0);
                this.parts.leftLeg = leftLeg;
                this.group.add(leftLeg);

                const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
                rightLeg.position.set(0.25, -0.6, 0);
                this.parts.rightLeg = rightLeg;
                this.group.add(rightLeg);

                // Dual swords
                const swordGeometry = new THREE.BoxGeometry(0.05, 0.8, 0.05);
                const swordMaterial = new THREE.MeshBasicMaterial({
                    color: pal.weapon.core,
                    emissive: pal.weapon.glow,
                    emissiveIntensity: 2.0
                });

                const leftSword = new THREE.Mesh(swordGeometry, swordMaterial);
                leftSword.position.set(-0.6, 0, -0.2);
                leftSword.rotation.z = -0.5;
                this.parts.leftSword = leftSword;
                this.group.add(leftSword);

                const rightSword = new THREE.Mesh(swordGeometry, swordMaterial);
                rightSword.position.set(0.6, 0, -0.2);
                rightSword.rotation.z = 0.5;
                this.parts.rightSword = rightSword;
                this.group.add(rightSword);
            }

            getAnimation(animKey) {
                const animations = {
                    idle: { frames: 8, frameTime: 250, loop: true },
                    walk: { frames: 8, frameTime: 125, loop: true },
                    attack: { frames: 6, frameTime: 83, loop: false }
                };
                return animations[animKey] || animations.idle;
            }

            updateAnimationPose(anim, frame) {
                const bobY = Math.sin(frame / 4 * Math.PI) * (anim === 'walk' ? 0.15 : 0.05);
                const legOffset = anim === 'walk' ? Math.sin(frame / 4 * Math.PI) * 0.2 : 0;
                const armSwing = anim === 'walk' ? Math.sin(frame / 4 * Math.PI) * 0.3 : 0;
                const attackAngle = anim === 'attack' ? (frame / 6) * Math.PI * 0.8 : 0;

                this.group.position.y = bobY;

                if (this.parts.leftLeg && this.parts.rightLeg) {
                    this.parts.leftLeg.position.x = -0.25 + legOffset;
                    this.parts.rightLeg.position.x = 0.25 - legOffset;
                }

                if (this.parts.leftArm && this.parts.rightArm) {
                    if (anim === 'attack') {
                        this.parts.leftArm.rotation.z = 0.3 - attackAngle;
                        this.parts.rightArm.rotation.z = -0.3 + attackAngle;
                        if (this.parts.leftSword && this.parts.rightSword) {
                            this.parts.leftSword.rotation.z = -0.5 - attackAngle;
                            this.parts.rightSword.rotation.z = 0.5 + attackAngle;
                        }
                    } else {
                        this.parts.leftArm.rotation.z = 0.3 + armSwing;
                        this.parts.rightArm.rotation.z = -0.3 - armSwing;
                    }
                }
            }
        }

        /**
         * Cyborg 3D Sprite (UNIQUE) - Tech-themed with energy conduit glow
         */
        class Cyborg3DSprite extends Sprite3DBase {
            constructor(THREE, scene, gradientTexture, palette = 'ice') {
                super(THREE, scene, gradientTexture, palette);

                const pal = this.getPalette(palette);
                this.createMesh(pal);
                this.scene.add(this.group);
            }

            getPalette(palette) {
                const palettes = {
                    ice: {
                        skin: { base: 0x4a5a6a, highlight: 0x6a7a8a, shadow: 0x2a3a4a },
                        clothes: { base: 0x1a2a3a, highlight: 0x3a4a5a, shadow: 0x0a1a2a },
                        weapon: { core: 0x00ccff, glow: 0x66eeff, bloom: 0x00ffff },
                        eyes: 0x00ffff,
                        tech: { core: 0x00ffff, glow: 0x88eeff }
                    },
                    fire: {
                        skin: { base: 0x6a4a3a, highlight: 0x8a6a5a, shadow: 0x4a2a1a },
                        clothes: { base: 0x3a2a1a, highlight: 0x5a4a3a, shadow: 0x1a0a0a },
                        weapon: { core: 0xff6600, glow: 0xff8844, bloom: 0xff4400 },
                        eyes: 0xff4400,
                        tech: { core: 0xff4400, glow: 0xff8844 }
                    }
                };
                return palettes[palette] || palettes.ice;
            }

            createMesh(pal) {
                // Body (cyborg torso with tech lines)
                const bodyGeometry = new THREE.CylinderGeometry(0.7, 0.7, 1.2, 8);
                const bodyMesh = new THREE.Mesh(bodyGeometry, this.createToonMaterial(pal.clothes.base));
                bodyMesh.castShadow = true;
                this.parts.body = bodyMesh;
                this.group.add(bodyMesh);

                // Tech conduits (glowing energy lines)
                const conduitGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.8, 8);
                const conduitMaterial = new THREE.MeshBasicMaterial({
                    color: pal.tech.core,
                    emissive: pal.tech.glow,
                    emissiveIntensity: 2.5
                });

                const leftConduit = new THREE.Mesh(conduitGeometry, conduitMaterial);
                leftConduit.position.set(-0.5, 0, 0.5);
                this.group.add(leftConduit);

                const rightConduit = new THREE.Mesh(conduitGeometry, conduitMaterial);
                rightConduit.position.set(0.5, 0, 0.5);
                this.group.add(rightConduit);

                // Head (cyborg head with visor)
                const headGeometry = new THREE.SphereGeometry(0.4, 16, 16);
                const headMesh = new THREE.Mesh(headGeometry, this.createToonMaterial(pal.skin.base));
                headMesh.position.set(0, 0.8, 0);
                headMesh.castShadow = true;
                this.parts.head = headMesh;
                this.group.add(headMesh);

                // Visor (glowing eye piece)
                const visorGeometry = new THREE.BoxGeometry(0.5, 0.15, 0.1);
                const visorMaterial = new THREE.MeshBasicMaterial({
                    color: pal.eyes,
                    emissive: pal.tech.glow,
                    emissiveIntensity: 3.0,
                    transparent: true,
                    opacity: 0.8
                });
                const visor = new THREE.Mesh(visorGeometry, visorMaterial);
                visor.position.set(0, 0.85, 0.38);
                this.group.add(visor);

                // Arms (mechanical)
                const armGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.6, 8);
                const armMaterial = this.createToonMaterial(pal.clothes.base);

                const leftArm = new THREE.Mesh(armGeometry, armMaterial);
                leftArm.position.set(-0.5, 0.3, 0);
                leftArm.rotation.z = 0.3;
                this.parts.leftArm = leftArm;
                this.group.add(leftArm);

                const rightArm = new THREE.Mesh(armGeometry, armMaterial);
                rightArm.position.set(0.5, 0.3, 0);
                rightArm.rotation.z = -0.3;
                this.parts.rightArm = rightArm;
                this.group.add(rightArm);

                // Legs
                const legGeometry = new THREE.CylinderGeometry(0.2, 0.2, 0.7, 8);
                const legMaterial = this.createToonMaterial(pal.clothes.base);

                const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
                leftLeg.position.set(-0.25, -0.6, 0);
                this.parts.leftLeg = leftLeg;
                this.group.add(leftLeg);

                const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
                rightLeg.position.set(0.25, -0.6, 0);
                this.parts.rightLeg = rightLeg;
                this.group.add(rightLeg);

                // Energy weapon (gun/launcher)
                const weaponGeometry = new THREE.BoxGeometry(0.15, 0.4, 0.15);
                const weaponMaterial = new THREE.MeshBasicMaterial({
                    color: pal.weapon.core,
                    emissive: pal.weapon.glow,
                    emissiveIntensity: 2.0
                });
                const weapon = new THREE.Mesh(weaponGeometry, weaponMaterial);
                weapon.position.set(0.6, 0.2, -0.1);
                weapon.rotation.z = -0.3;
                this.parts.weapon = weapon;
                this.group.add(weapon);
            }

            getAnimation(animKey) {
                const animations = {
                    idle: { frames: 8, frameTime: 250, loop: true },
                    walk: { frames: 8, frameTime: 125, loop: true },
                    attack: { frames: 6, frameTime: 83, loop: false }
                };
                return animations[animKey] || animations.idle;
            }

            updateAnimationPose(anim, frame) {
                const bobY = Math.sin(frame / 4 * Math.PI) * (anim === 'walk' ? 0.15 : 0.05);
                const legOffset = anim === 'walk' ? Math.sin(frame / 4 * Math.PI) * 0.2 : 0;
                const armSwing = anim === 'walk' ? Math.sin(frame / 4 * Math.PI) * 0.3 : 0;
                const attackAngle = anim === 'attack' ? (frame / 6) * Math.PI * 0.8 : 0;

                this.group.position.y = bobY;

                if (this.parts.leftLeg && this.parts.rightLeg) {
                    this.parts.leftLeg.position.x = -0.25 + legOffset;
                    this.parts.rightLeg.position.x = 0.25 - legOffset;
                }

                if (this.parts.leftArm && this.parts.rightArm) {
                    if (anim === 'attack') {
                        this.parts.leftArm.rotation.z = 0.3 - attackAngle;
                        this.parts.rightArm.rotation.z = -0.3 + attackAngle;
                        if (this.parts.weapon) {
                            this.parts.weapon.rotation.z = -0.3 - attackAngle * 0.5;
                        }
                    } else {
                        this.parts.leftArm.rotation.z = 0.3 + armSwing;
                        this.parts.rightArm.rotation.z = -0.3 - armSwing;
                    }
                }
            }
        }

        /**
         * Cat Angel 3D Sprite (MISSY) - Cute cat with angel wings and halo
         */
        class CatAngel3DSprite extends Sprite3DBase {
            constructor(THREE, scene, gradientTexture, palette = 'light') {
                super(THREE, scene, gradientTexture, palette);

                const pal = this.getPalette(palette);
                this.createMesh(pal);
                this.scene.add(this.group);
            }

            getPalette(palette) {
                const palettes = {
                    light: {
                        skin: { base: 0xffe5b4, highlight: 0xfff0d4, shadow: 0xffcc99 },
                        clothes: { base: 0xffffff, highlight: 0xffeeee, shadow: 0xdddddd },
                        weapon: { core: 0xffcc00, glow: 0xffee66, bloom: 0xffff00 },
                        eyes: 0xffff00,
                        halo: { core: 0xffff00, glow: 0xffffee }
                    },
                    shadow: {
                        skin: { base: 0x4a4a4a, highlight: 0x6a6a6a, shadow: 0x2a2a2a },
                        clothes: { base: 0x2a2a2a, highlight: 0x4a4a4a, shadow: 0x1a1a1a },
                        weapon: { core: 0xaa00ff, glow: 0xdd66ff, bloom: 0xcc00ff },
                        eyes: 0xaa00ff,
                        halo: { core: 0xaa00ff, glow: 0xdd66ff }
                    }
                };
                return palettes[palette] || palettes.light;
            }

            createMesh(pal) {
                // Body (smaller, cat-like)
                const bodyGeometry = new THREE.CylinderGeometry(0.5, 0.5, 0.8, 8);
                const bodyMesh = new THREE.Mesh(bodyGeometry, this.createToonMaterial(pal.clothes.base));
                bodyMesh.castShadow = true;
                this.parts.body = bodyMesh;
                this.group.add(bodyMesh);

                // Head (cat head)
                const headGeometry = new THREE.SphereGeometry(0.35, 16, 16);
                const headMesh = new THREE.Mesh(headGeometry, this.createToonMaterial(pal.skin.base));
                headMesh.position.set(0, 0.6, 0);
                headMesh.scale.set(1, 1.2, 1); // Slightly elongated for cat look
                headMesh.castShadow = true;
                this.parts.head = headMesh;
                this.group.add(headMesh);

                // Cat ears
                const earGeometry = new THREE.ConeGeometry(0.15, 0.3, 8);
                const earMaterial = this.createToonMaterial(pal.skin.base);

                const leftEar = new THREE.Mesh(earGeometry, earMaterial);
                leftEar.position.set(-0.2, 0.9, 0.1);
                leftEar.rotation.z = -0.3;
                this.group.add(leftEar);

                const rightEar = new THREE.Mesh(earGeometry, earMaterial);
                rightEar.position.set(0.2, 0.9, 0.1);
                rightEar.rotation.z = 0.3;
                this.group.add(rightEar);

                // Eyes (glowing)
                const eyeGeometry = new THREE.SphereGeometry(0.06, 8, 8);
                const eyeMaterial = new THREE.MeshBasicMaterial({
                    color: pal.eyes,
                    emissive: pal.eyes,
                    emissiveIntensity: 2.5
                });

                const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                leftEye.position.set(-0.12, 0.65, 0.32);
                this.group.add(leftEye);

                const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
                rightEye.position.set(0.12, 0.65, 0.32);
                this.group.add(rightEye);

                // Halo (floating ring above head)
                const haloGeometry = new THREE.TorusGeometry(0.3, 0.03, 8, 32);
                const haloMaterial = new THREE.MeshBasicMaterial({
                    color: pal.halo.core,
                    emissive: pal.halo.glow,
                    emissiveIntensity: 3.0
                });
                const halo = new THREE.Mesh(haloGeometry, haloMaterial);
                halo.position.set(0, 1.2, 0);
                halo.rotation.x = Math.PI / 2;
                this.parts.halo = halo;
                this.group.add(halo);

                // Wings (angel wings)
                const wingGeometry = new THREE.PlaneGeometry(0.4, 0.6);
                const wingMaterial = this.createToonMaterial(0xffffff);
                wingMaterial.side = THREE.DoubleSide;
                wingMaterial.transparent = true;
                wingMaterial.opacity = 0.9;

                const leftWing = new THREE.Mesh(wingGeometry, wingMaterial);
                leftWing.position.set(-0.5, 0.4, 0);
                leftWing.rotation.z = 0.3;
                this.parts.leftWing = leftWing;
                this.group.add(leftWing);

                const rightWing = new THREE.Mesh(wingGeometry, wingMaterial);
                rightWing.position.set(0.5, 0.4, 0);
                rightWing.rotation.z = -0.3;
                this.parts.rightWing = rightWing;
                this.group.add(rightWing);

                // Arms
                const armGeometry = new THREE.CylinderGeometry(0.1, 0.1, 0.4, 8);
                const armMaterial = this.createToonMaterial(pal.skin.base);

                const leftArm = new THREE.Mesh(armGeometry, armMaterial);
                leftArm.position.set(-0.35, 0.2, 0);
                leftArm.rotation.z = 0.3;
                this.parts.leftArm = leftArm;
                this.group.add(leftArm);

                const rightArm = new THREE.Mesh(armGeometry, armMaterial);
                rightArm.position.set(0.35, 0.2, 0);
                rightArm.rotation.z = -0.3;
                this.parts.rightArm = rightArm;
                this.group.add(rightArm);

                // Legs (shorter)
                const legGeometry = new THREE.CylinderGeometry(0.15, 0.15, 0.5, 8);
                const legMaterial = this.createToonMaterial(pal.skin.base);

                const leftLeg = new THREE.Mesh(legGeometry, legMaterial);
                leftLeg.position.set(-0.2, -0.5, 0);
                this.parts.leftLeg = leftLeg;
                this.group.add(leftLeg);

                const rightLeg = new THREE.Mesh(legGeometry, legMaterial);
                rightLeg.position.set(0.2, -0.5, 0);
                this.parts.rightLeg = rightLeg;
                this.group.add(rightLeg);
            }

            getAnimation(animKey) {
                const animations = {
                    idle: { frames: 8, frameTime: 250, loop: true },
                    walk: { frames: 8, frameTime: 125, loop: true },
                    attack: { frames: 6, frameTime: 83, loop: false }
                };
                return animations[animKey] || animations.idle;
            }

            updateAnimationPose(anim, frame) {
                const bobY = Math.sin(frame / 4 * Math.PI) * (anim === 'walk' ? 0.12 : 0.04);
                const legOffset = anim === 'walk' ? Math.sin(frame / 4 * Math.PI) * 0.15 : 0;
                const wingFlap = anim === 'walk' ? Math.sin(frame / 4 * Math.PI) * 0.2 : 0;
                const attackAngle = anim === 'attack' ? (frame / 6) * Math.PI * 0.6 : 0;

                this.group.position.y = bobY;

                // Halo bobs
                if (this.parts.halo) {
                    this.parts.halo.position.y = 1.2 + Math.sin(frame / 4 * Math.PI) * 0.05;
                    this.parts.halo.rotation.z += 0.01;
                }

                // Wing flapping
                if (this.parts.leftWing && this.parts.rightWing) {
                    if (anim === 'walk' || anim === 'attack') {
                        this.parts.leftWing.rotation.z = 0.3 + wingFlap;
                        this.parts.rightWing.rotation.z = -0.3 - wingFlap;
                    }
                }

                if (this.parts.leftLeg && this.parts.rightLeg) {
                    this.parts.leftLeg.position.x = -0.2 + legOffset;
                    this.parts.rightLeg.position.x = 0.2 - legOffset;
                }

                if (this.parts.leftArm && this.parts.rightArm) {
                    if (anim === 'attack') {
                        this.parts.leftArm.rotation.z = 0.3 - attackAngle;
                        this.parts.rightArm.rotation.z = -0.3 + attackAngle;
                    } else {
                        this.parts.leftArm.rotation.z = 0.3 + wingFlap * 0.5;
                        this.parts.rightArm.rotation.z = -0.3 - wingFlap * 0.5;
                    }
                }
            }
        }

        // Initialize 3D Sprite Manager (will be created after scene is set up)
        let sprite3DManager = null;

        // -- SCENE SETUP --

        // -- AUDIO --
        let audioContext;
        let isAudioInitialized = false;

        let scene, camera, renderer, clock;
        let player, npcs = [];
        const keys = {};

        // Global error handler to catch all unhandled errors
        window.addEventListener('error', (event) => {
            if (event.message && event.message.includes('currentHealth')) {
                // Silently handle currentHealth errors - they're being caught by try-catch blocks
                event.preventDefault();
                return true;
            }
        }, true);

        // Also catch unhandled promise rejections
        window.addEventListener('unhandledrejection', (event) => {
            if (event.reason && event.reason.message && event.reason.message.includes('currentHealth')) {
                event.preventDefault();
            }
        });

        // ═══════════════════════════════════════════════════════════════════════════
        // ENHANCED ERROR HANDLING SYSTEM
        // ═══════════════════════════════════════════════════════════════════════════
        (function() {
            const ErrorHandler = {
                errors: [],
                maxErrors: 100,
                
                log(error, context = '') {
                    const errorEntry = {
                        timestamp: new Date().toISOString(),
                        message: error.message || String(error),
                        stack: error.stack || '',
                        context: context,
                        url: window.location.href
                    };
                    
                    this.errors.push(errorEntry);
                    if (this.errors.length > this.maxErrors) {
                        this.errors.shift();
                    }
                    
                    // Log to console with context
                    console.error(`[ErrorHandler] ${context}:`, error);
                    
                    // Try to save to localStorage for debugging
                    try {
                        localStorage.setItem('game_errors', JSON.stringify(this.errors.slice(-20)));
                    } catch (e) {
                        // Ignore localStorage errors
                    }
                },
                
                getErrors() {
                    return this.errors;
                },
                
                clearErrors() {
                    this.errors = [];
                }
            };
            
            // Enhanced global error handler
            const originalErrorHandler = window.onerror;
            window.onerror = function(message, source, lineno, colno, error) {
                // Skip known harmless errors
                if (message && message.includes('currentHealth')) {
                    return true;
                }
                
                ErrorHandler.log({
                    message: message,
                    source: source,
                    lineno: lineno,
                    colno: colno,
                    stack: error?.stack || ''
                }, 'Global Error');
                
                if (originalErrorHandler) {
                    return originalErrorHandler.apply(this, arguments);
                }
                return false;
            };
            
            // Enhanced promise rejection handler
            window.addEventListener('unhandledrejection', (event) => {
                if (event.reason && event.reason.message && event.reason.message.includes('currentHealth')) {
                    event.preventDefault();
                    return;
                }
                
                ErrorHandler.log(event.reason || event, 'Unhandled Promise Rejection');
            });
            
            // Expose error handler globally
            window.ErrorHandler = ErrorHandler;
        })();

        // ═══════════════════════════════════════════════════════════════════════════
        // AUTO-SAVE SYSTEM
        // ═══════════════════════════════════════════════════════════════════════════
        (function() {
            const AutoSave = {
                interval: 30000, // 30 seconds
                timer: null,
                isEnabled: true,
                lastSave: null,
                
                init() {
                    if (!this.isEnabled) return;
                    
                    // Load saved state on init
                    this.load();
                    
                    // Start auto-save timer
                    this.timer = setInterval(() => {
                        this.save();
                    }, this.interval);
                    
                    // Save before page unload
                    window.addEventListener('beforeunload', () => {
                        this.save();
                    });
                    
                    console.log('[AutoSave] Initialized - Auto-saving every 30 seconds');
                },
                
                save() {
                    try {
                        if (!window.gameState) return;
                        
                        // Validate gameState before saving
                        if (window.GameStateValidator) {
                            const validation = window.GameStateValidator.validate(window.gameState);
                            if (!validation.valid) {
                                console.warn('[AutoSave] GameState validation failed, fixing...');
                                window.gameState = window.GameStateValidator.fix(window.gameState);
                            }
                        }
                        
                        // Create backup before saving
                        if (window.BackupSystem) {
                            window.BackupSystem.createBackup(window.gameState);
                        }
                        
                        const saveData = {
                            timestamp: Date.now(),
                            gameState: JSON.parse(JSON.stringify(window.gameState)),
                            version: '1.0'
                        };
                        
                        localStorage.setItem('game_autosave', JSON.stringify(saveData));
                        this.lastSave = Date.now();
                        
                        // Visual feedback (subtle)
                        const indicator = document.getElementById('autosave-indicator');
                        if (indicator) {
                            indicator.style.opacity = '1';
                            setTimeout(() => {
                                indicator.style.opacity = '0';
                            }, 1000);
                        }
                    } catch (error) {
                        console.warn('[AutoSave] Save failed:', error);
                        window.ErrorHandler?.log(error, 'AutoSave');
                        
                        // Try recovery
                        if (window.ErrorRecovery) {
                            window.ErrorRecovery.recover(error, 'AutoSave.save');
                        }
                    }
                },
                
                load() {
                    try {
                        const saved = localStorage.getItem('game_autosave');
                        if (!saved) return false;
                        
                        const saveData = JSON.parse(saved);
                        
                        // Validate save data
                        if (!saveData.gameState || !saveData.version) {
                            console.warn('[AutoSave] Invalid save data, trying backup...');
                            // Try to load from backup
                            if (window.BackupSystem) {
                                return window.BackupSystem.restore(0);
                            }
                            return false;
                        }
                        
                        // Validate gameState structure
                        if (window.GameStateValidator) {
                            const validation = window.GameStateValidator.validate(saveData.gameState);
                            if (!validation.valid) {
                                console.warn('[AutoSave] Save data validation failed, fixing...');
                                saveData.gameState = window.GameStateValidator.fix(saveData.gameState);
                            }
                        }
                        
                        // Merge with existing gameState
                        if (window.gameState) {
                            Object.assign(window.gameState, saveData.gameState);
                            console.log('[AutoSave] Loaded save from', new Date(saveData.timestamp).toLocaleTimeString());
                            return true;
                        }
                    } catch (error) {
                        console.warn('[AutoSave] Load failed:', error);
                        window.ErrorHandler?.log(error, 'AutoSave Load');
                        
                        // Try recovery
                        if (window.ErrorRecovery) {
                            const recovered = window.ErrorRecovery.recover(error, 'AutoSave.load');
                            if (recovered) {
                                return true;
                            }
                        }
                    }
                    return false;
                },
                
                enable() {
                    this.isEnabled = true;
                    this.init();
                },
                
                disable() {
                    this.isEnabled = false;
                    if (this.timer) {
                        clearInterval(this.timer);
                        this.timer = null;
                    }
                }
            };
            
            window.AutoSave = AutoSave;
        })();

        // ═══════════════════════════════════════════════════════════════════════════
        // LOADING PROGRESS SYSTEM
        // ═══════════════════════════════════════════════════════════════════════════
        (function() {
            const LoadingProgress = {
                progress: 0,
                steps: [],
                currentStep: 0,
                
                init() {
                    // Create loading overlay
                    const overlay = document.createElement('div');
                    overlay.id = 'loading-overlay';
                    overlay.innerHTML = `
                        <div class="loading-container">
                            <div class="loading-title">Loading 3D Hero World...</div>
                            <div class="loading-progress-bar">
                                <div class="loading-progress-fill" id="loading-progress-fill"></div>
                            </div>
                            <div class="loading-text" id="loading-text">Initializing...</div>
                        </div>
                    `;
                    document.body.appendChild(overlay);
                    
                    // Add styles
                    const style = document.createElement('style');
                    style.textContent = `
                        #loading-overlay {
                            position: fixed;
                            top: 0;
                            left: 0;
                            width: 100%;
                            height: 100%;
                            background: rgba(0, 0, 0, 0.95);
                            z-index: 10000;
                            display: flex;
                            align-items: center;
                            justify-content: center;
                            transition: opacity 0.5s ease;
                        }
                        #loading-overlay.hidden {
                            opacity: 0;
                            pointer-events: none;
                        }
                        .loading-container {
                            text-align: center;
                            width: 400px;
                        }
                        .loading-title {
                            font-size: 24px;
                            margin-bottom: 20px;
                            color: #fff;
                        }
                        .loading-progress-bar {
                            width: 100%;
                            height: 20px;
                            background: rgba(255, 255, 255, 0.1);
                            border-radius: 10px;
                            overflow: hidden;
                            margin-bottom: 10px;
                        }
                        .loading-progress-fill {
                            height: 100%;
                            background: linear-gradient(90deg, #4CAF50, #8BC34A);
                            width: 0%;
                            transition: width 0.3s ease;
                        }
                        .loading-text {
                            color: #aaa;
                            font-size: 14px;
                        }
                    `;
                    document.head.appendChild(style);
                },
                
                update(percent, text = '') {
                    this.progress = Math.min(100, Math.max(0, percent));
                    const fill = document.getElementById('loading-progress-fill');
                    const textEl = document.getElementById('loading-text');
                    
                    if (fill) {
                        fill.style.width = this.progress + '%';
                    }
                    if (textEl && text) {
                        textEl.textContent = text;
                    }
                },
                
                complete() {
                    this.update(100, 'Complete!');
                    setTimeout(() => {
                        const overlay = document.getElementById('loading-overlay');
                        if (overlay) {
                            overlay.classList.add('hidden');
                            setTimeout(() => {
                                overlay.remove();
                            }, 500);
                        }
                    }, 500);
                },
                
                step(name, callback) {
                    this.steps.push({ name, callback });
                },
                
                async runSteps() {
                    for (let i = 0; i < this.steps.length; i++) {
                        this.currentStep = i;
                        const step = this.steps[i];
                        this.update((i / this.steps.length) * 100, step.name);
                        
                        try {
                            await step.callback();
                        } catch (error) {
                            console.error(`[LoadingProgress] Step "${step.name}" failed:`, error);
                            window.ErrorHandler?.log(error, `Loading: ${step.name}`);
                        }
                    }
                    this.complete();
                }
            };
            
            window.LoadingProgress = LoadingProgress;
            LoadingProgress.init();
        })();

        // ═══════════════════════════════════════════════════════════════════════════
        // KEYBOARD SHORTCUTS SYSTEM
        // ═══════════════════════════════════════════════════════════════════════════
        (function() {
            const KeyboardShortcuts = {
                shortcuts: new Map(),
                enabled: true,
                
                init() {
                    document.addEventListener('keydown', (e) => {
                        if (!this.enabled) return;
                        
                        // Don't trigger shortcuts when typing in inputs
                        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                            return;
                        }
                        
                        const key = e.key.toLowerCase();
                        const combo = this.getCombo(e);
                        
                        // Check for registered shortcuts
                        for (const [shortcut, handler] of this.shortcuts) {
                            if (this.matches(shortcut, combo, key)) {
                                e.preventDefault();
                                try {
                                    handler(e);
                                } catch (error) {
                                    console.error(`[KeyboardShortcuts] Error in handler for "${shortcut}":`, error);
                                    window.ErrorHandler?.log(error, `Shortcut: ${shortcut}`);
                                }
                                return;
                            }
                        }
                    });
                    
                    console.log('[KeyboardShortcuts] Initialized');
                },
                
                getCombo(e) {
                    const parts = [];
                    if (e.ctrlKey) parts.push('ctrl');
                    if (e.altKey) parts.push('alt');
                    if (e.shiftKey) parts.push('shift');
                    if (e.metaKey) parts.push('meta');
                    return parts.join('+');
                },
                
                matches(shortcut, combo, key) {
                    // Support formats: 'i', 'ctrl+i', 'alt+shift+k'
                    const parts = shortcut.toLowerCase().split('+');
                    const shortcutKey = parts.pop();
                    const shortcutCombo = parts.join('+');
                    
                    return key === shortcutKey && combo === shortcutCombo;
                },
                
                register(shortcut, handler, description = '') {
                    this.shortcuts.set(shortcut, handler);
                    if (description) {
                        console.log(`[KeyboardShortcuts] Registered: ${shortcut} - ${description}`);
                    }
                },
                
                unregister(shortcut) {
                    this.shortcuts.delete(shortcut);
                }
            };
            
            // Register common shortcuts
            KeyboardShortcuts.init();
            KeyboardShortcuts.register('i', () => {
                // Toggle inventory/bag
                if (window.BagSystem && typeof window.BagSystem.toggle === 'function') {
                    window.BagSystem.toggle();
                }
            }, 'Toggle Inventory');
            
            KeyboardShortcuts.register('escape', () => {
                // Close any open windows
                if (window.BagSystem && typeof window.BagSystem.close === 'function') {
                    window.BagSystem.close();
                }
            }, 'Close Windows');
            
            KeyboardShortcuts.register('ctrl+s', (e) => {
                e.preventDefault();
                if (window.AutoSave) {
                    window.AutoSave.save();
                    console.log('[KeyboardShortcuts] Manual save triggered');
                }
            }, 'Manual Save');
            
            window.KeyboardShortcuts = KeyboardShortcuts;
        })();

        // ═══════════════════════════════════════════════════════════════════════════
        // GAME STATE VALIDATION SYSTEM
        // ═══════════════════════════════════════════════════════════════════════════
        (function() {
            const GameStateValidator = {
                validate(gameState) {
                    const errors = [];
                    const warnings = [];
                    
                    // Required properties
                    const required = ['level', 'gold', 'gems', 'keys', 'tickets'];
                    for (const prop of required) {
                        if (typeof gameState[prop] === 'undefined') {
                            errors.push(`Missing required property: ${prop}`);
                        } else if (typeof gameState[prop] !== 'number' || gameState[prop] < 0) {
                            warnings.push(`Invalid value for ${prop}: ${gameState[prop]}`);
                        }
                    }
                    
                    // Validate inventory structure
                    if (gameState.inventory) {
                        const requiredArrays = ['gear', 'pets', 'robots', 'spirits', 'vehicles', 'skills', 'items'];
                        for (const arr of requiredArrays) {
                            if (!Array.isArray(gameState.inventory[arr])) {
                                errors.push(`Invalid inventory.${arr}: must be an array`);
                            }
                        }
                    } else {
                        warnings.push('Missing inventory object');
                    }
                    
                    // Validate equipped structure
                    if (gameState.equipped) {
                        const requiredSlots = ['head', 'chest', 'gloves', 'pants', 'boots', 'weapon', 'offhand'];
                        for (const slot of requiredSlots) {
                            if (!(slot in gameState.equipped)) {
                                warnings.push(`Missing equipped slot: ${slot}`);
                            }
                        }
                    } else {
                        warnings.push('Missing equipped object');
                    }
                    
                    return {
                        valid: errors.length === 0,
                        errors,
                        warnings
                    };
                },
                
                fix(gameState) {
                    // Fix missing properties with defaults
                    const defaults = {
                        level: 1,
                        gold: 0,
                        gems: 0,
                        keys: 0,
                        tickets: 0,
                        inventory: {
                            gear: [], pets: [], robots: [], spirits: [], vehicles: [], skills: [], items: []
                        },
                        equipped: {
                            head: null, chest: null, gloves: null, pants: null, boots: null,
                            weapon: null, offhand: null, ring1: null, ring2: null, necklace: null,
                            pet: null, robot: null, spirit: null, vehicle: null
                        },
                        equippedSkills: {
                            A1: { S1: 'A1_S1', S2: 'A1_S2', S3: 'A1_S3' },
                            MISSY: { S1: 'MISSY_S1', S2: 'MISSY_S2', S3: 'MISSY_S3' },
                            UNIQUE: { S1: 'UNIQUE_S1', S2: 'UNIQUE_S2', S3: 'UNIQUE_S3' }
                        }
                    };
                    
                    // Merge defaults with existing state
                    for (const key in defaults) {
                        if (!(key in gameState)) {
                            gameState[key] = JSON.parse(JSON.stringify(defaults[key]));
                        } else if (typeof defaults[key] === 'object' && !Array.isArray(defaults[key])) {
                            // Deep merge objects
                            for (const subKey in defaults[key]) {
                                if (!(subKey in gameState[key])) {
                                    gameState[key][subKey] = JSON.parse(JSON.stringify(defaults[key][subKey]));
                                }
                            }
                        }
                    }
                    
                    return gameState;
                }
            };
            
            window.GameStateValidator = GameStateValidator;
        })();

        // ═══════════════════════════════════════════════════════════════════════════
        // ERROR RECOVERY SYSTEM
        // ═══════════════════════════════════════════════════════════════════════════
        (function() {
            const ErrorRecovery = {
                maxRecoveryAttempts: 3,
                recoveryAttempts: 0,
                
                recover(error, context) {
                    console.warn(`[ErrorRecovery] Attempting recovery for: ${context}`, error);
                    
                    if (this.recoveryAttempts >= this.maxRecoveryAttempts) {
                        console.error('[ErrorRecovery] Max recovery attempts reached');
                        return false;
                    }
                    
                    this.recoveryAttempts++;
                    
                    try {
                        // Try to recover gameState
                        if (context.includes('gameState') || context.includes('save')) {
                            if (window.gameState && window.GameStateValidator) {
                                const validation = window.GameStateValidator.validate(window.gameState);
                                if (!validation.valid) {
                                    console.log('[ErrorRecovery] Fixing gameState...');
                                    window.gameState = window.GameStateValidator.fix(window.gameState);
                                    console.log('[ErrorRecovery] GameState fixed');
                                    return true;
                                }
                            }
                        }
                        
                        // Try to reload from backup
                        if (context.includes('load') || context.includes('save')) {
                            if (window.AutoSave) {
                                const backup = localStorage.getItem('game_autosave_backup');
                                if (backup) {
                                    try {
                                        const backupData = JSON.parse(backup);
                                        if (backupData.gameState) {
                                            console.log('[ErrorRecovery] Loading from backup...');
                                            window.gameState = backupData.gameState;
                                            return true;
                                        }
                                    } catch (e) {
                                        console.error('[ErrorRecovery] Backup corrupted');
                                    }
                                }
                            }
                        }
                    } catch (recoveryError) {
                        console.error('[ErrorRecovery] Recovery failed:', recoveryError);
                    }
                    
                    return false;
                },
                
                reset() {
                    this.recoveryAttempts = 0;
                }
            };
            
            window.ErrorRecovery = ErrorRecovery;
        })();

        // ═══════════════════════════════════════════════════════════════════════════
        // BACKUP SYSTEM
        // ═══════════════════════════════════════════════════════════════════════════
        (function() {
            const BackupSystem = {
                maxBackups: 5,
                
                createBackup(gameState) {
                    try {
                        // Get existing backups
                        const backups = this.getBackups();
                        
                        // Create new backup
                        const backup = {
                            timestamp: Date.now(),
                            gameState: JSON.parse(JSON.stringify(gameState)),
                            version: '1.0'
                        };
                        
                        // Add to backups list
                        backups.unshift(backup);
                        
                        // Keep only maxBackups
                        if (backups.length > this.maxBackups) {
                            backups.pop();
                        }
                        
                        // Save backups
                        localStorage.setItem('game_backups', JSON.stringify(backups));
                        localStorage.setItem('game_autosave_backup', JSON.stringify(backup));
                        
                        console.log(`[BackupSystem] Created backup (${backups.length}/${this.maxBackups})`);
                        return true;
                    } catch (error) {
                        console.error('[BackupSystem] Backup failed:', error);
                        window.ErrorHandler?.log(error, 'BackupSystem');
                        return false;
                    }
                },
                
                getBackups() {
                    try {
                        const backups = localStorage.getItem('game_backups');
                        return backups ? JSON.parse(backups) : [];
                    } catch (error) {
                        return [];
                    }
                },
                
                restore(backupIndex = 0) {
                    try {
                        const backups = this.getBackups();
                        if (backupIndex >= backups.length) {
                            console.error('[BackupSystem] Invalid backup index');
                            return false;
                        }
                        
                        const backup = backups[backupIndex];
                        if (window.gameState && backup.gameState) {
                            Object.assign(window.gameState, backup.gameState);
                            console.log(`[BackupSystem] Restored backup from ${new Date(backup.timestamp).toLocaleString()}`);
                            return true;
                        }
                    } catch (error) {
                        console.error('[BackupSystem] Restore failed:', error);
                        window.ErrorHandler?.log(error, 'BackupSystem Restore');
                    }
                    return false;
                }
            };
            
            window.BackupSystem = BackupSystem;
        })();

        // ═══════════════════════════════════════════════════════════════════════════
        // PERFORMANCE MONITORING SYSTEM
        // ═══════════════════════════════════════════════════════════════════════════
        (function() {
            const PerformanceMonitor = {
                fps: 0,
                frameCount: 0,
                lastTime: performance.now(),
                fpsHistory: [],
                maxHistory: 60,
                memory: null,
                
                update() {
                    const now = performance.now();
                    const delta = now - this.lastTime;
                    this.frameCount++;
                    
                    // Update FPS every second
                    if (delta >= 1000) {
                        this.fps = Math.round((this.frameCount * 1000) / delta);
                        this.frameCount = 0;
                        this.lastTime = now;
                        
                        // Store in history
                        this.fpsHistory.push(this.fps);
                        if (this.fpsHistory.length > this.maxHistory) {
                            this.fpsHistory.shift();
                        }
                    }
                    
                    // Get memory info if available
                    if (performance.memory) {
                        this.memory = {
                            used: Math.round(performance.memory.usedJSHeapSize / 1048576),
                            total: Math.round(performance.memory.totalJSHeapSize / 1048576),
                            limit: Math.round(performance.memory.jsHeapSizeLimit / 1048576)
                        };
                    }
                },
                
                getAverageFPS() {
                    if (this.fpsHistory.length === 0) return 0;
                    const sum = this.fpsHistory.reduce((a, b) => a + b, 0);
                    return Math.round(sum / this.fpsHistory.length);
                },
                
                getMinFPS() {
                    return this.fpsHistory.length > 0 ? Math.min(...this.fpsHistory) : 0;
                },
                
                getMaxFPS() {
                    return this.fpsHistory.length > 0 ? Math.max(...this.fpsHistory) : 0;
                },
                
                start() {
                    // Performance monitoring will be called from animate function
                    // This is just initialization
                    console.log('[PerformanceMonitor] Started');
                }
            };
            
            window.PerformanceMonitor = PerformanceMonitor;
            PerformanceMonitor.start();
        })();

        // ═══════════════════════════════════════════════════════════════════════════
        // DEBUG PANEL SYSTEM
        // ═══════════════════════════════════════════════════════════════════════════
        (function() {
            const DebugPanel = {
                isVisible: false,
                panel: null,
                
                init() {
                    // Create debug panel
                    this.panel = document.createElement('div');
                    this.panel.id = 'debug-panel';
                    this.panel.innerHTML = `
                        <div class="debug-header">
                            <span>🐛 Debug Panel</span>
                            <button class="debug-close" onclick="window.DebugPanel.toggle()">×</button>
                        </div>
                        <div class="debug-content">
                            <div class="debug-section">
                                <h4>Performance</h4>
                                <div id="debug-fps">FPS: --</div>
                                <div id="debug-avg-fps">Avg FPS: --</div>
                                <div id="debug-min-fps">Min FPS: --</div>
                                <div id="debug-max-fps">Max FPS: --</div>
                                <div id="debug-memory">Memory: --</div>
                            </div>
                            <div class="debug-section">
                                <h4>Game State</h4>
                                <div id="debug-gamestate">Loading...</div>
                            </div>
                            <div class="debug-section">
                                <h4>Auto-Save</h4>
                                <div id="debug-autosave">Last save: --</div>
                            </div>
                            <div class="debug-section">
                                <h4>Errors (${window.ErrorHandler?.getErrors().length || 0})</h4>
                                <div id="debug-errors" class="debug-errors"></div>
                            </div>
                        </div>
                    `;
                    document.body.appendChild(this.panel);
                    
                    // Add styles
                    const style = document.createElement('style');
                    style.textContent = `
                        #debug-panel {
                            position: fixed;
                            bottom: 20px;
                            right: 20px;
                            width: 350px;
                            max-height: 500px;
                            background: rgba(0, 0, 0, 0.9);
                            border: 2px solid #4CAF50;
                            border-radius: 8px;
                            padding: 10px;
                            z-index: 9999;
                            display: none;
                            overflow-y: auto;
                            font-family: monospace;
                            font-size: 12px;
                            color: #fff;
                        }
                        #debug-panel.visible {
                            display: block;
                        }
                        .debug-header {
                            display: flex;
                            justify-content: space-between;
                            align-items: center;
                            margin-bottom: 10px;
                            padding-bottom: 10px;
                            border-bottom: 1px solid #555;
                        }
                        .debug-close {
                            background: #f44336;
                            border: none;
                            color: #fff;
                            width: 24px;
                            height: 24px;
                            border-radius: 4px;
                            cursor: pointer;
                        }
                        .debug-section {
                            margin-bottom: 15px;
                        }
                        .debug-section h4 {
                            margin: 0 0 8px 0;
                            color: #4CAF50;
                        }
                        .debug-errors {
                            max-height: 150px;
                            overflow-y: auto;
                            font-size: 10px;
                        }
                        .debug-error-item {
                            padding: 4px;
                            margin: 4px 0;
                            background: rgba(244, 67, 54, 0.2);
                            border-left: 3px solid #f44336;
                        }
                    `;
                    document.head.appendChild(style);
                    
                    // Toggle with F3 key
                    window.KeyboardShortcuts?.register('f3', () => {
                        this.toggle();
                    }, 'Toggle Debug Panel');
                    
                    // Update panel periodically
                    this.startUpdates();
                },
                
                toggle() {
                    this.isVisible = !this.isVisible;
                    if (this.panel) {
                        this.panel.classList.toggle('visible', this.isVisible);
                    }
                    if (this.isVisible) {
                        this.update();
                    }
                },
                
                update() {
                    if (!this.panel || !this.isVisible) return;
                    
                    // Update FPS from PerformanceMonitor
                    if (window.PerformanceMonitor) {
                        const pm = window.PerformanceMonitor;
                        const fpsEl = document.getElementById('debug-fps');
                        const avgFpsEl = document.getElementById('debug-avg-fps');
                        const minFpsEl = document.getElementById('debug-min-fps');
                        const maxFpsEl = document.getElementById('debug-max-fps');
                        
                        if (fpsEl) {
                            const fps = pm.fps;
                            fpsEl.textContent = `FPS: ${fps}`;
                            fpsEl.style.color = fps >= 60 ? '#4CAF50' : fps >= 30 ? '#FFC107' : '#f44336';
                        }
                        if (avgFpsEl) avgFpsEl.textContent = `Avg: ${pm.getAverageFPS()}`;
                        if (minFpsEl) minFpsEl.textContent = `Min: ${pm.getMinFPS()}`;
                        if (maxFpsEl) maxFpsEl.textContent = `Max: ${pm.getMaxFPS()}`;
                        
                        // Update memory
                        const memoryEl = document.getElementById('debug-memory');
                        if (memoryEl && pm.memory) {
                            memoryEl.textContent = `Memory: ${pm.memory.used}MB / ${pm.memory.total}MB`;
                        }
                    }
                    
                    // Update game state
                    const stateEl = document.getElementById('debug-gamestate');
                    if (stateEl && window.gameState) {
                        stateEl.innerHTML = `
                            Level: ${window.gameState.level || 'N/A'}<br>
                            Gold: ${window.gameState.gold || 0}<br>
                            Gems: ${window.gameState.gems || 0}<br>
                            Keys: ${window.gameState.keys || 0}
                        `;
                    }
                    
                    // Update auto-save status
                    const autosaveEl = document.getElementById('debug-autosave');
                    if (autosaveEl && window.AutoSave && window.AutoSave.lastSave) {
                        const timeSince = Math.round((Date.now() - window.AutoSave.lastSave) / 1000);
                        autosaveEl.textContent = `Last save: ${timeSince}s ago`;
                    }
                    
                    // Update errors
                    const errorsEl = document.getElementById('debug-errors');
                    if (errorsEl && window.ErrorHandler) {
                        const errors = window.ErrorHandler.getErrors().slice(-5);
                        errorsEl.innerHTML = errors.length > 0
                            ? errors.map(e => `
                                <div class="debug-error-item">
                                    ${e.message || 'Unknown error'}<br>
                                    <small>${e.context || ''} - ${new Date(e.timestamp).toLocaleTimeString()}</small>
                                </div>
                            `).join('')
                            : '<div style="color: #4CAF50;">No errors</div>';
                    }
                },
                
                startUpdates() {
                    setInterval(() => {
                        if (this.isVisible) {
                            this.update();
                        }
                    }, 1000);
                }
            };
            
            // Initialize debug panel after a short delay
            setTimeout(() => {
                DebugPanel.init();
            }, 1000);
            
            window.DebugPanel = DebugPanel;
        })();

        // ═══════════════════════════════════════════════════════════════════════════
        // DESTRUCTIBLE SYSTEM - Handles breakable objects and loot drops
        // ═══════════════════════════════════════════════════════════════════════════
        class DestructibleSystem {
            constructor(scene, particleSystem) {
                this.scene = scene;
                this.particleSystem = particleSystem;
                this.objects = []; // Stores all interactive world objects
                this.airDropTimer = 0;
                this.AIR_DROP_INTERVAL = 300; // 5 minutes (in seconds)
            }

            /**
             * Create a destructible object (tree, rock, or air drop)
             */
            createObject(type, position) {
                let mesh, health, maxHealth, scale;
                const id = Math.random().toString(36).substr(2, 9);

                if (type === 'tree') {
                    // Visuals: Brown Trunk + Green Cone
                    const group = new THREE.Group();
                    const trunk = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.4, 0.6, 2, 6),
                        new THREE.MeshStandardMaterial({ color: 0x5C3D2E, flatShading: true })
                    );
                    trunk.position.y = 1;
                    trunk.castShadow = true;

                    const leaves = new THREE.Mesh(
                        new THREE.ConeGeometry(1.5, 4, 8),
                        new THREE.MeshStandardMaterial({ color: 0x2E8B57, flatShading: true })
                    );
                    leaves.position.y = 3;
                    leaves.castShadow = true;

                    group.add(trunk, leaves);
                    mesh = group;
                    health = 300; // 3-4 hits
                    scale = 1.0 + Math.random() * 0.5;
                } 
                else if (type === 'rock') {
                    // Visuals: Low Poly Gray Rock
                    const geo = new THREE.DodecahedronGeometry(1.2 + Math.random(), 0);
                    const mat = new THREE.MeshStandardMaterial({ color: 0x696969, flatShading: true });
                    mesh = new THREE.Mesh(geo, mat);
                    mesh.position.y = 1;
                    mesh.castShadow = true;
                    health = 500; // Tanky
                    scale = 1.0;
                }
                else if (type === 'airdrop') {
                    // Visuals: Tech Crate with Beacon
                    const group = new THREE.Group();
                    const box = new THREE.Mesh(
                        new THREE.BoxGeometry(2, 2, 2),
                        new THREE.MeshStandardMaterial({ color: 0xFF4500, metalness: 0.8, roughness: 0.2 })
                    );
                    box.position.y = 1;
                    box.castShadow = true;

                    // Beacon Light Beam
                    const beam = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.1, 0.1, 100, 8),
                        new THREE.MeshBasicMaterial({ color: 0xFF0000, transparent: true, opacity: 0.3 })
                    );
                    beam.position.y = 50;

                    group.add(box, beam);
                    mesh = group;
                    health = 2000; // Raid boss HP level
                    scale = 1.0;
                }

                mesh.position.copy(position);
                mesh.scale.set(scale, scale, scale);
                this.scene.add(mesh);

                // Create Collision Box
                const collider = new THREE.Box3().setFromObject(mesh);
                const obj = {
                    id: id,
                    type: type,
                    mesh: mesh,
                    health: health,
                    maxHealth: health,
                    collider: collider,
                    hitBySwing: null // Track which swing hit this object
                };

                this.objects.push(obj);
                // Add to global colliders for player movement blocking
                if (window.gameState && window.gameState.colliders) {
                    window.gameState.colliders.push(collider);
                }

                return obj;
            }

            /**
             * Spawn an air drop near the player
             */
            spawnAirDrop(playerPos) {
                // Spawn 30-60 units away from player
                const angle = Math.random() * Math.PI * 2;
                const dist = 30 + Math.random() * 30;
                const x = playerPos.x + Math.cos(angle) * dist;
                const z = playerPos.z + Math.sin(angle) * dist;

                const pos = new THREE.Vector3(x, 0, z);

                // Calculate terrain height (using existing terrain formula)
                let h = Math.sin(x * 0.05) * Math.cos(z * 0.05) * 4;
                h += Math.sin(x * 0.01) * Math.cos(z * 0.01) * 8;
                pos.y = h;

                const obj = this.createObject('airdrop', pos);

                // Notification
                if (window.BagSystem) {
                    window.BagSystem.showToast("⚠️ A SUPPLY DROP IS FALLING NEARBY!");
                }
                console.log("AIR DROP SPAWNED AT", pos);
            }

            /**
             * Check if an attack hits any destructible objects
             */
            checkHit(position, radius, damage) {
                let hitSomething = false;
                for (let i = this.objects.length - 1; i >= 0; i--) {
                    const obj = this.objects[i];
                    const distance = position.distanceTo(obj.mesh.position);

                    // Simple sphere check
                    if (distance < (radius + 2)) { // +2 for object size buffer
                        this.takeDamage(obj, damage);
                        hitSomething = true;
                    }
                }
                return hitSomething;
            }

            /**
             * Apply damage to a destructible object
             */
            takeDamage(object, damage) {
                object.health -= damage;

                // Visual Feedback: Flash White
                const meshToFlash = object.type === 'tree' || object.type === 'airdrop' ? object.mesh.children[0] : object.mesh;
                if (meshToFlash && meshToFlash.material) {
                    const oldColor = meshToFlash.material.emissive ? meshToFlash.material.emissive.getHex() : 0x000000;
                    if (!meshToFlash.material.emissive) {
                        meshToFlash.material.emissive = new THREE.Color(0x000000);
                    }
                    meshToFlash.material.emissive.setHex(0xFFFFFF);
                    setTimeout(() => {
                        if (meshToFlash.material && meshToFlash.material.emissive) {
                            meshToFlash.material.emissive.setHex(oldColor);
                        }
                    }, 100);
                }

                // Show Damage Number
                createDamageIndicator(object.mesh.position.clone().add(new THREE.Vector3(0, 2, 0)), damage, { color: '#CCCCCC' });

                // Check Death
                if (object.health <= 0) {
                    this.destroyObject(object);
                }
            }

            /**
             * Destroy an object and generate loot
             */
            destroyObject(object) {
                const isBuilding = object.mesh && object.mesh.userData && object.mesh.userData.buildingData;
                const buildingData = isBuilding ? object.mesh.userData.buildingData : null;
                
                // Enhanced destruction effects for buildings
                if (isBuilding && buildingData) {
                    const position = object.mesh.position.clone();
                    
                    // 1. Screen shake (stronger for buildings)
                    if (typeof applyScreenShake === 'function') {
                        applyScreenShake(0.5, 0.8);
                    }
                    
                    // 2. Large particle explosion
                    if (this.particleSystem) {
                        // Main explosion
                        this.particleSystem.emit(position, 50, 0x666666, 0.5, 2.0);
                        // Smoke/dust cloud
                        setTimeout(() => {
                            this.particleSystem.emit(position, 30, 0x333333, 0.3, 1.5);
                        }, 100);
                    }
                    
                    // 3. Debris chunks (falling pieces)
                    this.createDebrisChunks(position, buildingData.size);
                    
                    // 4. Smoke effect (billboard sprites)
                    this.createSmokeEffect(position, buildingData.size.height);
                    
                    // 5. Explosion flash
                    this.createExplosionFlash(position);
                } else {
                    // Standard destruction for trees/rocks
                    const color = object.type === 'tree' ? 0x5C3D2E : (object.type === 'rock' ? 0x808080 : 0xFF4500);
                    if (this.particleSystem) {
                        this.particleSystem.emit(object.mesh.position, 20, color, 0.3, 1.0);
                    }
                }
                
                if (typeof playSound === 'function') {
                    playSound('hit');
                }

                // 1. Remove from Scene and Arrays
                this.scene.remove(object.mesh);
                this.objects = this.objects.filter(o => o !== object);

                // Remove collider from global list
                if (window.gameState && window.gameState.colliders) {
                    const colIdx = window.gameState.colliders.indexOf(object.collider);
                    if (colIdx > -1) window.gameState.colliders.splice(colIdx, 1);
                }
                
                // Remove building from gameState if it's a building
                if (isBuilding && buildingData && gameState.buildings) {
                    const buildingIdx = gameState.buildings.findIndex(b => b.id === buildingData.id);
                    if (buildingIdx > -1) {
                        gameState.buildings[buildingIdx].isDestroyed = true;
                    }
                }

                // 3. LOOT GENERATION
                this.dropLoot(object.type, object.mesh.position);
            }

            /**
             * Create debris chunks that fall and fade
             */
            createDebrisChunks(position, size) {
                const chunkCount = 15;
                const chunks = [];
                
                for (let i = 0; i < chunkCount; i++) {
                    const chunkSize = 0.3 + Math.random() * 0.5;
                    const chunkGeo = new THREE.BoxGeometry(chunkSize, chunkSize, chunkSize);
                    const chunkMat = new THREE.MeshStandardMaterial({ 
                        color: 0x666666,
                        roughness: 0.8
                    });
                    const chunk = new THREE.Mesh(chunkGeo, chunkMat);
                    
                    // Random position around building
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 2 + Math.random() * (size.width || 5);
                    chunk.position.set(
                        position.x + Math.cos(angle) * distance,
                        position.y + (size.height || 10) / 2 + Math.random() * 5,
                        position.z + Math.sin(angle) * distance
                    );
                    
                    // Random velocity
                    chunk.userData.velocity = new THREE.Vector3(
                        (Math.random() - 0.5) * 2,
                        -2 - Math.random() * 2,
                        (Math.random() - 0.5) * 2
                    );
                    chunk.userData.lifetime = 5 + Math.random() * 5;
                    chunk.userData.maxLifetime = chunk.userData.lifetime;
                    
                    this.scene.add(chunk);
                    chunks.push(chunk);
                }
                
                // Store chunks for update
                if (!this.debrisChunks) this.debrisChunks = [];
                chunks.forEach(chunk => {
                    chunk.userData.startTime = Date.now();
                    this.debrisChunks.push(chunk);
                });
            }

            /**
             * Create smoke effect using billboard sprites
             */
            createSmokeEffect(position, height) {
                const smokeCount = 8;
                
                for (let i = 0; i < smokeCount; i++) {
                    setTimeout(() => {
                        const canvas = document.createElement('canvas');
                        canvas.width = 64;
                        canvas.height = 64;
                        const ctx = canvas.getContext('2d');
                        
                        // Draw smoke puff
                        const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
                        gradient.addColorStop(0, 'rgba(100, 100, 100, 0.8)');
                        gradient.addColorStop(0.5, 'rgba(80, 80, 80, 0.4)');
                        gradient.addColorStop(1, 'rgba(60, 60, 60, 0)');
                        ctx.fillStyle = gradient;
                        ctx.fillRect(0, 0, 64, 64);
                        
                        const texture = new THREE.CanvasTexture(canvas);
                        texture.needsUpdate = true;
                        
                        const smokeMat = new THREE.SpriteMaterial({
                            map: texture,
                            transparent: true,
                            opacity: 0.6
                        });
                        
                        const smoke = new THREE.Sprite(smokeMat);
                        smoke.position.copy(position);
                        smoke.position.y += (height || 10) / 2;
                        smoke.position.x += (Math.random() - 0.5) * 4;
                        smoke.position.z += (Math.random() - 0.5) * 4;
                        smoke.scale.set(2, 2, 1);
                        
                        smoke.userData.velocity = new THREE.Vector3(
                            (Math.random() - 0.5) * 0.5,
                            0.5 + Math.random() * 0.5,
                            (Math.random() - 0.5) * 0.5
                        );
                        smoke.userData.lifetime = 3 + Math.random() * 2;
                        smoke.userData.maxLifetime = smoke.userData.lifetime;
                        
                        this.scene.add(smoke);
                        
                        if (!this.smokeParticles) this.smokeParticles = [];
                        this.smokeParticles.push(smoke);
                    }, i * 100);
                }
            }

            /**
             * Create explosion flash effect
             */
            createExplosionFlash(position) {
                const flashGeo = new THREE.SphereGeometry(10, 16, 16);
                const flashMat = new THREE.MeshBasicMaterial({
                    color: 0xffffff,
                    transparent: true,
                    opacity: 0.8
                });
                const flash = new THREE.Mesh(flashGeo, flashMat);
                flash.position.copy(position);
                this.scene.add(flash);
                
                // Fade out quickly
                let opacity = 0.8;
                const fadeInterval = setInterval(() => {
                    opacity -= 0.1;
                    flashMat.opacity = opacity;
                    if (opacity <= 0) {
                        clearInterval(fadeInterval);
                        this.scene.remove(flash);
                        flashGeo.dispose();
                        flashMat.dispose();
                    }
                }, 50);
            }

            /**
             * Update debris and smoke particles
             */
            updateDebrisAndSmoke(deltaTime) {
                // Update debris chunks
                if (this.debrisChunks) {
                    for (let i = this.debrisChunks.length - 1; i >= 0; i--) {
                        const chunk = this.debrisChunks[i];
                        if (!chunk || !chunk.userData) {
                            this.debrisChunks.splice(i, 1);
                            continue;
                        }
                        
                        // Apply gravity and velocity
                        chunk.userData.velocity.y -= 9.8 * deltaTime; // Gravity
                        chunk.position.add(chunk.userData.velocity.clone().multiplyScalar(deltaTime));
                        
                        // Rotate chunk
                        chunk.rotation.x += deltaTime * 2;
                        chunk.rotation.y += deltaTime * 2;
                        
                        // Update lifetime and fade
                        chunk.userData.lifetime -= deltaTime;
                        if (chunk.userData.lifetime <= 0) {
                            this.scene.remove(chunk);
                            chunk.geometry.dispose();
                            chunk.material.dispose();
                            this.debrisChunks.splice(i, 1);
                        } else {
                            // Fade out
                            const fadeProgress = 1 - (chunk.userData.lifetime / chunk.userData.maxLifetime);
                            chunk.material.opacity = 1 - fadeProgress;
                        }
                    }
                }
                
                // Update smoke particles
                if (this.smokeParticles) {
                    for (let i = this.smokeParticles.length - 1; i >= 0; i--) {
                        const smoke = this.smokeParticles[i];
                        if (!smoke || !smoke.userData) {
                            this.smokeParticles.splice(i, 1);
                            continue;
                        }
                        
                        // Move smoke upward
                        smoke.position.add(smoke.userData.velocity.clone().multiplyScalar(deltaTime));
                        
                        // Grow and fade
                        smoke.userData.lifetime -= deltaTime;
                        if (smoke.userData.lifetime <= 0) {
                            this.scene.remove(smoke);
                            smoke.material.map.dispose();
                            smoke.material.dispose();
                            this.smokeParticles.splice(i, 1);
                        } else {
                            const fadeProgress = 1 - (smoke.userData.lifetime / smoke.userData.maxLifetime);
                            smoke.material.opacity = 0.6 * (1 - fadeProgress);
                            smoke.scale.multiplyScalar(1 + deltaTime * 0.5); // Grow
                            
                            // Face camera
                            if (camera) {
                                smoke.lookAt(camera.position);
                            }
                        }
                    }
                }
            }

            /**
             * Generate and drop loot when object is destroyed
             */
            dropLoot(type, position) {
                const table = LOOT_TABLES[type];
                if (!table) return;

                // 1. Gold
                const goldAmt = Math.floor(Math.random() * (table.gold[1] - table.gold[0] + 1) + table.gold[0]);
                if (window.gameState) {
                    window.gameState.gold = (window.gameState.gold || 0) + goldAmt;
                }

                // Floating Text for Gold
                createDamageIndicator(position.clone().add(new THREE.Vector3(0, 1, 0)), `+${goldAmt} G`, { color: '#FFD700' });

                // 2. Items
                table.items.forEach((entry, index) => {
                    if (Math.random() <= entry.chance) {
                        const qty = Math.floor(Math.random() * (entry.max - entry.min + 1)) + entry.min;
                        const itemData = RESOURCE_DB[entry.id] || { name: 'Unknown', icon: '?', rarity: 'common', desc: '' };

                        // Add to Inventory State
                        this.addToInventory(entry.id, qty, itemData);

                        // Floating Text for Item (Staggered)
                        setTimeout(() => {
                            createDamageIndicator(
                                position.clone().add(new THREE.Vector3(0, 1.5 + (index * 0.5), 0)), 
                                `+${qty} ${itemData.icon} ${itemData.name}`, 
                                { color: '#FFFFFF' }
                            );
                        }, 200 * (index + 1));
                    }
                });

                // Trigger Bag Update if open
                if (window.BagSystem) {
                    if (window.BagSystem.isOpen) {
                        if (typeof window.BagSystem.renderCurrencies === 'function') {
                            window.BagSystem.renderCurrencies();
                        }
                        if (window.BagSystem.activeTab === 'gear' && typeof window.BagSystem.renderTab === 'function') {
                            window.BagSystem.renderTab('gear');
                        }
                    }
                    window.BagSystem.showToast(`Gathered: ${goldAmt} Gold and resources!`);
                }
            }

            /**
             * Add resource to inventory
             */
            addToInventory(id, qty, data) {
                if (!window.gameState) return;
                if (!window.gameState.inventory) window.gameState.inventory = {};
                if (!window.gameState.inventory.items) window.gameState.inventory.items = [];

                const existing = window.gameState.inventory.items.find(i => i.id === id);
                if (existing) {
                    existing.quantity += qty;
                } else {
                    window.gameState.inventory.items.push({
                        id: id,
                        name: data.name,
                        icon: data.icon,
                        category: 'material',
                        quantity: qty,
                        rarity: data.rarity,
                        description: data.desc
                    });
                }
            }

            /**
             * Update system (handles air drop timer and debris/smoke)
             */
            update(deltaTime) {
                // Timer for Air Drops
                this.airDropTimer += deltaTime;
                if (this.airDropTimer >= this.AIR_DROP_INTERVAL) {
                    this.airDropTimer = 0;
                    if (window.gameState && window.gameState.player && window.gameState.player.mesh) {
                        this.spawnAirDrop(window.gameState.player.mesh.position);
                    } else if (window.gameState && window.gameState.activeCharacter && window.gameState.activeCharacter.mesh) {
                        this.spawnAirDrop(window.gameState.activeCharacter.mesh.position);
                    }
                }
                
                // Update debris and smoke effects
                this.updateDebrisAndSmoke(deltaTime);
            }
        }

        // Helper function to check WebGL support with multiple context attributes
        function checkWebGLSupport() {
            const canvas = document.createElement('canvas');
            const contextAttributes = [
                { alpha: false, antialias: false, depth: true, stencil: false, failIfMajorPerformanceCaveat: false },
                { alpha: false, antialias: false, depth: true, stencil: false, failIfMajorPerformanceCaveat: true },
                { alpha: true, antialias: false, depth: true, stencil: false, failIfMajorPerformanceCaveat: false },
                {} // Default attributes
            ];

            for (let attrs of contextAttributes) {
                try {
                    const gl = canvas.getContext('webgl', attrs) || 
                               canvas.getContext('experimental-webgl', attrs) ||
                               canvas.getContext('webgl2', attrs);
                    if (gl) {
                        // Test if context is actually usable
                        const testShader = gl.createShader(gl.VERTEX_SHADER);
                        if (testShader) {
                            gl.deleteShader(testShader);
                            return true;
                        }
                    }
                } catch (e) {
                    continue;
                }
            }
            return false;
        }

        // Helper function to create WebGL renderer with multiple fallback strategies
        function createWebGLRenderer() {
            // Ensure document.body exists before proceeding
            if (!document.body) {
                console.warn("Document body not ready - will retry in fallback");
                return null;
            }

            // Check if WebGL is supported at all - test multiple ways
            const canvas = document.createElement('canvas');
            let gl = null;
            
            // Try different WebGL context requests with more permissive options
            const contextOptions = [
                { alpha: false, antialias: false, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false },
                { alpha: false, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false },
                { failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false },
                { failIfMajorPerformanceCaveat: false },
                {} // Most permissive - let browser decide
            ];
            
            for (let opts of contextOptions) {
                try {
                    // Try WebGL2 first, then WebGL1, then experimental
                    gl = canvas.getContext('webgl2', opts) ||
                         canvas.getContext('webgl', opts) || 
                         canvas.getContext('experimental-webgl', opts);
                    if (gl) {
                        // Test if context is actually usable
                        try {
                            const testShader = gl.createShader(gl.VERTEX_SHADER);
                            if (testShader) {
                                gl.deleteShader(testShader);
                                // Additional test: try creating a buffer
                                const testBuffer = gl.createBuffer();
                                if (testBuffer) {
                                    gl.deleteBuffer(testBuffer);
                                    break; // Found working context
                                }
                            }
                        } catch (e) {
                            gl = null;
                        }
                    }
                } catch (e) {
                    continue;
                }
            }
            
            if (!gl) {
                console.warn("WebGL context cannot be created - using fallback renderer");
                return null;
            }

            // Suppress Three.js WebGL errors temporarily - catch ALL errors
            const originalConsoleError = console.error;
            const originalConsoleWarn = console.warn;
            const webGLErrors = [];
            let errorSuppressed = false;
            
            // Override console.error to suppress WebGL-related errors
            console.error = function(...args) {
                const message = args.join(' ');
                if (message.includes('WebGL') || 
                    message.includes('WebGLRenderer') || 
                    message.includes('context') ||
                    message.includes('BindToCurrentSequence') ||
                    message.includes('ANGLE') ||
                    message.includes('VENDOR') ||
                    message.includes('DEVICE')) {
                    webGLErrors.push(message);
                    errorSuppressed = true;
                    return; // Suppress WebGL errors during renderer creation
                }
                originalConsoleError.apply(console, args);
            };
            
            // Also suppress warnings during renderer creation
            console.warn = function(...args) {
                const message = args.join(' ');
                if (message.includes('WebGL') || 
                    message.includes('WebGLRenderer') || 
                    message.includes('context') ||
                    message.includes('deprecated') ||
                    message.includes('r153') ||
                    message.includes('r163')) {
                    return; // Suppress WebGL warnings
                }
                originalConsoleWarn.apply(console, args);
            };

            // Strategy: Try WebGL with optimal settings, including WebGL2
            const strategies = [
                { antialias: true, powerPreference: "high-performance", failIfMajorPerformanceCaveat: false },
                { antialias: true, powerPreference: "default", failIfMajorPerformanceCaveat: false },
                { antialias: false, powerPreference: "default", failIfMajorPerformanceCaveat: false },
                { antialias: false, powerPreference: "low-power", failIfMajorPerformanceCaveat: false },
                { antialias: false, powerPreference: "default", failIfMajorPerformanceCaveat: true },
                { antialias: false, powerPreference: "low-power", failIfMajorPerformanceCaveat: true },
                // Most permissive options
                { failIfMajorPerformanceCaveat: false },
                { failIfMajorPerformanceCaveat: true }
            ];

            let successfulRenderer = null;
            let lastError = null;

            for (let i = 0; i < strategies.length; i++) {
                webGLErrors.length = 0; // Clear previous errors
                try {
                    // Create canvas element first to ensure it exists
                    const renderCanvas = document.createElement('canvas');
                    renderCanvas.width = window.innerWidth || 800;
                    renderCanvas.height = window.innerHeight || 600;
                    
                    // Try creating renderer with explicit canvas
                    const testRenderer = new THREE.WebGLRenderer({ 
                        canvas: renderCanvas,
                        ...strategies[i]
                    });
                    
                    // Verify the renderer actually has a valid context
                    const context = testRenderer.getContext();
                    
                    if (context) {
                        // Double-check: try to use the context
                        try {
                            const testBuffer = context.createBuffer();
                            if (testBuffer) {
                                context.deleteBuffer(testBuffer);
                                
                                // Additional validation: check if context is not lost
                                if (context.isContextLost && context.isContextLost()) {
                                    testRenderer.dispose();
                                    lastError = "WebGL context was lost";
                                    continue;
                                }
                                
                                console.log(`✅ WebGL renderer created successfully with strategy ${i + 1}`);
                                successfulRenderer = testRenderer;
                                break;
                            }
                        } catch (e) {
                            lastError = e.message;
                            testRenderer.dispose();
                            continue;
                        }
                    } else {
                        lastError = "Renderer created but context is null";
                        testRenderer.dispose();
                    }
                } catch (error) {
                    lastError = error.message;
                    // Don't log every failed attempt to reduce console noise
                    continue;
                }
            }

            // Restore console functions
            console.error = originalConsoleError;
            console.warn = originalConsoleWarn;

            if (!successfulRenderer) {
                // Only log if we actually suppressed errors (means WebGL was attempted but failed)
                if (errorSuppressed || webGLErrors.length > 0) {
                    console.warn("WebGL renderer creation failed - will use fallback renderer");
                    // Don't log the full error details to reduce console noise
                } else if (lastError) {
                    console.warn(`WebGL renderer creation failed: ${lastError} - using fallback`);
                }
                
                // Skip final fallback attempt if we've already tried everything
                // The minimal fallback in init() will handle it
                return null;
            }

            return successfulRenderer;
        }

        
const lootTables = {
    slime: [
        { id: 'slime_gel', name: 'Slime Gel', icon: '💧', rarity: 'common', description: 'A sticky, gelatinous substance.', chance: 0.9, quantity: [1, 3] },
        { id: 'health_potion_small', name: 'Small Health Potion', icon: '🧪', rarity: 'uncommon', description: 'Restores 20 HP.', chance: 0.15, quantity: [1, 1] }
    ]
};

function dropLoot(enemy) {
    if (!enemy.type || !lootTables[enemy.type]) return;

    const table = lootTables[enemy.type];
    const lootPosition = enemy.mesh.position.clone();
    lootPosition.y = 0.5; // Drop it on the ground

    table.forEach(item => {
        if (Math.random() < item.chance) {
            const quantity = Math.floor(Math.random() * (item.quantity[1] - item.quantity[0] + 1)) + item.quantity[0];

            const lootGeometry = new THREE.BoxGeometry(0.5, 0.5, 0.5);
            let lootMaterial;
            switch (item.rarity) {
                case 'uncommon':
                    lootMaterial = new THREE.MeshStandardMaterial({ color: 0x10b981, emissive: 0x10b981, emissiveIntensity: 0.5 });
                    break;
                case 'rare':
                    lootMaterial = new THREE.MeshStandardMaterial({ color: 0x3b82f6, emissive: 0x3b82f6, emissiveIntensity: 0.5 });
                    break;
                default: // common
                    lootMaterial = new THREE.MeshStandardMaterial({ color: 0x9ca3af, emissive: 0x9ca3af, emissiveIntensity: 0.5 });
            }

            const lootMesh = new THREE.Mesh(lootGeometry, lootMaterial);
            lootMesh.position.copy(lootPosition);
            // Scatter drops a bit
            lootMesh.position.x += (Math.random() - 0.5) * 1.5;
            lootMesh.position.z += (Math.random() - 0.5) * 1.5;

            lootMesh.userData = {
                isLoot: true,
                item: { ...item, quantity: quantity },
                creationTime: clock.getElapsedTime()
            };

            scene.add(lootMesh);
            if(window.gameState && window.gameState.lootDrops) {
                window.gameState.lootDrops.push(lootMesh);
            }
        }
    });
}

function checkLootPickup() {
    if (!window.gameState || !window.gameState.player || !window.gameState.player.mesh || !window.gameState.lootDrops) return;
    const playerPosition = window.gameState.player.mesh.position;
    const pickupRadius = 1.5;

    for (let i = window.gameState.lootDrops.length - 1; i >= 0; i--) {
        const loot = window.gameState.lootDrops[i];
        if (loot.position.distanceTo(playerPosition) < pickupRadius) {
            addItemToInventory(loot.userData.item);
            scene.remove(loot);
            window.gameState.lootDrops.splice(i, 1);
        }
    }
}

function addItemToInventory(item) {
    if (!window.gameState || !window.gameState.player || !window.gameState.player.inventory) return;

    if (window.gameState.player.inventory[item.id]) {
        window.gameState.player.inventory[item.id].quantity += item.quantity;
    } else {
        window.gameState.player.inventory[item.id] = { ...item };
    }
    
    const bagWindow = document.querySelector('.bag-window');
    if (bagWindow && bagWindow.classList.contains('open')) {
        renderInventory();
    }
}

function renderInventory() {
    if (!window.gameState || !window.gameState.player || !window.gameState.player.inventory) return;

    const inventory = window.gameState.player.inventory;
    const grid = document.querySelector('#bag-tab-content-items .cards-grid');
    if (!grid) return;

    grid.innerHTML = ''; // Clear existing items

    const items = Object.values(inventory);

    if (items.length === 0) {
        grid.innerHTML = `<div class="empty-state" style="grid-column: 1 / -1;">
            <div class="empty-state-icon">🎒</div>
            <p class="empty-state-text">Your bag is empty.</p>
            <p class="empty-state-subtext">Defeat enemies to collect loot!</p>
        </div>`;
        return;
    }

    items.sort((a, b) => { // Sort to keep order consistent
        const rarityOrder = { 'common': 0, 'uncommon': 1, 'rare': 2, 'epic': 3, 'legendary': 4, 'mythic': 5 };
        if (rarityOrder[b.rarity] !== rarityOrder[a.rarity]) {
            return (rarityOrder[b.rarity] || 0) - (rarityOrder[a.rarity] || 0);
        }
        return a.name.localeCompare(b.name);
    });

    items.forEach(item => {
        const useButtonHTML = item.id === 'health_potion_small' 
            ? `<button class="item-action-btn" onclick="useItem('${item.id}')">Use</button>`
            : `<button class="item-action-btn" style="opacity:0.5; cursor:not-allowed;">Use</button>`;

        const cardHTML = `
            <div class="item-card" data-rarity="${item.rarity || 'common'}">
                <div class="item-icon">${item.icon}</div>
                <h3 class="item-name">${item.name} (x${item.quantity})</h3>
                <p class="item-rarity" data-rarity="${item.rarity || 'common'}">${item.rarity}</p>
                <p class="item-description">${item.description}</p>
                ${useButtonHTML}
            </div>
        `;
        grid.innerHTML += cardHTML;
    });
}

function useItem(itemId) {
    if (!window.gameState || !window.gameState.player || !window.gameState.player.inventory) return;

    const item = window.gameState.player.inventory[itemId];
    if (!item) {
        console.error("Tried to use an item that doesn't exist:", itemId);
        return;
    }

    let itemUsed = false;
    switch (itemId) {
        case 'health_potion_small':
            if (window.gameState.player.stats.hp < window.gameState.player.stats.maxHp) {
                const healAmount = 20;
                window.gameState.player.stats.hp = Math.min(window.gameState.player.stats.maxHp, window.gameState.player.stats.hp + healAmount);
                updatePlayerStatsUI();
                showDamageText(healAmount, window.gameState.player.mesh.position, '#38ef7d'); // Green for healing
                itemUsed = true;
            }
            break;
        default:
            console.log(`Item '${item.name}' has no use effect yet.`);
            break;
    }

    if (itemUsed) {
        item.quantity--;
        if (item.quantity <= 0) {
            delete window.gameState.player.inventory[itemId];
        }
        renderInventory();
    }
}

function init() {
            // Update loading progress
            if (window.LoadingProgress) {
                window.LoadingProgress.update(10, 'Checking WebGL support...');
            }
            
            // Check WebGL support (non-blocking - fallback will handle if not available)
            const webGLSupported = checkWebGLSupport();
            if (!webGLSupported) {
                console.warn("WebGL not detected, will attempt fallback rendering");
                window.USING_FALLBACK_RENDERER = true;
            }

            // Update loading progress
            if (window.LoadingProgress) {
                window.LoadingProgress.update(20, 'Creating scene...');
            }
            
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb); // Sky blue
            scene.fog = new THREE.Fog(0x87ceeb, 100, WORLD_SIZE / 1.5);

            // Update loading progress
            if (window.LoadingProgress) {
                window.LoadingProgress.update(30, 'Initializing renderer...');
            }
            
            // Renderer with multiple fallback strategies
            renderer = createWebGLRenderer();
            let usingWebGLFallback = false;
            
            if (!renderer) {
                // Skip further WebGL attempts - Three.js renderer won't work
                // The fallback 2D canvas renderer will be created below
                console.warn("WebGL renderer creation failed - using 2D canvas fallback");
                renderer = null; // Explicitly set to null to trigger fallback creation
            }
            
            if (!renderer) {
                // Show warning but continue with basic rendering
                console.warn("⚠️ WebGL not available. Game will run with reduced graphics quality.");
                
                // Show informational message (not blocking)
                const infoDiv = document.createElement('div');
                infoDiv.id = 'webgl-warning';
                infoDiv.style.cssText = 'position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(255, 165, 0, 0.9); color: white; padding: 15px 25px; border-radius: 8px; z-index: 9999; max-width: 600px; text-align: center; box-shadow: 0 4px 6px rgba(0,0,0,0.3);';
                infoDiv.innerHTML = `
                    <strong>⚠️ WebGL Not Available</strong><br>
                    <span style="font-size: 13px;">Running with reduced graphics. Game will still function but may have limited visuals.</span>
                    <button onclick="this.parentElement.remove()" style="margin-left: 15px; padding: 5px 15px; background: rgba(255,255,255,0.3); color: white; border: 1px solid white; border-radius: 4px; cursor: pointer;">Dismiss</button>
                `;
                document.body.appendChild(infoDiv);
                
                // Auto-dismiss after 10 seconds
                setTimeout(() => {
                    const warning = document.getElementById('webgl-warning');
                    if (warning) warning.remove();
                }, 10000);
                
                // Create a basic 2D canvas renderer wrapper for compatibility
                // This allows the game to continue running even without WebGL
                const fallbackCanvas = document.createElement('canvas');
                fallbackCanvas.id = 'fallback-renderer';
                fallbackCanvas.width = window.innerWidth;
                fallbackCanvas.height = window.innerHeight;
                fallbackCanvas.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #87ceeb; z-index: 1;';
                document.body.appendChild(fallbackCanvas);
                
                const ctx = fallbackCanvas.getContext('2d');
                let lastRenderTime = 0;
                let frameCount = 0;
                
                // Create a minimal renderer object for compatibility
                renderer = {
                    domElement: fallbackCanvas,
                    render: function(scene, camera) {
                        // Clear canvas
                        ctx.fillStyle = '#87ceeb';
                        ctx.fillRect(0, 0, fallbackCanvas.width, fallbackCanvas.height);
                        
                        // Show basic status info
                        const now = Date.now();
                        if (now - lastRenderTime > 1000) { // Update every second
                            frameCount = 0;
                            lastRenderTime = now;
                        }
                        frameCount++;
                        
                        // Draw simple status display
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        ctx.fillRect(10, 10, 400, 120);
                        
                        ctx.fillStyle = '#ffffff';
                        ctx.font = 'bold 18px Arial';
                        ctx.textAlign = 'left';
                        ctx.fillText('⚠️ WebGL Not Available', 20, 35);
                        
                        ctx.font = '14px Arial';
                        ctx.fillText('Game is running but 3D graphics are unavailable.', 20, 60);
                        ctx.fillText('Your graphics driver may need updating.', 20, 80);
                        ctx.fillText(`FPS: ${frameCount} | Game Logic: Active`, 20, 100);
                        
                        // Draw a simple representation of game state if available
                        if (gameState && gameState.activeCharacter && gameState.activeCharacter.mesh) {
                            const char = gameState.activeCharacter;
                            ctx.fillStyle = '#ffff00';
                            ctx.fillRect(50, fallbackCanvas.height - 100, 30, 30);
                            ctx.fillStyle = '#ffffff';
                            ctx.font = '12px Arial';
                            ctx.fillText('Player', 85, fallbackCanvas.height - 85);
                        }
                    },
                    setSize: function(width, height) {
                        fallbackCanvas.width = width;
                        fallbackCanvas.height = height;
                    },
                    setPixelRatio: function() {},
                    getContext: function() { return ctx; },
                    shadowMap: { enabled: false },
                    dispose: function() {
                        if (fallbackCanvas.parentElement) {
                            fallbackCanvas.parentElement.removeChild(fallbackCanvas);
                        }
                    }
                };
                
                window.USING_FALLBACK_RENDERER = true; // Flag for minimal mode
                console.log("⚠️ Using fallback 2D canvas renderer. Game will function but 3D graphics are unavailable.");
            }
            
            if (renderer && renderer.setSize) {
                renderer.setSize(window.innerWidth, window.innerHeight);
                if (renderer.setPixelRatio) {
                    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // Limit pixel ratio for performance
                }
                if (renderer.shadowMap) {
                    // Only enable shadows if not using fallback
                    renderer.shadowMap.enabled = !usingWebGLFallback && !window.USING_FALLBACK_RENDERER;
                }
                if (renderer.domElement && !renderer.domElement.parentElement) {
                    document.body.appendChild(renderer.domElement);
                }
            }

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(100, 100, 50);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.left = -WORLD_SIZE / 2;
            directionalLight.shadow.camera.right = WORLD_SIZE / 2;
            directionalLight.shadow.camera.top = WORLD_SIZE / 2;
            directionalLight.shadow.camera.bottom = -WORLD_SIZE / 2;
            scene.add(directionalLight);

            // Clock
            clock = new THREE.Clock();

            // Initialize 3D Sprite Manager
            sprite3DManager = new Sprite3DManager(THREE, scene);

            // Initialize Interior System
            if (!window.InteriorSystem) {
                window.InteriorSystem = new InteriorSystem(THREE, scene);
            }

            // Initialize NPC Building Behavior System
            if (typeof NPCBuildingBehavior !== 'undefined') {
                window.NPCBuildingBehavior = new NPCBuildingBehavior(THREE, scene);
            }

            // Initialize Shop System
            if (typeof ShopSystem !== 'undefined') {
                window.ShopSystem = new ShopSystem(THREE, scene);
            }

            // Initialize Quest System
            if (typeof QuestSystem !== 'undefined') {
                window.QuestSystem = new QuestSystem();
            }

            // Initialize Building Upgrade System
            if (typeof BuildingUpgradeSystem !== 'undefined') {
                window.BuildingUpgradeSystem = new BuildingUpgradeSystem();
            }

            // Initialize Day/Night Cycle System
            if (typeof DayNightCycleSystem !== 'undefined') {
                window.DayNightCycleSystem = new DayNightCycleSystem(scene);
            }

            // Initialize Building Ownership System
            if (typeof BuildingOwnershipSystem !== 'undefined') {
                window.BuildingOwnershipSystem = new BuildingOwnershipSystem();
            }

            // Initialize Building Customization System
            if (typeof BuildingCustomizationSystem !== 'undefined') {
                window.BuildingCustomizationSystem = new BuildingCustomizationSystem();
            }

            // Initialize Building Event System
            if (typeof BuildingEventSystem !== 'undefined') {
                window.BuildingEventSystem = new BuildingEventSystem(scene);
            }

            // Initialize Building Reputation System
            if (typeof BuildingReputationSystem !== 'undefined') {
                window.BuildingReputationSystem = new BuildingReputationSystem();
            }

            // Initialize Interaction System
            InteractionSystem.init();

            // Initialize Breach System
            if (!window.BreachSystem) {
                window.BreachSystem = new BreachSystem(THREE, scene);
            }

            // Initialize World Boss System
            if (!window.WorldBossSystem) {
                window.WorldBossSystem = new WorldBossSystem(THREE, scene);
            }

            // Initialize Building UI System (before createCity() is called)
            if (typeof BuildingUISystem !== 'undefined') {
                window.BuildingUISystem = new BuildingUISystem(THREE, scene, camera);
            }

            // Update loading progress
            if (window.LoadingProgress) {
                window.LoadingProgress.update(60, 'Generating world...');
            }
            
            // -- WORLD GENERATION --
            createWorld();
            createCity();
            
            // Update loading progress
            if (window.LoadingProgress) {
                window.LoadingProgress.update(80, 'Finalizing...');
            }
            
            // Initialize Destructible System (will be fully initialized after particleSystem is created)
            // For now, create with null particleSystem, will be updated later
            window.destructibleSystem = new DestructibleSystem(scene, null);
            
            createNature();

            // -- PLAYER & NPC CREATION --
            createCharacters();
            createNPCs();
            createPartyMembers();

            // Create 3D sprite for player after player mesh is created
            if (gameState.activeCharacter && gameState.activeCharacter.mesh) {
                const playerPos = gameState.activeCharacter.mesh.position.clone();
                const characterId = gameState.activeCharacter.characterId || 'A1';
                const playerSprite = sprite3DManager.createSprite(characterId, playerPos, 'fire');
                if (playerSprite) {
                    gameState.activeCharacter.sprite3D = playerSprite;
                    console.log(`✅ Created 3D sprite for ${characterId}`);
                }

                // Initialize sprite renderer for player
                if (spriteRenderer) {
                    spriteRenderer.initCharacter(characterId, gameState.activeCharacter.mesh);
                    spriteRenderer.setAnimation(characterId, 'idle', 0);
                }
            }




            setupInputListeners();

            // Handle window resizing
            window.addEventListener('resize', onWindowResize, false);

            // Start the game loop
            // Complete loading progress
            if (window.LoadingProgress) {
                window.LoadingProgress.complete();
            }
            
            animate();
        }

        function createWorld() {
            const groundGeometry = new THREE.PlaneGeometry(WORLD_SIZE, WORLD_SIZE, 100, 100);
            const groundMaterial = new THREE.MeshStandardMaterial({ vertexColors: true, flatShading: true });

            const positionAttribute = groundGeometry.getAttribute('position');
            const colors = [];
            const color = new THREE.Color();

            for (let i = 0; i < positionAttribute.count; i++) {
                const x = positionAttribute.getX(i);
                const y = positionAttribute.getY(i);

                // Simple noise for rolling hills
                let z = Math.sin(x * 0.05) * Math.cos(y * 0.05) * 4;
                z += Math.sin(x * 0.01) * Math.cos(y * 0.01) * 8;
                positionAttribute.setZ(i, z);

                // Color based on location and height
                if (x > -WORLD_SIZE / 4 && x < WORLD_SIZE / 4 && y > -WORLD_SIZE / 4 && y < WORLD_SIZE / 4) {
                    // City area - grey
                    color.set(0x555555);
                } else {
                    // Nature area - green
                    if (z > 5) {
                        color.set(0x6c8c4f); // Darker green for peaks
                    } else {
                        color.set(0x5a7d43); // Lighter green for valleys
                    }
                }
                colors.push(color.r, color.g, color.b);
            }

            groundGeometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            groundGeometry.computeVertexNormals();

            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            gameState.ground = ground; // Store ground for collision detection
            scene.add(ground);
        }

        function createCity() {
            console.log("[CitySystem] Generating Nexus City Districts...");
            
            // Initialize building data storage
            if (!gameState.buildings) gameState.buildings = [];
            if (!gameState.doorTriggers) gameState.doorTriggers = [];

            // Building materials
            const buildingMat = new THREE.MeshStandardMaterial({ 
                color: 0x444455, 
                roughness: 0.2, 
                metalness: 0.6 
            });
            const windowMat = new THREE.MeshBasicMaterial({ 
                color: 0xaaccff,
                emissive: 0x224466,
                emissiveIntensity: 0.3
            });
            const doorMat = new THREE.MeshBasicMaterial({ 
                color: 0xffaa00,
                emissive: 0xff6600,
                emissiveIntensity: 0.5
            }); // Orange doors for visibility

            const buildingTypes = ['shop', 'residential', 'office', 'warehouse', 'apartment'];
            let buildingIndex = 0;

            // Create grid-based city layout
            const gridSpacing = 60;
            const cityArea = WORLD_SIZE / 4;
            
            for (let x = -cityArea; x <= cityArea; x += gridSpacing) {
                for (let z = -cityArea; z <= cityArea; z += gridSpacing) {
                    // Skip center spawn area (player starting location)
                    if (Math.abs(x) < 40 && Math.abs(z) < 40) continue;

                    // Randomize building size
                    const width = 20 + Math.random() * 15;
                    const depth = 20 + Math.random() * 15;
                    const height = 40 + Math.random() * 80;

                    // Create building
                    const buildingGeometry = new THREE.BoxGeometry(width, height, depth);
                    const building = new THREE.Mesh(buildingGeometry, buildingMat);
                    building.position.set(x, height / 2, z);
                    building.castShadow = true;
                    building.receiveShadow = true;
                    scene.add(building);

                    // Add windows to building faces
                    const windowSize = 2;
                    const windowSpacing = 5;
                    const numWindowsX = Math.floor(width / windowSpacing);
                    const numWindowsZ = Math.floor(depth / windowSpacing);
                    
                    // Front face windows (facing positive Z)
                    for (let wx = 0; wx < numWindowsX; wx++) {
                        for (let wy = 0; wy < Math.floor(height / windowSpacing) - 1; wy++) {
                            const windowGeo = new THREE.PlaneGeometry(windowSize, windowSize);
                            const window = new THREE.Mesh(windowGeo, windowMat);
                            window.position.set(
                                x - width/2 + (wx + 0.5) * windowSpacing,
                                height/2 - (wy + 1) * windowSpacing,
                                z + depth/2 + 0.1
                            );
                            scene.add(window);
                        }
                    }

                    // Side face windows
                    for (let wz = 0; wz < numWindowsZ; wz++) {
                        for (let wy = 0; wy < Math.floor(height / windowSpacing) - 1; wy++) {
                            const windowGeo = new THREE.PlaneGeometry(windowSize, windowSize);
                            const window = new THREE.Mesh(windowGeo, windowMat);
                            window.rotation.y = Math.PI / 2;
                            window.position.set(
                                x + width/2 + 0.1,
                                height/2 - (wy + 1) * windowSpacing,
                                z - depth/2 + (wz + 0.5) * windowSpacing
                            );
                            scene.add(window);
                        }
                    }

                    const buildingCollider = new THREE.Box3().setFromObject(building);
                    gameState.colliders.push(buildingCollider);

                    // Determine building type and properties
                    const buildingType = buildingTypes[Math.floor(Math.random() * buildingTypes.length)];
                    const hasInterior = Math.random() < 0.7; // 70% of buildings have interiors
                    const isDestructible = Math.random() < 0.3; // 30% are destructible

                    // Store building data
                    const buildingData = {
                        id: `building_${buildingIndex}`,
                        mesh: building,
                        position: new THREE.Vector3(x, height / 2, z),
                        size: { width: width, height: height, depth: depth },
                        type: buildingType,
                        hasInterior: hasInterior,
                        collider: buildingCollider
                    };
                    gameState.buildings.push(buildingData);
                    building.userData.buildingData = buildingData;

                    // Create door trigger for buildings with interiors
                    if (hasInterior) {
                        // Door position on front face of building (facing positive Z)
                        const doorPosition = new THREE.Vector3(
                            x,
                            3.5, // Door height at ground level + 3.5
                            z + depth / 2 + 0.1 // Slightly in front of building
                        );
                        
                        // Create visible door mesh
                        const doorGeo = new THREE.PlaneGeometry(4, 7);
                        const door = new THREE.Mesh(doorGeo, doorMat);
                        door.position.copy(doorPosition);
                        door.userData.isDoor = true;
                        // Door animation state
                        door.userData.animationState = {
                            isOpen: false,
                            isAnimating: false,
                            currentRotation: 0,
                            targetRotation: 0,
                            animationSpeed: 3.0 // radians per second (90 degrees in 0.3s = ~5.24 rad/s, but using 3 for smoother)
                        };
                        // Store pivot point (left edge of door for rotation)
                        door.userData.pivotOffset = new THREE.Vector3(-2, 0, 0); // Half door width to left
                        scene.add(door);
                        
                        // Create door trigger zone
                        const doorTriggerSize = 5; // Interaction radius
                        const doorTrigger = {
                            id: `door_${buildingIndex}`,
                            buildingId: buildingData.id,
                            position: doorPosition,
                            size: doorTriggerSize,
                            building: buildingData,
                            doorMesh: door
                        };
                        gameState.doorTriggers.push(doorTrigger);
                        
                        // Create nameplate and icon for building
                        if (window.BuildingUISystem) {
                            const buildingName = window.BuildingUISystem.getBuildingName(buildingType, buildingIndex);
                            const iconEmoji = window.BuildingUISystem.getBuildingIcon(buildingType);
                            window.BuildingUISystem.createNameplate(buildingName, doorPosition, buildingType);
                            window.BuildingUISystem.createIcon(iconEmoji, doorPosition);
                        }
                    }

                    // Add destructible state if applicable
                    if (isDestructible) {
                        const health = 200 + Math.random() * 300;
                        building.userData.isDestructible = true;
                        const healthBar = createHealthBar();
                        healthBar.position.y = (height / 2) + 2;
                        building.add(healthBar);

                        const destructibleState = {
                            mesh: building,
                            health: health,
                            maxHealth: health,
                            collider: buildingCollider,
                            isDestroyed: false,
                            regenerationTimer: 0,
                            healthBar: healthBar,
                            originalScale: building.scale.clone()
                        };
                        gameState.destructibleObjects.push(destructibleState);
                    }

                    buildingIndex++;
                }
            }

            console.log(`[CitySystem] Generated ${buildingIndex} buildings in grid layout`);
        }

        // ═══════════════════════════════════════════════════════════════════════════
        // WORLD BOSS SYSTEM - Spawns and manages world bosses
        // ═══════════════════════════════════════════════════════════════════════════
        class WorldBossSystem {
            constructor(THREE, scene) {
                this.THREE = THREE;
                this.scene = scene;
                this.activeBosses = [];
                this.spawnTimer = 0;
                this.spawnInterval = 15 * 60 * 1000; // 15 minutes
                this.lastSpawnTime = 0;
            }

            // Spawn a world boss
            spawnWorldBoss(district = 'District_1') {
                // Don't spawn if already have active boss
                if (this.activeBosses.length > 0) {
                    return;
                }

                // Create boss NPC (enhanced villain)
                const bossGeometry = new THREE.CapsuleGeometry(1.2, 2.0, 8, 16);
                const bossMaterial = new THREE.MeshStandardMaterial({
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.8
                });
                const bossMesh = new THREE.Mesh(bossGeometry, bossMaterial);

                // Spawn position (away from city center)
                const spawnX = THREE.MathUtils.randFloat(-WORLD_SIZE / 2, WORLD_SIZE / 2);
                const spawnZ = THREE.MathUtils.randFloat(-WORLD_SIZE / 2, WORLD_SIZE / 2);
                bossMesh.position.set(spawnX, 2.0, spawnZ);
                bossMesh.castShadow = true;
                this.scene.add(bossMesh);

                // Create boss state
                const bossState = {
                    id: `world_boss_${Date.now()}`,
                    mesh: bossMesh,
                    healthBar: createHealthBar(),
                    type: 'worldBoss',
                    health: 5000,
                    maxHealth: 5000,
                    rank: 'SS',
                    stats: {
                        attack: 100
                    },
                    attackCooldown: 0,
                    attackTarget: null,
                    state: 'wandering',
                    district: district,
                    spawnTime: Date.now()
                };

                bossMesh.add(bossState.healthBar);
                bossState.healthBar.position.y = 3.5;

                // Add to NPCs array for combat system
                gameState.npcs.push(bossState);
                this.activeBosses.push(bossState);

                // Show notification
                if (window.BagSystem) {
                    window.BagSystem.showToast(`👑 World Boss spawned in ${district}!`);
                }
                console.log(`[WorldBossSystem] Spawned boss in ${district}`);

                return bossState;
            }

            // Update boss AI
            update(deltaTime) {
                // Update spawn timer
                this.spawnTimer += deltaTime * 1000; // Convert to milliseconds
                if (this.spawnTimer >= this.spawnInterval && this.activeBosses.length === 0) {
                    this.spawnWorldBoss();
                    this.spawnTimer = 0;
                    this.lastSpawnTime = Date.now();
                }

                // Update active bosses
                for (let i = this.activeBosses.length - 1; i >= 0; i--) {
                    const boss = this.activeBosses[i];
                    if (boss.health <= 0) {
                        this.defeatBoss(boss.id);
                        this.activeBosses.splice(i, 1);
                    }
                }
            }

            // Defeat boss
            defeatBoss(bossId) {
                const boss = this.activeBosses.find(b => b.id === bossId);
                if (!boss) return;

                boss.defeated = true;
                if (boss.mesh && boss.mesh.parent) {
                    this.scene.remove(boss.mesh);
                }

                // Remove from NPCs
                const npcIndex = gameState.npcs.findIndex(n => n.id === bossId);
                if (npcIndex !== -1) {
                    gameState.npcs.splice(npcIndex, 1);
                }

                // Show notification
                if (window.BagSystem) {
                    window.BagSystem.showToast('✅ World Boss defeated!');
                }
                console.log(`[WorldBossSystem] Boss ${bossId} defeated`);
            }
        }

        // ═══════════════════════════════════════════════════════════════════════════
        // INTERIOR SYSTEM - Handles building interiors and teleportation
        // ═══════════════════════════════════════════════════════════════════════════
        class InteriorSystem {
            constructor(THREE, scene) {
                this.THREE = THREE;
                this.scene = scene;
                this.interiorScene = null;
                this.isInInterior = false;
                this.currentBuilding = null;
                this.savedExteriorPosition = null;
                this.interiorOffset = -500; // Y offset for interior location
            }

            // Generate interior geometry for a building
            generateInterior(buildingData) {
                const interiorGroup = new THREE.Group();
                const floorSize = Math.max(buildingData.size.width, buildingData.size.depth);
                
                // Floor
                const floorGeometry = new THREE.PlaneGeometry(floorSize, floorSize);
                const floorMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x654321,
                    roughness: 0.8
                });
                const floor = new THREE.Mesh(floorGeometry, floorMaterial);
                floor.rotation.x = -Math.PI / 2;
                floor.position.y = this.interiorOffset;
                floor.receiveShadow = true;
                interiorGroup.add(floor);

                // Walls
                const wallHeight = buildingData.size.height * 0.8;
                const wallMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xcccccc,
                    roughness: 0.6
                });
                
                // Front wall (with door opening)
                const frontWallGeometry = new THREE.BoxGeometry(floorSize, wallHeight, 0.2);
                const frontWall = new THREE.Mesh(frontWallGeometry, wallMaterial);
                frontWall.position.set(0, this.interiorOffset + wallHeight / 2, -floorSize / 2);
                frontWall.castShadow = true;
                interiorGroup.add(frontWall);

                // Back wall
                const backWall = new THREE.Mesh(frontWallGeometry, wallMaterial);
                backWall.position.set(0, this.interiorOffset + wallHeight / 2, floorSize / 2);
                backWall.castShadow = true;
                interiorGroup.add(backWall);

                // Side walls
                const sideWallGeometry = new THREE.BoxGeometry(0.2, wallHeight, floorSize);
                const leftWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
                leftWall.position.set(-floorSize / 2, this.interiorOffset + wallHeight / 2, 0);
                leftWall.castShadow = true;
                interiorGroup.add(leftWall);

                const rightWall = new THREE.Mesh(sideWallGeometry, wallMaterial);
                rightWall.position.set(floorSize / 2, this.interiorOffset + wallHeight / 2, 0);
                rightWall.castShadow = true;
                interiorGroup.add(rightWall);

                // Ceiling
                const ceilingGeometry = new THREE.PlaneGeometry(floorSize, floorSize);
                const ceilingMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0xffffff,
                    roughness: 0.4
                });
                const ceiling = new THREE.Mesh(ceilingGeometry, ceilingMaterial);
                ceiling.rotation.x = Math.PI / 2;
                ceiling.position.y = this.interiorOffset + wallHeight;
                ceiling.receiveShadow = true;
                interiorGroup.add(ceiling);

                // Interior lighting
                const interiorLight = new THREE.PointLight(0xffffff, 1.0, 50);
                interiorLight.position.set(0, this.interiorOffset + wallHeight / 2, 0);
                interiorGroup.add(interiorLight);

                // Add exit door (red, highly visible)
                const exitDoorGeo = new THREE.PlaneGeometry(4, 7);
                const exitDoorMat = new THREE.MeshBasicMaterial({ 
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.8,
                    transparent: true,
                    opacity: 0.9
                });
                const exitDoor = new THREE.Mesh(exitDoorGeo, exitDoorMat);
                exitDoor.position.set(0, this.interiorOffset + 3.5, floorSize / 2 - 0.1);
                exitDoor.rotation.y = Math.PI; // Face inside
                exitDoor.userData.isExitDoor = true;
                exitDoor.userData.buildingData = buildingData;
                interiorGroup.add(exitDoor);

                // Store exit door reference for interaction
                buildingData.exitDoor = exitDoor;
                buildingData.exitDoorPosition = exitDoor.position.clone();

                // Add some interior objects based on building type
                this.addInteriorFurniture(interiorGroup, buildingData.type, floorSize, wallHeight);

                return interiorGroup;
            }

            // Add furniture and objects to interior based on building type
            addInteriorFurniture(group, buildingType, floorSize, wallHeight) {
                const furnitureMaterial = new THREE.MeshStandardMaterial({ 
                    color: 0x8B4513,
                    roughness: 0.7
                });
                const metalMaterial = new THREE.MeshStandardMaterial({
                    color: 0x666666,
                    metalness: 0.8,
                    roughness: 0.2
                });

                if (buildingType === 'shop') {
                    // Shop: Add counter and shelves
                    const counterGeometry = new THREE.BoxGeometry(floorSize * 0.6, 1, 0.5);
                    const counter = new THREE.Mesh(counterGeometry, furnitureMaterial);
                    counter.position.set(0, this.interiorOffset + 0.5, floorSize * 0.3);
                    counter.castShadow = true;
                    group.add(counter);
                    
                    // Shelves on back wall
                    for (let i = 0; i < 3; i++) {
                        const shelfGeo = new THREE.BoxGeometry(floorSize * 0.4, 0.2, 0.3);
                        const shelf = new THREE.Mesh(shelfGeo, furnitureMaterial);
                        shelf.position.set(-floorSize * 0.3 + i * (floorSize * 0.3), this.interiorOffset + 2 + i * 1.5, -floorSize * 0.4);
                        shelf.castShadow = true;
                        group.add(shelf);
                    }
                } else if (buildingType === 'residential' || buildingType === 'apartment') {
                    // Residential: Add table, chairs, and bed
                    const tableGeometry = new THREE.BoxGeometry(2, 0.1, 2);
                    const table = new THREE.Mesh(tableGeometry, furnitureMaterial);
                    table.position.set(0, this.interiorOffset + 0.5, 0);
                    table.castShadow = true;
                    group.add(table);
                    
                    // Chairs around table
                    for (let i = 0; i < 4; i++) {
                        const angle = (i / 4) * Math.PI * 2;
                        const chairGeo = new THREE.BoxGeometry(0.5, 1, 0.5);
                        const chair = new THREE.Mesh(chairGeo, furnitureMaterial);
                        chair.position.set(
                            Math.cos(angle) * 1.5,
                            this.interiorOffset + 0.5,
                            Math.sin(angle) * 1.5
                        );
                        chair.castShadow = true;
                        group.add(chair);
                    }
                    
                    // Bed
                    const bedGeo = new THREE.BoxGeometry(3, 0.5, 2);
                    const bed = new THREE.Mesh(bedGeo, furnitureMaterial);
                    bed.position.set(-floorSize * 0.3, this.interiorOffset + 0.25, floorSize * 0.3);
                    bed.castShadow = true;
                    group.add(bed);
                } else if (buildingType === 'office') {
                    // Office: Add desk, chair, and filing cabinets
                    const deskGeometry = new THREE.BoxGeometry(3, 0.8, 1.5);
                    const desk = new THREE.Mesh(deskGeometry, furnitureMaterial);
                    desk.position.set(0, this.interiorOffset + 0.4, -floorSize * 0.3);
                    desk.castShadow = true;
                    group.add(desk);
                    
                    // Office chair
                    const chairGeo = new THREE.CylinderGeometry(0.4, 0.4, 1, 8);
                    const chair = new THREE.Mesh(chairGeo, metalMaterial);
                    chair.position.set(0, this.interiorOffset + 0.5, -floorSize * 0.1);
                    chair.castShadow = true;
                    group.add(chair);
                    
                    // Filing cabinets
                    for (let i = 0; i < 2; i++) {
                        const cabinetGeo = new THREE.BoxGeometry(0.8, 1.5, 0.6);
                        const cabinet = new THREE.Mesh(cabinetGeo, metalMaterial);
                        cabinet.position.set(-floorSize * 0.35 + i * 1.5, this.interiorOffset + 0.75, floorSize * 0.3);
                        cabinet.castShadow = true;
                        group.add(cabinet);
                    }
                } else if (buildingType === 'warehouse') {
                    // Warehouse: Add crates and storage
                    for (let i = 0; i < 6; i++) {
                        const crateGeo = new THREE.BoxGeometry(1.5, 1.5, 1.5);
                        const crate = new THREE.Mesh(crateGeo, furnitureMaterial);
                        crate.position.set(
                            -floorSize * 0.3 + (i % 3) * 2,
                            this.interiorOffset + 0.75,
                            -floorSize * 0.3 + Math.floor(i / 3) * 2
                        );
                        crate.castShadow = true;
                        group.add(crate);
                    }
                }
            }

            // Enter a building interior
            enterBuilding(buildingData) {
                if (this.isInInterior) {
                    console.warn('[InteriorSystem] Already in an interior');
                    return;
                }

                if (!buildingData.hasInterior) {
                    console.warn('[InteriorSystem] Building has no interior');
                    return;
                }

                // Save exterior position
                if (gameState.activeCharacter && gameState.activeCharacter.mesh) {
                    this.savedExteriorPosition = gameState.activeCharacter.mesh.position.clone();
                }

                // Generate or get interior
                if (!buildingData.interiorMesh) {
                    buildingData.interiorMesh = this.generateInterior(buildingData);
                }
                this.interiorScene = buildingData.interiorMesh;
                this.scene.add(this.interiorScene);

                // Teleport player to interior
                if (gameState.activeCharacter && gameState.activeCharacter.mesh) {
                    gameState.activeCharacter.mesh.position.set(
                        buildingData.position.x,
                        this.interiorOffset + 1.7,
                        buildingData.position.z
                    );
                }

                this.isInInterior = true;
                this.currentBuilding = buildingData;

                // Open shop if it's a shop building
                if (buildingData.type === 'shop' && window.ShopSystem) {
                    setTimeout(() => {
                        window.ShopSystem.openShop(buildingData.id, buildingData.type);
                    }, 500);
                }

                // Show notification
                if (window.BagSystem) {
                    window.BagSystem.showToast(`🏠 Entered ${buildingData.type} building`);
                }
                console.log(`[InteriorSystem] Entered building: ${buildingData.id}`);
            }

            // Exit building interior
            exitBuilding() {
                if (!this.isInInterior) {
                    console.warn('[InteriorSystem] Not in an interior');
                    return;
                }

                // Close door when exiting
                if (this.currentBuilding && gameState.doorTriggers) {
                    const doorTrigger = gameState.doorTriggers.find(dt => dt.buildingId === this.currentBuilding.id);
                    if (doorTrigger && doorTrigger.doorMesh && doorTrigger.doorMesh.userData.animationState) {
                        const animState = doorTrigger.doorMesh.userData.animationState;
                        if (!animState.isAnimating) {
                            animState.isAnimating = true;
                            animState.isOpen = false;
                            animState.targetRotation = 0; // Close door
                        }
                    }
                }

                // Remove interior from scene
                if (this.interiorScene) {
                    this.scene.remove(this.interiorScene);
                    this.interiorScene = null;
                }

                // Restore exterior position (offset slightly to avoid spawning in door)
                if (this.savedExteriorPosition && gameState.activeCharacter && gameState.activeCharacter.mesh) {
                    const exitPos = this.savedExteriorPosition.clone();
                    // Offset slightly forward from door
                    exitPos.z += 3;
                    gameState.activeCharacter.mesh.position.copy(exitPos);
                }

                // Close shop if open
                if (window.ShopSystem) {
                    window.ShopSystem.closeShop();
                }

                // Close shop if open
                if (window.ShopSystem) {
                    window.ShopSystem.closeShop();
                }

                this.isInInterior = false;
                this.currentBuilding = null;
                this.savedExteriorPosition = null;

                // Show notification
                if (window.BagSystem) {
                    window.BagSystem.showToast('🚪 Exited building');
                }
                console.log('[InteriorSystem] Exited building');
            }
        }

        // ═══════════════════════════════════════════════════════════════════════════
        // NPC BUILDING BEHAVIOR SYSTEM - NPCs entering/exiting buildings
        // ═══════════════════════════════════════════════════════════════════════════
        class NPCBuildingBehavior {
            constructor(THREE, scene) {
                this.THREE = THREE;
                this.scene = scene;
                this.npcBuildingVisits = new Map(); // NPC ID -> building visit data
            }

            /**
             * Initialize building behavior for an NPC
             */
            initNPCBehavior(npc) {
                if (!npc || !npc.mesh) return;
                
                // Only civilians visit buildings (not heroes/villains in combat)
                if (npc.type !== 'civilian') return;
                
                // Add building visit state
                npc.buildingBehavior = {
                    state: 'wandering', // 'wandering', 'goingToBuilding', 'entering', 'inside', 'exiting'
                    targetBuilding: null,
                    targetDoor: null,
                    insideTimer: 0,
                    visitDuration: 30 + Math.random() * 90, // 30-120 seconds inside
                    nextVisitTimer: 60 + Math.random() * 120, // Wait 60-180 seconds before next visit
                    lastVisitTime: 0
                };
            }

            /**
             * Update NPC building behavior
             */
            updateNPCBehavior(npc, deltaTime) {
                if (!npc || !npc.buildingBehavior || npc.type !== 'civilian') return;
                if (npc.health <= 0 || npc.state === 'dying') return; // Don't visit buildings when dead
                
                const behavior = npc.buildingBehavior;
                
                switch (behavior.state) {
                    case 'wandering':
                        // Check if it's time to visit a building
                        behavior.nextVisitTimer -= deltaTime;
                        if (behavior.nextVisitTimer <= 0 && gameState.buildings && gameState.buildings.length > 0) {
                            // Find a random building with interior
                            const buildingsWithInteriors = gameState.buildings.filter(b => b.hasInterior && !b.isDestroyed);
                            if (buildingsWithInteriors.length > 0) {
                                behavior.targetBuilding = buildingsWithInteriors[Math.floor(Math.random() * buildingsWithInteriors.length)];
                                
                                // Find door for this building
                                if (gameState.doorTriggers) {
                                    behavior.targetDoor = gameState.doorTriggers.find(dt => dt.buildingId === behavior.targetBuilding.id);
                                }
                                
                                if (behavior.targetDoor) {
                                    behavior.state = 'goingToBuilding';
                                }
                            }
                        }
                        break;
                        
                    case 'goingToBuilding':
                        if (!behavior.targetDoor || !behavior.targetDoor.position) {
                            behavior.state = 'wandering';
                            behavior.nextVisitTimer = 60 + Math.random() * 120;
                            break;
                        }
                        
                        // Move towards door
                        const doorPos = behavior.targetDoor.position;
                        const npcPos = npc.mesh.position;
                        const distanceToDoor = npcPos.distanceTo(doorPos);
                        
                        if (distanceToDoor < 3.0) {
                            // Reached door, wait a moment then enter
                            behavior.state = 'entering';
                            behavior.enterTimer = 1.0; // Wait 1 second at door
                        } else {
                            // Move towards door
                            const direction = new THREE.Vector3()
                                .subVectors(doorPos, npcPos)
                                .normalize();
                            const moveSpeed = 2.0; // NPCs move slower than player
                            npc.mesh.position.add(direction.multiplyScalar(moveSpeed * deltaTime));
                            npc.mesh.lookAt(doorPos);
                        }
                        break;
                        
                    case 'entering':
                        behavior.enterTimer -= deltaTime;
                        if (behavior.enterTimer <= 0) {
                            // Hide NPC (they're inside)
                            npc.mesh.visible = false;
                            behavior.state = 'inside';
                            behavior.insideTimer = behavior.visitDuration;
                            
                            // Store visit data
                            this.npcBuildingVisits.set(npc.mesh.uuid, {
                                npc: npc,
                                building: behavior.targetBuilding,
                                enterTime: Date.now()
                            });
                        }
                        break;
                        
                    case 'inside':
                        behavior.insideTimer -= deltaTime;
                        if (behavior.insideTimer <= 0) {
                            // Time to exit
                            behavior.state = 'exiting';
                            // Show NPC at door position
                            if (behavior.targetDoor && behavior.targetDoor.position) {
                                npc.mesh.position.copy(behavior.targetDoor.position);
                                npc.mesh.position.z += 2; // Slightly in front of door
                                npc.mesh.visible = true;
                            }
                            behavior.exitTimer = 1.0; // Wait 1 second before moving away
                        }
                        break;
                        
                    case 'exiting':
                        behavior.exitTimer -= deltaTime;
                        if (behavior.exitTimer <= 0) {
                            // Move away from door and resume wandering
                            behavior.state = 'wandering';
                            behavior.targetBuilding = null;
                            behavior.targetDoor = null;
                            behavior.lastVisitTime = Date.now();
                            behavior.nextVisitTimer = 60 + Math.random() * 120;
                            
                            // Remove visit data
                            this.npcBuildingVisits.delete(npc.mesh.uuid);
                        }
                        break;
                }
            }

            /**
             * Get NPCs currently inside a building
             */
            getNPCsInBuilding(buildingId) {
                const npcsInside = [];
                this.npcBuildingVisits.forEach((visitData, npcId) => {
                    if (visitData.building && visitData.building.id === buildingId) {
                        npcsInside.push(visitData.npc);
                    }
                });
                return npcsInside;
            }
        }

        // ═══════════════════════════════════════════════════════════════════════════
        // SHOP SYSTEM - Buy/sell items in buildings
        // ═══════════════════════════════════════════════════════════════════════════
        class ShopSystem {
            constructor(THREE, scene) {
                this.THREE = THREE;
                this.scene = scene;
                this.shopInventories = {}; // buildingId -> inventory array
                this.currentShop = null;
                this.shopUI = null;
                this.shopkeeperNPCs = new Map(); // buildingId -> shopkeeper NPC
            }

            /**
             * Generate shop inventory based on building type
             */
            generateShopInventory(buildingId, buildingType) {
                if (this.shopInventories[buildingId]) {
                    return this.shopInventories[buildingId]; // Already generated
                }

                const inventory = [];
                
                // Get items from GEAR_MANIFEST (if available)
                const gearManifest = (typeof GEAR_MANIFEST !== 'undefined' ? GEAR_MANIFEST : []) || window.GEAR_MANIFEST || [];
                
                switch (buildingType) {
                    case 'shop':
                        // General store: Basic gear and consumables
                        const basicGear = gearManifest.filter(item => 
                            item.rarity === 'common' && item.levelReq <= 10
                        );
                        inventory.push(...basicGear.slice(0, 8)); // 8 random basic items
                        // Add consumables
                        inventory.push(
                            { id: 'potion_health', name: 'Health Potion', icon: '🧪', price: 50, type: 'consumable' },
                            { id: 'potion_mana', name: 'Mana Potion', icon: '💧', price: 50, type: 'consumable' },
                            { id: 'food_bread', name: 'Bread', icon: '🍞', price: 10, type: 'consumable' }
                        );
                        break;
                        
                    case 'warehouse':
                        // Warehouse: Materials and resources
                        const resources = [
                            { id: 'res_scrap', name: 'Scrap Metal', icon: '🔩', price: 5, type: 'material' },
                            { id: 'res_wood', name: 'Synth-Wood', icon: '🪵', price: 3, type: 'material' },
                            { id: 'res_stone', name: 'Concrete Chunk', icon: '🪨', price: 4, type: 'material' },
                            { id: 'res_circuit', name: 'Fried Circuit', icon: '📟', price: 15, type: 'material' }
                        ];
                        inventory.push(...resources);
                        break;
                        
                    case 'office':
                        // Office: Premium gear
                        const premiumGear = gearManifest.filter(item => 
                            (item.rarity === 'rare' || item.rarity === 'legendary') && item.levelReq <= 30
                        );
                        inventory.push(...premiumGear.slice(0, 6)); // 6 premium items
                        break;
                        
                    default:
                        // Default: Mix of items
                        const defaultGear = gearManifest.filter(item => item.rarity === 'common');
                        inventory.push(...defaultGear.slice(0, 5));
                        break;
                }
                
                this.shopInventories[buildingId] = inventory;
                return inventory;
            }

            /**
             * Create shopkeeper NPC in shop interior
             */
            createShopkeeper(buildingId, position) {
                const shopkeeperGeo = new THREE.CapsuleGeometry(0.6, 1.0, 4, 8);
                const shopkeeperMat = new THREE.MeshStandardMaterial({
                    color: 0x4a90e2,
                    emissive: 0x1a3a5a,
                    emissiveIntensity: 0.3
                });
                const shopkeeper = new THREE.Mesh(shopkeeperGeo, shopkeeperMat);
                shopkeeper.position.copy(position);
                shopkeeper.position.y = 1.0;
                shopkeeper.castShadow = true;
                
                this.scene.add(shopkeeper);
                this.shopkeeperNPCs.set(buildingId, shopkeeper);
                
                return shopkeeper;
            }

            /**
             * Open shop UI
             */
            openShop(buildingId, buildingType) {
                this.currentShop = { id: buildingId, type: buildingType };
                const inventory = this.generateShopInventory(buildingId, buildingType);
                this.showShopUI(inventory);
            }

            /**
             * Show shop UI overlay
             */
            showShopUI(shopInventory) {
                // Remove existing UI if present
                if (this.shopUI) {
                    this.shopUI.remove();
                }

                const shopDiv = document.createElement('div');
                shopDiv.id = 'shop-ui';
                shopDiv.style.cssText = `
                    position: fixed;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    width: 800px;
                    max-height: 600px;
                    background: rgba(20, 20, 30, 0.95);
                    border: 3px solid #4a90e2;
                    border-radius: 12px;
                    padding: 20px;
                    z-index: 2000;
                    color: #fff;
                    font-family: monospace;
                    overflow-y: auto;
                `;

                let html = '<h2 style="margin-top: 0; color: #4a90e2;">🏪 Shop</h2>';
                html += '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">';
                
                // Shop inventory
                html += '<div><h3>Items for Sale</h3><div id="shop-items" style="display: grid; gap: 10px;">';
                shopInventory.forEach((item, index) => {
                    const price = item.price || 100;
                    html += `
                        <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <span style="font-size: 20px;">${item.icon || '📦'}</span>
                                <strong>${item.name || item.id}</strong>
                                <div style="font-size: 12px; color: #aaa;">${item.description || ''}</div>
                            </div>
                            <div>
                                <div style="color: #FFD700;">${price} Gold</div>
                                <button onclick="window.ShopSystem.buyItem(${index})" style="margin-top: 5px; padding: 5px 15px; background: #4a90e2; color: white; border: none; border-radius: 4px; cursor: pointer;">Buy</button>
                            </div>
                        </div>
                    `;
                });
                html += '</div></div>';

                // Player inventory (for selling)
                html += '<div><h3>Your Inventory</h3><div id="player-items" style="display: grid; gap: 10px; max-height: 400px; overflow-y: auto;">';
                if (window.gameState && window.gameState.inventory) {
                    const playerItems = window.gameState.inventory.items || [];
                    playerItems.forEach((item, index) => {
                        const sellPrice = Math.floor((item.price || 50) * 0.5); // 50% sell price
                        html += `
                            <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 6px; display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <span style="font-size: 20px;">${item.icon || '📦'}</span>
                                    <strong>${item.name || item.id}</strong>
                                    <div style="font-size: 12px; color: #aaa;">Qty: ${item.quantity || 1}</div>
                                </div>
                                <div>
                                    <div style="color: #FFD700;">${sellPrice} Gold</div>
                                    <button onclick="window.ShopSystem.sellItem(${index})" style="margin-top: 5px; padding: 5px 15px; background: #e24a4a; color: white; border: none; border-radius: 4px; cursor: pointer;">Sell</button>
                                </div>
                            </div>
                        `;
                    });
                }
                html += '</div></div>';

                html += '</div>';
                html += '<button onclick="window.ShopSystem.closeShop()" style="margin-top: 20px; padding: 10px 20px; background: #666; color: white; border: none; border-radius: 4px; cursor: pointer; width: 100%;">Close</button>';

                shopDiv.innerHTML = html;
                document.body.appendChild(shopDiv);
                this.shopUI = shopDiv;
            }

            /**
             * Buy item from shop
             */
            buyItem(itemIndex) {
                if (!this.currentShop) return;
                const inventory = this.shopInventories[this.currentShop.id];
                if (!inventory || !inventory[itemIndex]) return;

                const item = inventory[itemIndex];
                const price = item.price || 100;

                if (!window.gameState || !window.gameState.gold || window.gameState.gold < price) {
                    if (window.BagSystem) {
                        window.BagSystem.showToast('Not enough gold!');
                    }
                    return;
                }

                // Deduct gold
                window.gameState.gold -= price;

                // Add to inventory
                if (!window.gameState.inventory) window.gameState.inventory = {};
                if (!window.gameState.inventory.items) window.gameState.inventory.items = [];

                const existingItem = window.gameState.inventory.items.find(i => i.id === item.id);
                if (existingItem) {
                    existingItem.quantity = (existingItem.quantity || 1) + 1;
                } else {
                    window.gameState.inventory.items.push({
                        ...item,
                        quantity: 1
                    });
                }

                if (window.BagSystem) {
                    window.BagSystem.showToast(`Bought ${item.name || item.id} for ${price} gold!`);
                    if (window.BagSystem.isOpen) {
                        window.BagSystem.renderCurrencies();
                    }
                }

                // Refresh UI
                this.showShopUI(inventory);
            }

            /**
             * Sell item to shop
             */
            sellItem(itemIndex) {
                if (!window.gameState || !window.gameState.inventory || !window.gameState.inventory.items) return;
                const items = window.gameState.inventory.items;
                if (!items[itemIndex]) return;

                const item = items[itemIndex];
                const sellPrice = Math.floor((item.price || 50) * 0.5);

                // Add gold
                if (!window.gameState.gold) window.gameState.gold = 0;
                window.gameState.gold += sellPrice;

                // Remove item
                if (item.quantity > 1) {
                    item.quantity--;
                } else {
                    items.splice(itemIndex, 1);
                }

                if (window.BagSystem) {
                    window.BagSystem.showToast(`Sold ${item.name || item.id} for ${sellPrice} gold!`);
                    if (window.BagSystem.isOpen) {
                        window.BagSystem.renderCurrencies();
                    }
                }

                // Refresh UI
                if (this.currentShop) {
                    const inventory = this.shopInventories[this.currentShop.id];
                    this.showShopUI(inventory);
                }
            }

            /**
             * Close shop UI
             */
            closeShop() {
                if (this.shopUI) {
                    this.shopUI.remove();
                    this.shopUI = null;
                }
                this.currentShop = null;
            }
        }

        // ═══════════════════════════════════════════════════════════════════════════
        // QUEST SYSTEM - Fetch/kill/delivery quests
        // ═══════════════════════════════════════════════════════════════════════════
        class QuestSystem {
            constructor() {
                this.quests = []; // Active quests
                this.completedQuests = []; // Completed quests
                this.questGivers = new Map(); // buildingId -> quest giver data
            }

            createQuest(type, title, description, target, reward) {
                return {
                    id: `quest_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
                    type: type, // 'fetch', 'kill', 'delivery'
                    title: title,
                    description: description,
                    target: target,
                    reward: reward,
                    progress: 0,
                    targetAmount: target.amount || 1,
                    status: 'available' // 'available', 'active', 'completed'
                };
            }

            addQuestGiver(buildingId, quests) {
                this.questGivers.set(buildingId, { quests: quests, npc: null });
            }

            acceptQuest(questId) {
                const quest = this.quests.find(q => q.id === questId);
                if (quest) {
                    quest.status = 'active';
                    if (!gameState.activeQuests) gameState.activeQuests = [];
                    gameState.activeQuests.push(quest);
                    if (window.BagSystem) {
                        window.BagSystem.showToast(`Quest accepted: ${quest.title}`);
                    }
                }
            }

            updateQuestProgress(questId, amount = 1) {
                const quest = gameState.activeQuests?.find(q => q.id === questId);
                if (!quest) return;
                quest.progress += amount;
                if (quest.progress >= quest.targetAmount) {
                    this.completeQuest(questId);
                }
            }

            completeQuest(questId) {
                const quest = gameState.activeQuests?.find(q => q.id === questId);
                if (!quest) return;
                quest.status = 'completed';
                // Give rewards
                if (quest.reward.gold) {
                    if (!gameState.gold) gameState.gold = 0;
                    gameState.gold += quest.reward.gold;
                }
                if (quest.reward.xp && PlayerState) {
                    PlayerState.gainXP(quest.reward.xp);
                }
                // Move to completed
                gameState.activeQuests = gameState.activeQuests.filter(q => q.id !== questId);
                if (!gameState.completedQuests) gameState.completedQuests = [];
                gameState.completedQuests.push(quest);
                if (window.BagSystem) {
                    window.BagSystem.showToast(`Quest completed: ${quest.title}! +${quest.reward.gold || 0} Gold`);
                }
            }
        }

        // ═══════════════════════════════════════════════════════════════════════════
        // BUILDING UPGRADE SYSTEM
        // ═══════════════════════════════════════════════════════════════════════════
        class BuildingUpgradeSystem {
            upgradeBuilding(buildingId, level) {
                if (!gameState.buildings) return false;
                const building = gameState.buildings.find(b => b.id === buildingId);
                if (!building) return false;
                building.upgradeLevel = level;
                // Visual upgrades would be applied here
                return true;
            }

            getUpgradeCost(buildingId, targetLevel) {
                return targetLevel * 1000; // 1000 gold per level
            }
        }

        // ═══════════════════════════════════════════════════════════════════════════
        // DAY/NIGHT CYCLE SYSTEM
        // ═══════════════════════════════════════════════════════════════════════════
        class DayNightCycleSystem {
            constructor(scene) {
                this.scene = scene;
                this.timeOfDay = 12.0; // 0-24 hours, start at noon
                this.timeSpeed = 0.1; // 1 hour = 0.1 real seconds
            }

            update(deltaTime) {
                this.timeOfDay += this.timeSpeed * deltaTime;
                if (this.timeOfDay >= 24) this.timeOfDay -= 24;
                if (gameState) gameState.timeOfDay = this.timeOfDay;
                this.updateLighting();
            }

            updateLighting() {
                const isNight = this.timeOfDay < 6 || this.timeOfDay > 18;
                // Update window materials to glow at night
                if (gameState.buildings) {
                    gameState.buildings.forEach(building => {
                        // Window glow logic would go here
                    });
                }
            }
        }

        // ═══════════════════════════════════════════════════════════════════════════
        // BUILDING OWNERSHIP SYSTEM
        // ═══════════════════════════════════════════════════════════════════════════
        class BuildingOwnershipSystem {
            purchaseBuilding(buildingId, price) {
                if (!gameState.gold || gameState.gold < price) return false;
                if (!gameState.ownedBuildings) gameState.ownedBuildings = {};
                gameState.gold -= price;
                gameState.ownedBuildings[buildingId] = {
                    purchaseDate: Date.now(),
                    income: 0
                };
                return true;
            }

            generateIncome(deltaTime) {
                if (!gameState.ownedBuildings) return;
                Object.keys(gameState.ownedBuildings).forEach(buildingId => {
                    const owned = gameState.ownedBuildings[buildingId];
                    owned.income += deltaTime * 0.1; // Generate income over time
                    if (owned.income >= 100) {
                        gameState.gold += 100;
                        owned.income -= 100;
                    }
                });
            }
        }

        // ═══════════════════════════════════════════════════════════════════════════
        // BUILDING CUSTOMIZATION SYSTEM
        // ═══════════════════════════════════════════════════════════════════════════
        class BuildingCustomizationSystem {
            customizeBuilding(buildingId, customization) {
                if (!gameState.buildingCustomizations) gameState.buildingCustomizations = {};
                gameState.buildingCustomizations[buildingId] = customization;
            }

            getCustomization(buildingId) {
                return gameState.buildingCustomizations?.[buildingId] || null;
            }
        }

        // ═══════════════════════════════════════════════════════════════════════════
        // BUILDING EVENT SYSTEM
        // ═══════════════════════════════════════════════════════════════════════════
        class BuildingEventSystem {
            constructor(scene) {
                this.scene = scene;
                this.activeEvents = [];
            }

            triggerEvent(buildingId, eventType) {
                const event = {
                    id: `event_${Date.now()}`,
                    buildingId: buildingId,
                    type: eventType,
                    duration: 30,
                    rewards: { gold: 50, items: [] }
                };
                this.activeEvents.push(event);
                if (!gameState.activeBuildingEvents) gameState.activeBuildingEvents = [];
                gameState.activeBuildingEvents.push(event);
                return event;
            }

            update(deltaTime) {
                this.activeEvents.forEach(event => {
                    event.duration -= deltaTime;
                    if (event.duration <= 0) {
                        this.completeEvent(event.id);
                    }
                });
            }

            completeEvent(eventId) {
                const event = this.activeEvents.find(e => e.id === eventId);
                if (event) {
                    if (gameState.gold) gameState.gold += event.rewards.gold;
                    this.activeEvents = this.activeEvents.filter(e => e.id !== eventId);
                    if (gameState.activeBuildingEvents) {
                        gameState.activeBuildingEvents = gameState.activeBuildingEvents.filter(e => e.id !== eventId);
                    }
                }
            }
        }

        // ═══════════════════════════════════════════════════════════════════════════
        // BUILDING REPUTATION SYSTEM
        // ═══════════════════════════════════════════════════════════════════════════
        class BuildingReputationSystem {
            constructor() {
                if (!gameState.buildingReputation) {
                    gameState.buildingReputation = {};
                }
            }

            adjustReputation(buildingType, amount) {
                if (!gameState.buildingReputation[buildingType]) {
                    gameState.buildingReputation[buildingType] = 0;
                }
                gameState.buildingReputation[buildingType] += amount;
                gameState.buildingReputation[buildingType] = Math.max(-100, Math.min(100, gameState.buildingReputation[buildingType]));
            }

            getReputation(buildingType) {
                return gameState.buildingReputation[buildingType] || 0;
            }

            getReputationLevel(buildingType) {
                const rep = this.getReputation(buildingType);
                if (rep >= 50) return 'loved';
                if (rep >= 0) return 'liked';
                if (rep >= -50) return 'disliked';
                return 'hated';
            }
        }

        // ═══════════════════════════════════════════════════════════════════════════
        // BUILDING UI SYSTEM - Nameplates and Icons
        // ═══════════════════════════════════════════════════════════════════════════
        class BuildingUISystem {
            constructor(THREE, scene, camera) {
                this.THREE = THREE;
                this.scene = scene;
                this.camera = camera;
                this.nameplates = [];
                this.icons = [];
            }

            /**
             * Create text sprite for building nameplate
             */
            createNameplate(text, position, buildingType) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                
                // Background
                context.fillStyle = 'rgba(0, 0, 0, 0.7)';
                context.fillRect(0, 0, canvas.width, canvas.height);
                
                // Border
                context.strokeStyle = '#ffffff';
                context.lineWidth = 2;
                context.strokeRect(0, 0, canvas.width, canvas.height);
                
                // Text
                context.fillStyle = '#ffffff';
                context.font = 'bold 24px Arial';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(text, canvas.width / 2, canvas.height / 2);
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                
                const spriteMaterial = new THREE.SpriteMaterial({
                    map: texture,
                    transparent: true,
                    alphaTest: 0.1
                });
                
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.copy(position);
                sprite.position.y += 5; // 5 units above door
                sprite.scale.set(4, 1, 1); // Scale to readable size
                
                this.scene.add(sprite);
                this.nameplates.push(sprite);
                
                return sprite;
            }

            /**
             * Create icon sprite for building type
             */
            createIcon(iconEmoji, position) {
                const canvas = document.createElement('canvas');
                const context = canvas.getContext('2d');
                canvas.width = 64;
                canvas.height = 64;
                
                // Background circle
                context.fillStyle = 'rgba(0, 0, 0, 0.6)';
                context.beginPath();
                context.arc(32, 32, 28, 0, Math.PI * 2);
                context.fill();
                
                // Border
                context.strokeStyle = '#ffffff';
                context.lineWidth = 2;
                context.stroke();
                
                // Icon emoji
                context.font = '40px Arial';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(iconEmoji, 32, 32);
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.needsUpdate = true;
                
                const spriteMaterial = new THREE.SpriteMaterial({
                    map: texture,
                    transparent: true,
                    alphaTest: 0.1
                });
                
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.position.copy(position);
                sprite.position.y += 6.5; // Above nameplate
                sprite.scale.set(1.5, 1.5, 1);
                
                this.scene.add(sprite);
                this.icons.push(sprite);
                
                return sprite;
            }

            /**
             * Update nameplates and icons to face camera
             */
            update() {
                if (!this.camera) return;
                
                // Make nameplates face camera
                this.nameplates.forEach(sprite => {
                    sprite.lookAt(this.camera.position);
                });
                
                // Make icons face camera
                this.icons.forEach(sprite => {
                    sprite.lookAt(this.camera.position);
                });
            }

            /**
             * Get building name based on type
             */
            getBuildingName(buildingType, buildingIndex) {
                const names = {
                    'shop': ['General Store', 'Market', 'Shop', 'Trading Post', 'Bazaar'],
                    'residential': ['Apartment', 'Residence', 'Home', 'Housing', 'Dwelling'],
                    'office': ['Office Building', 'Corporate Tower', 'Business Center', 'Tower', 'Skyscraper'],
                    'warehouse': ['Warehouse', 'Storage', 'Depot', 'Storage Facility', 'Distribution Center'],
                    'apartment': ['Apartment Complex', 'Residential Tower', 'Housing Block', 'Apartment Building', 'Residence']
                };
                
                const nameList = names[buildingType] || ['Building'];
                return nameList[buildingIndex % nameList.length];
            }

            /**
             * Get icon emoji for building type
             */
            getBuildingIcon(buildingType) {
                const icons = {
                    'shop': '🏪',
                    'residential': '🏠',
                    'office': '🏢',
                    'warehouse': '📦',
                    'apartment': '🏘️'
                };
                return icons[buildingType] || '🏛️';
            }
        }

        // ═══════════════════════════════════════════════════════════════════════════
        // BREACH SYSTEM - Procedural Dungeon Generation
        // ═══════════════════════════════════════════════════════════════════════════
        class BreachSystem {
            constructor(THREE, scene) {
                this.THREE = THREE;
                this.scene = scene;
                this.activeBreaches = [];
                this.breachOffset = -1000; // Y offset for breach locations
            }

            // Generate a procedural breach (dungeon)
            generateBreach(breachType = 'standard', difficulty = 1) {
                const breachGroup = new THREE.Group();
                const roomCount = 5 + Math.floor(difficulty * 2);
                const roomSize = 15;
                const corridorWidth = 3;
                const rooms = [];
                const corridors = [];

                // Generate rooms in a grid-like pattern
                for (let i = 0; i < roomCount; i++) {
                    const roomX = (i % 3) * (roomSize + 5);
                    const roomZ = Math.floor(i / 3) * (roomSize + 5);
                    
                    rooms.push({
                        x: roomX,
                        z: roomZ,
                        width: roomSize,
                        depth: roomSize
                    });
                }

                // Create room geometry
                rooms.forEach((room, index) => {
                    // Floor
                    const floorGeo = new THREE.PlaneGeometry(room.width, room.depth);
                    const floorMat = new THREE.MeshStandardMaterial({ 
                        color: 0x333333,
                        roughness: 0.9
                    });
                    const floor = new THREE.Mesh(floorGeo, floorMat);
                    floor.rotation.x = -Math.PI / 2;
                    floor.position.set(room.x, this.breachOffset, room.z);
                    floor.receiveShadow = true;
                    breachGroup.add(floor);

                    // Walls
                    const wallHeight = 8;
                    const wallMat = new THREE.MeshStandardMaterial({ 
                        color: 0x222222,
                        roughness: 0.8
                    });

                    // Front wall (with opening if not first room)
                    if (index > 0) {
                        const frontWallGeo = new THREE.BoxGeometry(room.width * 0.6, wallHeight, 0.2);
                        const frontWall = new THREE.Mesh(frontWallGeo, wallMat);
                        frontWall.position.set(room.x, this.breachOffset + wallHeight / 2, room.z - room.depth / 2);
                        breachGroup.add(frontWall);
                    }

                    // Back wall
                    const backWallGeo = new THREE.BoxGeometry(room.width, wallHeight, 0.2);
                    const backWall = new THREE.Mesh(backWallGeo, wallMat);
                    backWall.position.set(room.x, this.breachOffset + wallHeight / 2, room.z + room.depth / 2);
                    breachGroup.add(backWall);

                    // Side walls
                    const sideWallGeo = new THREE.BoxGeometry(0.2, wallHeight, room.depth);
                    const leftWall = new THREE.Mesh(sideWallGeo, wallMat);
                    leftWall.position.set(room.x - room.width / 2, this.breachOffset + wallHeight / 2, room.z);
                    breachGroup.add(leftWall);

                    const rightWall = new THREE.Mesh(sideWallGeo, wallMat);
                    rightWall.position.set(room.x + room.width / 2, this.breachOffset + wallHeight / 2, room.z);
                    breachGroup.add(rightWall);

                    // Ceiling
                    const ceilingGeo = new THREE.PlaneGeometry(room.width, room.depth);
                    const ceilingMat = new THREE.MeshStandardMaterial({ 
                        color: 0x111111,
                        roughness: 0.5
                    });
                    const ceiling = new THREE.Mesh(ceilingGeo, ceilingMat);
                    ceiling.rotation.x = Math.PI / 2;
                    ceiling.position.set(room.x, this.breachOffset + wallHeight, room.z);
                    breachGroup.add(ceiling);

                    // Lighting
                    const roomLight = new THREE.PointLight(0xff6600, 0.8, 30);
                    roomLight.position.set(room.x, this.breachOffset + wallHeight / 2, room.z);
                    breachGroup.add(roomLight);
                });

                // Create corridors between rooms
                for (let i = 0; i < rooms.length - 1; i++) {
                    const currentRoom = rooms[i];
                    const nextRoom = rooms[i + 1];
                    
                    const midX = (currentRoom.x + nextRoom.x) / 2;
                    const midZ = (currentRoom.z + nextRoom.z) / 2;
                    const corridorLength = Math.abs(nextRoom.x - currentRoom.x) + Math.abs(nextRoom.z - currentRoom.z);

                    // Corridor floor
                    const corridorFloorGeo = new THREE.PlaneGeometry(corridorWidth, corridorLength);
                    const corridorFloorMat = new THREE.MeshStandardMaterial({ 
                        color: 0x2a2a2a,
                        roughness: 0.9
                    });
                    const corridorFloor = new THREE.Mesh(corridorFloorGeo, corridorFloorMat);
                    corridorFloor.rotation.x = -Math.PI / 2;
                    corridorFloor.position.set(midX, this.breachOffset, midZ);
                    corridorFloor.receiveShadow = true;
                    breachGroup.add(corridorFloor);
                }

                // Add breach entrance portal (in main world)
                const entrancePortal = this.createBreachPortal(
                    THREE.MathUtils.randFloat(-WORLD_SIZE / 4, WORLD_SIZE / 4),
                    0,
                    THREE.MathUtils.randFloat(-WORLD_SIZE / 4, WORLD_SIZE / 4),
                    breachGroup
                );
                this.scene.add(entrancePortal);

                const breachData = {
                    id: `breach_${Date.now()}`,
                    type: breachType,
                    difficulty: difficulty,
                    mesh: breachGroup,
                    entrancePortal: entrancePortal,
                    rooms: rooms
                };

                this.activeBreaches.push(breachData);
                this.scene.add(breachGroup);

                return breachData;
            }

            // Create breach entrance portal in main world
            createBreachPortal(x, y, z, breachMesh) {
                const portalGroup = new THREE.Group();
                
                // Portal frame
                const frameGeo = new THREE.TorusGeometry(2, 0.3, 8, 16);
                const frameMat = new THREE.MeshStandardMaterial({ 
                    color: 0xff0000,
                    emissive: 0xff0000,
                    emissiveIntensity: 0.5
                });
                const frame = new THREE.Mesh(frameGeo, frameMat);
                frame.rotation.x = Math.PI / 2;
                portalGroup.add(frame);

                // Portal effect (glowing center)
                const portalCenterGeo = new THREE.CircleGeometry(1.5, 32);
                const portalCenterMat = new THREE.MeshBasicMaterial({ 
                    color: 0xff0000,
                    transparent: true,
                    opacity: 0.6
                });
                const portalCenter = new THREE.Mesh(portalCenterGeo, portalCenterMat);
                portalCenter.rotation.x = -Math.PI / 2;
                portalGroup.add(portalCenter);

                portalGroup.position.set(x, y + 1, z);
                portalGroup.userData.isBreachPortal = true;
                portalGroup.userData.breachMesh = breachMesh;

                return portalGroup;
            }

            // Enter breach (teleport player)
            enterBreach(breachData) {
                if (!gameState.activeCharacter || !gameState.activeCharacter.mesh) return;

                // Save exterior position
                if (!gameState.savedExteriorPosition) {
                    gameState.savedExteriorPosition = gameState.activeCharacter.mesh.position.clone();
                }

                // Teleport to first room
                if (breachData.rooms && breachData.rooms.length > 0) {
                    const firstRoom = breachData.rooms[0];
                    gameState.activeCharacter.mesh.position.set(
                        firstRoom.x,
                        this.breachOffset + 1.7,
                        firstRoom.z
                    );
                }

                // Apply breach environment
                this.applyBreachEnvironment(true);
            }

            // Exit breach
            exitBreach() {
                if (!gameState.activeCharacter || !gameState.activeCharacter.mesh) return;

                // Restore exterior position
                if (gameState.savedExteriorPosition) {
                    gameState.activeCharacter.mesh.position.copy(gameState.savedExteriorPosition);
                    gameState.savedExteriorPosition = null;
                }

                // Restore normal environment
                this.applyBreachEnvironment(false);
            }

            // Apply breach environment (red sky, fog, lighting)
            applyBreachEnvironment(isInBreach) {
                if (isInBreach) {
                    // Red sky
                    scene.background = new THREE.Color(0x330000);
                    // Red fog
                    scene.fog = new THREE.Fog(0x330000, 10, 50);
                    // Red ambient light
                    if (scene.children.find(c => c.type === 'AmbientLight')) {
                        const ambientLight = scene.children.find(c => c.type === 'AmbientLight');
                        ambientLight.color.set(0xff3333);
                        ambientLight.intensity = 0.5;
                    }
                } else {
                    // Restore normal sky
                    scene.background = new THREE.Color(0x87ceeb);
                    // Normal fog
                    scene.fog = new THREE.Fog(0x87ceeb, 100, WORLD_SIZE / 1.5);
                    // Normal ambient light
                    if (scene.children.find(c => c.type === 'AmbientLight')) {
                        const ambientLight = scene.children.find(c => c.type === 'AmbientLight');
                        ambientLight.color.set(0xffffff);
                        ambientLight.intensity = 0.7;
                    }
                }
            }
        }

        function createNature() {
            if (!window.destructibleSystem) return;

            // Create destructible Trees and Rocks instead of static meshes
            for (let i = 0; i < 150; i++) {
                const x = THREE.MathUtils.randFloat(-WORLD_SIZE / 2, WORLD_SIZE / 2);
                const z = THREE.MathUtils.randFloat(-WORLD_SIZE / 2, WORLD_SIZE / 2);

                // Avoid city center
                if (Math.abs(x) < WORLD_SIZE / 4 && Math.abs(z) < WORLD_SIZE / 4) continue;

                // 70% chance Tree, 30% chance Rock
                const type = Math.random() > 0.3 ? 'tree' : 'rock';

                // Calculate terrain height (Copying existing terrain logic)
                let y = Math.sin(x * 0.05) * Math.cos(z * 0.05) * 4;
                y += Math.sin(x * 0.01) * Math.cos(z * 0.01) * 8;

                // Adjust Y offset based on object type
                const pos = new THREE.Vector3(x, y, z);
                window.destructibleSystem.createObject(type, pos);
            }
        }

        // -- GAME STATE --
        // -- GAME STATE --
        const gameState = {
            characters: [], // Array to hold all player characters
            activeCharacterIndex: 0, // Index of the currently controlled character
            get activeCharacter() { // A handy getter for the current character
                return this.characters[this.activeCharacterIndex];
            },
            get player() { // Backward compatibility alias for activeCharacter
                // Return activeCharacter if it exists, otherwise return null to prevent undefined errors
                const char = this.activeCharacter;
                return char || null;
            },
            npcs: [],
            projectiles: [],

            lootDrops: [],
            damageIndicators: [],
            partyMembers: [],
            destructibleObjects: [],
            colliders: [],
            summons: [],
            skillCooldowns: {}, // { A1: { S1: 0, S2: 0, S3: 0 }, ... }
            comboState: {
                lastBasicAttackTime: 0,
                basicAttackCount: 0,
                comboWindow: 2000, // 2 second window
                maxComboCount: 5
            },
            synergyComboState: {
                totalCombos: 0,
                currentCombo: 0,
                lastSynergyTime: 0,
                comboWindow: 5000, // 5 second window for synergy combos
                maxCombo: 0 // Highest combo achieved
            },
            skillComboSequence: [], // Track skill sequence for visual chains
            skillCooldownStates: {}, // Track previous cooldown states for ready sound
            statusEffects: {}, // { entityId: { effectType: { duration, stacks, source } } }
            ground: null,
        };

        /**
         * Status Effect Manager - Handles buffs and debuffs
         */
        class StatusEffectManager {
            constructor() {
                this.effectTypes = {
                    // Debuffs
                    BURN: { type: 'debuff', icon: '🔥', color: 0xff4400, particleColor: 0xff6600 },
                    FREEZE: { type: 'debuff', icon: '❄️', color: 0x00ccff, particleColor: 0x66ccff },
                    STUN: { type: 'debuff', icon: '💫', color: 0xffff00, particleColor: 0xffff88 },
                    BLEED: { type: 'debuff', icon: '🩸', color: 0xcc0000, particleColor: 0xff0000 },
                    SLOW: { type: 'debuff', icon: '🐌', color: 0x8888ff, particleColor: 0xaaaaaa },
                    POISON: { type: 'debuff', icon: '☠️', color: 0x00ff00, particleColor: 0x88ff88 },

                    // Buffs
                    SHIELD: { type: 'buff', icon: '🛡️', color: 0x00ffff, particleColor: 0x88ffff },
                    SPEED_BOOST: { type: 'buff', icon: '⚡', color: 0xffff00, particleColor: 0xffff88 },
                    DAMAGE_BOOST: { type: 'buff', icon: '⚔️', color: 0xff0000, particleColor: 0xff8888 },
                    REGEN: { type: 'buff', icon: '💚', color: 0x00ff00, particleColor: 0x88ff88 },
                    CRIT_BOOST: { type: 'buff', icon: '⭐', color: 0xffd700, particleColor: 0xfff8dc },
                    INVULNERABLE: { type: 'buff', icon: '✨', color: 0xffffff, particleColor: 0xffffff }
                };
            }

            /**
             * Apply status effect to entity
             */
            applyEffect(entityId, effectType, duration, stacks = 1, source = null) {
                if (!this.effectTypes[effectType]) {
                    console.warn(`Unknown effect type: ${effectType}`);
                    return false;
                }

                if (!gameState.statusEffects[entityId]) {
                    gameState.statusEffects[entityId] = {};
                }

                const effect = this.effectTypes[effectType];
                const existing = gameState.statusEffects[entityId][effectType];

                if (existing) {
                    // Stack or refresh based on effect type
                    if (effect.type === 'debuff' && effectType !== 'STUN') {
                        // Most debuffs stack
                        existing.stacks = Math.min(existing.stacks + stacks, 5); // Max 5 stacks
                        existing.duration = Math.max(existing.duration, duration); // Refresh duration
                    } else {
                        // Buffs and stun refresh duration
                        existing.duration = Math.max(existing.duration, duration);
                    }
                } else {
                    // Create new effect
                    gameState.statusEffects[entityId][effectType] = {
                        type: effectType,
                        duration: duration,
                        maxDuration: duration,
                        stacks: stacks,
                        source: source,
                        appliedAt: Date.now()
                    };
                }

                return true;
            }

            /**
             * Remove status effect
             */
            removeEffect(entityId, effectType) {
                if (gameState.statusEffects[entityId] && gameState.statusEffects[entityId][effectType]) {
                    delete gameState.statusEffects[entityId][effectType];
                    if (Object.keys(gameState.statusEffects[entityId]).length === 0) {
                        delete gameState.statusEffects[entityId];
                    }
                    return true;
                }
                return false;
            }

            /**
             * Check if entity has effect
             */
            hasEffect(entityId, effectType) {
                return gameState.statusEffects[entityId] && gameState.statusEffects[entityId][effectType] !== undefined;
            }

            /**
             * Get effect data
             */
            getEffect(entityId, effectType) {
                return gameState.statusEffects[entityId]?.[effectType] || null;
            }

            /**
             * Get all effects for entity
             */
            getEntityEffects(entityId) {
                return gameState.statusEffects[entityId] || {};
            }

            /**
             * Update all status effects (call in game loop)
             */
            update(deltaTime) {
                for (const entityId in gameState.statusEffects) {
                    const effects = gameState.statusEffects[entityId];
                    for (const effectType in effects) {
                        const effect = effects[effectType];
                        effect.duration -= deltaTime;

                        // Apply damage over time effects
                        if (effect.duration > 0) {
                            this.applyDoTEffects(entityId, effectType, effect, deltaTime);
                        }

                        // Update visual indicators
                        this.updateEffectVisuals(entityId, effectType, effect);

                        // Remove expired effects
                        if (effect.duration <= 0) {
                            this.removeEffectVisuals(entityId, effectType);
                            this.removeEffect(entityId, effectType);
                        }
                    }
                }
            }

            /**
             * Update visual indicators for status effects
             */
            updateEffectVisuals(entityId, effectType, effect) {
                const effectDef = this.effectTypes[effectType];
                if (!effectDef) return;

                // Get entity position and mesh
                let entityPos = null;
                let entityMesh = null;
                if (entityId === 'player' && gameState.activeCharacter) {
                    entityPos = gameState.activeCharacter.mesh.position;
                    entityMesh = gameState.activeCharacter.mesh;
                } else {
                    for (const npc of gameState.npcs) {
                        if (npc.mesh.uuid === entityId || npc.id === entityId) {
                            entityPos = npc.mesh.position;
                            entityMesh = npc.mesh;
                            break;
                        }
                    }
                }

                if (!entityPos || !entityMesh) return;

                // Create or update duration bar container
                if (!entityMesh.durationBarContainer) {
                    entityMesh.durationBarContainer = new THREE.Group();
                    entityMesh.durationBarContainer.name = 'durationBars';
                    scene.add(entityMesh.durationBarContainer);
                }

                // Create or update duration bar for this effect
                const barKey = `bar_${effectType}`;
                let barGroup = entityMesh.durationBarContainer.getObjectByName(barKey);

                if (!barGroup) {
                    barGroup = new THREE.Group();
                    barGroup.name = barKey;

                    // Background bar
                    const bgGeometry = new THREE.PlaneGeometry(1.2, 0.08);
                    const bgMaterial = new THREE.MeshBasicMaterial({
                        color: 0x000000,
                        transparent: true,
                        opacity: 0.6
                    });
                    const bgBar = new THREE.Mesh(bgGeometry, bgMaterial);
                    bgBar.position.z = 0.01;
                    barGroup.add(bgBar);

                    // Fill bar
                    const fillGeometry = new THREE.PlaneGeometry(1.2, 0.08);
                    const fillMaterial = new THREE.MeshBasicMaterial({
                        color: effectDef.color,
                        transparent: true,
                        opacity: 0.9
                    });
                    const fillBar = new THREE.Mesh(fillGeometry, fillMaterial);
                    fillBar.name = 'fill';
                    fillBar.position.z = 0.02;
                    barGroup.add(fillBar);

                    entityMesh.durationBarContainer.add(barGroup);
                }

                // Update fill bar width based on duration
                const fillBar = barGroup.getObjectByName('fill');
                if (fillBar && effect.maxDuration > 0) {
                    const progress = Math.max(0, Math.min(1, effect.duration / effect.maxDuration));
                    fillBar.scale.x = progress;
                    fillBar.position.x = -0.6 * (1 - progress); // Scale from left
                }

                // Position duration bar container above entity
                const allEffects = this.getEntityEffects(entityId);
                const effectList = Object.keys(allEffects);
                const effectIndex = effectList.indexOf(effectType);
                const barHeight = 0.12;
                const startY = 4.0; // Start 4 units above entity

                barGroup.position.copy(entityPos);
                barGroup.position.y = startY - (effectIndex * barHeight);

                // Make bars face camera
                barGroup.lookAt(camera.position);

                // Create or update floating icon
                if (!effect.iconMesh) {
                    // Create sprite for icon
                    const canvas = document.createElement('canvas');
                    canvas.width = 64;
                    canvas.height = 64;
                    const ctx = canvas.getContext('2d');
                    ctx.font = '48px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(effectDef.icon, 32, 32);

                    const texture = new THREE.CanvasTexture(canvas);
                    const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
                    const sprite = new THREE.Sprite(spriteMaterial);
                    sprite.scale.set(1, 1, 1);
                    sprite.position.copy(entityPos).add(new THREE.Vector3(0, 3, 0));
                    scene.add(sprite);
                    effect.iconMesh = sprite;
                } else {
                    // Update position
                    effect.iconMesh.position.copy(entityPos).add(new THREE.Vector3(0, 3, 0));
                }

                // Emit particles for certain effects
                if (effectType === 'BURN' || effectType === 'BLEED' || effectType === 'POISON') {
                    if (!effect.lastParticleTime) effect.lastParticleTime = 0;
                    effect.lastParticleTime += deltaTime;
                    if (effect.lastParticleTime >= 0.2) {
                        effect.lastParticleTime = 0;
                        const particlePos = entityPos.clone().add(new THREE.Vector3(
                            (Math.random() - 0.5) * 2,
                            Math.random() * 2,
                            (Math.random() - 0.5) * 2
                        ));
                        particleSystem.emit(particlePos, 2, effectDef.particleColor, 0.1, 0.5);
                    }
                }
            }

            /**
             * Remove visual indicators
             */
            removeEffectVisuals(entityId, effectType) {
                const effects = gameState.statusEffects[entityId];
                if (effects && effects[effectType] && effects[effectType].iconMesh) {
                    scene.remove(effects[effectType].iconMesh);
                    effects[effectType].iconMesh.material.map.dispose();
                    effects[effectType].iconMesh.material.dispose();
                    effects[effectType].iconMesh = null;
                }

                // Remove duration bar
                let entityMesh = null;
                if (entityId === 'player' && gameState.activeCharacter) {
                    entityMesh = gameState.activeCharacter.mesh;
                } else {
                    for (const npc of gameState.npcs) {
                        if (npc.mesh.uuid === entityId || npc.id === entityId) {
                            entityMesh = npc.mesh;
                            break;
                        }
                    }
                }

                if (entityMesh && entityMesh.durationBarContainer) {
                    const barKey = `bar_${effectType}`;
                    const barGroup = entityMesh.durationBarContainer.getObjectByName(barKey);
                    if (barGroup) {
                        // Dispose materials and geometries
                        barGroup.traverse((child) => {
                            if (child instanceof THREE.Mesh) {
                                if (child.geometry) child.geometry.dispose();
                                if (child.material) {
                                    if (child.material.map) child.material.map.dispose();
                                    child.material.dispose();
                                }
                            }
                        });
                        entityMesh.durationBarContainer.remove(barGroup);
                    }
                }
            }

            /**
             * Apply damage over time effects
             */
            applyDoTEffects(entityId, effectType, effect, deltaTime) {
                const dotInterval = 0.5; // Apply DoT every 0.5 seconds
                if (!effect.lastDotTime) effect.lastDotTime = 0;
                effect.lastDotTime += deltaTime;

                if (effect.lastDotTime >= dotInterval) {
                    effect.lastDotTime = 0;
                    const stacks = effect.stacks || 1;

                    let damage = 0;
                    if (effectType === 'BURN') {
                        damage = 5 * stacks; // 5 damage per stack per tick
                    } else if (effectType === 'BLEED') {
                        damage = 8 * stacks; // 8 damage per stack per tick
                    } else if (effectType === 'POISON') {
                        damage = 3 * stacks; // 3 damage per stack per tick
                    }

                    if (damage > 0) {
                        // Apply damage to entity
                        this.applyDamageToEntity(entityId, damage, effectType);
                    }
                }
            }

            /**
             * Apply damage to entity (NPC or player)
             */
            applyDamageToEntity(entityId, damage, effectType) {
                // Check if it's player
                if (entityId === 'player' && gameState.activeCharacter) {
                    gameState.activeCharacter.currentHealth -= damage;
                    if (gameState.activeCharacter.currentHealth < 0) gameState.activeCharacter.currentHealth = 0;
                    createDamageIndicator(gameState.activeCharacter.mesh.position.clone().add(new THREE.Vector3(0, 2, 0)), damage);
                } else {
                    // Find NPC
                    for (const npc of gameState.npcs) {
                        if (npc.id === entityId || npc.mesh.uuid === entityId) {
                            npc.health -= damage;
                            if (npc.health <= 0) {
                                npc.health = 0;
                                npc.state = 'dying';
                                npc.dyingTimer = 0.5;
                            }
                            createDamageIndicator(npc.mesh.position.clone().add(new THREE.Vector3(0, 2, 0)), damage);
                            break;
                        }
                    }
                }
            }

            /**
             * Get effect multiplier (for damage, speed, etc.)
             */
            getEffectMultiplier(entityId, multiplierType) {
                const effects = this.getEntityEffects(entityId);
                let multiplier = 1.0;

                for (const effectType in effects) {
                    const effect = effects[effectType];
                    const stacks = effect.stacks || 1;

                    switch (multiplierType) {
                        case 'damage':
                            if (effectType === 'DAMAGE_BOOST') multiplier += 0.2 * stacks; // +20% per stack
                            if (effectType === 'CRIT_BOOST') multiplier += 0.15 * stacks; // +15% crit chance per stack
                            break;
                        case 'speed':
                            if (effectType === 'SPEED_BOOST') multiplier += 0.3 * stacks; // +30% per stack
                            if (effectType === 'SLOW') multiplier -= 0.2 * stacks; // -20% per stack
                            break;
                        case 'defense':
                            if (effectType === 'SHIELD') multiplier *= 0.5; // 50% damage reduction
                            if (effectType === 'INVULNERABLE') multiplier = 0; // No damage
                            break;
                    }
                }

                return Math.max(0, multiplier);
            }

            /**
             * Check if entity is stunned
             */
            isStunned(entityId) {
                return this.hasEffect(entityId, 'STUN');
            }

            /**
             * Check if entity is frozen
             */
            isFrozen(entityId) {
                return this.hasEffect(entityId, 'FREEZE');
            }
        }

        // Global status effect manager instance
        const statusEffectManager = new StatusEffectManager();

        /**
         * Skill Effect Calculator - Handles stat calculations and scaling
         */
        class SkillEffectCalculator {
            constructor() {
                // Element damage multipliers
                this.elementMultipliers = {
                    PHYSICAL: 1.0,
                    FIRE: 1.2,
                    ICE: 1.1,
                    LIGHTNING: 1.15,
                    SHADOW: 1.25,
                    LIGHT: 1.2,
                    ARCANE: 1.3,
                    PLASMA: 1.15,
                    ENERGY: 1.1,
                    SUMMON: 1.0
                };

                // Element weaknesses (damage bonus against certain types)
                this.elementWeaknesses = {
                    FIRE: ['ICE'],
                    ICE: ['FIRE', 'LIGHTNING'],
                    LIGHTNING: ['ICE', 'WATER'],
                    SHADOW: ['LIGHT'],
                    LIGHT: ['SHADOW'],
                    ARCANE: ['PHYSICAL']
                };
            }

            /**
             * Calculate final damage with all modifiers
             */
            calculateDamage(skillData, baseDamage, targetEntity = null, sourceEntity = 'player') {
                let finalDamage = baseDamage;

                // Apply element multiplier
                if (skillData.element) {
                    finalDamage *= (this.elementMultipliers[skillData.element] || 1.0);
                }

                // Apply crit chance
                const critChance = skillData.critChance || 0.05; // 5% base crit
                const critMultiplier = skillData.critMultiplier || 2.0;
                const isCrit = Math.random() < critChance;
                if (isCrit) {
                    finalDamage *= critMultiplier;
                }

                // Apply status effect multipliers
                if (statusEffectManager) {
                    const damageMult = statusEffectManager.getEffectMultiplier(sourceEntity, 'damage');
                    finalDamage *= damageMult;
                }

                // Apply mastery bonuses (if available)
                if (window.skillLibrary) {
                    const skillLib = window.skillLibrary;
                    const characterId = gameState.activeCharacter?.characterId || 'A1';
                    const masteryBonuses = skillLib.getMasteryBonuses(characterId, skillData.id);
                    if (masteryBonuses.damageBonus > 0) {
                        finalDamage *= (1 + masteryBonuses.damageBonus);
                    }
                }

                // Apply combo multiplier
                const comboMult = getComboMultiplier();
                finalDamage *= comboMult;

                return {
                    damage: Math.round(finalDamage),
                    isCrit: isCrit,
                    element: skillData.element || 'PHYSICAL'
                };
            }

            /**
             * Calculate area of effect radius
             */
            calculateAoE(skillData) {
                return skillData.areaOfEffect || 0;
            }

            /**
             * Calculate pierce count
             */
            calculatePierce(skillData) {
                return skillData.pierceCount || 0;
            }

            /**
             * Calculate bounce count
             */
            calculateBounce(skillData) {
                return skillData.bounceCount || 0;
            }

            /**
             * Calculate knockback force
             */
            calculateKnockback(skillData) {
                return skillData.knockback || 0;
            }

            /**
             * Calculate lifesteal amount
             */
            calculateLifesteal(skillData, damage) {
                const lifestealPercent = skillData.lifesteal || 0;
                return damage * lifestealPercent;
            }

            /**
             * Get status effects to apply
             */
            getStatusEffects(skillData) {
                return skillData.statusEffects || [];
            }

            /**
             * Calculate skill scaling based on level
             */
            calculateLevelScaling(skillData, playerLevel) {
                const baseDamage = Array.isArray(skillData.baseDamage) ? skillData.baseDamage[0] : skillData.baseDamage;
                const scalingFactor = 1.0 + (playerLevel - 1) * 0.05; // 5% per level
                return baseDamage * scalingFactor;
            }

            /**
             * Apply skill effects to target
             */
            applySkillEffects(skillData, targetEntityId, damageResult) {
                const statusEffects = this.getStatusEffects(skillData);

                statusEffects.forEach(effect => {
                    if (statusEffectManager) {
                        statusEffectManager.applyEffect(
                            targetEntityId,
                            effect.type,
                            effect.duration || 2.0,
                            effect.stacks || 1,
                            skillData.id
                        );
                    }
                });

                // Apply lifesteal if applicable
                if (skillData.lifesteal && gameState.player && gameState.player.effectiveStats) {
                    const lifestealAmount = this.calculateLifesteal(skillData, damageResult.damage);
                    gameState.player.currentHealth = Math.min(
                        gameState.player.currentHealth + lifestealAmount,
                        gameState.player.effectiveStats.health
                    );
                }
            }
        }

        // Global skill effect calculator instance
        const skillEffectCalculator = new SkillEffectCalculator();


        // --- RPG STATE DEFINITION ---
        const RANK_ORDER = ['E', 'D', 'C', 'B', 'A', 'S', 'SS'];

        const PlayerState = {
            current: {
                name: "A1",
                perceivedRank: 'E', // What others see
                trueRank: 'S',      // The hidden power
                level: 1,
                xp: 0,
                money: 1000,
                activeClass: 'Hero',

                base_stats: {
                    health: 100,
                    attack: 20,
                    defense: 10,
                    power_regen: 5,
                },

                hasUncontrolledPower: true,
                spritePowerLevel: 'S',

                ability_cooldowns: {
                    primary_duration: 0.5, // seconds
                    primary_timer: 0,
                },
            },

            party: [
                {
                    name: "Missy",
                    perceivedRank: 'C',
                    trueRank: 'C',
                    activeClass: 'Healer',
                    base_stats: { health: 80, attack: 10, defense: 15 },
                },
                {
                    name: "Unique",
                    perceivedRank: 'A',
                    trueRank: 'A',
                    activeClass: 'Berserker',
                    base_stats: { health: 120, attack: 35, defense: 5 },
                }
            ],

            classes: {
                Hero: { focus: "Balanced", primary_ability: "BasicBlast" },
                Slayer: { focus: "Melee Damage", primary_ability: "PowerStrike" },
                Hunter: { focus: "Ranged/Utility", primary_ability: "PrecisionShot" },
                Samurai: { focus: "Discipline/Block", primary_ability: "IronGuard" },
                Healer: { focus: "Support/Healing", primary_ability: "MinorHeal" },
                Berserker: { focus: "High-Risk Damage", primary_ability: "WildSwing" }
            },

            rankScaling: {
                'E': { health_mult: 0.5, attack_mult: 0.5 },
                'D': { health_mult: 0.7, attack_mult: 0.7 },
                'C': { health_mult: 1.0, attack_mult: 1.0 }, // Base
                'B': { health_mult: 1.4, attack_mult: 1.4 },
                'A': { health_mult: 1.9, attack_mult: 1.9 },
                'S': { health_mult: 2.8, attack_mult: 2.8 },
                'SS': { health_mult: 4.0, attack_mult: 4.0 },
            },

            canAccess: function (requiredRank) {
                const playerIndex = RANK_ORDER.indexOf(this.current.rank);
                const requiredIndex = RANK_ORDER.indexOf(requiredRank);
                return playerIndex >= requiredIndex;
            },

            gainXP: function (amount) {
                this.current.xp += amount;
                // Simplification: for now, no actual leveling logic, just display.
                console.log(`[RPG] Gained ${amount} XP. Current Rank: ${this.current.rank}`);
            }
        };

        // Function to calculate current effective stats
        function calculateEffectiveStats() {
            const { current, rankScaling, classes } = PlayerState;
            // The server-side logic is prototyped here:
            // We use the TRUE rank for all combat calculations.
            const trueRankStats = rankScaling[current.trueRank];

            return {
                health: current.base_stats.health * trueRankStats.health_mult,
                attack: current.base_stats.attack * trueRankStats.attack_mult,
                defense: current.base_stats.defense, // Defense might scale differently or not at all yet
                activeAbility: classes[current.activeClass].primary_ability
            };
        }


        // -- PLAYER & NPC CREATION --
        function createPartyMembers() {
            const playerPos = gameState.activeCharacter.mesh.position;
            const partyColors = [0xffc0cb, 0x9400d3]; // Pink for Missy, Violet for Unique

            PlayerState.party.forEach((memberData, index) => {
                const partyMemberGeometry = new THREE.CapsuleGeometry(0.7, 1.2, 4, 8);
                const partyMemberMaterial = new THREE.MeshStandardMaterial({ color: partyColors[index] || 0xffffff });
                const partyMemberMesh = new THREE.Mesh(partyMemberGeometry, partyMemberMaterial);

                // Position them slightly behind the player initially
                const offsetX = (index === 0) ? -3 : 3;
                partyMemberMesh.position.set(playerPos.x + offsetX, playerPos.y, playerPos.z - 3);
                partyMemberMesh.castShadow = true;

                const partyMemberState = {
                    mesh: partyMemberMesh,
                    healthBar: createHealthBar(),
                    details: memberData,
                    state: 'following', // AI state
                    attackTarget: null,
                    attackCooldown: 0,
                    stats: { // Simplified stats for party members
                        attack: (memberData.base_stats.attack * (PlayerState.rankScaling[memberData.trueRank]?.attack_mult || 1)),
                        attack_cooldown: 2.0,
                    },
                    currentHealth: (memberData.base_stats.health * (PlayerState.rankScaling[memberData.trueRank]?.health_mult || 1)),
                    maxHealth: (memberData.base_stats.health * (PlayerState.rankScaling[memberData.trueRank]?.health_mult || 1)),
                };

                partyMemberMesh.add(partyMemberState.healthBar);
                partyMemberState.healthBar.position.y = 2.5;

                gameState.partyMembers.push(partyMemberState);
                scene.add(partyMemberMesh);
            });
        }



        // -- PLAYER & NPC CREATION --
        function createCharacters() {
            const characterIds = ['A1', 'UNIQUE', 'MISSY'];
            const startPosition = new THREE.Vector3(0, 10, 140);

            characterIds.forEach((id, index) => {
                const geometry = new THREE.CapsuleGeometry(0.8, 1.4, 4, 16);
                // Assign unique colors for now
                const material = new THREE.MeshStandardMaterial({ color: [0x00aaff, 0x00ffff, 0xff69b4][index] });
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(startPosition);
                mesh.castShadow = true;

                // Hide inactive characters
                mesh.visible = (index === 0);
                scene.add(mesh);

                const characterState = {
                    mesh: mesh,
                    characterId: id,
                    effectiveStats: {}, // We'll calculate this on switch
                    currentHealth: 100,
                    maxHealth: 100,
                    currentMana: 100,
                    maxMana: 100,
                    direction: new THREE.Vector3(0, 0, -1),
                    rotation: new THREE.Euler(0, 0, 0, 'YXZ'),
                    cameraTarget: new THREE.Vector3(),
                    isJumping: false,
                    onGround: true,
                    jumpVelocity: 0,
                    isFlying: false,
                };

                // Calculate initial stats
                PlayerState.current.name = id; // Temporarily set to calculate stats
                characterState.effectiveStats = calculateEffectiveStats();
                characterState.currentHealth = characterState.effectiveStats.health;
                characterState.maxHealth = characterState.effectiveStats.health;

                gameState.characters.push(characterState);
            });

            // Make sure the active character's cameraTarget is initialized correctly
            if (gameState.activeCharacter) {
                gameState.activeCharacter.cameraTarget.copy(gameState.activeCharacter.mesh.position);
                // Set the global player object for legacy compatibility
                player = gameState.activeCharacter.mesh;
            }

            console.log(`[Trinity System] Created ${gameState.characters.length} characters. Active: ${gameState.activeCharacter.characterId}`);
            updateCharacterHUD(); // Initial HUD setup
        }

        function switchCharacter() {
            if (gameState.characters.length <= 1) return;

            const oldCharacter = gameState.activeCharacter;

            // Hide old character's 3D sprite if it exists
            if (oldCharacter && oldCharacter.sprite3D) {
                oldCharacter.sprite3D.group.visible = false;
            }
            oldCharacter.mesh.visible = false;


            // Cycle to the next character
            gameState.activeCharacterIndex = (gameState.activeCharacterIndex + 1) % gameState.characters.length;

            const newCharacter = gameState.activeCharacter;
            player = newCharacter.mesh; // Update the global player reference

            console.log(`Switching to ${newCharacter.characterId}`);

            // Move new character to the old one's position and orientation
            newCharacter.mesh.position.copy(oldCharacter.mesh.position);
            newCharacter.mesh.rotation.copy(oldCharacter.mesh.rotation);
            newCharacter.mesh.visible = true;

            // Update PlayerState for stat calculations
            PlayerState.current.name = newCharacter.characterId;
            // In a more complex system, you'd load the full state for that character.

            // Show new character's 3D sprite
            if (!newCharacter.sprite3D) {
                // Create sprite if it doesn't exist yet
                newCharacter.sprite3D = sprite3DManager.createSprite(newCharacter.characterId, newCharacter.mesh.position);
            }
            if (newCharacter.sprite3D) {
                newCharacter.sprite3D.group.visible = true;
                newCharacter.sprite3D.group.position.copy(newCharacter.mesh.position);
                newCharacter.sprite3D.group.rotation.copy(newCharacter.mesh.rotation);
            }

            // Instantly move camera to the new character
            camera.position.add(new THREE.Vector3().subVectors(newCharacter.mesh.position, oldCharacter.mesh.position));
            newCharacter.cameraTarget.copy(newCharacter.mesh.position);

            updateCharacterHUD();
            playSound('skill_ready', { pitch: 1.5 });
        }


        function updateCharacterHUD() {
            const character = gameState.activeCharacter;
            if (!character || !window.HUD) return;

            const skillLib = window.skillLibrary;

            ['S1', 'S2', 'S3'].forEach(slotKey => {
                const skill = skillLib.getEquippedSkill(character.characterId, slotKey);
                const skillPill = document.querySelector(`.skill-pill[data-btn="${slotKey.toLowerCase()}"]`);
                if (skillPill) {
                    if (skill) {
                        skillPill.setAttribute('data-skill', skill.name);
                        // Make the button display the icon, not the name
                        const currentIcon = skillPill.querySelector('.skill-icon');
                        if (currentIcon) currentIcon.remove();
                        skillPill.textContent = skill.icon || skill.name.substring(0, 2);
                    } else {
                        skillPill.setAttribute('data-skill', slotKey);
                        skillPill.textContent = slotKey;
                    }
                }
                // Reset and update cooldown display
                HUD.updateSkillCooldown(slotKey, gameState.skillCooldowns[character.characterId]?.[slotKey] || 0);
            });
        }



        // ADDING this function to show RPG status
        function updateHUD() {
            // Info div was removed - HUD info is now in stats panel
            // Game over handling can be added to stats panel if needed
            // No longer updating standalone info div
            // Safety check: ensure we don't try to access removed elements
            const infoDiv = document.getElementById('info');
            if (!infoDiv) {
                return; // Element doesn't exist, which is expected
            }
            // If somehow the element exists, we still won't update it
        }

        // Add tab state
        if (!window.statsPanelState) {
            window.statsPanelState = { activeTab: 'radar', isVisible: true };
        }

        function updateStatsPanel() {
            const statsPanel = document.getElementById('stats-panel');
            const healthBarsContainer = document.getElementById('health-bars-container');
            const showBtn = document.getElementById('stats-panel-show-btn');

            if (!statsPanel || !gameState.activeCharacter || gameState.activeCharacter.currentHealth <= 0) {
                if (statsPanel) {
                    statsPanel.classList.add('hidden');
                    if (showBtn) showBtn.classList.add('visible');
                }
                return;
            }

            // Handle visibility
            if (window.statsPanelState.isVisible) {
                statsPanel.classList.remove('hidden');
                if (showBtn) showBtn.classList.remove('visible');
            } else {
                statsPanel.classList.add('hidden');
                if (showBtn) showBtn.classList.add('visible');
                return; // Don't update content if hidden
            }

            const activeTab = window.statsPanelState.activeTab || 'radar';

            // Update tab buttons
            statsPanel.querySelectorAll('.stats-panel-tab').forEach(tab => {
                tab.classList.toggle('active', tab.dataset.tab === activeTab);
            });

            // Update tab content visibility
            statsPanel.querySelectorAll('.stats-panel-tab-content').forEach(content => {
                content.classList.toggle('active', content.id === `${activeTab}-tab-content`);
            });

            // Render based on active tab
            switch (activeTab) {
                case 'stats':
                    renderStatsTab();
                    break;
                case 'info':
                    renderInfoTab();
                    break;
                case 'radar':
                    renderRadarTab();
                    break;
                case 'mastery':
                    renderMasteryTab();
                    break;
                case 'heatmap':
                    renderHeatmapTab();
                    break;
                case 'logs':
                    renderLogsTab();
                    break;
            }
        }

        function renderStatsTab() {
            const statsContent = document.getElementById('stats-tab-content');
            if (!statsContent) return;

            const playerStats = gameState.activeCharacter.effectiveStats;

            let panelHTML = `<div class="stat-block player">`;
            panelHTML += `<h3>${gameState.activeCharacter.characterId} (Rank ${PlayerState.current.perceivedRank})</h3>`;
            panelHTML += `<div class="hp-bar"><div class="hp-fill" style="width: ${100 * gameState.activeCharacter.currentHealth / playerStats.health}%"></div></div>`;
            panelHTML += `<p>HP: ${Math.round(gameState.activeCharacter.currentHealth)} / ${Math.round(playerStats.health)}</p>`;
            const cooldowns = PlayerState.current.ability_cooldowns;
            const cooldownText = cooldowns.primary_timer > 0
                ? `(CD: ${cooldowns.primary_timer.toFixed(1)}s)`
                : '(Ready)';
            panelHTML += `<p>ATK: ${Math.round(playerStats.attack)} | Ability: ${playerStats.activeAbility} ${cooldownText}</p>`;
            panelHTML += `</div>`;

            panelHTML += '<h4>Party</h4>';

            PlayerState.party.forEach((member, index) => {
                const memberRankStats = PlayerState.rankScaling[member.trueRank];
                const partyMemberState = gameState.partyMembers[index];

                panelHTML += `<div class="stat-block party-member">`;
                panelHTML += `<b>${member.name} (Rank ${member.perceivedRank})</b>`;
                if (partyMemberState) {
                    panelHTML += `<div class="hp-bar"><div class="hp-fill" style="width: ${100 * partyMemberState.currentHealth / partyMemberState.maxHealth}%"></div></div>`;
                    panelHTML += `<p>HP: ${Math.round(partyMemberState.currentHealth)} / ${Math.round(partyMemberState.maxHealth)}</p>`;
                }
                panelHTML += `</div>`;
            });

            statsContent.innerHTML = panelHTML;
        }

        function renderInfoTab() {
            const infoContent = document.getElementById('info-tab-content');
            if (!infoContent) return;

            const controls = [
                { key: 'WASD / Arrow Keys', action: 'Move' },
                { key: 'A / D', action: 'Look Left/Right' },
                { key: 'Shift', action: 'Sprint' },
                { key: 'Space', action: 'Fire / Attack' },
                { key: '1, 2, 3', action: 'Skills (S1, S2, S3)' },
                { key: 'Mouse / Touch', action: 'Look Around' },
                { key: 'Q / E', action: 'Strafe Left/Right' },
                { key: 'R', action: 'Rage Mode' },
                { key: 'F', action: 'Shield Mode' },
                { key: 'B', action: 'Open Bag' },
                { key: 'Tab', action: 'Switch Character' }
            ];

            let html = '<h3>Controls</h3>';
            html += '<ul class="controls-list">';
            controls.forEach(control => {
                html += `<li><span class="key">${control.key}</span> - ${control.action}</li>`;
            });
            html += '</ul>';

            html += '<h4>Game Info</h4>';
            html += '<p><strong>Character:</strong> ' + PlayerState.current.name + '</p>';
            html += '<p><strong>Rank:</strong> ' + PlayerState.current.perceivedRank + ' (True: ' + PlayerState.current.trueRank + ')</p>';
            html += '<p><strong>Level:</strong> ' + PlayerState.current.level + '</p>';
            html += '<p><strong>Money:</strong> ' + PlayerState.current.money.toLocaleString() + '</p>';

            infoContent.innerHTML = html;
        }

        function renderRadarTab() {
            const radarContent = document.getElementById('radar-tab-content');
            if (!radarContent) return;

            // Safety check for player
            if (!gameState.player || !gameState.player.mesh) return;

            const playerPos = gameState.player.mesh.position;
            const radarRadius = 50; // Radar range in game units
            const radarSize = 250; // Radar display size in pixels
            const scale = radarSize / (radarRadius * 2);

            let html = '<h3>Radar</h3>';
            html += '<div class="radar-container">';
            html += '<div class="radar-canvas" id="radar-canvas">';
            html += '<div class="radar-center"></div>'; // Player at center

            // Draw NPCs on radar
            gameState.npcs.forEach(npc => {
                if (npc.health <= 0) return;

                const distance = playerPos.distanceTo(npc.mesh.position);
                if (distance > radarRadius) return;

                const dx = npc.mesh.position.x - playerPos.x;
                const dz = npc.mesh.position.z - playerPos.z;

                // Convert to radar coordinates (0-250px)
                const radarX = (dx + radarRadius) * scale;
                const radarY = (dz + radarRadius) * scale;

                let dotClass = 'civilian';
                if (npc.type === 'villain') dotClass = 'enemy';
                else if (npc.type === 'hero') dotClass = 'hero';

                html += `<div class="radar-dot ${dotClass}" style="left: ${radarX}px; top: ${radarY}px;" title="${npc.type}"></div>`;
            });

            // Draw party members
            gameState.partyMembers.forEach((member, index) => {
                if (member.currentHealth <= 0) return;

                const distance = playerPos.distanceTo(member.mesh.position);
                if (distance > radarRadius) return;

                const dx = member.mesh.position.x - playerPos.x;
                const dz = member.mesh.position.z - playerPos.z;

                const radarX = (dx + radarRadius) * scale;
                const radarY = (dz + radarRadius) * scale;

                html += `<div class="radar-dot party" style="left: ${radarX}px; top: ${radarY}px;" title="Party: ${PlayerState.party[index]?.name || 'Member'}"></div>`;
            });

            html += '</div></div>';

            // Legend
            html += '<div class="radar-legend">';
            html += '<div class="radar-legend-item"><div class="radar-legend-dot" style="background: #0f0;"></div><span>You</span></div>';
            html += '<div class="radar-legend-item"><div class="radar-legend-dot" style="background: #0ff;"></div><span>Party</span></div>';
            html += '<div class="radar-legend-item"><div class="radar-legend-dot" style="background: #f00;"></div><span>Enemy</span></div>';
            html += '<div class="radar-legend-item"><div class="radar-legend-dot" style="background: #00f;"></div><span>Hero</span></div>';
            html += '<div class="radar-legend-item"><div class="radar-legend-dot" style="background: #ff0;"></div><span>Civilian</span></div>';
            html += '</div>';

            // Entity count
            const enemyCount = gameState.npcs.filter(n => n.type === 'villain' && n.health > 0).length;
            const heroCount = gameState.npcs.filter(n => n.type === 'hero' && n.health > 0).length;
            const civilianCount = gameState.npcs.filter(n => n.type === 'civilian' && n.health > 0).length;

            html += '<div style="margin-top: 10px; font-size: 11px;">';
            html += `<p><strong>Enemies:</strong> ${enemyCount}</p>`;
            html += `<p><strong>Heroes:</strong> ${heroCount}</p>`;
            html += `<p><strong>Civilians:</strong> ${civilianCount}</p>`;
            html += `<p><strong>Party:</strong> ${gameState.partyMembers.length}</p>`;
            html += '</div>';

            radarContent.innerHTML = html;
        }

        /**
         * Render mastery leaderboard tab
         */
        function renderMasteryTab() {
            const masteryContent = document.getElementById('mastery-tab-content');
            if (!masteryContent) return;

            const skillLib = window.skillLibrary || skillLibrary;
            if (!skillLib) {
                masteryContent.innerHTML = '<p>SkillLibrary not available</p>';
                return;
            }

            const characterId = gameState.activeCharacter?.characterId || 'A1';
            const allSkills = skillLib.getAllSkills(characterId);
            const masteryData = skillLib.skillMastery[characterId] || {};

            // Get all skills with mastery data
            const skillsWithMastery = allSkills.map(skill => {
                const mastery = masteryData[skill.id] || { level: 1, xp: 0, xpToNext: 100, totalUses: 0 };
                const stats = skillLib.skillStats[characterId]?.[skill.id] || { totalDamage: 0, totalKills: 0, averageDamage: 0 };
                return {
                    skill,
                    mastery,
                    stats
                };
            }).filter(item => item.mastery.totalUses > 0 || item.mastery.level > 1);

            // Sort by mastery level (descending), then by total uses
            skillsWithMastery.sort((a, b) => {
                if (b.mastery.level !== a.mastery.level) {
                    return b.mastery.level - a.mastery.level;
                }
                return b.mastery.totalUses - a.mastery.totalUses;
            });

            let html = '<h3>Mastery Leaderboard</h3>';
            html += '<div class="mastery-leaderboard">';

            if (skillsWithMastery.length === 0) {
                html += '<p style="color: #aaa; text-align: center; margin-top: 20px;">No mastery data yet. Use skills to gain mastery!</p>';
            } else {
                skillsWithMastery.forEach((item, index) => {
                    const { skill, mastery, stats } = item;
                    const xpPercent = (mastery.xp / mastery.xpToNext) * 100;
                    const badge = getMasteryBadge(mastery.level);

                    html += `<div class="mastery-entry" style="margin-bottom: 12px; padding: 10px; background: rgba(255,255,255,0.05); border-radius: 6px; border-left: 3px solid ${getMasteryColor(mastery.level)};">`;
                    html += `<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">`;
                    html += `<div><strong>#${index + 1}</strong> ${skill.icon || '⚔️'} ${skill.name}</div>`;
                    html += `<div style="font-size: 18px;">${badge}</div>`;
                    html += `</div>`;
                    html += `<div style="font-size: 12px; color: #aaa;">Level ${mastery.level} | Uses: ${mastery.totalUses} | Kills: ${stats.totalKills}</div>`;
                    html += `<div style="margin-top: 4px; height: 4px; background: rgba(0,0,0,0.3); border-radius: 2px; overflow: hidden;">`;
                    html += `<div style="height: 100%; background: ${getMasteryColor(mastery.level)}; width: ${xpPercent}%; transition: width 0.3s;"></div>`;
                    html += `</div>`;
                    html += `<div style="font-size: 10px; color: #888; margin-top: 2px;">XP: ${Math.round(mastery.xp)}/${mastery.xpToNext}</div>`;
                    html += `</div>`;
                });
            }

            html += '</div>';
            masteryContent.innerHTML = html;
        }

        /**
         * Render skill usage heatmap tab
         */
        function renderHeatmapTab() {
            const heatmapContent = document.getElementById('heatmap-tab-content');
            if (!heatmapContent) return;

            const skillLib = window.skillLibrary || skillLibrary;
            if (!skillLib) {
                heatmapContent.innerHTML = '<p>SkillLibrary not available</p>';
                return;
            }

            const characterId = gameState.activeCharacter?.characterId || 'A1';
            const allSkills = skillLib.getAllSkills(characterId);
            const statsData = skillLib.skillStats[characterId] || {};

            // Get usage data
            const usageData = allSkills.map(skill => {
                const stats = statsData[skill.id] || { totalUses: 0, totalDamage: 0, totalKills: 0 };
                const mastery = skillLib.skillMastery[characterId]?.[skill.id] || { totalUses: 0 };
                return {
                    skill,
                    uses: mastery.totalUses || stats.totalUses || 0,
                    damage: stats.totalDamage || 0,
                    kills: stats.totalKills || 0
                };
            });

            // Find max values for normalization
            const maxUses = Math.max(...usageData.map(d => d.uses), 1);
            const maxDamage = Math.max(...usageData.map(d => d.damage), 1);

            let html = '<h3>Skill Usage Heatmap</h3>';
            html += '<div class="heatmap-container" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 10px; margin-top: 10px;">';

            usageData.forEach(item => {
                const intensity = item.uses / maxUses;
                const damageIntensity = item.damage / maxDamage;
                const heatColor = getHeatmapColor(intensity);
                const damageColor = getHeatmapColor(damageIntensity);

                html += `<div class="heatmap-item" style="padding: 12px; background: ${heatColor}; border-radius: 6px; text-align: center; border: 2px solid ${damageColor};">`;
                html += `<div style="font-size: 24px; margin-bottom: 4px;">${item.skill.icon || '⚔️'}</div>`;
                html += `<div style="font-size: 11px; font-weight: bold; margin-bottom: 4px;">${item.skill.name}</div>`;
                html += `<div style="font-size: 10px; color: rgba(255,255,255,0.8);">Uses: ${item.uses}</div>`;
                html += `<div style="font-size: 10px; color: rgba(255,255,255,0.7);">DMG: ${Math.round(item.damage)}</div>`;
                html += `<div style="font-size: 10px; color: rgba(255,255,255,0.7);">Kills: ${item.kills}</div>`;
                html += `</div>`;
            });

            html += '</div>';
            html += '<div style="margin-top: 15px; font-size: 11px; color: #aaa; text-align: center;">';
            html += '<div>Color intensity = Usage frequency</div>';
            html += '<div style="margin-top: 4px;">Border color = Damage dealt</div>';
            html += '</div>';

            heatmapContent.innerHTML = html;
        }

        /**
         * Get mastery badge based on level
         */
        function getMasteryBadge(level) {
            if (level >= 10) return '🏆';
            if (level >= 9) return '⭐';
            if (level >= 7) return '🌟';
            if (level >= 5) return '💫';
            if (level >= 3) return '✨';
            return '•';
        }

        /**
         * Get mastery color based on level
         */
        function getMasteryColor(level) {
            if (level >= 10) return '#FFD700'; // Gold
            if (level >= 9) return '#FF6B6B'; // Red
            if (level >= 7) return '#4ECDC4'; // Teal
            if (level >= 5) return '#95E1D3'; // Mint
            if (level >= 3) return '#F38181'; // Pink
            return '#AAA'; // Gray
        }

        /**
         * Get heatmap color based on intensity (0-1)
         */
        function getHeatmapColor(intensity) {
            if (intensity === 0) return 'rgba(0, 0, 0, 0.3)';
            if (intensity < 0.2) return `rgba(0, 50, 100, ${0.3 + intensity * 0.3})`;
            if (intensity < 0.5) return `rgba(0, 100, 200, ${0.4 + intensity * 0.4})`;
            if (intensity < 0.8) return `rgba(200, 150, 0, ${0.5 + intensity * 0.3})`;
            return `rgba(255, 50, 50, ${0.6 + intensity * 0.4})`;
        }

        /**
         * Render logs tab (synergy combo counter is already in HTML)
         */
        function renderLogsTab() {
            const logsContent = document.getElementById('logs-tab-content');
            if (!logsContent) return;

            // The synergy combo counter HTML is already in the tab content
            // This function ensures the counter is updated when tab is switched to
            updateSynergyComboDisplay();
        }

        // Tab switching handler
        function initStatsPanelTabs() {
            const statsPanel = document.getElementById('stats-panel');
            if (!statsPanel) return;

            // Tab switching
            statsPanel.querySelectorAll('.stats-panel-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    window.statsPanelState.activeTab = tab.dataset.tab;
                    updateStatsPanel();
                });
            });

            // Toggle button
            const toggleBtn = document.getElementById('stats-panel-toggle');
            if (toggleBtn) {
                toggleBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    window.statsPanelState.isVisible = !window.statsPanelState.isVisible;
                    toggleBtn.textContent = window.statsPanelState.isVisible ? '−' : '+';
                    updateStatsPanel();
                });
            }

            // Show button (when panel is hidden)
            const showBtn = document.getElementById('stats-panel-show-btn');
            if (showBtn) {
                showBtn.addEventListener('click', () => {
                    window.statsPanelState.isVisible = true;
                    const toggleBtn = document.getElementById('stats-panel-toggle');
                    if (toggleBtn) toggleBtn.textContent = '−';
                    updateStatsPanel();
                });
            }
        }


        function createNPCs() {
            for (let i = 0; i < NPC_COUNT; i++) {
                const type = ['hero', 'villain', 'civilian'][Math.floor(Math.random() * 3)];
                let color, emissiveColor, health, rank;

                switch (type) {
                    case 'hero':
                        color = 0x4444ff;
                        emissiveColor = 0x2222aa;
                        health = 80;
                        rank = 'C';
                        break;
                    case 'villain':
                        color = 0xff4444;
                        emissiveColor = 0xaa2222;
                        health = 100;
                        rank = 'C';
                        break;
                    default:
                        color = 0x999999;
                        emissiveColor = 0x000000;
                        health = 20;
                        rank = 'E';
                        break;
                }

                const npcGeometry = new THREE.CapsuleGeometry(0.7, 1.2, 4, 8);
                const npcMaterial = new THREE.MeshStandardMaterial({
                    color: color,
                    emissive: emissiveColor,
                    emissiveIntensity: 0.5
                });
                const npc = new THREE.Mesh(npcGeometry, npcMaterial);

                const x = THREE.MathUtils.randFloat(-WORLD_SIZE / 2, WORLD_SIZE / 2);
                const z = THREE.MathUtils.randFloat(-WORLD_SIZE / 2, WORLD_SIZE / 2);
                npc.position.set(x, 1.6, z);
                npc.castShadow = true;

                // Create waypoint route for NPCs (city navigation)
                const waypoints = [];
                if (gameState.buildings && gameState.buildings.length > 0) {
                    // Create 3-5 waypoints near buildings for pathfinding
                    const numWaypoints = 3 + Math.floor(Math.random() * 3);
                    for (let w = 0; w < numWaypoints; w++) {
                        const building = gameState.buildings[Math.floor(Math.random() * gameState.buildings.length)];
                        if (building) {
                            const waypointX = building.position.x + (Math.random() - 0.5) * 20;
                            const waypointZ = building.position.z + (Math.random() - 0.5) * 20;
                            waypoints.push(new THREE.Vector3(waypointX, 1.6, waypointZ));
                        }
                    }
                }
                // If no buildings, create random waypoints
                if (waypoints.length === 0) {
                    for (let w = 0; w < 3; w++) {
                        waypoints.push(new THREE.Vector3(
                            THREE.MathUtils.randFloat(-WORLD_SIZE / 2, WORLD_SIZE / 2),
                            1.6,
                            THREE.MathUtils.randFloat(-WORLD_SIZE / 2, WORLD_SIZE / 2)
                        ));
                    }
                }

                const npcState = {
                    mesh: npc,
                    healthBar: createHealthBar(),
                    type: type,
                    health: health,
                    maxHealth: health,
                    rank: rank,
                    stats: { // Add stats for combat
                        attack: (type === 'villain' ? 15 : 10)
                    },
                    attackCooldown: 0,
                    attackTarget: null,
                    state: 'wandering', // AI states: 'wandering', 'chasing', 'attacking', 'dying'
                    dyingTimer: 0,
                    wanderTarget: waypoints.length > 0 ? waypoints[0] : new THREE.Vector3(x, 1.6, z),
                    wanderTimer: Math.random() * 5,
                    waypoints: waypoints, // Store waypoint route
                    currentWaypointIndex: 0, // Current waypoint in route
                    factionId: type === 'villain' ? 'villain' : (type === 'hero' ? 'hero' : 'neutral'), // Faction for combat
                };

                npc.add(npcState.healthBar); // Attach health bar to the mesh
                npcState.healthBar.position.y = 2.2;

                // Initialize building behavior for NPC
                if (window.NPCBuildingBehavior) {
                    window.NPCBuildingBehavior.initNPCBehavior(npcState);
                }

                gameState.npcs.push(npcState);
                scene.add(npc);
            }
        }

        // -- AUDIO LOGIC --
        function initAudio() {
            if (isAudioInitialized) return;
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            isAudioInitialized = true;
        }

        /**
         * Enhanced playSound function with element-based and tier-based sounds
         */
        function playSound(type, options = {}) {
            if (!isAudioInitialized) return;
            if (!audioContext) return;

            const {
                element = 'PHYSICAL',
                tier = 'common',
                pitch = 1.0,
                volume = 0.1
            } = options;

            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);

            let frequency = 200;
            let duration = 0.1;
            let waveType = 'square';

            // Base frequency by type
            switch (type) {
                case 'shoot':
                    frequency = 400;
                    duration = 0.05;
                    waveType = 'triangle';
                    break;
                case 'hit':
                    frequency = 220;
                    duration = 0.15;
                    waveType = 'square';
                    break;
                case 'levelup':
                    frequency = 600;
                    duration = 0.3;
                    waveType = 'sine';
                    break;
                case 'skill_cast':
                    frequency = 300;
                    duration = 0.15;
                    waveType = 'sine';
                    break;
                case 'skill_ultimate':
                    frequency = 200;
                    duration = 0.4;
                    waveType = 'sawtooth';
                    break;
                case 'crit':
                    frequency = 800;
                    duration = 0.2;
                    waveType = 'sine';
                    break;
                case 'skill_ready':
                    frequency = 550;
                    duration = 0.1;
                    waveType = 'sine';
                    break;
            }

            // Adjust frequency based on element
            const elementFreqMultipliers = {
                'FIRE': 1.2,
                'ICE': 0.8,
                'LIGHTNING': 1.5,
                'SHADOW': 0.7,
                'LIGHT': 1.3,
                'ARCANE': 1.1,
                'PLASMA': 1.4,
                'ENERGY': 1.0
            };
            frequency *= (elementFreqMultipliers[element] || 1.0);

            // Adjust frequency based on tier
            const tierFreqMultipliers = {
                'common': 1.0,
                'uncommon': 1.1,
                'rare': 1.2,
                'epic': 1.3,
                'legendary': 1.5
            };
            frequency *= (tierFreqMultipliers[tier] || 1.0);

            // Apply pitch variation
            frequency *= pitch;

            oscillator.type = waveType;
            oscillator.frequency.setValueAtTime(frequency, audioContext.currentTime);

            if (type === 'hit') {
                oscillator.frequency.exponentialRampToValueAtTime(frequency * 0.5, audioContext.currentTime + duration);
            }

            gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.00001, audioContext.currentTime + duration);

            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration);
        }


        // ═══════════════════════════════════════════════════════════════════════════
        // INTERACTION SYSTEM - Handles F key interactions with doors and objects
        // ═══════════════════════════════════════════════════════════════════════════
        const InteractionSystem = {
            interactionRange: 3.0, // Maximum distance for interaction
            nearestDoor: null,
            interactionPrompt: null,

            init() {
                // Create interaction prompt UI element
                this.createInteractionPrompt();
            },

            createInteractionPrompt() {
                const prompt = document.createElement('div');
                prompt.id = 'interaction-prompt';
                prompt.style.cssText = `
                    position: fixed;
                    bottom: 100px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(0, 0, 0, 0.8);
                    color: #fff;
                    padding: 10px 20px;
                    border-radius: 8px;
                    border: 2px solid #00ff00;
                    font-family: monospace;
                    font-size: 14px;
                    z-index: 1000;
                    display: none;
                    pointer-events: none;
                `;
                prompt.textContent = 'Press F to interact';
                document.body.appendChild(prompt);
                this.interactionPrompt = prompt;
            },

            update(deltaTime) {
                if (!gameState.activeCharacter || !gameState.activeCharacter.mesh) return;

                const playerPos = gameState.activeCharacter.mesh.position;
                let nearestDistance = Infinity;
                let nearest = null;

                // Check if in interior - allow exit via red exit door
                if (window.InteriorSystem && window.InteriorSystem.isInInterior) {
                    const currentBuilding = window.InteriorSystem.currentBuilding;
                    if (currentBuilding && currentBuilding.exitDoorPosition) {
                        const distance = playerPos.distanceTo(currentBuilding.exitDoorPosition);
                        if (distance < this.interactionRange) {
                            // Show exit prompt
                            if (this.interactionPrompt) {
                                this.interactionPrompt.textContent = 'Press F to exit building';
                                this.interactionPrompt.style.display = 'block';
                            }
                            this.nearestDoor = { type: 'exit' };
                            return;
                        }
                    } else {
                        // Fallback: allow exit anywhere in interior
                        if (this.interactionPrompt) {
                            this.interactionPrompt.textContent = 'Press F to exit building';
                            this.interactionPrompt.style.display = 'block';
                        }
                        this.nearestDoor = { type: 'exit' };
                        return;
                    }
                }

                // Check door triggers in exterior
                if (gameState.doorTriggers && gameState.doorTriggers.length > 0) {
                    for (const door of gameState.doorTriggers) {
                        const distance = playerPos.distanceTo(door.position);
                        if (distance < this.interactionRange && distance < nearestDistance) {
                            nearestDistance = distance;
                            nearest = door;
                        }
                    }
                }

                this.nearestDoor = nearest;

                // Show/hide interaction prompt
                if (this.interactionPrompt) {
                    if (nearest) {
                        this.interactionPrompt.textContent = 'Press F to enter building';
                        this.interactionPrompt.style.display = 'block';
                    } else {
                        this.interactionPrompt.style.display = 'none';
                    }
                }
            },

            interact() {
                if (!this.nearestDoor) return;

                // Handle exit from interior
                if (this.nearestDoor.type === 'exit') {
                    if (window.InteriorSystem) {
                        window.InteriorSystem.exitBuilding();
                    }
                    return;
                }

                // Handle entering building
                if (this.nearestDoor.building) {
                    // Animate door opening
                    const door = this.nearestDoor.doorMesh;
                    if (door && door.userData.animationState) {
                        const animState = door.userData.animationState;
                        if (!animState.isAnimating) {
                            animState.isAnimating = true;
                            animState.isOpen = !animState.isOpen;
                            animState.targetRotation = animState.isOpen ? -Math.PI / 2 : 0; // -90 degrees when open
                        }
                    }
                    
                    if (window.InteriorSystem) {
                        window.InteriorSystem.enterBuilding(this.nearestDoor.building);
                    }
                }
            },

            updateDoorAnimations(deltaTime) {
                // Update all door animations
                if (!gameState.doorTriggers) return;
                
                for (const doorTrigger of gameState.doorTriggers) {
                    const door = doorTrigger.doorMesh;
                    if (!door || !door.userData.animationState) continue;
                    
                    const animState = door.userData.animationState;
                    if (!animState.isAnimating) continue;
                    
                    // Interpolate rotation
                    const rotationDiff = animState.targetRotation - animState.currentRotation;
                    if (Math.abs(rotationDiff) < 0.01) {
                        // Animation complete
                        animState.currentRotation = animState.targetRotation;
                        animState.isAnimating = false;
                    } else {
                        // Animate towards target
                        const rotationStep = animState.animationSpeed * deltaTime;
                        if (Math.abs(rotationDiff) <= rotationStep) {
                            animState.currentRotation = animState.targetRotation;
                            animState.isAnimating = false;
                        } else {
                            animState.currentRotation += Math.sign(rotationDiff) * rotationStep;
                        }
                    }
                    
                    // Apply rotation around pivot point (left edge of door)
                    const pivotOffset = door.userData.pivotOffset || new THREE.Vector3(-2, 0, 0);
                    const worldPivot = door.position.clone().add(pivotOffset);
                    
                    // Reset rotation and position
                    door.rotation.y = 0;
                    door.position.sub(pivotOffset);
                    
                    // Apply rotation around pivot
                    door.rotation.y = animState.currentRotation;
                    
                    // Rotate pivot offset and add back
                    const rotatedPivot = pivotOffset.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), animState.currentRotation);
                    door.position.add(rotatedPivot);
                }
            }
        };

        // -- INPUT HANDLING --
        function setupInputListeners() {
            document.addEventListener('keydown', (event) => {
                initAudio(); // Initialize audio on first user interaction
                keys[event.key.toLowerCase()] = true;
                
                // Handle F key for interactions
                if (event.key.toLowerCase() === 'f') {
                    InteractionSystem.interact();
                }
            });
            document.addEventListener('keyup', (event) => { keys[event.key.toLowerCase()] = false; });
            document.addEventListener('keydown', (event) => {
                if (['1', '2', '3'].includes(event.key)) {
                    activateSkillBySlot(parseInt(event.key));
                }
            });
        }

        // -- PLAYER LOGIC --
        const raycaster = new THREE.Raycaster(); // For ground collision

        function updatePlayer(deltaTime) {
            if (!gameState.activeCharacter || gameState.activeCharacter.currentHealth === undefined || gameState.activeCharacter.currentHealth <= 0) return; // Stop player movement on death

            const { mesh } = gameState.activeCharacter;
            const playerHeight = 1.7; // Approximate height of player capsule for ground offset

            // --- Rotation ---
            // Joystick X controls rotation, keyboard A/D also work
            const rotationInput = (window.joystickState && window.joystickState.active)
                ? window.joystickState.x * 2.0  // Scale joystick rotation
                : 0;

            if (keys['a'] || keys['arrowleft'] || rotationInput < -0.1) {
                const rotSpeed = rotationInput < -0.1 ? Math.abs(rotationInput) * PLAYER_ROTATION_SPEED : PLAYER_ROTATION_SPEED;
                mesh.rotation.y += rotSpeed * deltaTime;
            }
            if (keys['d'] || keys['arrowright'] || rotationInput > 0.1) {
                const rotSpeed = rotationInput > 0.1 ? rotationInput * PLAYER_ROTATION_SPEED : PLAYER_ROTATION_SPEED;
                mesh.rotation.y -= rotSpeed * deltaTime;
            }

            // --- Movement ---
            let moveVector = new THREE.Vector3(0, 0, 0);
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(mesh.quaternion);

            // Joystick Y controls forward/backward movement
            const joystickY = (window.joystickState && window.joystickState.active) ? window.joystickState.y : 0;

            if (keys['w'] || keys['arrowup'] || joystickY < -0.1) {
                const moveAmount = joystickY < -0.1 ? Math.abs(joystickY) : 1;
                moveVector.add(forward.clone().multiplyScalar(moveAmount));
            }
            if (keys['s'] || keys['arrowdown'] || joystickY > 0.1) {
                const moveAmount = joystickY > 0.1 ? joystickY : 1;
                moveVector.sub(forward.clone().multiplyScalar(moveAmount));
            }

            // Apply speed boost if active
            const speedMultiplier = gameState.activeCharacter.speedBoost ? 1.5 : 1.0;
            // Check vehicle multiplier (defaults to 1.0 if not mounted)
            const vehicleMult = gameState.activeCharacter.speedMultiplier || 1.0;
            // Apply vehicle multiplier to speed
            const currentSpeed = (keys['shift'] ? PLAYER_SPRINT_SPEED : PLAYER_BASE_SPEED) * speedMultiplier * vehicleMult;

            if (moveVector.lengthSq() > 0) {
                moveVector.normalize();
                moveVector.multiplyScalar(currentSpeed * deltaTime);

                // --- Wall Collision Detection ---
                // We check X and Z movement separately to allow sliding along walls
                const originalPosition = mesh.position.clone();

                // Move on X axis and check for collisions
                mesh.position.x += moveVector.x;
                let collisionX = false;
                const playerBoxX = new THREE.Box3().setFromObject(mesh);
                for (const collider of gameState.colliders) {
                    if (playerBoxX.intersectsBox(collider)) {
                        collisionX = true;
                        break;
                    }
                }
                if (collisionX) {
                    mesh.position.x = originalPosition.x; // Revert X movement
                }

                // Move on Z axis and check for collisions
                mesh.position.z += moveVector.z;
                let collisionZ = false;
                const playerBoxZ = new THREE.Box3().setFromObject(mesh);
                for (const collider of gameState.colliders) {
                    if (playerBoxZ.intersectsBox(collider)) {
                        collisionZ = true;
                        break;
                    }
                }
                if (collisionZ) {
                    mesh.position.z = originalPosition.z; // Revert Z movement
                }
            }

            // --- Jump Physics ---
            // Skip normal jump/ground physics if flying
            if (!gameState.activeCharacter.isFlying) {
                if (gameState.activeCharacter.isJumping) {
                    gameState.activeCharacter.jumpVelocity -= 30 * deltaTime; // Gravity
                    mesh.position.y += gameState.activeCharacter.jumpVelocity * deltaTime;

                    // Check if we hit the ground
                    if (gameState.ground) {
                        const rayOrigin = new THREE.Vector3(mesh.position.x, mesh.position.y + 5, mesh.position.z);
                        raycaster.set(rayOrigin, new THREE.Vector3(0, -1, 0));
                        const intersects = raycaster.intersectObject(gameState.ground);

                        if (intersects.length > 0) {
                            const groundHeight = intersects[0].point.y;
                            if (mesh.position.y <= groundHeight + playerHeight) {
                                mesh.position.y = groundHeight + playerHeight;
                                gameState.activeCharacter.isJumping = false;
                                gameState.activeCharacter.onGround = true;
                                gameState.activeCharacter.jumpVelocity = 0;
                            }
                        }
                    }
                } else {
                    // --- Ground Collision (Terrain Following) ---
                    if (gameState.ground) {
                        const rayOrigin = new THREE.Vector3(mesh.position.x, 50, mesh.position.z);
                        raycaster.set(rayOrigin, new THREE.Vector3(0, -1, 0));
                        const intersects = raycaster.intersectObject(gameState.ground);

                        if (intersects.length > 0) {
                            const groundHeight = intersects[0].point.y;
                            const targetY = groundHeight + playerHeight;
                            if (Math.abs(mesh.position.y - targetY) < 0.1) {
                                mesh.position.y = targetY;
                                gameState.activeCharacter.onGround = true;
                            } else {
                                mesh.position.y = targetY;
                                gameState.activeCharacter.onGround = true;
                            }
                        }
                    }
                }
            }


            // Boundary checks
            mesh.position.x = Math.max(-WORLD_SIZE / 2, Math.min(WORLD_SIZE / 2, mesh.position.x));
            mesh.position.z = Math.max(-WORLD_SIZE / 2, Math.min(WORLD_SIZE / 2, mesh.position.z));

            // Combat system hooks
            if (keys[' ']) {
                firePrimaryPower();
                keys[' '] = false; // Prevents firing every frame, acts as a single shot trigger
            }

            // -- Cooldown Management --
            const cooldowns = PlayerState.current.ability_cooldowns;
            if (cooldowns.primary_timer > 0) {
                cooldowns.primary_timer -= deltaTime;
            }
        }


        // -- PARTY LOGIC --
        // Party members follow the active character
        function updatePartyMembers(deltaTime) {
            const playerMesh = gameState.activeCharacter.mesh;
            const formationDistance = 3.5;
            const AGGRO_RADIUS = 30;
            const SHOOTING_RANGE = 25;

            gameState.partyMembers.forEach((member, index) => {
                // Cooldowns
                if (member.attackCooldown > 0) {
                    member.attackCooldown -= deltaTime;
                }

                // --- AI State Logic ---
                // 1. Find a target if we don't have one
                if (!member.attackTarget || member.attackTarget.health <= 0) {
                    member.attackTarget = null;
                    member.state = 'following'; // Default state
                    let closestDistance = AGGRO_RADIUS;

                    for (const npc of gameState.npcs) {
                        if (npc.type === 'villain') {
                            const distance = member.mesh.position.distanceTo(npc.mesh.position);
                            if (distance < closestDistance) {
                                closestDistance = distance;
                                member.attackTarget = npc;
                            }
                        }
                    }
                    if (member.attackTarget) {
                        member.state = 'chasing';
                    }
                }

                // 2. State transitions based on target distance
                if (member.attackTarget) {
                    const distanceToTarget = member.mesh.position.distanceTo(member.attackTarget.mesh.position);
                    if (distanceToTarget < SHOOTING_RANGE) {
                        member.state = 'attacking';
                    } else if (distanceToTarget < AGGRO_RADIUS) {
                        member.state = 'chasing';
                    } else {
                        // Target is too far, drop it
                        member.attackTarget = null;
                        member.state = 'following';
                    }
                }

                // 3. Actions based on state
                switch (member.state) {
                    case 'attacking':
                        if (member.attackTarget && member.attackTarget.health > 0) {
                            member.mesh.lookAt(member.attackTarget.mesh.position);
                            if (member.attackCooldown <= 0) {
                                const projectileColor = (member.details.name === "Missy") ? 0xffc0cb : 0x9400d3;
                                fireProjectile(member.mesh, member.attackTarget.mesh.position, 'hero', member.stats.attack, projectileColor);
                                member.attackCooldown = member.stats.attack_cooldown;
                            }
                        } else {
                            member.state = 'following';
                            member.attackTarget = null;
                        }
                        break;

                    case 'chasing':
                        if (member.attackTarget) {
                            const direction = new THREE.Vector3().subVectors(member.attackTarget.mesh.position, member.mesh.position).normalize();
                            member.mesh.position.add(direction.multiplyScalar(deltaTime * (PLAYER_BASE_SPEED * 0.8)));
                            member.mesh.lookAt(member.attackTarget.mesh.position);
                        }
                        break;

                    case 'following':
                    default:
                        // Define a target position in formation around the player
                        const side = (index === 0) ? -1 : 1; // Left or Right of player
                        const offset = new THREE.Vector3(side * formationDistance, 0, formationDistance);
                        offset.applyQuaternion(playerMesh.quaternion); // Rotate offset to be behind player
                        const targetPosition = new THREE.Vector3().addVectors(playerMesh.position, offset);

                        // Ground collision for the target position
                        if (gameState.ground) {
                            const playerHeight = 1.6;
                            const rayOrigin = new THREE.Vector3(targetPosition.x, 50, targetPosition.z);
                            raycaster.set(rayOrigin, new THREE.Vector3(0, -1, 0));
                            const intersects = raycaster.intersectObject(gameState.ground);
                            if (intersects.length > 0) {
                                targetPosition.y = intersects[0].point.y + playerHeight;
                            }
                        }

                        // Move towards the target position
                        const distanceToTarget = member.mesh.position.distanceTo(targetPosition);
                        if (distanceToTarget > 1.5) {
                            member.mesh.position.lerp(targetPosition, deltaTime * 2.0);
                        }
                        member.mesh.lookAt(playerMesh.position);
                        break;
                }
            });
        }


        function updateDestructibleEnvironment(deltaTime) {
            const REGENERATION_TIME = 40; // 40 seconds to regenerate

            for (const obj of gameState.destructibleObjects) {
                if (obj.isDestroyed) {
                    obj.regenerationTimer -= deltaTime;
                    if (obj.regenerationTimer <= 0) {
                        // Regenerate the object
                        obj.isDestroyed = false;
                        obj.mesh.visible = true;
                        obj.health = obj.maxHealth;

                        // Add collider back
                        if (obj.collider && !gameState.colliders.includes(obj.collider)) {
                            gameState.colliders.push(obj.collider);
                        }

                        // Restore scale for shrink effect
                        obj.mesh.scale.copy(obj.originalScale);
                    }
                } else if (obj.health <= 0 && !obj.isDestroyed) {
                    // Destroy the object
                    obj.isDestroyed = true;
                    obj.mesh.visible = false; // Simple destruction: just hide it
                    obj.regenerationTimer = REGENERATION_TIME;

                    // Remove collider
                    const colliderIndex = gameState.colliders.indexOf(obj.collider);
                    if (colliderIndex > -1) {
                        gameState.colliders.splice(colliderIndex, 1);
                    }
                }

                // Update health bar
                if (obj.healthBar) {
                    obj.healthBar.quaternion.copy(camera.quaternion);
                    const fgBar = obj.healthBar.getObjectByName('fgBar');
                    if (fgBar) {
                        const healthPercent = obj.health / obj.maxHealth;
                        fgBar.scale.x = Math.max(0, healthPercent);
                        fgBar.position.x = -0.75 * (1 - fgBar.scale.x);
                    }
                    obj.healthBar.visible = !obj.isDestroyed && obj.health > 0 && obj.health < obj.maxHealth;
                }
            }
        }

        // -- NPC LOGIC -- SIMPLIFIED VERSION (removed complex health tracking)
        function updateNPCs(deltaTime) {
            // Early return if gameState or npcs array is invalid
            if (!gameState || !gameState.npcs || !Array.isArray(gameState.npcs)) {
                return;
            }

            // Early return if activeCharacter doesn't exist or has no mesh
            if (!gameState.activeCharacter || !gameState.activeCharacter.mesh) {
                return;
            }

            const playerMesh = gameState.activeCharacter.mesh;
            const AGGRO_RADIUS = 40;
            const SHOOTING_RANGE = 35;
            const ATTACK_COOLDOWN = 1.5; // seconds

            for (let i = gameState.npcs.length - 1; i >= 0; i--) {
                const npc = gameState.npcs[i];

                // Safety check: ensure npc exists and has required properties
                if (!npc || !npc.mesh) {
                    gameState.npcs.splice(i, 1);
                    continue;
                }

                // Handle death animation state
                if (npc.state === 'dying') {
                    npc.dyingTimer -= deltaTime;
                    const scale = Math.max(0, npc.dyingTimer / 0.5);
                    npc.mesh.scale.set(scale, scale, scale);
                    if (npc.dyingTimer <= 0) {
                        scene.remove(npc.mesh);
                        gameState.npcs.splice(i, 1);
                    }
                    continue;
                }

                // Update building behavior
                if (window.NPCBuildingBehavior) {
                    window.NPCBuildingBehavior.updateNPCBehavior(npc, deltaTime);
                }

                // Skip normal AI if NPC is inside a building
                if (npc.buildingBehavior && npc.buildingBehavior.state === 'inside') {
                    continue;
                }

                if (npc.attackCooldown > 0) {
                    npc.attackCooldown -= deltaTime;
                }

                // --- Simplified Combat AI for Heroes and Villains ---
                if (npc.type === 'villain' || npc.type === 'hero') {
                    // 1. Check if current target is still valid (only check if mesh exists)
                    if (npc.attackTarget && !npc.attackTarget.mesh) {
                        npc.attackTarget = null;
                        npc.state = 'wandering';
                    }

                    // 2. Find a new target if we don't have one
                    if (!npc.attackTarget) {
                        let closestDistance = AGGRO_RADIUS;
                        let closestTarget = null;

                        // Villains target player, then party, then heroes
                        if (npc.type === 'villain') {
                            // Target Player - only check if mesh exists
                            if (playerMesh) {
                                const distToPlayer = npc.mesh.position.distanceTo(playerMesh.position);
                                if (distToPlayer < closestDistance) {
                                    closestDistance = distToPlayer;
                                    closestTarget = {
                                        mesh: playerMesh,
                                        type: 'player'
                                    };
                                }
                            }

                            // Target Party - only check if mesh exists
                            if (Array.isArray(gameState.partyMembers)) {
                                for (let j = 0; j < gameState.partyMembers.length; j++) {
                                    const p = gameState.partyMembers[j];
                                    if (p && p.mesh) {
                                        const dist = npc.mesh.position.distanceTo(p.mesh.position);
                                        if (dist < closestDistance) {
                                            closestDistance = dist;
                                            closestTarget = {
                                                mesh: p.mesh,
                                                type: 'hero'
                                            };
                                        }
                                    }
                                }
                            }

                            // Target Heroes - only check if mesh and health exist
                            for (let j = 0; j < gameState.npcs.length; j++) {
                                const otherNpc = gameState.npcs[j];
                                if (otherNpc && otherNpc !== npc && otherNpc.type === 'hero' && otherNpc.mesh && otherNpc.health > 0) {
                                    const dist = npc.mesh.position.distanceTo(otherNpc.mesh.position);
                                    if (dist < closestDistance) {
                                        closestDistance = dist;
                                        closestTarget = {
                                            mesh: otherNpc.mesh,
                                            health: otherNpc.health,
                                            type: 'hero'
                                        };
                                    }
                                }
                            }
                        }
                        // Heroes only target Villains
                        else if (npc.type === 'hero') {
                            for (let j = 0; j < gameState.npcs.length; j++) {
                                const otherNpc = gameState.npcs[j];
                                if (otherNpc && otherNpc !== npc && otherNpc.type === 'villain' && otherNpc.mesh && otherNpc.health > 0) {
                                    const dist = npc.mesh.position.distanceTo(otherNpc.mesh.position);
                                    if (dist < closestDistance) {
                                        closestDistance = dist;
                                        closestTarget = {
                                            mesh: otherNpc.mesh,
                                            health: otherNpc.health,
                                            type: 'villain'
                                        };
                                    }
                                }
                            }
                        }

                        if (closestTarget) {
                            npc.attackTarget = closestTarget;
                            npc.state = 'chasing';
                        }
                    }

                    // 3. State transitions based on target distance (no health checks)
                    if (npc.attackTarget && npc.attackTarget.mesh) {
                        const distanceToTarget = npc.mesh.position.distanceTo(npc.attackTarget.mesh.position);
                        if (distanceToTarget < SHOOTING_RANGE) {
                            npc.state = 'attacking';
                        } else if (distanceToTarget < AGGRO_RADIUS) {
                            npc.state = 'chasing';
                        } else {
                            npc.attackTarget = null;
                            npc.state = 'wandering';
                        }
                    }

                    // 4. Actions based on state
                    switch (npc.state) {
                        case 'attacking':
                            if (npc.attackTarget && npc.attackTarget.mesh) {
                                npc.mesh.lookAt(npc.attackTarget.mesh.position);
                                if (npc.attackCooldown <= 0) {
                                    const projectileColor = npc.type === 'villain' ? 0xff4444 : 0x4444ff;
                                    fireProjectile(npc.mesh, npc.attackTarget.mesh.position, npc.type, npc.stats.attack, projectileColor);
                                    npc.attackCooldown = ATTACK_COOLDOWN;
                                }
                            } else {
                                npc.attackTarget = null;
                                npc.state = 'wandering';
                            }
                            break;
                        case 'chasing':
                            if (npc.attackTarget && npc.attackTarget.mesh) {
                                const direction = new THREE.Vector3().subVectors(npc.attackTarget.mesh.position, npc.mesh.position).normalize();
                                npc.mesh.position.add(direction.multiplyScalar(deltaTime * 5));
                                npc.mesh.lookAt(npc.attackTarget.mesh.position);
                            } else {
                                npc.attackTarget = null;
                                npc.state = 'wandering';
                            }
                            break;
                        case 'wandering':
                            // Use waypoint system if available
                            if (npc.waypoints && npc.waypoints.length > 0) {
                                const currentWaypoint = npc.waypoints[npc.currentWaypointIndex];
                                const distanceToWaypoint = npc.mesh.position.distanceTo(currentWaypoint);
                                
                                if (distanceToWaypoint < 2.0) {
                                    // Reached waypoint, move to next
                                    npc.currentWaypointIndex = (npc.currentWaypointIndex + 1) % npc.waypoints.length;
                                    npc.wanderTarget = npc.waypoints[npc.currentWaypointIndex];
                                } else {
                                    // Move towards current waypoint
                                    npc.wanderTarget = currentWaypoint;
                                }
                            } else {
                                // Fallback to random wandering
                                npc.wanderTimer -= deltaTime;
                                if (npc.wanderTimer <= 0) {
                                    const range = 20;
                                    npc.wanderTarget.set(
                                        npc.mesh.position.x + THREE.MathUtils.randFloat(-range, range),
                                        npc.mesh.position.y,
                                        npc.mesh.position.z + THREE.MathUtils.randFloat(-range, range)
                                    );
                                    npc.wanderTimer = 3 + Math.random() * 4;
                                }
                            }
                            
                            const wanderDir = new THREE.Vector3().subVectors(npc.wanderTarget, npc.mesh.position);
                            if (wanderDir.length() > 1) {
                                wanderDir.normalize();
                                const speed = npc.type === 'civilian' ? 1.5 : 2.0;
                                npc.mesh.position.add(wanderDir.multiplyScalar(deltaTime * speed));
                                npc.mesh.lookAt(npc.wanderTarget);
                            }
                            break;
                    }
                } else {
                    // --- Default Wandering AI for Civilians ---
                    npc.wanderTimer -= deltaTime;
                    if (npc.wanderTimer <= 0) {
                        const range = 20;
                        npc.wanderTarget.set(
                            npc.mesh.position.x + THREE.MathUtils.randFloat(-range, range),
                            npc.mesh.position.y,
                            npc.mesh.position.z + THREE.MathUtils.randFloat(-range, range)
                        );
                        npc.wanderTimer = 3 + Math.random() * 4;
                    }

                    const direction = new THREE.Vector3().subVectors(npc.wanderTarget, npc.mesh.position);
                    if (direction.length() > 1) {
                        direction.normalize();
                        npc.mesh.position.add(direction.multiplyScalar(deltaTime * 2));
                        npc.mesh.lookAt(npc.wanderTarget);
                    }
                }
            }
        }

        // -- COMBAT & PROJECTILE LOGIC --
        // -- COMBAT & PROJECTILE LOGIC --
        /**
         * Enhanced fireProjectile function using ProjectileSystem
         */
        function fireProjectile(firer, targetPosition, team, damage, color = 0xffff00, options = {}) {
            const startPosition = firer.position.clone().add(new THREE.Vector3(0, 1.5, 0));
            const direction = new THREE.Vector3().subVectors(targetPosition, startPosition).normalize();

            // Position slightly in front of firer
            const spawnPosition = startPosition.clone().add(direction.clone().multiplyScalar(2.0));

            // Extract options or use defaults
            const {
                tier = 'common',
                shape = 'sphere',
                element = 'PHYSICAL',
                speed = 80.0,
                lifetime = 3.0,
                trailEnabled = true,
                glowEnabled = true,
                rotationSpeed = 0
            } = options;

            // Create projectile using ProjectileSystem
            const projectile = projectileSystem.createProjectile({
                position: spawnPosition,
                direction: direction,
                speed: speed,
                damage: damage,
                team: team,
                color: color,
                tier: tier,
                shape: shape,
                element: element,
                lifetime: lifetime,
                trailEnabled: trailEnabled,
                glowEnabled: glowEnabled,
                rotationSpeed: rotationSpeed
            });

            // Also add to gameState.projectiles for compatibility with existing collision code
            const projectileRef = {
                mesh: projectile.mesh,
                velocity: projectile.velocity,
                lifetime: projectile.lifetime,
                team: projectile.team,
                damage: projectile.damage,
                projectileSystemRef: projectile // Reference to ProjectileSystem projectile
            };
            gameState.projectiles.push(projectileRef);

            return projectileRef; // Return for homing assignment
        }

        function firePrimaryPower() {
            // Safety check for activeCharacter/player
            if (!gameState.activeCharacter || !gameState.player || !gameState.player.mesh) {
                return;
            }

            // Only A1 uses sword swings, others keep projectiles
            const characterId = gameState.activeCharacter.characterId || 'A1';

            if (characterId === 'A1') {
                // Sword swing attack for A1
                // Check if the ability is on cooldown
                if (PlayerState.current.ability_cooldowns.primary_timer > 0) return;

                // Set the cooldown
                PlayerState.current.ability_cooldowns.primary_timer = PlayerState.current.ability_cooldowns.primary_duration;

                // Track combo state
                const now = Date.now();
                const timeSinceLastAttack = now - gameState.comboState.lastBasicAttackTime;

                // Reset combo if window expired
                if (timeSinceLastAttack > gameState.comboState.comboWindow) {
                    gameState.comboState.basicAttackCount = 0;
                }

                // Increment combo count
                gameState.comboState.basicAttackCount = Math.min(
                    gameState.comboState.basicAttackCount + 1,
                    gameState.comboState.maxComboCount
                );
                gameState.comboState.lastBasicAttackTime = now;

                // Show combo indicator
                if (typeof showComboIndicator === 'function') {
                    showComboIndicator(gameState.comboState.basicAttackCount);
                }

                const player = gameState.player.mesh;

                // Execute sword swing
                if (swordSwingSystem) {
                    swordSwingSystem.executeSwing(player, characterId);
                    playSound('skill_cast', { element: 'PHYSICAL', tier: 'common' });
                }
            } else {
                // Projectile attack for Missy and Unique
                // Check if the ability is on cooldown
                if (PlayerState.current.ability_cooldowns.primary_timer > 0) return;

                // Set the cooldown
                PlayerState.current.ability_cooldowns.primary_timer = PlayerState.current.ability_cooldowns.primary_duration;

                // Track combo state
                const now = Date.now();
                const timeSinceLastAttack = now - gameState.comboState.lastBasicAttackTime;

                // Reset combo if window expired
                if (timeSinceLastAttack > gameState.comboState.comboWindow) {
                    gameState.comboState.basicAttackCount = 0;
                }

                // Increment combo count
                gameState.comboState.basicAttackCount = Math.min(
                    gameState.comboState.basicAttackCount + 1,
                    gameState.comboState.maxComboCount
                );
                gameState.comboState.lastBasicAttackTime = now;

                // Show combo indicator
                if (typeof showComboIndicator === 'function') {
                    showComboIndicator(gameState.comboState.basicAttackCount);
                }

                // Safety check before accessing player mesh
                if (!gameState.player || !gameState.player.mesh) return;

                const player = gameState.player.mesh;
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(player.quaternion);

                // Find nearest enemy for homing
                let nearestEnemy = null;
                let nearestDistance = Infinity;
                for (const npc of gameState.npcs) {
                    if (npc.type === 'villain' && npc.health > 0) {
                        const dist = player.position.distanceTo(npc.mesh.position);
                        if (dist < nearestDistance && dist < 50) {
                            nearestDistance = dist;
                            nearestEnemy = npc;
                        }
                    }
                }

                // Aim at nearest enemy or far away
                const targetPosition = nearestEnemy
                    ? nearestEnemy.mesh.position.clone().add(new THREE.Vector3(0, 1, 0))
                    : player.position.clone().add(forward.multiplyScalar(200));

                const projectile = fireProjectile(player, targetPosition, 'player', (gameState.player && gameState.player.effectiveStats) ? gameState.player.effectiveStats.attack : 100, 0x00ffff);

                // Add homing target if enemy found
                if (nearestEnemy && projectile && projectile.projectileSystemRef) {
                    projectile.projectileSystemRef.homingTarget = nearestEnemy;
                } else if (nearestEnemy && projectile) {
                    projectile.homingTarget = nearestEnemy;
                }

                playSound('shoot');
            }
        }

        // ═══════════════════════════════════════════════════════════════
        // PHASE 2.3: SKILL CASTING - Updated to use SkillLibrary
        // ═══════════════════════════════════════════════════════════════
        function activateSkillBySlot(slotNum) {
            if (gameState.activeCharacter.currentHealth <= 0) return;

            const characterId = gameState.activeCharacter.characterId;
            // Only S1, S2, S3 slots exist - X1/X2 skills are equipped to these slots
            const slotKey = `S${slotNum}`;

            // Phase 2.3: Use SkillLibrary instead of direct arrays
            const skillLib = window.skillLibrary || skillLibrary;
            if (!skillLib) {
                console.error('SkillLibrary not available!');
                return;
            }

            // Check if character has cooldowns initialized
            if (!gameState.skillCooldowns[characterId]) {
                gameState.skillCooldowns[characterId] = {};
            }

            const cooldown = gameState.skillCooldowns[characterId][slotKey] || 0;
            if (cooldown > 0) {
                console.log(`${slotKey} is on cooldown for ${cooldown.toFixed(1)}s`);
                return;
            }

            // Get equipped skill from SkillLibrary
            const skillData = skillLib.getEquippedSkill(characterId, slotKey);
            if (!skillData) {
                console.log(`No skill equipped in slot ${slotKey} for ${characterId}`);
                return;
            }

            // Check if skill is unlocked
            const unlocked = skillLib.getUnlockedSkills(characterId);
            if (!unlocked.find(s => s.id === skillData.id)) {
                console.log(`Skill ${skillData.name} is locked for ${characterId}`);
                return;
            }

            // Execute the skill and set cooldown
            console.log(`⚔️ Activating ${characterId}'s skill: ${skillData.name} (${skillData.id})`);

            // Trigger attack animation on 3D sprite if available
            if (gameState.activeCharacter && gameState.activeCharacter.sprite3D) {
                gameState.activeCharacter.sprite3D.playAnimation('attack');
            }

            // Apply mastery bonuses
            const masteryBonuses = skillLib.getMasteryBonuses(characterId, skillData.id);
            const originalDamage = Array.isArray(skillData.damage) ? [...skillData.damage] : skillData.damage;
            const originalCooldown = skillData.cooldown;

            // Apply damage bonus
            if (masteryBonuses.damageBonus > 0) {
                if (Array.isArray(skillData.damage)) {
                    skillData.damage = skillData.damage.map(d => d * (1 + masteryBonuses.damageBonus));
                } else {
                    skillData.damage = (skillData.damage || 0) * (1 + masteryBonuses.damageBonus);
                }
            }

            // Apply cooldown reduction
            const reducedCooldown = originalCooldown * (1 - masteryBonuses.cooldownReduction);

            // Safety check for player before emitting particles
            if (!gameState.player || !gameState.player.mesh) return;

            // Emit particles for skill activation
            const playerPos = gameState.player.mesh.position.clone().add(new THREE.Vector3(0, 1.5, 0));
            const skillColor = parseInt(skillData.color.replace('#', '0x'), 16) || 0xffffff;
            if (skillData.tier === 'legendary') {
                emitUltimateParticles(playerPos, skillColor, 50);
                applyScreenShake(0.3, 0.5);
            } else if (skillData.tier === 'epic') {
                emitSkillParticles(playerPos, skillColor, 30);
                applyScreenShake(0.2, 0.3);
            } else {
                emitSkillParticles(playerPos, skillColor, 15);
                applyScreenShake(0.1, 0.2);
            }

            executeSkillEffect(skillData);

            // Set cooldown with mastery reduction
            gameState.skillCooldowns[characterId][slotKey] = reducedCooldown;
            if (window.HUD) {
                if (typeof window.HUD.setSkillReady === 'function') {
                    window.HUD.setSkillReady(slotKey, false);
                }
                if (typeof window.HUD.updateSkillCooldown === 'function') {
                    window.HUD.updateSkillCooldown(slotKey, reducedCooldown);
                }
            }

            // Gain mastery XP
            skillLib.gainSkillMasteryXP(characterId, skillData.id, 10, 0);

            // Check for synergy combo
            const synergies = getAvailableSynergies(characterId);
            const now = Date.now();
            const timeSinceLastSynergy = now - gameState.synergyComboState.lastSynergyTime;

            // Check if this skill is part of a synergy
            const isSynergy = synergies.some(s => s.to === slotKey);
            if (isSynergy && timeSinceLastSynergy < gameState.synergyComboState.comboWindow) {
                // Continue combo
                gameState.synergyComboState.currentCombo++;
                gameState.synergyComboState.totalCombos++;
                if (gameState.synergyComboState.currentCombo > gameState.synergyComboState.maxCombo) {
                    gameState.synergyComboState.maxCombo = gameState.synergyComboState.currentCombo;
                }
                // Add to combo sequence
                gameState.skillComboSequence.push({
                    slotKey: slotKey,
                    skillId: skillData.id,
                    skillName: skillData.name,
                    icon: skillData.icon || '⚔️',
                    timestamp: now
                });
            } else if (isSynergy) {
                // Start new combo
                gameState.synergyComboState.currentCombo = 1;
                gameState.synergyComboState.totalCombos++;
                // Reset sequence and add first skill
                gameState.skillComboSequence = [{
                    slotKey: slotKey,
                    skillId: skillData.id,
                    skillName: skillData.name,
                    icon: skillData.icon || '⚔️',
                    timestamp: now
                }];
            } else if (timeSinceLastSynergy > gameState.synergyComboState.comboWindow) {
                // Reset combo if window expired
                gameState.synergyComboState.currentCombo = 0;
                gameState.skillComboSequence = [];
            }

            if (isSynergy) {
                gameState.synergyComboState.lastSynergyTime = now;
                // Show visual combo chain
                showSkillComboChain(gameState.skillComboSequence);
            }

            // Show skill name popup
            if (typeof showSkillNamePopup === 'function') {
                showSkillNamePopup(skillData);
            }

            // Play skill sound based on tier and element
            const soundType = skillData.tier === 'legendary' ? 'skill_ultimate' : 'skill_cast';
            playSound(soundType, {
                element: skillData.element || 'PHYSICAL',
                tier: skillData.tier || 'common',
                pitch: 1.0 + (Math.random() - 0.5) * 0.1
            });
        }

        /**
         * Get combo multiplier based on current combo state
         */
        function getComboMultiplier() {
            const now = Date.now();
            const timeSinceLastAttack = now - gameState.comboState.lastBasicAttackTime;

            // No combo if window expired
            if (timeSinceLastAttack > gameState.comboState.comboWindow) {
                return 1.0;
            }

            const comboCount = gameState.comboState.basicAttackCount;

            // Return multiplier based on combo count
            if (comboCount >= 5) return 1.50; // 50% bonus
            if (comboCount >= 3) return 1.30; // 30% bonus
            if (comboCount >= 1) return 1.15; // 15% bonus
            return 1.0; // No combo
        }

        function executeSkillEffect(skillData) {
            const player = gameState.activeCharacter.mesh;
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(player.quaternion);

            // Get combo multiplier and apply to damage
            const comboMultiplier = getComboMultiplier();
            if (comboMultiplier > 1.0) {
                // Apply combo multiplier to skill damage
                if (Array.isArray(skillData.damage)) {
                    skillData.damage = skillData.damage.map(d => d * comboMultiplier);
                } else {
                    skillData.damage = (skillData.damage || 0) * comboMultiplier;
                }

                // Show combo activation indicator
                if (typeof showComboIndicator === 'function') {
                    showComboIndicator(gameState.comboState.basicAttackCount, true);
                }

                // Reset combo after skill use
                gameState.comboState.basicAttackCount = 0;
            }

            // Generic projectile logic with enhanced visuals
            if (skillData.projectileCount > 0) {
                // Find nearest enemies for homing
                const enemies = gameState.npcs.filter(npc =>
                    npc.type === 'villain' && npc.health > 0
                ).sort((a, b) => {
                    const distA = player.position.distanceTo(a.mesh.position);
                    const distB = player.position.distanceTo(b.mesh.position);
                    return distA - distB;
                });

                for (let i = 0; i < skillData.projectileCount; i++) {
                    // Add a slight spread for multi-shot skills
                    const spreadAngle = (skillData.projectileCount > 1) ? (-0.1 + 0.2 * (i / (skillData.projectileCount - 1))) : 0;
                    const spreadQuaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), spreadAngle);
                    const direction = forward.clone().applyQuaternion(spreadQuaternion);

                    // Target nearest enemy or forward direction
                    const targetEnemy = enemies[i % enemies.length];
                    const targetPosition = targetEnemy && targetEnemy.mesh.position.distanceTo(player.position) < 50
                        ? targetEnemy.mesh.position.clone().add(new THREE.Vector3(0, 1, 0))
                        : player.position.clone().add(direction.multiplyScalar(200));

                    const damage = Array.isArray(skillData.damage) ? skillData.damage[0] : (skillData.damage || ((gameState.player && gameState.player.effectiveStats) ? gameState.player.effectiveStats.attack : 100));
                    const color = parseInt(skillData.color.replace('#', '0x'), 16);

                    // Determine projectile shape based on skill
                    let shape = 'sphere';
                    if (skillData.shape === 'xwave' || skillData.shape === 'wave') shape = 'wave';
                    else if (skillData.shape === 'crescent') shape = 'crescent';
                    else if (skillData.shape === 'star') shape = 'star';

                    setTimeout(() => {
                        const projectile = fireProjectile(player, targetPosition, 'player', damage, color, {
                            tier: skillData.tier || 'common',
                            shape: shape,
                            element: skillData.element || 'PHYSICAL',
                            speed: 80.0,
                            lifetime: 3.0,
                            trailEnabled: true,
                            glowEnabled: true,
                            rotationSpeed: 0
                        });

                        // Add homing target if enemy found
                        if (targetEnemy && projectile) {
                            if (projectile.projectileSystemRef) {
                                projectile.projectileSystemRef.homingTarget = targetEnemy;
                            } else {
                                projectile.homingTarget = targetEnemy;
                            }
                        }
                    }, i * 100); // Stagger projectiles slightly
                }
                playSound('shoot');
            }

            // ═══════════════════════════════════════════════════════════════
            // PHASE 2: A1 S1 COMBAT - CRIMSON SLASH COMBO
            // ═══════════════════════════════════════════════════════════════
            // Specific skill ID logic for unique effects
            switch (skillData.id) {
                case 'A1_S1': // Crimson Slash Combo - Sword swings + X projectiles
                    executeA1S1CrimsonSlash(skillData, player, forward);
                    return; // Early return to skip generic projectile logic
                case 'A1_S2': // Summon Clone
                    summonClone();
                    break;
                case 'A1_S3': // Power Wave - Enhanced wave projectiles
                    executeA1S3PowerWave(skillData, player, forward);
                    return;
                case 'A1_S4': // Phantom Step - Teleport backstab
                    executeA1S4PhantomStep(skillData, player, forward);
                    return;
                case 'A1_S5': // Crimson Cyclone - Blink chain
                    executeA1S5CrimsonCyclone(skillData, player, forward);
                    return;
                case 'A1_X1': // World Splitter - Chargeable ultimate
                    executeA1X1WorldSplitter(skillData, player, forward);
                    return;
                case 'A1_X2': // Phantom ULTIMATE
                    executeA1X2PhantomUltimate(skillData, player, forward);
                    return;
                case 'MISSY_S1': // Blade Dance - Arrow projectiles
                    executeMissyS1BladeDance(skillData, player, forward);
                    return;
                case 'MISSY_S2': // Summon Pet
                    summonPet();
                    break;
                case 'MISSY_S3': // Gun Barrage - AoE light beam
                    executeMissyS3GunBarrage(skillData, player, forward);
                    return;
                case 'MISSY_S4': // Angel Wings - Flight/dash
                    executeMissyS4AngelWings(skillData, player, forward);
                    return;
                case 'MISSY_S5': // Divine Protection - Shield buff
                    executeMissyS5DivineProtection(skillData, player, forward);
                    return;
                case 'MISSY_X1': // Celestial Rain - Multi-projectile rain
                    executeMissyX1CelestialRain(skillData, player, forward);
                    return;
                case 'MISSY_X2': // Angel ULTIMATE
                    executeMissyX2AngelUltimate(skillData, player, forward);
                    return;
                case 'UNIQUE_S1': // Plasma Blast - Enhanced with plasma trail
                    executeUniqueS1PlasmaBlast(skillData, player, forward);
                    return;
                case 'UNIQUE_S2': // Summon Drone
                    summonDrone();
                    break;
                case 'UNIQUE_S3': // Void Rift - Portal/rift mechanics
                    executeUniqueS3VoidRift(skillData, player, forward);
                    return;
                case 'UNIQUE_S4': // Energy Overload - Chain lightning
                    executeUniqueS4EnergyOverload(skillData, player, forward);
                    return;
                case 'UNIQUE_S5': // Quantum Strike - Teleport strike
                    executeUniqueS5QuantumStrike(skillData, player, forward);
                    return;
                case 'UNIQUE_X1': // Void Convergence - Ultimate with void pull
                    executeUniqueX1VoidConvergence(skillData, player, forward);
                    return;
                case 'UNIQUE_X2': // Voidlight ULTIMATE
                    executeUniqueX2VoidlightUltimate(skillData, player, forward);
                    return;
            }
        }

        // ═══════════════════════════════════════════════════════════════
        // PHASE 2: A1 S1 CRIMSON SLASH COMBO IMPLEMENTATION
        // ═══════════════════════════════════════════════════════════════
        /**
         * Execute A1 S1: Crimson Slash Combo
         * - Multiple sword swings (3-5) with red/black trails
         * - X-shaped projectiles after swings complete
         * - Scaling based on charge/rage state
         */
        function executeA1S1CrimsonSlash(skillData, player, forward) {
            console.log('⚔️ A1 S1: Crimson Slash Combo!');

            // Check for charge/rage state (if available in gameState)
            const isCharged = gameState.activeCharacter?.isCharged || false;
            const isRageCharged = gameState.activeCharacter?.isRageCharged || false;
            const rageActive = gameState.activeCharacter?.rageActive || false;

            // Scale swing count based on charge/rage
            // Base: 3 swings, Charged: 4 swings, Rage: 5 swings
            let swingCount = 3;
            if (isRageCharged || rageActive) {
                swingCount = 5;
            } else if (isCharged) {
                swingCount = 4;
            }

            // Scale projectile count
            // Base: 3 projectiles, Charged: 4-5, Rage: 6-7
            let projectileCount = 3;
            if (isRageCharged || rageActive) {
                projectileCount = 6 + Math.floor(Math.random() * 2); // 6-7
            } else if (isCharged) {
                projectileCount = 4 + Math.floor(Math.random() * 2); // 4-5
            }

            const damage = skillData.damage || 150;
            const baseDamage = Array.isArray(damage) ? damage[0] : damage;

            // Phase 1: Sword swings with red and black trails
            for (let i = 0; i < swingCount; i++) {
                setTimeout(() => {
                    // Calculate swing angle (spread around forward direction)
                    const swingAngle = (i / swingCount) * Math.PI * 0.6 - Math.PI * 0.3; // 60 degree spread
                    const swingDirection = forward.clone().applyAxisAngle(
                        new THREE.Vector3(0, 1, 0),
                        swingAngle
                    );

                    // Create sword slash VFX (red trail)
                    createSwordSlashTrail(player, swingDirection, 0xff0000, 60, 8, 0.6);

                    // Create black shadow trail
                    setTimeout(() => {
                        createSwordSlashTrail(player, swingDirection, 0x000000, 50, 6, 0.4);
                    }, 50);

                    // Player mesh rotation effect (swing animation)
                    const originalRotation = player.rotation.y;
                    player.rotation.y += swingAngle;
                    setTimeout(() => {
                        player.rotation.y = originalRotation;
                    }, 100);

                    console.log(`⚔️ Sword swing ${i + 1}/${swingCount}`);
                }, i * 150); // 150ms between swings
            }

            // Phase 2: X-shaped projectiles after swings complete
            const totalSwingTime = swingCount * 150;
            setTimeout(() => {
                for (let i = 0; i < projectileCount; i++) {
                    // Spread projectiles in a circle
                    const spreadAngle = (i / projectileCount) * Math.PI * 2;
                    const xDirection = forward.clone().applyAxisAngle(
                        new THREE.Vector3(0, 1, 0),
                        spreadAngle
                    );
                    const targetPosition = player.position.clone()
                        .add(xDirection.multiplyScalar(200));

                    // Fire X-wave projectile with crimson color
                    const projectileDamage = baseDamage * (isRageCharged || rageActive ? 1.35 : isCharged ? 1.2 : 1.0);
                    fireXWaveProjectile(player, targetPosition, projectileDamage, 0xff0000);
                }
                playSound('shoot');
            }, totalSwingTime + 100); // After all swings complete + 100ms delay
        }

        /**
         * Create sword slash trail VFX
         */
        function createSwordSlashTrail(source, direction, color, length, width, lifetime) {
            // Create a line geometry for the slash trail
            const startPos = source.position.clone().add(new THREE.Vector3(0, 1.5, 0));
            const endPos = startPos.clone().add(direction.clone().multiplyScalar(length));

            const geometry = new THREE.BufferGeometry().setFromPoints([startPos, endPos]);
            const material = new THREE.LineBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.8,
                linewidth: width
            });

            const line = new THREE.Line(geometry, material);
            scene.add(line);

            // Animate and remove
            let elapsed = 0;
            const fadeOut = () => {
                elapsed += 16; // ~60fps
                const progress = elapsed / (lifetime * 1000);

                if (progress >= 1) {
                    scene.remove(line);
                    geometry.dispose();
                    material.dispose();
                    return;
                }

                // Fade out
                material.opacity = 0.8 * (1 - progress);
                material.linewidth = width * (1 - progress * 0.5);

                requestAnimationFrame(fadeOut);
            };
            fadeOut();
        }

        /**
         * Fire X-wave projectile (two crossing lines)
         */
        function fireXWaveProjectile(source, target, damage, color = 0xff0000) {
            const startPosition = source.position.clone().add(new THREE.Vector3(0, 1.5, 0));
            const direction = new THREE.Vector3().subVectors(target, startPosition).normalize();

            // Create X-shape by firing two crossing projectiles
            const crossAngle1 = Math.atan2(direction.z, direction.x);
            const crossAngle2 = crossAngle1 + Math.PI / 2; // Perpendicular

            // Projectile 1: Forward diagonal
            const dir1 = new THREE.Vector3(
                Math.cos(crossAngle1 + Math.PI / 4),
                0,
                Math.sin(crossAngle1 + Math.PI / 4)
            ).normalize();

            // Projectile 2: Backward diagonal (forming X)
            const dir2 = new THREE.Vector3(
                Math.cos(crossAngle1 - Math.PI / 4),
                0,
                Math.sin(crossAngle1 - Math.PI / 4)
            ).normalize();

            // Fire both projectiles with slight offset to form X
            fireXWaveLine(startPosition, dir1, damage, color);
            fireXWaveLine(startPosition, dir2, damage, color);
        }

        /**
         * Fire a single X-wave line (one diagonal of the X)
         */
        function fireXWaveLine(startPos, direction, damage, color) {
            // Create a thick line projectile
            const length = 100;
            const endPos = startPos.clone().add(direction.clone().multiplyScalar(length));

            const geometry = new THREE.BufferGeometry().setFromPoints([startPos, endPos]);
            const material = new THREE.LineBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.9,
                linewidth: 6
            });

            const line = new THREE.Line(geometry, material);
            scene.add(line);

            // Move the line forward
            const speed = 80.0;
            const velocity = direction.clone().multiplyScalar(speed);

            const projectileState = {
                mesh: line,
                velocity: velocity,
                lifetime: 3,
                team: 'player',
                damage: damage,
                type: 'xwave'
            };

            gameState.projectiles.push(projectileState);

            // Also create a sphere projectile at center for collision
            const projectileGeometry = new THREE.SphereGeometry(0.4, 8, 8);
            const projectileMaterial = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.7
            });
            const projectileSphere = new THREE.Mesh(projectileGeometry, projectileMaterial);
            projectileSphere.position.copy(startPos);

            const sphereVelocity = velocity.clone();
            const sphereState = {
                mesh: projectileSphere,
                velocity: sphereVelocity,
                lifetime: 3,
                team: 'player',
                damage: damage,
                type: 'xwave'
            };

            gameState.projectiles.push(sphereState);
            scene.add(projectileSphere);
        }

        // Phase 2.4: Summon functions
        function summonClone() {
            const player = gameState.activeCharacter.mesh;
            const cloneMaterial = new THREE.MeshStandardMaterial({
                color: 0x00aaff,
                transparent: true,
                opacity: 0.6
            });
            const cloneMesh = new THREE.Mesh(player.geometry, cloneMaterial);
            cloneMesh.position.copy(player.position).add(new THREE.Vector3(2, 0, -2));
            scene.add(cloneMesh);

            const cloneState = {
                mesh: cloneMesh,
                lifetime: 10.0, // 10 seconds
                attackCooldown: 1.5,
                attackTarget: null,
                damage: (gameState.player && gameState.player.effectiveStats) ? gameState.player.effectiveStats.attack * 0.5 : 50, // Clone does 50% damage
                type: 'clone'
            };

            gameState.summons.push(cloneState);
            console.log('👥 Shadow Clone summoned!');
            return cloneState; // Return clone state for X2 ultimate
        }

        function summonPet() {
            const player = gameState.activeCharacter.mesh;
            const petGeometry = new THREE.CapsuleGeometry(0.4, 0.8, 4, 8);
            const petMaterial = new THREE.MeshStandardMaterial({
                color: 0xff69b4,
                transparent: true,
                opacity: 0.8
            });
            const petMesh = new THREE.Mesh(petGeometry, petMaterial);
            petMesh.position.copy(player.position).add(new THREE.Vector3(-2, 0, -2));
            petMesh.castShadow = true;
            scene.add(petMesh);

            const petState = {
                mesh: petMesh,
                lifetime: 15.0, // 15 seconds
                attackCooldown: 1.0,
                attackTarget: null,
                damage: gameState.activeCharacter.effectiveStats.attack * 0.4, // Pet does 40% damage
                type: 'pet'
            };

            gameState.summons.push(petState);
            console.log('🐱 Magical Pet summoned!');
        }

        function summonDrone() {
            const player = gameState.activeCharacter.mesh;
            const droneGeometry = new THREE.BoxGeometry(0.6, 0.3, 0.6);
            const droneMaterial = new THREE.MeshStandardMaterial({
                color: 0x00ffff,
                emissive: 0x004444,
                emissiveIntensity: 0.5
            });
            const droneMesh = new THREE.Mesh(droneGeometry, droneMaterial);
            droneMesh.position.copy(player.position).add(new THREE.Vector3(0, 2, -2));
            droneMesh.castShadow = true;
            scene.add(droneMesh);

            const droneState = {
                mesh: droneMesh,
                lifetime: 12.0, // 12 seconds
                attackCooldown: 0.8,
                attackTarget: null,
                damage: gameState.activeCharacter.effectiveStats.attack * 0.6, // Drone does 60% damage
                type: 'drone'
            };

            gameState.summons.push(droneState);
            console.log('🤖 Combat Drone deployed!');
        }

        /**
         * Execute A1 X2: Phantom ULTIMATE
         * - Spawn 3 shadow clones that perform synchronized attacks
         * - 8-hit phantom barrage combo with teleportation
         * - Screen shake and dark shadow VFX
         */
        /**
         * Execute A1 S3: Power Wave - Enhanced wave projectiles with energy trails
         */
        function executeA1S3PowerWave(skillData, player, forward) {
            console.log('💥 A1 S3: Power Wave!');

            const damage = skillData.damage || 250;
            const projectileCount = skillData.projectileCount || 4;
            const color = parseInt(skillData.color.replace('#', '0x'), 16) || 0xff0000;

            // Calculate damage with skill calculator
            const damageResult = skillEffectCalculator.calculateDamage(skillData, damage);

            // Fire enhanced wave projectiles with energy trails
            for (let i = 0; i < projectileCount; i++) {
                setTimeout(() => {
                    const spreadAngle = (skillData.projectileCount > 1) ? (-0.15 + 0.3 * (i / (projectileCount - 1))) : 0;
                    const spreadQuaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), spreadAngle);
                    const direction = forward.clone().applyQuaternion(spreadQuaternion);
                    const targetPosition = player.position.clone().add(direction.multiplyScalar(200));

                    fireProjectile(player, targetPosition, 'player', damageResult.damage, color, {
                        tier: skillData.tier || 'rare',
                        shape: 'wave',
                        element: skillData.element || 'ENERGY',
                        speed: 90.0,
                        lifetime: 3.5,
                        trailEnabled: true,
                        glowEnabled: true,
                        rotationSpeed: 5
                    });
                }, i * 80);
            }

            // Emit energy particles
            const playerPos = player.position.clone().add(new THREE.Vector3(0, 1.5, 0));
            emitSkillParticles(playerPos, color, 25);
            applyScreenShake(0.15, 0.3);
        }

        /**
         * Execute A1 S4: Phantom Step - Teleport backstab with time manipulation VFX
         */
        function executeA1S4PhantomStep(skillData, player, forward) {
            console.log('⏰ A1 S4: Phantom Step - Backstab Waltz!');

            // Find nearest enemy
            let nearestEnemy = null;
            let nearestDistance = Infinity;

            for (const npc of gameState.npcs) {
                if (npc.type === 'villain' && npc.health > 0) {
                    const distance = player.position.distanceTo(npc.mesh.position);
                    if (distance < nearestDistance && distance < 30) {
                        nearestDistance = distance;
                        nearestEnemy = npc;
                    }
                }
            }

            if (nearestEnemy) {
                // Teleport behind enemy
                const enemyPos = nearestEnemy.mesh.position;
                const enemyForward = new THREE.Vector3(0, 0, -1).applyQuaternion(nearestEnemy.mesh.quaternion);
                const teleportPos = enemyPos.clone().add(enemyForward.multiplyScalar(-3));
                teleportPos.y = player.position.y;

                // Create teleport VFX at origin
                const originPos = player.position.clone();
                emitSkillParticles(originPos, 0x00E5FF, 20);

                // Teleport player
                player.position.copy(teleportPos);
                player.lookAt(enemyPos);

                // Create arrival VFX
                setTimeout(() => {
                    emitSkillParticles(teleportPos, 0x00E5FF, 20);

                    // Apply backstab damage
                    const damage = skillData.finalPower || 320;
                    const damageResult = skillEffectCalculator.calculateDamage(skillData, damage);

                    nearestEnemy.health -= damageResult.damage;
                    createDamageIndicator(enemyPos, damageResult.damage);

                    // Apply status effects
                    if (skillData.statusEffects && skillData.statusEffects.length > 0) {
                        skillEffectCalculator.applySkillEffects(skillData, nearestEnemy.mesh.uuid, damageResult);
                    }

                    if (nearestEnemy.health <= 0) {
                        nearestEnemy.health = 0;
                        nearestEnemy.state = 'dying';
                        nearestEnemy.dyingTimer = 0.5;
                    }
                }, 100);

                applyScreenShake(0.2, 0.4);
            }
        }

        /**
         * Execute A1 S5: Crimson Cyclone - Blink chain with vortex effects
         */
        function executeA1S5CrimsonCyclone(skillData, player, forward) {
            console.log('🌪️ A1 S5: Crimson Cyclone - Blink Chain!');

            const blinkCount = skillData.blinkCount || 3;
            const spinTickDamage = skillData.spinTickDamage || 50;
            const slamDamage = skillData.slamDamage || 300;
            const vortexRadius = skillData.vortexRadius || 200;

            // Find enemies in range
            const enemiesInRange = gameState.npcs.filter(npc =>
                npc.type === 'villain' &&
                npc.health > 0 &&
                player.position.distanceTo(npc.mesh.position) < vortexRadius
            );

            if (enemiesInRange.length === 0) return;

            // Sort by distance
            enemiesInRange.sort((a, b) =>
                player.position.distanceTo(a.mesh.position) - player.position.distanceTo(b.mesh.position)
            );

            // Blink to each enemy
            const targets = enemiesInRange.slice(0, blinkCount);

            targets.forEach((enemy, index) => {
                setTimeout(() => {
                    const enemyPos = enemy.mesh.position;
                    const teleportPos = enemyPos.clone().add(new THREE.Vector3(
                        (Math.random() - 0.5) * 2,
                        0,
                        (Math.random() - 0.5) * 2
                    ));
                    teleportPos.y = player.position.y;

                    // Create vortex effect
                    createVortexEffect(enemyPos, 0xFF0000, 5);

                    // Teleport player
                    if (index === 0) {
                        player.position.copy(teleportPos);
                    }

                    // Apply spin damage
                    const spinDamage = skillEffectCalculator.calculateDamage(skillData, spinTickDamage);
                    enemy.health -= spinDamage.damage;
                    createDamageIndicator(enemyPos, spinDamage.damage);

                    // Apply stun if applicable
                    if (skillData.stunDuration > 0) {
                        statusEffectManager.applyEffect(enemy.mesh.uuid, 'STUN', skillData.stunDuration, 1, skillData.id);
                    }

                    if (enemy.health <= 0) {
                        enemy.health = 0;
                        enemy.state = 'dying';
                        enemy.dyingTimer = 0.5;
                    }
                }, index * 200);
            });

            // Final slam on last target
            if (targets.length > 0) {
                setTimeout(() => {
                    const lastTarget = targets[targets.length - 1];
                    const slamPos = lastTarget.mesh.position;

                    // Create slam effect
                    createVortexEffect(slamPos, 0xFF0000, 10);
                    applyScreenShake(0.3, 0.5);

                    // Apply slam damage to all nearby enemies
                    const nearbyEnemies = gameState.npcs.filter(npc =>
                        npc.type === 'villain' &&
                        npc.health > 0 &&
                        slamPos.distanceTo(npc.mesh.position) < 8
                    );

                    nearbyEnemies.forEach(enemy => {
                        const slamDamageResult = skillEffectCalculator.calculateDamage(skillData, slamDamage);
                        enemy.health -= slamDamageResult.damage;
                        createDamageIndicator(enemy.mesh.position, slamDamageResult.damage);

                        if (enemy.health <= 0) {
                            enemy.health = 0;
                            enemy.state = 'dying';
                            enemy.dyingTimer = 0.5;
                        }
                    });
                }, targets.length * 200 + 100);
            }
        }

        /**
         * Execute A1 X1: World Splitter - Chargeable ultimate with dimensional rifts
         */
        function executeA1X1WorldSplitter(skillData, player, forward) {
            console.log('🌌 A1 X1: World Splitter!');

            // Check charge level (if charging system exists)
            const chargeLevel = gameState.activeCharacter?.chargeLevel || 1.0;
            const chargeTiers = skillData.charge || { t1: 0.50, t2: 0.80 };

            let tier = 1;
            if (chargeLevel >= chargeTiers.t2) tier = 3;
            else if (chargeLevel >= chargeTiers.t1) tier = 2;

            const damage = Array.isArray(skillData.damage) ? skillData.damage[tier - 1] : skillData.damage;
            const riftCount = skillData.riftCount || 2;
            const riftWidth = Array.isArray(skillData.riftWidth) ? skillData.riftWidth[tier - 1] : (skillData.riftWidth || 60);

            // Create dimensional rifts
            for (let i = 0; i < riftCount; i++) {
                setTimeout(() => {
                    const angle = (i / riftCount) * Math.PI * 2;
                    const riftDirection = forward.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
                    const riftStart = player.position.clone().add(new THREE.Vector3(0, 1.5, 0));
                    const riftEnd = riftStart.clone().add(riftDirection.multiplyScalar(200));

                    createDimensionalRift(riftStart, riftEnd, riftWidth, 0x00E5FF, damage, tier, skillData);
                }, i * 150);
            }

            // Apply screen shake based on tier
            applyScreenShake(0.2 + (tier * 0.1), 0.4 + (tier * 0.2));

            // Emit ultimate particles
            const playerPos = player.position.clone().add(new THREE.Vector3(0, 1.5, 0));
            emitUltimateParticles(playerPos, 0x00E5FF, 60);
        }

        /**
         * Create vortex effect
         */
        function createVortexEffect(center, color, intensity) {
            const particleCount = 20 * intensity;
            for (let i = 0; i < particleCount; i++) {
                const angle = (i / particleCount) * Math.PI * 2;
                const radius = 2 + Math.random() * 3;
                const particle = {
                    mesh: new THREE.Mesh(
                        new THREE.SphereGeometry(0.15, 4, 4),
                        new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.9 })
                    ),
                    velocity: new THREE.Vector3(
                        Math.cos(angle) * radius * 2,
                        Math.random() * 2,
                        Math.sin(angle) * radius * 2
                    ),
                    lifetime: 0.8,
                    maxLifetime: 0.8
                };
                particle.mesh.position.copy(center);
                scene.add(particle.mesh);
                particleSystem.particles.push(particle);
            }
        }

        /**
         * Create dimensional rift effect
         */
        function createDimensionalRift(start, end, width, color, damage, tier, skillDataRef) {
            const direction = new THREE.Vector3().subVectors(end, start).normalize();
            const length = start.distanceTo(end);

            // Create rift visual (thick line with glow)
            const geometry = new THREE.BufferGeometry().setFromPoints([start, end]);
            const material = new THREE.LineBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.9,
                linewidth: width
            });

            const rift = new THREE.Line(geometry, material);
            scene.add(rift);

            // Move rift forward and check collisions
            const speed = 100.0;
            const lifetime = length / speed;
            let age = 0;
            const hitEnemies = new Set(); // Track hit enemies to prevent multiple hits

            const updateRift = () => {
                age += 0.016; // ~60fps
                const progress = age / lifetime;

                if (progress >= 1.0) {
                    scene.remove(rift);
                    rift.geometry.dispose();
                    rift.material.dispose();
                    return;
                }

                // Update position
                const currentStart = start.clone().add(direction.clone().multiplyScalar(speed * age));
                const currentEnd = currentStart.clone().add(direction.clone().multiplyScalar(length));

                // Check collisions with enemies
                for (const npc of gameState.npcs) {
                    if (npc.type === 'villain' && npc.health > 0 && !hitEnemies.has(npc.mesh.uuid)) {
                        const npcPos = npc.mesh.position;
                        const distanceToLine = Math.abs(
                            (currentEnd.x - currentStart.x) * (currentStart.z - npcPos.z) -
                            (currentStart.x - npcPos.x) * (currentEnd.z - currentStart.z)
                        ) / Math.sqrt(
                            Math.pow(currentEnd.x - currentStart.x, 2) +
                            Math.pow(currentEnd.z - currentStart.z, 2)
                        );

                        if (distanceToLine < width / 2 + 1.5) {
                            hitEnemies.add(npc.mesh.uuid);
                            const damageResult = skillEffectCalculator.calculateDamage(skillDataRef, damage);
                            npc.health -= damageResult.damage;
                            createDamageIndicator(npcPos, damageResult.damage);

                            if (npc.health <= 0) {
                                npc.health = 0;
                                npc.state = 'dying';
                                npc.dyingTimer = 0.5;
                            }
                        }
                    }
                }

                // Update geometry
                rift.geometry.setFromPoints([currentStart, currentEnd]);

                if (progress < 1.0) {
                    requestAnimationFrame(updateRift);
                }
            };

            updateRift();
        }

        function executeA1X2PhantomUltimate(skillData, player, forward) {
            console.log('👻 A1 X2: Phantom ULTIMATE!');

            const damage = skillData.damage || 500;
            const cloneCount = skillData.shadowClones || 3;
            const barrageCount = skillData.barrageCount || 8;
            const cloneDamageMultiplier = skillData.cloneDamage || 0.5;

            // Apply screen shake for ultimate
            if (typeof applyScreenShake === 'function') {
                applyScreenShake(0.5, 1.0);
            }

            // Phase 1: Spawn shadow clones
            const clones = [];
            for (let i = 0; i < cloneCount; i++) {
                setTimeout(() => {
                    const clone = summonClone();
                    if (clone && gameState.player && gameState.player.effectiveStats) {
                        clone.damage = gameState.player.effectiveStats.attack * cloneDamageMultiplier;
                        clones.push(clone);
                    }
                }, i * 200);
            }

            // Phase 2: Synchronized phantom barrage
            setTimeout(() => {
                const playerPos = player.position.clone();
                const forwardDir = forward.clone();

                // Main player performs barrage
                for (let i = 0; i < barrageCount; i++) {
                    setTimeout(() => {
                        // Teleport effect
                        const teleportOffset = forwardDir.clone().multiplyScalar(15 * (i + 1));
                        const newPos = playerPos.clone().add(teleportOffset);

                        // Create dark shadow trail
                        createSwordSlashTrail(player, forwardDir, 0x000000, 80, 12, 0.8);

                        // Fire phantom projectile
                        const targetPos = newPos.clone().add(forwardDir.clone().multiplyScalar(200));
                        fireProjectile(player, targetPos, 'player', damage / barrageCount, 0x000000);

                        // Each clone also attacks
                        clones.forEach((clone, cloneIdx) => {
                            if (clone && clone.mesh) {
                                const cloneForward = forwardDir.clone().applyAxisAngle(
                                    new THREE.Vector3(0, 1, 0),
                                    (cloneIdx - 1) * Math.PI / 6
                                );
                                const cloneTarget = clone.mesh.position.clone().add(cloneForward.multiplyScalar(200));
                                fireProjectile(clone.mesh, cloneTarget, 'player', damage * cloneDamageMultiplier / barrageCount, 0x333333);
                            }
                        });

                        // Screen shake on each hit
                        if (i % 2 === 0 && typeof applyScreenShake === 'function') {
                            applyScreenShake(0.1, 0.2);
                        }
                    }, i * 150);
                }
            }, cloneCount * 200 + 300);
        }

        /**
         * Execute Missy X2: Angel ULTIMATE
         * - Divine judgment beam from above (AoE)
         * - Heal player and party members for 200 HP
         * - Golden light particles and angel wing VFX
         */
        /**
         * Execute MISSY S1: Blade Dance - Arrow projectiles with light trails
         */
        function executeMissyS1BladeDance(skillData, player, forward) {
            console.log('🗡️ MISSY S1: Blade Dance!');

            const damage = skillData.damage || 130;
            const projectileCount = skillData.projectileCount || 3;
            const color = parseInt(skillData.color.replace('#', '0x'), 16) || 0xff69b4;

            const damageResult = skillEffectCalculator.calculateDamage(skillData, damage);

            // Fire arrow-shaped projectiles with light trails
            for (let i = 0; i < projectileCount; i++) {
                setTimeout(() => {
                    const spreadAngle = (projectileCount > 1) ? (-0.1 + 0.2 * (i / (projectileCount - 1))) : 0;
                    const spreadQuaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), spreadAngle);
                    const direction = forward.clone().applyQuaternion(spreadQuaternion);
                    const targetPosition = player.position.clone().add(direction.multiplyScalar(200));

                    fireProjectile(player, targetPosition, 'player', damageResult.damage, color, {
                        tier: skillData.tier || 'common',
                        shape: 'star', // Arrow-like shape
                        element: skillData.element || 'PHYSICAL',
                        speed: 85.0,
                        lifetime: 3.0,
                        trailEnabled: true,
                        glowEnabled: true,
                        rotationSpeed: 4
                    });
                }, i * 100);
            }

            emitSkillParticles(player.position.clone().add(new THREE.Vector3(0, 1.5, 0)), color, 15);
        }

        /**
         * Execute MISSY S3: Gun Barrage - AoE light beam with healing effects
         */
        function executeMissyS3GunBarrage(skillData, player, forward) {
            console.log('💰 MISSY S3: Gun Barrage!');

            const damage = skillData.damage || 200;
            const projectileCount = skillData.projectileCount || 4;
            const color = parseInt(skillData.color.replace('#', '0x'), 16) || 0xff69b4;

            const damageResult = skillEffectCalculator.calculateDamage(skillData, damage);

            // Fire rapid bullet projectiles
            for (let i = 0; i < projectileCount; i++) {
                setTimeout(() => {
                    const spreadAngle = (projectileCount > 1) ? (-0.12 + 0.24 * (i / (projectileCount - 1))) : 0;
                    const spreadQuaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), spreadAngle);
                    const direction = forward.clone().applyQuaternion(spreadQuaternion);
                    const targetPosition = player.position.clone().add(direction.multiplyScalar(200));

                    fireProjectile(player, targetPosition, 'player', damageResult.damage, color, {
                        tier: skillData.tier || 'rare',
                        shape: 'cube', // Bullet shape
                        element: skillData.element || 'LIGHT',
                        speed: 95.0,
                        lifetime: 3.0,
                        trailEnabled: true,
                        glowEnabled: true,
                        rotationSpeed: 6
                    });
                }, i * 50); // Faster firing
            }

            // Create light beam AoE effect
            createLightBeamAoE(player.position.clone().add(forward.multiplyScalar(10)), forward, 5, color);
            emitSkillParticles(player.position.clone().add(new THREE.Vector3(0, 1.5, 0)), color, 20);
            applyScreenShake(0.15, 0.25);
        }

        /**
         * Execute MISSY S4: Angel Wings - Flight/dash with wing particle effects
         */
        function executeMissyS4AngelWings(skillData, player, forward) {
            console.log('✨ MISSY S4: Angel Wings!');

            // Dash forward with wing trail
            const dashDistance = 15;
            const dashSpeed = 50.0;
            const dashDuration = dashDistance / dashSpeed;

            const startPos = player.position.clone();
            const endPos = startPos.clone().add(forward.multiplyScalar(dashDistance));

            // Create wing particle trail
            createWingTrail(startPos, endPos, 0xffd700);

            // Apply speed boost
            if (statusEffectManager) {
                statusEffectManager.applyEffect('player', 'SPEED_BOOST', 2.0, 1, skillData.id);
            }

            // Dash animation
            let dashProgress = 0;
            const dashInterval = setInterval(() => {
                dashProgress += 0.016;
                if (dashProgress >= dashDuration) {
                    clearInterval(dashInterval);
                    player.position.copy(endPos);
                } else {
                    const currentPos = startPos.clone().lerp(endPos, dashProgress / dashDuration);
                    player.position.copy(currentPos);
                }
            }, 16);

            // Apply damage to enemies in path
            const pathEnemies = gameState.npcs.filter(npc =>
                npc.type === 'villain' &&
                npc.health > 0 &&
                startPos.distanceTo(npc.mesh.position) < dashDistance + 3
            );

            pathEnemies.forEach(enemy => {
                const damage = skillData.damage || 560;
                const damageResult = skillEffectCalculator.calculateDamage(skillData, damage);
                enemy.health -= damageResult.damage;
                createDamageIndicator(enemy.mesh.position, damageResult.damage);

                if (enemy.health <= 0) {
                    enemy.health = 0;
                    enemy.state = 'dying';
                    enemy.dyingTimer = 0.5;
                }
            });

            emitSkillParticles(startPos, 0xffd700, 30);
            applyScreenShake(0.1, 0.2);
        }

        /**
         * Execute MISSY S5: Divine Protection - Shield buff with aura effects
         */
        function executeMissyS5DivineProtection(skillData, player, forward) {
            console.log('🌀 MISSY S5: Royal Typhoon!');

            const damage = skillData.damage || 720;
            const cycloneRadius = skillData.typhoonRadius || 150;
            const cycloneDuration = skillData.cycloneDuration || 1.8;
            const cycloneTicks = skillData.cycloneTicks || 18;
            const tickDamage = skillData.cycloneTickDamage || 40;
            const color = parseInt(skillData.color.replace('#', '0x'), 16) || 0xffd700;

            // Create cyclone effect at player position
            const cycloneCenter = player.position.clone();
            createCycloneEffect(cycloneCenter, cycloneRadius, color, cycloneDuration);

            // Apply damage over time to enemies in cyclone
            const tickInterval = cycloneDuration / cycloneTicks;
            let tickCount = 0;

            const cycloneDamageInterval = setInterval(() => {
                tickCount++;
                const enemiesInCyclone = gameState.npcs.filter(npc =>
                    npc.type === 'villain' &&
                    npc.health > 0 &&
                    cycloneCenter.distanceTo(npc.mesh.position) < cycloneRadius
                );

                enemiesInCyclone.forEach(enemy => {
                    const damageResult = skillEffectCalculator.calculateDamage(skillData, tickDamage);
                    enemy.health -= damageResult.damage;
                    createDamageIndicator(enemy.mesh.position, damageResult.damage);

                    if (enemy.health <= 0) {
                        enemy.health = 0;
                        enemy.state = 'dying';
                        enemy.dyingTimer = 0.5;
                    }
                });

                // These blocks were causing errors due to undefined variables (end, width, endBurst, slamPos, slamDamage).
                // They appear to be copy-paste errors from other skill functions and have been removed.


                if (tickCount >= cycloneTicks) {
                    clearInterval(cycloneDamageInterval);
                }
            }, tickInterval * 1000);

            // Fire cone volleys
            if (skillData.coneVolleys) {
                for (let v = 0; v < skillData.coneVolleys; v++) {
                    setTimeout(() => {
                        for (let p = 0; p < (skillData.conePellets || 8); p++) {
                            const spread = (p / (skillData.conePellets - 1)) * (skillData.coneSpread || 35) * Math.PI / 180;
                            const direction = forward.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), spread - (skillData.coneSpread * Math.PI / 180 / 2));
                            const targetPos = player.position.clone().add(direction.multiplyScalar(200));

                            fireProjectile(player, targetPos, 'player', skillData.conePower || 110, color, {
                                tier: skillData.tier || 'epic',
                                shape: 'sphere',
                                element: skillData.element || 'LIGHT',
                                speed: 80.0,
                                lifetime: 3.0,
                                trailEnabled: true,
                                glowEnabled: true
                            });
                        }
                    }, v * 300);
                }
            }

            emitSkillParticles(cycloneCenter, color, 40);
            applyScreenShake(0.25, 0.4);
        }

        /**
         * Execute MISSY X1: Celestial Rain - Multi-projectile rain with healing
         */
        function executeMissyX1CelestialRain(skillData, player, forward) {
            console.log('💎 MISSY X1: Royal Coin Cannon!');

            // Check charge level
            const chargeLevel = gameState.activeCharacter?.chargeLevel || 1.0;
            const chargeTiers = skillData.charge || { t1: 0.5, t2: 0.9 };

            let tier = 1;
            if (chargeLevel >= chargeTiers.t2) tier = 3;
            else if (chargeLevel >= chargeTiers.t1) tier = 2;

            const damage = Array.isArray(skillData.damage) ? skillData.damage[tier - 1] : skillData.damage;
            const beamWidth = Array.isArray(skillData.beamWidth) ? skillData.beamWidth[tier - 1] : (skillData.beamWidth || 70);
            const beamDuration = skillData.beamDuration || 1.4;
            const beamTicksPerSec = skillData.beamTicksPerSec || 12;
            const tickDamage = skillData.beamTickDamage || 90;
            const color = parseInt(skillData.color.replace('#', '0x'), 16) || 0xffd700;

            // Create beam effect
            const beamStart = player.position.clone().add(new THREE.Vector3(0, 1.5, 0));
            const beamEnd = beamStart.clone().add(forward.multiplyScalar(200));

            createRoyalCoinBeam(beamStart, beamEnd, beamWidth, color, beamDuration, tickDamage, skillData, tier);

            // Final nova explosion
            setTimeout(() => {
                const novaDamage = Array.isArray(skillData.finalNova) ? skillData.finalNova[tier - 1] : (skillData.finalNova || 1200);
                createNovaExplosion(beamEnd, beamWidth * 2, color, novaDamage, skillData);
            }, beamDuration * 1000);

            applyScreenShake(0.3 + (tier * 0.1), 0.5 + (tier * 0.2));
            emitUltimateParticles(beamStart, color, 50);
        }

        /**
         * Create light beam AoE effect
         */
        function createLightBeamAoE(center, direction, radius, color) {
            // Create circular AoE indicator
            const geometry = new THREE.RingGeometry(0, radius, 32);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(geometry, material);
            ring.position.copy(center);
            ring.rotation.x = -Math.PI / 2;
            scene.add(ring);

            // Fade out and remove
            setTimeout(() => {
                scene.remove(ring);
                ring.geometry.dispose();
                ring.material.dispose();
            }, 1000);
        }

        /**
         * Create wing trail effect
         */
        function createWingTrail(start, end, color) {
            const particleCount = 30;
            for (let i = 0; i < particleCount; i++) {
                const progress = i / particleCount;
                const pos = start.clone().lerp(end, progress);
                const particle = {
                    mesh: new THREE.Mesh(
                        new THREE.SphereGeometry(0.2, 4, 4),
                        new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.8 })
                    ),
                    velocity: new THREE.Vector3(
                        (Math.random() - 0.5) * 2,
                        Math.random() * 2,
                        (Math.random() - 0.5) * 2
                    ),
                    lifetime: 0.6,
                    maxLifetime: 0.6
                };
                particle.mesh.position.copy(pos);
                scene.add(particle.mesh);
                particleSystem.particles.push(particle);
            }
        }

        /**
         * Create cyclone effect
         */
        function createCycloneEffect(center, radius, color, duration) {
            const particleCount = 50;
            for (let i = 0; i < particleCount; i++) {
                const angle = (i / particleCount) * Math.PI * 2;
                const height = (i / particleCount) * 5;
                const particle = {
                    mesh: new THREE.Mesh(
                        new THREE.SphereGeometry(0.2, 4, 4),
                        new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.7 })
                    ),
                    velocity: new THREE.Vector3(
                        Math.cos(angle) * 3,
                        2,
                        Math.sin(angle) * 3
                    ),
                    lifetime: duration,
                    maxLifetime: duration,
                    startAngle: angle
                };
                particle.mesh.position.copy(center).add(new THREE.Vector3(
                    Math.cos(angle) * radius * 0.5,
                    height,
                    Math.sin(angle) * radius * 0.5
                ));
                scene.add(particle.mesh);
                particleSystem.particles.push(particle);
            }
        }

        /**
         * Create royal coin beam
         */
        function createRoyalCoinBeam(start, end, width, color, duration, tickDamage, skillData, tier) {
            const direction = new THREE.Vector3().subVectors(end, start).normalize();
            const length = start.distanceTo(end);

            // Create beam visual
            const geometry = new THREE.CylinderGeometry(width / 2, width / 2, length, 16);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.7,
                side: THREE.DoubleSide
            });
            const beam = new THREE.Mesh(geometry, material);
            beam.position.copy(start.clone().add(end).multiplyScalar(0.5));
            beam.lookAt(end);
            scene.add(beam);

            // Apply damage over time
            const tickInterval = 1.0 / (skillData.beamTicksPerSec || 12);
            let tickCount = 0;
            const maxTicks = Math.floor(duration / tickInterval);
            const hitEnemies = new Set();

            const damageInterval = setInterval(() => {
                tickCount++;
                const currentBeamPos = start.clone().add(direction.clone().multiplyScalar((tickCount / maxTicks) * length));

                // Check enemies in beam
                for (const npc of gameState.npcs) {
                    if (npc.type === 'villain' && npc.health > 0 && !hitEnemies.has(npc.mesh.uuid)) {
                        const distanceToBeam = npc.mesh.position.distanceTo(currentBeamPos);
                        if (distanceToBeam < width / 2 + 2) {
                            hitEnemies.add(npc.mesh.uuid);
                            const damageResult = skillEffectCalculator.calculateDamage(skillData, tickDamage);
                            npc.health -= damageResult.damage;
                            createDamageIndicator(npc.mesh.position, damageResult.damage);

                            if (npc.health <= 0) {
                                npc.health = 0;
                                npc.state = 'dying';
                                npc.dyingTimer = 0.5;
                            }
                        }
                    }
                }

                if (tickCount >= maxTicks) {
                    clearInterval(damageInterval);
                }
            }, tickInterval * 1000);

            // This block was causing an error because 'currentWidth' is not defined in this scope.
            // It has been removed to fix the crash. A similar, correct implementation exists in createAuroraBurstBeam.


            // Damage destructible objects in drill
            for (const obj of gameState.destructibleObjects) {
                if (!obj.isDestroyed && !hitEnemies.has(obj.mesh.uuid)) {
                    const distance = obj.mesh.position.distanceTo(currentPos);
                    if (distance < width / 2 + 2) {
                        hitEnemies.add(obj.mesh.uuid);
                        const damage = skillData.baseDamage || 38;
                        const damageResult = skillEffectCalculator.calculateDamage(skillData, damage);
                        obj.health -= damageResult.damage;
                        createDamageIndicator(obj.mesh.position, damageResult.damage, { color: '#aaaaaa' });
                        if (obj.health <= 0) {
                            obj.health = 0;
                        }
                    }
                }
            }


            // Check destructible objects
            for (const obj of gameState.destructibleObjects) {
                if (!obj.isDestroyed && !hitEnemies.has(obj.mesh.uuid)) {
                    const distance = obj.mesh.position.distanceTo(currentPos);
                    if (distance < width / 2 + 2) {
                        hitEnemies.add(obj.mesh.uuid);
                        const damage = skillData.baseDamage || 45;
                        const damageResult = skillEffectCalculator.calculateDamage(skillData, damage);
                        obj.health -= damageResult.damage;
                        createDamageIndicator(obj.mesh.position, damageResult.damage, { color: '#aaaaaa' });
                        if (obj.health <= 0) {
                            obj.health = 0;
                        }
                    }
                }
            }


            // Check for destructible objects
            for (const obj of gameState.destructibleObjects) {
                if (!obj.isDestroyed && !hitEnemies.has(obj.mesh.uuid)) {
                    const distance = obj.mesh.position.distanceTo(currentPos);
                    if (distance < width / 2 + 2) { // 2 is approx radius of object
                        hitEnemies.add(obj.mesh.uuid);
                        const damageResult = skillEffectCalculator.calculateDamage(skillData, damage / maxTicks);
                        obj.health -= damageResult.damage;
                        createDamageIndicator(obj.mesh.position, damageResult.damage, { color: '#aaaaaa' });
                        if (obj.health <= 0) {
                            obj.health = 0;
                        }
                    }
                }
            }


            // Remove beam after duration
            setTimeout(() => {
                scene.remove(beam);
                beam.geometry.dispose();
                beam.material.dispose();
                clearInterval(damageInterval);
            }, duration * 1000);
        }

        /**
         * Create nova explosion
         */
        function createNovaExplosion(center, radius, color, damage, skillData) {
            // Create expanding ring
            const geometry = new THREE.RingGeometry(0, radius, 32);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.8,
                side: THREE.DoubleSide
            });
            const ring = new THREE.Mesh(geometry, material);
            ring.position.copy(center);
            ring.rotation.x = -Math.PI / 2;
            scene.add(ring);

            // Expand animation
            let scale = 0;
            const expandInterval = setInterval(() => {
                scale += 0.05;
                ring.scale.set(scale, scale, scale);
                material.opacity = 0.8 * (1 - scale);

                if (scale >= 1.0) {
                    clearInterval(expandInterval);
                    scene.remove(ring);
                    ring.geometry.dispose();
                    ring.material.dispose();
                }
            }, 16);

            // Damage enemies in radius
            const enemiesInRadius = gameState.npcs.filter(npc =>
                npc.type === 'villain' &&
                npc.health > 0 &&
                center.distanceTo(npc.mesh.position) < radius
            );

            enemiesInRadius.forEach(enemy => {
                const damageResult = skillEffectCalculator.calculateDamage(skillData, damage);
                enemy.health -= damageResult.damage;
                createDamageIndicator(enemy.mesh.position, damageResult.damage);

                if (enemy.health <= 0) {
                    enemy.health = 0;
                    enemy.state = 'dying';
                    enemy.dyingTimer = 0.5;
                }
            });

            // Emit particles
            emitUltimateParticles(center, color, 60);
            applyScreenShake(0.4, 0.6);
        }

        function executeMissyX2AngelUltimate(skillData, player, forward) {
            console.log('👼 Missy X2: Angel ULTIMATE!');

            const damage = skillData.damage || 550;
            const radius = skillData.judgmentRadius || 300;
            const healAmount = skillData.healAmount || 200;
            const beamDuration = skillData.beamDuration || 2.0;

            // Apply screen shake
            if (typeof applyScreenShake === 'function') {
                applyScreenShake(0.5, 1.0);
            }

            // Phase 1: Pre-cast - Screen flash and charge-up
            const playerPos = player.position.clone();
            const beamStartPos = playerPos.clone().add(new THREE.Vector3(0, 50, 0));

            // Create golden light aura
            const auraGeometry = new THREE.SphereGeometry(radius / 10, 16, 16);
            const auraMaterial = new THREE.MeshBasicMaterial({
                color: 0xFFD700,
                transparent: true,
                opacity: 0.3
            });
            const aura = new THREE.Mesh(auraGeometry, auraMaterial);
            aura.position.copy(beamStartPos);
            scene.add(aura);

            // Phase 2: Divine beam from above
            setTimeout(() => {
                // Create beam cylinder
                const beamGeometry = new THREE.CylinderGeometry(radius / 2, radius / 2, 50, 32);
                const beamMaterial = new THREE.MeshBasicMaterial({
                    color: 0xFFD700,
                    transparent: true,
                    opacity: 0.7,
                    emissive: 0xFFD700,
                    emissiveIntensity: 0.5
                });
                const beam = new THREE.Mesh(beamGeometry, beamMaterial);
                beam.position.copy(playerPos);
                beam.rotation.x = Math.PI / 2;
                scene.add(beam);

                // Damage all enemies in radius
                gameState.npcs.forEach(npc => {
                    if (npc.type === 'villain' && npc.health > 0) {
                        const distance = npc.mesh.position.distanceTo(playerPos);
                        if (distance <= radius) {
                            npc.health -= damage;
                            createDamageIndicator(npc.mesh.position, damage);
                            if (npc.health <= 0) {
                                npc.health = 0;
                                npc.state = 'dying';
                                npc.dyingTimer = 0.5;
                            }
                        }
                    }
                });

                // Heal player and party
                if (gameState.player && gameState.player.currentHealth !== undefined && gameState.player.maxHealth !== undefined) {
                    if (gameState.player.currentHealth < gameState.player.maxHealth) {
                        gameState.player.currentHealth = Math.min(
                            gameState.player.currentHealth + healAmount,
                            gameState.player.maxHealth
                        );
                    }
                }
                gameState.partyMembers.forEach(member => {
                    if (member.currentHealth < member.maxHealth) {
                        member.currentHealth = Math.min(
                            member.currentHealth + healAmount,
                            member.maxHealth
                        );
                    }
                });

                // Remove beam after duration
                setTimeout(() => {
                    scene.remove(beam);
                    scene.remove(aura);
                    beam.geometry.dispose();
                    beam.material.dispose();
                    aura.geometry.dispose();
                    aura.material.dispose();
                }, beamDuration * 1000);
            }, 500);
        }

        /**
         * Execute Unique X2: Voidlight ULTIMATE
         * - 5-layer void convergence attack
         * - Pulls enemies within 250 units toward center
         * - Each layer deals increasing damage
         */
        /**
         * Execute UNIQUE S1: Plasma Blast - Enhanced with plasma trail effects
         */
        function executeUniqueS1PlasmaBlast(skillData, player, forward) {
            console.log('🔫 UNIQUE S1: Plasma Blast!');

            const damage = skillData.damage || 120;
            const projectileCount = skillData.projectileCount || 3;
            const color = parseInt(skillData.color.replace('#', '0x'), 16) || 0x00ffff;

            const damageResult = skillEffectCalculator.calculateDamage(skillData, damage);

            // Fire plasma projectiles with enhanced trails
            for (let i = 0; i < projectileCount; i++) {
                setTimeout(() => {
                    const spreadAngle = (projectileCount > 1) ? (-0.1 + 0.2 * (i / (projectileCount - 1))) : 0;
                    const spreadQuaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), spreadAngle);
                    const direction = forward.clone().applyQuaternion(spreadQuaternion);
                    const targetPosition = player.position.clone().add(direction.multiplyScalar(200));

                    fireProjectile(player, targetPosition, 'player', damageResult.damage, color, {
                        tier: skillData.tier || 'common',
                        shape: 'sphere',
                        element: skillData.element || 'PLASMA',
                        speed: 85.0,
                        lifetime: 3.0,
                        trailEnabled: true,
                        glowEnabled: true,
                        rotationSpeed: 8 // Fast rotation for plasma
                    });
                }, i * 80);
            }

            emitSkillParticles(player.position.clone().add(new THREE.Vector3(0, 1.5, 0)), color, 18);
        }

        /**
         * Execute UNIQUE S3: Void Rift - Portal/rift mechanics with pull effects
         */
        function executeUniqueS3VoidRift(skillData, player, forward) {
            console.log('💠 UNIQUE S3: Aether Wave Beam!');

            const damage = skillData.damage || 400;
            const beamDuration = 1.5;
            const beamWidth = 4;
            const color = parseInt(skillData.color.replace('#', '0x'), 16) || 0x00ffff;

            const damageResult = skillEffectCalculator.calculateDamage(skillData, damage);

            // Create beam effect
            const beamStart = player.position.clone().add(new THREE.Vector3(0, 1.5, 0));
            const beamEnd = beamStart.clone().add(forward.multiplyScalar(200));

            createEnergyBeam(beamStart, beamEnd, beamWidth, color, beamDuration, damageResult.damage, skillData);

            emitSkillParticles(beamStart, color, 25);
            applyScreenShake(0.2, 0.3);
        }

        /**
         * Execute UNIQUE S4: Energy Overload - Chain lightning with bounce effects
         */
        function executeUniqueS4EnergyOverload(skillData, player, forward) {
            console.log('❄️ UNIQUE S4: Absolute Zero Rail + Cryo Barrage!');

            const railDuration = skillData.railDuration || 0.45;
            const railTicksPerSec = skillData.railTicksPerSec || 12;
            const cryoCount = skillData.cryoCount || 4;
            const cryoDamage = skillData.cryoDamage || 180;
            const color = parseInt(skillData.color.replace('#', '0x'), 16) || 0x87CEEB;

            // Create rail beam
            const railStart = player.position.clone().add(new THREE.Vector3(0, 1.5, 0));
            const railEnd = railStart.clone().add(forward.multiplyScalar(200));
            const railWidth = 3;

            createCryoRail(railStart, railEnd, railWidth, color, railDuration, railTicksPerSec, skillData);

            // Fire cryo projectiles
            setTimeout(() => {
                for (let i = 0; i < cryoCount; i++) {
                    const angle = (i / cryoCount) * Math.PI * 2;
                    const direction = forward.clone().applyAxisAngle(new THREE.Vector3(0, 1, 0), angle);
                    const targetPos = player.position.clone().add(direction.multiplyScalar(200));

                    fireProjectile(player, targetPos, 'player', cryoDamage, color, {
                        tier: skillData.tier || 'epic',
                        shape: 'star',
                        element: skillData.element || 'ICE',
                        speed: 80.0,
                        lifetime: 3.0,
                        trailEnabled: true,
                        glowEnabled: true,
                        rotationSpeed: 5
                    });
                }
            }, railDuration * 1000);

            emitSkillParticles(railStart, color, 30);
            applyScreenShake(0.2, 0.35);
        }

        /**
         * Execute UNIQUE S5: Quantum Strike - Teleport strike with quantum effects
         */
        function executeUniqueS5QuantumStrike(skillData, player, forward) {
            console.log('🔩 UNIQUE S5: Ion Helix Drill!');

            const drillDuration = skillData.drillDuration || 0.9;
            const drillTicksPerSec = skillData.drillTicksPerSec || 15;
            const pullStrength = skillData.pullStrength || 120;
            const endBurst = skillData.endBurst || 220;
            const color = parseInt(skillData.color.replace('#', '0x'), 16) || 0x00ffff;

            // Create helix drill beam
            const drillStart = player.position.clone().add(new THREE.Vector3(0, 1.5, 0));
            const drillEnd = drillStart.clone().add(forward.multiplyScalar(200));
            const drillWidth = 5;

            createHelixDrill(drillStart, drillEnd, drillWidth, color, drillDuration, drillTicksPerSec, pullStrength, endBurst, skillData);

            emitSkillParticles(drillStart, color, 35);
            applyScreenShake(0.25, 0.4);
        }

        /**
         * Execute UNIQUE X1: Void Convergence - Ultimate with void pull mechanics
         */
        function executeUniqueX1VoidConvergence(skillData, player, forward) {
            console.log('⚡ UNIQUE X1: Hyper Ion Wave!');

            // Check charge level
            const chargeLevel = gameState.player?.chargeLevel || 1.0;
            const chargeTiers = skillData.charge || { t1: 0.60, t2: 1.00 };

            let tier = 1;
            if (chargeLevel >= chargeTiers.t2) tier = 3;
            else if (chargeLevel >= chargeTiers.t1) tier = 2;

            const beamDuration = skillData.beamDuration || 1.6;
            const beamTicksPerSec = skillData.beamTicksPerSec || 16;
            const beamWidth = Array.isArray(skillData.beamWidth) ? skillData.beamWidth[tier - 1] : (skillData.beamWidth || 80);
            const endCone = Array.isArray(skillData.endCone) ? skillData.endCone[tier - 1] : (skillData.endCone || 200);
            const color = parseInt(skillData.color.replace('#', '0x'), 16) || 0x00ffff;

            // Create aurora burst beam
            const beamStart = player.position.clone().add(new THREE.Vector3(0, 1.5, 0));
            const beamEnd = beamStart.clone().add(forward.multiplyScalar(200));

            createAuroraBurstBeam(beamStart, beamEnd, beamWidth, endCone, color, beamDuration, beamTicksPerSec, skillData, tier);

            // Apply freeze stacks
            if (skillData.deepChillStacks) {
                const enemiesInBeam = gameState.npcs.filter(npc =>
                    npc.type === 'villain' &&
                    npc.health > 0 &&
                    beamStart.distanceTo(npc.mesh.position) < 200
                );
                enemiesInBeam.forEach(enemy => {
                    statusEffectManager.applyEffect(enemy.mesh.uuid, 'FREEZE', 3.0, skillData.deepChillStacks, skillData.id);
                });
            }

            applyScreenShake(0.3 + (tier * 0.1), 0.5 + (tier * 0.2));
            emitUltimateParticles(beamStart, color, 55);
        }

        /**
         * Create energy beam effect
         */
        function createEnergyBeam(start, end, width, color, duration, damage, skillData) {
            const direction = new THREE.Vector3().subVectors(end, start).normalize();
            const length = start.distanceTo(end);

            const geometry = new THREE.CylinderGeometry(width / 2, width / 2, length, 16);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.8,
                emissive: color,
                emissiveIntensity: 0.5
            });
            const beam = new THREE.Mesh(geometry, material);
            beam.position.copy(start.clone().add(end).multiplyScalar(0.5));
            beam.lookAt(end);
            scene.add(beam);

            // Apply damage
            const tickInterval = 1.0 / 12;
            let tickCount = 0;
            const maxTicks = Math.floor(duration / tickInterval);
            const hitEnemies = new Set();

            const damageInterval = setInterval(() => {
                tickCount++;
                const currentPos = start.clone().add(direction.clone().multiplyScalar((tickCount / maxTicks) * length));

                for (const npc of gameState.npcs) {
                    if (npc.type === 'villain' && npc.health > 0 && !hitEnemies.has(npc.mesh.uuid)) {
                        const distance = npc.mesh.position.distanceTo(currentPos);
                        if (distance < width / 2 + 2) {
                            hitEnemies.add(npc.mesh.uuid);
                            const damageResult = skillEffectCalculator.calculateDamage(skillData, damage / maxTicks);
                            npc.health -= damageResult.damage;
                            createDamageIndicator(npc.mesh.position, damageResult.damage);

                            if (npc.health <= 0) {
                                npc.health = 0;
                                npc.state = 'dying';
                                npc.dyingTimer = 0.5;
                            }
                        }
                    }
                }

                if (tickCount >= maxTicks) {
                    clearInterval(damageInterval);
                }
            }, tickInterval * 1000);

            setTimeout(() => {
                scene.remove(beam);
                beam.geometry.dispose();
                beam.material.dispose();
                clearInterval(damageInterval);
            }, duration * 1000);
        }

        /**
         * Create cryo rail beam
         */
        function createCryoRail(start, end, width, color, duration, ticksPerSec, skillData) {
            const direction = new THREE.Vector3().subVectors(end, start).normalize();
            const length = start.distanceTo(end);

            const geometry = new THREE.CylinderGeometry(width / 2, width / 2, length, 16);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.7
            });
            const rail = new THREE.Mesh(geometry, material);
            rail.position.copy(start.clone().add(end).multiplyScalar(0.5));
            rail.lookAt(end);
            scene.add(rail);

            const tickInterval = 1.0 / ticksPerSec;
            let tickCount = 0;
            const maxTicks = Math.floor(duration * ticksPerSec);
            const hitEnemies = new Set();

            const damageInterval = setInterval(() => {
                tickCount++;
                const currentPos = start.clone().add(direction.clone().multiplyScalar((tickCount / maxTicks) * length));

                for (const npc of gameState.npcs) {
                    if (npc.type === 'villain' && npc.health > 0 && !hitEnemies.has(npc.mesh.uuid)) {
                        const distance = npc.mesh.position.distanceTo(currentPos);
                        if (distance < width / 2 + 2) {
                            hitEnemies.add(npc.mesh.uuid);
                            const damage = skillData.baseDamage || 45;
                            const damageResult = skillEffectCalculator.calculateDamage(skillData, damage);
                            npc.health -= damageResult.damage;
                            createDamageIndicator(npc.mesh.position, damageResult.damage, {
                                isCrit: damageResult.isCrit,
                                element: damageResult.element
                            });

                            // Play hit sound
                            if (damageResult.isCrit) {
                                playSound('crit', { element: damageResult.element });
                            } else {
                                playSound('hit', { element: damageResult.element });
                            }

                            // Apply freeze
                            if (skillData.freeze) {
                                statusEffectManager.applyEffect(npc.mesh.uuid, 'FREEZE', 1.0, 1, skillData.id);
                            }

                            if (npc.health <= 0) {
                                npc.health = 0;
                                npc.state = 'dying';
                                npc.dyingTimer = 0.5;
                            }
                        }
                    }
                }

                if (tickCount >= maxTicks) {
                    clearInterval(damageInterval);
                }
            }, tickInterval * 1000);

            setTimeout(() => {
                scene.remove(rail);
                rail.geometry.dispose();
                rail.material.dispose();
                clearInterval(damageInterval);
            }, duration * 1000);
        }

        /**
         * Create helix drill effect
         */
        function createHelixDrill(start, end, width, color, duration, ticksPerSec, pullStrength, endBurst, skillData) {
            const direction = new THREE.Vector3().subVectors(end, start).normalize();
            const length = start.distanceTo(end);

            // Create rotating helix visual
            const helixParticles = [];
            for (let i = 0; i < 20; i++) {
                const angle = (i / 20) * Math.PI * 4;
                const radius = width / 2;
                const height = (i / 20) * length;
                const particle = {
                    mesh: new THREE.Mesh(
                        new THREE.SphereGeometry(0.3, 4, 4),
                        new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.8 })
                    ),
                    startAngle: angle,
                    radius: radius,
                    height: height,
                    lifetime: duration,
                    maxLifetime: duration
                };
                const pos = start.clone().add(new THREE.Vector3(
                    Math.cos(angle) * radius,
                    height,
                    Math.sin(angle) * radius
                ));
                particle.mesh.position.copy(pos);
                scene.add(particle.mesh);
                helixParticles.push(particle);
            }

            // Apply damage and pull
            const tickInterval = 1.0 / ticksPerSec;
            let tickCount = 0;
            const maxTicks = Math.floor(duration * ticksPerSec);
            const hitEnemies = new Set();

            const damageInterval = setInterval(() => {
                tickCount++;
                const currentPos = start.clone().add(direction.clone().multiplyScalar((tickCount / maxTicks) * length));

                // Pull enemies
                for (const npc of gameState.npcs) {
                    if (npc.type === 'villain' && npc.health > 0) {
                        const distance = npc.mesh.position.distanceTo(currentPos);
                        if (distance < 10) {
                            const pullDir = new THREE.Vector3().subVectors(currentPos, npc.mesh.position).normalize();
                            npc.mesh.position.add(pullDir.multiplyScalar(pullStrength * 0.016));
                        }
                    }
                }

                // Damage enemies in drill
                for (const npc of gameState.npcs) {
                    if (npc.type === 'villain' && npc.health > 0 && !hitEnemies.has(npc.mesh.uuid)) {
                        const distance = npc.mesh.position.distanceTo(currentPos);
                        if (distance < width / 2 + 2) {
                            hitEnemies.add(npc.mesh.uuid);
                            const damage = skillData.baseDamage || 38;
                            const damageResult = skillEffectCalculator.calculateDamage(skillData, damage);
                            npc.health -= damageResult.damage;
                            createDamageIndicator(npc.mesh.position, damageResult.damage, {
                                isCrit: damageResult.isCrit,
                                element: damageResult.element
                            });

                            // Play hit sound
                            if (damageResult.isCrit) {
                                playSound('crit', { element: damageResult.element });
                            } else {
                                playSound('hit', { element: damageResult.element });
                            }

                            if (npc.health <= 0) {
                                npc.health = 0;
                                npc.state = 'dying';
                                npc.dyingTimer = 0.5;
                            }
                        }
                    }
                }

                if (tickCount >= maxTicks) {
                    clearInterval(damageInterval);
                }
            }, tickInterval * 1000);

            // End burst
            setTimeout(() => {
                const burstEnemies = gameState.npcs.filter(npc =>
                    npc.type === 'villain' &&
                    npc.health > 0 &&
                    end.distanceTo(npc.mesh.position) < width * 2
                );

                burstEnemies.forEach(enemy => {
                    const damageResult = skillEffectCalculator.calculateDamage(skillData, endBurst);
                    enemy.health -= damageResult.damage;
                    createDamageIndicator(enemy.mesh.position, damageResult.damage);

                    if (enemy.health <= 0) {
                        enemy.health = 0;
                        enemy.state = 'dying';
                        enemy.dyingTimer = 0.5;
                    }
                });

                // Cleanup helix particles
                helixParticles.forEach(p => {
                    scene.remove(p.mesh);
                    p.mesh.geometry.dispose();
                    p.mesh.material.dispose();
                });
                clearInterval(damageInterval);
            }, duration * 1000);
        }

        /**
         * Create aurora burst beam
         */
        function createAuroraBurstBeam(start, end, width, endCone, color, duration, ticksPerSec, skillData, tier) {
            const direction = new THREE.Vector3().subVectors(end, start).normalize();
            const length = start.distanceTo(end);

            // Create beam
            const geometry = new THREE.ConeGeometry(width / 2, length, 16);
            const material = new THREE.MeshBasicMaterial({
                color: color,
                transparent: true,
                opacity: 0.6,
                emissive: color,
                emissiveIntensity: 0.4
            });
            const beam = new THREE.Mesh(geometry, material);
            beam.position.copy(start);
            beam.lookAt(end);
            scene.add(beam);

            // Apply damage
            const tickInterval = 1.0 / ticksPerSec;
            let tickCount = 0;
            const maxTicks = Math.floor(duration * ticksPerSec);
            const hitEnemies = new Set();

            const damageInterval = setInterval(() => {
                tickCount++;
                const progress = tickCount / maxTicks;
                const currentWidth = width + (endCone - width) * progress;
                const currentPos = start.clone().add(direction.clone().multiplyScalar(progress * length));

                for (const npc of gameState.npcs) {
                    if (npc.type === 'villain' && npc.health > 0 && !hitEnemies.has(npc.mesh.uuid)) {
                        const distance = npc.mesh.position.distanceTo(currentPos);
                        const effectiveRadius = currentWidth / 2;
                        if (distance < effectiveRadius + 2) {
                            hitEnemies.add(npc.mesh.uuid);
                            const baseDamage = Array.isArray(skillData.baseDamage) ? skillData.baseDamage[tier - 1] : (skillData.baseDamage || 34);
                            const damageResult = skillEffectCalculator.calculateDamage(skillData, baseDamage);
                            npc.health -= damageResult.damage;
                            createDamageIndicator(npc.mesh.position, damageResult.damage);

                            if (npc.health <= 0) {
                                npc.health = 0;
                                npc.state = 'dying';
                                npc.dyingTimer = 0.5;
                            }
                        }
                    }
                }

                if (tickCount >= maxTicks) {
                    clearInterval(damageInterval);
                }
            }, tickInterval * 1000);

            setTimeout(() => {
                scene.remove(beam);
                beam.geometry.dispose();
                beam.material.dispose();
                clearInterval(damageInterval);
            }, duration * 1000);
        }

        function executeUniqueX2VoidlightUltimate(skillData, player, forward) {
            console.log('🌌 Unique X2: Voidlight ULTIMATE!');

            const baseDamage = skillData.damage || 600;
            const pullRadius = skillData.voidPull || 250;
            const layers = skillData.convergenceLayers || 5;
            const layerDamage = skillData.layerDamage || [100, 150, 200, 250, 300];

            // Apply screen shake
            if (typeof applyScreenShake === 'function') {
                applyScreenShake(0.5, 1.0);
            }

            const playerPos = player.position.clone();
            const centerPos = playerPos.clone();

            // Create void convergence center
            const voidCenterGeometry = new THREE.SphereGeometry(5, 16, 16);
            const voidCenterMaterial = new THREE.MeshBasicMaterial({
                color: 0x8A2BE2,
                transparent: true,
                opacity: 0.8,
                emissive: 0x8A2BE2,
                emissiveIntensity: 0.7
            });
            const voidCenter = new THREE.Mesh(voidCenterGeometry, voidCenterMaterial);
            voidCenter.position.copy(centerPos);
            scene.add(voidCenter);

            // Phase 1: Pull enemies toward center
            gameState.npcs.forEach(npc => {
                if (npc.type === 'villain' && npc.health > 0) {
                    const distance = npc.mesh.position.distanceTo(centerPos);
                    if (distance <= pullRadius) {
                        // Pull effect
                        const pullDirection = new THREE.Vector3().subVectors(centerPos, npc.mesh.position).normalize();
                        const pullStrength = (pullRadius - distance) / pullRadius;
                        npc.mesh.position.add(pullDirection.multiplyScalar(pullStrength * 5));
                    }
                }
            });

            // Phase 2: Layer convergence attacks
            for (let layer = 0; layer < layers; layer++) {
                setTimeout(() => {
                    // Create layer ring
                    const ringRadius = (pullRadius / layers) * (layer + 1);
                    const ringGeometry = new THREE.RingGeometry(ringRadius - 5, ringRadius + 5, 32);
                    const ringMaterial = new THREE.MeshBasicMaterial({
                        color: 0x8A2BE2,
                        transparent: true,
                        opacity: 0.6,
                        side: THREE.DoubleSide
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.position.copy(centerPos);
                    ring.rotation.x = Math.PI / 2;
                    scene.add(ring);

                    // Damage enemies in this layer
                    gameState.npcs.forEach(npc => {
                        if (npc.type === 'villain' && npc.health > 0) {
                            const distance = npc.mesh.position.distanceTo(centerPos);
                            const layerMinRadius = (pullRadius / layers) * layer;
                            const layerMaxRadius = (pullRadius / layers) * (layer + 1);

                            if (distance >= layerMinRadius && distance <= layerMaxRadius) {
                                const damage = layerDamage[layer] || baseDamage;
                                npc.health -= damage;
                                createDamageIndicator(npc.mesh.position, damage);
                                if (npc.health <= 0) {
                                    npc.health = 0;
                                    npc.state = 'dying';
                                    npc.dyingTimer = 0.5;
                                }
                            }
                        }
                    });

                    // Damage destructible objects
                    gameState.destructibleObjects.forEach(obj => {
                        if (!obj.isDestroyed) {
                            const distance = obj.mesh.position.distanceTo(centerPos);
                            const layerMinRadius = (pullRadius / layers) * layer;
                            const layerMaxRadius = (pullRadius / layers) * (layer + 1);

                            if (distance >= layerMinRadius && distance <= layerMaxRadius) {
                                const damage = layerDamage[layer] || baseDamage;
                                obj.health -= damage;
                                createDamageIndicator(obj.mesh.position, damage, { color: '#aaaaaa' });
                                if (obj.health <= 0) {
                                    obj.health = 0;
                                }
                            }
                        }
                    });


                    // Remove ring after animation
                    setTimeout(() => {
                        scene.remove(ring);
                        ring.geometry.dispose();
                        ring.material.dispose();
                    }, 500);
                }, layer * 300);
            }

            // Remove void center after all layers
            setTimeout(() => {
                scene.remove(voidCenter);
                voidCenter.geometry.dispose();
                voidCenter.material.dispose();
            }, layers * 300 + 500);
        }

        function updateSummons(deltaTime) {
            const AGGRO_RADIUS = 40;
            const SHOOTING_RANGE = 35;

            for (let i = gameState.summons.length - 1; i >= 0; i--) {
                const summon = gameState.summons[i];
                summon.lifetime -= deltaTime;

                if (summon.lifetime <= 0) {
                    scene.remove(summon.mesh);
                    gameState.summons.splice(i, 1);
                    continue;
                }

                if (summon.attackCooldown > 0) {
                    summon.attackCooldown -= deltaTime;
                }

                // AI: Find target
                if (!summon.attackTarget || summon.attackTarget.health <= 0) {
                    summon.attackTarget = null;
                    let closestDistance = AGGRO_RADIUS;
                    for (const npc of gameState.npcs) {
                        if (npc.type === 'villain' && npc.health > 0) {
                            const distance = summon.mesh.position.distanceTo(npc.mesh.position);
                            if (distance < closestDistance) {
                                closestDistance = distance;
                                summon.attackTarget = npc;
                            }
                        }
                    }
                }

                // AI: Attack target
                if (summon.attackTarget) {
                    const distance = summon.mesh.position.distanceTo(summon.attackTarget.mesh.position);
                    if (distance > SHOOTING_RANGE) {
                        // Chase
                        const direction = new THREE.Vector3().subVectors(summon.attackTarget.mesh.position, summon.mesh.position).normalize();
                        summon.mesh.position.add(direction.multiplyScalar(deltaTime * 10));
                    }

                    summon.mesh.lookAt(summon.attackTarget.mesh.position);

                    if (distance < SHOOTING_RANGE && summon.attackCooldown <= 0) {
                        fireProjectile(summon.mesh, summon.attackTarget.mesh.position, 'player', summon.damage, 0x00aaff);
                        summon.attackCooldown = 1.5;
                    }
                }
            }
        }

        function updateProjectiles(deltaTime) {
            // Update ProjectileSystem projectiles
            if (projectileSystem) {
                projectileSystem.update(deltaTime);
            }

            // Update legacy projectiles and handle collisions
            for (let i = gameState.projectiles.length - 1; i >= 0; i--) {
                const projectile = gameState.projectiles[i];
                let projectileRemoved = false;

                // Handle X-shaped projectiles (special rendering)
                if (projectile.isXProjectile) {
                    // Update X projectile with homing
                    if (projectile.target && projectile.target.health > 0) {
                        // Update target position
                        projectile.targetPos = projectile.target.mesh.position.clone();
                        projectile.targetPos.y += 1.0;

                        // Calculate homing direction
                        const toTarget = new THREE.Vector3().subVectors(projectile.targetPos, projectile.position).normalize();
                        const currentDir = projectile.velocity.clone().normalize();

                        // Blend current direction with target direction (homing)
                        const homedDir = currentDir.lerp(toTarget, projectile.homingStrength * deltaTime);
                        const speed = projectile.velocity.length();
                        projectile.velocity = homedDir.multiplyScalar(speed);
                    }

                    // Update position
                    projectile.position.add(projectile.velocity.clone().multiplyScalar(deltaTime));
                    projectile.rotation += projectile.rotationSpeed * deltaTime;
                    projectile.lifetime -= deltaTime;

                    // Update X line positions (rotate around center)
                    const center = projectile.position;
                    const size = projectile.size || 0.6; // Increased by 50% from 0.4 to 0.6
                    const cos = Math.cos(projectile.rotation);
                    const sin = Math.sin(projectile.rotation);

                    // Calculate forward direction for X orientation
                    const forward = projectile.velocity.clone().normalize();
                    const right = new THREE.Vector3(1, 0, 0).applyQuaternion(
                        new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(0, 0, -1), forward)
                    );
                    const up = new THREE.Vector3(0, 1, 0);

                    // X shape: two crossing lines
                    // Line 1: Red (diagonal top-left to bottom-right)
                    const offset1 = right.clone().multiplyScalar(size * cos).add(up.clone().multiplyScalar(size * sin));
                    projectile.line1Start = center.clone().add(offset1);
                    projectile.line1End = center.clone().sub(offset1);

                    // Line 2: Black (diagonal top-right to bottom-left)
                    const offset2 = right.clone().multiplyScalar(size * sin).sub(up.clone().multiplyScalar(size * cos));
                    projectile.line2Start = center.clone().add(offset2);
                    projectile.line2End = center.clone().sub(offset2);

                    if (projectile.lifetime <= 0) {
                        gameState.projectiles.splice(i, 1);
                        continue;
                    }

                    // Check collision for X projectiles
                    if (projectile.target && projectile.target.health > 0) {
                        const distance = projectile.position.distanceTo(projectile.target.mesh.position);
                        if (distance < 1.5) {
                            // Hit enemy
                            projectile.target.health -= projectile.damage;
                            createDamageIndicator(projectile.target.mesh.position, projectile.damage);
                            playSound('hit');

                            if (projectile.target.health <= 0) {
                                projectile.target.health = 0;
                                projectile.target.state = 'dying';
                                projectile.target.dyingTimer = 0.5;
                                PlayerState.gainXP(25);
                            }

                            // Create impact effect
                            emitSkillParticles(projectile.position, 0xff0000, 15);
                            gameState.projectiles.splice(i, 1);
                            continue;
                        }
                    }

                    // Skip normal collision for X projectiles (handled above)
                    continue;
                }

                // Skip if this projectile is managed by ProjectileSystem (it will be updated there)
                if (projectile.projectileSystemRef) {
                    // Apply homing to ProjectileSystem projectiles if they have a target
                    if (projectile.projectileSystemRef.homingTarget) {
                        const target = projectile.projectileSystemRef.homingTarget;
                        if (target.health > 0) {
                            const targetPos = target.mesh ? target.mesh.position.clone() : target.position.clone();
                            targetPos.y += 1.0;
                            const toTarget = new THREE.Vector3().subVectors(targetPos, projectile.mesh.position).normalize();
                            const currentDir = projectile.projectileSystemRef.velocity.clone().normalize();
                            const homedDir = currentDir.lerp(toTarget, 3.0 * deltaTime);
                            const speed = projectile.projectileSystemRef.velocity.length();
                            projectile.projectileSystemRef.velocity = homedDir.multiplyScalar(speed);
                        }
                    }

                    // Check if it was removed by ProjectileSystem
                    if (projectile.projectileSystemRef.hasHit || projectile.projectileSystemRef.lifetime <= 0) {
                        gameState.projectiles.splice(i, 1);
                        continue;
                    }
                    // Update position from ProjectileSystem
                    projectile.mesh.position.copy(projectile.projectileSystemRef.mesh.position);
                } else if (projectile.mesh) {
                    // Legacy projectile update with homing
                    if (projectile.homingTarget && projectile.homingTarget.health > 0) {
                        const targetPos = projectile.homingTarget.mesh.position.clone();
                        targetPos.y += 1.0;
                        const toTarget = new THREE.Vector3().subVectors(targetPos, projectile.mesh.position).normalize();
                        const currentDir = projectile.velocity.clone().normalize();
                        const homedDir = currentDir.lerp(toTarget, 3.0 * deltaTime);
                        const speed = projectile.velocity.length();
                        projectile.velocity = homedDir.multiplyScalar(speed);
                    }

                    projectile.mesh.position.add(projectile.velocity.clone().multiplyScalar(deltaTime));
                    projectile.lifetime -= deltaTime;
                    if (projectile.lifetime <= 0) {
                        scene.remove(projectile.mesh);
                        projectile.mesh.geometry.dispose();
                        projectile.mesh.material.dispose();
                        gameState.projectiles.splice(i, 1);
                        continue;
                    }
                }

                // --- Projectile Collision Detection ---
                // Check if projectile was deflected (team changed to 'player')
                if (projectile.team === 'player' || projectile.team === 'hero') {
                    // This projectile targets villains (including deflected bullets)
                    for (let j = gameState.npcs.length - 1; j >= 0; j--) {
                        const npc = gameState.npcs[j];
                        if (npc.type === 'villain' && npc.health > 0 && projectile.mesh.position.distanceTo(npc.mesh.position) < 1.5) {
                            let damage = projectile.damage;
                            // Apply rage multiplier if active
                            if (projectile.team === 'player' && gameState.activeCharacter.rageMultiplier) {
                                damage *= gameState.activeCharacter.rageMultiplier;
                            }
                            npc.health -= damage;
                            createDamageIndicator(npc.mesh.position, damage, {
                                isCrit: projectile.projectileSystemRef && projectile.projectileSystemRef.damage > projectile.damage
                            });
                            playSound('hit');

                            // Create impact effect
                            if (projectile.projectileSystemRef) {
                                const color = parseInt(projectile.mesh.material.color.getHex(), 16);
                                const tier = projectile.projectileSystemRef.tier || 'common';
                                projectileSystem.createImpactEffect(npc.mesh.position.clone(), color, tier);
                                projectile.projectileSystemRef.hasHit = true;
                            }

                            if (npc.health <= 0) {
                                npc.health = 0;
                                npc.state = 'dying';
                                npc.dyingTimer = 0.5; // Start the death animation
                                if (projectile.team === 'player') PlayerState.gainXP(25);
                            }
                            projectileRemoved = true;
                            break;
                        }
                    }
                } else if (projectile.team === 'villain') {
                    // This projectile targets player and heroes (party members + good npcs)

                    // Check for bullet deflection first (only for A1)
                    const characterId = gameState.activeCharacter.characterId || 'A1';
                    if (characterId === 'A1' && bulletDeflectionSystem && swordSwingSystem) {
                        const deflectionInfo = bulletDeflectionSystem.checkBulletDeflection(
                            projectile,
                            gameState.activeCharacter.mesh,
                            characterId
                        );

                        if (deflectionInfo && deflectionInfo.canDeflect && gameState.player && gameState.player.mesh) {
                            // Deflect the bullet
                            bulletDeflectionSystem.deflectBullet(projectile, deflectionInfo, gameState.player.mesh);
                            // Don't remove projectile, it's now deflected back
                            continue;
                        }
                    }

                    // Check player (only if not deflected)
                    if (gameState.activeCharacter.currentHealth > 0 && projectile.mesh.position.distanceTo(gameState.activeCharacter.mesh.position) < 1.5) {
                        let damage = projectile.damage;
                        // Apply shield multiplier if active
                        if (gameState.activeCharacter.shieldMultiplier) {
                            damage *= gameState.activeCharacter.shieldMultiplier;
                        }
                        gameState.activeCharacter.currentHealth -= damage;
                        createDamageIndicator(gameState.activeCharacter.mesh.position, damage);
                        playSound('hit');

                        // Create impact effect
                        if (projectile.projectileSystemRef) {
                            const color = parseInt(projectile.mesh.material.color.getHex(), 16);
                            const tier = projectile.projectileSystemRef.tier || 'common';
                            projectileSystem.createImpactEffect(gameState.activeCharacter.mesh.position.clone(), color, tier);
                            projectile.projectileSystemRef.hasHit = true;
                        }

                        if (gameState.activeCharacter.currentHealth < 0) gameState.activeCharacter.currentHealth = 0;
                        projectileRemoved = true;
                    }

                    // This block was erroneous and has been removed. Projectile-environment collision is handled elsewhere.

                    // Check party members
                    if (!projectileRemoved) {
                        for (const member of gameState.partyMembers) {
                            if (member.currentHealth > 0 && projectile.mesh.position.distanceTo(member.mesh.position) < 1.5) {
                                member.currentHealth -= projectile.damage;
                                createDamageIndicator(member.mesh.position, projectile.damage);
                                playSound('hit');
                                if (member.currentHealth < 0) member.currentHealth = 0;
                                projectileRemoved = true;
                                break;
                            }
                        }
                    }
                    // Check hero NPCs
                    if (!projectileRemoved) {
                        for (const npc of gameState.npcs) {
                            if (npc.type === 'hero' && npc.health > 0 && projectile.mesh.position.distanceTo(npc.mesh.position) < 1.5) {
                                npc.health -= projectile.damage;
                                createDamageIndicator(npc.mesh.position, projectile.damage);
                                playSound('hit');
                                if (npc.health < 0) npc.health = 0; // Don't remove hero NPCs on death yet
                                projectileRemoved = true;
                                break;
                            }
                        }
                    }
                }

                // --- Environmental Collision ---
                if (!projectileRemoved) {
                    for (const destructible of gameState.destructibleObjects) {
                        if (destructible.isDestroyed) continue;

                        const projectileBox = new THREE.Box3().setFromObject(projectile.mesh);
                        const objectBox = new THREE.Box3().setFromObject(destructible.mesh);

                        if (projectileBox.intersectsBox(objectBox)) {
                            destructible.health -= projectile.damage;
                            createDamageIndicator(projectile.mesh.position, projectile.damage, { color: '#aaaaaa' });

                            if (projectile.projectileSystemRef) {
                                projectileSystem.createImpactEffect(projectile.mesh.position, 0x888888, 'common');
                                projectile.projectileSystemRef.hasHit = true;
                            }

                            projectileRemoved = true;
                            break;
                        }
                    }
                }

                // --- NEW: Check DestructibleSystem Objects ---
                if (!projectileRemoved && window.destructibleSystem) {
                    for (let k = window.destructibleSystem.objects.length - 1; k >= 0; k--) {
                        const obj = window.destructibleSystem.objects[k];
                        if (projectile.mesh.position.distanceTo(obj.mesh.position) < 2.0) {
                            window.destructibleSystem.takeDamage(obj, projectile.damage);

                            // Impact FX
                            if (projectile.projectileSystemRef) {
                                const color = parseInt(projectile.mesh.material.color.getHex(), 16);
                                const tier = projectile.projectileSystemRef.tier || 'common';
                                projectileSystem.createImpactEffect(obj.mesh.position.clone(), color, tier);
                                projectile.projectileSystemRef.hasHit = true;
                            }

                            projectileRemoved = true;
                            break;
                        }
                    }
                }


                if (projectileRemoved) {
                    scene.remove(projectile.mesh);
                    projectile.mesh.geometry.dispose();
                    projectile.mesh.material.dispose();
                    gameState.projectiles.splice(i, 1);
                    continue;
                }

                projectile.lifetime -= deltaTime;
                if (projectile.lifetime <= 0) {
                    scene.remove(projectile.mesh);
                    projectile.mesh.geometry.dispose();
                    projectile.mesh.material.dispose();
                    gameState.projectiles.splice(i, 1);
                }
            }
        }

        // -- CAMERA LOGIC --
        // -- UI & FEEDBACK LOGIC --
        /**
         * Enhanced damage indicator with element colors and crit support
         */
        function createDamageIndicator(position3D, amount, options = {}) {
            const {
                isCrit = false,
                element = 'PHYSICAL',
                color = null
            } = options;

            const container = document.getElementById('damage-container');
            if (!container) return;

            const elem = document.createElement('div');
            elem.className = 'damage-text';

            // Determine color based on element or provided color
            let damageColor = color;
            if (!damageColor) {
                const elementColors = {
                    'PHYSICAL': '#ffffff',
                    'FIRE': '#ff4400',
                    'ICE': '#00ccff',
                    'LIGHTNING': '#ffff00',
                    'SHADOW': '#8b00ff',
                    'LIGHT': '#ffd700',
                    'ARCANE': '#8A2BE2',
                    'PLASMA': '#00ffff',
                    'ENERGY': '#00ff00',
                    'SUMMON': '#ff69b4'
                };
                damageColor = elementColors[element] || '#ffffff';
            }

            // Style based on crit and element
            if (isCrit) {
                elem.textContent = `CRIT! ${Math.round(amount)}`;
                elem.style.fontSize = '28px';
                elem.style.fontWeight = 'bold';
                elem.style.color = '#ffd700';
                elem.style.textShadow = '0 0 10px #ffd700, 0 0 20px #ffd700';
            } else {
                elem.textContent = Math.round(amount);
                elem.style.color = damageColor;
                elem.style.textShadow = `0 0 5px ${damageColor}, 0 0 10px ${damageColor}`;
            }

            const indicator = {
                element: elem,
                position: position3D.clone(),
                lifetime: isCrit ? 1.5 : 1.0,
                isCrit: isCrit
            };

            gameState.damageIndicators.push(indicator);
            container.appendChild(elem);
        }

        function updateDamageIndicators(deltaTime) {
            const container = document.getElementById('damage-container');
            for (let i = gameState.damageIndicators.length - 1; i >= 0; i--) {
                const indicator = gameState.damageIndicators[i];
                indicator.lifetime -= deltaTime;

                if (indicator.lifetime <= 0) {
                    container.removeChild(indicator.element);
                    gameState.damageIndicators.splice(i, 1);
                    continue;
                }

                // Project 3D position to 2D screen space
                const screenPos = indicator.position.clone().project(camera);
                const x = (screenPos.x * 0.5 + 0.5) * window.innerWidth;
                const y = (screenPos.y * -0.5 + 0.5) * window.innerHeight;

                indicator.element.style.left = `${x}px`;
                indicator.element.style.top = `${y}px`;

                // Animate upwards
                const progress = 1.0 - (indicator.lifetime / 1.0);
                indicator.element.style.transform = `translateY(-${progress * 60}px)`;
                indicator.element.style.opacity = indicator.lifetime;
            }
        }

        /**
         * Apply screen shake effect
         */
        function applyScreenShake(intensity = 0.1, duration = 0.2) {
            if (!camera) return;

            const originalPosition = camera.position.clone();
            let elapsed = 0;
            const maxOffset = intensity * 2;

            const shake = () => {
                elapsed += 16; // ~60fps
                const progress = elapsed / (duration * 1000);

                if (progress >= 1) {
                    camera.position.copy(originalPosition);
                    return;
                }

                // Random offset that decreases over time
                const currentIntensity = maxOffset * (1 - progress);
                const offsetX = (Math.random() - 0.5) * currentIntensity;
                const offsetY = (Math.random() - 0.5) * currentIntensity;
                const offsetZ = (Math.random() - 0.5) * currentIntensity;

                camera.position.set(
                    originalPosition.x + offsetX,
                    originalPosition.y + offsetY,
                    originalPosition.z + offsetZ
                );

                requestAnimationFrame(shake);
            };

            shake();
        }

        /**
         * Show skill name popup
         */
        function showSkillNamePopup(skillData) {
            const container = document.getElementById('damage-container');
            if (!container) return;

            const elem = document.createElement('div');
            elem.className = 'skill-name-popup';
            elem.style.cssText = `
                position: fixed;
                top: 15%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: 36px;
                font-weight: bold;
                text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
                z-index: 1000;
                pointer-events: none;
                transition: all 0.3s ease;
            `;

            // Color code by tier
            const tierColors = {
                'common': '#FFFFFF',
                'uncommon': '#00FF00',
                'rare': '#0080FF',
                'epic': '#8000FF',
                'legendary': '#FFD700'
            };
            elem.style.color = tierColors[skillData.tier] || '#FFFFFF';

            elem.textContent = skillData.name;
            container.appendChild(elem);

            // Animate: scale up, fade out, move upward
            setTimeout(() => {
                elem.style.transform = 'translate(-50%, -70%) scale(1.3)';
                elem.style.opacity = '0.9';
            }, 10);

            setTimeout(() => {
                if (elem.parentNode) {
                    elem.style.opacity = '0';
                    elem.style.transform = 'translate(-50%, -90%) scale(0.8)';
                    setTimeout(() => {
                        if (elem.parentNode) elem.parentNode.removeChild(elem);
                    }, 300);
                }
            }, 1500);
        }

        /**
         * Simple Particle System for skill effects
         */
        class ParticleSystem {
            constructor() {
                this.particles = [];
                this.maxParticles = 100;
                this.particlePool = [];
                this.maxPoolSize = 200;
            }

            /**
             * Get a particle from the pool or create a new one
             */
            createPooledParticle(position, color, size, lifetime) {
                let particle = null;

                // Try to reuse from pool
                if (this.particlePool.length > 0) {
                    particle = this.particlePool.pop();
                    // Reset particle properties
                    particle.mesh.position.copy(position);
                    particle.mesh.material.color.setHex(color);
                    particle.mesh.material.opacity = 0.8;
                    particle.velocity.set(
                        (Math.random() - 0.5) * 5,
                        Math.random() * 5,
                        (Math.random() - 0.5) * 5
                    );
                    particle.lifetime = lifetime;
                    particle.maxLifetime = lifetime;
                } else {
                    // Create new particle
                    particle = {
                        mesh: new THREE.Mesh(
                            new THREE.SphereGeometry(size, 4, 4),
                            new THREE.MeshBasicMaterial({ color: color, transparent: true, opacity: 0.8 })
                        ),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 5,
                            Math.random() * 5,
                            (Math.random() - 0.5) * 5
                        ),
                        lifetime: lifetime,
                        maxLifetime: lifetime
                    };
                    particle.mesh.position.copy(position);
                }

                return particle;
            }

            /**
             * Return particle to pool for reuse
             */
            returnToPool(particle) {
                if (this.particlePool.length < this.maxPoolSize) {
                    // Remove from scene
                    scene.remove(particle.mesh);
                    // Reset properties
                    particle.mesh.visible = false;
                    particle.lifetime = 0;
                    // Add to pool
                    this.particlePool.push(particle);
                } else {
                    // Pool is full, dispose particle
                    scene.remove(particle.mesh);
                    particle.mesh.geometry.dispose();
                    particle.mesh.material.dispose();
                }
            }

            emit(position, count = 10, color = 0xffffff, size = 0.1, lifetime = 1.0) {
                for (let i = 0; i < count && this.particles.length < this.maxParticles; i++) {
                    const particle = this.createPooledParticle(position, color, size, lifetime);

                    // Make visible and add to scene
                    particle.mesh.visible = true;
                    scene.add(particle.mesh);
                    this.particles.push(particle);
                }
            }

            update(deltaTime) {
                for (let i = this.particles.length - 1; i >= 0; i--) {
                    const p = this.particles[i];
                    p.lifetime -= deltaTime;

                    if (p.lifetime <= 0) {
                        // Return to pool instead of disposing
                        this.returnToPool(p);
                        this.particles.splice(i, 1);
                        continue;
                    }

                    // Update position
                    p.mesh.position.add(p.velocity.clone().multiplyScalar(deltaTime));

                    // Fade out
                    const progress = 1.0 - (p.lifetime / p.maxLifetime);
                    p.mesh.material.opacity = 0.8 * (1 - progress);
                }
            }
        }

        /**
         * Sprite Renderer System - Handles character sprite animations
         */
        class SpriteRenderer {
            constructor() {
                this.characters = {};
                this.animations = {
                    'A1': {
                        idle: { frames: 8, duration: 2.0, loop: true },
                        walk: { frames: 8, duration: 1.0, loop: true },
                        attack: { frames: 6, duration: 0.5, loop: false }
                    },
                    'MISSY': {
                        idle: { frames: 8, duration: 2.0, loop: true },
                        walk: { frames: 8, duration: 1.0, loop: true },
                        attack: { frames: 6, duration: 0.5, loop: false }
                    },
                    'UNIQUE': {
                        idle: { frames: 8, duration: 2.0, loop: true },
                        walk: { frames: 8, duration: 1.0, loop: true },
                        attack: { frames: 6, duration: 0.5, loop: false }
                    }
                };
            }

            /**
             * Initialize sprite for character
             */
            initCharacter(characterId, mesh) {
                if (!this.characters[characterId]) {
                    this.characters[characterId] = {
                        mesh: mesh,
                        currentAnimation: 'idle',
                        currentFrame: 0,
                        animationTime: 0,
                        spriteCanvas: null,
                        spriteTexture: null,
                        spriteMaterial: null,
                        spriteMesh: null
                    };
                }
                return this.characters[characterId];
            }

            /**
             * Set animation state
             */
            setAnimation(characterId, animationName, frame = 0) {
                const char = this.characters[characterId];
                if (!char) return;

                if (char.currentAnimation !== animationName) {
                    char.currentAnimation = animationName;
                    char.currentFrame = frame;
                    char.animationTime = 0;
                }
            }

            /**
             * Update sprite animation
             */
            update(deltaTime) {
                for (const charId in this.characters) {
                    const char = this.characters[charId];
                    const anim = this.animations[charId]?.[char.currentAnimation];
                    if (!anim) continue;

                    char.animationTime += deltaTime;
                    const frameDuration = anim.duration / anim.frames;

                    if (char.animationTime >= frameDuration) {
                        char.currentFrame++;
                        char.animationTime = 0;

                        if (char.currentFrame >= anim.frames) {
                            if (anim.loop) {
                                char.currentFrame = 0;
                            } else {
                                // Auto-return to idle after attack
                                if (char.currentAnimation === 'attack') {
                                    this.setAnimation(charId, 'idle', 0);
                                } else {
                                    char.currentFrame = anim.frames - 1;
                                }
                            }
                        }
                    }
                }
            }

            /**
             * Get current animation frame
             */
            getCurrentFrame(characterId) {
                const char = this.characters[characterId];
                if (!char) return 0;
                return char.currentFrame;
            }

            /**
             * Check if animation is in active damage frame
             */
            isInDamageFrame(characterId) {
                const char = this.characters[characterId];
                if (!char || char.currentAnimation !== 'attack') return false;
                // Frames 3-5 are active damage frames (out of 6 total)
                return char.currentFrame >= 2 && char.currentFrame <= 4;
            }

            /**
             * Get animation progress (0-1)
             */
            getAnimationProgress(characterId) {
                const char = this.characters[characterId];
                if (!char) return 0;
                const anim = this.animations[charId]?.[char.currentAnimation];
                if (!anim) return 0;
                return (char.currentFrame + char.animationTime / (anim.duration / anim.frames)) / anim.frames;
            }
        }

        // Global sprite renderer instance
        const spriteRenderer = new SpriteRenderer();

        /**
         * Sword Swing System - Handles melee sword attacks with hit detection
         */
        class SwordSwingSystem {
            constructor() {
                this.activeSwings = [];
                this.comboState = {
                    currentCombo: 0,
                    maxCombo: 3,
                    comboWindow: 1.5,
                    lastSwingTime: 0,
                    swingCount: 0 // Track total swings for X projectile trigger
                };
            }

            /**
             * Execute a sword swing
             */
            executeSwing(player, characterId, comboIndex = 0) {
                const now = Date.now();
                const timeSinceLastSwing = now - this.comboState.lastSwingTime;

                // Reset combo if window expired
                if (timeSinceLastSwing > this.comboState.comboWindow * 1000) {
                    this.comboState.currentCombo = 0;
                }

                // Determine combo index
                let actualComboIndex = comboIndex;
                if (comboIndex === 0) {
                    actualComboIndex = this.comboState.currentCombo;
                    this.comboState.currentCombo = (this.comboState.currentCombo + 1) % this.comboState.maxCombo;
                }

                // Calculate swing arc based on player rotation
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(player.quaternion);
                const playerRotation = Math.atan2(forward.x, forward.z);

                // Swing angles: horizontal → diagonal → vertical
                const swingAngles = [
                    { start: -Math.PI / 3, end: Math.PI / 3 },      // Horizontal (120 degrees)
                    { start: -Math.PI / 4, end: Math.PI / 4 + Math.PI / 6 }, // Diagonal
                    { start: -Math.PI / 6, end: Math.PI / 2 }       // Vertical
                ];

                const angle = swingAngles[actualComboIndex] || swingAngles[0];
                const swingArc = {
                    center: player.position.clone(),
                    radius: 3.9, // Increased by 30% from 3.0 to 3.9
                    startAngle: playerRotation + angle.start,
                    endAngle: playerRotation + angle.end,
                    height: 1.5,
                    damage: this.getComboDamage(actualComboIndex),
                    comboIndex: actualComboIndex,
                    startTime: now,
                    duration: 0.5,
                    active: true
                };

                this.activeSwings.push(swingArc);
                this.comboState.lastSwingTime = now;
                this.comboState.swingCount++;

                // Set attack animation
                if (spriteRenderer) {
                    spriteRenderer.setAnimation(characterId, 'attack', 0);
                }

                // Create visual trail
                this.createSwordTrail(player, swingArc, actualComboIndex);

                // Check for X projectile trigger (after 3-4 swings, 20-30% chance)
                if (this.comboState.swingCount >= 3 && this.comboState.swingCount <= 4) {
                    const chance = Math.random();
                    const triggerChance = 0.20 + (this.comboState.swingCount - 3) * 0.10; // 20% at 3, 30% at 4

                    if (chance < triggerChance) {
                        // Fire X-shaped homing projectiles
                        this.fireXProjectiles(player, characterId);
                        this.comboState.swingCount = 0; // Reset counter
                    }
                } else if (this.comboState.swingCount > 4) {
                    this.comboState.swingCount = 0; // Reset if missed window
                }

                return swingArc;
            }

            /**
             * Fire X-shaped homing projectiles (anime-style)
             */
            fireXProjectiles(player, characterId) {
                console.log('⚔️ X-Shaped Projectiles!');

                // Find nearest enemies
                const enemies = gameState.npcs.filter(npc =>
                    npc.type === 'villain' && npc.health > 0
                ).sort((a, b) => {
                    const distA = player.position.distanceTo(a.mesh.position);
                    const distB = player.position.distanceTo(b.mesh.position);
                    return distA - distB;
                }).slice(0, 3); // Target up to 3 enemies

                if (enemies.length === 0) return;
                if (!gameState.player || !gameState.player.effectiveStats) return;

                const baseDamage = gameState.player.effectiveStats.attack * 1.5; // 150% damage
                const playerPos = player.position.clone();
                playerPos.y += 1.5;

                enemies.forEach((enemy, index) => {
                    setTimeout(() => {
                        const targetPos = enemy.mesh.position.clone();
                        targetPos.y += 1.0;

                        // Create X-shaped projectile with homing
                        this.createXProjectile(playerPos, targetPos, baseDamage, enemy);
                    }, index * 100); // Stagger projectiles
                });

                // Visual effect
                emitUltimateParticles(playerPos, 0xff0000, 30);
                applyScreenShake(0.15, 0.3);
                playSound('skill_cast', { element: 'PHYSICAL', tier: 'epic' });
            }

            /**
             * Create X-shaped homing projectile (anime-style)
             */
            createXProjectile(startPos, targetPos, damage, targetEnemy) {
                // Create X shape using two crossing lines
                const direction = new THREE.Vector3().subVectors(targetPos, startPos).normalize();
                const size = 0.6; // Increased by 50% from 0.4 to 0.6

                // Initialize X line positions (will be updated in render loop)
                const line1Start = startPos.clone();
                const line1End = startPos.clone();
                const line2Start = startPos.clone();
                const line2End = startPos.clone();

                // Create X projectile state
                const xProjectile = {
                    line1Start: line1Start,
                    line1End: line1End,
                    line2Start: line2Start,
                    line2End: line2End,
                    position: startPos.clone(),
                    target: targetEnemy,
                    targetPos: targetPos,
                    velocity: direction.clone().multiplyScalar(100),
                    damage: damage,
                    lifetime: 5.0,
                    homingStrength: 5.0, // How strongly it homes in
                    rotation: 0,
                    rotationSpeed: 10, // Rotate the X
                    team: 'player',
                    isXProjectile: true,
                    size: size
                };

                // Add to projectiles array
                gameState.projectiles.push(xProjectile);
            }

            /**
             * Get damage multiplier for combo
             */
            getComboDamage(comboIndex) {
                const multipliers = [1.0, 1.3, 1.6];
                return multipliers[comboIndex] || 1.0;
            }

            /**
             * Check enemies in swing arc
             */
            checkSwordHit(swingArc) {
                const hitEnemies = [];

                for (const npc of gameState.npcs) {
                    if (npc.type !== 'villain' || npc.health <= 0) continue;

                    const npcPos = npc.mesh.position;
                    const distance = swingArc.center.distanceTo(npcPos);

                    // Check if in radius
                    if (distance > swingArc.radius) continue;

                    // Check if in height range
                    const heightDiff = Math.abs(npcPos.y - swingArc.center.y);
                    if (heightDiff > swingArc.height) continue;

                    // Check if in angle range
                    const dx = npcPos.x - swingArc.center.x;
                    const dz = npcPos.z - swingArc.center.z;
                    const angle = Math.atan2(dx, dz);

                    // Normalize angles
                    let startAngle = swingArc.startAngle;
                    let endAngle = swingArc.endAngle;
                    if (endAngle < startAngle) endAngle += Math.PI * 2;
                    let npcAngle = angle;
                    if (npcAngle < startAngle) npcAngle += Math.PI * 2;

                    if (npcAngle >= startAngle && npcAngle <= endAngle) {
                        hitEnemies.push({ npc, distance, angle });
                    }
                }

                // --- NEW: Check Destructibles ---
                if (window.destructibleSystem) {
                    window.destructibleSystem.objects.forEach(obj => {
                        const objPos = obj.mesh.position;
                        const distance = swingArc.center.distanceTo(objPos);

                        // Check if in radius
                        if (distance > swingArc.radius) return;

                        // Check if in height range
                        const heightDiff = Math.abs(objPos.y - swingArc.center.y);
                        if (heightDiff > swingArc.height) return;

                        // Check if in angle range
                        const dx = objPos.x - swingArc.center.x;
                        const dz = objPos.z - swingArc.center.z;
                        const angle = Math.atan2(dx, dz);

                        // Normalize angles
                        let startAngle = swingArc.startAngle;
                        let endAngle = swingArc.endAngle;
                        if (endAngle < startAngle) endAngle += Math.PI * 2;
                        let objAngle = angle;
                        if (objAngle < startAngle) objAngle += Math.PI * 2;

                        if (objAngle >= startAngle && objAngle <= endAngle) {
                            // Only hit once per swing
                            if (!obj.hitBySwing || obj.hitBySwing !== swingArc) {
                                if (gameState.player && gameState.player.effectiveStats) {
                                    const baseDamage = gameState.player.effectiveStats.attack;
                                    const finalDamage = baseDamage * (swingArc.damage || 1.0);
                                    window.destructibleSystem.takeDamage(obj, finalDamage);
                                    obj.hitBySwing = swingArc;
                                }
                            }
                        }
                    });
                }

                return hitEnemies;
            }

            checkEnvironmentHit(swingArc) {
                const hitObjects = [];
                for (const obj of gameState.destructibleObjects) {
                    if (obj.isDestroyed || !obj.collider) continue;

                    // Check if any point along the arc is inside the object's bounding box
                    const arcPoints = 5;
                    for (let i = 0; i <= arcPoints; i++) {
                        const t = i / arcPoints;
                        const angle = swingArc.startAngle + (swingArc.endAngle - swingArc.startAngle) * t;
                        const pointOnArc = new THREE.Vector3(
                            swingArc.center.x + Math.sin(angle) * swingArc.radius,
                            swingArc.center.y + 1.0, // Approx height of swing
                            swingArc.center.z + Math.cos(angle) * swingArc.radius
                        );

                        if (obj.collider.containsPoint(pointOnArc)) {
                            hitObjects.push(obj);
                            break; // Object is hit, no need to check other points
                        }
                    }
                }
                return hitObjects;
            }


            /**
             * Create visual sword trail with enhanced effects
             */
            createSwordTrail(player, swingArc, comboIndex) {
                const colors = [0xff0000, 0xffffff, 0xff4400]; // Red, White, Orange
                const color = colors[comboIndex] || 0xff0000;

                // Create trail particles along the arc
                const trailStart = swingArc.center.clone();
                trailStart.y += 1.0;

                // Create multiple trail points along the arc
                const arcPoints = 20;
                for (let i = 0; i <= arcPoints; i++) {
                    const t = i / arcPoints;
                    const angle = swingArc.startAngle + (swingArc.endAngle - swingArc.startAngle) * t;
                    const pos = new THREE.Vector3(
                        trailStart.x + Math.sin(angle) * swingArc.radius * t,
                        trailStart.y,
                        trailStart.z + Math.cos(angle) * swingArc.radius * t
                    );

                    // Emit particles with varying intensity
                    const intensity = comboIndex === 2 ? 3 : 2;
                    emitSkillParticles(pos, color, intensity);
                }

                // Create energy arc visual (Three.js line)
                const points = [];
                for (let i = 0; i <= 10; i++) {
                    const t = i / 10;
                    const angle = swingArc.startAngle + (swingArc.endAngle - swingArc.startAngle) * t;
                    points.push(new THREE.Vector3(
                        trailStart.x + Math.sin(angle) * swingArc.radius * 0.8,
                        trailStart.y,
                        trailStart.z + Math.cos(angle) * swingArc.radius * 0.8
                    ));
                }

                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({
                    color: color,
                    transparent: true,
                    opacity: 0.6,
                    linewidth: 3
                });
                const line = new THREE.Line(geometry, material);
                scene.add(line);

                // Fade out and remove
                setTimeout(() => {
                    const fadeOut = setInterval(() => {
                        material.opacity -= 0.1;
                        if (material.opacity <= 0) {
                            clearInterval(fadeOut);
                            scene.remove(line);
                            geometry.dispose();
                            material.dispose();
                        }
                    }, 50);
                }, 100);

                // Screen shake on swing (intensity based on combo)
                const shakeIntensity = 0.1 + (comboIndex * 0.05);
                applyScreenShake(shakeIntensity, 0.2 + (comboIndex * 0.1));
            }

            /**
             * Update active swings
             */
            update(deltaTime) {
                const now = Date.now();

                for (let i = this.activeSwings.length - 1; i >= 0; i--) {
                    const swing = this.activeSwings[i];
                    const age = (now - swing.startTime) / 1000;

                    // Check hits during active frames (0.1s to 0.4s)
                    if (age >= 0.1 && age <= 0.4 && swing.active) {
                        const hitEnemies = this.checkSwordHit(swing);

                        for (const hit of hitEnemies) {
                            // Apply damage once per swing
                            if (!hit.npc.hitBySwing || hit.npc.hitBySwing !== swing) {
                                if (!gameState.player || !gameState.player.effectiveStats) continue;
                                const baseDamage = gameState.player.effectiveStats.attack;
                                const finalDamage = baseDamage * swing.damage;

                                hit.npc.health -= finalDamage;
                                hit.npc.hitBySwing = swing;

                                createDamageIndicator(hit.npc.mesh.position, finalDamage);
                                playSound('hit');

                                // Knockback
                                const knockbackDir = new THREE.Vector3()
                                    .subVectors(hit.npc.mesh.position, swing.center)
                                    .normalize();
                                hit.npc.mesh.position.add(knockbackDir.multiplyScalar(0.5));

                                if (hit.npc.health <= 0) {
                                    hit.npc.health = 0;
                                    hit.npc.state = 'dying';
                                    hit.npc.dyingTimer = 0.5;
                                    PlayerState.gainXP(25);
                                }
                            }
                        }
                    }

                    // Check for environment hits
                    const hitObjects = this.checkEnvironmentHit(swing);
                    for (const obj of hitObjects) {
                        if (!obj.hitBySwing || obj.hitBySwing !== swing) {
                            if (!gameState.player || !gameState.player.effectiveStats) continue;
                            const baseDamage = gameState.player.effectiveStats.attack;
                            const finalDamage = baseDamage * swing.damage;

                            obj.health -= finalDamage;
                            obj.hitBySwing = swing;

                            createDamageIndicator(obj.mesh.position, finalDamage, { color: '#aaaaaa' });

                            if (obj.health <= 0) {
                                obj.health = 0;
                            }
                        }
                    }


                    // Clear hitBySwing flags and remove swing when it ends
                    if (age >= swing.duration) {
                        // Clear hitBySwing flags for this swing
                        for (const npc of gameState.npcs) {
                            if (npc.hitBySwing === swing) {
                                npc.hitBySwing = null;
                            }
                        }
                        // Clear hitBySwing flags for destructibles
                        if (window.destructibleSystem) {
                            window.destructibleSystem.objects.forEach(obj => {
                                if (obj.hitBySwing === swing) {
                                    obj.hitBySwing = null;
                                }
                            });
                        }
                        this.activeSwings.splice(i, 1);
                        continue;
                    }
                }
            }

            /**
             * Get active swing hitbox for bullet deflection
             */
            getActiveSwingHitbox(player, characterId) {
                if (!spriteRenderer.isInDamageFrame(characterId)) {
                    return null;
                }

                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(player.quaternion);
                const swordTip = player.position.clone().add(forward.multiplyScalar(1.5));
                swordTip.y += 1.0;

                return {
                    position: swordTip,
                    radius: 0.8,
                    active: true
                };
            }
        }

        // Global sword swing system instance
        const swordSwingSystem = new SwordSwingSystem();

        /**
         * Bullet Deflection System - Handles parrying and deflecting projectiles
         */
        class BulletDeflectionSystem {
            constructor() {
                this.parryWindow = 0.1; // 0.1s perfect parry window
                this.deflectionHistory = [];
            }

            /**
             * Check if bullet can be deflected
             */
            checkBulletDeflection(projectile, player, characterId) {
                if (!projectile || projectile.team === 'player' || projectile.team === 'hero') {
                    return null; // Don't deflect friendly projectiles
                }

                // Get active sword hitbox
                const swordHitbox = swordSwingSystem.getActiveSwingHitbox(player, characterId);
                if (!swordHitbox || !swordHitbox.active) {
                    return null;
                }

                // Check if bullet is within sword hitbox
                const bulletPos = projectile.mesh ? projectile.mesh.position : projectile.position;
                const distance = bulletPos.distanceTo(swordHitbox.position);

                if (distance <= swordHitbox.radius) {
                    // Check if in perfect parry window (first 0.1s of damage frame)
                    const frame = spriteRenderer.getCurrentFrame(characterId);
                    const isPerfectParry = frame === 2; // First damage frame

                    return {
                        canDeflect: true,
                        isPerfect: isPerfectParry,
                        hitbox: swordHitbox
                    };
                }

                return null;
            }

            /**
             * Deflect bullet back at shooter
             */
            deflectBullet(projectile, deflectionInfo, player) {
                if (!deflectionInfo || !deflectionInfo.canDeflect) return;

                // Find the shooter (enemy that fired this)
                let shooter = null;
                for (const npc of gameState.npcs) {
                    if (npc.type === 'villain' && npc.mesh) {
                        // Simple check: if bullet is close to NPC, assume it's the shooter
                        const bulletPos = projectile.mesh ? projectile.mesh.position : projectile.position;
                        if (bulletPos.distanceTo(npc.mesh.position) < 50) {
                            shooter = npc;
                            break;
                        }
                    }
                }

                if (!shooter) return;

                // Calculate deflection direction (towards shooter)
                const bulletPos = projectile.mesh ? projectile.mesh.position : projectile.position;
                const direction = new THREE.Vector3()
                    .subVectors(shooter.mesh.position, bulletPos)
                    .normalize();

                // Reverse bullet direction and make it 2x bigger with 2x damage
                if (projectile.mesh) {
                    // Update velocity
                    const speed = projectile.velocity ? projectile.velocity.length() : 80;
                    projectile.velocity = direction.multiplyScalar(speed);

                    // Make projectile 2x bigger
                    if (projectile.mesh.scale) {
                        projectile.mesh.scale.multiplyScalar(2.0);
                    } else {
                        projectile.mesh.scale = new THREE.Vector3(2.0, 2.0, 2.0);
                    }

                    // 2x damage
                    projectile.damage *= 2.0;

                    // Change color to indicate deflection
                    if (projectile.mesh.material) {
                        projectile.mesh.material.color.setHex(deflectionInfo.isPerfect ? 0x00ff00 : 0xffff00);
                    }
                } else if (projectile.projectileSystemRef) {
                    // Update ProjectileSystem projectile
                    const speed = projectile.projectileSystemRef.speed || 80;
                    projectile.projectileSystemRef.velocity = direction.multiplyScalar(speed);
                    projectile.projectileSystemRef.team = 'player'; // Change team to player

                    // Make projectile 2x bigger
                    if (projectile.projectileSystemRef.mesh) {
                        if (projectile.projectileSystemRef.mesh.scale) {
                            projectile.projectileSystemRef.mesh.scale.multiplyScalar(2.0);
                        } else {
                            projectile.projectileSystemRef.mesh.scale = new THREE.Vector3(2.0, 2.0, 2.0);
                        }
                    }

                    // Always 2x damage when deflected
                    projectile.projectileSystemRef.damage *= 2.0;
                    projectile.damage *= 2.0;
                }

                // Create parry effect
                this.createParryEffect(bulletPos, deflectionInfo.isPerfect);

                // Play sound
                playSound(deflectionInfo.isPerfect ? 'crit' : 'hit', {
                    element: 'PHYSICAL',
                    tier: deflectionInfo.isPerfect ? 'epic' : 'common'
                });

                return true;
            }

            /**
             * Create visual parry effect
             */
            createParryEffect(position, isPerfect) {
                // Spark particles
                const color = isPerfect ? 0x00ff00 : 0xffff00;
                emitSkillParticles(position, color, isPerfect ? 20 : 10);

                // Screen flash on perfect parry
                if (isPerfect) {
                    applyScreenShake(0.2, 0.4);

                    // Create flash effect
                    const container = document.getElementById('damage-container');
                    if (container) {
                        const flash = document.createElement('div');
                        flash.style.cssText = `
                            position: fixed;
                            top: 0;
                            left: 0;
                            width: 100%;
                            height: 100%;
                            background: rgba(0, 255, 0, 0.3);
                            z-index: 9999;
                            pointer-events: none;
                            animation: flashFade 0.2s ease-out;
                        `;
                        container.appendChild(flash);
                        setTimeout(() => flash.remove(), 200);
                    }
                } else {
                    applyScreenShake(0.1, 0.2);
                }
            }
        }

        // Global bullet deflection system instance
        const bulletDeflectionSystem = new BulletDeflectionSystem();

        /**
         * Enhanced Projectile System with trails, glow, and advanced visuals
         */
        class ProjectileSystem {
            constructor() {
                this.projectiles = [];
                this.trailPool = [];
                this.maxTrails = 200;
            }

            /**
             * Create a projectile with advanced visuals
             */
            createProjectile(options = {}) {
                const {
                    position,
                    direction,
                    speed = 80.0,
                    damage = 10,
                    team = 'player',
                    color = 0xffff00,
                    size = 0.3,
                    tier = 'common',
                    shape = 'sphere',
                    element = 'PHYSICAL',
                    lifetime = 3.0,
                    trailEnabled = true,
                    glowEnabled = true,
                    rotationSpeed = 0
                } = options;

                // Determine size based on tier
                const tierSizes = {
                    'common': 0.3,
                    'uncommon': 0.35,
                    'rare': 0.4,
                    'epic': 0.5,
                    'legendary': 0.6
                };
                const finalSize = size || tierSizes[tier] || 0.3;

                // Create projectile geometry based on shape
                let geometry;
                switch (shape) {
                    case 'cube':
                        geometry = new THREE.BoxGeometry(finalSize, finalSize, finalSize);
                        break;
                    case 'star':
                        // Create star shape using octahedron
                        geometry = new THREE.OctahedronGeometry(finalSize * 0.8);
                        break;
                    case 'crescent':
                        // Use torus for crescent-like shape
                        geometry = new THREE.TorusGeometry(finalSize * 0.6, finalSize * 0.2, 8, 16);
                        break;
                    case 'wave':
                        // Use plane for wave effect
                        geometry = new THREE.PlaneGeometry(finalSize * 2, finalSize * 0.5);
                        break;
                    default: // sphere
                        geometry = new THREE.SphereGeometry(finalSize, 12, 12);
                }

                // Create material with glow effect
                const material = new THREE.MeshStandardMaterial({
                    color: color,
                    emissive: color,
                    emissiveIntensity: glowEnabled ? 0.5 : 0,
                    transparent: true,
                    opacity: 1.0
                });

                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(position);
                mesh.castShadow = true;

                // Add glow halo for higher tiers
                if (glowEnabled && (tier === 'epic' || tier === 'legendary')) {
                    const glowGeometry = new THREE.SphereGeometry(finalSize * 1.5, 16, 16);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: color,
                        transparent: true,
                        opacity: 0.3,
                        side: THREE.BackSide
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    mesh.add(glow);
                }

                // Create trail if enabled
                let trail = null;
                if (trailEnabled) {
                    trail = this.createTrail(mesh, color, tier);
                }

                const velocity = direction.clone().multiplyScalar(speed);

                const projectile = {
                    mesh: mesh,
                    velocity: velocity,
                    lifetime: lifetime,
                    maxLifetime: lifetime,
                    team: team,
                    damage: damage,
                    tier: tier,
                    element: element,
                    trail: trail,
                    rotationSpeed: rotationSpeed || (element === 'ENERGY' ? 5 : element === 'PLASMA' ? 8 : 3),
                    age: 0,
                    hasHit: false
                };

                scene.add(mesh);
                this.projectiles.push(projectile);
                return projectile;
            }

            /**
             * Create trail effect for projectile
             */
            createTrail(projectileMesh, color, tier) {
                const trailLength = tier === 'legendary' ? 20 : tier === 'epic' ? 15 : tier === 'rare' ? 10 : 8;
                const trailGeometry = new THREE.BufferGeometry();
                const positions = new Float32Array(trailLength * 3);
                const colors = new Float32Array(trailLength * 3);

                // Initialize trail positions
                for (let i = 0; i < trailLength; i++) {
                    positions[i * 3] = projectileMesh.position.x;
                    positions[i * 3 + 1] = projectileMesh.position.y;
                    positions[i * 3 + 2] = projectileMesh.position.z;

                    const intensity = 1.0 - (i / trailLength);
                    const r = ((color >> 16) & 0xff) / 255;
                    const g = ((color >> 8) & 0xff) / 255;
                    const b = (color & 0xff) / 255;
                    colors[i * 3] = r * intensity;
                    colors[i * 3 + 1] = g * intensity;
                    colors[i * 3 + 2] = b * intensity;
                }

                trailGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                trailGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

                const trailMaterial = new THREE.LineBasicMaterial({
                    vertexColors: true,
                    transparent: true,
                    opacity: 0.8,
                    linewidth: tier === 'legendary' ? 3 : tier === 'epic' ? 2.5 : 2
                });

                const trail = new THREE.Line(trailGeometry, trailMaterial);
                trail.frustumCulled = false;
                scene.add(trail);

                return {
                    line: trail,
                    positions: positions,
                    colors: colors,
                    length: trailLength,
                    index: 0
                };
            }

            /**
             * Update all projectiles
             */
            update(deltaTime) {
                for (let i = this.projectiles.length - 1; i >= 0; i--) {
                    const proj = this.projectiles[i];
                    proj.age += deltaTime;
                    proj.lifetime -= deltaTime;

                    // Update position
                    proj.mesh.position.add(proj.velocity.clone().multiplyScalar(deltaTime));

                    // Update rotation
                    if (proj.rotationSpeed > 0) {
                        proj.mesh.rotation.x += proj.rotationSpeed * deltaTime;
                        proj.mesh.rotation.y += proj.rotationSpeed * deltaTime * 0.7;
                    }

                    // Update trail
                    if (proj.trail) {
                        this.updateTrail(proj);
                    }

                    // Fade out as lifetime expires
                    const lifeProgress = proj.lifetime / proj.maxLifetime;
                    if (lifeProgress < 0.3) {
                        proj.mesh.material.opacity = lifeProgress / 0.3;
                        if (proj.mesh.children.length > 0) {
                            proj.mesh.children[0].material.opacity = (lifeProgress / 0.3) * 0.3;
                        }
                    }

                    // Remove expired projectiles
                    if (proj.lifetime <= 0 || proj.hasHit) {
                        this.removeProjectile(i);
                    }
                }
            }

            /**
             * Update trail positions
             */
            updateTrail(projectile) {
                if (!projectile.trail) return;

                const trail = projectile.trail;
                const projPos = projectile.mesh.position;

                // Shift trail positions
                for (let i = trail.length - 1; i > 0; i--) {
                    trail.positions[i * 3] = trail.positions[(i - 1) * 3];
                    trail.positions[i * 3 + 1] = trail.positions[(i - 1) * 3 + 1];
                    trail.positions[i * 3 + 2] = trail.positions[(i - 1) * 3 + 2];
                }

                // Add current position
                trail.positions[0] = projPos.x;
                trail.positions[1] = projPos.y;
                trail.positions[2] = projPos.z;

                // Update colors (fade from front to back)
                for (let i = 0; i < trail.length; i++) {
                    const intensity = 1.0 - (i / trail.length);
                    const color = parseInt(projectile.mesh.material.color.getHex(), 16);
                    const r = ((color >> 16) & 0xff) / 255;
                    const g = ((color >> 8) & 0xff) / 255;
                    const b = (color & 0xff) / 255;
                    trail.colors[i * 3] = r * intensity;
                    trail.colors[i * 3 + 1] = g * intensity;
                    trail.colors[i * 3 + 2] = b * intensity;
                }

                trail.line.geometry.attributes.position.needsUpdate = true;
                trail.line.geometry.attributes.color.needsUpdate = true;
            }

            /**
             * Create impact effect
             */
            createImpactEffect(position, color, tier) {
                const particleCount = tier === 'legendary' ? 30 : tier === 'epic' ? 20 : 15;
                const impactColor = color;

                for (let i = 0; i < particleCount; i++) {
                    const angle = (Math.PI * 2 * i) / particleCount;
                    const speed = 5 + Math.random() * 5;
                    const particle = {
                        mesh: new THREE.Mesh(
                            new THREE.SphereGeometry(0.1, 4, 4),
                            new THREE.MeshBasicMaterial({ color: impactColor, transparent: true, opacity: 0.9 })
                        ),
                        velocity: new THREE.Vector3(
                            Math.cos(angle) * speed,
                            Math.random() * 3,
                            Math.sin(angle) * speed
                        ),
                        lifetime: 0.5 + Math.random() * 0.5,
                        maxLifetime: 0.5 + Math.random() * 0.5
                    };
                    particle.mesh.position.copy(position);
                    scene.add(particle.mesh);
                    particleSystem.particles.push(particle);
                }
            }

            /**
             * Remove projectile and cleanup
             */
            removeProjectile(index) {
                const proj = this.projectiles[index];

                // Remove trail
                if (proj.trail && proj.trail.line) {
                    scene.remove(proj.trail.line);
                    proj.trail.line.geometry.dispose();
                    proj.trail.line.material.dispose();
                }

                // Remove mesh
                scene.remove(proj.mesh);
                proj.mesh.geometry.dispose();
                proj.mesh.material.dispose();
                if (proj.mesh.children.length > 0) {
                    proj.mesh.children.forEach(child => {
                        child.geometry.dispose();
                        child.material.dispose();
                    });
                }

                this.projectiles.splice(index, 1);
            }

            /**
             * Get projectile at position (for collision detection)
             */
            getProjectileAt(position, radius = 1.5) {
                for (let i = 0; i < this.projectiles.length; i++) {
                    const proj = this.projectiles[i];
                    if (proj.mesh.position.distanceTo(position) < radius && !proj.hasHit) {
                        return { projectile: proj, index: i };
                    }
                }
                return null;
            }
        }

        // Global particle system instance
        const particleSystem = new ParticleSystem();

        // Global projectile system instance
        const projectileSystem = new ProjectileSystem();

        // Update destructible system with particle system reference
        if (window.destructibleSystem) {
            window.destructibleSystem.particleSystem = particleSystem;
        }

        /**
         * Emit particles for skill activation
         */
        function emitSkillParticles(position, color = 0xffffff, count = 20) {
            particleSystem.emit(position, count, color, 0.15, 0.8);
        }

        /**
         * Emit particles for ultimate skills
         */
        function emitUltimateParticles(position, color = 0xffd700, count = 50) {
            particleSystem.emit(position, count, color, 0.2, 1.5);
        }

        // ═══════════════════════════════════════════════════════════════════════════
        // ADVANCED MOVEMENT SYSTEM (MP Flight + Double Jump)
        // ═══════════════════════════════════════════════════════════════════════════
        const MovementSystem = {
            lastJumpTime: 0,
            DOUBLE_JUMP_WINDOW: 400, // ms
            FLIGHT_SPEED: 40.0,
            FLIGHT_COST: 15.0, // MP per second

            handleJumpInput() {
                const now = Date.now();
                const player = gameState.activeCharacter;
                
                if (!player) return;

                if (player.isFlying) {
                    this.stopFlying();
                    return;
                }

                if (now - this.lastJumpTime < this.DOUBLE_JUMP_WINDOW) {
                    // Only fly if we have enough mana
                    if (player.currentMana > 10) {
                        this.startFlying();
                    } else {
                        if (window.BagSystem && typeof window.BagSystem.showToast === 'function') {
                            window.BagSystem.showToast("Not enough Mana to fly!");
                        }
                    }
                } else {
                    // Normal Jump
                    if (player.onGround) {
                        player.isJumping = true;
                        player.onGround = false;
                        player.jumpVelocity = 15;
                    }
                }

                this.lastJumpTime = now;
            },

            startFlying() {
                const player = gameState.activeCharacter;
                if (!player) return;

                player.isFlying = true;
                player.isJumping = false;
                player.jumpVelocity = 0;
                player.onGround = false;

                if (window.BagSystem && typeof window.BagSystem.showToast === 'function') {
                    window.BagSystem.showToast("🚀 Flight Engaged!");
                }

                if (typeof emitUltimateParticles === 'function') {
                    emitUltimateParticles(player.mesh.position, 0x00ffff, 20);
                }
            },

            stopFlying() {
                const player = gameState.activeCharacter;
                if (!player) return;

                player.isFlying = false;

                if (window.BagSystem && typeof window.BagSystem.showToast === 'function') {
                    window.BagSystem.showToast("Flight Disengaged");
                }
            },

            updateFlight(deltaTime) {
                const player = gameState.activeCharacter;
                if (!player || !player.isFlying) return;

                const mesh = player.mesh;
                if (!mesh) return;

                // 1. Drain Mana
                player.currentMana -= this.FLIGHT_COST * deltaTime;

                // Update UI Bar
                const mpFill = document.querySelector('.mp-fill');
                if (mpFill) {
                    const mpPercent = Math.max(0, Math.min(100, (player.currentMana / player.maxMana) * 100));
                    mpFill.style.width = `${mpPercent}%`;
                }

                // 2. Check for Empty Tank
                if (player.currentMana <= 0) {
                    player.currentMana = 0;
                    this.stopFlying();
                    return; // Stop processing flight movement
                }

                // 3. Flight Movement
                let moveVector = new THREE.Vector3(0, 0, 0);
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(mesh.quaternion);
                const joyY = window.joystickState ? window.joystickState.y : 0;

                if (keys['w'] || joyY < -0.1) moveVector.add(forward);
                if (keys['s'] || joyY > 0.1) moveVector.sub(forward);

                if (moveVector.lengthSq() > 0) {
                    moveVector.normalize().multiplyScalar(this.FLIGHT_SPEED * deltaTime);
                    mesh.position.add(moveVector);
                }

                // Hover Effect
                mesh.position.y += Math.sin(Date.now() * 0.003) * 0.02;
                if (mesh.position.y < 2) mesh.position.y = 2;
            }
        };

        // ═══════════════════════════════════════════════════════════════════════════
        // TEAM ACTION SYSTEM (Hold Act2 - Spin Attack & Charged Throw)
        // ═══════════════════════════════════════════════════════════════════════════
        const TeamActionSystem = {
            holdingRef: null,
            throwVelocity: new THREE.Vector3(),
            isHoldingButton: false,
            chargeTime: 0,
            spinSpeed: 0,

            // Called on Mousedown/Touchstart
            startAct2() {
                this.isHoldingButton = true;
                this.chargeTime = 0;
                if (!this.holdingRef) {
                    // Try pickup immediately
                    this.tryPickupTeammate();
                }
            },

            // Called on Mouseup/Touchend
            endAct2() {
                this.isHoldingButton = false;

                if (this.holdingRef) {
                    // If we held it for > 0.5s, it's a super throw
                    const power = Math.min(this.chargeTime, 2.0); // Cap charge at 2s
                    this.throwTeammate(1.0 + power); // Multiplier: 1.0 to 3.0x
                }

                // Reset spin
                this.spinSpeed = 0;
                this.chargeTime = 0;
            },

            tryPickupTeammate() {
                const player = gameState.activeCharacter;
                if (!player || !player.mesh) return;

                const playerPos = player.mesh.position;
                let nearest = null;
                let minDst = 5.0;

                gameState.partyMembers.forEach(member => {
                    if (!member || !member.mesh) return;
                    const dst = playerPos.distanceTo(member.mesh.position);
                    if (dst < minDst) {
                        minDst = dst;
                        nearest = member;
                    }
                });

                if (nearest) {
                    this.holdingRef = nearest;
                    nearest.state = "held";
                    player.mesh.add(nearest.mesh);
                    nearest.mesh.position.set(0, 2.5, 1.0); // Hold slightly forward
                    nearest.mesh.rotation.set(0, 0, Math.PI / 2); // Horizontal carry

                    if (window.BagSystem && typeof window.BagSystem.showToast === 'function') {
                        window.BagSystem.showToast(`Got ${nearest.details.name}! Hold to Spin!`);
                    }

                    // Sound effect on pickup
                    if (typeof playSound === 'function') {
                        playSound('skill_cast', { pitch: 1.2, volume: 0.15 });
                    }

                    // Particle effect on pickup
                    if (typeof emitSkillParticles === 'function') {
                        emitSkillParticles(player.mesh.position, 0x00ffff, 15);
                    }
                }
            },

            // Logic for "Human Beyblade"
            updateHoldLogic(deltaTime) {
                if (!this.holdingRef) return;
                if (!this.isHoldingButton) return;

                const player = gameState.activeCharacter;
                if (!player || !player.mesh) return;

                this.chargeTime += deltaTime;

                // Spin Player Mesh - faster as you charge up
                const currentSpin = 10.0 + (this.chargeTime * 10.0);
                player.mesh.rotation.y -= currentSpin * deltaTime;

                // Charging visual feedback - particles increase with charge
                if (this.chargeTime > 0.3 && typeof emitSkillParticles === 'function') {
                    const particleIntensity = Math.min(30, 10 + (this.chargeTime * 10));
                    emitSkillParticles(player.mesh.position, 0xffaa00, Math.floor(particleIntensity));
                }

                // Check for collisions with held teammate (The Club)
                this.checkSpinHit();
            },

            checkSpinHit() {
                if (!this.holdingRef || !this.holdingRef.mesh) return;

                const member = this.holdingRef;
                // Get world position of the held member
                const wPos = new THREE.Vector3();
                member.mesh.getWorldPosition(wPos);

                gameState.npcs.forEach(npc => {
                    if (!npc || !npc.mesh || npc.type !== 'villain' || npc.health <= 0) return;

                    if (wPos.distanceTo(npc.mesh.position) < 3.0) {
                        // SPIN HIT!
                        // Add cooldown so we don't hit every frame
                        if (!npc.lastSpinHit || Date.now() - npc.lastSpinHit > 500) {
                            npc.health -= 30;
                            npc.lastSpinHit = Date.now();

                            // Damage indicator
                            if (typeof createDamageIndicator === 'function') {
                                createDamageIndicator(npc.mesh.position, 30, { color: '#FFA500' });
                            }

                            // Sound effect
                            if (typeof playSound === 'function') {
                                playSound('hit', { pitch: 1.1, volume: 0.12 });
                            }

                            // Knockback away from player
                            const player = gameState.activeCharacter;
                            if (player && player.mesh) {
                                const push = new THREE.Vector3().subVectors(npc.mesh.position, player.mesh.position).normalize().multiplyScalar(5);
                                npc.mesh.position.add(push);
                            }

                            // Particle effect
                            if (typeof emitSkillParticles === 'function') {
                                emitSkillParticles(npc.mesh.position, 0xffaa00, 5);
                            }
                        }
                    }
                });
            },

            throwTeammate(powerMult = 1.0) {
                if (!this.holdingRef) return;

                const member = this.holdingRef;
                const player = gameState.activeCharacter;
                if (!player || !player.mesh) return;

                scene.add(member.mesh);

                const worldPos = new THREE.Vector3();
                player.mesh.getWorldPosition(worldPos);
                member.mesh.position.copy(worldPos).add(new THREE.Vector3(0, 3, 0));
                member.mesh.rotation.set(0, 0, 0);

                // Velocity calculation based on charge
                const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(player.mesh.quaternion);
                const speed = 40 * powerMult;

                this.throwVelocity.copy(forward).multiplyScalar(speed).add(new THREE.Vector3(0, 10, 0));

                member.state = "thrown";
                member.velocity = this.throwVelocity.clone();
                member.powerMult = powerMult; // Pass multiplier to collision logic

                this.holdingRef = null;

                const msg = powerMult > 2.0 ? "SUPER YEET!" : "Yeet!";
                if (window.BagSystem && typeof window.BagSystem.showToast === 'function') {
                    window.BagSystem.showToast(msg);
                }

                // Screen shake for super throw
                if (powerMult > 2.0 && typeof applyScreenShake === 'function') {
                    applyScreenShake(0.3, 0.3);
                }

                // Sound effect
                if (typeof playSound === 'function') {
                    if (powerMult > 2.0) {
                        playSound('skill_ultimate', { pitch: 1.0, volume: 0.2 });
                    } else {
                        playSound('skill_cast', { pitch: 1.3, volume: 0.15 });
                    }
                }

                // Particle effect
                if (typeof emitSkillParticles === 'function') {
                    const particleCount = powerMult > 2.0 ? 30 : 15;
                    const color = powerMult > 2.0 ? 0xff00ff : 0x00ffff;
                    emitSkillParticles(worldPos, color, particleCount);
                }
            },

            updatePhysics(deltaTime) {
                // Handle Hold Logic
                this.updateHoldLogic(deltaTime);

                // Handle Thrown Logic
                gameState.partyMembers.forEach(member => {
                    if (!member || !member.mesh) return;

                    if (member.state === "thrown") {
                        if (!member.velocity) {
                            member.state = "following";
                            return;
                        }

                        member.mesh.position.add(member.velocity.clone().multiplyScalar(deltaTime));
                        member.velocity.y -= 50 * deltaTime;

                        // Spin while flying through air
                        member.mesh.rotation.x += 10 * deltaTime;

                        // Ground Collision
                        if (member.mesh.position.y <= 1.5) {
                            member.mesh.position.y = 1.5;
                            member.state = "following";
                            member.velocity.set(0, 0, 0);
                            member.mesh.rotation.set(0, 0, 0);

                            // Landing impact
                            if (typeof emitSkillParticles === 'function') {
                                emitSkillParticles(member.mesh.position, 0xffffff, 10);
                            }
                        }

                        // Enemy Collision
                        gameState.npcs.forEach(npc => {
                            if (!npc || !npc.mesh || npc.type !== 'villain' || npc.health <= 0) return;

                            if (member.mesh.position.distanceTo(npc.mesh.position) < 3) {
                                // Damage based on Power Multiplier
                                const dmg = 50 * (member.powerMult || 1.0);

                                npc.health -= dmg;

                                // Damage indicator with crit styling for super throw
                                if (typeof createDamageIndicator === 'function') {
                                    const isSuper = (member.powerMult || 1.0) >= 2.0;
                                    createDamageIndicator(npc.mesh.position, dmg, {
                                        isCrit: isSuper,
                                        color: isSuper ? '#ff00ff' : '#ffffff'
                                    });
                                }

                                // Only stop if not SUPER charged (Super charge pierces enemies)
                                if ((member.powerMult || 1.0) < 2.0) {
                                    member.state = "following";
                                    member.velocity.set(0, 0, 0);
                                    member.mesh.rotation.set(0, 0, 0);
                                }

                                // Knockback
                                const push = member.velocity.clone().normalize().multiplyScalar(10);
                                npc.mesh.position.add(push);

                                // Particle effect
                                if (typeof emitSkillParticles === 'function') {
                                    const color = (member.powerMult || 1.0) >= 2.0 ? 0xff00ff : 0xffffff;
                                    emitSkillParticles(npc.mesh.position, color, 15);
                                }

                                if (npc.health <= 0) {
                                    npc.state = 'dying';
                                    npc.dyingTimer = 0.5;
                                }
                            }
                        });
                    }
                });
            }
        };

        /**
         * Get available synergies based on game state
         */
        function getAvailableSynergies(characterId) {
            const synergies = [];
            const skillLib = window.skillLibrary || skillLibrary;
            if (!skillLib) return synergies;

            // Check cooldowns to determine available synergies
            const cooldowns = gameState.skillCooldowns[characterId] || {};

            // A1 Synergies
            if (characterId === 'A1') {
                // S2 → S1 (Explosive Wave) - if S2 was used recently
                if (cooldowns.S2 && cooldowns.S2 < 5) {
                    synergies.push({
                        from: 'S2',
                        to: 'S1',
                        name: 'Explosive Wave',
                        description: 'S1 becomes enhanced after S2'
                    });
                }
                // S3 → S2 reset
                if (cooldowns.S3 === 0) {
                    synergies.push({
                        from: 'S3',
                        to: 'S2',
                        name: 'Power Reset',
                        description: 'S3 resets S2 cooldown'
                    });
                }
                // S5 → S1/S2 reset (on kill)
                if (cooldowns.S5 === 0) {
                    synergies.push({
                        from: 'S5',
                        to: 'S1',
                        name: 'Crimson Reset',
                        description: 'S5 resets S1 & S2 on kill'
                    });
                }
            }

            // Missy Synergies
            if (characterId === 'MISSY') {
                // S5 → S1/S2 reset
                if (cooldowns.S5 === 0) {
                    synergies.push({
                        from: 'S5',
                        to: 'S1',
                        name: 'Royal Reset',
                        description: 'S5 resets S1 & S2 cooldowns'
                    });
                }
            }

            return synergies;
        }

        /**
         * Show combo indicator UI
         */
        function showComboIndicator(comboCount, isSkillActivation = false) {
            const container = document.getElementById('damage-container');
            if (!container) return;

            // Remove existing combo indicator
            const existing = document.getElementById('combo-indicator');
            if (existing) existing.remove();

            if (comboCount === 0) return;

            const elem = document.createElement('div');
            elem.id = 'combo-indicator';
            elem.style.cssText = `
                position: fixed;
                top: 20%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-size: ${isSkillActivation ? '48px' : '32px'};
                font-weight: bold;
                text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
                z-index: 1000;
                pointer-events: none;
                transition: all 0.3s ease;
            `;

            // Color code based on combo level
            if (comboCount >= 5) {
                elem.style.color = '#FFD700'; // Gold
            } else if (comboCount >= 3) {
                elem.style.color = '#FFA500'; // Orange/Yellow
            } else {
                elem.style.color = '#FFFFFF'; // White
            }

            elem.textContent = isSkillActivation ? `COMBO x${comboCount}!` : `Combo: ${comboCount}`;
            container.appendChild(elem);

            // Animate
            setTimeout(() => {
                elem.style.transform = 'translate(-50%, -50%) scale(1.2)';
                elem.style.opacity = '0.9';
            }, 10);

            // Remove after animation
            setTimeout(() => {
                if (elem.parentNode) {
                    elem.style.opacity = '0';
                    elem.style.transform = 'translate(-50%, -50%) scale(0.8)';
                    setTimeout(() => {
                        if (elem.parentNode) elem.parentNode.removeChild(elem);
                    }, 300);
                }
            }, isSkillActivation ? 1500 : 1000);
        }

        /**
         * Show skill combo visual chain connecting skill pills
         */
        function showSkillComboChain(skillSequence) {
            if (!skillSequence || skillSequence.length < 2) return;

            const skillRow = document.querySelector('.skill-row');
            if (!skillRow) return;

            // Remove existing chain
            const existingChain = document.getElementById('skill-combo-chain');
            if (existingChain) existingChain.remove();

            const chainContainer = document.createElement('div');
            chainContainer.id = 'skill-combo-chain';
            chainContainer.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
                z-index: 5;
            `;
            skillRow.appendChild(chainContainer);

            const skillPills = Array.from(skillRow.querySelectorAll('.skill-pill'));
            const sequencePills = [];

            // Get pill positions for sequence
            skillSequence.forEach((skill, index) => {
                const pill = skillPills.find(p => p.dataset.skill === skill.slotKey);
                if (pill) {
                    sequencePills.push({
                        pill: pill,
                        skill: skill,
                        index: index
                    });
                }
            });

            if (sequencePills.length < 2) return;

            // Draw connecting lines
            for (let i = 0; i < sequencePills.length - 1; i++) {
                const fromPill = sequencePills[i].pill;
                const toPill = sequencePills[i + 1].pill;
                const fromRect = fromPill.getBoundingClientRect();
                const toRect = toPill.getBoundingClientRect();
                const rowRect = skillRow.getBoundingClientRect();

                const fromX = fromRect.left + fromRect.width / 2 - rowRect.left;
                const fromY = fromRect.top + fromRect.height / 2 - rowRect.top;
                const toX = toRect.left + toRect.width / 2 - rowRect.left;
                const toY = toRect.top + toRect.height / 2 - rowRect.top;

                const dx = toX - fromX;
                const dy = toY - fromY;
                const length = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;

                // Create animated chain line
                const chainLine = document.createElement('div');
                chainLine.className = 'combo-chain-line';
                chainLine.style.cssText = `
                    position: absolute;
                    left: ${fromX}px;
                    top: ${fromY}px;
                    width: ${length}px;
                    height: 3px;
                    background: linear-gradient(90deg, #FFD700, #FFA500, #FFD700);
                    background-size: 200% 100%;
                    transform: rotate(${angle}deg);
                    transform-origin: 0 50%;
                    box-shadow: 0 0 8px rgba(255, 215, 0, 0.8);
                    animation: chainPulse 0.8s ease-in-out infinite;
                `;
                chainContainer.appendChild(chainLine);

                // Add skill icon along the chain
                const iconPos = document.createElement('div');
                iconPos.className = 'combo-chain-icon';
                iconPos.style.cssText = `
                    position: absolute;
                    left: ${fromX + dx * 0.5}px;
                    top: ${fromY + dy * 0.5}px;
                    transform: translate(-50%, -50%);
                    font-size: 20px;
                    animation: iconFloat 1s ease-in-out infinite;
                `;
                iconPos.textContent = sequencePills[i + 1].skill.icon;
                chainContainer.appendChild(iconPos);
            }

            // Add CSS animation if not already added
            if (!document.getElementById('combo-chain-styles')) {
                const style = document.createElement('style');
                style.id = 'combo-chain-styles';
                style.textContent = `
                    @keyframes chainPulse {
                        0%, 100% { background-position: 0% 50%; opacity: 0.8; }
                        50% { background-position: 100% 50%; opacity: 1; }
                    }
                    @keyframes iconFloat {
                        0%, 100% { transform: translate(-50%, -50%) scale(1); }
                        50% { transform: translate(-50%, -50%) scale(1.2); }
                    }
                `;
                document.head.appendChild(style);
            }

            // Remove chain after animation
            setTimeout(() => {
                if (chainContainer.parentNode) {
                    chainContainer.style.opacity = '0';
                    chainContainer.style.transition = 'opacity 0.5s ease';
                    setTimeout(() => {
                        if (chainContainer.parentNode) chainContainer.remove();
                    }, 500);
                }
            }, 3000);
        }

        function createHealthBar() {
            const healthBarGroup = new THREE.Group();

            const bgBar = new THREE.Mesh(
                new THREE.PlaneGeometry(1.5, 0.2),
                new THREE.MeshBasicMaterial({ color: 0x333333 })
            );
            healthBarGroup.add(bgBar);

            const fgBar = new THREE.Mesh(
                new THREE.PlaneGeometry(1.5, 0.2),
                new THREE.MeshBasicMaterial({ color: 0x4CAF50 })
            );
            fgBar.position.z = 0.01; // Prevent z-fighting
            healthBarGroup.add(fgBar);

            healthBarGroup.name = 'healthBar';
            fgBar.name = 'fgBar';

            return healthBarGroup;
        }

        function updateHealthBars() {
            const allCharacters = [...gameState.npcs, ...gameState.partyMembers];
            for (const char of allCharacters) {
                if (char.healthBar) {
                    // Make health bar face the camera
                    char.healthBar.quaternion.copy(camera.quaternion);

                    // Update fill amount
                    const fgBar = char.healthBar.getObjectByName('fgBar');
                    if (fgBar) {
                        const healthPercent = char.currentHealth ? (char.currentHealth / char.maxHealth) : (char.health / char.maxHealth);
                        fgBar.scale.x = Math.max(0, healthPercent);
                        // Reposition to scale from the left
                        fgBar.position.x = -0.75 * (1 - fgBar.scale.x);
                    }

                    // Hide if dead or at full health
                    char.healthBar.visible = char.health > 0 && char.health < char.maxHealth;
                }
            }
        }

        function updateCamera() {
            const { mesh, cameraTarget } = gameState.activeCharacter;

            // Calculate ideal camera position
            const offset = new THREE.Vector3(0, CAMERA_HEIGHT, CAMERA_DISTANCE);
            offset.applyQuaternion(mesh.quaternion);
            const idealPosition = new THREE.Vector3().addVectors(mesh.position, offset);

            // Smoothly move camera to ideal position
            camera.position.lerp(idealPosition, 0.1);

            // Smoothly update the point camera looks at
            cameraTarget.lerp(mesh.position, 0.1);
            camera.lookAt(cameraTarget);
        }

        /**
         * Render X-shaped projectiles (anime-style with red and black lines)
         */
        function renderXProjectiles() {
            // Remove old X projectile meshes
            if (!window.xProjectileMeshes) {
                window.xProjectileMeshes = [];
            }

            // Remove meshes for projectiles that no longer exist
            for (let i = window.xProjectileMeshes.length - 1; i >= 0; i--) {
                const meshData = window.xProjectileMeshes[i];
                const stillExists = gameState.projectiles.some(p => p === meshData.projectile);
                if (!stillExists) {
                    scene.remove(meshData.line1);
                    scene.remove(meshData.line2);
                    meshData.line1.geometry.dispose();
                    meshData.line1.material.dispose();
                    meshData.line2.geometry.dispose();
                    meshData.line2.material.dispose();
                    window.xProjectileMeshes.splice(i, 1);
                }
            }

            // Render each X projectile
            for (const projectile of gameState.projectiles) {
                if (!projectile.isXProjectile) continue;

                // Find or create meshes for this projectile
                let meshData = window.xProjectileMeshes.find(m => m.projectile === projectile);

                if (!meshData) {
                    // Create new X shape meshes
                    const line1Geometry = new THREE.BufferGeometry();
                    const line2Geometry = new THREE.BufferGeometry();

                    // Red line material (anime-style glow) - 50% bigger
                    const redMaterial = new THREE.LineBasicMaterial({
                        color: 0xff0000,
                        linewidth: 6, // Increased from 4 to 6 (50% bigger)
                        transparent: true,
                        opacity: 0.9
                    });

                    // Black line material (anime-style dark energy) - 50% bigger
                    const blackMaterial = new THREE.LineBasicMaterial({
                        color: 0x000000,
                        linewidth: 4.5, // Increased from 3 to 4.5 (50% bigger)
                        transparent: true,
                        opacity: 0.8
                    });

                    const line1 = new THREE.Line(line1Geometry, redMaterial);
                    const line2 = new THREE.Line(line2Geometry, blackMaterial);

                    scene.add(line1);
                    scene.add(line2);

                    meshData = { projectile, line1, line2 };
                    window.xProjectileMeshes.push(meshData);
                }

                // Update line positions
                const line1Points = [projectile.line1Start, projectile.line1End];
                const line2Points = [projectile.line2Start, projectile.line2End];

                meshData.line1.geometry.setFromPoints(line1Points);
                meshData.line2.geometry.setFromPoints(line2Points);

                // Add glow effect (anime-style)
                const glowIntensity = 0.5 + Math.sin(Date.now() * 0.01) * 0.3;
                meshData.line1.material.opacity = 0.7 + glowIntensity * 0.3;
                meshData.line2.material.opacity = 0.6 + glowIntensity * 0.2;
            }
        }

        // -- RENDER LOGIC / GAME LOOP --
        // Store ability timers globally for access in animate
        window.abilityTimers = {
            rageActive: false,
            shieldActive: false,
            rageTimer: 0,
            shieldTimer: 0,
            rageCooldownTimer: 0,
            shieldCooldownTimer: 0,
            skillCooldowns: {}
        };


        function updateAllHealthBars() {
            const canvas = renderer.domElement;
            enemies.forEach(enemy => {
                if (!enemy.healthBarEl) return;

                const vector = new THREE.Vector3();
                // Position the bar slightly above the enemy's head
                enemy.mesh.getWorldPosition(vector).add(new THREE.Vector3(0, 1.2, 0));
                vector.project(camera);

                // Hide if behind camera
                if (vector.z > 1) {
                    enemy.healthBarEl.style.display = 'none';
                    return;
                }
                enemy.healthBarEl.style.display = 'block';

                const x = (vector.x * .5 + .5) * canvas.clientWidth;
                const y = (vector.y * -.5 + .5) * canvas.clientHeight;

                enemy.healthBarEl.style.left = `${x}px`;
                enemy.healthBarEl.style.top = `${y}px`;
            });
        }

        function animate() {
            requestAnimationFrame(animate);

            // Update performance monitor
            if (window.PerformanceMonitor) {
                window.PerformanceMonitor.update();
            }

            const deltaTime = clock.getDelta();

            // Update ability timers
            if (window.abilityTimers.rageActive) {
                window.abilityTimers.rageTimer -= deltaTime;
                if (window.abilityTimers.rageTimer <= 0) {
                    window.abilityTimers.rageActive = false;
                    if (gameState.activeCharacter) gameState.activeCharacter.rageMultiplier = 1.0;
                }
            }
            if (window.abilityTimers.rageCooldownTimer > 0) {
                window.abilityTimers.rageCooldownTimer -= deltaTime;
            }

            if (window.abilityTimers.shieldActive) {
                window.abilityTimers.shieldTimer -= deltaTime;
                if (window.abilityTimers.shieldTimer <= 0) {
                    window.abilityTimers.shieldActive = false;
                    if (gameState.activeCharacter) gameState.activeCharacter.shieldMultiplier = 1.0;
                }
            }
            if (window.abilityTimers.shieldCooldownTimer > 0) {
                window.abilityTimers.shieldCooldownTimer -= deltaTime;
            }

            // Update speed boost timer
            if (gameState.activeCharacter && gameState.activeCharacter.speedBoost) {
                gameState.activeCharacter.speedBoostTimer -= deltaTime;
                if (gameState.activeCharacter.speedBoostTimer <= 0) {
                    gameState.activeCharacter.speedBoost = false;
                    gameState.activeCharacter.speedBoostTimer = 0;
                }
            }

            // Mana regeneration (5 MP/sec, only when not flying)
            if (gameState.activeCharacter && !gameState.activeCharacter.isFlying) {
                if (gameState.activeCharacter.currentMana < gameState.activeCharacter.maxMana) {
                    gameState.activeCharacter.currentMana += 5 * deltaTime;
                    gameState.activeCharacter.currentMana = Math.min(
                        gameState.activeCharacter.currentMana,
                        gameState.activeCharacter.maxMana
                    );

                    // Update MP bar UI
                    const mpFill = document.querySelector('.mp-fill');
                    if (mpFill) {
                        const mpPercent = (gameState.activeCharacter.currentMana / gameState.activeCharacter.maxMana) * 100;
                        mpFill.style.width = `${mpPercent}%`;
                    }
                }
            }

            // Update combo state - check for window expiration
            const now = Date.now();
            const timeSinceLastAttack = now - gameState.comboState.lastBasicAttackTime;
            if (timeSinceLastAttack > gameState.comboState.comboWindow && gameState.comboState.basicAttackCount > 0) {
                gameState.comboState.basicAttackCount = 0;
                // Hide combo indicator
                const comboIndicator = document.getElementById('combo-indicator');
                if (comboIndicator) comboIndicator.remove();
            }

            // Update game logic
            updatePlayer(deltaTime);
            
            // Update flight system if flying
            if (gameState.activeCharacter && gameState.activeCharacter.isFlying) {
                MovementSystem.updateFlight(deltaTime);
            }
            
            InteractionSystem.update(deltaTime);
            InteractionSystem.updateDoorAnimations(deltaTime);
            
            // Update Building UI System (nameplates face camera)
            if (window.BuildingUISystem) {
                window.BuildingUISystem.update();
            }
            
            // Update Day/Night Cycle
            if (window.DayNightCycleSystem) {
                window.DayNightCycleSystem.update(deltaTime);
            }
            
            // Update Building Ownership (income generation)
            if (window.BuildingOwnershipSystem) {
                window.BuildingOwnershipSystem.generateIncome(deltaTime);
            }
            
            // Update Building Events
            if (window.BuildingEventSystem) {
                window.BuildingEventSystem.update(deltaTime);
            }
            
            // Update World Boss System
            if (window.WorldBossSystem) {
                window.WorldBossSystem.update(deltaTime);
            }
            updatePartyMembers(deltaTime);
            
            // Update team action physics (thrown teammates, spin attacks)
            if (typeof TeamActionSystem !== 'undefined' && TeamActionSystem.updatePhysics) {
                TeamActionSystem.updatePhysics(deltaTime);
            }
            
            updateDestructibleEnvironment(deltaTime);


            try {
                updateNPCs(deltaTime);
            } catch (e) {
                // Silently catch and handle errors to prevent game crash
                // Only log once per error type to avoid spam
                if (e && e.message && e.message.includes('currentHealth')) {
                    // This error is being caught and handled - game continues
                } else {
                    console.warn('Error in updateNPCs, skipping this frame:', e);
                }
            }
            updateProjectiles(deltaTime);
            updateSummons(deltaTime);

            // Update particle system
            if (particleSystem) {
                particleSystem.update(deltaTime);
            }

            // Update destructible system (air drops, etc.)
            if (window.destructibleSystem) {
                window.destructibleSystem.update(deltaTime);
            }

            // Update status effects
            if (statusEffectManager) {
                statusEffectManager.update(deltaTime);
            }

            // Update sprite renderer animations
            if (spriteRenderer) {
                spriteRenderer.update(deltaTime);
            }

            // Update sword swing system
            if (swordSwingSystem) {
                swordSwingSystem.update(deltaTime);
            }

            // Update 3D sprites
            if (sprite3DManager) {
                sprite3DManager.update(deltaTime);

                // Sync player sprite position/rotation with player mesh
                if (gameState.activeCharacter && gameState.activeCharacter.mesh && gameState.activeCharacter.sprite3D) {
                    const sprite = gameState.activeCharacter.sprite3D;
                    sprite.group.position.copy(gameState.activeCharacter.mesh.position);
                    sprite.group.rotation.copy(gameState.activeCharacter.mesh.rotation);

                    // Sync animation state based on player movement
                    const isMoving = keys['w'] || keys['a'] || keys['s'] || keys['d'];
                    const characterId = gameState.activeCharacter.characterId || 'A1';

                    // Check if attack animation is playing
                    if (spriteRenderer && spriteRenderer.characters[characterId]) {
                        const char = spriteRenderer.characters[characterId];
                        if (char.currentAnimation === 'attack') {
                            // Keep attack animation playing
                            if (sprite.animState.current !== 'attack') {
                                sprite.playAnimation('attack');
                            }
                        } else {
                            // Sync with movement
                            if (isMoving && sprite.animState.current === 'idle') {
                                sprite.playAnimation('walk');
                            } else if (!isMoving && sprite.animState.current === 'walk') {
                                sprite.playAnimation('idle');
                            }
                        }
                    } else {
                        // Fallback: sync with movement
                        if (isMoving && sprite.animState.current === 'idle') {
                            sprite.playAnimation('walk');
                        } else if (!isMoving && sprite.animState.current === 'walk') {
                            sprite.playAnimation('idle');
                        }
                    }
                }
            }

            // Update UI and feedback systems
            updateHUD();
            updateStatsPanel();
            updateDamageIndicators(deltaTime);
            updateHealthBars();
            updateSynergyComboDisplay();

            // ═══════════════════════════════════════════════════════════════
            // PHASE 2.2: BASIC COOLDOWN LOGIC - Update cooldowns in game loop
            // ═══════════════════════════════════════════════════════════════
            // Update Skill Cooldowns
            const playerCharId = gameState.activeCharacter.characterId;
            for (const charId in gameState.skillCooldowns) {
                for (const slotKey in gameState.skillCooldowns[charId]) {
                    if (gameState.skillCooldowns[charId][slotKey] > 0) {
                        gameState.skillCooldowns[charId][slotKey] -= deltaTime;
                        const remainingCooldown = gameState.skillCooldowns[charId][slotKey];

                        // Update HUD only for the player character
                        if (charId === playerCharId && window.HUD) {
                            // Initialize cooldown state tracking
                            if (!gameState.skillCooldownStates[slotKey]) {
                                gameState.skillCooldownStates[slotKey] = { wasReady: false };
                            }

                            if (remainingCooldown <= 0) {
                                gameState.skillCooldowns[charId][slotKey] = 0;

                                // Check if skill just became ready (transition from >0 to 0)
                                if (!gameState.skillCooldownStates[slotKey].wasReady) {
                                    // Play ready sound
                                    const skillLib = window.skillLibrary || skillLibrary;
                                    if (skillLib) {
                                        const skillId = skillLib.getEquippedSkill(charId, slotKey);
                                        if (skillId) {
                                            const skillData = skillLib.getSkillById(skillId);
                                            if (skillData) {
                                                playSound('skill_ready', {
                                                    element: skillData.element || 'PHYSICAL',
                                                    tier: skillData.tier || 'common',
                                                    pitch: 1.0 + (Math.random() - 0.5) * 0.1
                                                });
                                            }
                                        }
                                    }
                                    gameState.skillCooldownStates[slotKey].wasReady = true;
                                }

                                if (typeof window.HUD.setSkillReady === 'function') {
                                    window.HUD.setSkillReady(slotKey, true);
                                }
                                if (typeof window.HUD.updateSkillCooldown === 'function') {
                                    window.HUD.updateSkillCooldown(slotKey, 0);
                                }
                            } else {
                                // Skill is still on cooldown
                                gameState.skillCooldownStates[slotKey].wasReady = false;

                                // Update cooldown display
                                if (typeof window.HUD.updateSkillCooldown === 'function') {
                                    window.HUD.updateSkillCooldown(slotKey, remainingCooldown);
                                }
                            }
                        }
                    }
                }
            }

            // Update Mastery UI for equipped skills
            if (playerCharId && window.skillLibrary && window.HUD && typeof window.HUD.updateSkillMastery === 'function') {
                const skillLib = window.skillLibrary;
                ['S1', 'S2', 'S3'].forEach(slotKey => {
                    const skillData = skillLib.getEquippedSkill(playerCharId, slotKey);
                    if (skillData) {
                        window.HUD.updateSkillMastery(slotKey, playerCharId, skillData.id);
                    }
                });
            }

            // Update Synergy UI (throttled to every 0.5 seconds)
            if (!window.lastSynergyUpdate) window.lastSynergyUpdate = 0;
            if (Date.now() - window.lastSynergyUpdate > 500) {
                if (playerCharId && window.HUD && typeof window.HUD.updateSkillSynergies === 'function') {
                    window.HUD.updateSkillSynergies(playerCharId);
                }
                window.lastSynergyUpdate = Date.now();
            }

            // Clear combo sequence if window expired
            const comboNow = Date.now();
            if (gameState.skillComboSequence.length > 0) {
                const lastSkillTime = gameState.skillComboSequence[gameState.skillComboSequence.length - 1].timestamp;
                if (comboNow - lastSkillTime > gameState.synergyComboState.comboWindow) {
                    gameState.skillComboSequence = [];
                }
            }

            
    if (window.destructibleSystem) {
        window.destructibleSystem.update(deltaTime);
        
        // Make health bars face camera
        if (camera) {
            window.destructibleSystem.objects.forEach(obj => {
                if (obj.healthBar) {
                    obj.healthBar.lookAt(camera.position);
                }
            });
        }
    }

// Update camera
            updateCamera();

            // Render X-shaped projectiles (anime-style)
            renderXProjectiles();

            // Render the scene (handle fallback renderer gracefully)
            if (renderer && typeof renderer.render === 'function') {
                try {
                    renderer.render(scene, camera);
                } catch (e) {
                    // Silently handle rendering errors to prevent game crash
                    if (window.USING_FALLBACK_RENDERER) {
                        // Fallback renderer handles errors internally
                        console.warn('Rendering error (fallback mode):', e.message);
                    } else {
                        console.error('Rendering error:', e);
                    }
                }
            }
        }

        /**
         * Update synergy combo counter display
         */
        function updateSynergyComboDisplay() {
            const counter = document.getElementById('synergy-combo-counter');
            if (!counter) return;

            const comboState = gameState.synergyComboState;
            const now = Date.now();
            const timeSinceLastSynergy = now - comboState.lastSynergyTime;

            // Reset combo if window expired
            if (timeSinceLastSynergy > comboState.comboWindow && comboState.currentCombo > 0) {
                comboState.currentCombo = 0;
            }

            // Update display
            const comboValue = document.getElementById('synergy-combo-value');
            const totalSpan = document.getElementById('synergy-total');
            const maxSpan = document.getElementById('synergy-max');

            if (comboValue) comboValue.textContent = comboState.currentCombo;
            if (totalSpan) totalSpan.textContent = comboState.totalCombos;
            if (maxSpan) maxSpan.textContent = comboState.maxCombo;

            // Add active class if combo > 0
            if (comboState.currentCombo > 0) {
                counter.classList.add('active');
                setTimeout(() => counter.classList.remove('active'), 500);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();


            // Camera Zoom Effect variables
            let originalCameraZoom = camera.zoom;
            let cameraZoomTarget = originalCameraZoom;
            const cameraZoomSpeed = 5; // Controls how fast the zoom happens
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // ===== A1K BUTTON SYSTEM INTEGRATION =====
        // ===== COMPLETE HUD SYSTEM OVERHAUL (OPTION 3) =====
        // Initialize HUD BEFORE init() to ensure it's available when animate() starts
        (function () {
            'use strict';

            // Configuration
            const HUDConfig = {
                enableAnimations: true,
                animationDuration: 300,
                enablePerformanceMonitoring: true,
                updateThrottle: 16,
                enableErrorRecovery: true,
                enableDebugMode: false,
                maxErrorLogSize: 100,
                retryAttempts: 3,
                retryDelay: 100
            };

            // Internal state
            const HUDState = {
                initialized: false,
                skills: new Map(),
                lastUpdate: 0,
                errorLog: [],
                performance: { updateCount: 0, averageUpdateTime: 0, maxUpdateTime: 0, minUpdateTime: Infinity, totalUpdateTime: 0 },
                recoveryAttempts: 0
            };

            // Error handling
            const ErrorHandler = {
                logError(method, error, context = {}) {
                    const errorEntry = {
                        timestamp: Date.now(),
                        method,
                        error: error instanceof Error ? error.message : error,
                        context
                    };
                    HUDState.errorLog.push(errorEntry);
                    if (HUDState.errorLog.length > HUDConfig.maxErrorLogSize) HUDState.errorLog.shift();
                    if (HUDConfig.enableDebugMode) console.error(`[HUD Error] ${method}:`, error, context);
                    if (HUDConfig.enableErrorRecovery && !HUDState.initialized && HUDState.recoveryAttempts < HUDConfig.retryAttempts) {
                        HUDState.recoveryAttempts++;
                        setTimeout(() => initializeHUD(), HUDConfig.retryDelay * HUDState.recoveryAttempts);
                    }
                },
                getErrorStats() {
                    return { totalErrors: HUDState.errorLog.length, recentErrors: HUDState.errorLog.slice(-10) };
                },
                clearErrors() { HUDState.errorLog = []; HUDState.recoveryAttempts = 0; }
            };

            // Performance monitoring
            const PerformanceMonitor = {
                start() { return performance.now(); },
                end(startTime, operation = 'unknown') {
                    const duration = performance.now() - startTime;
                    const perf = HUDState.performance;
                    perf.updateCount++;
                    perf.totalUpdateTime += duration;
                    perf.averageUpdateTime = perf.totalUpdateTime / perf.updateCount;
                    perf.maxUpdateTime = Math.max(perf.maxUpdateTime, duration);
                    perf.minUpdateTime = Math.min(perf.minUpdateTime, duration);
                    if (HUDConfig.enableDebugMode && duration > 16) console.warn(`[HUD Performance] ${operation} took ${duration.toFixed(2)}ms`);
                    return duration;
                },
                getStats() { return { ...HUDState.performance, fps: 1000 / HUDState.performance.averageUpdateTime || 0 }; },
                reset() { HUDState.performance = { updateCount: 0, averageUpdateTime: 0, maxUpdateTime: 0, minUpdateTime: Infinity, totalUpdateTime: 0 }; }
            };

            // Animation manager
            const AnimationManager = {
                activeAnimations: new Map(),
                animate(element, property, startValue, endValue, duration, easing = this.easeInOutQuad, callback = null) {
                    if (!HUDConfig.enableAnimations) { if (callback) callback(); return; }
                    const animationId = `${Date.now()}-${Math.random()}`;
                    const startTime = performance.now();
                    const animate = (currentTime) => {
                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / duration, 1);
                        const easedProgress = easing(progress);
                        let currentValue = typeof startValue === 'number' && typeof endValue === 'number'
                            ? startValue + (endValue - startValue) * easedProgress : (progress < 0.5 ? startValue : endValue);
                        if (property.startsWith('style.')) {
                            element.style[property.replace('style.', '')] = currentValue;
                        } else {
                            element[property] = currentValue;
                        }
                        if (progress < 1) {
                            this.activeAnimations.set(animationId, requestAnimationFrame(animate));
                        } else {
                            this.activeAnimations.delete(animationId);
                            if (callback) callback();
                        }
                    };
                    this.activeAnimations.set(animationId, requestAnimationFrame(animate));
                    return animationId;
                },
                cancel(animationId) { if (this.activeAnimations.has(animationId)) { cancelAnimationFrame(this.activeAnimations.get(animationId)); this.activeAnimations.delete(animationId); } },
                cancelAll() { this.activeAnimations.forEach(id => cancelAnimationFrame(id)); this.activeAnimations.clear(); },
                easeInOutQuad(t) { return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t; },
                easeOutQuad(t) { return t * (2 - t); }
            };

            // DOM utilities with caching
            const DOMUtils = {
                cache: new Map(),
                cacheTimeout: 5000,
                getElement(selector, useCache = true) {
                    if (useCache && this.cache.has(selector)) {
                        const cached = this.cache.get(selector);
                        if (cached.element && document.contains(cached.element)) return cached.element;
                        this.cache.delete(selector);
                    }
                    try {
                        const element = document.querySelector(selector);
                        if (element && useCache) this.cache.set(selector, { element, timestamp: Date.now() });
                        return element;
                    } catch (error) {
                        ErrorHandler.logError('getElement', error, { selector });
                        return null;
                    }
                },
                clearCache() { this.cache.clear(); }
            };

            // Validation utilities
            const Validator = {
                isValidSkillId(id) { return typeof id === 'string' && /^(S1|S2|S3)$/.test(id); },
                isValidCooldown(cooldown) { return typeof cooldown === 'number' && cooldown >= 0 && isFinite(cooldown); },
                isValidElement(element) { return element instanceof HTMLElement && document.contains(element); },
                isValidCharacterId(characterId) { return typeof characterId === 'string' && characterId.length > 0; }
            };

            // Initialize HUD system
            function initializeHUD() {
                try {
                    const startTime = PerformanceMonitor.start();
                    DOMUtils.clearCache();
                    AnimationManager.cancelAll();
                    ['S1', 'S2', 'S3'].forEach(skillId => {
                        const element = DOMUtils.getElement(`.skill-row [data-skill="${skillId}"]`, false);
                        if (element) {
                            HUDState.skills.set(skillId, { element, id: skillId, ready: true, cooldown: 0, mastery: null });
                        }
                    });
                    HUDState.initialized = true;
                    HUDState.lastUpdate = Date.now();
                    PerformanceMonitor.end(startTime, 'initializeHUD');
                    if (HUDConfig.enableDebugMode) console.log('[HUD] Initialized successfully');
                    return true;
                } catch (error) {
                    ErrorHandler.logError('initializeHUD', error);
                    HUDState.initialized = false;
                    return false;
                }
            }

            // Main HUD object
            const HUD = window.HUD = window.HUD || {};

            // Enhanced skillEl with caching and validation
            function skillEl(id) {
                if (!Validator.isValidSkillId(id)) {
                    if (ErrorHandler) {
                        ErrorHandler.logError('skillEl', `Invalid skill ID: ${id}`);
                    }
                    return null;
                }
                const element = DOMUtils.getElement(`.skill-row [data-skill="${id}"]`);
                if (!element && ErrorHandler) {
                    // Log warning but don't throw - element might not exist yet
                    ErrorHandler.logError('skillEl', `Element not found for skill: ${id}`, { silent: true });
                }
                return element;
            }

            /**
             * Set skill ready state with animation support
             * @param {string} id - Skill ID (S1, S2, S3)
             * @param {boolean} ready - Ready state
             */
            HUD.setSkillReady = function (id, ready = true) {
                try {
                    const startTime = PerformanceMonitor.start();

                    if (!HUDState.initialized && !initializeHUD()) {
                        ErrorHandler.logError('setSkillReady', 'HUD not initialized', { id, ready });
                        return;
                    }

                    if (!Validator.isValidSkillId(id)) {
                        ErrorHandler.logError('setSkillReady', `Invalid skill ID: ${id}`);
                        return;
                    }

                    const el = skillEl(id);
                    if (!el) {
                        // Element might not exist yet - try to initialize HUD first
                        if (!HUDState.initialized) {
                            initializeHUD();
                            const retryEl = skillEl(id);
                            if (!retryEl) {
                                if (ErrorHandler) {
                                    ErrorHandler.logError('setSkillReady', `Element not found for skill: ${id}`, { silent: true });
                                }
                                return;
                            }
                            // Use retryEl if found
                            const skillData = HUDState.skills.get(id);
                            if (skillData) {
                                skillData.ready = !!ready;
                            }
                            retryEl.classList.toggle('ready', !!ready);
                            return;
                        }
                        if (ErrorHandler) {
                            ErrorHandler.logError('setSkillReady', `Element not found for skill: ${id}`, { silent: true });
                        }
                        return;
                    }

                    const skillData = HUDState.skills.get(id);
                    if (skillData) {
                        skillData.ready = !!ready;
                    }

                    // Update class with optional animation
                    if (HUDConfig.enableAnimations) {
                        const currentOpacity = ready ? 1 : 0.5;
                        const targetOpacity = ready ? 1 : 0.5;
                        AnimationManager.animate(el, 'style.opacity', currentOpacity, targetOpacity, HUDConfig.animationDuration / 2);
                    }

                    el.classList.toggle('ready', !!ready);

                    HUDState.lastUpdate = Date.now();
                    PerformanceMonitor.end(startTime, 'setSkillReady');
                } catch (error) {
                    ErrorHandler.logError('setSkillReady', error, { id, ready });
                }
            };

            /**
             * Update skill cooldown display with enhanced features
             * @param {string} id - Skill ID (S1, S2, S3)
             * @param {number} cooldown - Cooldown in seconds
             */
            HUD.updateSkillCooldown = function (id, cooldown) {
                try {
                    const startTime = PerformanceMonitor.start();

                    if (!HUDState.initialized && !initializeHUD()) {
                        ErrorHandler.logError('updateSkillCooldown', 'HUD not initialized', { id, cooldown });
                        return;
                    }

                    if (!Validator.isValidSkillId(id)) {
                        ErrorHandler.logError('updateSkillCooldown', `Invalid skill ID: ${id}`);
                        return;
                    }

                    if (!Validator.isValidCooldown(cooldown)) {
                        ErrorHandler.logError('updateSkillCooldown', `Invalid cooldown value: ${cooldown}`, { id });
                        return;
                    }

                    const el = skillEl(id);
                    if (!el) {
                        // Element might not exist yet - try to initialize HUD first
                        if (!HUDState.initialized) {
                            initializeHUD();
                            const retryEl = skillEl(id);
                            if (!retryEl) {
                                if (ErrorHandler) {
                                    ErrorHandler.logError('updateSkillCooldown', `Element not found for skill: ${id}`, { silent: true });
                                }
                                return;
                            }
                            // Continue with retryEl
                            const skillData = HUDState.skills.get(id);
                            if (skillData) {
                                skillData.cooldown = cooldown;
                            }
                            // Update cooldown display would continue here...
                            return;
                        }
                        if (ErrorHandler) {
                            ErrorHandler.logError('updateSkillCooldown', `Element not found for skill: ${id}`, { silent: true });
                        }
                        return;
                    }

                    // Update internal state
                    const skillData = HUDState.skills.get(id);
                    if (skillData) {
                        skillData.cooldown = cooldown;
                    }

                    // Remove existing cooldown text
                    const existingText = el.querySelector('.cooldown-text');
                    if (existingText) {
                        if (HUDConfig.enableAnimations) {
                            AnimationManager.animate(existingText, 'style.opacity', 1, 0, HUDConfig.animationDuration / 3, AnimationManager.easeOutQuad, () => {
                                existingText.remove();
                            });
                        } else {
                            existingText.remove();
                        }
                    }

                    if (cooldown > 0) {
                        const cooldownText = document.createElement('div');
                        cooldownText.className = 'cooldown-text';
                        cooldownText.style.cssText = 'position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 18px; font-weight: bold; color: #fff; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); z-index: 10; opacity: 0;';
                        cooldownText.textContent = cooldown.toFixed(1);
                        el.appendChild(cooldownText);

                        // Animate in
                        if (HUDConfig.enableAnimations) {
                            AnimationManager.animate(cooldownText, 'style.opacity', 0, 1, HUDConfig.animationDuration / 3);
                        } else {
                            cooldownText.style.opacity = '1';
                        }

                        el.classList.remove('ready');
                        if (skillData) {
                            skillData.ready = false;
                        }
                    } else {
                        el.classList.add('ready');
                        if (skillData) {
                            skillData.ready = true;
                        }
                    }

                    HUDState.lastUpdate = Date.now();
                    PerformanceMonitor.end(startTime, 'updateSkillCooldown');
                } catch (error) {
                    ErrorHandler.logError('updateSkillCooldown', error, { id, cooldown });
                }
            };

            // Mastery UI Update Function
            HUD.updateSkillMastery = function (id, characterId, skillId) {
                const el = skillEl(id);
                if (!el) return;

                const skillLib = window.skillLibrary || skillLibrary;
                if (!skillLib || !skillId) {
                    // Remove mastery UI if no skill
                    el.querySelectorAll('.mastery-badge, .mastery-xp-bar, .mastery-tooltip').forEach(e => e.remove());
                    return;
                }

                // Initialize mastery if needed
                skillLib.initMastery(characterId, skillId);
                const mastery = skillLib.skillMastery[characterId][skillId];
                const stats = skillLib.skillStats[characterId][skillId];
                if (!mastery) return;

                // Update mastery badge
                let badge = el.querySelector('.mastery-badge');
                if (!badge) {
                    badge = document.createElement('div');
                    badge.className = 'mastery-badge';
                    el.appendChild(badge);
                }
                badge.textContent = mastery.level || 1;

                // Update XP bar
                let xpBar = el.querySelector('.mastery-xp-bar');
                if (!xpBar) {
                    xpBar = document.createElement('div');
                    xpBar.className = 'mastery-xp-bar';
                    el.appendChild(xpBar);

                    const xpFill = document.createElement('div');
                    xpFill.className = 'mastery-xp-fill';
                    xpBar.appendChild(xpFill);
                }
                const xpFill = xpBar.querySelector('.mastery-xp-fill');
                if (xpFill) {
                    const currentXP = mastery.currentXP || 0;
                    const xpForNextLevel = mastery.xpForNextLevel || 100;
                    const xpPercent = Math.min(100, (currentXP / xpForNextLevel) * 100);
                    xpFill.style.width = `${xpPercent}%`;
                }

                // Update tooltip
                let tooltip = el.querySelector('.mastery-tooltip');
                if (!tooltip) {
                    tooltip = document.createElement('div');
                    tooltip.className = 'mastery-tooltip';
                    el.appendChild(tooltip);
                }
                const bonuses = skillLib.getMasteryBonuses(characterId, skillId);
                tooltip.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 4px;">Mastery Lv.${mastery.level || 1}</div>
                    <div>XP: ${mastery.currentXP || 0}/${mastery.xpForNextLevel || 100}</div>
                    <div>DMG: +${(bonuses.damageBonus * 100).toFixed(1)}%</div>
                    <div>CD: -${(bonuses.cooldownReduction * 100).toFixed(1)}%</div>
                    <div>Uses: ${stats.totalUses || 0}</div>
                    <div>Kills: ${stats.totalKills || 0}</div>
                `;
            };

            // Synergy UI Update Function
            HUD.updateSkillSynergies = function (characterId) {
                const skillRow = document.querySelector('.skill-row');
                if (!skillRow) return;

                // Remove existing synergy indicators
                skillRow.querySelectorAll('.synergy-connection, .synergy-indicator').forEach(e => e.remove());
                skillRow.querySelectorAll('.skill-pill').forEach(pill => {
                    pill.classList.remove('synergy-available');
                });

                const synergies = getAvailableSynergies(characterId);
                if (synergies.length === 0) return;

                const skillPills = Array.from(skillRow.querySelectorAll('.skill-pill'));

                synergies.forEach(synergy => {
                    const fromPill = skillPills.find(p => p.dataset.skill === synergy.from);
                    const toPill = skillPills.find(p => p.dataset.skill === synergy.to);

                    if (!fromPill || !toPill) return;

                    // Mark target skill as having synergy available
                    toPill.classList.add('synergy-available');

                    // Add synergy indicator
                    let indicator = toPill.querySelector('.synergy-indicator');
                    if (!indicator) {
                        indicator = document.createElement('div');
                        indicator.className = 'synergy-indicator';
                        toPill.appendChild(indicator);
                    }
                    indicator.textContent = '⚡';
                    indicator.title = `${synergy.name}: ${synergy.description}`;

                    // Draw connection line
                    const fromRect = fromPill.getBoundingClientRect();
                    const toRect = toPill.getBoundingClientRect();
                    const rowRect = skillRow.getBoundingClientRect();

                    const fromX = fromRect.left + fromRect.width / 2 - rowRect.left;
                    const fromY = fromRect.top + fromRect.height / 2 - rowRect.top;
                    const toX = toRect.left + toRect.width / 2 - rowRect.left;
                    const toY = toRect.top + toRect.height / 2 - rowRect.top;

                    const dx = toX - fromX;
                    const dy = toY - fromY;
                    const length = Math.sqrt(dx * dx + dy * dy);
                    const angle = Math.atan2(dy, dx) * 180 / Math.PI;

                    const connection = document.createElement('div');
                    connection.className = 'synergy-connection';
                    connection.style.cssText = `
                        left: ${fromX}px;
                        top: ${fromY}px;
                        width: ${length}px;
                        transform: rotate(${angle}deg);
                        transform-origin: 0 50%;
                    `;
                    connection.title = `${synergy.name}: ${synergy.description}`;
                    skillRow.appendChild(connection);
                });
            };

            HUD.setJoystickReady = function (ready = true) {
                document.getElementById('vj-root').classList.toggle('ready', !!ready);
            };

            HUD.setAllReady = function (ready = true) {
                HUD.setSkillReady('S1', ready);
                HUD.setSkillReady('S2', ready);
                HUD.setSkillReady('S3', ready);
                HUD.setJoystickReady(ready);
            };

            /**
             * Initialize skill tooltips on hover
             */
            HUD.initSkillTooltips = function () {
                const skillPills = document.querySelectorAll('.skill-pill');
                skillPills.forEach(pill => {
                    pill.addEventListener('mouseenter', (e) => {
                        const skillId = pill.dataset.skill;
                        if (skillId) {
                            HUD.showSkillTooltip(skillId, e);
                        }
                    });
                    pill.addEventListener('mouseleave', () => {
                        HUD.hideSkillTooltip();
                    });
                    pill.addEventListener('mousemove', (e) => {
                        const skillId = pill.dataset.skill;
                        if (skillId) {
                            HUD.updateTooltipPosition(e);
                        }
                    });
                });
            };

            /**
             * Show skill tooltip with stats
             */
            HUD.showSkillTooltip = function (skillId, event) {
                const skillLib = window.skillLibrary || skillLibrary;
                if (!skillLib) return;

                const characterId = gameState.activeCharacter?.characterId || 'A1';
                const equippedSkill = skillLib.getEquippedSkill(characterId, skillId);
                if (!equippedSkill) return;

                const skillData = equippedSkill; // The object returned is the full skill data
                if (!skillData) return;

                // Remove existing tooltip
                const existing = document.querySelector('.skill-tooltip');
                if (existing) existing.remove();

                // Create tooltip
                const tooltip = document.createElement('div');
                tooltip.className = 'skill-tooltip';

                // Header
                const header = document.createElement('div');
                header.className = 'skill-tooltip-header';
                header.innerHTML = `
                    <span class="skill-tooltip-icon">${skillData.icon || '⚔️'}</span>
                    <span class="skill-tooltip-name">${skillData.name || 'Unknown Skill'}</span>
                    <span class="skill-tooltip-tier">${(skillData.tier || 'common').toUpperCase()}</span>
                `;
                tooltip.appendChild(header);

                // Description
                if (skillData.description) {
                    const desc = document.createElement('div');
                    desc.className = 'skill-tooltip-description';
                    desc.textContent = skillData.description;
                    tooltip.appendChild(desc);
                }

                // Stats
                const stats = document.createElement('div');
                stats.className = 'skill-tooltip-stats';

                const damage = Array.isArray(skillData.damage) ? skillData.damage[0] : (skillData.damage || skillData.baseDamage || 0);
                const cooldown = skillData.cooldown || 0;
                const critChance = (skillData.critChance || 0) * 100;
                const pierceCount = skillData.pierceCount || 0;
                const areaOfEffect = skillData.areaOfEffect || 0;
                const lifesteal = (skillData.lifesteal || 0) * 100;

                const statPairs = [
                    ['Damage', Math.round(damage)],
                    ['Cooldown', `${cooldown.toFixed(1)}s`],
                    ['Crit Chance', `${critChance.toFixed(1)}%`],
                    ['Pierce', pierceCount > 0 ? pierceCount : 'None'],
                    ['AoE Radius', areaOfEffect > 0 ? `${areaOfEffect}m` : 'None'],
                    ['Lifesteal', lifesteal > 0 ? `${lifesteal.toFixed(1)}%` : 'None']
                ];

                statPairs.forEach(([label, value]) => {
                    const stat = document.createElement('div');
                    stat.className = 'skill-tooltip-stat';
                    stat.innerHTML = `
                        <span class="skill-tooltip-stat-label">${label}:</span>
                        <span class="skill-tooltip-stat-value">${value}</span>
                    `;
                    stats.appendChild(stat);
                });

                // Status effects
                if (skillData.statusEffects && skillData.statusEffects.length > 0) {
                    const statusEffects = document.createElement('div');
                    statusEffects.className = 'skill-tooltip-stat';
                    statusEffects.style.gridColumn = '1 / -1';
                    statusEffects.innerHTML = `
                        <span class="skill-tooltip-stat-label">Status Effects:</span>
                        <span class="skill-tooltip-stat-value">${skillData.statusEffects.map(e => e.type).join(', ')}</span>
                    `;
                    stats.appendChild(statusEffects);
                }

                tooltip.appendChild(stats);

                // Element
                if (skillData.element) {
                    const element = document.createElement('div');
                    element.className = 'skill-tooltip-element';
                    element.textContent = `Element: ${skillData.element}`;
                    tooltip.appendChild(element);
                }

                document.body.appendChild(tooltip);
                HUD.updateTooltipPosition(event);
                setTimeout(() => tooltip.classList.add('visible'), 10);
            };

            /**
             * Update tooltip position
             */
            HUD.updateTooltipPosition = function (event) {
                const tooltip = document.querySelector('.skill-tooltip');
                if (!tooltip) return;

                const x = event.clientX + 15;
                const y = event.clientY - 10;

                // Keep tooltip within viewport
                const tooltipRect = tooltip.getBoundingClientRect();
                const maxX = window.innerWidth - tooltipRect.width - 10;
                const maxY = window.innerHeight - tooltipRect.height - 10;

                tooltip.style.left = `${Math.min(x, maxX)}px`;
                tooltip.style.top = `${Math.max(10, Math.min(y, maxY))}px`;
            };

            /**
             * Hide skill tooltip
             */
            HUD.hideSkillTooltip = function () {
                const tooltip = document.querySelector('.skill-tooltip');
                if (tooltip) {
                    tooltip.classList.remove('visible');
                    setTimeout(() => tooltip.remove(), 200);
                }
            };
        })();

        // -- INITIALIZATION --
        // Initialize stats panel tabs
        initStatsPanelTabs();

        // Initialize skill tooltips
        if (window.HUD && typeof window.HUD.initSkillTooltips === 'function') {
            // Wait for DOM to be ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', () => {
                    window.HUD.initSkillTooltips();
                });
            } else {
                window.HUD.initSkillTooltips();
            }
        }

        // Initialize game (after HUD is ready and DOM is fully loaded)
        function startGame() {
            // Ensure document.body exists before initializing
            if (!document.body) {
                // Wait for body to be available
                if (document.readyState === 'loading') {
                    document.addEventListener('DOMContentLoaded', () => {
                        setTimeout(() => init(), 100); // Small delay to ensure all elements are ready
                    });
                } else {
                    setTimeout(() => startGame(), 50); // Retry after short delay
                }
                return;
            }
            
            // Double-check that body is actually in the DOM
            if (!document.body.parentElement) {
                setTimeout(() => startGame(), 50);
                return;
            }
            
            try {
                init();
            } catch (error) {
                console.error('Error initializing game:', error);
                // Show user-friendly error message
                const errorDiv = document.createElement('div');
                errorDiv.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(255, 0, 0, 0.9); color: white; padding: 20px; border-radius: 8px; z-index: 10000; max-width: 500px; text-align: center;';
                errorDiv.innerHTML = `
                    <h2>⚠️ Initialization Error</h2>
                    <p>${error.message}</p>
                    <button onclick="location.reload()" style="margin-top: 15px; padding: 10px 20px; background: white; color: black; border: none; border-radius: 4px; cursor: pointer;">Reload Page</button>
                `;
                document.body.appendChild(errorDiv);
            }
        }
        
        // Start the game
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                setTimeout(() => startGame(), 100);
            });
        } else {
            setTimeout(() => startGame(), 100);
        }

        // ===== JOYSTICK CONTROLLER =====
        (function () {
            const root = document.getElementById('vj-root');
            const knob = document.getElementById('vj-knob');
            const radius = 59; // Half of base size
            let isActive = false;
            let joystickState = { x: 0, y: 0, active: false };

            function getTouch(e) {
                return e.touches ? e.touches[0] : e;
            }

            function handleStart(e) {
                if (e.type === 'mousedown' && e.button !== 0) return;
                isActive = true;
                joystickState.active = true;
                if (e.type === 'touchstart') e.preventDefault();
                handleMove(e);
            }

            function handleMove(e) {
                if (!isActive) return;

                const touch = getTouch(e);
                const rect = root.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;

                let dx = touch.clientX - centerX;
                let dy = touch.clientY - centerY;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance > radius) {
                    const ratio = radius / distance;
                    dx *= ratio;
                    dy *= ratio;
                }

                knob.style.transform = `translate(${dx}px, ${dy}px)`;

                // Emit joystick move event (normalized -1 to 1)
                const joyX = dx / radius;
                const joyY = dy / radius;
                joystickState.x = joyX;
                joystickState.y = joyY;

                window.dispatchEvent(new CustomEvent('joystick:move', {
                    detail: { x: joyX, y: joyY, distance: distance / radius }
                }));

                if (e.type === 'touchmove') e.preventDefault();
            }

            function handleEnd(e) {
                if (!isActive) return;
                isActive = false;
                joystickState.active = false;
                joystickState.x = 0;
                joystickState.y = 0;
                knob.style.transform = 'translate(0, 0)';
                window.dispatchEvent(new CustomEvent('joystick:end', { detail: { x: 0, y: 0 } }));
            }

            // Attach events
            root.addEventListener('touchstart', handleStart, { passive: false });
            root.addEventListener('touchmove', handleMove, { passive: false });
            root.addEventListener('touchend', handleEnd);
            root.addEventListener('touchcancel', handleEnd);
            root.addEventListener('mousedown', handleStart);
            document.addEventListener('mousemove', handleMove);
            document.addEventListener('mouseup', handleEnd);

            // Expose joystick state for game access
            window.joystickState = joystickState;
        })();

        // ===== BUTTON CLICK HANDLERS =====
        (function () {
            const buttons = document.querySelectorAll('[data-btn]');

            buttons.forEach(btn => {
                btn.addEventListener('click', function () {
                    const btnType = this.dataset.btn;
                    console.log('Button clicked:', btnType);

                    // Emit custom event
                    window.dispatchEvent(new CustomEvent('button:click', {
                        detail: { button: btnType }
                    }));
                });
            });
        })();

        // ===== GAME INTEGRATION =====
        // Joystick movement integration
        let joystickInput = { x: 0, y: 0 };
        window.addEventListener('joystick:move', (e) => {
            joystickInput.x = e.detail.x;
            joystickInput.y = e.detail.y;
        });

        window.addEventListener('joystick:end', () => {
            joystickInput.x = 0;
            joystickInput.y = 0;
        });

        // Attack button integration
        window.addEventListener('button:click', (e) => {
            if (e.detail.button === 'attack') {
                firePrimaryPower();
            }
        });

        // Jump button integration
        window.addEventListener('button:click', (e) => {
            if (e.detail.button === 'jump') {
                if (typeof MovementSystem !== 'undefined' && MovementSystem.handleJumpInput) {
                    MovementSystem.handleJumpInput();
                }
            }
        });

        // Skill buttons integration
        window.addEventListener('button:click', (e) => {
            const btn = e.detail.button;
            if (btn === 's1') activateSkillBySlot(1);
            if (btn === 's2') activateSkillBySlot(2);
            if (btn === 's3') activateSkillBySlot(3);
        });

        // Initialize player state for jump and abilities
        // This is now handled within the character objects in gameState.characters
        /*
        gameState.player.isJumping = false;
        gameState.player.onGround = true;
        gameState.player.jumpVelocity = 0;
        gameState.player.rageMultiplier = 1.0;
        gameState.player.shieldMultiplier = 1.0;
        gameState.player.speedBoost = false;
        gameState.player.speedBoostTimer = 0;
        */

        // Utility buttons (placeholder handlers)
        window.addEventListener('button:click', (e) => {
            const btn = e.detail.button;
            if (btn === 'switch') {
                switchCharacter();
            } else if (btn === 'bag') {
                // Open bag system
                if (window.BagSystem) {
                    window.BagSystem.open();
                } else {
                    console.warn('BagSystem not initialized yet');
                }
            } else if (['pet', 'veh', 'act', 'ai'].includes(btn)) {
                console.log(`Utility button ${btn} pressed - placeholder`);
                // Future implementation
            } else if (btn === 'act2') {
                // Act2 is handled by hold events below, but allow tap-to-pickup if not holding
                if (typeof TeamActionSystem !== 'undefined' && !TeamActionSystem.isHoldingButton) {
                    TeamActionSystem.tryPickupTeammate();
                }
            }
        });

        // ═══════════════════════════════════════════════════════════════════════════
        // WIRE ACT 2 HOLD EVENTS
        // ═══════════════════════════════════════════════════════════════════════════
        (function() {
            // Wait for DOM to be ready
            function wireAct2HoldEvents() {
                const act2Btn = document.querySelector('[data-btn="act2"]');
                if (!act2Btn) {
                    // Retry after a short delay if button not found
                    setTimeout(wireAct2HoldEvents, 100);
                    return;
                }

                // Remove any existing listeners by cloning the button
                const newBtn = act2Btn.cloneNode(true);
                act2Btn.parentNode.replaceChild(newBtn, act2Btn);
                const btn = newBtn;

                // Touch Events
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (typeof TeamActionSystem !== 'undefined' && TeamActionSystem.startAct2) {
                        TeamActionSystem.startAct2();
                    }
                    btn.style.transform = "scale(0.9)";
                }, { passive: false });

                btn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    if (typeof TeamActionSystem !== 'undefined' && TeamActionSystem.endAct2) {
                        TeamActionSystem.endAct2();
                    }
                    btn.style.transform = "scale(1.0)";
                }, { passive: false });

                // Mouse Events
                btn.addEventListener('mousedown', (e) => {
                    if (typeof TeamActionSystem !== 'undefined' && TeamActionSystem.startAct2) {
                        TeamActionSystem.startAct2();
                    }
                    btn.style.transform = "scale(0.9)";
                });

                // Global mouseup to catch if they drag off the button
                const handleMouseUp = (e) => {
                    if (typeof TeamActionSystem !== 'undefined' && TeamActionSystem.isHoldingButton) {
                        TeamActionSystem.endAct2();
                    }
                    btn.style.transform = "scale(1.0)";
                };

                document.addEventListener('mouseup', handleMouseUp);

                // Cleanup on page unload
                window.addEventListener('beforeunload', () => {
                    document.removeEventListener('mouseup', handleMouseUp);
                });
            }

            // Start wiring after DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', wireAct2HoldEvents);
            } else {
                // DOM already ready, but wait a bit for HUD to render
                setTimeout(wireAct2HoldEvents, 1000);
            }
        })();

        // Initialize HUD ready states
        setTimeout(() => {
            if (window.HUD) {
                if (typeof window.HUD.setJoystickReady === 'function') {
                    window.HUD.setJoystickReady(true);
                }
                if (typeof window.HUD.setSkillReady === 'function') {
                    window.HUD.setSkillReady('S1', true);
                    window.HUD.setSkillReady('S2', true);
                    window.HUD.setSkillReady('S3', true);
                }
            }
        }, 1000);

        // This is now handled within the character objects in gameState.characters
        /*
        gameState.player.isJumping = false;
        gameState.player.onGround = true;
        gameState.player.jumpVelocity = 0;
        gameState.player.rageMultiplier = 1.0;
        gameState.player.shieldMultiplier = 1.0;
        gameState.player.speedBoost = false;
        gameState.player.speedBoostTimer = 0;
        */

        // ═══════════════════════════════════════════════════════════════════════════
        // A1K BAG SYSTEM JAVASCRIPT - Integrated from a1 last bag/index.html
        // ═══════════════════════════════════════════════════════════════════════════

        // Initialize window.gameState if it doesn't exist
        if (!window.gameState) {
            window.gameState = {

        inventory: { items: [] },};
        }

        // Merge bag system gameState properties into existing gameState
        if (typeof window.gameState.gold === 'undefined') window.gameState.gold = 125000;
        if (typeof window.gameState.gems === 'undefined') window.gameState.gems = 450;
        if (typeof window.gameState.keys === 'undefined') window.gameState.keys = 12;
        if (typeof window.gameState.tickets === 'undefined') window.gameState.tickets = 8;
        if (typeof window.gameState.level === 'undefined') {
            // Try to get level from PlayerState if available, otherwise default to 1
            try {
                window.gameState.level = (typeof PlayerState !== 'undefined' && PlayerState.current) ? PlayerState.current.level || 1 : 1;
            } catch (e) {
                window.gameState.level = 1;
            }
        }
        if (!window.gameState.equipped) window.gameState.equipped = {
            head: null, chest: null, gloves: null, pants: null, boots: null,
            weapon: null, offhand: null, ring1: null, ring2: null, necklace: null,
            pet: null, robot: null, spirit: null, vehicle: null
        };
        if (!window.gameState.equippedSkills) window.gameState.equippedSkills = {
            A1: { S1: 'A1_S1', S2: 'A1_S2', S3: 'A1_S3' },
            MISSY: { S1: 'MISSY_S1', S2: 'MISSY_S2', S3: 'MISSY_S3' },
            UNIQUE: { S1: 'UNIQUE_S1', S2: 'UNIQUE_S2', S3: 'UNIQUE_S3' }
        };
        if (!window.gameState.inventory) window.gameState.inventory = {
            gear: [], pets: [], robots: [], spirits: [], vehicles: [], skills: [], items: []
        };
        if (!window.gameState.activeTab) window.gameState.activeTab = 'gear';
        if (!window.gameState.activeSubtab) window.gameState.activeSubtab = {};
        if (!window.gameState.skillViewMode) window.gameState.skillViewMode = 'equippable';
        if (!window.gameState.selectedCharacter) window.gameState.selectedCharacter = 'MISSY';

        // ═══════════════════════════════════════════════════════════════════════════
        // GEAR DATA - Complete manifest from A1k Bag System
        // ═══════════════════════════════════════════════════════════════════════════
        const GEAR_MANIFEST = [
            // Recruit Initiate Set
            { id: 'gear_recruit_blade', name: 'Recruit Blade', icon: '🗡️', category: 'weapon', slot: 'weapon', rarity: 'common', levelReq: 1, baseStats: { attack: 22, critRate: 0.03, critDamage: 0.15, speed: 0.02 }, price: 320, description: 'Standard issue academy blade for new adventurers.' },
            { id: 'gear_recruit_shield', name: 'Recruit Bulwark', icon: '🛡️', category: 'weapon', slot: 'offhand', rarity: 'common', levelReq: 1, baseStats: { defense: 22, hp: 110, block: 0.05 }, price: 280, description: 'Reliable wooden shield reinforced with iron plating.' },
            { id: 'gear_recruit_helm', name: 'Recruit Visor', icon: '🪖', category: 'armor', slot: 'head', rarity: 'common', levelReq: 1, baseStats: { defense: 16, hp: 60 }, price: 230, description: 'Basic metal visor that keeps trainees safe.' },
            { id: 'gear_recruit_mail', name: 'Recruit Mail', icon: '🥋', category: 'armor', slot: 'chest', rarity: 'common', levelReq: 1, baseStats: { defense: 28, hp: 140 }, price: 360, description: 'Padded mail armor issued to academy graduates.' },
            { id: 'gear_recruit_gloves', name: 'Recruit Grips', icon: '🧤', category: 'armor', slot: 'gloves', rarity: 'common', levelReq: 1, baseStats: { attack: 12, speed: 0.015 }, price: 210, description: 'Leather grips that enhance weapon control.' },
            { id: 'gear_recruit_pants', name: 'Recruit Greaves', icon: '🦿', category: 'armor', slot: 'pants', rarity: 'common', levelReq: 1, baseStats: { defense: 20, hp: 100 }, price: 260, description: 'Solid greaves perfect for frontline cadets.' },
            { id: 'gear_recruit_boots', name: 'Recruit Marchers', icon: '👢', category: 'armor', slot: 'boots', rarity: 'common', levelReq: 1, baseStats: { defense: 14, speed: 0.03 }, price: 240, description: 'Lightweight boots that keep recruits swift.' },
            { id: 'gear_recruit_ring', name: 'Recruit Signet', icon: '💍', category: 'accessory', slot: 'ring1', rarity: 'common', levelReq: 1, baseStats: { attack: 10, critRate: 0.04, critDamage: 0.1 }, price: 200, description: 'Signet ring worn by academy initiates.' },
            { id: 'gear_recruit_amulet', name: 'Recruit Pendant', icon: '📿', category: 'accessory', slot: 'necklace', rarity: 'common', levelReq: 1, baseStats: { hp: 120, mp: 40, lifesteal: 0.01 }, price: 260, description: 'Blessed pendant that restores vitality.' },
            // Vanguard Aegis Set
            { id: 'gear_vanguard_blade', name: 'Vanguard Claymore', icon: '⚔️', category: 'weapon', slot: 'weapon', rarity: 'rare', levelReq: 15, baseStats: { attack: 55, critRate: 0.05, critDamage: 0.22, armorPen: 0.05 }, price: 980, description: 'Heavy claymore favored by elite vanguard captains.' },
            { id: 'gear_vanguard_shield', name: 'Vanguard Tower Shield', icon: '🛡️', category: 'weapon', slot: 'offhand', rarity: 'rare', levelReq: 15, baseStats: { defense: 55, hp: 220, block: 0.08 }, price: 920, description: 'Tower shield that anchors the vanguard line.' },
            { id: 'gear_vanguard_helm', name: 'Vanguard Visor', icon: '🪖', category: 'armor', slot: 'head', rarity: 'rare', levelReq: 15, baseStats: { defense: 40, hp: 140, block: 0.03 }, price: 760, description: 'Articulated visor that deflects lethal blows.' },
            { id: 'gear_vanguard_mail', name: 'Vanguard Plate', icon: '🥋', category: 'armor', slot: 'chest', rarity: 'rare', levelReq: 15, baseStats: { defense: 70, hp: 260 }, price: 1150, description: 'Full plate harness forged for the vanguard order.' },
            { id: 'gear_vanguard_gloves', name: 'Vanguard Gauntlets', icon: '🧤', category: 'armor', slot: 'gloves', rarity: 'rare', levelReq: 15, baseStats: { attack: 24, speed: 0.02, armorPen: 0.02 }, price: 780, description: 'Weighted gauntlets that empower crushing blows.' },
            { id: 'gear_vanguard_pants', name: 'Vanguard Greaves', icon: '🦿', category: 'armor', slot: 'pants', rarity: 'rare', levelReq: 15, baseStats: { defense: 48, hp: 210 }, price: 820, description: 'Reinforced greaves that keep the line unbroken.' },
            { id: 'gear_vanguard_boots', name: 'Vanguard Marchers', icon: '👢', category: 'armor', slot: 'boots', rarity: 'rare', levelReq: 15, baseStats: { defense: 34, speed: 0.04 }, price: 780, description: 'Marching boots that let defenders reposition quickly.' },
            { id: 'gear_vanguard_ring', name: 'Vanguard Crest', icon: '💍', category: 'accessory', slot: 'ring1', rarity: 'rare', levelReq: 15, baseStats: { attack: 22, critRate: 0.05, critDamage: 0.18 }, price: 720, description: 'Golden crest representing the vanguard order.' },
            { id: 'gear_vanguard_amulet', name: 'Vanguard Sigil', icon: '📿', category: 'accessory', slot: 'necklace', rarity: 'rare', levelReq: 15, baseStats: { hp: 260, mp: 80, lifesteal: 0.02 }, price: 860, description: 'Radiant sigil that sustains the front line.' },
            // Mythic Ascendant Set
            { id: 'gear_mythic_blade', name: 'Mythic Dawnblade', icon: '🗡️', category: 'weapon', slot: 'weapon', rarity: 'legendary', levelReq: 30, baseStats: { attack: 110, critRate: 0.08, critDamage: 0.35, armorPen: 0.1, speed: 0.04 }, price: 2850, description: 'Blade of sunsteel that carves through reality itself.' },
            { id: 'gear_mythic_shield', name: 'Mythic Starshield', icon: '🛡️', category: 'weapon', slot: 'offhand', rarity: 'legendary', levelReq: 30, baseStats: { defense: 105, hp: 420, block: 0.12, elementalResist: 0.08 }, price: 2680, description: 'Celestial shield that bends starlight into barriers.' },
            { id: 'gear_mythic_helm', name: 'Mythic Halo', icon: '🪖', category: 'armor', slot: 'head', rarity: 'legendary', levelReq: 30, baseStats: { defense: 70, hp: 240, critRate: 0.04, elementalResist: 0.06 }, price: 2240, description: 'Grants the wearer a radiant halo of protection.' },
            { id: 'gear_mythic_mail', name: 'Mythic Radiant Plate', icon: '🥋', category: 'armor', slot: 'chest', rarity: 'legendary', levelReq: 30, baseStats: { defense: 120, hp: 480, elementalResist: 0.1 }, price: 3100, description: 'Armor that radiates pure sunlight to repel darkness.' },
            { id: 'gear_mythic_gloves', name: 'Mythic Dawnclaws', icon: '🧤', category: 'armor', slot: 'gloves', rarity: 'legendary', levelReq: 30, baseStats: { attack: 48, speed: 0.05, lifesteal: 0.03 }, price: 2380, description: 'Sunlit claws that tear through shadow and refill life.' },
            { id: 'gear_mythic_pants', name: 'Mythic Legplates', icon: '🦿', category: 'armor', slot: 'pants', rarity: 'legendary', levelReq: 30, baseStats: { defense: 90, hp: 360, speed: 0.04 }, price: 2460, description: 'Swift greaves that leave trails of shimmering light.' },
            { id: 'gear_mythic_boots', name: 'Mythic Zephyr Boots', icon: '👢', category: 'armor', slot: 'boots', rarity: 'legendary', levelReq: 30, baseStats: { defense: 60, speed: 0.07, evade: 0.04 }, price: 2320, description: 'Boots that glide across battlefields with astral wind.' },
            { id: 'gear_mythic_ring', name: 'Mythic Solar Band', icon: '💍', category: 'accessory', slot: 'ring1', rarity: 'legendary', levelReq: 30, baseStats: { attack: 40, critRate: 0.07, critDamage: 0.28, armorPen: 0.06 }, price: 2200, description: 'Ring forged from a captured solar flare.' },
            { id: 'gear_mythic_amulet', name: 'Mythic Heart', icon: '📿', category: 'accessory', slot: 'necklace', rarity: 'legendary', levelReq: 30, baseStats: { hp: 520, mp: 160, lifesteal: 0.04, cooldownReduction: 0.04 }, price: 2550, description: 'Heart of a sun-leviathan crystallized into an amulet.' }
        ];

        // ═══════════════════════════════════════════════════════════════════════════
        // DROP SYSTEM: RESOURCE DATABASE & LOOT TABLES
        // ═══════════════════════════════════════════════════════════════════════════
        const RESOURCE_DB = {
            // T1 - Common
            'res_scrap': { name: 'Scrap Metal', icon: '🔩', rarity: 'common', desc: 'Rusted metal bits from the old city.' },
            'res_wood':  { name: 'Synth-Wood', icon: '🪵', rarity: 'common', desc: 'Bio-engineered wood, tough but burnable.' },
            'res_stone': { name: 'Concrete Chunk', icon: '🪨', rarity: 'common', desc: 'Debris from the fallen skyline.' },
            // T2 - Uncommon
            'res_circuit': { name: 'Fried Circuit', icon: '📟', rarity: 'uncommon', desc: 'Salvaged electronics.' },
            'res_breach':  { name: 'Breach Dust', icon: '✨', rarity: 'uncommon', desc: 'Glowing residue from dimension rifts.' },
            // T3 - Rare
            'res_gold_bar': { name: 'Refined Gold', icon: '🧈', rarity: 'rare', desc: 'Pure currency standard.' },
        };

        const LOOT_TABLES = {
            'tree': {
                gold: [1000, 10000],
                items: [{ id: 'res_wood', chance: 1.0, min: 1, max: 3 }]
            },
            'rock': {
                gold: [1000, 10000],
                items: [
                    { id: 'res_stone', chance: 1.0, min: 1, max: 3 },
                    { id: 'res_scrap', chance: 0.3, min: 1, max: 1 } // 30% chance for scrap
                ]
            },
            'crate': {
                gold: [500, 1500],
                items: [
                    { id: 'res_scrap', chance: 1.0, min: 2, max: 5 },
                    { id: 'res_circuit', chance: 0.5, min: 1, max: 2 }
                ]
            },
            'airdrop': {
                gold: [5000, 20000],
                items: [
                    { id: 'res_gold_bar', chance: 1.0, min: 1, max: 3 },
                    { id: 'res_circuit', chance: 1.0, min: 5, max: 10 },
                    { id: 'shop_chest_gold', chance: 0.5, min: 1, max: 1 } // 50% chance for a chest
                ]
            }
        };

        // ═══════════════════════════════════════════════════════════════════════════
        // COMPANION DATA
        // ═══════════════════════════════════════════════════════════════════════════
        const PETS_DATA = [
            { id: 'pet_fire_pup', name: 'Fire Pup', icon: '🐕', rarity: 'common', level: 5, stats: { attack: 15, hp: 100 }, description: 'A loyal fire-elemental companion.' },
            { id: 'pet_ice_wolf', name: 'Ice Wolf', icon: '🐺', rarity: 'rare', level: 10, stats: { attack: 35, hp: 200 }, description: 'A swift ice-elemental companion.' },
            { id: 'pet_flame_dragon', name: 'Flame Dragon', icon: '🐉', rarity: 'epic', level: 15, stats: { attack: 65, hp: 350 }, description: 'A powerful fire-breathing companion.' },
            { id: 'pet_thunder_hawk', name: 'Thunder Hawk', icon: '🦅', rarity: 'uncommon', level: 8, stats: { attack: 25, hp: 150 }, description: 'A lightning-fast aerial companion.' },
            { id: 'pet_earth_golem', name: 'Earth Golem', icon: '🗿', rarity: 'rare', level: 12, stats: { defense: 50, hp: 400 }, description: 'A sturdy earth-elemental guardian.' }
        ];

        const ROBOTS_DATA = [
            { id: 'robot_trainee_bot', name: 'Trainee Bot', icon: '🤖', rarity: 'common', level: 3, stats: { attack: 10, defense: 15 }, description: 'Basic combat robot for beginners.' },
            { id: 'robot_combat_mk2', name: 'Combat Bot MK2', icon: '🤖', rarity: 'rare', level: 12, stats: { attack: 45, defense: 30 }, description: 'Advanced combat robot with enhanced AI.' },
            { id: 'robot_healer_v1', name: 'Healer Bot V1', icon: '⚕️', rarity: 'uncommon', level: 9, stats: { defense: 20, hp: 250 }, description: 'Medical support robot for healing.' },
            { id: 'robot_scout_x3', name: 'Scout Bot X3', icon: '🔍', rarity: 'common', level: 6, stats: { speed: 40, attack: 18 }, description: 'Reconnaissance robot for scouting.' },
            { id: 'robot_tank_omega', name: 'Tank Omega', icon: '🛡️', rarity: 'epic', level: 18, stats: { defense: 80, hp: 500 }, description: 'Heavy-duty tank robot for defense.' }
        ];

        const SPIRITS_DATA = [
            { id: 'spirit_fire_spark', name: 'Fire Spark', icon: '🔥', rarity: 'common', level: 5, stats: { attack: 20, critRate: 0.05 }, description: 'A small but fierce fire spirit.' },
            { id: 'spirit_ancient_wisdom', name: 'Ancient Wisdom', icon: '✨', rarity: 'legendary', level: 20, stats: { mp: 200, cooldownReduction: 0.1 }, description: 'Ancient spirit of knowledge and power.' },
            { id: 'spirit_nature_guardian', name: 'Nature Guardian', icon: '🌿', rarity: 'epic', level: 14, stats: { hp: 300, defense: 40 }, description: 'Protector of nature and life.' },
            { id: 'spirit_shadow_whisper', name: 'Shadow Whisper', icon: '🌑', rarity: 'rare', level: 11, stats: { attack: 50, critDamage: 0.2 }, description: 'Mysterious shadow spirit of darkness.' },
            { id: 'spirit_light_radiant', name: 'Light Radiant', icon: '☀️', rarity: 'epic', level: 16, stats: { attack: 60, defense: 35, hp: 250 }, description: 'Radiant light spirit of purity.' }
        ];

        const VEHICLES_DATA = [
            { id: 'veh_speedster', name: 'Speedster', icon: '🚗', rarity: 'uncommon', level: 8, stats: { speed: 50, attack: 20 }, description: 'Fast ground vehicle for quick travel.' },
            { id: 'veh_sky_glider', name: 'Sky Glider', icon: '✈️', rarity: 'rare', level: 12, stats: { speed: 80, defense: 25 }, description: 'Aerial transport for sky exploration.' },
            { id: 'veh_tank_heavy', name: 'Heavy Tank', icon: '🚛', rarity: 'epic', level: 15, stats: { defense: 70, hp: 400, attack: 45 }, description: 'Armored vehicle for heavy combat.' },
            { id: 'veh_hover_bike', name: 'Hover Bike', icon: '🏍️', rarity: 'rare', level: 10, stats: { speed: 65, attack: 30 }, description: 'Futuristic hover bike for speed.' },
            { id: 'veh_mech_walker', name: 'Mech Walker', icon: '🤖', rarity: 'epic', level: 18, stats: { defense: 90, hp: 500, attack: 60 }, description: 'Massive mech walker for battle.' }
        ];

        // ═══════════════════════════════════════════════════════════════════════════
        // TALENTS & POWERS DATA
        // ═══════════════════════════════════════════════════════════════════════════
        const TALENTS_DATA = [
            { id: 'talent_quick_reflexes', name: 'Quick Reflexes', icon: '⚡', tier: 1, unlocked: true, description: 'Increases attack speed by 10%.' },
            { id: 'talent_iron_will', name: 'Iron Will', icon: '🛡️', tier: 1, unlocked: false, description: 'Increases defense by 15%.' },
            { id: 'talent_critical_strike', name: 'Critical Strike', icon: '🎯', tier: 2, unlocked: false, description: 'Increases crit rate by 5%.' },
            { id: 'talent_vitality', name: 'Vitality', icon: '❤️', tier: 1, unlocked: false, description: 'Increases max HP by 20%.' },
            { id: 'talent_arcane_mastery', name: 'Arcane Mastery', icon: '🔮', tier: 3, unlocked: false, description: 'Increases all elemental damage by 25%.' }
        ];

        const POWERS_DATA = [
            { id: 'power_flame_touch', name: 'Flame Touch', icon: '🔥', category: 'elemental', rarity: 'common', cooldown: 8000, description: 'Imbue your attacks with fire, dealing bonus burn damage.' },
            { id: 'power_frost_shield', name: 'Frost Shield', icon: '❄️', category: 'elemental', rarity: 'common', cooldown: 10000, description: 'Summon a protective ice barrier that reduces incoming damage.' },
            { id: 'power_wind_step', name: 'Wind Step', icon: '💨', category: 'elemental', rarity: 'uncommon', cooldown: 6000, description: 'Become as swift as the wind, increasing movement and evasion.' },
            { id: 'power_earth_blessing', name: 'Earth Blessing', icon: '🌿', category: 'elemental', rarity: 'common', cooldown: 12000, description: 'Channel earth\'s vitality for permanent HP boost and regeneration.' },
            { id: 'power_lightning_storm', name: 'Lightning Storm', icon: '⚡', category: 'elemental', rarity: 'rare', cooldown: 15000, description: 'Call down a devastating lightning storm on enemies.' },
            { id: 'power_void_embrace', name: 'Void Embrace', icon: '🌑', category: 'cosmic', rarity: 'epic', cooldown: 20000, description: 'Embrace the void to become temporarily invulnerable.' }
        ];

        // ═══════════════════════════════════════════════════════════════════════════
        // OLD SKILLS DATA REMOVED - Now using Phase 1.1 skill arrays above
        // Skills are managed via SkillLibrary (window.skillLibrary)
        // ═══════════════════════════════════════════════════════════════════════════

        // ═══════════════════════════════════════════════════════════════════════════
        // JOURNAL DATA
        // ═══════════════════════════════════════════════════════════════════════════
        const MISSIONS_DATA = [
            { id: 'mission_001', name: 'First Steps', status: 'active', description: 'Open the bag and inspect your gear.', progress: 50, rewards: { gold: 100, xp: 50 } },
            { id: 'mission_002', name: 'Gear Up', status: 'available', description: 'Equip at least 3 pieces of gear.', progress: 0, rewards: { gold: 200, xp: 100 } },
            { id: 'mission_003', name: 'Companion Bond', status: 'available', description: 'Equip your first companion.', progress: 0, rewards: { gold: 150, xp: 75 } },
            { id: 'mission_004', name: 'Dungeon Crawler', status: 'completed', description: 'Complete your first dungeon.', progress: 100, rewards: { gold: 500, xp: 250 } }
        ];

        const BESTIARY_DATA = [
            { id: 'enemy_goblin', name: 'Goblin', icon: '👹', level: 5, hp: 100, attack: 15, defense: 5, defeated: 12, description: 'Small but aggressive creature.' },
            { id: 'enemy_orc', name: 'Orc Warrior', icon: '👺', level: 15, hp: 300, attack: 45, defense: 20, defeated: 5, description: 'Brutal warrior with high attack.' },
            { id: 'enemy_dragon', name: 'Fire Dragon', icon: '🐉', level: 30, hp: 1000, attack: 120, defense: 60, defeated: 1, description: 'Legendary fire-breathing dragon.' },
            { id: 'enemy_skeleton', name: 'Skeleton Warrior', icon: '💀', level: 10, hp: 150, attack: 25, defense: 10, defeated: 8, description: 'Undead warrior risen from the grave.' }
        ];

        const DROPS_DATA = [
            { id: 'drop_common', name: 'Common Loot', icon: '📦', rarity: 'common', chance: 60, items: ['Gold x50', 'Health Potion'] },
            { id: 'drop_uncommon', name: 'Uncommon Loot', icon: '📦', rarity: 'uncommon', chance: 25, items: ['Gold x150', 'Mana Potion', 'Common Gear'] },
            { id: 'drop_rare', name: 'Rare Loot', icon: '📦', rarity: 'rare', chance: 10, items: ['Gold x500', 'Rare Gear', 'Skill Scroll'] },
            { id: 'drop_epic', name: 'Epic Loot', icon: '📦', rarity: 'epic', chance: 4, items: ['Gold x1500', 'Epic Gear', 'Rare Material'] },
            { id: 'drop_legendary', name: 'Legendary Loot', icon: '📦', rarity: 'legendary', chance: 1, items: ['Gold x5000', 'Legendary Gear', 'Mythic Material'] }
        ];

        // ═══════════════════════════════════════════════════════════════════════════
        // TAB DEFINITIONS
        // ═══════════════════════════════════════════════════════════════════════════
        const TAB_DEFINITIONS = [
            { id: 'gear', label: 'Gear & Items', icon: '⚔️', isHub: true, order: 1 },
            { id: 'companions', label: 'Companions', icon: '👥', isHub: true, order: 2 },
            { id: 'abilities', label: 'Abilities', icon: '⭐', isHub: true, order: 3 },
            { id: 'journal', label: 'Journal', icon: '📖', isHub: true, order: 4 },
            { id: 'alchemy', label: 'Alchemy', icon: '⚗️', isHub: false, order: 5 },
            { id: 'shop', label: 'Shop', icon: '🏪', isHub: false, order: 6 },
            { id: 'settings', label: 'Settings', icon: '⚙️', isHub: true, order: 7 }
        ];

        // Merge bag system gameState properties into existing gameState
        if (!window.gameState.gold) window.gameState.gold = 125000;
        if (!window.gameState.gems) window.gameState.gems = 450;
        if (!window.gameState.keys) window.gameState.keys = 12;
        if (!window.gameState.tickets) window.gameState.tickets = 8;
        if (!window.gameState.inventory) window.gameState.inventory = {};
        if (!window.gameState.inventory.gear) window.gameState.inventory.gear = [];
        if (!window.gameState.inventory.items) window.gameState.inventory.items = [];
        if (!window.gameState.equipped) window.gameState.equipped = {
            head: null, chest: null, gloves: null, pants: null, boots: null,
            weapon: null, offhand: null, ring1: null, ring2: null, necklace: null,
            pet: null, robot: null, spirit: null, vehicle: null
        };
        if (!window.gameState.equippedSkills) window.gameState.equippedSkills = {};
        if (!window.gameState.selectedCharacter) window.gameState.selectedCharacter = 'MISSY';
        if (!window.gameState.skillViewMode) window.gameState.skillViewMode = 'equippable';

        // ═══════════════════════════════════════════════════════════════════════════
        // VEHICLE SYSTEM - Transferred from A1K-Runner-Standalone
        // ═══════════════════════════════════════════════════════════════════════════
        const VehicleSystem = {
            isMounted: false,
            currentVehicleId: null,
            vehicleMesh: null,
            baseSpeedMultiplier: 1.0,

            // Create a procedural Hover Bike mesh (Replacement for external assets)
            createVehicleMesh() {
                const group = new THREE.Group();

                // Main Body
                const bodyGeo = new THREE.BoxGeometry(1, 0.5, 3);
                const bodyMat = new THREE.MeshStandardMaterial({ color: 0xff0000, metalness: 0.8, roughness: 0.2 });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.y = 0.5;
                group.add(body);

                // Engine/Thrusters
                const thrusterGeo = new THREE.CylinderGeometry(0.2, 0.4, 1, 16);
                const thrusterMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
                
                const t1 = new THREE.Mesh(thrusterGeo, thrusterMat);
                t1.rotation.x = Math.PI / 2;
                t1.position.set(0.6, 0.5, 1.5);
                group.add(t1);

                const t2 = t1.clone();
                t2.position.set(-0.6, 0.5, 1.5);
                group.add(t2);

                // Hover Glow
                const glowGeo = new THREE.PlaneGeometry(2, 4);
                const glowMat = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.3, side: THREE.DoubleSide });
                const glow = new THREE.Mesh(glowGeo, glowMat);
                glow.rotation.x = Math.PI / 2;
                glow.position.y = 0.1;
                group.add(glow);

                return group;
            },

            mount(vehicleId) {
                if (this.isMounted) return;
                
                const player = gameState.activeCharacter?.mesh;
                if (!player) return;

                // 1. Instantiate Vehicle Mesh
                this.vehicleMesh = this.createVehicleMesh();
                this.currentVehicleId = vehicleId;

                // 2. Attach Player to Vehicle (Visuals)
                // Move player up slightly to "sit"
                player.position.y += 1.0; 
                this.vehicleMesh.position.set(0, -1.0, 0); // Offset vehicle below player
                player.add(this.vehicleMesh); // Parent vehicle to player so it moves with them

                // 3. Apply Stats (Speed Boost)
                // Fetch stats from VEHICLES_DATA defined in Bag System
                const vehicleData = VEHICLES_DATA.find(v => v.id === vehicleId);
                const speedStat = vehicleData ? vehicleData.stats.speed : 50;
                
                // Convert stat to multiplier (e.g., 50 speed = 1.5x, 100 speed = 2.0x)
                this.baseSpeedMultiplier = 1 + (speedStat / 100);
                
                // Apply to player state
                if (!gameState.activeCharacter.speedMultiplier) {
                    gameState.activeCharacter.speedMultiplier = 1.0;
                }
                gameState.activeCharacter.speedMultiplier = this.baseSpeedMultiplier;
                gameState.activeCharacter.isMounted = true; // Flag for animation system
                this.isMounted = true;
                
                // Toast notification
                if(window.BagSystem) window.BagSystem.showToast(`Mounted ${vehicleData ? vehicleData.name : 'Vehicle'}! Speed x${this.baseSpeedMultiplier.toFixed(1)}`);
                console.log(`[VehicleSystem] Mounted ${vehicleId}. Speed increased.`);
            },

            dismount() {
                if (!this.isMounted) return;
                const player = gameState.activeCharacter?.mesh;
                if (player && this.vehicleMesh) {
                    player.remove(this.vehicleMesh);
                    // Optional: Dispose geometry/material to prevent leaks
                    this.vehicleMesh = null;
                }

                // Reset Player Stats
                if (gameState.activeCharacter) {
                    gameState.activeCharacter.speedMultiplier = 1.0;
                    gameState.activeCharacter.isMounted = false;
                }
                this.currentVehicleId = null;
                this.isMounted = false;
                if(window.BagSystem) window.BagSystem.showToast("Dismounted.");
            }
        };

        // ═══════════════════════════════════════════════════════════════════════════
        // BAG SYSTEM - Complete Implementation
        // ═══════════════════════════════════════════════════════════════════════════
        const BagSystem = {
            isOpen: false,
            activeTab: 'gear',
            activeSubtab: {},

            init() {
                this.renderTabs();
                this.renderCurrencies();
                this.attachEventListeners();
                console.log('[BagSystem] Initialized with complete hub architecture - All items merged!');
            },

            renderTabs() {
                const tabsStrip = document.getElementById('bagTabsStrip');
                if (!tabsStrip) return;
                tabsStrip.innerHTML = TAB_DEFINITIONS.map(tab => `
                    <button class="bag-tab ${tab.id === this.activeTab ? 'active' : ''}" 
                            data-tab="${tab.id}">
                        <span class="tab-icon">${tab.icon}</span>
                        <span class="tab-label">${tab.label}</span>
                    </button>
                `).join('');

                tabsStrip.querySelectorAll('.bag-tab').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const tabId = btn.dataset.tab;
                        this.switchTab(tabId);
                    });
                });
            },

            switchTab(tabId) {
                this.activeTab = tabId;
                const tab = TAB_DEFINITIONS.find(t => t.id === tabId);

                // Hide all sub-tabs
                document.querySelectorAll('.hub-subtabs').forEach(st => st.classList.remove('active'));

                // Show sub-tabs if this is a hub
                if (tab && tab.isHub) {
                    const subtabsId = `${tabId}Subtabs`;
                    const subtabsEl = document.getElementById(subtabsId);
                    if (subtabsEl) {
                        subtabsEl.classList.add('active');
                        // Initialize first subtab if not set
                        if (!this.activeSubtab[tabId]) {
                            const firstSubtab = subtabsEl.querySelector('.hub-subtab');
                            if (firstSubtab) {
                                this.activeSubtab[tabId] = firstSubtab.dataset.subtab;
                            }
                        }
                    }
                }

                this.renderTabs();
                this.renderTab(tabId);
            },

            switchSubtab(hubId, subtabId) {
                this.activeSubtab[hubId] = subtabId;

                // Update sub-tab buttons
                const subtabsEl = document.getElementById(`${hubId}Subtabs`);
                if (subtabsEl) {
                    subtabsEl.querySelectorAll('.hub-subtab').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.subtab === subtabId);
                    });
                }

                this.renderTab(hubId);
            },

            renderTab(tabId) {
                const pane = document.getElementById('bagContentPane');
                if (!pane) return;

                switch (tabId) {
                    case 'gear':
                        this.renderGearHub();
                        break;
                    case 'companions':
                        pane.innerHTML = this.renderCompanionsHub();
                        break;
                    case 'abilities':
                        pane.innerHTML = this.renderAbilitiesHub();
                        break;
                    case 'journal':
                        pane.innerHTML = this.renderJournalHub();
                        break;
                    case 'alchemy':
                        pane.innerHTML = this.renderAlchemyTab();
                        break;
                    case 'shop':
                        pane.innerHTML = this.renderShopTab();
                        break;
                    case 'settings':
                        pane.innerHTML = this.renderSettingsHub();
                        break;
                    default:
                        pane.innerHTML = '<div class="empty-state"><div class="empty-state-icon">❓</div><div class="empty-state-text">Tab not implemented</div></div>';
                }
            },

            // ═══ GEAR & ITEMS HUB ═══
            renderGearHub() {
                const pane = document.getElementById('bagContentPane');
                if (!pane) return;

                const subtab = this.activeSubtab['gear'] || 'gear';

                switch (subtab) {
                    case 'gear':
                        pane.innerHTML = this.renderGearTab();
                        break;
                    case 'items':
                        pane.innerHTML = this.renderItemsTab();
                        break;
                    default:
                        pane.innerHTML = this.renderGearTab();
                }
            },

            // ═══ GEAR TAB ═══
            renderGearTab() {
                const equipped = window.gameState.equipped;
                const inventory = window.gameState.inventory.gear || [];
                const slots = ['head', 'chest', 'gloves', 'pants', 'boots', 'weapon', 'offhand', 'ring1', 'ring2', 'necklace'];

                return `
                    <div>
                        <h2 style="margin-bottom: 20px; color: var(--a1k-gold);">⚔️ Equipment</h2>
                        <div class="gear-slots-container">
                            ${slots.map(slot => {
                    const item = equipped[slot];
                    return `
                            <div class="gear-slot ${item ? 'equipped' : ''}">
                                <div class="gear-slot-label">${slot.charAt(0).toUpperCase() + slot.slice(1)}</div>
                                ${item ? `
                                    <div class="gear-slot-item">${item.icon}</div>
                                    <div class="gear-slot-name">${item.name}</div>
                                ` : '<div style="color: var(--text-secondary); font-size: 12px;">Empty</div>'}
                            </div>
                        `;
                }).join('')}
                        </div>
                        <h3 style="margin: 24px 0 16px; color: var(--a1k-gold);">📦 Inventory Gear (${inventory.length} items)</h3>
                        <div class="cards-grid">
                            ${inventory.length === 0 ? '<div class="empty-state"><div class="empty-state-icon">📦</div><div class="empty-state-text">No gear in inventory</div></div>' : inventory.map(gear => `
                                <div class="item-card" data-rarity="${gear.rarity}">
                                    <div class="item-icon">${gear.icon}</div>
                                    <div class="item-name">${gear.name}</div>
                                    <div class="item-rarity" data-rarity="${gear.rarity}">${gear.rarity}</div>
                                    <div class="item-description">${gear.description}</div>
                                    <div class="item-stats">
                                        ${Object.entries(gear.baseStats || {}).map(([key, value]) => `
                                            <div class="stat-row">
                                                <span class="stat-label">${key}:</span>
                                                <span class="stat-value">${typeof value === 'number' && value < 1 ? (value * 100).toFixed(1) + '%' : value}</span>
                                            </div>
                                        `).join('')}
                                    </div>
                                    <button class="item-action-btn" onclick="BagSystem.equipGear('${gear.slot}', '${gear.id}')">Equip</button>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            },

            equipGear(slot, gearId) {
                const gear = GEAR_MANIFEST.find(g => g.id === gearId);
                if (gear) {
                    window.gameState.equipped[slot] = gear;
                    this.renderTab('gear');
                    this.showToast(`Equipped ${gear.name}!`);
                }
            },

            // ═══ COMPANIONS HUB ═══
            renderCompanionsHub() {
                const subtab = this.activeSubtab['companions'] || 'overview';

                switch (subtab) {
                    case 'overview':
                        return this.renderCompanionsOverview();
                    case 'pets':
                        return this.renderCompanionsList(PETS_DATA, 'Pets', 'pet');
                    case 'robots':
                        return this.renderCompanionsList(ROBOTS_DATA, 'Robots', 'robot');
                    case 'spirits':
                        return this.renderCompanionsList(SPIRITS_DATA, 'Spirits', 'spirit');
                    case 'vehicles':
                        return this.renderCompanionsList(VEHICLES_DATA, 'Vehicles', 'vehicle');
                    default:
                        return this.renderCompanionsOverview();
                }
            },

            renderCompanionsOverview() {
                const equipped = window.gameState.equipped;
                const companions = [
                    { slot: 'pet', ...equipped.pet },
                    { slot: 'robot', ...equipped.robot },
                    { slot: 'spirit', ...equipped.spirit },
                    { slot: 'vehicle', ...equipped.vehicle }
                ].filter(c => c.id);

                if (companions.length === 0) {
                    return `
                        <div class="empty-state">
                            <div class="empty-state-icon">👥</div>
                            <div class="empty-state-text">No Companions Equipped</div>
                            <div class="empty-state-subtext">Equip companions from their respective tabs</div>
                        </div>
                    `;
                }

                return `
                    <div>
                        <h2 style="margin-bottom: 20px; color: var(--a1k-gold);">👥 Companions Overview</h2>
                        <div class="companions-overview">
                            ${companions.map(comp => `
                                <div class="companion-card">
                                    <div class="companion-header">
                                        <div class="companion-icon">${comp.icon}</div>
                                        <div class="companion-info">
                                            <h3>${comp.name}</h3>
                                            <p>${comp.type || comp.slot} • Level ${comp.level || 1}</p>
                                        </div>
                                    </div>
                                    <div class="companion-stats">
                                        <div class="stat-row">
                                            <span class="stat-label">Rarity:</span>
                                            <span class="stat-value">${comp.rarity}</span>
                                        </div>
                                        ${comp.stats ? Object.entries(comp.stats).map(([key, value]) => `
                                            <div class="stat-row">
                                                <span class="stat-label">${key}:</span>
                                                <span class="stat-value">${value}</span>
                                            </div>
                                        `).join('') : ''}
                                    </div>
                                    
                                    ${comp.slot === 'vehicle' || comp.type === 'vehicle' ? `
                                        <button class="item-action-btn" 
                                            style="margin-top: 10px; background: ${VehicleSystem.isMounted ? '#ff4444' : 'var(--a1k-green)'}"
                                            onclick="${VehicleSystem.isMounted ? 'VehicleSystem.dismount()' : `VehicleSystem.mount('${comp.id}')`}">
                                            ${VehicleSystem.isMounted ? '🛑 Dismount' : '🚀 Ride Vehicle'}
                                        </button>
                                    ` : ''}
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            },

            renderCompanionsList(data, title, type) {
                return `
                    <div>
                        <h2 style="margin-bottom: 20px; color: var(--a1k-gold);">${title} (${data.length} available)</h2>
                        <div class="cards-grid">
                            ${data.map(item => `
                                <div class="item-card" data-rarity="${item.rarity}">
                                    <div class="item-icon">${item.icon}</div>
                                    <div class="item-name">${item.name}</div>
                                    <div class="item-rarity" data-rarity="${item.rarity}">${item.rarity}</div>
                                    <div class="item-description">${item.description}</div>
                                    <div class="item-stats">
                                        ${item.stats ? Object.entries(item.stats).map(([key, value]) => `
                                            <div class="stat-row">
                                                <span class="stat-label">${key}:</span>
                                                <span class="stat-value">${value}</span>
                                            </div>
                                        `).join('') : ''}
                                        <div class="stat-row">
                                            <span class="stat-label">Level:</span>
                                            <span class="stat-value">${item.level || 1}</span>
                                        </div>
                                    </div>
                                    <button class="item-action-btn" onclick="BagSystem.equipCompanion('${type}', '${item.id}')">Equip</button>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            },

            equipCompanion(type, id) {
                const dataMap = {
                    pet: PETS_DATA,
                    robot: ROBOTS_DATA,
                    spirit: SPIRITS_DATA,
                    vehicle: VEHICLES_DATA
                };
                const data = dataMap[type]?.find(c => c.id === id);
                if (data) {
                    window.gameState.equipped[type] = { ...data, type };
                    this.renderTab('companions');
                    this.showToast(`Equipped ${data.name}!`);
                }
            },

            // ═══ ABILITIES HUB ═══
            renderAbilitiesHub() {
                const subtab = this.activeSubtab['abilities'] || 'talents';

                switch (subtab) {
                    case 'talents':
                        return this.renderTalentsTab();
                    case 'powers':
                        return this.renderPowersTab();
                    case 'skills':
                        return this.renderSkillsTab();
                    default:
                        return this.renderSkillsTab(); // Changed from renderTalentsTab() - Skills is now default
                }
            },

            renderTalentsTab() {
                return `
                    <div>
                        <h2 style="margin-bottom: 20px; color: var(--a1k-gold);">⭐ Talent Tree</h2>
                        <div class="cards-grid">
                            ${TALENTS_DATA.map(talent => `
                                <div class="item-card ${talent.unlocked ? '' : 'opacity-50'}" data-rarity="${talent.tier === 1 ? 'common' : talent.tier === 2 ? 'rare' : 'epic'}">
                                    <div class="item-icon">${talent.icon}</div>
                                    <div class="item-name">${talent.name}</div>
                                    <div class="item-rarity" data-rarity="${talent.tier === 1 ? 'common' : talent.tier === 2 ? 'rare' : 'epic'}">Tier ${talent.tier}</div>
                                    <div class="item-description">${talent.description}</div>
                                    <button class="item-action-btn" ${talent.unlocked ? 'disabled' : ''} onclick="BagSystem.unlockTalent('${talent.id}')">
                                        ${talent.unlocked ? 'Unlocked' : 'Unlock'}
                                    </button>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            },

            renderPowersTab() {
                return `
                    <div>
                        <h2 style="margin-bottom: 20px; color: var(--a1k-gold);">🔮 Supernatural Powers</h2>
                        <div class="cards-grid">
                            ${POWERS_DATA.map(power => `
                                <div class="item-card" data-rarity="${power.rarity}">
                                    <div class="item-icon">${power.icon}</div>
                                    <div class="item-name">${power.name}</div>
                                    <div class="item-rarity" data-rarity="${power.rarity}">${power.rarity}</div>
                                    <div class="item-description">${power.description}</div>
                                    <div class="item-stats">
                                        <div class="stat-row">
                                            <span class="stat-label">Category:</span>
                                            <span class="stat-value">${power.category}</span>
                                        </div>
                                        <div class="stat-row">
                                            <span class="stat-label">Cooldown:</span>
                                            <span class="stat-value">${(power.cooldown / 1000).toFixed(1)}s</span>
                                        </div>
                                    </div>
                                    <button class="item-action-btn" onclick="BagSystem.equipPower('${power.id}')">Equip</button>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            },

            unlockTalent(id) {
                const talent = TALENTS_DATA.find(t => t.id === id);
                if (talent && !talent.unlocked) {
                    talent.unlocked = true;
                    this.renderTab('abilities');
                    this.showToast(`Unlocked ${talent.name}!`);
                }
            },

            equipPower(id) {
                const power = POWERS_DATA.find(p => p.id === id);
                if (power) {
                    this.showToast(`Equipped ${power.name}!`);
                }
            },

            // ═══ SKILLS TAB ═══
            renderSkillsTab() {
                const selectedCharacter = window.gameState.selectedCharacter || 'MISSY';
                const viewMode = window.gameState.skillViewMode || 'equippable';

                // Phase 1.5: Use SkillLibrary instead of direct arrays
                const skillLib = window.skillLibrary || skillLibrary;
                const progManager = window.progressionManager || progressionManager;

                // Get all skills for character (unlocked + locked for preview)
                const allCharSkills = skillLib ? skillLib.getAllSkills(selectedCharacter) : [];
                const unlockedSkills = skillLib ? skillLib.getUnlockedSkills(selectedCharacter) : [];
                const lockedSkills = skillLib ? skillLib.getLockedSkills(selectedCharacter) : [];

                // Get equipped skills from SkillLibrary
                const charEquipped = skillLib ? skillLib.equipped[selectedCharacter] || {} : {};

                // Determine display skills based on view mode
                let displaySkills = [];
                if (viewMode === 'equippable') {
                    // Show S1-S3 skills, but also include S4/S5/X as equippable to S1-S3
                    displaySkills = allCharSkills.filter(skill =>
                        (skill.slot >= 1 && skill.slot <= 3) ||
                        (skill.slot === 4 || skill.slot === 5 || skill.slot === 'X' || skill.slot === 'X2')
                    );
                } else {
                    // Show all skills (library view)
                    displaySkills = allCharSkills;
                }

                // Mark skills as unlocked
                displaySkills = displaySkills.map(skill => {
                    const isUnlocked = unlockedSkills.find(s => s.id === skill.id) !== undefined;
                    return { ...skill, unlocked: isUnlocked };
                });

                return `
                    <div>
                        <h2 style="margin-bottom: 16px; color: var(--a1k-gold); font-size: 22px;">🔰 Skills</h2>
                        <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 20px; justify-content: center; align-items: center;">
                            <div style="display: flex; gap: 6px;">
                                <button class="hub-subtab ${selectedCharacter === 'MISSY' ? 'active' : ''}" 
                                        onclick="BagSystem.selectCharacter('MISSY')"
                                        style="padding: 8px 14px; font-size: 13px;">
                                    🐱 MISSY
                                </button>
                                <button class="hub-subtab ${selectedCharacter === 'A1' ? 'active' : ''}" 
                                        onclick="BagSystem.selectCharacter('A1')"
                                        style="padding: 8px 14px; font-size: 13px;">
                                    ⚔️ A1
                                </button>
                                <button class="hub-subtab ${selectedCharacter === 'UNIQUE' ? 'active' : ''}" 
                                        onclick="BagSystem.selectCharacter('UNIQUE')"
                                        style="padding: 8px 14px; font-size: 13px;">
                                    🤖 UNIQUE
                                </button>
                            </div>
                            <div style="display: flex; gap: 6px; margin-left: 12px;">
                                <button class="hub-subtab ${viewMode === 'equippable' ? 'active' : ''}" 
                                        onclick="BagSystem.setSkillViewMode('equippable')"
                                        style="padding: 8px 14px; font-size: 13px;">
                                    ⚔️ Equippable (S1-S3)
                                </button>
                                <button class="hub-subtab ${viewMode === 'library' ? 'active' : ''}" 
                                        onclick="BagSystem.setSkillViewMode('library')"
                                        style="padding: 8px 14px; font-size: 13px;">
                                    📚 Full Library
                                </button>
                            </div>
                        </div>
                        <div style="margin-bottom: 24px; padding: 16px; background: var(--bg-secondary); border-radius: 12px; border: 2px solid var(--border-default);">
                            <h3 style="margin-bottom: 12px; color: var(--a1k-gold); text-align: center; font-size: 16px;">
                                ${selectedCharacter} Equipped Skills
                            </h3>
                            <div class="skill-row" style="justify-content: center;">
                                ${[1, 2, 3].map(slotNum => {
                    const slotKey = `S${slotNum}`;
                    const equippedSkill = skillLib ? skillLib.getEquippedSkill(selectedCharacter, slotKey) : null;

                    return `
                                    <button class="skill-pill s${slotNum} ${equippedSkill ? 'equipped' : ''}" 
                                            onclick="BagSystem.openSkillSelector('${selectedCharacter}', ${slotNum})"
                                            title="${equippedSkill ? equippedSkill.name : `Click to equip ${slotKey}`}">
                                        ${equippedSkill ? `
                                            <span class="skill-icon">${equippedSkill.icon}</span>
                                            <span class="skill-name">${equippedSkill.name}</span>
                                        ` : slotKey}
                                    </button>
                                `;
                }).join('')}
                            </div>
                        </div>
                        ${displaySkills.length === 0 ? `
                            <div class="empty-state">
                                <div class="empty-state-icon">🔰</div>
                                <div class="empty-state-text">No ${selectedCharacter} Skills Available</div>
                            </div>
                        ` : `
                            <div class="cards-grid">
                                ${displaySkills.map(skill => {
                    // All skills can be equipped to S1-S3 slots
                    // Check if skill is equipped to any S1-S3 slot
                    let isEquipped = false;
                    let equippedSlot = null;
                    if (skillLib) {
                        for (let slot = 1; slot <= 3; slot++) {
                            const equippedSkill = skillLib.getEquippedSkill(selectedCharacter, `S${slot}`);
                            if (equippedSkill && equippedSkill.id === skill.id) {
                                isEquipped = true;
                                equippedSlot = slot;
                                break;
                            }
                        }
                    }
                    const playerLevel = progManager ? progManager.getLevel() : (window.gameState?.level || 1);
                    const unlockLevel = skill.unlockLevel || skill.unlock || 1;
                    const canUnlock = playerLevel >= unlockLevel;
                    const isUnlocked = skill.unlocked !== undefined ? skill.unlocked : (unlockedSkills.find(s => s.id === skill.id) !== undefined);
                    const rarityClass = skill.tier === 'common' ? 'common' :
                        skill.tier === 'uncommon' ? 'uncommon' :
                            skill.tier === 'rare' ? 'rare' :
                                skill.tier === 'epic' ? 'epic' :
                                    skill.tier === 'legendary' ? 'legendary' : 'mythic';

                    let slotDisplay = skill.slot;
                    if (skill.slot === 'X' || skill.slot === 'X2') {
                        slotDisplay = skill.slot === 'X' ? 'X1' : 'X2';
                    }

                    // Calculate damage display (handle array damage for chargeable skills)
                    const damageDisplay = Array.isArray(skill.damage) ? skill.damage[0] : (skill.damage || skill.baseDamage || 0);

                    return `
                                    <div class="item-card ${!isUnlocked ? 'opacity-50' : ''}" data-rarity="${rarityClass}">
                                        <div class="item-icon" style="font-size: 40px; color: ${skill.color || '#ffffff'}; margin-bottom: 8px;">${skill.icon}</div>
                                        <div class="item-name" style="font-size: 14px; margin-bottom: 6px;">${skill.name}</div>
                                        <div class="item-rarity" data-rarity="${rarityClass}" style="font-size: 10px; margin-bottom: 8px;">
                                            ${skill.tier.toUpperCase()} • Slot ${slotDisplay}
                                        </div>
                                        <div class="item-description" style="font-size: 11px; min-height: 32px; margin-bottom: 10px;">${skill.description || 'No description'}</div>
                                        <div class="item-stats" style="font-size: 11px; margin-bottom: 10px;">
                                            <div class="stat-row">
                                                <span class="stat-label">DMG:</span>
                                                <span class="stat-value">${damageDisplay.toLocaleString()}</span>
                                            </div>
                                            <div class="stat-row">
                                                <span class="stat-label">CD:</span>
                                                <span class="stat-value">${skill.cooldown}s</span>
                                            </div>
                                            <div class="stat-row">
                                                <span class="stat-label">Lv:</span>
                                                <span class="stat-value">${unlockLevel}</span>
                                            </div>
                                            ${!isUnlocked ? `
                                            <div class="stat-row" style="color: #ff6b6b; margin-top: 4px;">
                                                <span class="stat-label">🔒 Locked</span>
                                            </div>
                                            ` : ''}
                                        </div>
                                        ${!isUnlocked ? `
                                                <button class="item-action-btn" 
                                                        ${!canUnlock ? 'disabled style="opacity: 0.5; cursor: not-allowed;"' : ''}
                                                        onclick="BagSystem.unlockSkill('${skill.id}')">
                                                    ${canUnlock ? `Unlock (Lv. ${unlockLevel})` : `Lv. ${unlockLevel} Required`}
                                                </button>
                                            ` : `
                                                <button class="item-action-btn ${isEquipped ? 'active' : ''}" 
                                                        onclick="BagSystem.openSkillSelector('${selectedCharacter}', 1)"
                                                        style="${isEquipped ? 'background: linear-gradient(135deg, rgba(56, 239, 125, 0.5), rgba(79, 195, 247, 0.5)); border-color: var(--a1k-green);' : ''}">
                                                    ${isEquipped ? `✓ Equipped to S${equippedSlot}` : 'Equip to S1-S3'}
                                                </button>
                                            `}
                                    </div>
                                `;
                }).join('')}
                            </div>
                        `}
                    </div>
                `;
            },

            setSkillViewMode(mode) {
                window.gameState.skillViewMode = mode;
                this.renderTab('abilities');
            },

            selectCharacter(characterId) {
                window.gameState.selectedCharacter = characterId;
                this.renderTab('abilities');
            },

            unlockSkill(skillId) {
                // Phase 1.5: Skills are automatically unlocked based on level via SkillLibrary
                // This function is kept for UI compatibility but skills unlock automatically
                const skillLib = window.skillLibrary || skillLibrary;
                const progManager = window.progressionManager || progressionManager;

                if (!skillLib || !progManager) {
                    this.showToast('SkillLibrary not available!');
                    return;
                }

                const skill = skillLib.getSkillById(skillId);
                if (!skill) {
                    this.showToast('Skill not found!');
                    return;
                }

                const playerLevel = progManager.getLevel();
                const unlockLevel = skill.unlockLevel || skill.unlock || 1;

                // Check if already unlocked
                const unlocked = skillLib.getUnlockedSkills(skill.characterId);
                if (unlocked.find(s => s.id === skillId)) {
                    this.showToast(`${skill.name} is already unlocked!`);
                    return;
                }

                if (playerLevel < unlockLevel) {
                    this.showToast(`Requires level ${unlockLevel}! (Current: ${playerLevel})`);
                    return;
                }

                // Skill should already be unlocked if level is sufficient
                // Re-render to show updated state
                this.renderTab('abilities');
                this.showToast(`✅ ${skill.name} is available! (Level ${playerLevel} >= ${unlockLevel})`);
            },

            equipSkillToSlot(characterId, slotNum, skillId) {
                // Phase 1.5: Use SkillLibrary for equipping
                const skillLib = window.skillLibrary || skillLibrary;

                if (!skillLib) {
                    this.showToast('SkillLibrary not available!');
                    return;
                }

                const skill = skillLib.getSkillById(skillId);
                if (!skill) {
                    this.showToast('Skill not found!');
                    return;
                }

                if (skill.characterId !== characterId) {
                    this.showToast(`❌ ${skill.name} belongs to ${skill.characterId}, not ${characterId}!`);
                    return;
                }

                // Only S1, S2, S3 slots exist - any skill can be equipped to these slots
                if (slotNum < 1 || slotNum > 3) {
                    this.showToast(`❌ Only S1, S2, S3 slots available!`);
                    return;
                }

                // Check if unlocked
                const unlocked = skillLib.getUnlockedSkills(characterId);
                if (!unlocked.find(s => s.id === skillId)) {
                    this.showToast(`Unlock ${skill.name} first! (Level ${skill.unlockLevel || skill.unlock} required)`);
                    return;
                }

                const slotKey = `S${slotNum}`;
                const success = skillLib.equipSkill(characterId, slotKey, skillId);

                if (success) {
                    this.showToast(`✅ Equipped ${skill.name} to ${slotKey}!`);
                    this.renderTab('abilities');
                    // Update mastery UI if this is the current character
                    if (gameState.player && gameState.player.characterId === characterId && window.HUD && typeof window.HUD.updateSkillMastery === 'function') {
                        window.HUD.updateSkillMastery(slotKey, characterId, skillId);
                    }
                } else {
                    this.showToast(`❌ Failed to equip ${skill.name}!`);
                }
            },

            equipTier3SkillToSlot(characterId, skillId) {
                // Allow S4/S5/X skills to be equipped to S1-S3 slots
                const skillLib = window.skillLibrary || skillLibrary;
                if (!skillLib) {
                    this.showToast('SkillLibrary not available!');
                    return;
                }

                const skill = skillLib.getSkillById(skillId);
                if (!skill) {
                    this.showToast('Skill not found!');
                    return;
                }

                // Check if it's actually a T3 skill
                const isTier3Skill = (skill.slot === 4 || skill.slot === 5 || skill.slot === 'X' || skill.slot === 'X2');
                if (!isTier3Skill) {
                    this.showToast('This function is for T3 skills only!');
                    return;
                }

                // Show slot selector (S1, S2, S3)
                const slotChoice = prompt(`Which slot should ${skill.name} be equipped to?\n\nEnter 1, 2, or 3:`);
                if (!slotChoice) return;

                const slotNum = parseInt(slotChoice);
                if (slotNum < 1 || slotNum > 3) {
                    this.showToast('❌ Invalid slot! Must be 1, 2, or 3.');
                    return;
                }

                // Use existing equipSkillToSlot logic but allow T3 skills
                if (skill.characterId !== characterId) {
                    this.showToast(`❌ ${skill.name} belongs to ${skill.characterId}, not ${characterId}!`);
                    return;
                }

                // Check if unlocked
                const unlocked = skillLib.getUnlockedSkills(characterId);
                if (!unlocked.find(s => s.id === skillId)) {
                    this.showToast(`Unlock ${skill.name} first! (Level ${skill.unlockLevel || skill.unlock} required)`);
                    return;
                }

                const slotKey = `S${slotNum}`;
                const success = skillLib.equipSkill(characterId, slotKey, skillId);

                if (success) {
                    this.showToast(`✅ Equipped ${skill.name} to ${slotKey}!`);
                    this.renderTab('abilities');
                    // Update mastery UI if this is the current character
                    if (gameState.player && gameState.player.characterId === characterId && window.HUD && typeof window.HUD.updateSkillMastery === 'function') {
                        window.HUD.updateSkillMastery(slotKey, characterId, skillId);
                    }
                } else {
                    this.showToast(`❌ Failed to equip ${skill.name}!`);
                }
            },

            openSkillSelector(characterId, slotNum) {
                // Phase 1.5: Use SkillLibrary instead of direct arrays
                const skillLib = window.skillLibrary || skillLibrary;
                const charSkills = skillLib ? skillLib.getAllSkills(characterId) : [];
                const unlockedSkills = skillLib ? skillLib.getUnlockedSkills(characterId) : [];

                // Show ALL skills (S1-S5, X1, X2) when selecting for S1-S3 slots
                // X1/X2 skills can be equipped to any S1-S3 slot
                const filteredSkills = charSkills.filter(s =>
                    s.characterId === characterId
                    // Allow any skill to be equipped to S1-S3 slots
                );

                if (filteredSkills.length === 0) {
                    this.showToast(`No ${characterId} skills available!`);
                    return;
                }

                window.gameState.selectorCharacter = characterId;
                window.gameState.selectorSlot = slotNum;

                const titleEl = document.getElementById('skillSelectorTitle');
                if (titleEl) titleEl.textContent = `Select ${characterId} Skill for S${slotNum}`;

                // Get equipped skill from SkillLibrary
                const slotKey = `S${slotNum}`;
                const currentEquippedSkill = skillLib ? skillLib.getEquippedSkill(characterId, slotKey) : null;
                const currentEquipped = currentEquippedSkill ? currentEquippedSkill.id : null;

                const progManager = window.progressionManager || progressionManager;
                const playerLevel = progManager ? progManager.getLevel() : (window.gameState?.level || 1);

                const grid = document.getElementById('skillSelectorGrid');
                if (grid) {
                    grid.innerHTML = filteredSkills.map(skill => {
                        // Check if this skill is equipped to any S1-S3 slot
                        let isEquipped = currentEquipped === skill.id;
                        let equippedToSlot = null;
                        if (skillLib) {
                            for (let s = 1; s <= 3; s++) {
                                const eqSkill = skillLib.getEquippedSkill(characterId, `S${s}`);
                                if (eqSkill && eqSkill.id === skill.id) {
                                    isEquipped = true;
                                    equippedToSlot = s;
                                    break;
                                }
                            }
                        }

                        const unlockLevel = skill.unlockLevel || skill.unlock || 1;
                        const canUnlock = playerLevel >= unlockLevel;
                        const isUnlocked = unlockedSkills.find(s => s.id === skill.id) !== undefined;
                        const rarityClass = skill.tier === 'common' ? 'common' :
                            skill.tier === 'uncommon' ? 'uncommon' :
                                skill.tier === 'rare' ? 'rare' :
                                    skill.tier === 'epic' ? 'epic' :
                                        skill.tier === 'legendary' ? 'legendary' : 'mythic';

                        // Display slot name properly (X1 for X, X2 for X2)
                        const slotDisplay = skill.slot === 'X' ? 'X1' : (skill.slot === 'X2' ? 'X2' : `S${skill.slot}`);

                        return `
                            <div class="skill-selector-item ${isEquipped ? 'selected' : ''} ${!isUnlocked && !canUnlock ? 'disabled' : ''}" 
                                 data-rarity="${rarityClass}"
                                 onclick="${isUnlocked || canUnlock ? `BagSystem.selectSkillFromModal('${skill.id}')` : ''}">
                                <div class="skill-selector-item-icon" style="color: ${skill.color || '#ffffff'};">${skill.icon}</div>
                                <div class="skill-selector-item-name">${skill.name}</div>
                                <div class="skill-selector-item-slot">${slotDisplay} • ${skill.tier.toUpperCase()}</div>
                                ${equippedToSlot ? `<div style="font-size: 10px; color: var(--a1k-green); margin-top: 4px;">Equipped to S${equippedToSlot}</div>` : ''}
                                ${!isUnlocked ? `
                                    <div style="font-size: 10px; color: var(--text-secondary); margin-top: 4px;">
                                        Requires Lv. ${unlockLevel}
                                    </div>
                                ` : ''}
                                ${isEquipped ? `
                                    <div style="font-size: 11px; color: var(--a1k-green); margin-top: 4px; font-weight: 600;">
                                        ✓ Currently Equipped
                                    </div>
                                ` : ''}
                            </div>
                        `;
                    }).join('');
                }

                const modal = document.getElementById('skillSelectorModal');
                if (modal) modal.classList.add('open');
            },

            closeSkillSelector() {
                const modal = document.getElementById('skillSelectorModal');
                if (modal) modal.classList.remove('open');
                window.gameState.selectorCharacter = null;
                window.gameState.selectorSlot = null;
            },

            selectSkillFromModal(skillId) {
                const characterId = window.gameState.selectorCharacter;
                const slotNum = window.gameState.selectorSlot;

                if (!characterId || !slotNum) {
                    this.showToast('Selector state error!');
                    return;
                }

                this.equipSkillToSlot(characterId, slotNum, skillId);
                this.closeSkillSelector();
            },

            // ═══ JOURNAL HUB ═══
            renderJournalHub() {
                const subtab = this.activeSubtab['journal'] || 'missions';

                switch (subtab) {
                    case 'missions':
                        return this.renderMissionsTab();
                    case 'map':
                        return this.renderMapTab();
                    case 'bestiary':
                        return this.renderBestiaryTab();
                    case 'drops':
                        return this.renderDropsTab();
                    default:
                        return this.renderMissionsTab();
                }
            },

            renderMissionsTab() {
                return `
                    <div>
                        <h2 style="margin-bottom: 20px; color: var(--a1k-gold);">🗺️ Mission Board</h2>
                        <div class="cards-grid">
                            ${MISSIONS_DATA.map(mission => `
                                <div class="item-card" data-rarity="${mission.status === 'completed' ? 'epic' : mission.status === 'active' ? 'rare' : 'common'}">
                                    <div class="item-icon">${mission.status === 'completed' ? '✅' : mission.status === 'active' ? '🔄' : '📋'}</div>
                                    <div class="item-name">${mission.name}</div>
                                    <div class="item-rarity" data-rarity="${mission.status === 'completed' ? 'epic' : mission.status === 'active' ? 'rare' : 'common'}">${mission.status}</div>
                                    <div class="item-description">${mission.description}</div>
                                    <div class="item-stats">
                                        <div class="stat-row">
                                            <span class="stat-label">Progress:</span>
                                            <span class="stat-value">${mission.progress}%</span>
                                        </div>
                                        <div class="stat-row">
                                            <span class="stat-label">Rewards:</span>
                                            <span class="stat-value">${Object.entries(mission.rewards).map(([k, v]) => `${k}: ${v}`).join(', ')}</span>
                                        </div>
                                    </div>
                                    <button class="item-action-btn" ${mission.status === 'completed' ? 'disabled' : ''} onclick="BagSystem.acceptMission('${mission.id}')">
                                        ${mission.status === 'completed' ? 'Completed' : mission.status === 'active' ? 'In Progress' : 'Accept'}
                                    </button>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            },

            renderMapTab() {
                return `
                    <div class="empty-state">
                        <div class="empty-state-icon">🗺️</div>
                        <div class="empty-state-text">World Map</div>
                        <div class="empty-state-subtext">Explore the game world and discover new locations</div>
                    </div>
                `;
            },

            renderBestiaryTab() {
                return `
                    <div>
                        <h2 style="margin-bottom: 20px; color: var(--a1k-gold);">📖 Bestiary</h2>
                        <div class="cards-grid">
                            ${BESTIARY_DATA.map(enemy => `
                                <div class="item-card" data-rarity="${enemy.level >= 25 ? 'epic' : enemy.level >= 15 ? 'rare' : 'common'}">
                                    <div class="item-icon">${enemy.icon}</div>
                                    <div class="item-name">${enemy.name}</div>
                                    <div class="item-rarity" data-rarity="${enemy.level >= 25 ? 'epic' : enemy.level >= 15 ? 'rare' : 'common'}">Level ${enemy.level}</div>
                                    <div class="item-description">${enemy.description}</div>
                                    <div class="item-stats">
                                        <div class="stat-row">
                                            <span class="stat-label">HP:</span>
                                            <span class="stat-value">${enemy.hp}</span>
                                        </div>
                                        <div class="stat-row">
                                            <span class="stat-label">Attack:</span>
                                            <span class="stat-value">${enemy.attack}</span>
                                        </div>
                                        <div class="stat-row">
                                            <span class="stat-label">Defense:</span>
                                            <span class="stat-value">${enemy.defense}</span>
                                        </div>
                                        <div class="stat-row">
                                            <span class="stat-label">Defeated:</span>
                                            <span class="stat-value">${enemy.defeated}x</span>
                                        </div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            },

            renderDropsTab() {
                return `
                    <div>
                        <h2 style="margin-bottom: 20px; color: var(--a1k-gold);">🎁 Drop Tables</h2>
                        <div class="cards-grid">
                            ${DROPS_DATA.map(drop => `
                                <div class="item-card" data-rarity="${drop.rarity}">
                                    <div class="item-icon">${drop.icon}</div>
                                    <div class="item-name">${drop.name}</div>
                                    <div class="item-rarity" data-rarity="${drop.rarity}">${drop.rarity}</div>
                                    <div class="item-description">Drop chance: ${drop.chance}%</div>
                                    <div class="item-stats">
                                        <div class="stat-row">
                                            <span class="stat-label">Possible Items:</span>
                                        </div>
                                        ${drop.items.map(item => `
                                            <div class="stat-row">
                                                <span class="stat-value" style="font-size: 10px;">• ${item}</span>
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            },

            acceptMission(id) {
                const mission = MISSIONS_DATA.find(m => m.id === id);
                if (mission && mission.status === 'available') {
                    mission.status = 'active';
                    this.renderTab('journal');
                    this.showToast(`Accepted mission: ${mission.name}!`);
                }
            },

            // ═══ OTHER TABS ═══
            renderItemsTab() {
                const items = window.gameState.inventory.items || [];
                return `
                    <div>
                        <h2 style="margin-bottom: 20px; color: var(--a1k-gold);">📦 Items & Consumables</h2>
                        <div class="cards-grid">
                            ${items.length === 0 ? '<div class="empty-state"><div class="empty-state-icon">📦</div><div class="empty-state-text">No items in inventory</div></div>' : items.map(item => `
                                <div class="item-card" data-rarity="${item.rarity}">
                                    <div class="item-icon">${item.icon}</div>
                                    <div class="item-name">${item.name}</div>
                                    <div class="item-rarity" data-rarity="${item.rarity}">${item.rarity}</div>
                                    <div class="item-description">Quantity: ${item.quantity}</div>
                                    <div class="item-stats">
                                        <div class="stat-row">
                                            <span class="stat-label">Category:</span>
                                            <span class="stat-value">${item.category}</span>
                                        </div>
                                    </div>
                                    <button class="item-action-btn" onclick="BagSystem.useItem('${item.id}')">Use</button>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            },

            renderAlchemyTab() {
                const gridSize = 9;
                const alchemyGrid = window.gameState.alchemyGrid || Array(gridSize).fill(null);
                const selectedRecipe = window.gameState.selectedRecipe || null;

                const recipes = [
                    {
                        id: 'recipe_health_potion',
                        name: 'Health Potion',
                        ingredients: ['Herb', 'Water', 'Crystal'],
                        result: { name: 'Health Potion', icon: '🧪', rarity: 'common' },
                        cost: 50
                    },
                    {
                        id: 'recipe_mana_potion',
                        name: 'Mana Potion',
                        ingredients: ['Mana Flower', 'Water', 'Essence'],
                        result: { name: 'Mana Potion', icon: '💙', rarity: 'common' },
                        cost: 60
                    },
                    {
                        id: 'recipe_strength_elixir',
                        name: 'Strength Elixir',
                        ingredients: ['Iron Ore', 'Herb', 'Herb', 'Crystal'],
                        result: { name: 'Strength Elixir', icon: '💪', rarity: 'uncommon' },
                        cost: 150
                    },
                    {
                        id: 'recipe_gear_upgrade',
                        name: 'Gear Upgrade Stone',
                        ingredients: ['Iron Ore', 'Iron Ore', 'Crystal', 'Essence', 'Essence'],
                        result: { name: 'Upgrade Stone', icon: '💎', rarity: 'rare' },
                        cost: 300
                    }
                ];

                return `
                    <div>
                        <h2 style="margin-bottom: 20px; color: var(--a1k-gold); text-align: center;">⚗️ Alchemy Lab</h2>
                        <div class="alchemy-container">
                            <div class="alchemy-grid-section">
                                <div class="alchemy-title">Crafting Grid (3x3)</div>
                                <div class="alchemy-grid">
                                    ${alchemyGrid.map((item, index) => `
                                        <div class="alchemy-square ${item ? 'filled' : ''}" 
                                             onclick="BagSystem.clearAlchemySquare(${index})"
                                             ondrop="BagSystem.dropOnAlchemySquare(event, ${index})"
                                             ondragover="event.preventDefault()">
                                            ${item ? `
                                                <div class="alchemy-square-icon">${item.icon}</div>
                                                <div class="alchemy-square-name">${item.name}</div>
                                            ` : '<div style="color: var(--text-secondary); font-size: 24px;">+</div>'}
                                        </div>
                                    `).join('')}
                                </div>
                                <div class="alchemy-result">
                                    <div class="alchemy-result-label">Result</div>
                                    ${selectedRecipe ? `
                                        <div class="alchemy-result-icon">${selectedRecipe.result.icon}</div>
                                        <div class="alchemy-result-name">${selectedRecipe.result.name}</div>
                                        <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 16px;">
                                            Cost: ${selectedRecipe.cost} gold
                                        </div>
                                        <button class="alchemy-craft-btn" onclick="BagSystem.craftItem()">
                                            Craft Item
                                        </button>
                                    ` : `
                                        <div style="color: var(--text-secondary); font-size: 14px;">
                                            Place ingredients in the grid to see result
                                        </div>
                                    `}
                                </div>
                            </div>
                            <div class="alchemy-grid-section">
                                <div class="alchemy-title">Recipes</div>
                                <div class="alchemy-recipes">
                                    ${recipes.map(recipe => `
                                        <div class="alchemy-recipe-card" onclick="BagSystem.selectRecipe('${recipe.id}')">
                                            <div class="alchemy-recipe-name">${recipe.name}</div>
                                            <div class="alchemy-recipe-ingredients">
                                                Ingredients: ${recipe.ingredients.join(', ')}
                                            </div>
                                            <div class="alchemy-recipe-result">
                                                → ${recipe.result.name} ${recipe.result.icon} (${recipe.cost} gold)
                                            </div>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        </div>
                        <div style="margin-top: 24px;">
                            <h3 style="color: var(--a1k-gold); margin-bottom: 16px;">Available Ingredients</h3>
                            <div class="cards-grid">
                                ${this.getAlchemyIngredients().map(ingredient => `
                                    <div class="item-card" data-rarity="${ingredient.rarity || 'common'}" 
                                         draggable="true"
                                         ondragstart="BagSystem.dragAlchemyIngredient(event, '${ingredient.id}')">
                                        <div class="item-icon">${ingredient.icon}</div>
                                        <div class="item-name">${ingredient.name}</div>
                                        <div class="item-description">Quantity: ${ingredient.quantity || 1}</div>
                                        <button class="item-action-btn" onclick="BagSystem.addToAlchemyGrid('${ingredient.id}')">
                                            Add to Grid
                                        </button>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;
            },

            getAlchemyIngredients() {
                return [
                    { id: 'ing_herb', name: 'Herb', icon: '🌿', rarity: 'common', quantity: 15 },
                    { id: 'ing_water', name: 'Water', icon: '💧', rarity: 'common', quantity: 20 },
                    { id: 'ing_crystal', name: 'Crystal', icon: '💎', rarity: 'uncommon', quantity: 8 },
                    { id: 'ing_mana_flower', name: 'Mana Flower', icon: '🌸', rarity: 'uncommon', quantity: 10 },
                    { id: 'ing_essence', name: 'Essence', icon: '✨', rarity: 'rare', quantity: 5 },
                    { id: 'ing_iron_ore', name: 'Iron Ore', icon: '⛏️', rarity: 'common', quantity: 12 }
                ];
            },

            addToAlchemyGrid(ingredientId) {
                if (!window.gameState.alchemyGrid) {
                    window.gameState.alchemyGrid = Array(9).fill(null);
                }

                const ingredients = this.getAlchemyIngredients();
                const ingredient = ingredients.find(i => i.id === ingredientId);
                if (!ingredient) return;

                const emptyIndex = window.gameState.alchemyGrid.findIndex(slot => slot === null);
                if (emptyIndex !== -1) {
                    window.gameState.alchemyGrid[emptyIndex] = ingredient;
                    this.renderTab('alchemy');
                    this.checkAlchemyRecipe();
                } else {
                    this.showToast('Grid is full! Clear a slot first.');
                }
            },

            clearAlchemySquare(index) {
                if (window.gameState.alchemyGrid && window.gameState.alchemyGrid[index]) {
                    window.gameState.alchemyGrid[index] = null;
                    this.renderTab('alchemy');
                    this.checkAlchemyRecipe();
                }
            },

            dropOnAlchemySquare(event, index) {
                event.preventDefault();
                const ingredientId = event.dataTransfer.getData('ingredientId');
                if (ingredientId) {
                    if (!window.gameState.alchemyGrid) {
                        window.gameState.alchemyGrid = Array(9).fill(null);
                    }
                    const ingredients = this.getAlchemyIngredients();
                    const ingredient = ingredients.find(i => i.id === ingredientId);
                    if (ingredient) {
                        window.gameState.alchemyGrid[index] = ingredient;
                        this.renderTab('alchemy');
                        this.checkAlchemyRecipe();
                    }
                }
            },

            dragAlchemyIngredient(event, ingredientId) {
                event.dataTransfer.setData('ingredientId', ingredientId);
            },

            selectRecipe(recipeId) {
                const recipes = [
                    {
                        id: 'recipe_health_potion',
                        name: 'Health Potion',
                        ingredients: ['Herb', 'Water', 'Crystal'],
                        result: { name: 'Health Potion', icon: '🧪', rarity: 'common' },
                        cost: 50
                    },
                    {
                        id: 'recipe_mana_potion',
                        name: 'Mana Potion',
                        ingredients: ['Mana Flower', 'Water', 'Essence'],
                        result: { name: 'Mana Potion', icon: '💙', rarity: 'common' },
                        cost: 60
                    },
                    {
                        id: 'recipe_strength_elixir',
                        name: 'Strength Elixir',
                        ingredients: ['Iron Ore', 'Herb', 'Herb', 'Crystal'],
                        result: { name: 'Strength Elixir', icon: '💪', rarity: 'uncommon' },
                        cost: 150
                    },
                    {
                        id: 'recipe_gear_upgrade',
                        name: 'Gear Upgrade Stone',
                        ingredients: ['Iron Ore', 'Iron Ore', 'Crystal', 'Essence', 'Essence'],
                        result: { name: 'Upgrade Stone', icon: '💎', rarity: 'rare' },
                        cost: 300
                    }
                ];

                const recipe = recipes.find(r => r.id === recipeId);
                if (recipe) {
                    window.gameState.selectedRecipe = recipe;
                    if (!window.gameState.alchemyGrid) {
                        window.gameState.alchemyGrid = Array(9).fill(null);
                    }
                    const ingredients = this.getAlchemyIngredients();
                    recipe.ingredients.forEach((ingName, idx) => {
                        const ingredient = ingredients.find(i => i.name === ingName);
                        if (ingredient && idx < 9) {
                            window.gameState.alchemyGrid[idx] = ingredient;
                        }
                    });
                    this.renderTab('alchemy');
                }
            },

            checkAlchemyRecipe() {
                if (!window.gameState.alchemyGrid) return;

                const recipes = [
                    {
                        id: 'recipe_health_potion',
                        name: 'Health Potion',
                        ingredients: ['Herb', 'Water', 'Crystal'],
                        result: { name: 'Health Potion', icon: '🧪', rarity: 'common' },
                        cost: 50
                    },
                    {
                        id: 'recipe_mana_potion',
                        name: 'Mana Potion',
                        ingredients: ['Mana Flower', 'Water', 'Essence'],
                        result: { name: 'Mana Potion', icon: '💙', rarity: 'common' },
                        cost: 60
                    },
                    {
                        id: 'recipe_strength_elixir',
                        name: 'Strength Elixir',
                        ingredients: ['Iron Ore', 'Herb', 'Herb', 'Crystal'],
                        result: { name: 'Strength Elixir', icon: '💪', rarity: 'uncommon' },
                        cost: 150
                    },
                    {
                        id: 'recipe_gear_upgrade',
                        name: 'Gear Upgrade Stone',
                        ingredients: ['Iron Ore', 'Iron Ore', 'Crystal', 'Essence', 'Essence'],
                        result: { name: 'Upgrade Stone', icon: '💎', rarity: 'rare' },
                        cost: 300
                    }
                ];

                const gridItems = window.gameState.alchemyGrid.filter(item => item !== null);
                const gridNames = gridItems.map(item => item.name);

                for (const recipe of recipes) {
                    const recipeNames = [...recipe.ingredients].sort();
                    const gridNamesSorted = [...gridNames].sort();

                    if (recipeNames.length === gridNamesSorted.length &&
                        recipeNames.every((name, idx) => gridNamesSorted[idx] === name)) {
                        window.gameState.selectedRecipe = recipe;
                        this.renderTab('alchemy');
                        return;
                    }
                }

                window.gameState.selectedRecipe = null;
            },

            craftItem() {
                const recipe = window.gameState.selectedRecipe;
                if (!recipe) {
                    this.showToast('No valid recipe!');
                    return;
                }

                if (window.gameState.gold < recipe.cost) {
                    this.showToast(`Not enough gold! Need ${recipe.cost}, have ${window.gameState.gold}`);
                    return;
                }

                window.gameState.gold -= recipe.cost;
                window.gameState.alchemyGrid = Array(9).fill(null);
                window.gameState.selectedRecipe = null;

                if (!window.gameState.inventory.items) {
                    window.gameState.inventory.items = [];
                }
                window.gameState.inventory.items.push({
                    id: `item_${recipe.result.name.toLowerCase().replace(/\s/g, '_')}`,
                    name: recipe.result.name,
                    icon: recipe.result.icon,
                    category: 'consumable',
                    quantity: 1,
                    rarity: recipe.result.rarity
                });

                this.renderCurrencies();
                this.renderTab('alchemy');
                this.showToast(`Crafted ${recipe.result.name}!`);
            },

            renderShopTab() {
                const shopCategory = window.gameState.shopCategory || 'all';

                const shopItems = [
                    { id: 'shop_hp_potion', name: 'Health Potion', icon: '🧪', category: 'consumable', cost: 150, currency: 'gold', rarity: 'common', description: 'Restores 100 HP', quantity: 1 },
                    { id: 'shop_mp_potion', name: 'Mana Potion', icon: '💙', category: 'consumable', cost: 120, currency: 'gold', rarity: 'common', description: 'Restores 50 MP', quantity: 1 },
                    { id: 'shop_elixir_health', name: 'Greater Health Elixir', icon: '🧪', category: 'consumable', cost: 500, currency: 'gold', rarity: 'uncommon', description: 'Restores 500 HP', quantity: 1 },
                    { id: 'shop_elixir_mana', name: 'Greater Mana Elixir', icon: '💙', category: 'consumable', cost: 450, currency: 'gold', rarity: 'uncommon', description: 'Restores 250 MP', quantity: 1 },
                    { id: 'shop_xp_box_low', name: 'Small XP Box', icon: '📦', category: 'consumable', cost: 200, currency: 'gold', rarity: 'common', description: 'Grants 50 XP', quantity: 1 },
                    { id: 'shop_xp_box_mid', name: 'Medium XP Box', icon: '📦', category: 'consumable', cost: 500, currency: 'gold', rarity: 'uncommon', description: 'Grants 150 XP', quantity: 1 },
                    { id: 'shop_xp_box_high', name: 'Large XP Box', icon: '📦', category: 'consumable', cost: 1200, currency: 'gold', rarity: 'rare', description: 'Grants 400 XP', quantity: 1 },
                    { id: 'shop_herb', name: 'Herb', icon: '🌿', category: 'material', cost: 25, currency: 'gold', rarity: 'common', description: 'Basic alchemy ingredient', quantity: 1 },
                    { id: 'shop_water', name: 'Water', icon: '💧', category: 'material', cost: 10, currency: 'gold', rarity: 'common', description: 'Basic alchemy ingredient', quantity: 1 },
                    { id: 'shop_crystal', name: 'Crystal', icon: '💎', category: 'material', cost: 100, currency: 'gold', rarity: 'uncommon', description: 'Rare alchemy ingredient', quantity: 1 },
                    { id: 'shop_mana_flower', name: 'Mana Flower', icon: '🌸', category: 'material', cost: 80, currency: 'gold', rarity: 'uncommon', description: 'Magical alchemy ingredient', quantity: 1 },
                    { id: 'shop_essence', name: 'Essence', icon: '✨', category: 'material', cost: 200, currency: 'gold', rarity: 'rare', description: 'Powerful alchemy ingredient', quantity: 1 },
                    { id: 'shop_iron_ore', name: 'Iron Ore', icon: '⛏️', category: 'material', cost: 50, currency: 'gold', rarity: 'common', description: 'Crafting material', quantity: 1 },
                    { id: 'shop_gear_recruit_pants', name: 'Recruit Greaves', icon: '🦿', category: 'gear', cost: 260, currency: 'gold', rarity: 'common', description: 'Starter leg armor', slot: 'pants', quantity: 1 },
                    { id: 'shop_gear_vanguard_pants', name: 'Vanguard Greaves', icon: '🦿', category: 'gear', cost: 820, currency: 'gold', rarity: 'rare', description: 'Elite leg armor', slot: 'pants', quantity: 1 },
                    { id: 'shop_gear_mythic_pants', name: 'Mythic Legplates', icon: '🦿', category: 'gear', cost: 2460, currency: 'gold', rarity: 'legendary', description: 'Legendary leg armor', slot: 'pants', quantity: 1 },
                    { id: 'shop_gear_recruit_ring', name: 'Recruit Signet', icon: '💍', category: 'gear', cost: 200, currency: 'gold', rarity: 'common', description: 'Starter ring', slot: 'ring', quantity: 1 },
                    { id: 'shop_gear_vanguard_ring', name: 'Vanguard Crest', icon: '💍', category: 'gear', cost: 720, currency: 'gold', rarity: 'rare', description: 'Elite ring', slot: 'ring', quantity: 1 },
                    { id: 'shop_key', name: 'Dungeon Key', icon: '🔑', category: 'special', cost: 500, currency: 'gold', rarity: 'uncommon', description: 'Opens dungeon doors', quantity: 1 },
                    { id: 'shop_ticket', name: 'Arcade Ticket', icon: '🎟️', category: 'special', cost: 300, currency: 'gold', rarity: 'uncommon', description: 'Play arcade games', quantity: 1 },
                    { id: 'shop_gem', name: 'Gem Pack', icon: '💎', category: 'special', cost: 1000, currency: 'gold', rarity: 'rare', description: 'Contains 5 gems', quantity: 1 },
                    { id: 'shop_chest_bronze', name: 'Bronze Chest', icon: '📦', category: 'special', cost: 250, currency: 'gold', rarity: 'common', description: 'Contains random common items', quantity: 1 },
                    { id: 'shop_chest_silver', name: 'Silver Chest', icon: '📦', category: 'special', cost: 750, currency: 'gold', rarity: 'uncommon', description: 'Contains random uncommon items', quantity: 1 },
                    { id: 'shop_chest_gold', name: 'Gold Chest', icon: '📦', category: 'special', cost: 2000, currency: 'gold', rarity: 'rare', description: 'Contains random rare items', quantity: 1 },
                    { id: 'shop_upgrade_stone', name: 'Upgrade Stone', icon: '💎', category: 'upgrade', cost: 500, currency: 'gold', rarity: 'rare', description: 'Upgrades gear by 1 level', quantity: 1 },
                    { id: 'shop_fusion_core', name: 'Fusion Core', icon: '⚡', category: 'upgrade', cost: 1500, currency: 'gold', rarity: 'epic', description: 'Fuses two items together', quantity: 1 },
                    { id: 'shop_enhancement_scroll', name: 'Enhancement Scroll', icon: '📜', category: 'upgrade', cost: 800, currency: 'gold', rarity: 'rare', description: 'Enhances item stats', quantity: 1 }
                ];

                const filteredItems = shopCategory === 'all'
                    ? shopItems
                    : shopItems.filter(item => item.category === shopCategory);

                const categories = [
                    { id: 'all', label: 'All Items', icon: '🏪' },
                    { id: 'consumable', label: 'Consumables', icon: '🧪' },
                    { id: 'material', label: 'Materials', icon: '🌿' },
                    { id: 'gear', label: 'Gear', icon: '⚔️' },
                    { id: 'special', label: 'Special', icon: '🎁' },
                    { id: 'upgrade', label: 'Upgrades', icon: '⬆️' }
                ];

                return `
                    <div>
                        <h2 style="margin-bottom: 20px; color: var(--a1k-gold); text-align: center;">🏪 Shop</h2>
                        <div style="display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 24px; justify-content: center;">
                            ${categories.map(cat => `
                                <button class="hub-subtab ${shopCategory === cat.id ? 'active' : ''}" 
                                        onclick="BagSystem.setShopCategory('${cat.id}')"
                                        style="padding: 10px 16px;">
                                    <span style="margin-right: 6px;">${cat.icon}</span>
                                    ${cat.label}
                                </button>
                            `).join('')}
                        </div>
                        <div class="cards-grid">
                            ${filteredItems.map(item => {
                    const canAfford = window.gameState[item.currency] >= item.cost;
                    return `
                                    <div class="item-card" data-rarity="${item.rarity}">
                                        <div class="item-icon">${item.icon}</div>
                                        <div class="item-name">${item.name}</div>
                                        <div class="item-rarity" data-rarity="${item.rarity}">${item.rarity}</div>
                                        <div class="item-description">${item.description}</div>
                                        <div class="item-stats">
                                            <div class="stat-row">
                                                <span class="stat-label">Category:</span>
                                                <span class="stat-value">${item.category}</span>
                                            </div>
                                            <div class="stat-row">
                                                <span class="stat-label">Price:</span>
                                                <span class="stat-value" style="color: ${canAfford ? 'var(--a1k-gold)' : 'var(--a1k-red)'};">
                                                    ${item.cost.toLocaleString()} ${item.currency === 'gold' ? '💰' : item.currency === 'gems' ? '💎' : item.currency}
                                                </span>
                                            </div>
                                            ${item.slot ? `
                                                <div class="stat-row">
                                                    <span class="stat-label">Slot:</span>
                                                    <span class="stat-value">${item.slot}</span>
                                                </div>
                                            ` : ''}
                                        </div>
                                        <button class="item-action-btn" 
                                                onclick="BagSystem.purchaseItem('${item.id}')"
                                                ${!canAfford ? 'disabled style="opacity: 0.5; cursor: not-allowed;"' : ''}>
                                            ${canAfford ? `Buy (${item.cost.toLocaleString()})` : 'Cannot Afford'}
                                        </button>
                                    </div>
                                `;
                }).join('')}
                        </div>
                        <div style="margin-top: 24px; padding: 16px; background: var(--bg-secondary); border-radius: 12px; border: 2px solid var(--border-default);">
                            <div style="display: flex; justify-content: space-around; flex-wrap: wrap; gap: 16px;">
                                <div style="text-align: center;">
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">Total Items</div>
                                    <div style="font-size: 20px; font-weight: 700; color: var(--a1k-gold);">${shopItems.length}</div>
                                </div>
                                <div style="text-align: center;">
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">Available</div>
                                    <div style="font-size: 20px; font-weight: 700; color: var(--a1k-green);">${filteredItems.length}</div>
                                </div>
                                <div style="text-align: center;">
                                    <div style="font-size: 12px; color: var(--text-secondary); margin-bottom: 4px;">Your Gold</div>
                                    <div style="font-size: 20px; font-weight: 700; color: var(--a1k-gold);">${window.gameState.gold.toLocaleString()}</div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            },

            setShopCategory(category) {
                window.gameState.shopCategory = category;
                this.renderTab('shop');
            },

            purchaseItem(itemId) {
                const shopItems = [
                    { id: 'shop_hp_potion', name: 'Health Potion', icon: '🧪', category: 'consumable', cost: 150, currency: 'gold', rarity: 'common', description: 'Restores 100 HP', quantity: 1 },
                    { id: 'shop_mp_potion', name: 'Mana Potion', icon: '💙', category: 'consumable', cost: 120, currency: 'gold', rarity: 'common', description: 'Restores 50 MP', quantity: 1 },
                    { id: 'shop_elixir_health', name: 'Greater Health Elixir', icon: '🧪', category: 'consumable', cost: 500, currency: 'gold', rarity: 'uncommon', description: 'Restores 500 HP', quantity: 1 },
                    { id: 'shop_elixir_mana', name: 'Greater Mana Elixir', icon: '💙', category: 'consumable', cost: 450, currency: 'gold', rarity: 'uncommon', description: 'Restores 250 MP', quantity: 1 },
                    { id: 'shop_xp_box_low', name: 'Small XP Box', icon: '📦', category: 'consumable', cost: 200, currency: 'gold', rarity: 'common', description: 'Grants 50 XP', quantity: 1 },
                    { id: 'shop_xp_box_mid', name: 'Medium XP Box', icon: '📦', category: 'consumable', cost: 500, currency: 'gold', rarity: 'uncommon', description: 'Grants 150 XP', quantity: 1 },
                    { id: 'shop_xp_box_high', name: 'Large XP Box', icon: '📦', category: 'consumable', cost: 1200, currency: 'gold', rarity: 'rare', description: 'Grants 400 XP', quantity: 1 },
                    { id: 'shop_herb', name: 'Herb', icon: '🌿', category: 'material', cost: 25, currency: 'gold', rarity: 'common', description: 'Basic alchemy ingredient', quantity: 1 },
                    { id: 'shop_water', name: 'Water', icon: '💧', category: 'material', cost: 10, currency: 'gold', rarity: 'common', description: 'Basic alchemy ingredient', quantity: 1 },
                    { id: 'shop_crystal', name: 'Crystal', icon: '💎', category: 'material', cost: 100, currency: 'gold', rarity: 'uncommon', description: 'Rare alchemy ingredient', quantity: 1 },
                    { id: 'shop_mana_flower', name: 'Mana Flower', icon: '🌸', category: 'material', cost: 80, currency: 'gold', rarity: 'uncommon', description: 'Magical alchemy ingredient', quantity: 1 },
                    { id: 'shop_essence', name: 'Essence', icon: '✨', category: 'material', cost: 200, currency: 'gold', rarity: 'rare', description: 'Powerful alchemy ingredient', quantity: 1 },
                    { id: 'shop_iron_ore', name: 'Iron Ore', icon: '⛏️', category: 'material', cost: 50, currency: 'gold', rarity: 'common', description: 'Crafting material', quantity: 1 },
                    { id: 'shop_gear_recruit_pants', name: 'Recruit Greaves', icon: '🦿', category: 'gear', cost: 260, currency: 'gold', rarity: 'common', description: 'Starter leg armor', slot: 'pants', quantity: 1 },
                    { id: 'shop_gear_vanguard_pants', name: 'Vanguard Greaves', icon: '🦿', category: 'gear', cost: 820, currency: 'gold', rarity: 'rare', description: 'Elite leg armor', slot: 'pants', quantity: 1 },
                    { id: 'shop_gear_mythic_pants', name: 'Mythic Legplates', icon: '🦿', category: 'gear', cost: 2460, currency: 'gold', rarity: 'legendary', description: 'Legendary leg armor', slot: 'pants', quantity: 1 },
                    { id: 'shop_gear_recruit_ring', name: 'Recruit Signet', icon: '💍', category: 'gear', cost: 200, currency: 'gold', rarity: 'common', description: 'Starter ring', slot: 'ring', quantity: 1 },
                    { id: 'shop_gear_vanguard_ring', name: 'Vanguard Crest', icon: '💍', category: 'gear', cost: 720, currency: 'gold', rarity: 'rare', description: 'Elite ring', slot: 'ring', quantity: 1 },
                    { id: 'shop_key', name: 'Dungeon Key', icon: '🔑', category: 'special', cost: 500, currency: 'gold', rarity: 'uncommon', description: 'Opens dungeon doors', quantity: 1 },
                    { id: 'shop_ticket', name: 'Arcade Ticket', icon: '🎟️', category: 'special', cost: 300, currency: 'gold', rarity: 'uncommon', description: 'Play arcade games', quantity: 1 },
                    { id: 'shop_gem', name: 'Gem Pack', icon: '💎', category: 'special', cost: 1000, currency: 'gold', rarity: 'rare', description: 'Contains 5 gems', quantity: 1 },
                    { id: 'shop_chest_bronze', name: 'Bronze Chest', icon: '📦', category: 'special', cost: 250, currency: 'gold', rarity: 'common', description: 'Contains random common items', quantity: 1 },
                    { id: 'shop_chest_silver', name: 'Silver Chest', icon: '📦', category: 'special', cost: 750, currency: 'gold', rarity: 'uncommon', description: 'Contains random uncommon items', quantity: 1 },
                    { id: 'shop_chest_gold', name: 'Gold Chest', icon: '📦', category: 'special', cost: 2000, currency: 'gold', rarity: 'rare', description: 'Contains random rare items', quantity: 1 },
                    { id: 'shop_upgrade_stone', name: 'Upgrade Stone', icon: '💎', category: 'upgrade', cost: 500, currency: 'gold', rarity: 'rare', description: 'Upgrades gear by 1 level', quantity: 1 },
                    { id: 'shop_fusion_core', name: 'Fusion Core', icon: '⚡', category: 'upgrade', cost: 1500, currency: 'gold', rarity: 'epic', description: 'Fuses two items together', quantity: 1 },
                    { id: 'shop_enhancement_scroll', name: 'Enhancement Scroll', icon: '📜', category: 'upgrade', cost: 800, currency: 'gold', rarity: 'rare', description: 'Enhances item stats', quantity: 1 }
                ];

                const item = shopItems.find(i => i.id === itemId);
                if (!item) {
                    this.showToast('Item not found!');
                    return;
                }

                const currency = item.currency || 'gold';
                const cost = item.cost;

                if (window.gameState[currency] < cost) {
                    this.showToast(`Not enough ${currency}! Need ${cost}, have ${window.gameState[currency]}`);
                    return;
                }

                window.gameState[currency] -= cost;

                if (item.id === 'shop_gem') {
                    window.gameState.gems += 5;
                    this.showToast(`Purchased ${item.name}! Received 5 gems!`);
                } else if (item.id.startsWith('shop_gear_')) {
                    const gearId = item.id.replace('shop_gear_', 'gear_');
                    const gear = GEAR_MANIFEST.find(g => g.id === gearId);
                    if (gear) {
                        if (!window.gameState.inventory.gear) {
                            window.gameState.inventory.gear = [];
                        }
                        window.gameState.inventory.gear.push(gear);
                        this.showToast(`Purchased ${item.name}! Added to inventory!`);
                    }
                } else {
                    if (!window.gameState.inventory.items) {
                        window.gameState.inventory.items = [];
                    }

                    const existingItem = window.gameState.inventory.items.find(i => i.id === itemId);
                    if (existingItem) {
                        existingItem.quantity += item.quantity || 1;
                    } else {
                        window.gameState.inventory.items.push({
                            id: itemId,
                            name: item.name,
                            icon: item.icon,
                            category: item.category,
                            quantity: item.quantity || 1,
                            rarity: item.rarity,
                            description: item.description
                        });
                    }
                    this.showToast(`Purchased ${item.name}!`);
                }

                this.renderCurrencies();
                this.renderTab('shop');
            },

            // ═══ SETTINGS HUB ═══
            renderSettingsHub() {
                const subtab = this.activeSubtab['settings'] || 'gameplay';

                switch (subtab) {
                    case 'gameplay':
                        return this.renderGameplaySettings();
                    case 'graphics':
                        return this.renderGraphicsSettings();
                    case 'audio':
                        return this.renderAudioSettings();
                    case 'controls':
                        return this.renderControlsSettings();
                    default:
                        return this.renderGameplaySettings();
                }
            },

            renderGameplaySettings() {
                return `
                    <div class="settings-section active">
                        <div class="setting-group">
                            <h3>Gameplay Settings</h3>
                            <div class="setting-item">
                                <span class="setting-label">Auto-Equip Best Gear</span>
                                <div class="setting-control">
                                    <div class="toggle-switch active"></div>
                                </div>
                            </div>
                            <div class="setting-item">
                                <span class="setting-label">Show Damage Numbers</span>
                                <div class="setting-control">
                                    <div class="toggle-switch active"></div>
                                </div>
                            </div>
                            <div class="setting-item">
                                <span class="setting-label">Difficulty Level</span>
                                <div class="setting-control">
                                    <input type="range" class="slider" min="1" max="5" value="3">
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            },

            renderGraphicsSettings() {
                return `
                    <div class="settings-section active">
                        <div class="setting-group">
                            <h3>Graphics Settings</h3>
                            <div class="setting-item">
                                <span class="setting-label">Quality</span>
                                <div class="setting-control">
                                    <input type="range" class="slider" min="1" max="5" value="4">
                                </div>
                            </div>
                            <div class="setting-item">
                                <span class="setting-label">VSync</span>
                                <div class="setting-control">
                                    <div class="toggle-switch"></div>
                                </div>
                            </div>
                            <div class="setting-item">
                                <span class="setting-label">Particle Effects</span>
                                <div class="setting-control">
                                    <div class="toggle-switch active"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            },

            renderAudioSettings() {
                return `
                    <div class="settings-section active">
                        <div class="setting-group">
                            <h3>Audio Settings</h3>
                            <div class="setting-item">
                                <span class="setting-label">Master Volume</span>
                                <div class="setting-control">
                                    <input type="range" class="slider" min="0" max="100" value="75">
                                </div>
                            </div>
                            <div class="setting-item">
                                <span class="setting-label">Music Volume</span>
                                <div class="setting-control">
                                    <input type="range" class="slider" min="0" max="100" value="60">
                                </div>
                            </div>
                            <div class="setting-item">
                                <span class="setting-label">SFX Volume</span>
                                <div class="setting-control">
                                    <input type="range" class="slider" min="0" max="100" value="80">
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            },

            renderControlsSettings() {
                return `
                    <div class="settings-section active">
                        <div class="setting-group">
                            <h3>Controls Settings</h3>
                            <div class="setting-item">
                                <span class="setting-label">Keybind: Attack</span>
                                <div class="setting-control">
                                    <button class="item-action-btn" style="width: auto; padding: 6px 12px;">Space</button>
                                </div>
                            </div>
                            <div class="setting-item">
                                <span class="setting-label">Keybind: Jump</span>
                                <div class="setting-control">
                                    <button class="item-action-btn" style="width: auto; padding: 6px 12px;">W</button>
                                </div>
                            </div>
                            <div class="setting-item">
                                <span class="setting-label">Invert Mouse Y</span>
                                <div class="setting-control">
                                    <div class="toggle-switch"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            },

            renderCurrencies() {
                const strip = document.getElementById('currenciesStrip');
                if (!strip) return;
                const currencies = [
                    { icon: '💰', label: 'Gold', value: window.gameState.gold },
                    { icon: '💎', label: 'Gems', value: window.gameState.gems },
                    { icon: '🔑', label: 'Keys', value: window.gameState.keys },
                    { icon: '🎟️', label: 'Tickets', value: window.gameState.tickets }
                ];

                strip.innerHTML = currencies.map(c => `
                    <div class="currency-item">
                        <div class="currency-icon">${c.icon}</div>
                        <div class="currency-details">
                            <div class="currency-label">${c.label}</div>
                            <div class="currency-value">${c.value.toLocaleString()}</div>
                        </div>
                    </div>
                `).join('');
            },

            showToast(message) {
                const toast = document.createElement('div');
                toast.style.cssText = 'position: fixed; top: 80px; right: 20px; background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%); border: 3px solid #fff; padding: 12px 20px; border-radius: 10px; color: white; font-weight: 700; z-index: 10000; animation: toastSlideIn 0.3s ease;';
                toast.textContent = message;
                document.body.appendChild(toast);
                setTimeout(() => {
                    toast.style.animation = 'toastSlideOut 0.3s ease';
                    setTimeout(() => toast.remove(), 300);
                }, 2000);
            },

            useItem(id) {
                this.showToast(`Used item!`);
            },

            attachEventListeners() {
                // Close bag button (removed openBagBtn reference - bag opens from game button)
                const closeBtn = document.getElementById('closeBagBtn');
                if (closeBtn) {
                    closeBtn.addEventListener('click', () => this.close());
                }

                // Sub-tab navigation
                document.querySelectorAll('.hub-subtab').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const hubId = btn.closest('.hub-subtabs').id.replace('Subtabs', '');
                        const subtabId = btn.dataset.subtab;
                        this.switchSubtab(hubId, subtabId);
                    });
                });

                // Toggle switches
                document.addEventListener('click', (e) => {
                    if (e.target.classList.contains('toggle-switch')) {
                        e.target.classList.toggle('active');
                    }
                });

                // ESC key to close bag
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.isOpen) {
                        this.close();
                    }
                });
            },

            open() {
                const bagWindow = document.getElementById('bagWindow');
                if (bagWindow) {
                    bagWindow.classList.add('open');
                    this.isOpen = true;
                    this.renderTab(this.activeTab);
                    this.renderCurrencies();
                }
            },

            close() {
                const bagWindow = document.getElementById('bagWindow');
                if (bagWindow) {
                    bagWindow.classList.remove('open');
                    this.isOpen = false;
                }
            }
        };

        // Expose BagSystem globally
        window.BagSystem = BagSystem;

        // Initialize BagSystem after DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                BagSystem.init();
                // Initialize AutoSave after gameState is ready
                if (window.gameState && window.AutoSave) {
                    window.AutoSave.init();
                }
            });
        } else {
            // DOM already loaded
            BagSystem.init();
            // Initialize AutoSave after gameState is ready
            if (window.gameState && window.AutoSave) {
                window.AutoSave.init();
            }
        }

    </script>

    <!-- ═══════════════════════════════════════════════════════════════════════════ -->
    <!-- A1K BAG SYSTEM HTML - Integrated from a1 last bag/index.html -->
    <!-- ═══════════════════════════════════════════════════════════════════════════ -->
    <!-- Bag Window -->
    <div class="bag-window" id="bagWindow">
        <div class="bag-header">
            <div class="bag-title">🎒 A1K Bag System - Complete Hub</div>
            <button class="bag-close-btn" id="closeBagBtn">✕ Close</button>
        </div>

        <div class="bag-currencies">
            <div class="currencies-strip" id="currenciesStrip"></div>
        </div>

        <div class="bag-tabs-bar">
            <div class="bag-tabs-strip" id="bagTabsStrip"></div>
        </div>

        <!-- Hub Sub-tabs -->
        <div class="hub-subtabs" id="gearSubtabs">
            <button class="hub-subtab active" data-subtab="gear">Gear</button>
            <button class="hub-subtab" data-subtab="items">Items</button>
        </div>

        <div class="hub-subtabs" id="companionsSubtabs">
            <button class="hub-subtab active" data-subtab="overview">Overview</button>
            <button class="hub-subtab" data-subtab="pets">Pets</button>
            <button class="hub-subtab" data-subtab="robots">Robots</button>
            <button class="hub-subtab" data-subtab="spirits">Spirits</button>
            <button class="hub-subtab" data-subtab="vehicles">Vehicles</button>
        </div>

        <div class="hub-subtabs" id="abilitiesSubtabs">
            <button class="hub-subtab active" data-subtab="skills">Skills</button>
            <button class="hub-subtab" data-subtab="talents">Talents</button>
            <button class="hub-subtab" data-subtab="powers">Powers</button>
        </div>

        <div class="hub-subtabs" id="journalSubtabs">
            <button class="hub-subtab active" data-subtab="missions">Missions</button>
            <button class="hub-subtab" data-subtab="map">Map</button>
            <button class="hub-subtab" data-subtab="bestiary">Bestiary</button>
            <button class="hub-subtab" data-subtab="drops">Drop Tables</button>
        </div>

        <div class="hub-subtabs" id="settingsSubtabs">
            <button class="hub-subtab active" data-subtab="gameplay">Gameplay</button>
            <button class="hub-subtab" data-subtab="graphics">Graphics</button>
            <button class="hub-subtab" data-subtab="audio">Audio</button>
            <button class="hub-subtab" data-subtab="controls">Controls</button>
        </div>

        <div class="bag-content-pane" id="bagContentPane"></div>
    </div>

    <!-- Skill Selector Modal -->
    <div class="skill-selector-modal" id="skillSelectorModal">
        <div class="skill-selector-content">
            <div class="skill-selector-header">
                <div class="skill-selector-title" id="skillSelectorTitle">Select Skill for S1</div>
                <button class="skill-selector-close" onclick="BagSystem.closeSkillSelector()">✕ Close</button>
            </div>
            <div class="skill-selector-grid" id="skillSelectorGrid"></div>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div id="game-over-screen" class="hidden">
        GAME OVER
        <button onclick="location.reload()" class="restart-button">Restart</button>
    </div>

    <!-- Auto-save Indicator -->
    <div id="autosave-indicator" style="position: fixed; bottom: 20px; left: 20px; background: rgba(76, 175, 80, 0.8); color: white; padding: 8px 12px; border-radius: 4px; font-size: 12px; z-index: 9998; opacity: 0; transition: opacity 0.3s ease; pointer-events: none;">
        💾 Auto-saved
    </div>
</body>

</html>